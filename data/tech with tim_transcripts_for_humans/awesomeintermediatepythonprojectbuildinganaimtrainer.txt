With timestamps:

00:00 - in this video I'll share with you how to
00:02 - build a custom aim trainer in Python
00:03 - that you can make as easy or challenging
00:05 - as you want now this is a great project
00:07 - for anyone who's a beginner or
00:09 - intermediate python programmer just
00:11 - looking to work on something fun that
00:12 - will help you practice your skills I
00:14 - don't assume any advanced python
00:16 - knowledge in this video but I am
00:17 - assuming that you've worked with python
00:19 - before you've maybe done a project or
00:21 - two in the past and you have some idea
00:22 - about basic syntax like for Loops
00:25 - functions classes Etc regardless this is
00:28 - a great project I want to lay the intro
00:30 - anymore let's go ahead and get into it
00:32 - and I'll show you how we can build this
00:34 - aim trainer so we'll dive into building
00:35 - that project in one second but I just
00:37 - want to share with you that I do have a
00:38 - course known as programming expert which
00:40 - is for anyone looking to get better at
00:42 - programming and become a software
00:43 - engineer this course covers all kinds of
00:45 - different content but specifically
00:47 - focuses on python go and all of the
00:49 - necessary skills like software
00:51 - engineering tools that you need to land
00:53 - a job you can check that out from the
00:54 - link in the description and if you're
00:56 - interested in blockchain or web3
00:57 - development I have another course called
00:59 - blockchain expert I'll leave that link
01:01 - down below as well okay so now that I've
01:03 - gone through that let's go into a new
01:05 - file here and let's start working on
01:06 - this aim trainer but actually I'll just
01:08 - quickly demo it so we can talk about
01:09 - kind of what we need to do here so you
01:11 - can see that what I'm doing is tracking
01:12 - some different stats so I've set a
01:14 - number of lives that's essentially how
01:16 - many targets you have to miss before the
01:18 - aim trainer is going to finish and tell
01:20 - you what your stats are I've set it
01:21 - really high for the demo but typically
01:23 - we'd have this at something like three
01:24 - or five we then have stats that are
01:27 - keeping track of the number of hits you
01:28 - have the number of targets you press per
01:30 - second and the total time elapsed
01:33 - obviously we have targets that are
01:34 - appearing randomly on the screen you can
01:36 - press on them and you'll see that they
01:38 - are shrinking and kind of growing as
01:40 - they appear so they grow up to a certain
01:42 - size pause for a second and then shrink
01:44 - back down that's exactly what we're
01:46 - attempting to do okay so now that we've
01:48 - looked at that quick demo we have some
01:50 - kind of idea of what we need to build
01:51 - here let's go into a new python file
01:53 - which I'm in right now and let's start
01:55 - working on this project now for this
01:57 - project I'm going to use a module called
01:59 - Pi game now Pi game is something we need
02:01 - to install so what we're going to do
02:02 - here is go to our command line or
02:04 - terminal
02:05 - and type pip install and then Pi game
02:09 - now I already have this installed so I'm
02:10 - not going to run that command for you
02:12 - you may need to do pip 3 install Pi game
02:14 - if you're on Mac or Linux you can also
02:17 - try python hyphen M pip install Pi game
02:20 - or Python 3 hyphen M pip install Pi game
02:23 - if none of those work I'll leave two
02:24 - videos on the screen that show you how
02:26 - to install piking okay so now that we
02:28 - have Pi game installed we can start
02:30 - working it so we're just going to do a
02:31 - few Imports here Define our PI game
02:34 - window don't worry if you've never used
02:35 - Pi game before it's super
02:37 - straightforward and it's actually a
02:38 - really great thing to build some basic
02:39 - user interfaces in Python so I'll walk
02:42 - you through all the steps
02:43 - let's start by importing pygame we are
02:45 - then going to type pygame dot init which
02:48 - is going to initialize Pi game and
02:50 - initialize the fonts and some other
02:51 - things that we need I'm then going to go
02:53 - up here and before Pi game I'm going to
02:55 - import math because we're going to use
02:56 - that
02:57 - I'm going to import random we're going
02:59 - to need that as well and then I'm going
03:01 - to import time
03:04 - I think that's all we need now that
03:06 - we've done that we're going to define
03:07 - the width and the height of our window
03:08 - we're going to create a window object
03:10 - and then we're going to create what's
03:11 - known as the main Loop for our pygame
03:13 - project so we're going to say width
03:15 - comma height is equal to and then I'm
03:18 - going to go with 800 and 600. now keep
03:21 - in mind if you're on a smaller display
03:22 - you need you may need to make this a
03:24 - little bit smaller I'm on quite a large
03:26 - display so you'll see that this is kind
03:28 - of a good size but for some of you you
03:29 - may want to do 600 by 400 this is the
03:31 - number of pixels you're going to be
03:33 - using for the window okay
03:35 - so now that we have the width and the
03:37 - height I'm going to define a window
03:38 - object so I'm going to say win is equal
03:40 - to Pi game dot display dot set
03:44 - underscore mode and inside a set of
03:46 - parentheses I'm going to pass my width
03:48 - and my height now what this will do is
03:50 - initialize a pi game window and display
03:52 - that on the screen so this is going to
03:54 - pop up kind of a black window that will
03:56 - have an 800 width and a 600 height
03:58 - because we've passed that inside of the
04:00 - parentheses once we have this window we
04:03 - can then draw things onto it which we'll
04:04 - do in a minute
04:05 - so next we're going to say pygame dot
04:07 - display dot set underscore caption
04:10 - and the caption for this is simply going
04:12 - to be aim trainer now the caption is
04:14 - just the name of the window you don't
04:15 - need to set this but I like to do this
04:17 - for my projects okay so now that we've
04:20 - done that let's create what's known as
04:21 - the main Loop of our program which is
04:23 - essentially an infinite Loop that will
04:25 - check for different events so pressing
04:27 - on the screen quitting the window if a
04:29 - Target appeared or disappeared that's
04:31 - what we're going to be doing inside of
04:32 - the main Loop so we're going to say
04:33 - Define main which is our main function
04:35 - now inside of here we're essentially
04:37 - going to create a while loop that will
04:38 - run forever until we quit the window so
04:41 - we're going to say well run and we'll
04:43 - Define a variable here called run we'll
04:44 - make that equal to true and inside of
04:47 - the while loop what we're going to do is
04:49 - Loop through all the different Pi game
04:50 - events and see if the user quit the
04:53 - window now you'd think that it's already
04:55 - built in that when you press the x
04:56 - button it's going to close the window
04:57 - that's actually not the case here in pi
04:59 - game what happens when you press the x
05:01 - button is an event will be triggered and
05:03 - we then need to respond to that event
05:05 - and close the window for the user so to
05:07 - do that we're going to say four events
05:09 - in pygame.events.get
05:12 - now what this is going to do is Loop
05:14 - through all of the different events that
05:15 - are occurring so that will be kind of
05:17 - equal to the event here and then we will
05:19 - check if this event is equal to the quit
05:22 - event if it is then quits we'll say if
05:24 - event DOT type is equal to pygame dot
05:28 - quit like that then we're simply going
05:30 - to say run
05:33 - is equal to false and we're going to
05:35 - break out of this for Loop here okay so
05:37 - now what we have is a while loop that's
05:39 - going to run while this variable is true
05:41 - we then Loop through all of the
05:42 - different events that are occurring as
05:44 - we go through this while loop so at
05:45 - pretty much every millisecond or however
05:47 - fast this while loop is running we're
05:48 - looking at all the events if one of the
05:50 - events is quit then we're going to break
05:52 - the loop and get outside of it so now
05:55 - for outside of the loop we're going to
05:56 - save highgame.quit and that's going to
05:59 - quit the pi game window and close it and
06:01 - then we're going to come down here and
06:03 - we're going to say if underscore
06:04 - underscore name is equal to underscore
06:06 - unscore Main
06:07 - then run the main function now what this
06:10 - will do is just ensure that we're only
06:12 - running the main function if we're
06:14 - executing this file directly don't worry
06:16 - too much about this if you haven't seen
06:18 - it before just a nice line to add in to
06:20 - make sure if we import one of these
06:21 - functions from another file it doesn't
06:23 - cause this game to run so now let's
06:25 - quickly test this out you can see when I
06:27 - run this a window appears that says aim
06:29 - trainer which is 800 by 600 and then if
06:31 - I click on X it closes the window and
06:33 - all is good perfect that's all we needed
06:36 - for right now okay so now that we have
06:38 - our main Loop implemented what we need
06:40 - to do is start putting some Targets on
06:42 - the screen viewing those targets then
06:44 - seeing them kind of shrink and grow
06:46 - so what we're going to do is create a
06:48 - class which is going to represent our
06:49 - targets so we're going to say class
06:51 - Target like that and inside of the class
06:53 - we're going to define a few variables
06:55 - that we need for the Target remember
06:56 - it's kind of growing and shrinking so
06:59 - we're going to set a maximum size for
07:00 - the Target which is essentially the size
07:02 - at which we want to start shrinking so
07:04 - we'll grow up to the maximum size as
07:06 - soon as we hit that we'll start
07:07 - shrinking so the max size will be 30.
07:09 - you can change all these values by the
07:11 - way
07:12 - I'm then going to say the growth rate
07:15 - is equal to 0.2 now this is how many
07:18 - pixels we want to grow the target per
07:20 - frame now we'll talk about frames in one
07:22 - second but both of these values you can
07:24 - adjust and as you adjust it will make
07:26 - the aim trainer more difficult or easier
07:28 - depending on the direction you go in
07:30 - then I'm going to set the color for my
07:32 - target equal to Red you'll see why we
07:35 - want that in a second just so that we
07:36 - can kind of change the color Target
07:37 - quite easily okay next we are going to
07:41 - Define an initialization this is what's
07:43 - known as The Constructor for our Target
07:45 - inside of here I'm going to take in self
07:47 - X and Y self will refer to the Target
07:50 - itself that we are calling this
07:51 - Constructor on and X and Y will be the
07:53 - position where we want to place this
07:55 - Target on the screen so we'll kind of
07:57 - randomly generate those positions and
07:58 - then we'll store them inside of the
08:00 - target object so we'll say self.x is
08:02 - equal to X and self.y is equal to Y
08:05 - we're then going to Define two variables
08:07 - here one is self.size is equal to zero
08:11 - now the size will be the radius of the
08:13 - target it's going to start at zero and
08:15 - then we're going to increase it by this
08:17 - growth factor until it hits the maximum
08:19 - size once it hits the maximum size we'll
08:21 - start shrinking it down so then it gets
08:23 - to zero and then once that zero will
08:25 - make the target disappear from the
08:26 - screen we're also going to have an
08:28 - attribute here called grow we're going
08:31 - to start this equal to true but then we
08:33 - need to make this false as soon as we
08:34 - hit the maximum size so we start
08:36 - shrinking rather than growing great so
08:39 - now let's write a method that we can
08:40 - call to update the target size which
08:42 - we'll need to do so we're going to say
08:44 - Define update and we're going to take in
08:46 - self now what we'll do in here is we'll
08:48 - essentially check if we should be
08:50 - growing or shrinking and then adjust the
08:52 - target based on that so we know that we
08:54 - need to start shrinking the target as
08:56 - soon as the current size of the target
08:58 - is going to be greater than the maximum
09:00 - size so I say if the self.size Plus
09:04 - the self dot growth rate
09:07 - is going to be greater than or equal to
09:09 - the self.maximum size then I need to say
09:12 - self.grow
09:14 - is equal to false so as soon as I add
09:17 - this growth rate and it causes the size
09:19 - of my target to be greater than or equal
09:21 - to the maximum size I need to set grow
09:23 - equal to false okay
09:25 - then I'm going to come down here I'm
09:27 - going to say if
09:28 - self.grow so if we are growing
09:31 - then self.size plus equals the
09:34 - self.growth rate
09:36 - otherwise if we're not growing we must
09:37 - be shrinking so we'll say self.size
09:39 - minus equals the self dot growth rate
09:42 - okay so now we have a function that will
09:44 - handle sizing our Target and making it
09:46 - larger or smaller based on if we're
09:48 - growing or not
09:50 - okay now we need a function that
09:51 - actually draws the target onto the
09:53 - screen
09:55 - so we're going to say Define draw we're
09:57 - going to take in self and we're going to
09:58 - take in a window object that we want to
10:00 - draw this target onto Now The Way We
10:03 - Draw Something in pi game is different
10:05 - depending on the thing that we're
10:06 - drawing but in our case we want to draw
10:08 - a circle so we're going to say
10:10 - Pi game
10:12 - dot draw
10:14 - dot Circle
10:16 - okay now what we pass here when we're
10:18 - drawing a circle is the window we want
10:20 - to draw the circle onto the color of the
10:22 - circle and then the center position of
10:24 - the circle as well as the radius okay
10:26 - having all of those different pieces of
10:28 - information allows Pi game to put this
10:30 - on the surface so in pi game we're
10:32 - constantly dealing with surfaces this
10:34 - window here is going to be our window
10:36 - object that we've created and we're
10:37 - saying yes we want to draw this circle
10:39 - onto the window where do we want to draw
10:41 - it what color is it how big should it be
10:43 - that's what it's asking us so we're
10:45 - going to put win because that's where we
10:46 - want to draw it we're going to put
10:47 - self.color because that's the color we
10:49 - want the target to be and then we're
10:51 - going to pass a tuple that contains the
10:53 - X Y position of the center of the target
10:55 - so we're going to say self.x self.y
10:58 - that's the center of the target then
11:00 - we're going to pass the radius or the
11:01 - size of our Target so we're going to say
11:03 - self.size and when we pass self.size
11:06 - whatever the current size is well that's
11:07 - the size we'll be drawing for the radius
11:09 - of the target meaning as the size
11:11 - increases we'll be drawing a larger and
11:13 - larger circles now for now this is just
11:16 - go going to draw a red circle however if
11:18 - we want to draw kind of that Target
11:20 - style Circle where we have you know red
11:22 - white red white Etc we actually need to
11:24 - draw four circles the first one will be
11:27 - the largest Circle then we'll draw
11:28 - smaller and smaller circles that will
11:30 - overlap each other's story and cause
11:32 - this kind of ring pattern to appear
11:35 - so what I'm going to do is draw four
11:36 - circles here so I'll just kind of copy
11:38 - this down four times and what we'll do
11:40 - is we'll adjust the size so we'll say
11:41 - self.size times 0.8 now it's important
11:45 - that we do this by some kind of
11:46 - multiplication Factor so that as the
11:48 - size of our Target changes so does the
11:51 - size of all the Rings inside side of the
11:53 - target sorry I can't just say draw this
11:55 - size 20 draw the next one size 30. I
11:57 - need to do it dynamically based on what
11:59 - the current size of our Target is
12:00 - because it's going to grow and it's
12:02 - going to shrink right okay so we do
12:04 - times 0.8 then we're going to do times
12:06 - 0.6 and then times 0.4 and if you want
12:10 - the Rings to be spaced out differently
12:11 - then you can adjust these values but I
12:13 - think this will give us a nice ring
12:15 - shape for our Target now what we need to
12:17 - do is just adjust the size or set up the
12:19 - size the color of our targets so we have
12:22 - self.color here and in fact let's go and
12:24 - say we have a second color which is
12:28 - equal to White
12:29 - okay so we'll use the color variable for
12:31 - the red rings and the second color
12:34 - variable for the white rings so now I'm
12:35 - going to go here
12:36 - and change each uh kind of second target
12:39 - drawing here to be the second color so
12:43 - we have color second color color Second
12:44 - Color you can see that we're constantly
12:46 - going smaller in size so what happens is
12:48 - we draw this very large Circle then on
12:51 - top of that Circle we draw one that is a
12:53 - little bit smaller then on top of that a
12:55 - little bit smaller on top of that a
12:57 - little bit smaller and what that does is
12:59 - overlap these different circles causing
13:01 - us to have this kind of ring shape in pi
13:04 - game the order in which you draw things
13:05 - is important when you draw something
13:07 - after something else it's going to go on
13:09 - top of that object or overlap it so
13:12 - that's why we're able to accomplish this
13:13 - here with these four draws okay that's
13:16 - fantastic so now we have our Target
13:18 - we've created that and what we need to
13:19 - do is start making these targets appear
13:21 - on the screen so how are we going to do
13:23 - that well we need to go into main here
13:25 - and we need to create
13:27 - a variable called targets now this is
13:30 - where we're going to store all of the
13:31 - different targets then what we'll do is
13:33 - we'll Loop through all the targets we
13:35 - have we'll update their size and we'll
13:37 - draw them on the screen but every X
13:39 - seconds we need to kind of place a new
13:41 - Target onto the screen
13:43 - so to do this we're going to create
13:45 - what's known as a custom event now this
13:47 - event will essentially be triggered
13:49 - every 500 milliseconds or 600
13:51 - milliseconds or whatever we want we can
13:54 - then check for that event when that
13:55 - event occurs we can then make a new
13:57 - Target at a random position and add it
14:00 - inside of this array so let me show you
14:02 - how that works we're going to go to the
14:03 - top of our program and we're going to
14:05 - Define two variables here the first
14:07 - variable we're going to Define is the
14:09 - targets underscore
14:11 - increment now this is going to be equal
14:13 - to 400 milliseconds now you can change
14:16 - this if you make it uh slower or sorry
14:18 - if you make it less so like 300 200 it's
14:21 - going to be much harder if you make it
14:22 - larger it's going to be much easier
14:24 - because the targets appear later so I've
14:26 - gone with 400 milliseconds you can
14:27 - adjust that as you want
14:29 - next I'm going to say Target underscore
14:31 - event is equal to pygame dot user event
14:35 - and then I'm just going to Define
14:36 - another variable here which is the
14:38 - target underscore padding which is
14:40 - essentially how many pixels I want this
14:41 - to be off the edge of the screen we'll
14:44 - just put this here for now and then
14:45 - we'll kind of look at that in a second
14:46 - but I'll set that to be 30. okay so we
14:49 - have a custom event which is the target
14:51 - event which is a pygame.user event we
14:54 - then have the increment which is the
14:55 - number of milliseconds so we want to
14:56 - delay until we create another Target now
14:59 - that we've defined those variables we're
15:00 - going to start using them down here
15:02 - sorry I didn't mean to kind of scroll
15:03 - through that crazy so what I'm going to
15:05 - do is essentially create a timer so I'm
15:08 - going to say pygame dot time dot set
15:11 - underscore timer
15:13 - and the timer that I want to trigger is
15:15 - the target event then I'm going to put
15:18 - the target increment now what this says
15:20 - is trigger this event every Target
15:23 - increment milliseconds so we're going to
15:25 - trigger the target event every 400
15:27 - milliseconds that's what we're doing
15:28 - okay so now that we have that timer what
15:31 - we'll do is we'll go inside of our event
15:32 - Loop here and we'll listen for that
15:35 - event and when that event occurs we'll
15:37 - make the target appear on the screen so
15:39 - I'm going to say if event.type is equal
15:41 - to and now we're going to use our custom
15:43 - event which is the target event so as
15:46 - soon as I see this occurring I want to
15:47 - create a new Target to create a new
15:49 - Target I need to randomly generate an X
15:51 - and Y position for it then create the
15:53 - Target and add that to my target array
15:55 - or my target list so I'm going to say x
15:57 - is equal to random dot random integer
16:01 - and we're going to generate a random
16:03 - integer for X in the range of our Target
16:06 - padding and our width minus our Target
16:10 - padding now the reason I'm doing this is
16:12 - to ensure that my targets don't appear
16:14 - off the screen since we're drawing from
16:16 - the center position of our Target that
16:18 - means the radius of our Target will go
16:21 - to the right and it will go to the left
16:22 - so if I had a position like 10 10 so I'm
16:25 - drawing at X position 10 x position y
16:29 - but my target has a radius of 30 that
16:31 - means my target will really appear from
16:34 - kind of negative 20 here
16:37 - all the way to 30 right uh or sorry not
16:41 - 30 all the way to 40 because the radius
16:43 - is 30 so it's going to take up 30 pixels
16:46 - on each side of the X and Y coordinate
16:49 - hopefully that makes sense but if this
16:50 - is the center position then the radius
16:52 - kind of expands outwards so I need to
16:54 - make sure my Center position is such
16:56 - that when the radius is applied to my
16:58 - target it doesn't appear off the screen
17:00 - so that's why I have this target padding
17:02 - here I'm generating a random integer
17:04 - between the target padding and between
17:06 - the width minus the target padding to
17:08 - ensure the center position causes the
17:10 - target to not be off the screen now I'm
17:12 - going to do a similar thing for my y I'm
17:14 - going to say Y is equal to the random
17:17 - dot Rand int and this will be again the
17:20 - target padding and then the height
17:22 - minus the target pad okay I'm then going
17:25 - to say Target
17:26 - is equal to Target and I'm going to pass
17:29 - my X and Y so I'm initializing a new
17:31 - instance of the target class then I'm
17:34 - going to say targets.append
17:37 - Target and what this will do is now push
17:39 - this new Target object into this list so
17:42 - then we can use it and loop through it
17:43 - great so now every X seconds every 400
17:47 - milliseconds whatever we Define in the
17:49 - variable we will create a new Target
17:51 - what we need to do next is update all of
17:53 - our targets and draw them on the screen
17:55 - now what I like to do is put all of my
17:57 - drawing inside of a separate function so
17:59 - I'm going to write a new function here
18:00 - called Draw I'm going to take in a
18:02 - window object and I'm going to take in
18:04 - my targets now in pi game remember I
18:07 - told you that the order in which we draw
18:09 - things is important if we draw something
18:11 - over top of something else what that's
18:13 - going to do is overlap it so essentially
18:15 - what we need to do inside of this draw
18:16 - function is we need to clear the screen
18:18 - every single time we draw so we're going
18:21 - to wipe the entire screen clear by
18:22 - drawing swing over top of it then we're
18:25 - going to draw all of our objects and
18:27 - then we're going to update the display
18:28 - and we're going to do this every single
18:30 - frame so every frame we wipe what was on
18:32 - the screen previously then we draw onto
18:35 - it what we want to see next so it's kind
18:37 - of frame by frame rendering that's what
18:39 - we're doing here that's not how it works
18:40 - in every single system anyways what we
18:43 - do is we type win dot blit uh sorry not
18:46 - Blitz dot fill
18:48 - and then we can fill the window with a
18:50 - specific color now you can just write in
18:52 - a string the color you want so if you
18:54 - want it to be yellow you can write
18:55 - yellow if you want it blue write blue
18:57 - but if you want a more specific color
18:58 - coding like what we have then you can
19:00 - use an RGB value so what I'm going to do
19:03 - is go to the top of my program and I'm
19:04 - going to say my BG underscore color is
19:07 - equal to and then I'm going to specify
19:09 - the red green blue value that I want to
19:11 - draw so in this case it's going to be 0
19:13 - 25 and 40. now if you're not familiar
19:16 - with how RGB works this is essentially
19:18 - three values in the range of 0 to 255.
19:22 - now all three of these values tell you
19:24 - the number of red green and blues the
19:26 - first value 0 means I want to have no
19:28 - red 25 means I want 25 green and then 40
19:33 - means I want 40 blue and the maximum is
19:36 - 255. so as you kind of change these
19:38 - values you get different colors that's
19:40 - kind of how RGB Works in Python you
19:42 - define three values in a tuple and then
19:44 - you can use them inside of a function
19:46 - like this so I can pass my background
19:49 - color and now I'm going to fill the
19:51 - entire window with the background color
19:53 - next I'm going to Loop through all of my
19:55 - targets so I'm going to say four Target
19:58 - in targets then what I'm going to do is
20:00 - say Target dot draw I'm going to pass
20:04 - this window object so if we go and we
20:06 - look at the draw function here you can
20:08 - see that it accepts the window so we
20:10 - just pass the window here Loop through
20:12 - all of the targets draw them all on the
20:13 - screen lastly we type highgame dot
20:17 - display
20:18 - dot update now the display is only going
20:20 - to draw all of the things that we've
20:22 - kind of rendered up until this point
20:24 - when the update function is called so
20:26 - once we've drawn all of the targets and
20:27 - we've filled the screen in then we will
20:29 - call update and we'll draw them onto the
20:31 - screen perfect that's the draw function
20:33 - so now we need to make sure we call the
20:35 - draw function so I'm going to go inside
20:36 - of my while loop and I'm going to call
20:38 - draw and then I need to pass my window
20:40 - and my targets so I'm going to pass win
20:43 - and targets like that now we're almost
20:45 - done at least with this step what we
20:47 - need to do next is we need to make sure
20:49 - that we update all of our targets before
20:51 - we draw them so I'm going to say for
20:53 - Target
20:55 - in targets
20:57 - and I'll simply call Target dot update
21:00 - okay so now what this will do is update
21:03 - all the targets by updating them we're
21:05 - going to change their size right we're
21:06 - going to make them grow or Shrink
21:07 - depending on where they currently are in
21:09 - the animation now there's a few more
21:11 - things we need to do but for now let's
21:12 - run this and see what happens
21:15 - okay so actually I just need to fix
21:17 - something there let's run and you see
21:20 - that the targets kind of appear very
21:22 - quickly on the screen now the reason
21:24 - they're going so quickly here is we
21:26 - haven't set what's known as the frame
21:27 - rate for our window so let's fix that
21:29 - then you should see that things get a
21:31 - little bit better
21:32 - okay so how do we fix the frame rate
21:33 - well inside of this while loop here
21:35 - essentially what's going to happen right
21:37 - now is all of this stuff is just going
21:39 - to run as quickly as our computer can
21:41 - execute this while loop because it's
21:42 - kind of an infinite Loop right but what
21:44 - we can do is regulate the speed at which
21:46 - this runs by introducing a frame rate so
21:49 - to introduce a frame rate we're going to
21:51 - create a clock object we're going to say
21:52 - clock is equal
21:53 - to Pi game
21:55 - dot time dot clock
21:57 - we're then going to go inside of here
21:58 - and we're going to say clock.tick
22:01 - and we'll just put a 60 inside of here
22:03 - now 60 means I want you to run this
22:05 - while loop at 60 frames per second
22:07 - meaning that no matter what computer
22:09 - we're on as long as it can run minimum
22:11 - 60 frames per second then we're going to
22:13 - run at 60 frames here so this tick just
22:16 - regulates the speed at which this while
22:18 - loop runs which means this code should
22:20 - run at the same speed on your computer
22:21 - as it does on mine if we didn't have
22:24 - this we're running based on the
22:25 - processor speed which can vary
22:27 - drastically even just based on what
22:29 - you're doing on the computer okay so
22:30 - let's go ahead and run this now and we
22:32 - should see that now our targets are kind
22:34 - of appearing a little bit better right
22:35 - so they're growing they're shrinking yes
22:38 - some of them are overlapping that's fine
22:39 - we haven't introduced Logic for that and
22:41 - they're appearing on the screen now what
22:43 - you'll notice is if we let this code run
22:45 - for a while it will start to get slower
22:47 - and slower now the reason it's going to
22:49 - get slower and slower is because we're
22:50 - not disposing of our targets once we put
22:53 - them or sorry once we shrink them down
22:55 - to a zero size right now what happens is
22:58 - this targets list just keeps getting
22:59 - larger and larger and larger and larger
23:01 - every time this event happens what we
23:04 - actually need to do now is we need to
23:06 - make sure we remove these targets as
23:08 - soon as they have a zero size so we
23:10 - start growing them and then as soon as
23:11 - they shrink all the way down to zero
23:13 - we'll want to get rid of them so our
23:15 - computer doesn't have to handle them
23:16 - anymore
23:17 - so how do we do that well the way we do
23:19 - that is the following we're going to say
23:22 - if the target dot size is less than or
23:26 - equal to zero then we want to remove
23:29 - this target from the targets list
23:31 - so we're going to say targets dot remove
23:34 - and then Target now that's just going to
23:36 - get rid of it and take it out of this
23:38 - list meaning the next time we run this
23:40 - code we're not going to be iterating
23:41 - over it which means we won't kind of be
23:43 - doing all of these unnecessary
23:44 - operations on a Target that's currently
23:47 - invisible hopefully that makes a bit of
23:48 - sense why we're doing that but we just
23:50 - need to remove it as soon as it has a
23:51 - zero size now the reason we put this if
23:53 - statement here and not before the update
23:55 - is because we want to update it first
23:57 - which means if it currently had a size
24:00 - of zero because it starts out on zero
24:02 - size and it's growing then what will
24:03 - happen is it will get a size of 0.2 or
24:06 - 0.4 whatever the size ends up being
24:08 - meaning we don't remove it if we just
24:10 - added it inside of this array if I had
24:13 - put this if statement before then we
24:14 - would never see a Target appearing on
24:16 - the screen because as soon as it was
24:17 - added it would have a zero size and then
24:19 - we would remove it so since we're
24:20 - updating first that means if we just
24:23 - added the target it will be growing so
24:24 - it will have a larger size than zero so
24:27 - we won't we won't remove its story until
24:28 - its size shrinks back down to zero after
24:31 - it has already been displayed okay so
24:33 - let's run this now
24:35 - and you'll see that the code works the
24:36 - exact same now what happens though is as
24:38 - soon as the target reaches zero we
24:40 - remove it and we don't get any errors
24:43 - okay there we go so now our targets are
24:45 - appearing on the screen the next thing
24:47 - we should probably do is make it so we
24:49 - can press on the targets so what we need
24:51 - to do is essentially get our Mouse
24:52 - position whenever we click down see if
24:54 - that's colliding with the Target and if
24:56 - it is and we need to remove that Target
24:58 - and then increment some kind of variable
24:59 - indicating that we pressed on the target
25:02 - so how do we do that well the first
25:04 - thing that we're going to do here is
25:05 - just to find some variables related to
25:06 - kind of our analytics as we play this
25:08 - game so we're going to have a variable
25:10 - called Target pressed which is equal to
25:12 - zero we're then going to have the number
25:14 - of clicks that we've made in total which
25:16 - will be zero we then want to track our
25:18 - time so we're going to say the start
25:19 - time is equal to time dot time you can
25:23 - find the time imported all the way up
25:25 - here okay so the reason I'm doing this I
25:27 - just want to say okay when did we start
25:29 - running this code and then what I can do
25:32 - is track how much time has elapsed since
25:34 - we started and that will give us the
25:36 - total duration of the round that we're
25:38 - currently in now I also want to have
25:40 - misses now Mrs essentially means that we
25:43 - missed a Target so it popped up on the
25:44 - screen and then it disappeared as soon
25:46 - as we have a certain number of Misses
25:47 - then we're going to end the game so
25:49 - that's kind of what we're tracking here
25:50 - and I think those are the only variables
25:52 - we need right now
25:53 - okay so now we have those let's go here
25:56 - and where we have if Target size is less
25:58 - than or equal to zero what we need to do
26:00 - is increment our misses by one so Mrs
26:03 - plus equals one because as soon as the
26:04 - target is removed because the size is
26:06 - equal to zero that means we didn't press
26:08 - on the Target and it appeared and
26:10 - disappeared and we didn't see it so we
26:12 - need to increment misses whereas if we
26:14 - collide with the target when we're
26:15 - pressing our Mouse on it then that means
26:16 - it was a successful click okay so now
26:19 - what I'm going to do is I'm going to
26:20 - write a variable called click I'm going
26:23 - to make this equal to false what I'll
26:25 - now do is I'll look inside of my events
26:27 - I'll see if the user pressed the mouse
26:29 - down if they did then I want to set
26:31 - click equal to true so then we check if
26:33 - the current Mouse position has collided
26:35 - with the target so I'm going to say if
26:38 - event.type is equal to and this is going
26:41 - to be
26:42 - pygame dot event dot actually no it's
26:46 - gonna be pygame.mouse button down
26:49 - sorry that's the event there
26:51 - then we're going to say click equals
26:52 - true and we're going to say clicks plus
26:54 - equals one because we've pressed so
26:56 - we're going to increment the number of
26:57 - clicks that we have in total okay great
27:00 - so we've Now set click equal to True
27:01 - clicks plus equals one now we need to
27:03 - handle colliding with our targets now
27:06 - the way that I like to do this is just
27:07 - by writing a simple method on each of my
27:10 - targets or on my target class
27:12 - so I'm going to go here
27:13 - and say Define
27:16 - Collide and we're going to take in
27:18 - an X and Y position which will represent
27:21 - the mouse position that we want to see
27:23 - if we've collided with this circle all
27:25 - right so performing Collision for our
27:27 - circle is fairly straightforward because
27:28 - we're just looking at the center
27:30 - coordinate of our Mouse position versus
27:32 - the center coordinate of our Circle
27:35 - position so what we can do is we can
27:37 - simply take the straight line distance
27:39 - from the two points and see if that
27:42 - distance is less than or equal to the
27:44 - radius of our Circle if that's the case
27:46 - then we've pressed on the circle I don't
27:48 - really know how to explain it much more
27:49 - than that but essentially if you have
27:51 - some kind of distance between your mouse
27:53 - position and the circle and it's less
27:54 - than or equal to the radius then you're
27:56 - within the circle if it's greater than
27:57 - the radius then you are outside of the
27:59 - circle there's other ways to perform
28:00 - this Collision but this is probably the
28:02 - easiest so how do we get this well what
28:04 - we need to do is use the distance to a
28:07 - point formula and that is going to be
28:09 - the following it's going to be self.x
28:11 - minus X and then all of this is going to
28:15 - be raised to the exponent two we're then
28:18 - going to add that to the self.y minus
28:21 - the Y and we're going to raise that to
28:23 - the exponent too and we're going to take
28:25 - the square root of all of this we're
28:27 - going to say math Dot sqrt
28:29 - of all of that that's going to be the
28:31 - distance between the two points I'm
28:33 - going to double check this because it's
28:34 - been a long time since I've written this
28:35 - formula and then we are simply going to
28:38 - return if the distance is less than or
28:41 - equal to the size and this is going to
28:43 - be the self.size okay now the only thing
28:46 - you need to kind of follow when you're
28:47 - writing this formula is that whatever
28:49 - order you put the coordinates in you
28:50 - need to maintain that so in this case
28:52 - I'm using the coordinates of my circle
28:54 - first and then the coordinates of my
28:56 - mouse since I'm raising this to the
28:57 - exponent 2 it essentially gives me the
28:59 - absolute value of this first component
29:01 - then the same thing will happen here all
29:03 - I'm trying to say is I can't Swap this
29:05 - and do like y minus self.y if I wanted
29:08 - to do that I would have to swap the
29:10 - other coordinate as well and say x minus
29:12 - self.x either order works you just have
29:14 - to maintain the same order when you do
29:16 - this we'll go in this order and you'll
29:18 - see this is fine okay so now we have
29:20 - this Collide function now that we have
29:21 - that we can start using it so notice
29:23 - we've kind of tracked if we clicked here
29:24 - so if we did click then we want to check
29:27 - if we're colliding with our different
29:28 - targets so I'm going to say if click
29:32 - and then we'll say Target dot Collide
29:36 - and then we need to get our Mouse's
29:38 - position so up here I'm going to say the
29:40 - mouse underscore position is equal to Pi
29:43 - game
29:44 - dot mouse dot get underscore pause
29:48 - and then what I'll do is pass that
29:51 - position so I'm actually going to pass
29:52 - an asterisk and then the mouse pause now
29:55 - when you use an asterisk inside of a
29:57 - function argument what this will do is
29:59 - break down the Tuple into its individual
30:02 - component so that might be confusing but
30:04 - Mouse position gives us
30:06 - the x y coordinate of the mouse in pi
30:09 - game so since this is a tuple this is
30:12 - considered one object right like pause
30:14 - is equal to X1
30:15 - but you can see that inside of our
30:18 - function right we're taking X and Y
30:21 - we're not taking an a tuple that
30:24 - contains X and Y so what we need to do
30:26 - is break this Tuple into its individual
30:28 - Elements by using the asterisk so when I
30:30 - do this it essentially takes the first
30:31 - element passes that as one positional
30:33 - argument takes the second element passes
30:35 - that as another positional argument so
30:37 - it's equal or equivalent to me passing
30:39 - Mouse position zero and mouse position
30:41 - one it's just a shorthand for doing that
30:43 - okay so we're just going to use the
30:44 - asterisks this is known as the Splat
30:46 - operator
30:48 - okay so if we have clicked and we are
30:51 - colliding with this target then make it
30:52 - disappear so to make it disappear we'll
30:54 - simply remove the Target and we will
30:56 - increment the targets pressed by one
30:59 - okay so Target pressed plus equals one
31:01 - there you go that's all we need to do
31:03 - for handling our Collision so let's run
31:05 - this now
31:06 - and let's see if this works
31:08 - and we get an error what is the error
31:11 - here
31:11 - it says some issue let me just run this
31:15 - again with the terminal open for some
31:16 - reason my terminal keeps cutting off the
31:18 - errors
31:19 - uh it says int object has no attribute
31:22 - self ah y dot self okay so I can see why
31:25 - we got that error so let's go back and
31:27 - fix this I'm sure you guys probably
31:28 - caught that yourself it's not y.self
31:30 - it's self dot y
31:32 - okay so now let's run this and see what
31:35 - happens when we press the targets and
31:36 - notice that they disappear meanwhile if
31:38 - I click outside the target it doesn't
31:39 - disappear because well we weren't within
31:42 - the bounds so now we've already kind of
31:44 - got the core logic working here for
31:45 - pressing the targets what we need to do
31:47 - next is really just display some of our
31:49 - statistics and then end the game and
31:51 - we'll be finished with this tutorial all
31:53 - right so what we're going to do now is
31:54 - we're going to draw kind of a top bar
31:56 - that will contain some of the statistics
31:58 - uh for our app or for our round or game
32:01 - or whatever you want to call it
32:03 - so the way we'll do that is we'll write
32:05 - a new function here called Define draw
32:08 - top bar now to draw this top bar we're
32:11 - going to take in the window and we need
32:12 - to take in some stats right some
32:14 - information that we want to display so
32:16 - what we'll take is the
32:18 - elapsed underscore time
32:21 - we'll take the targets pressed and we'll
32:24 - take the number of Misses that you
32:25 - currently have because what we'll do is
32:27 - we'll kind of track the number of lives
32:29 - remaining until we need to end the game
32:31 - right so that's the next thing we need
32:32 - to do as well if you've missed more than
32:34 - three targets well we need to end the
32:35 - game or however many lives we Define so
32:37 - let's actually Define that up here let's
32:39 - go ahead and say lives is equal to and
32:42 - let's set our lives equal to three we
32:44 - can then just quickly write some code
32:46 - down here we can say if the misses is
32:49 - greater than or equal to the lives then
32:52 - what we will do is we'll just say pass
32:54 - but really this is where we need to end
32:57 - the game okay so if the number of Misses
32:58 - we have the number of targets we have
33:00 - impressed is greater than or equal to
33:01 - the number of lives we have then we end
33:04 - the game we also could just subtract
33:05 - from the lives but I think this is fine
33:07 - as well okay then while we're at it
33:10 - we'll just call draw top bar and we'll
33:12 - pass in the information we need so we
33:14 - need the window we need the elapsed time
33:16 - well to get the elapsed time we'll
33:18 - create a variable so we'll say lapse
33:20 - time is equal to time.time minus start
33:24 - time so remember I was telling you if we
33:26 - have access to the start time then we
33:27 - can get the amount of time that's been
33:28 - elapsed by taking the current time and
33:30 - subtracting that from the start time
33:31 - that's all it's doing gives us current
33:33 - time minus the time we started this will
33:35 - give us the number of seconds that have
33:37 - elapsed so now we'll pass the elapsed
33:40 - time variable we then will pass the
33:43 - targets pressed and then we'll pass the
33:45 - number of Misses that we had
33:48 - uh why is that kind of highlighting here
33:51 - all right not sure why that's giving us
33:53 - that weird error but regardless let's go
33:56 - here okay
33:57 - so now inside of this function we want
33:58 - to draw this top bar now this top bar is
34:00 - really just going to be a rectangle that
34:01 - has some text on it so let's draw a
34:03 - rectangle and then we'll draw the rest
34:05 - of the stuff we need so let's say pygame
34:07 - dot draw dot rect now this is how you
34:09 - draw a rectangle use rect not rectangle
34:11 - then we're going to draw this on the
34:13 - window we need to choose the color we
34:15 - want so I'll just go with gray
34:17 - and then we need to pass a rectangle
34:19 - object now a rectangle object is going
34:21 - to be the X and Y of the top left hand
34:24 - corner where we want to draw the
34:25 - rectangle and then the width and the
34:27 - height for that corresponding rectangle
34:30 - so we're going to draw this at 0 0
34:31 - because we wanted to take up the entire
34:33 - screen 0 0 by the way is going to be the
34:35 - top left hand corner of our PI game
34:38 - window
34:38 - okay so we always start at 0 0 from the
34:40 - top left then we need to pass the width
34:43 - and the height well the width of our
34:45 - rectangle is going to be the width of
34:46 - the window
34:47 - so I'll just pass width and then the
34:50 - height is going to be some defined
34:51 - height that we're actually going to put
34:52 - in a variable so we'll go here and we'll
34:55 - say top bar
34:57 - height is equal to and we'll just go
34:59 - with a height of 50. we can use whatever
35:01 - height we want but I think 50 is fine
35:04 - then I'm just going to pass my top bar
35:06 - height here and draw it there okay so
35:08 - now this will draw a rectangle onto the
35:10 - screen next what we need to do is draw a
35:13 - bunch of different kind of text objects
35:15 - on the screen that represent our
35:16 - different statistics so this is where it
35:18 - gets actually a little complicated but
35:20 - whenever we want to draw text in pi game
35:22 - we need to create a font object and then
35:24 - render an instance of that font so what
35:27 - we'll do is go to the top of our program
35:28 - and we'll set our label underscore font
35:31 - is equal to
35:34 - pygame.font.sys font and then we need to
35:36 - pass
35:37 - a font so in this case I'll go with
35:39 - Comic Sans you can pick any font you
35:41 - want that's supported by pi game but I
35:43 - just recommend going with this and then
35:45 - you choose the font size in this case I
35:47 - want to go with 24. now you can see
35:48 - there's some other kind of things you
35:50 - can do here too like you can pass if it
35:52 - is bold italic Etc in our case we'll
35:54 - just go with the standard Comic Sans of
35:56 - size 24. okay so now we need to render
36:00 - this font so the processes create the
36:02 - font object then you render an instance
36:04 - of the font then you draw that onto the
36:06 - screen so the first thing we'll draw is
36:08 - our time so we're going to say the time
36:10 - underscore label
36:12 - is equal to and this will be our label
36:15 - font dot render now what you do in the
36:18 - render is you pass a string of the text
36:20 - you want to render you pass one for
36:22 - anti-aliasing don't worry about that
36:24 - just pass one and then for the color you
36:26 - pass the color that you want it to be in
36:27 - this case we can draw it in Black now
36:30 - for the text that we want to draw here
36:32 - essentially we want to take our time
36:33 - which is in seconds and we want to
36:35 - convert it into minutes seconds and then
36:37 - milliseconds so the way I'm going to do
36:39 - that is I'm just going to write a
36:40 - function called format underscore time
36:42 - now format time is going to take in the
36:44 - number of seconds that we have and it's
36:46 - going to return to us a string that
36:48 - contains the number of milliseconds
36:49 - seconds and minutes in a nicely
36:51 - formatted kind of thing okay so we're
36:53 - going to say Milli four milliseconds is
36:55 - equal to math.floor which will round
36:57 - something down inside of here we're
37:00 - going to take the int of our seconds
37:04 - multiplied
37:05 - by 1000
37:07 - modulus
37:10 - 1000 divided by 100. now what this will
37:14 - do is just give us the number of
37:16 - milliseconds
37:17 - um that we want to be displaying okay I
37:19 - know this seems a little bit weird not
37:20 - really going to explain it too much you
37:21 - can try to kind of break it down
37:22 - yourself it just gives us the number of
37:24 - milliseconds from this seconds which
37:26 - will contain a bunch of decimal places
37:27 - then we're going to have seconds now
37:30 - seconds is going to be equal to the ins
37:33 - of the rounded seconds mod 60 and we're
37:38 - going to round this to the first decimal
37:40 - place
37:41 - okay what we're doing is we're taking
37:43 - the number of seconds we're modding it
37:44 - by 60 that'll give us the number of
37:46 - seconds that we have and then we will
37:48 - handle the number of minutes here by
37:49 - doing an integer division so I'm going
37:51 - to say minutes is equal to int and then
37:54 - this is seconds integer divided by 60.
37:56 - we need the mod here to make sure we
37:58 - don't get something like 70 seconds or
38:00 - 90 seconds because that's going to be
38:01 - handled by our minutes
38:03 - okay so now actually sorry that
38:05 - shouldn't be seconds this should be sex
38:07 - like this because we need to use the
38:09 - same value
38:10 - all right now that we have that we're
38:12 - going to return a string
38:14 - I'm going to return an F string which is
38:15 - new in Python 3. I believe seven and
38:18 - above or maybe 3.6 and above anyways
38:20 - inside of the F string you can use these
38:22 - curly braces to embed variables so I'm
38:25 - going to say minutes colon 0 to D now
38:28 - the 0 to d means I want to pad this
38:30 - number such that it always has two
38:32 - digits and if it doesn't have two digits
38:34 - start it with a zero so this will format
38:36 - it such that you get like 0 1 0 2 0 3 or
38:39 - 0 0 if we have no minutes which is kind
38:41 - of what we want then we're going to do
38:43 - seconds we're going to do the same thing
38:44 - 0 to D and this is also why I need to
38:46 - convert these into ins because this only
38:48 - works when you have an INT type as
38:49 - opposed to a float type okay so we have
38:52 - our zero two D zero two D for the
38:53 - formatting and then we will just put our
38:55 - milliseconds here
38:57 - like that which I actually already
38:58 - formatted for us and we can put that
39:00 - with a DOT we can do a DOT or we do a
39:03 - colon up to you I'm going to go with a
39:04 - done okay so format time will give us a
39:06 - nicely formatted time string so now
39:08 - inside of our label font we're going to
39:10 - put an F string
39:11 - we're going to put time colon
39:13 - then we're going to call format time
39:15 - with the elapsed time so that will give
39:18 - us the string that we want to display
39:19 - inside of here after we have time
39:22 - okay now that we have this time label we
39:24 - want to display this on the screen
39:26 - to do that I'm going to say wind.lit
39:28 - blit is how you display another surface
39:30 - in this case I want to display the time
39:32 - label surface which we've just created
39:33 - I'm going to put what I want to display
39:36 - which is time label then I'm going to
39:38 - put the x y coordinate of the top left
39:41 - hand corner of the object I want to
39:43 - display
39:44 - so I'm going to go with 5 5 which means
39:46 - the top left hand corner of this time
39:48 - label will be at 5 5 and we'll draw
39:50 - downwards and to the right from there to
39:52 - draw our text
39:54 - okay so I think that's all we need now
39:57 - uh what I'm just going to do is I'm
39:59 - going to take this
40:02 - pygame.display.update out of my draw
40:03 - function
40:05 - and I'm going to put that inside of here
40:07 - all right so I'm going to kind of put
40:09 - that down here and what's the issue here
40:11 - it says targets pressed is not defined
40:13 - did I not have that to find Targets
40:16 - pressed okay and then let's go here to
40:20 - The Click targets pressed plus equals
40:23 - one okay so I just need to fix that
40:24 - variable name apologize but that I have
40:27 - my display now outside of these two
40:29 - functions so we're displaying afterwards
40:31 - and now if we run the code we should see
40:33 - we get our time displaying up here
40:35 - nicely so notice since I drew that five
40:36 - five it's five pixels down five from the
40:38 - left
40:39 - that's kind of what we're seeing
40:41 - okay so now that we have the time we
40:43 - want to display some other information
40:44 - like the number of Misses number of
40:46 - lives Etc that we have remaining so
40:48 - let's go here and do the rest so the
40:50 - next one I want to do is the speed
40:52 - now your speed is simply equal to the
40:55 - number of targets you've pressed based
40:57 - on the current time so like the targets
40:59 - per second so the way we do that is we
41:01 - take the targets that you've pressed and
41:03 - we divide that by the elapsed time so
41:05 - I'm going to use my round function I'm
41:07 - going to take targets pressed and divide
41:09 - that by elapsed time and I'm going to
41:11 - round this to the first decimal place so
41:12 - we get something like 2.1 or 1.1 or
41:15 - something along those lines now that we
41:17 - have the speed we'll create our speed
41:18 - label
41:20 - right which can be equal to the label
41:23 - font dot render and then we can go here
41:26 - with an F string we could say speed
41:27 - colon speed and then I'll put a t slash
41:30 - S standing for targets per second I need
41:33 - to put my one for the anti-alising to be
41:35 - true and then black and then we can draw
41:37 - this on the screen so we'll take this
41:39 - paste this down here change this to our
41:41 - speed label and then we're just going to
41:43 - set the x coordinate we want to draw
41:45 - this out so I want the y coordinate to
41:46 - be the same but the X I need to space
41:48 - this out for my time label so I'll just
41:50 - set this to be 200 so it goes a bit
41:52 - further to the right now let's do the
41:53 - rest of our labels so let's copy this
41:56 - so next we'll have the hits label this
41:58 - is the number of targets that we've
41:59 - currently pressed so we'll say hits and
42:02 - this will be
42:03 - targets pressed get rid of the T slash S
42:06 - and then we'll blit that one so copy
42:09 - this and then draw the hits label rather
42:13 - than 200 this time we can go with
42:14 - something like 450
42:16 - and then lastly we need to display the
42:19 - number of lives we have remaining so
42:21 - we'll say lives label is equal to and
42:23 - then I really should just copied this so
42:25 - let's copy that there and we'll say
42:27 - lives is equal
42:29 - to the total number of lives minus the
42:32 - number of Misses that we currently have
42:34 - okay then we'll draw this one
42:36 - with the lives label and we'll draw this
42:40 - at 650.
42:42 - okay so I think that's going to be good
42:44 - for the top bar
42:45 - let's run this now and you should see
42:47 - that as we press targets we start
42:49 - updating our different stats however
42:50 - you'll notice that some of our targets
42:52 - are appearing at the top bar I'm going
42:54 - to show you how we fix that in one
42:55 - second and you can see our lives are
42:56 - subtracting kind of as we miss the
42:58 - targets okay so why are they appearing
43:00 - in the top bar well the reason they're
43:02 - appearing in the top bar is because we
43:03 - haven't padded where we want to render
43:05 - the targets based on the position of the
43:07 - top bar so what we'll need to do now is
43:10 - go
43:10 - to where we have the randomly generated
43:13 - positions and for our x coordinate we'll
43:15 - just say our Target padding plus the top
43:18 - bar height just to make sure the minimum
43:20 - y coordinate is always going to be
43:22 - beneath that top bar so now that we've
43:25 - done that if we run this we should see
43:27 - that none of our targets will be
43:28 - rendered in that top bar anymore they
43:30 - can be close to it but they're always
43:32 - going to be bordering it they'll never
43:33 - be kind of beneath it meaning we're not
43:34 - going to miss them now obviously I'm
43:36 - performing quite poorly here because
43:37 - well I'm under pressure and I'm on the
43:39 - video I'm sure you guys will be doing
43:41 - better than me okay almost done here
43:44 - last thing we need to do is simply end
43:46 - the game once the user has no more lives
43:50 - so how do we do that well to end the
43:52 - game we are simply going to call a
43:53 - function that will display the user's
43:55 - stats so very similar to drawing the top
43:57 - bar
43:58 - we're going to draw a bunch of stats
44:00 - onto the screen
44:01 - so I'm going to write another function
44:03 - called end screen now this is the last
44:06 - function we need and inside of end
44:08 - screen we're going to take when the
44:09 - elapsed time the targets underscore
44:12 - pressed
44:14 - and the number of clicks that you had so
44:16 - that we can calculate what the accuracy
44:17 - is now what we'll do in here is we'll
44:20 - essentially kind of pause the execution
44:22 - of our code and we will render something
44:24 - onto the screen that displays the stats
44:27 - and then as soon as the user presses a
44:28 - button we'll just end the game okay so
44:30 - what I'm going to do is say when
44:32 - sorry win dot blit and then we're going
44:35 - to blit the background color so that we
44:37 - clear whatever was currently on the
44:38 - screen because what I want to do is just
44:40 - have some text that appears in the
44:41 - middle of the screen so what we'll Now
44:43 - do
44:44 - is we'll copy kind of all of the text we
44:46 - had from here
44:47 - and we'll paste this in but now I only
44:49 - want to display a few things so I don't
44:51 - need to display the lives anymore I can
44:53 - display the hits
44:54 - but I also want to display the accuracy
44:57 - okay so ack you receive I don't know if
44:59 - I spelled that correctly and then I'm
45:01 - going to define the accuracy here so for
45:03 - the accuracy this is simply going to be
45:05 - equal to the number of targets we've
45:07 - pressed divided by the number of clicks
45:09 - that we had so I'm going to say round
45:12 - the targets pressed divided by the
45:15 - clicks multiplied by 100 we'll round
45:18 - that uh actually do we even need to
45:20 - round this yeah we'll round that to one
45:22 - decimal place
45:23 - okay so this is going to be the accuracy
45:24 - that we have so now we'll just change
45:26 - this text to be accuracy and then we'll
45:29 - display the accuracy and then percent
45:32 - now what I'll do is I'll take these
45:34 - different labels and I'll just render
45:36 - them in a slightly different position on
45:37 - the screen so that it is in the center
45:39 - right because here we're displaying them
45:41 - on the top bar now we want to display
45:42 - them in the middle of the screen so to
45:44 - display them in the middle screen I'll
45:45 - actually copy this
45:47 - rather than the lives label now have the
45:49 - accuracy label and we just need to
45:52 - change these here so we're rendering in
45:54 - the middle of the screen
45:55 - now the way we render in the middle of
45:56 - the screen when we're using a label is
45:58 - we need to take the middle coordinate of
46:00 - the screen okay so it's a bit difficult
46:02 - to explain this visually or without
46:05 - having a visual so let's actually go
46:06 - into paint quickly here
46:08 - let's imagine we have a screen okay if
46:10 - we want to display something in the
46:12 - middle of the screen like this the
46:14 - natural thing to do would be okay well
46:15 - let me just find kind of this middle X
46:17 - position and then start drawing here
46:19 - well that works if you have something
46:20 - like a circle where you're drawing in
46:22 - the middle of the circle but in our case
46:23 - we're drawing from the top left hand
46:24 - corner which means if we draw something
46:27 - from the middle coordinate we end up
46:28 - drawing it to the right and down so what
46:32 - we actually need to do is draw from the
46:34 - middle so let's say this is X over 2
46:36 - minus the width of the object we're
46:39 - drawing minus 2.
46:41 - or sorry now minus 2 over 2. so if you
46:43 - take the width of the object over 2
46:45 - which is this right here and you now
46:46 - move back by that
46:48 - to here
46:49 - then you start drawing the object in the
46:51 - middle of the screen hopefully that
46:53 - makes a bit of sense what I just
46:54 - explained but we're going to take the
46:56 - kind of width of the entire screen
46:58 - divide that by two then subtract that by
47:01 - the width of the object that we're
47:02 - drawing over to that will then give us
47:04 - the X position where we need to draw the
47:06 - top left hand corner such that the
47:08 - object will be in the middle
47:10 - so let's get rid of that and let's make
47:12 - a function that calculates that for us
47:13 - so we'll say Define get middle
47:16 - this is going to take in a surface
47:19 - okay and what this is going to return
47:23 - is that middle position so we're going
47:24 - to say width over 2 minus the
47:26 - surface.get underscore width
47:29 - over 2. so now we can use this function
47:32 - on our different labels to determine
47:33 - what x coordinate we should draw them at
47:35 - so we're going to say for the time label
47:38 - well we want to draw this at get middle
47:40 - of the time label then for the speed
47:44 - this is going to be get middle of the
47:47 - speed label and then for the hits this
47:50 - is going to be get middle
47:51 - of the hits label and then for the
47:53 - accuracy get middle of the accuracy
47:57 - label
47:59 - okay so that should be good and that
48:00 - should draw everything on the screen
48:02 - however what I want to do is have it so
48:04 - it kind of pauses until the user presses
48:06 - something so what I'm going to do here
48:07 - is I'm going to manually update the
48:09 - screen so pygame.display.update I'm then
48:11 - going to run a while loop in here that
48:13 - will wait for the user to press
48:14 - something once they press something it
48:16 - will then close the screen so I'm going
48:18 - to say run equals true I'm going to say
48:19 - while run I'm going to say four events
48:22 - in highgame Dot event dot get I'm going
48:27 - to say if event DOT type is equal to Pi
48:31 - game Dot and all capitals quit
48:35 - then I am simply going to say
48:37 - quit like that otherwise I'm going to
48:40 - say if event DOT type is equal
48:44 - to Pi game
48:45 - and this will be dots and we'll go with
48:49 - key down so this just means if we press
48:51 - any key down then I'm going to say run
48:53 - equals false and I will break out of
48:56 - this Loop now what this quit function
48:58 - will do is just completely quit the
49:00 - Python program for us and then what this
49:01 - will do is kind of just exit the loop
49:03 - which will then cause us to get out now
49:05 - what I could actually do is just put
49:06 - quit here as well or I can make this
49:08 - even a little bit more elegant and I
49:09 - could copy this all
49:11 - and say
49:13 - or it equals this and now we just have
49:16 - that in one line so we really just have
49:18 - this one while loop this is kind of
49:19 - running forever and just waiting for us
49:21 - to press any key or to click quit as
49:23 - soon as we do that we just close the
49:24 - window
49:25 - okay so now all we need to do is call
49:26 - this end screen function as soon as we
49:28 - kind of lose the game so we'll go here
49:31 - and rather than pass we'll call end
49:32 - screen and we'll pass this the
49:34 - information we need so we need the
49:36 - window
49:38 - what else do we need the elapsed time
49:40 - the targets pressed
49:43 - so targets pressed and the number of
49:46 - clicks
49:48 - okay
49:48 - so now we should be fully finished our
49:51 - program let's run this and make sure it
49:52 - works
49:53 - and let's just see what happens now if
49:56 - we kind of click a few of the things
49:57 - here
49:58 - and then we kind of let some of our
49:59 - Lives run out
50:01 - okay two one and we got an error let's
50:04 - see what that error is
50:07 - uh was it an error or did it just quit
50:10 - immediately
50:13 - let's see here give this a second
50:18 - okay argument one must be Pi game
50:19 - surface not Tuple uh window blit ah okay
50:24 - start with that guys let's go fix this
50:26 - now go in end screen and rather than
50:28 - wind.blit this is going to be win Dot
50:30 - fill
50:32 - so we need to fill with the background
50:33 - color not blit with it that's my bad
50:36 - let's give this another shot here click
50:38 - a few targets
50:41 - okay
50:43 - and now let's lose
50:45 - so two lives one live and it shows our
50:48 - information however it's showing it all
50:50 - on one single line that's because we
50:53 - didn't change the Y positions so let's
50:54 - make these like a hundred
50:57 - 200
50:59 - 300 and 400 and while we're at it let's
51:03 - change the color here to be white
51:05 - because black is a little bit of an
51:07 - eyesore there on the blue background so
51:09 - let's change these all to be white
51:11 - and white
51:13 - and let's run this and now let's just
51:15 - run a few targets or click a few targets
51:17 - and kind of let this lose and see if it
51:19 - displays correctly for us
51:22 - all right so there you go we got our
51:24 - time our speed our hits and our accuracy
51:26 - and we have finished this project with
51:29 - that said I'm going to wrap up the video
51:30 - here I hope you guys found this helpful
51:32 - and that this was a cool project uh that
51:34 - you're able to kind of work on you could
51:36 - show to people and that could kind of
51:37 - improve your python knowledge what I
51:39 - will be doing is including all of the
51:40 - code in the link in the description in
51:42 - case you want to download any of it or
51:43 - in case you get lost so feel free to
51:45 - check that out anyways if you enjoyed
51:46 - make sure to leave a like subscribe the
51:48 - channel and I will see you in another
51:50 - one
51:57 - thank you

Cleaned transcript:

in this video I'll share with you how to build a custom aim trainer in Python that you can make as easy or challenging as you want now this is a great project for anyone who's a beginner or intermediate python programmer just looking to work on something fun that will help you practice your skills I don't assume any advanced python knowledge in this video but I am assuming that you've worked with python before you've maybe done a project or two in the past and you have some idea about basic syntax like for Loops functions classes Etc regardless this is a great project I want to lay the intro anymore let's go ahead and get into it and I'll show you how we can build this aim trainer so we'll dive into building that project in one second but I just want to share with you that I do have a course known as programming expert which is for anyone looking to get better at programming and become a software engineer this course covers all kinds of different content but specifically focuses on python go and all of the necessary skills like software engineering tools that you need to land a job you can check that out from the link in the description and if you're interested in blockchain or web3 development I have another course called blockchain expert I'll leave that link down below as well okay so now that I've gone through that let's go into a new file here and let's start working on this aim trainer but actually I'll just quickly demo it so we can talk about kind of what we need to do here so you can see that what I'm doing is tracking some different stats so I've set a number of lives that's essentially how many targets you have to miss before the aim trainer is going to finish and tell you what your stats are I've set it really high for the demo but typically we'd have this at something like three or five we then have stats that are keeping track of the number of hits you have the number of targets you press per second and the total time elapsed obviously we have targets that are appearing randomly on the screen you can press on them and you'll see that they are shrinking and kind of growing as they appear so they grow up to a certain size pause for a second and then shrink back down that's exactly what we're attempting to do okay so now that we've looked at that quick demo we have some kind of idea of what we need to build here let's go into a new python file which I'm in right now and let's start working on this project now for this project I'm going to use a module called Pi game now Pi game is something we need to install so what we're going to do here is go to our command line or terminal and type pip install and then Pi game now I already have this installed so I'm not going to run that command for you you may need to do pip 3 install Pi game if you're on Mac or Linux you can also try python hyphen M pip install Pi game or Python 3 hyphen M pip install Pi game if none of those work I'll leave two videos on the screen that show you how to install piking okay so now that we have Pi game installed we can start working it so we're just going to do a few Imports here Define our PI game window don't worry if you've never used Pi game before it's super straightforward and it's actually a really great thing to build some basic user interfaces in Python so I'll walk you through all the steps let's start by importing pygame we are then going to type pygame dot init which is going to initialize Pi game and initialize the fonts and some other things that we need I'm then going to go up here and before Pi game I'm going to import math because we're going to use that I'm going to import random we're going to need that as well and then I'm going to import time I think that's all we need now that we've done that we're going to define the width and the height of our window we're going to create a window object and then we're going to create what's known as the main Loop for our pygame project so we're going to say width comma height is equal to and then I'm going to go with 800 and 600. now keep in mind if you're on a smaller display you need you may need to make this a little bit smaller I'm on quite a large display so you'll see that this is kind of a good size but for some of you you may want to do 600 by 400 this is the number of pixels you're going to be using for the window okay so now that we have the width and the height I'm going to define a window object so I'm going to say win is equal to Pi game dot display dot set underscore mode and inside a set of parentheses I'm going to pass my width and my height now what this will do is initialize a pi game window and display that on the screen so this is going to pop up kind of a black window that will have an 800 width and a 600 height because we've passed that inside of the parentheses once we have this window we can then draw things onto it which we'll do in a minute so next we're going to say pygame dot display dot set underscore caption and the caption for this is simply going to be aim trainer now the caption is just the name of the window you don't need to set this but I like to do this for my projects okay so now that we've done that let's create what's known as the main Loop of our program which is essentially an infinite Loop that will check for different events so pressing on the screen quitting the window if a Target appeared or disappeared that's what we're going to be doing inside of the main Loop so we're going to say Define main which is our main function now inside of here we're essentially going to create a while loop that will run forever until we quit the window so we're going to say well run and we'll Define a variable here called run we'll make that equal to true and inside of the while loop what we're going to do is Loop through all the different Pi game events and see if the user quit the window now you'd think that it's already built in that when you press the x button it's going to close the window that's actually not the case here in pi game what happens when you press the x button is an event will be triggered and we then need to respond to that event and close the window for the user so to do that we're going to say four events in pygame.events.get now what this is going to do is Loop through all of the different events that are occurring so that will be kind of equal to the event here and then we will check if this event is equal to the quit event if it is then quits we'll say if event DOT type is equal to pygame dot quit like that then we're simply going to say run is equal to false and we're going to break out of this for Loop here okay so now what we have is a while loop that's going to run while this variable is true we then Loop through all of the different events that are occurring as we go through this while loop so at pretty much every millisecond or however fast this while loop is running we're looking at all the events if one of the events is quit then we're going to break the loop and get outside of it so now for outside of the loop we're going to save highgame.quit and that's going to quit the pi game window and close it and then we're going to come down here and we're going to say if underscore underscore name is equal to underscore unscore Main then run the main function now what this will do is just ensure that we're only running the main function if we're executing this file directly don't worry too much about this if you haven't seen it before just a nice line to add in to make sure if we import one of these functions from another file it doesn't cause this game to run so now let's quickly test this out you can see when I run this a window appears that says aim trainer which is 800 by 600 and then if I click on X it closes the window and all is good perfect that's all we needed for right now okay so now that we have our main Loop implemented what we need to do is start putting some Targets on the screen viewing those targets then seeing them kind of shrink and grow so what we're going to do is create a class which is going to represent our targets so we're going to say class Target like that and inside of the class we're going to define a few variables that we need for the Target remember it's kind of growing and shrinking so we're going to set a maximum size for the Target which is essentially the size at which we want to start shrinking so we'll grow up to the maximum size as soon as we hit that we'll start shrinking so the max size will be 30. you can change all these values by the way I'm then going to say the growth rate is equal to 0.2 now this is how many pixels we want to grow the target per frame now we'll talk about frames in one second but both of these values you can adjust and as you adjust it will make the aim trainer more difficult or easier depending on the direction you go in then I'm going to set the color for my target equal to Red you'll see why we want that in a second just so that we can kind of change the color Target quite easily okay next we are going to Define an initialization this is what's known as The Constructor for our Target inside of here I'm going to take in self X and Y self will refer to the Target itself that we are calling this Constructor on and X and Y will be the position where we want to place this Target on the screen so we'll kind of randomly generate those positions and then we'll store them inside of the target object so we'll say self.x is equal to X and self.y is equal to Y we're then going to Define two variables here one is self.size is equal to zero now the size will be the radius of the target it's going to start at zero and then we're going to increase it by this growth factor until it hits the maximum size once it hits the maximum size we'll start shrinking it down so then it gets to zero and then once that zero will make the target disappear from the screen we're also going to have an attribute here called grow we're going to start this equal to true but then we need to make this false as soon as we hit the maximum size so we start shrinking rather than growing great so now let's write a method that we can call to update the target size which we'll need to do so we're going to say Define update and we're going to take in self now what we'll do in here is we'll essentially check if we should be growing or shrinking and then adjust the target based on that so we know that we need to start shrinking the target as soon as the current size of the target is going to be greater than the maximum size so I say if the self.size Plus the self dot growth rate is going to be greater than or equal to the self.maximum size then I need to say self.grow is equal to false so as soon as I add this growth rate and it causes the size of my target to be greater than or equal to the maximum size I need to set grow equal to false okay then I'm going to come down here I'm going to say if self.grow so if we are growing then self.size plus equals the self.growth rate otherwise if we're not growing we must be shrinking so we'll say self.size minus equals the self dot growth rate okay so now we have a function that will handle sizing our Target and making it larger or smaller based on if we're growing or not okay now we need a function that actually draws the target onto the screen so we're going to say Define draw we're going to take in self and we're going to take in a window object that we want to draw this target onto Now The Way We Draw Something in pi game is different depending on the thing that we're drawing but in our case we want to draw a circle so we're going to say Pi game dot draw dot Circle okay now what we pass here when we're drawing a circle is the window we want to draw the circle onto the color of the circle and then the center position of the circle as well as the radius okay having all of those different pieces of information allows Pi game to put this on the surface so in pi game we're constantly dealing with surfaces this window here is going to be our window object that we've created and we're saying yes we want to draw this circle onto the window where do we want to draw it what color is it how big should it be that's what it's asking us so we're going to put win because that's where we want to draw it we're going to put self.color because that's the color we want the target to be and then we're going to pass a tuple that contains the X Y position of the center of the target so we're going to say self.x self.y that's the center of the target then we're going to pass the radius or the size of our Target so we're going to say self.size and when we pass self.size whatever the current size is well that's the size we'll be drawing for the radius of the target meaning as the size increases we'll be drawing a larger and larger circles now for now this is just go going to draw a red circle however if we want to draw kind of that Target style Circle where we have you know red white red white Etc we actually need to draw four circles the first one will be the largest Circle then we'll draw smaller and smaller circles that will overlap each other's story and cause this kind of ring pattern to appear so what I'm going to do is draw four circles here so I'll just kind of copy this down four times and what we'll do is we'll adjust the size so we'll say self.size times 0.8 now it's important that we do this by some kind of multiplication Factor so that as the size of our Target changes so does the size of all the Rings inside side of the target sorry I can't just say draw this size 20 draw the next one size 30. I need to do it dynamically based on what the current size of our Target is because it's going to grow and it's going to shrink right okay so we do times 0.8 then we're going to do times 0.6 and then times 0.4 and if you want the Rings to be spaced out differently then you can adjust these values but I think this will give us a nice ring shape for our Target now what we need to do is just adjust the size or set up the size the color of our targets so we have self.color here and in fact let's go and say we have a second color which is equal to White okay so we'll use the color variable for the red rings and the second color variable for the white rings so now I'm going to go here and change each uh kind of second target drawing here to be the second color so we have color second color color Second Color you can see that we're constantly going smaller in size so what happens is we draw this very large Circle then on top of that Circle we draw one that is a little bit smaller then on top of that a little bit smaller on top of that a little bit smaller and what that does is overlap these different circles causing us to have this kind of ring shape in pi game the order in which you draw things is important when you draw something after something else it's going to go on top of that object or overlap it so that's why we're able to accomplish this here with these four draws okay that's fantastic so now we have our Target we've created that and what we need to do is start making these targets appear on the screen so how are we going to do that well we need to go into main here and we need to create a variable called targets now this is where we're going to store all of the different targets then what we'll do is we'll Loop through all the targets we have we'll update their size and we'll draw them on the screen but every X seconds we need to kind of place a new Target onto the screen so to do this we're going to create what's known as a custom event now this event will essentially be triggered every 500 milliseconds or 600 milliseconds or whatever we want we can then check for that event when that event occurs we can then make a new Target at a random position and add it inside of this array so let me show you how that works we're going to go to the top of our program and we're going to Define two variables here the first variable we're going to Define is the targets underscore increment now this is going to be equal to 400 milliseconds now you can change this if you make it uh slower or sorry if you make it less so like 300 200 it's going to be much harder if you make it larger it's going to be much easier because the targets appear later so I've gone with 400 milliseconds you can adjust that as you want next I'm going to say Target underscore event is equal to pygame dot user event and then I'm just going to Define another variable here which is the target underscore padding which is essentially how many pixels I want this to be off the edge of the screen we'll just put this here for now and then we'll kind of look at that in a second but I'll set that to be 30. okay so we have a custom event which is the target event which is a pygame.user event we then have the increment which is the number of milliseconds so we want to delay until we create another Target now that we've defined those variables we're going to start using them down here sorry I didn't mean to kind of scroll through that crazy so what I'm going to do is essentially create a timer so I'm going to say pygame dot time dot set underscore timer and the timer that I want to trigger is the target event then I'm going to put the target increment now what this says is trigger this event every Target increment milliseconds so we're going to trigger the target event every 400 milliseconds that's what we're doing okay so now that we have that timer what we'll do is we'll go inside of our event Loop here and we'll listen for that event and when that event occurs we'll make the target appear on the screen so I'm going to say if event.type is equal to and now we're going to use our custom event which is the target event so as soon as I see this occurring I want to create a new Target to create a new Target I need to randomly generate an X and Y position for it then create the Target and add that to my target array or my target list so I'm going to say x is equal to random dot random integer and we're going to generate a random integer for X in the range of our Target padding and our width minus our Target padding now the reason I'm doing this is to ensure that my targets don't appear off the screen since we're drawing from the center position of our Target that means the radius of our Target will go to the right and it will go to the left so if I had a position like 10 10 so I'm drawing at X position 10 x position y but my target has a radius of 30 that means my target will really appear from kind of negative 20 here all the way to 30 right uh or sorry not 30 all the way to 40 because the radius is 30 so it's going to take up 30 pixels on each side of the X and Y coordinate hopefully that makes sense but if this is the center position then the radius kind of expands outwards so I need to make sure my Center position is such that when the radius is applied to my target it doesn't appear off the screen so that's why I have this target padding here I'm generating a random integer between the target padding and between the width minus the target padding to ensure the center position causes the target to not be off the screen now I'm going to do a similar thing for my y I'm going to say Y is equal to the random dot Rand int and this will be again the target padding and then the height minus the target pad okay I'm then going to say Target is equal to Target and I'm going to pass my X and Y so I'm initializing a new instance of the target class then I'm going to say targets.append Target and what this will do is now push this new Target object into this list so then we can use it and loop through it great so now every X seconds every 400 milliseconds whatever we Define in the variable we will create a new Target what we need to do next is update all of our targets and draw them on the screen now what I like to do is put all of my drawing inside of a separate function so I'm going to write a new function here called Draw I'm going to take in a window object and I'm going to take in my targets now in pi game remember I told you that the order in which we draw things is important if we draw something over top of something else what that's going to do is overlap it so essentially what we need to do inside of this draw function is we need to clear the screen every single time we draw so we're going to wipe the entire screen clear by drawing swing over top of it then we're going to draw all of our objects and then we're going to update the display and we're going to do this every single frame so every frame we wipe what was on the screen previously then we draw onto it what we want to see next so it's kind of frame by frame rendering that's what we're doing here that's not how it works in every single system anyways what we do is we type win dot blit uh sorry not Blitz dot fill and then we can fill the window with a specific color now you can just write in a string the color you want so if you want it to be yellow you can write yellow if you want it blue write blue but if you want a more specific color coding like what we have then you can use an RGB value so what I'm going to do is go to the top of my program and I'm going to say my BG underscore color is equal to and then I'm going to specify the red green blue value that I want to draw so in this case it's going to be 0 25 and 40. now if you're not familiar with how RGB works this is essentially three values in the range of 0 to 255. now all three of these values tell you the number of red green and blues the first value 0 means I want to have no red 25 means I want 25 green and then 40 means I want 40 blue and the maximum is 255. so as you kind of change these values you get different colors that's kind of how RGB Works in Python you define three values in a tuple and then you can use them inside of a function like this so I can pass my background color and now I'm going to fill the entire window with the background color next I'm going to Loop through all of my targets so I'm going to say four Target in targets then what I'm going to do is say Target dot draw I'm going to pass this window object so if we go and we look at the draw function here you can see that it accepts the window so we just pass the window here Loop through all of the targets draw them all on the screen lastly we type highgame dot display dot update now the display is only going to draw all of the things that we've kind of rendered up until this point when the update function is called so once we've drawn all of the targets and we've filled the screen in then we will call update and we'll draw them onto the screen perfect that's the draw function so now we need to make sure we call the draw function so I'm going to go inside of my while loop and I'm going to call draw and then I need to pass my window and my targets so I'm going to pass win and targets like that now we're almost done at least with this step what we need to do next is we need to make sure that we update all of our targets before we draw them so I'm going to say for Target in targets and I'll simply call Target dot update okay so now what this will do is update all the targets by updating them we're going to change their size right we're going to make them grow or Shrink depending on where they currently are in the animation now there's a few more things we need to do but for now let's run this and see what happens okay so actually I just need to fix something there let's run and you see that the targets kind of appear very quickly on the screen now the reason they're going so quickly here is we haven't set what's known as the frame rate for our window so let's fix that then you should see that things get a little bit better okay so how do we fix the frame rate well inside of this while loop here essentially what's going to happen right now is all of this stuff is just going to run as quickly as our computer can execute this while loop because it's kind of an infinite Loop right but what we can do is regulate the speed at which this runs by introducing a frame rate so to introduce a frame rate we're going to create a clock object we're going to say clock is equal to Pi game dot time dot clock we're then going to go inside of here and we're going to say clock.tick and we'll just put a 60 inside of here now 60 means I want you to run this while loop at 60 frames per second meaning that no matter what computer we're on as long as it can run minimum 60 frames per second then we're going to run at 60 frames here so this tick just regulates the speed at which this while loop runs which means this code should run at the same speed on your computer as it does on mine if we didn't have this we're running based on the processor speed which can vary drastically even just based on what you're doing on the computer okay so let's go ahead and run this now and we should see that now our targets are kind of appearing a little bit better right so they're growing they're shrinking yes some of them are overlapping that's fine we haven't introduced Logic for that and they're appearing on the screen now what you'll notice is if we let this code run for a while it will start to get slower and slower now the reason it's going to get slower and slower is because we're not disposing of our targets once we put them or sorry once we shrink them down to a zero size right now what happens is this targets list just keeps getting larger and larger and larger and larger every time this event happens what we actually need to do now is we need to make sure we remove these targets as soon as they have a zero size so we start growing them and then as soon as they shrink all the way down to zero we'll want to get rid of them so our computer doesn't have to handle them anymore so how do we do that well the way we do that is the following we're going to say if the target dot size is less than or equal to zero then we want to remove this target from the targets list so we're going to say targets dot remove and then Target now that's just going to get rid of it and take it out of this list meaning the next time we run this code we're not going to be iterating over it which means we won't kind of be doing all of these unnecessary operations on a Target that's currently invisible hopefully that makes a bit of sense why we're doing that but we just need to remove it as soon as it has a zero size now the reason we put this if statement here and not before the update is because we want to update it first which means if it currently had a size of zero because it starts out on zero size and it's growing then what will happen is it will get a size of 0.2 or 0.4 whatever the size ends up being meaning we don't remove it if we just added it inside of this array if I had put this if statement before then we would never see a Target appearing on the screen because as soon as it was added it would have a zero size and then we would remove it so since we're updating first that means if we just added the target it will be growing so it will have a larger size than zero so we won't we won't remove its story until its size shrinks back down to zero after it has already been displayed okay so let's run this now and you'll see that the code works the exact same now what happens though is as soon as the target reaches zero we remove it and we don't get any errors okay there we go so now our targets are appearing on the screen the next thing we should probably do is make it so we can press on the targets so what we need to do is essentially get our Mouse position whenever we click down see if that's colliding with the Target and if it is and we need to remove that Target and then increment some kind of variable indicating that we pressed on the target so how do we do that well the first thing that we're going to do here is just to find some variables related to kind of our analytics as we play this game so we're going to have a variable called Target pressed which is equal to zero we're then going to have the number of clicks that we've made in total which will be zero we then want to track our time so we're going to say the start time is equal to time dot time you can find the time imported all the way up here okay so the reason I'm doing this I just want to say okay when did we start running this code and then what I can do is track how much time has elapsed since we started and that will give us the total duration of the round that we're currently in now I also want to have misses now Mrs essentially means that we missed a Target so it popped up on the screen and then it disappeared as soon as we have a certain number of Misses then we're going to end the game so that's kind of what we're tracking here and I think those are the only variables we need right now okay so now we have those let's go here and where we have if Target size is less than or equal to zero what we need to do is increment our misses by one so Mrs plus equals one because as soon as the target is removed because the size is equal to zero that means we didn't press on the Target and it appeared and disappeared and we didn't see it so we need to increment misses whereas if we collide with the target when we're pressing our Mouse on it then that means it was a successful click okay so now what I'm going to do is I'm going to write a variable called click I'm going to make this equal to false what I'll now do is I'll look inside of my events I'll see if the user pressed the mouse down if they did then I want to set click equal to true so then we check if the current Mouse position has collided with the target so I'm going to say if event.type is equal to and this is going to be pygame dot event dot actually no it's gonna be pygame.mouse button down sorry that's the event there then we're going to say click equals true and we're going to say clicks plus equals one because we've pressed so we're going to increment the number of clicks that we have in total okay great so we've Now set click equal to True clicks plus equals one now we need to handle colliding with our targets now the way that I like to do this is just by writing a simple method on each of my targets or on my target class so I'm going to go here and say Define Collide and we're going to take in an X and Y position which will represent the mouse position that we want to see if we've collided with this circle all right so performing Collision for our circle is fairly straightforward because we're just looking at the center coordinate of our Mouse position versus the center coordinate of our Circle position so what we can do is we can simply take the straight line distance from the two points and see if that distance is less than or equal to the radius of our Circle if that's the case then we've pressed on the circle I don't really know how to explain it much more than that but essentially if you have some kind of distance between your mouse position and the circle and it's less than or equal to the radius then you're within the circle if it's greater than the radius then you are outside of the circle there's other ways to perform this Collision but this is probably the easiest so how do we get this well what we need to do is use the distance to a point formula and that is going to be the following it's going to be self.x minus X and then all of this is going to be raised to the exponent two we're then going to add that to the self.y minus the Y and we're going to raise that to the exponent too and we're going to take the square root of all of this we're going to say math Dot sqrt of all of that that's going to be the distance between the two points I'm going to double check this because it's been a long time since I've written this formula and then we are simply going to return if the distance is less than or equal to the size and this is going to be the self.size okay now the only thing you need to kind of follow when you're writing this formula is that whatever order you put the coordinates in you need to maintain that so in this case I'm using the coordinates of my circle first and then the coordinates of my mouse since I'm raising this to the exponent 2 it essentially gives me the absolute value of this first component then the same thing will happen here all I'm trying to say is I can't Swap this and do like y minus self.y if I wanted to do that I would have to swap the other coordinate as well and say x minus self.x either order works you just have to maintain the same order when you do this we'll go in this order and you'll see this is fine okay so now we have this Collide function now that we have that we can start using it so notice we've kind of tracked if we clicked here so if we did click then we want to check if we're colliding with our different targets so I'm going to say if click and then we'll say Target dot Collide and then we need to get our Mouse's position so up here I'm going to say the mouse underscore position is equal to Pi game dot mouse dot get underscore pause and then what I'll do is pass that position so I'm actually going to pass an asterisk and then the mouse pause now when you use an asterisk inside of a function argument what this will do is break down the Tuple into its individual component so that might be confusing but Mouse position gives us the x y coordinate of the mouse in pi game so since this is a tuple this is considered one object right like pause is equal to X1 but you can see that inside of our function right we're taking X and Y we're not taking an a tuple that contains X and Y so what we need to do is break this Tuple into its individual Elements by using the asterisk so when I do this it essentially takes the first element passes that as one positional argument takes the second element passes that as another positional argument so it's equal or equivalent to me passing Mouse position zero and mouse position one it's just a shorthand for doing that okay so we're just going to use the asterisks this is known as the Splat operator okay so if we have clicked and we are colliding with this target then make it disappear so to make it disappear we'll simply remove the Target and we will increment the targets pressed by one okay so Target pressed plus equals one there you go that's all we need to do for handling our Collision so let's run this now and let's see if this works and we get an error what is the error here it says some issue let me just run this again with the terminal open for some reason my terminal keeps cutting off the errors uh it says int object has no attribute self ah y dot self okay so I can see why we got that error so let's go back and fix this I'm sure you guys probably caught that yourself it's not y.self it's self dot y okay so now let's run this and see what happens when we press the targets and notice that they disappear meanwhile if I click outside the target it doesn't disappear because well we weren't within the bounds so now we've already kind of got the core logic working here for pressing the targets what we need to do next is really just display some of our statistics and then end the game and we'll be finished with this tutorial all right so what we're going to do now is we're going to draw kind of a top bar that will contain some of the statistics uh for our app or for our round or game or whatever you want to call it so the way we'll do that is we'll write a new function here called Define draw top bar now to draw this top bar we're going to take in the window and we need to take in some stats right some information that we want to display so what we'll take is the elapsed underscore time we'll take the targets pressed and we'll take the number of Misses that you currently have because what we'll do is we'll kind of track the number of lives remaining until we need to end the game right so that's the next thing we need to do as well if you've missed more than three targets well we need to end the game or however many lives we Define so let's actually Define that up here let's go ahead and say lives is equal to and let's set our lives equal to three we can then just quickly write some code down here we can say if the misses is greater than or equal to the lives then what we will do is we'll just say pass but really this is where we need to end the game okay so if the number of Misses we have the number of targets we have impressed is greater than or equal to the number of lives we have then we end the game we also could just subtract from the lives but I think this is fine as well okay then while we're at it we'll just call draw top bar and we'll pass in the information we need so we need the window we need the elapsed time well to get the elapsed time we'll create a variable so we'll say lapse time is equal to time.time minus start time so remember I was telling you if we have access to the start time then we can get the amount of time that's been elapsed by taking the current time and subtracting that from the start time that's all it's doing gives us current time minus the time we started this will give us the number of seconds that have elapsed so now we'll pass the elapsed time variable we then will pass the targets pressed and then we'll pass the number of Misses that we had uh why is that kind of highlighting here all right not sure why that's giving us that weird error but regardless let's go here okay so now inside of this function we want to draw this top bar now this top bar is really just going to be a rectangle that has some text on it so let's draw a rectangle and then we'll draw the rest of the stuff we need so let's say pygame dot draw dot rect now this is how you draw a rectangle use rect not rectangle then we're going to draw this on the window we need to choose the color we want so I'll just go with gray and then we need to pass a rectangle object now a rectangle object is going to be the X and Y of the top left hand corner where we want to draw the rectangle and then the width and the height for that corresponding rectangle so we're going to draw this at 0 0 because we wanted to take up the entire screen 0 0 by the way is going to be the top left hand corner of our PI game window okay so we always start at 0 0 from the top left then we need to pass the width and the height well the width of our rectangle is going to be the width of the window so I'll just pass width and then the height is going to be some defined height that we're actually going to put in a variable so we'll go here and we'll say top bar height is equal to and we'll just go with a height of 50. we can use whatever height we want but I think 50 is fine then I'm just going to pass my top bar height here and draw it there okay so now this will draw a rectangle onto the screen next what we need to do is draw a bunch of different kind of text objects on the screen that represent our different statistics so this is where it gets actually a little complicated but whenever we want to draw text in pi game we need to create a font object and then render an instance of that font so what we'll do is go to the top of our program and we'll set our label underscore font is equal to pygame.font.sys font and then we need to pass a font so in this case I'll go with Comic Sans you can pick any font you want that's supported by pi game but I just recommend going with this and then you choose the font size in this case I want to go with 24. now you can see there's some other kind of things you can do here too like you can pass if it is bold italic Etc in our case we'll just go with the standard Comic Sans of size 24. okay so now we need to render this font so the processes create the font object then you render an instance of the font then you draw that onto the screen so the first thing we'll draw is our time so we're going to say the time underscore label is equal to and this will be our label font dot render now what you do in the render is you pass a string of the text you want to render you pass one for antialiasing don't worry about that just pass one and then for the color you pass the color that you want it to be in this case we can draw it in Black now for the text that we want to draw here essentially we want to take our time which is in seconds and we want to convert it into minutes seconds and then milliseconds so the way I'm going to do that is I'm just going to write a function called format underscore time now format time is going to take in the number of seconds that we have and it's going to return to us a string that contains the number of milliseconds seconds and minutes in a nicely formatted kind of thing okay so we're going to say Milli four milliseconds is equal to math.floor which will round something down inside of here we're going to take the int of our seconds multiplied by 1000 modulus 1000 divided by 100. now what this will do is just give us the number of milliseconds um that we want to be displaying okay I know this seems a little bit weird not really going to explain it too much you can try to kind of break it down yourself it just gives us the number of milliseconds from this seconds which will contain a bunch of decimal places then we're going to have seconds now seconds is going to be equal to the ins of the rounded seconds mod 60 and we're going to round this to the first decimal place okay what we're doing is we're taking the number of seconds we're modding it by 60 that'll give us the number of seconds that we have and then we will handle the number of minutes here by doing an integer division so I'm going to say minutes is equal to int and then this is seconds integer divided by 60. we need the mod here to make sure we don't get something like 70 seconds or 90 seconds because that's going to be handled by our minutes okay so now actually sorry that shouldn't be seconds this should be sex like this because we need to use the same value all right now that we have that we're going to return a string I'm going to return an F string which is new in Python 3. I believe seven and above or maybe 3.6 and above anyways inside of the F string you can use these curly braces to embed variables so I'm going to say minutes colon 0 to D now the 0 to d means I want to pad this number such that it always has two digits and if it doesn't have two digits start it with a zero so this will format it such that you get like 0 1 0 2 0 3 or 0 0 if we have no minutes which is kind of what we want then we're going to do seconds we're going to do the same thing 0 to D and this is also why I need to convert these into ins because this only works when you have an INT type as opposed to a float type okay so we have our zero two D zero two D for the formatting and then we will just put our milliseconds here like that which I actually already formatted for us and we can put that with a DOT we can do a DOT or we do a colon up to you I'm going to go with a done okay so format time will give us a nicely formatted time string so now inside of our label font we're going to put an F string we're going to put time colon then we're going to call format time with the elapsed time so that will give us the string that we want to display inside of here after we have time okay now that we have this time label we want to display this on the screen to do that I'm going to say wind.lit blit is how you display another surface in this case I want to display the time label surface which we've just created I'm going to put what I want to display which is time label then I'm going to put the x y coordinate of the top left hand corner of the object I want to display so I'm going to go with 5 5 which means the top left hand corner of this time label will be at 5 5 and we'll draw downwards and to the right from there to draw our text okay so I think that's all we need now uh what I'm just going to do is I'm going to take this pygame.display.update out of my draw function and I'm going to put that inside of here all right so I'm going to kind of put that down here and what's the issue here it says targets pressed is not defined did I not have that to find Targets pressed okay and then let's go here to The Click targets pressed plus equals one okay so I just need to fix that variable name apologize but that I have my display now outside of these two functions so we're displaying afterwards and now if we run the code we should see we get our time displaying up here nicely so notice since I drew that five five it's five pixels down five from the left that's kind of what we're seeing okay so now that we have the time we want to display some other information like the number of Misses number of lives Etc that we have remaining so let's go here and do the rest so the next one I want to do is the speed now your speed is simply equal to the number of targets you've pressed based on the current time so like the targets per second so the way we do that is we take the targets that you've pressed and we divide that by the elapsed time so I'm going to use my round function I'm going to take targets pressed and divide that by elapsed time and I'm going to round this to the first decimal place so we get something like 2.1 or 1.1 or something along those lines now that we have the speed we'll create our speed label right which can be equal to the label font dot render and then we can go here with an F string we could say speed colon speed and then I'll put a t slash S standing for targets per second I need to put my one for the antialising to be true and then black and then we can draw this on the screen so we'll take this paste this down here change this to our speed label and then we're just going to set the x coordinate we want to draw this out so I want the y coordinate to be the same but the X I need to space this out for my time label so I'll just set this to be 200 so it goes a bit further to the right now let's do the rest of our labels so let's copy this so next we'll have the hits label this is the number of targets that we've currently pressed so we'll say hits and this will be targets pressed get rid of the T slash S and then we'll blit that one so copy this and then draw the hits label rather than 200 this time we can go with something like 450 and then lastly we need to display the number of lives we have remaining so we'll say lives label is equal to and then I really should just copied this so let's copy that there and we'll say lives is equal to the total number of lives minus the number of Misses that we currently have okay then we'll draw this one with the lives label and we'll draw this at 650. okay so I think that's going to be good for the top bar let's run this now and you should see that as we press targets we start updating our different stats however you'll notice that some of our targets are appearing at the top bar I'm going to show you how we fix that in one second and you can see our lives are subtracting kind of as we miss the targets okay so why are they appearing in the top bar well the reason they're appearing in the top bar is because we haven't padded where we want to render the targets based on the position of the top bar so what we'll need to do now is go to where we have the randomly generated positions and for our x coordinate we'll just say our Target padding plus the top bar height just to make sure the minimum y coordinate is always going to be beneath that top bar so now that we've done that if we run this we should see that none of our targets will be rendered in that top bar anymore they can be close to it but they're always going to be bordering it they'll never be kind of beneath it meaning we're not going to miss them now obviously I'm performing quite poorly here because well I'm under pressure and I'm on the video I'm sure you guys will be doing better than me okay almost done here last thing we need to do is simply end the game once the user has no more lives so how do we do that well to end the game we are simply going to call a function that will display the user's stats so very similar to drawing the top bar we're going to draw a bunch of stats onto the screen so I'm going to write another function called end screen now this is the last function we need and inside of end screen we're going to take when the elapsed time the targets underscore pressed and the number of clicks that you had so that we can calculate what the accuracy is now what we'll do in here is we'll essentially kind of pause the execution of our code and we will render something onto the screen that displays the stats and then as soon as the user presses a button we'll just end the game okay so what I'm going to do is say when sorry win dot blit and then we're going to blit the background color so that we clear whatever was currently on the screen because what I want to do is just have some text that appears in the middle of the screen so what we'll Now do is we'll copy kind of all of the text we had from here and we'll paste this in but now I only want to display a few things so I don't need to display the lives anymore I can display the hits but I also want to display the accuracy okay so ack you receive I don't know if I spelled that correctly and then I'm going to define the accuracy here so for the accuracy this is simply going to be equal to the number of targets we've pressed divided by the number of clicks that we had so I'm going to say round the targets pressed divided by the clicks multiplied by 100 we'll round that uh actually do we even need to round this yeah we'll round that to one decimal place okay so this is going to be the accuracy that we have so now we'll just change this text to be accuracy and then we'll display the accuracy and then percent now what I'll do is I'll take these different labels and I'll just render them in a slightly different position on the screen so that it is in the center right because here we're displaying them on the top bar now we want to display them in the middle of the screen so to display them in the middle screen I'll actually copy this rather than the lives label now have the accuracy label and we just need to change these here so we're rendering in the middle of the screen now the way we render in the middle of the screen when we're using a label is we need to take the middle coordinate of the screen okay so it's a bit difficult to explain this visually or without having a visual so let's actually go into paint quickly here let's imagine we have a screen okay if we want to display something in the middle of the screen like this the natural thing to do would be okay well let me just find kind of this middle X position and then start drawing here well that works if you have something like a circle where you're drawing in the middle of the circle but in our case we're drawing from the top left hand corner which means if we draw something from the middle coordinate we end up drawing it to the right and down so what we actually need to do is draw from the middle so let's say this is X over 2 minus the width of the object we're drawing minus 2. or sorry now minus 2 over 2. so if you take the width of the object over 2 which is this right here and you now move back by that to here then you start drawing the object in the middle of the screen hopefully that makes a bit of sense what I just explained but we're going to take the kind of width of the entire screen divide that by two then subtract that by the width of the object that we're drawing over to that will then give us the X position where we need to draw the top left hand corner such that the object will be in the middle so let's get rid of that and let's make a function that calculates that for us so we'll say Define get middle this is going to take in a surface okay and what this is going to return is that middle position so we're going to say width over 2 minus the surface.get underscore width over 2. so now we can use this function on our different labels to determine what x coordinate we should draw them at so we're going to say for the time label well we want to draw this at get middle of the time label then for the speed this is going to be get middle of the speed label and then for the hits this is going to be get middle of the hits label and then for the accuracy get middle of the accuracy label okay so that should be good and that should draw everything on the screen however what I want to do is have it so it kind of pauses until the user presses something so what I'm going to do here is I'm going to manually update the screen so pygame.display.update I'm then going to run a while loop in here that will wait for the user to press something once they press something it will then close the screen so I'm going to say run equals true I'm going to say while run I'm going to say four events in highgame Dot event dot get I'm going to say if event DOT type is equal to Pi game Dot and all capitals quit then I am simply going to say quit like that otherwise I'm going to say if event DOT type is equal to Pi game and this will be dots and we'll go with key down so this just means if we press any key down then I'm going to say run equals false and I will break out of this Loop now what this quit function will do is just completely quit the Python program for us and then what this will do is kind of just exit the loop which will then cause us to get out now what I could actually do is just put quit here as well or I can make this even a little bit more elegant and I could copy this all and say or it equals this and now we just have that in one line so we really just have this one while loop this is kind of running forever and just waiting for us to press any key or to click quit as soon as we do that we just close the window okay so now all we need to do is call this end screen function as soon as we kind of lose the game so we'll go here and rather than pass we'll call end screen and we'll pass this the information we need so we need the window what else do we need the elapsed time the targets pressed so targets pressed and the number of clicks okay so now we should be fully finished our program let's run this and make sure it works and let's just see what happens now if we kind of click a few of the things here and then we kind of let some of our Lives run out okay two one and we got an error let's see what that error is uh was it an error or did it just quit immediately let's see here give this a second okay argument one must be Pi game surface not Tuple uh window blit ah okay start with that guys let's go fix this now go in end screen and rather than wind.blit this is going to be win Dot fill so we need to fill with the background color not blit with it that's my bad let's give this another shot here click a few targets okay and now let's lose so two lives one live and it shows our information however it's showing it all on one single line that's because we didn't change the Y positions so let's make these like a hundred 200 300 and 400 and while we're at it let's change the color here to be white because black is a little bit of an eyesore there on the blue background so let's change these all to be white and white and let's run this and now let's just run a few targets or click a few targets and kind of let this lose and see if it displays correctly for us all right so there you go we got our time our speed our hits and our accuracy and we have finished this project with that said I'm going to wrap up the video here I hope you guys found this helpful and that this was a cool project uh that you're able to kind of work on you could show to people and that could kind of improve your python knowledge what I will be doing is including all of the code in the link in the description in case you want to download any of it or in case you get lost so feel free to check that out anyways if you enjoyed make sure to leave a like subscribe the channel and I will see you in another one thank you
