With timestamps:

00:00 - hi we're now looking at relational and
00:01 - logical operations we look to arithmetic
00:04 - operations in our first proper video on
00:06 - Python those are folks on numbers these
00:09 - are focused on boolean values okay I've
00:11 - got to wrap it open of course you can
00:13 - use any IDE which you want to but the
00:16 - interactive show is quite useful for
00:17 - demonstrating operators because they
00:19 - usually just a very small section of a
00:21 - proper program so we've looked at as I
00:24 - say arithmetic operators which work on
00:26 - numbers these ones working more on
00:27 - boolean values so a boolean value is
00:29 - either true or false it's a data type
00:31 - just over to our force so we'd write
00:33 - true capital letters and force like that
00:36 - can set variables to boolean values may
00:38 - be something like logged in equals true
00:42 - bunch of octane you might set that
00:44 - variable to be true so you can keep
00:45 - track of the status because boolean
00:47 - values can only be one of two values
00:49 - either true or false
00:50 - we can easily map this to binary which
00:52 - is how computers work and so really true
00:55 - could be said to be one and force can be
00:58 - zero so if I try to treat plus true
00:59 - presence I get two because really true
01:02 - is representing one and so we're doing
01:04 - one plus one likewise buddy force plus
01:07 - true force is zero true as one I wish
01:10 - you get us one I think that's important
01:13 - to have in the back of your mind okay so
01:15 - first of all we have our relational
01:17 - operators also called comparison
01:20 - operators I'm writing a comment there
01:23 - with a hash suppose nothing's gonna
01:25 - happen and we have I believe six of
01:27 - these let me show you them the whole
01:28 - idea of these operators is to test
01:31 - between two bits of data so the similar
01:35 - to explaining misses just show you so
01:37 - our first one we can do if we do maybe
01:39 - five is less than seven or the less than
01:42 - sign is a relational operator it's
01:46 - comparing two bits of data called the
01:48 - operands either side of there it's
01:49 - comparing five to seven is five less
01:52 - than seven it is so this will evaluate
01:54 - to true and relational operators always
01:57 - evaluate to boolean value so either true
01:59 - or false which correspond to one or zero
02:02 - we can leave the opposite of this for
02:04 - greater than sign so is 5 greater than 7
02:07 - no it's not so I get false fat time if
02:09 - value something like 5 is less than 5 I
02:12 - should get false because 5
02:13 - is not less than five it's equal to five
02:16 - so if we want to do a more inclusive
02:18 - operation we can do five is less than or
02:20 - equal to five so the less fun equal to
02:23 - sign we can't leave a little underline
02:24 - what you might do on paper we follow it
02:26 - with an equal sign like this so this
02:29 - should be true
02:29 - conversely if I do five is greater than
02:32 - or equal to five the other way around
02:34 - this is also true so notice how the
02:36 - equal sign always comes after the lesser
02:39 - or greater than sign it's not like five
02:42 - doesn't give a nice arrow unfortunately
02:44 - like this this would be an error this
02:46 - isn't a valid construct in Python we get
02:49 - a syntax error we've broken rules by
02:51 - putting the equal sign before for
02:53 - greater than sign so there's a four of
02:55 - our relational operators down which is
02:57 - nice be able to relate to actually being
03:00 - equal to so we know we're and either to
03:02 - set a variable we set the variable for
03:04 - logging in we could do a name equals
03:07 - whatever but setting a variable right
03:11 - with the operator for setting a variable
03:13 - is just a single equal sign so if we're
03:16 - trying to say what is names we're trying
03:17 - to compare name to this random string we
03:22 - can't use the single equal sign because
03:24 - this is assigning the data to variable
03:26 - name so instead we have to use a double
03:27 - equal sign so if we do name equals
03:30 - equals just a proper name like that
03:33 - press Enter we're now comparing the
03:35 - variable name to this string which is
03:37 - false because John does not match up
03:39 - with this random string so something
03:42 - like 6 equals equals 6 would be true and
03:45 - something I 6 equals equals 7 would be
03:48 - false so it works how you'd expect it to
03:49 - and we can have variables either side we
03:52 - can have any data type we want to either
03:53 - side of this operator the opposite of is
03:55 - equals to comparison operator is not
03:57 - equal to and we do this with a
03:59 - exclamation mark before our first equal
04:02 - sign is a little bit confusing because
04:04 - like I said we can't use a single equal
04:05 - sign for a comparison but yet it's used
04:09 - in but not equals and also the greater
04:11 - than and less fine that you can equal to
04:13 - signs as well so anyway but that's what
04:15 - it is not equals we have an exclamation
04:17 - mark and equals 2 not equal 6 will give
04:21 - us false because 6 does equal 6
04:23 - whereas value 6 not equal 7 this was
04:26 - true because they are
04:27 - equal so those are our relational
04:29 - operators we'll use these a lot in
04:30 - conditions in looking at loops and also
04:33 - selection statements okay let's now look
04:35 - at our Watson say boolean but logical
04:38 - operators which are also called boolean
04:40 - operators these also evaluate to true
04:43 - and false they evaluated boolean values
04:46 - but really they are boolean because if
04:49 - you've done any logic or boolean logic
04:50 - in particular we have and or not so
04:55 - these are free operators used in boolean
04:57 - logic like I say boolean maps to binary
04:59 - which is what's used in computers and
05:01 - canoe all sorts of logic to run programs
05:04 - really using just these free operators
05:06 - unlike our relational operators these
05:09 - need to have operands need to have data
05:11 - which is boolean so I can't do something
05:13 - like not 17 press Enter when I get false
05:18 - but it's not really telling us much
05:19 - instead of been designed to be used if
05:20 - only somehow not live where it's a lower
05:22 - case and upper case or something like
05:23 - not force or not does is do the opposite
05:28 - of what we're doing service if we're
05:29 - saying not false I want to get true from
05:31 - saying not true I want to get force I
05:33 - can also use 0 and 1 so not 0 it would
05:36 - give me 1 not true but not 1 will give
05:39 - me 0 or false I can't use I'm not 5
05:42 - that's right at the top I mean it gives
05:44 - us false but it's not really working how
05:46 - it should be working we use truth tables
05:48 - to show all the values of boolean
05:50 - expressions I put the really simple
05:52 - truth table up for not now but we've
05:54 - covered it just in our code so not as an
05:56 - operator only works with one operand
05:58 - only one bit of data which should follow
06:00 - it so here 0 is the operand it follows
06:03 - it but we also have or and and which
06:06 - both work two operands either side of it
06:08 - so let's do all first of all or will
06:11 - evaluate true will return true when
06:13 - either side is true so if I do true or
06:16 - false
06:18 - and press ENTER I get true because the
06:20 - left-hand side of or is true despite the
06:23 - right-hand side being force it doesn't
06:25 - mind is still going to return true
06:26 - because one of the sides is true if I do
06:28 - false
06:30 - force or force this will be false
06:32 - because neither side is true and
06:35 - conversely true or true will be true
06:37 - because both sides are true even if only
06:39 - needs one I can for completeness we can
06:42 - put for two stable up as well witches
06:43 - this one except with exception of ugly
06:45 - false or true just for your purse it of
06:48 - the one at the top is what's the truth
06:50 - because one side is true okay let's do
06:52 - ant and is more picky because and would
06:55 - only return true if both sides are true
06:56 - so if I do true and true press Enter
07:00 - this gives me true any of a combination
07:02 - and we can put the truth table up as
07:04 - well will be false because it needs both
07:07 - sides to be true and hopefully you have
07:09 - a play around with it yourself it's
07:11 - quite easy to have errors especially
07:13 - because I instinctively always do
07:14 - capital letters for for boolean
07:17 - operators because other languages do it
07:19 - in capital letters but this it doesn't
07:20 - like this it's got to be lowercase i get
07:22 - a syntax error if I do a even one
07:24 - uppercase letter for and because these
07:27 - have two operands if I do something like
07:29 - force or without the second operand
07:32 - again it doesn't like this it needs to
07:34 - have the two operands to be able to work
07:36 - okay so this is all well and good but
07:38 - for power does come once we start to
07:40 - combine our relational and boolean
07:41 - operators and put them into conditions
07:43 - in loops and selection constructs as
07:46 - will do in future videos so let's set
07:49 - some variables to play around with let's
07:50 - do a B and C but where you can use a
07:53 - shaver so you can assign multiple
07:55 - variables on one line by using commas
07:57 - which is a little bit quicker sometimes
08:00 - let's do five seven and twelve
08:02 - press ENTER so here I could have done
08:04 - this on three different lines but I've
08:05 - set five to a servant to be and twelve
08:08 - to see like that that's a little tip if
08:11 - you want to save some space so you can
08:14 - use something like not a is less than C
08:16 - and let's see what this evaluates to so
08:18 - first of all inside the brackets will be
08:21 - evaluated first like normal maths so a
08:23 - is less than C is five less than twelve
08:26 - yes it is so this will be true but we're
08:28 - doing not true then which will be forced
08:30 - so it works like that I could do
08:33 - something like a not equals B or
08:40 - true or true and see what happens here
08:43 - so first of all let's do each side
08:44 - individually left-hand side a not equals
08:47 - B well 5 does not equal certain so this
08:49 - bit is true so actually even without
08:50 - looking at this this would be true but
08:52 - then because it's only one side needs to
08:54 - be true and all but then here true or
08:56 - true would be true as well so this one
08:58 - would be true
08:59 - but we could just look at one side to
09:01 - get that answer already we can do
09:03 - expressions with just zeros and ones of
09:05 - course we can't use any other number it
09:07 - won't really work as we expect because
09:08 - they don't map to any other number let's
09:11 - have a look at this one so we've got
09:12 - first of all left hand side not to one
09:15 - or zero let's do 1 or 0 first sort of in
09:17 - the bracket so 1 or 0 this is gonna give
09:20 - us 1 because we have one on one of the
09:22 - sides so this would be true or 1 and we
09:24 - do not true so it becomes false other
09:27 - side in fact we don't even need to look
09:29 - at the other side because if we have on
09:31 - with an and one side is false from the
09:33 - other side doesn't matter because it's
09:35 - going to evaluate false anyway we could
09:36 - check the other side just for
09:38 - completeness we've got first of all not
09:40 - one here which is 0 and then 1 and 0
09:42 - would be 0 anyway so both sides are
09:44 - force and it evaluates to false this try
09:47 - now is a little bit more about
09:48 - prediction than actually programming
09:50 - yourself so for question 1 have a look
09:52 - at these four snippets and try and
09:54 - figure out what they would evaluate to
09:55 - what they would be what votes show on
09:58 - screen if you put them into the
09:59 - interactive shell having assigned for
10:02 - free variables at the top and for
10:03 - question two have a look at this small
10:05 - program for passwords and try and figure
10:07 - out similar to question 1 really well
10:09 - the final value of this correct would be
10:11 - based on a sequence of user input of Big
10:15 - Ben Big Ben and Alice so see if you can
10:18 - figure out what would be going on if you
10:20 - ran this program

Cleaned transcript:

hi we're now looking at relational and logical operations we look to arithmetic operations in our first proper video on Python those are folks on numbers these are focused on boolean values okay I've got to wrap it open of course you can use any IDE which you want to but the interactive show is quite useful for demonstrating operators because they usually just a very small section of a proper program so we've looked at as I say arithmetic operators which work on numbers these ones working more on boolean values so a boolean value is either true or false it's a data type just over to our force so we'd write true capital letters and force like that can set variables to boolean values may be something like logged in equals true bunch of octane you might set that variable to be true so you can keep track of the status because boolean values can only be one of two values either true or false we can easily map this to binary which is how computers work and so really true could be said to be one and force can be zero so if I try to treat plus true presence I get two because really true is representing one and so we're doing one plus one likewise buddy force plus true force is zero true as one I wish you get us one I think that's important to have in the back of your mind okay so first of all we have our relational operators also called comparison operators I'm writing a comment there with a hash suppose nothing's gonna happen and we have I believe six of these let me show you them the whole idea of these operators is to test between two bits of data so the similar to explaining misses just show you so our first one we can do if we do maybe five is less than seven or the less than sign is a relational operator it's comparing two bits of data called the operands either side of there it's comparing five to seven is five less than seven it is so this will evaluate to true and relational operators always evaluate to boolean value so either true or false which correspond to one or zero we can leave the opposite of this for greater than sign so is 5 greater than 7 no it's not so I get false fat time if value something like 5 is less than 5 I should get false because 5 is not less than five it's equal to five so if we want to do a more inclusive operation we can do five is less than or equal to five so the less fun equal to sign we can't leave a little underline what you might do on paper we follow it with an equal sign like this so this should be true conversely if I do five is greater than or equal to five the other way around this is also true so notice how the equal sign always comes after the lesser or greater than sign it's not like five doesn't give a nice arrow unfortunately like this this would be an error this isn't a valid construct in Python we get a syntax error we've broken rules by putting the equal sign before for greater than sign so there's a four of our relational operators down which is nice be able to relate to actually being equal to so we know we're and either to set a variable we set the variable for logging in we could do a name equals whatever but setting a variable right with the operator for setting a variable is just a single equal sign so if we're trying to say what is names we're trying to compare name to this random string we can't use the single equal sign because this is assigning the data to variable name so instead we have to use a double equal sign so if we do name equals equals just a proper name like that press Enter we're now comparing the variable name to this string which is false because John does not match up with this random string so something like 6 equals equals 6 would be true and something I 6 equals equals 7 would be false so it works how you'd expect it to and we can have variables either side we can have any data type we want to either side of this operator the opposite of is equals to comparison operator is not equal to and we do this with a exclamation mark before our first equal sign is a little bit confusing because like I said we can't use a single equal sign for a comparison but yet it's used in but not equals and also the greater than and less fine that you can equal to signs as well so anyway but that's what it is not equals we have an exclamation mark and equals 2 not equal 6 will give us false because 6 does equal 6 whereas value 6 not equal 7 this was true because they are equal so those are our relational operators we'll use these a lot in conditions in looking at loops and also selection statements okay let's now look at our Watson say boolean but logical operators which are also called boolean operators these also evaluate to true and false they evaluated boolean values but really they are boolean because if you've done any logic or boolean logic in particular we have and or not so these are free operators used in boolean logic like I say boolean maps to binary which is what's used in computers and canoe all sorts of logic to run programs really using just these free operators unlike our relational operators these need to have operands need to have data which is boolean so I can't do something like not 17 press Enter when I get false but it's not really telling us much instead of been designed to be used if only somehow not live where it's a lower case and upper case or something like not force or not does is do the opposite of what we're doing service if we're saying not false I want to get true from saying not true I want to get force I can also use 0 and 1 so not 0 it would give me 1 not true but not 1 will give me 0 or false I can't use I'm not 5 that's right at the top I mean it gives us false but it's not really working how it should be working we use truth tables to show all the values of boolean expressions I put the really simple truth table up for not now but we've covered it just in our code so not as an operator only works with one operand only one bit of data which should follow it so here 0 is the operand it follows it but we also have or and and which both work two operands either side of it so let's do all first of all or will evaluate true will return true when either side is true so if I do true or false and press ENTER I get true because the lefthand side of or is true despite the righthand side being force it doesn't mind is still going to return true because one of the sides is true if I do false force or force this will be false because neither side is true and conversely true or true will be true because both sides are true even if only needs one I can for completeness we can put for two stable up as well witches this one except with exception of ugly false or true just for your purse it of the one at the top is what's the truth because one side is true okay let's do ant and is more picky because and would only return true if both sides are true so if I do true and true press Enter this gives me true any of a combination and we can put the truth table up as well will be false because it needs both sides to be true and hopefully you have a play around with it yourself it's quite easy to have errors especially because I instinctively always do capital letters for for boolean operators because other languages do it in capital letters but this it doesn't like this it's got to be lowercase i get a syntax error if I do a even one uppercase letter for and because these have two operands if I do something like force or without the second operand again it doesn't like this it needs to have the two operands to be able to work okay so this is all well and good but for power does come once we start to combine our relational and boolean operators and put them into conditions in loops and selection constructs as will do in future videos so let's set some variables to play around with let's do a B and C but where you can use a shaver so you can assign multiple variables on one line by using commas which is a little bit quicker sometimes let's do five seven and twelve press ENTER so here I could have done this on three different lines but I've set five to a servant to be and twelve to see like that that's a little tip if you want to save some space so you can use something like not a is less than C and let's see what this evaluates to so first of all inside the brackets will be evaluated first like normal maths so a is less than C is five less than twelve yes it is so this will be true but we're doing not true then which will be forced so it works like that I could do something like a not equals B or true or true and see what happens here so first of all let's do each side individually lefthand side a not equals B well 5 does not equal certain so this bit is true so actually even without looking at this this would be true but then because it's only one side needs to be true and all but then here true or true would be true as well so this one would be true but we could just look at one side to get that answer already we can do expressions with just zeros and ones of course we can't use any other number it won't really work as we expect because they don't map to any other number let's have a look at this one so we've got first of all left hand side not to one or zero let's do 1 or 0 first sort of in the bracket so 1 or 0 this is gonna give us 1 because we have one on one of the sides so this would be true or 1 and we do not true so it becomes false other side in fact we don't even need to look at the other side because if we have on with an and one side is false from the other side doesn't matter because it's going to evaluate false anyway we could check the other side just for completeness we've got first of all not one here which is 0 and then 1 and 0 would be 0 anyway so both sides are force and it evaluates to false this try now is a little bit more about prediction than actually programming yourself so for question 1 have a look at these four snippets and try and figure out what they would evaluate to what they would be what votes show on screen if you put them into the interactive shell having assigned for free variables at the top and for question two have a look at this small program for passwords and try and figure out similar to question 1 really well the final value of this correct would be based on a sequence of user input of Big Ben Big Ben and Alice so see if you can figure out what would be going on if you ran this program
