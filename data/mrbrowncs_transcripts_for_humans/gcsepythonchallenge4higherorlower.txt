With timestamps:

00:00 - hi in our fourth python challenge we're
00:02 - going to be creating a basic
00:04 - guessing game which i'm calling higher
00:06 - or lower i say i'm calling it really um
00:08 - i'm sure this is a fairly well-known
00:10 - sort of task to do programming although
00:12 - i've put a slight spin on it
00:13 - so it's not quite the same as usual
00:15 - however you will need to
00:17 - before you do this task have understood
00:19 - how to define functions and
00:21 - including with parameters and having
00:22 - return values and also
00:24 - this whole guessing game is sort of
00:25 - predicated on you being able to generate
00:28 - some random numbers within her range so
00:30 - there are two videos
00:32 - in my tutorial playlist which will
00:34 - hopefully carve over content you need to
00:35 - know for this task
00:37 - so to explain how my version of this
00:40 - game should work
00:41 - let me go through some information here
00:42 - which i'll replicate in the description
00:44 - box in case you'd rather just sit and
00:45 - read it
00:46 - as opposed to looking at it on the video
00:48 - section so
00:49 - the whole point here is a guessing game
00:51 - with the computer
00:53 - so first of all the user is going to
00:55 - think of a number in between a range
00:57 - which they can choose so the user might
00:59 - decide that they want for range to be
01:01 - between 1 and 100 and so the user might
01:05 - think of a number
01:06 - 31 or 100 so it can include the upper or
01:09 - lower range
01:10 - so once for users force of this number
01:12 - the computer is going to make a random
01:14 - guess
01:15 - of this number in the range so if a
01:17 - range needs to be actually inputted
01:19 - the number they're thinking of doesn't
01:20 - need to be inputted and once this guess
01:22 - has been shown to the user
01:23 - the user will see if this number is
01:25 - correct and if it is correct from the
01:27 - user is going to input correct
01:28 - and the round will end and once for
01:31 - round does n the number of guesses made
01:33 - by the computer
01:34 - which i'm going to call the score will
01:36 - be printed out so if the user
01:38 - so if a computer guess is wrong first of
01:40 - all but guess is correctly on my second
01:42 - occasion
01:42 - then the score will be two if it takes
01:44 - five guesses the score will be five
01:46 - so until the user deems the input
01:50 - correct
01:51 - however if the computer isn't correct
01:53 - then the user is going to either type in
01:55 - h lowercase uppercase for higher and l
01:58 - uppercase lowercase for lower to give
02:01 - the computer a clue
02:02 - so if i'll type in higher if the number
02:06 - should be higher if i guess was too low
02:07 - i would type in lower if their guess was
02:09 - too high
02:10 - and the computer can use this clue to
02:13 - make another guess within the new
02:14 - interval so the fact that
02:16 - if the user is telling the computer
02:18 - their previous guess was too high or too
02:20 - low
02:20 - means that you can then alter your guess
02:22 - in the next
02:24 - guess to make it more accurate and so
02:26 - this process of
02:28 - guessing getting some feedback guessing
02:30 - get some feedback will continue as a
02:32 - loop
02:32 - until the number is correctly guessed
02:35 - here are some success criteria to
02:36 - hopefully help you
02:37 - get guided towards a good solution here
02:40 - so you should be defining a function
02:41 - called game which has two parameters
02:43 - which i'm calling upper and lower and it
02:45 - should return the value
02:47 - held in a variable called score these
02:49 - parameter values which is what you call
02:51 - the arguments
02:52 - are going to come from user input so
02:54 - initially in your main routine
02:56 - you're going to ask the user for the
02:58 - upper bound and the lower bound
03:00 - and those values will get passed in as
03:02 - parameters to this function
03:05 - and inside the function you need to
03:06 - generate a random integer which will be
03:08 - generated including and between the
03:11 - upper and lower bounds
03:12 - and that value generated is the
03:14 - computer's guess so the value generator
03:16 - can include the upper
03:18 - bound and the lower bound as well so the
03:21 - user should be able to respond to this
03:22 - guess with either correct
03:24 - or higher or lower and when the computer
03:27 - is correct the function will return to
03:28 - the main routine with the score
03:30 - which can be shown to the user but when
03:32 - the commute is not correct
03:33 - the score is going to increment which
03:35 - means just add one
03:36 - and based on the upper and lower
03:39 - response that bound will get updated
03:41 - accordingly
03:41 - for the next guess so think about how
03:43 - you can use if you use telling you it's
03:45 - too high or too low
03:46 - to update the next guess so this task is
03:48 - not easy by any means lots of people
03:50 - have tried
03:51 - this and not everyone has managed to do
03:53 - it in my experience at least first try
03:55 - once you can do it it's not too hard but
03:57 - if you are finding it easy you want to
03:58 - push yourself even more
04:00 - here are some extensions to try so first
04:03 - of all allow
04:04 - the game to have multiple rounds so so
04:06 - far we've only really allowed it to have
04:07 - one round
04:08 - you you know the computer's guessing it
04:10 - gets it correct
04:11 - and the game ends but here we can allow
04:13 - multiple rounds and it only ends when
04:15 - the user
04:15 - decides to quit so when the user does
04:18 - decide to quit
04:18 - the scores from all of the rounds
04:20 - previously should be printed out so
04:22 - in round one vertical might be five in
04:24 - round two the score might be eight
04:26 - and so on and so on and a second
04:27 - possible extension task of course you
04:29 - can think of your own ones if you want
04:30 - to
04:31 - this one is in italics because i'm not
04:33 - going to show you how to do it
04:34 - because this really works in a very
04:35 - similar way except we're doing it in the
04:37 - opposite way
04:38 - so you need to create a second function
04:40 - which works in the opposite way
04:42 - so this time the computer will think of
04:44 - a number or i say think loosely the
04:45 - computer will generate a number
04:47 - and the user guesses and the computer
04:49 - tells the user is too high or too low
04:51 - and then the game can alternate between
04:53 - the different modes and the winner is
04:54 - the one for lowest score
04:56 - of the two modes so initially you could
04:58 - have
04:59 - the user guessing and then you could
05:00 - have computer guessing and going back
05:02 - and forth
05:03 - and the winner is one with the lowest
05:04 - score out of the two okay and before you
05:06 - have a go yourself here is a quick demo
05:08 - because i know there's been a lot of
05:09 - information so far
05:10 - the first thing you'd see is something
05:11 - like this welcome to the game and then
05:13 - you are asked to enter a lower range
05:15 - so let's do one entry an upper range
05:18 - let's do 50 here
05:20 - so now i'm told to think for a number
05:21 - between 1 and 50. let's do
05:23 - 28 i guess it's 44
05:27 - so i type in l for lower and i guess
05:29 - it's 30
05:30 - so it's close again i type in l because
05:33 - 17 i now type in h
05:35 - i guess 24 it's higher than 24. it's 125
05:38 - higher than 27 and finally it guesses 28
05:41 - so i can type in c for correct
05:43 - press enter and then it kind of
05:45 - completes and says the score is seven
05:48 - so if you were doing the first extension
05:49 - task now you would give the opportunity
05:51 - for the user to quit
05:53 - otherwise have another round and if
05:55 - you're doing a second extension task you
05:57 - can now launch into
05:58 - the user guessing and the computer
06:00 - generating the number and then going
06:02 - back to back
06:02 - like that so pause have a look at our of
06:06 - the requirements again
06:07 - and have a go with yourself and now i'll
06:09 - show you the solution to the main part
06:11 - of this problem
06:13 - okay so the first thing i want to do is
06:15 - define my function which i said was
06:17 - going to be called game
06:18 - and has two parameters the first one
06:20 - being upper
06:21 - and then lower uh if the actual order
06:23 - those two doesn't matter it seems more
06:24 - logical to have lower before upper but
06:26 - anyway and then we're going to have some
06:28 - code down here right
06:30 - and then i'm going to return score and
06:33 - so we can
06:34 - first of all sort of score as a variable
06:37 - and so we need to actually have a value
06:39 - in that variable which of course we're
06:41 - going to change as we go through but we
06:42 - can initialize it to be zero
06:44 - so we can make sure it's always
06:46 - available to be returned in the end
06:49 - and below our definition we can have our
06:53 - sort of main
06:54 - our main program our main routine which
06:55 - is going to call our function
06:58 - and so we're going to call it by saying
07:00 - its name
07:01 - game and we're going to supply some
07:02 - arguments and these arguments are going
07:04 - to come
07:04 - from the user and so
07:08 - let's just for the time being call them
07:10 - up and lower again
07:13 - and because it's returning a value
07:14 - returning score which is an integer
07:16 - we're going to
07:17 - also assign this to be a variable so we
07:20 - are calling our function the function at
07:22 - the top executes
07:23 - and returns a value and the value is
07:25 - stored under score so we've got the same
07:27 - names here which is okay
07:28 - but it may cause some confusion but i
07:30 - think it's probably okay here
07:32 - so in our main we want to well first of
07:34 - all to welcome the user to the game that
07:35 - seems nice
07:38 - and then we're going to ask the user to
07:40 - input the lower range
07:42 - lower and the upper range upper and
07:46 - we can also just we'll validate these
07:49 - maybe later
07:50 - so um our upper value is going to be
07:53 - going to say input
08:02 - and we'll do the same for lower as well
08:09 - so we'll um we'll make sure these have
08:13 - added later because we'll have to
08:14 - because we are expecting these to be
08:16 - integers as like a
08:18 - upper and lower range we can cast these
08:22 - down here but it's wrapping those
08:25 - variables in
08:26 - the int casting function making sure
08:28 - i've got enough brackets
08:29 - there now the issue is if i if
08:33 - i run this into your range if i type in
08:36 - hello
08:36 - we're going to immediately get errors
08:38 - once i do her range as well
08:41 - because we're trying to convert a string
08:43 - into integer so let me
08:44 - i said i was going to do this validation
08:45 - later but let me do it now so
08:47 - um what we can do and i haven't talked
08:49 - with in the tutorials but i have
08:51 - done it in a couple of
08:52 - challenges i believe is do something
08:54 - like well
08:55 - while upper is
08:58 - digit equals equals false
09:01 - because what is digit what method is
09:03 - digit does is checks to see if your
09:05 - value
09:06 - is an integer and if it isn't an integer
09:10 - it's going to give us false i mean
09:11 - really it's a positive integer which is
09:13 - also fine here because we can't have
09:15 - we don't really want a lower range i
09:16 - don't think
09:18 - so um and also we need also well evo
09:22 - if either one is not a digit
09:25 - we're going to get him to ask to enter a
09:27 - game so we need
09:28 - or here not and because it was false
09:32 - and then we're going to get them to put
09:34 - them in again so if they can't proceed
09:36 - we can't do that casting in line 17
09:38 - until
09:39 - we make sure it's in the right data type
09:42 - so we could just add a message here
09:43 - saying
09:44 - something like is must
09:48 - be positive integers
09:52 - okay all right so that's all of our main
09:53 - program done for now if we do the
09:55 - extension
09:56 - later i'll show you how to we'll build
09:58 - up this a little bit but now the key bit
10:00 - here is inside our function
10:02 - so we need to actually have our game
10:04 - running in this function
10:05 - assuming this code works i should
10:06 - probably check it first i always
10:08 - i'll always move on without checking it
10:11 - okay
10:11 - perfect so um we are going to
10:16 - really this whole this whole game works
10:20 - by repeating repeating so i should say
10:24 - you know
10:25 - probably here print think
10:28 - of a number between and
10:32 - lower and
10:36 - upper now of course this game is relying
10:38 - on the user you know honestly
10:40 - um thinking of one and keeping in my
10:42 - mind if they forget it will be a bit of
10:43 - an issue
10:45 - but now we're going to make a guess and
10:47 - keep asking
10:48 - until the user says it's correct and so
10:51 - we need a while loop for this a for loop
10:53 - is where we have we sort of know how
10:54 - many times it's going to iterate
10:56 - here we don't know exactly it depends on
10:59 - what number of a user
11:00 - thinks of it depends how big this range
11:02 - is and so on so
11:04 - a while loop is more suitable we have a
11:06 - condition the condition being
11:08 - is it correct or not you know we could
11:11 - have a condition like is it correct or
11:12 - not but i think it's easier to have just
11:14 - a boolean toggle
11:16 - i use these a lot in while loops i don't
11:18 - know how brilliant
11:20 - design from a design point of view using
11:22 - them are but i think they're fine
11:24 - so while it's corrected was false and
11:26 - we're going to keep looping until
11:27 - view says it's correct and then we're
11:29 - going to set is correct to be true
11:31 - and it will envelope so we need to make
11:34 - sure we
11:34 - first of all um
11:38 - initialize is correct to be false and
11:40 - you can see down below i should
11:41 - have done two equal signs not one equal
11:43 - sign there one equal sign is for
11:45 - assigning a value two is for comparison
11:48 - so inside this while loop is where the
11:50 - main body of our code will go
11:52 - so first of all we need to make a guess
11:54 - so let's make a guess
11:56 - and this is going to be to make a a
11:59 - random guess
12:00 - unless you want to code it yourself
12:02 - which would be impossible if not
12:04 - well not possible it would be extremely
12:05 - difficult if not impossible
12:07 - um for some people we would need to
12:09 - import
12:10 - a random module so the random module is
12:13 - a whole bunch of different functions
12:15 - methods really which provide random
12:17 - functionality
12:18 - and they're not they're not available by
12:21 - default so i have to
12:22 - import from as a module but now we can
12:25 - use them
12:26 - so after guess i'm going to
12:30 - use a random keyword and then now i can
12:32 - do dot and the function we want here to
12:35 - generate integers in around in a range
12:38 - is randint
12:39 - which can take two arguments at least
12:40 - for lower range which is going to be
12:42 - lower here
12:43 - followed by the upper range which is
12:44 - upper and once we make this guess
12:46 - we're going to increment the score which
12:48 - i haven't actually had
12:50 - assigned yet and i have up here i forgot
12:52 - because we've made a guess we're going
12:54 - to increase the score so in this game
12:55 - a higher score is worse for the person
12:58 - guessing
12:59 - because um you want it to be lower as
13:01 - possible
13:03 - uh okay so um
13:06 - we now need to see
13:09 - if this guess is correct so we
13:13 - first wanted to show the user this guest
13:14 - right so we could do print
13:16 - um i guess guess
13:20 - and we could make it a bit prettier by
13:22 - adding a full stop maybe after this
13:24 - and because we're using concatenation on
13:26 - an integer and a string
13:28 - we need to make sure we cast guess to be
13:30 - a string as well
13:32 - i guess whatever it is full stop um
13:35 - then we could do um
13:38 - is this correct
13:42 - or should it be higher
13:45 - or lower okay
13:48 - and then we need to actually oh we need
13:51 - to get the input first of all so we
13:52 - could do
13:53 - um response equals input
13:56 - like that and now it's probably a good
13:57 - idea to sort of standardize our input
14:00 - by making it all lower case all
14:02 - uppercase depending on well it doesn't
14:03 - matter either way
14:04 - just to reduce the number of conditions
14:06 - we have it's best to try and make things
14:08 - as generic as possible
14:09 - you shouldn't need someone to enter a
14:11 - lowercase h
14:12 - or an uppercase h you know it shouldn't
14:15 - really matter
14:16 - so um we're now in an if statement to
14:18 - see if this response
14:20 - equals equals uh correct
14:23 - or um so that will never be true because
14:26 - i'm just made lowercase
14:28 - so correct lowercase or response
14:31 - equals equals just a like a c like that
14:36 - okay so if it is correct the most
14:37 - important thing to do here because i
14:38 - used this sort of boolean toggle
14:40 - is to then toggle it so that it is now
14:43 - true otherwise we'll be stuck in this
14:44 - loop
14:45 - forever and then we can
14:48 - uh i don't know something like print yes
14:51 - because i got it right the score
14:55 - is and ever the score is like that
14:59 - okay so that is really simple when it is
15:01 - correct it's not quite
15:02 - simple when it's not correct so we'll
15:05 - need an e-lift here because they're um
15:07 - not um because they're two different
15:10 - conditions so elev response is this time
15:13 - let's do if the response is higher
15:16 - or the response is just h on its own i
15:19 - do h on its own to make it quicker when
15:21 - i'm testing it
15:22 - and here we now need to think more
15:24 - carefully about how we can
15:26 - edit our sort of guess
15:29 - to be uh to be more clever right because
15:31 - we could
15:32 - we could have been told it's higher just
15:34 - guess another random invert original
15:36 - range but here we can now adapt our
15:37 - range
15:38 - to make it a bit smarter it works in a
15:39 - similar way to in a similar way to
15:42 - binary search if you come across that my
15:44 - indentation was off
15:46 - off there a little bit so um if if a
15:48 - response
15:49 - if we are taught so if we make a guess
15:51 - and and we are told
15:52 - it needs to be higher that means we can
15:55 - edit our lower bound
15:56 - because in fact if i just test this up
15:58 - until this point
16:00 - to maybe demonstrate how this works
16:02 - because i think it's
16:03 - fairly obvious but it might be worth
16:05 - demonstrating so if i put
16:06 - my upper range is um 10
16:10 - and lower range is one
16:13 - i guess 10 so we get so let's say we're
16:15 - thinking of 5
16:17 - but if i now say lower it's just going
16:20 - to guess again because we haven't coded
16:22 - this yet
16:23 - but if i guess lower then it can exclude
16:26 - 10 right now the range should be one to
16:27 - nine
16:28 - so we um that's for lower but if it's
16:32 - higher so let's say actually we're
16:33 - getting eight
16:34 - and it's guess seven well now the range
16:36 - should be eight to ten or eight to nine
16:37 - really
16:38 - because we have altered um autodown
16:41 - range
16:42 - and so really if i just uncomment this
16:44 - code
16:45 - lower should now be our current guess
16:48 - plus one like i had a go explaining if
16:51 - we are guessing seven
16:52 - and our value is eight we know then if
16:55 - it's if the value is too low
16:57 - because they've said higher we should
16:58 - plus one onto it and the same idea
17:01 - with when it's um lower
17:06 - blower or l
17:12 - we're going to set the upper range to be
17:14 - the guess
17:16 - minus one because
17:19 - you know up here i guess 10 if our
17:22 - number is
17:23 - eight and we say it's lower well then
17:25 - now the range has got to be between one
17:26 - and nine it's not going to include 10.
17:28 - so we can reduce a range like that and
17:30 - it will massively even if our
17:32 - starting range is huge massively cut
17:34 - down based on this
17:36 - so um that is the main sort of premise
17:39 - of our code
17:40 - and in fact our main kind of solution to
17:43 - our base requirements we could test this
17:45 - a couple of times
17:46 - now i've added in my code so upper range
17:49 - let's say 10 i should have really put
17:50 - myself way around
17:52 - so let's say i'm thinking of four so i
17:54 - guess nine well it's lower
17:56 - i get seven again it's still lower i
17:58 - guess two is higher i guess six
18:01 - uh i said four there's a wish you could
18:03 - forget this and lower
18:04 - and then higher again and we finally end
18:06 - up before that managed to get
18:08 - all of it all of them wrong there i
18:09 - panic for a second now i can type in
18:11 - correct
18:12 - and it should end so so the score is
18:14 - seven because it guessed seven times
18:16 - all right let's test that again because
18:18 - that confused me for some reason i've
18:19 - added uh two lines here
18:21 - to actually show us our range each time
18:23 - so hopefully should show us
18:25 - it updating let's not do up a range of
18:27 - 100
18:28 - no that's not 100 it's too much let's
18:30 - just do 10 again for lack of originality
18:33 - so let's think of a number of five let's
18:35 - guess five straight away let's do number
18:36 - two
18:37 - this is correct no it should be lower uh
18:39 - and now i guess there's two actually
18:41 - it's done really well here but you can
18:42 - see
18:43 - uh it has updated our range so when i
18:45 - say it's five
18:46 - and then it's lower um it has gone one
18:49 - to four
18:50 - let's just do this one more time that's
18:52 - when we do a range
18:53 - of 15 to 5 and let's think of a number
18:57 - 12
18:57 - guess is 11 so it should be higher okay
19:00 - this is
19:01 - um then i guess 15
19:05 - lower and now it's guess 12. so you can
19:07 - see
19:08 - this time when it's updating uh based on
19:10 - it being lower
19:12 - it's also working or based on it being
19:13 - higher it's still working as we want it
19:15 - to
19:16 - because our range has gone to 12. okay
19:19 - so our main code is working
19:21 - let's now look at some issues we have
19:24 - with it right so if i now
19:25 - sort of don't really play ball and
19:28 - deliberately
19:29 - i've deliberately or by mistake of
19:31 - course some issues if i type in hello
19:33 - that's fixed because we did that earlier
19:36 - um
19:37 - but if i do uh 15 to 25
19:40 - this time if i
19:44 - let's say so it's guess 29 let's say i
19:46 - was thinking of 29 but it kind of ignore
19:48 - that and just pretend it's lower
19:49 - i could you know potentially keep
19:52 - pressing in
19:53 - lower until we get an issue here it says
19:55 - the new range of 25 to 24
19:57 - well how how is it going to generate
19:59 - random number in that range
20:01 - because our low a lower value is higher
20:03 - than our upper value
20:05 - and so you know you could the user not
20:07 - really doing it properly
20:08 - could lead to an error like this and it
20:10 - would cause your program to break
20:11 - so we can do is make sure before we are
20:15 - allowing this random function to
20:17 - generate our numbers because that's what
20:18 - the issue is here if you look at the
20:19 - bottom
20:20 - empty range for round range is coming
20:23 - from
20:23 - our random function here and so we need
20:26 - to kind of protect
20:27 - this function by checking to see if
20:29 - there are any issues before we actually
20:31 - use it
20:31 - so we can do is sort of wrap it in
20:35 - and or not even wrap it in an if because
20:38 - what we can do is we can do if
20:40 - let's say upper equals equals lower
20:44 - well that's an issue first of all in
20:46 - fact we could even just do upper
20:48 - is less than or equal to um
20:51 - lower because first of all they
20:54 - shouldn't be equal we shouldn't really
20:55 - ever have them being equal
20:56 - or certainly in fact no that's not true
20:59 - they can be equal they can be equal if
21:01 - you've guessed all the opportunities
21:02 - but if they become a situation where
21:04 - upper is
21:05 - bigger than lower or sorry upper is
21:08 - smaller than lower
21:09 - that means something's gone wrong here
21:11 - you can see here
21:12 - the upper value is smaller than the
21:15 - lower value
21:16 - which doesn't make sense so we need to
21:18 - if we have this case
21:19 - there's been some issue we could say
21:21 - something like uh i think
21:23 - you have made a mistake
21:26 - and so not only much we can do here i
21:29 - think we need to
21:30 - just get us out of this loop asap
21:33 - so we could set this to be true unless
21:35 - maybe we want to reset the score
21:36 - because otherwise you know the score
21:38 - isn't really valid
21:41 - a bit if we don't have that issue that's
21:44 - fine we can proceed as normal with an
21:45 - else
21:46 - and we can just make sure all of our
21:47 - code down here is now nested within this
21:49 - house
21:50 - apart from return because return is the
21:51 - last thing we're doing
21:53 - so hopefully that's all nested across
21:57 - so fingers crossed this code allows us
21:58 - to check for any issues like this
22:00 - like where we uh to kind of deliberately
22:02 - get it wrong
22:04 - let's have a look and see so
22:07 - let's reset that not sure what's
22:08 - happened there
22:11 - okay let's do a smaller range this time
22:12 - so let's do five and then lower range is
22:14 - one
22:15 - so finger numbers in one and five let's
22:17 - say so it's guessed three straight away
22:18 - let's say i was thinking of three
22:20 - so if it's correct or should it be
22:22 - higher or lower um
22:23 - let's just do lower and you wanted to
22:25 - let's do lower again
22:27 - and i think you made a mistake and we
22:28 - end okay that's good
22:30 - i think we can now comment out our sort
22:32 - of uh new ranges one to two
22:35 - because it's now confusing me a couple
22:37 - of times so where is it down here
22:39 - so i think that is mostly us done except
22:42 - for
22:43 - maybe one other issue is if i just do
22:46 - this again quickly
22:48 - now if i type something other than h or
22:49 - l or c
22:51 - if i type in high here um
22:54 - it's going to keep guessing which is
22:57 - maybe okay
22:58 - actually no i think about it because the
23:01 - score is going up and it's sort of your
23:02 - fault you haven't done it right maybe we
23:04 - could show a message right we could just
23:05 - say
23:06 - um down here else in all of the cases
23:09 - print you must enter
23:12 - h l or c
23:16 - and then it's going to guess again so
23:17 - actually maybe guessing again it's not
23:18 - really a big problem you could
23:20 - sort of wrap this whole code in another
23:23 - while loop
23:24 - to make sure they are entering hlrc and
23:26 - if they're not asking them again because
23:28 - right now it's just going to increase
23:29 - for guesses but
23:30 - i feel like that's kind of okay at this
23:33 - point
23:34 - all right so i think that's our our main
23:36 - code done unless i'm missing something
23:38 - which is possible
23:39 - in terms of our extension which is where
23:41 - we wanted to have multiple rounds
23:43 - like right now if i get it correct the
23:45 - game ends and that's it
23:47 - but actually you may want it to be so
23:49 - that
23:50 - we may want it to be so that we have
23:53 - multiple rounds and so the user can keep
23:55 - going afterwards
23:56 - and this is ultimately why we are using
23:58 - a function right for good format
23:59 - functions is
24:00 - not only are they quite provide a nice
24:02 - clean interface with parameters and
24:04 - return values but
24:05 - we can call our function however many
24:08 - times we want
24:09 - and it will all be absolutely fine we
24:11 - don't have to repeat loads of code if we
24:13 - wanted say five rounds
24:15 - without a function we need to repeat
24:16 - this code five times and it would be
24:18 - really annoying but also if we wanted
24:20 - say an infinite number of rounds
24:22 - we can't copy code infinitely and again
24:25 - having a function
24:26 - makes it a lot cleaner we need another
24:28 - loop so down here at the bottom
24:30 - uh i might i'm gonna quickly edit my
24:32 - upper and lower here because i was
24:33 - irritating me a bit
24:35 - so what we could do before this welcome
24:37 - to the game we could have another while
24:39 - loop and again let's just use a boolean
24:41 - toggle here so while
24:42 - has quit equals equals false
24:46 - again i need to make sure actually uh
24:48 - initialize this just outside so it has
24:50 - quit
24:50 - it's going to initially be initially be
24:52 - false one equal sign there
24:54 - again let's just shift all of this code
24:56 - inside my while loop for the time being
24:59 - because this is our main game um we
25:02 - could
25:03 - now before we
25:07 - uh we could just print
25:12 - for rounds and then
25:15 - and then the number so we could use a
25:16 - counter at the top
25:18 - so round and number could be zero
25:22 - initially
25:23 - don't need to do this but i figure it
25:24 - might make it look a bit nicer
25:26 - around num so at least we know what's
25:28 - going on here maybe we just
25:30 - add a new line to make it a little bit
25:32 - more separate
25:34 - and then we're doing this code as normal
25:36 - is all fine
25:37 - and once we finish the game in this case
25:39 - we're gonna increment the round number
25:41 - so you can keep track of it and then
25:42 - give the user the opportunity to quit
25:44 - right so if we
25:46 - you could say you know quit quitting
25:49 - equals input uh
25:52 - do you want to quit yes
25:56 - or no and then like we did before if
25:59 - quitting like with our yes or no with
26:01 - our higher or lower if quitting equals
26:03 - equals
26:04 - um y
26:07 - we are going to um make sure it's a
26:09 - lowercase
26:11 - we're going to make sure we set has quit
26:14 - what is quitting i should has called it
26:16 - is quitting to be true and we could say
26:19 - thank you for playing right so one of my
26:20 - conditions was
26:22 - we print out the scores thank you for
26:24 - playing
26:25 - uh the scores work now how are we going
26:28 - to print out our scores here because
26:29 - what we've done here so far we've just
26:31 - saved the score so we've called our
26:34 - function we go through the whole
26:35 - rigmarole of our game playing
26:37 - we end it by saying it's correct the
26:39 - value gets saved underscore
26:41 - but you know the whole point here is
26:43 - when we are quitting
26:44 - we want to print out all the scores and
26:46 - right now only one score is being
26:47 - printed at a time
26:49 - which is not really what we want because
26:51 - we can go through five rounds
26:53 - but every single round is just saving
26:55 - any value underscore
26:56 - the previous values are lost so if we
26:59 - you know we could
27:00 - if we were going about over the top like
27:02 - save our save our scores in a file
27:05 - like a text file which a future video
27:06 - will show how to do that
27:08 - feature tutorial but we could also just
27:12 - have a list a list is really nice
27:13 - because i like a variable a variable can
27:15 - only
27:16 - hold one bit of data at a time their
27:18 - list can hold loads of bits of data
27:21 - and you can add on to it right so you
27:22 - you know you don't have the opportunity
27:24 - to um create variables at runtime but
27:28 - list you can just append values to lists
27:31 - whenever you want to
27:32 - so if we just have a list maybe here
27:34 - called scores
27:35 - which we can initialize to be an empty
27:37 - list because nothing's happened yet
27:39 - and now instead of assigning our score
27:44 - our return score to our values to our
27:46 - variable score we can now
27:48 - make sure we are appending uh this
27:51 - to what i call it scores so scores
27:54 - dot append append means just add in um
27:58 - a value to it at the end of the list
28:01 - like so
28:02 - okay and then once we are ready to quit
28:04 - we can then iterate through
28:06 - this scores list which could have one
28:09 - value in it it could have
28:10 - 500 values in it and just print them out
28:12 - as we go
28:13 - okay i think it would be nice to down
28:15 - here use our round numbers
28:17 - in our in our um printing so we can use
28:20 - a for loop here instead of
28:22 - well we're gonna use a for loop anyway
28:23 - instead of saying something like four
28:25 - item
28:25 - in scores or four scoring scores we
28:27 - could say
28:29 - a round num in range
28:33 - zero going up to the length of scores
28:39 - and then we are going to print so round
28:43 - in round round num
28:46 - or maybe our code on there is a bit
28:48 - premature in round
28:50 - say one and then we might want to colon
28:52 - here
28:54 - which means i need to cast this round
28:57 - num and in fact because
28:59 - we start counting our indexes from zero
29:01 - round one will be zero here so in around
29:03 - zero
29:04 - it will be whatever which doesn't really
29:06 - make sense we might wanna hit we might
29:07 - want to
29:08 - do round one plus one here so it starts
29:10 - counting at one and then we can print
29:12 - the score
29:14 - but we need to use our use our list
29:17 - which is scores and index it with ground
29:20 - none in this case okay
29:24 - so hopefully that works how we want it
29:27 - to let's try this
29:29 - i may have made an error here about
29:31 - noticing so welcome to the game round
29:33 - zero
29:34 - so okay right so we need to make sure we
29:37 - around zero seems a bit strange so we
29:39 - could make sure we
29:40 - uh initialize it to be one not zero okay
29:42 - try again
29:44 - from one into a lower range let's do one
29:46 - upper range ten
29:47 - let's say i'm thinking of six so it
29:49 - needs to do lower
29:51 - let's um higher lower again
29:54 - five higher and now it's correct lovely
29:57 - so if score is five in that case do you
29:59 - do i want to quit let's say no
30:02 - uh round two lovely enter low range do
30:04 - one
30:05 - and ten this time uh let's just say
30:08 - again and let's now think of one so
30:11 - eleven seven
30:12 - lower than six eleven five and then it's
30:15 - got one
30:17 - and now let's quit now i've done two
30:19 - rounds i could keep going
30:20 - infinitely but hopefully thank you for
30:22 - playing with scores where
30:23 - round one was five round two was four
30:27 - except now it's uh asked us again i'm
30:29 - not sure why let's see why it's asking
30:31 - us again
30:33 - because i used for wrong the wrong
30:36 - variable here it was has correct i knew
30:38 - it was
30:38 - okay so right now we got stuck in the
30:41 - infinite while loop down here
30:43 - in our has quit loop because i never
30:46 - changed has quit i was changing is
30:47 - quitting which is not the same variable
30:49 - okay
30:49 - but i think the point remains right you
30:51 - can see we could keep playing infinitely
30:53 - we're adding new values to our scores
30:55 - list
30:55 - which is a nice way of keeping track of
30:56 - it and in the end we can
30:59 - um print them out just by iterating
31:01 - through our
31:02 - list so um that is pretty much
31:07 - the solution i believe well done if you
31:09 - have tried it
31:10 - and managed to do most of it if you can
31:11 - do all of it it's fine
31:13 - there's another extension task which i
31:14 - won't show you how to do in terms of
31:16 - actually kind of flipping this having a
31:17 - second function
31:18 - and getting it to now be um the computer
31:21 - generates a round number and you have to
31:22 - guess it
31:23 - so it kind of flips on its head and then
31:24 - you could sort of do a back to back game
31:26 - where round one might be for computer
31:28 - guessing round two might be the user
31:29 - guessing
31:30 - and it works like that i'll leave you to
31:32 - come up with your own solution for that
31:33 - if you have one
31:34 - feel free to share it i'd be interested
31:36 - in seeing it otherwise
31:37 - let me know any questions this solution
31:39 - will be in the description for you to
31:41 - have a look at if you want to
31:42 - otherwise thank you very much for
31:44 - watching

Cleaned transcript:

hi in our fourth python challenge we're going to be creating a basic guessing game which i'm calling higher or lower i say i'm calling it really um i'm sure this is a fairly wellknown sort of task to do programming although i've put a slight spin on it so it's not quite the same as usual however you will need to before you do this task have understood how to define functions and including with parameters and having return values and also this whole guessing game is sort of predicated on you being able to generate some random numbers within her range so there are two videos in my tutorial playlist which will hopefully carve over content you need to know for this task so to explain how my version of this game should work let me go through some information here which i'll replicate in the description box in case you'd rather just sit and read it as opposed to looking at it on the video section so the whole point here is a guessing game with the computer so first of all the user is going to think of a number in between a range which they can choose so the user might decide that they want for range to be between 1 and 100 and so the user might think of a number 31 or 100 so it can include the upper or lower range so once for users force of this number the computer is going to make a random guess of this number in the range so if a range needs to be actually inputted the number they're thinking of doesn't need to be inputted and once this guess has been shown to the user the user will see if this number is correct and if it is correct from the user is going to input correct and the round will end and once for round does n the number of guesses made by the computer which i'm going to call the score will be printed out so if the user so if a computer guess is wrong first of all but guess is correctly on my second occasion then the score will be two if it takes five guesses the score will be five so until the user deems the input correct however if the computer isn't correct then the user is going to either type in h lowercase uppercase for higher and l uppercase lowercase for lower to give the computer a clue so if i'll type in higher if the number should be higher if i guess was too low i would type in lower if their guess was too high and the computer can use this clue to make another guess within the new interval so the fact that if the user is telling the computer their previous guess was too high or too low means that you can then alter your guess in the next guess to make it more accurate and so this process of guessing getting some feedback guessing get some feedback will continue as a loop until the number is correctly guessed here are some success criteria to hopefully help you get guided towards a good solution here so you should be defining a function called game which has two parameters which i'm calling upper and lower and it should return the value held in a variable called score these parameter values which is what you call the arguments are going to come from user input so initially in your main routine you're going to ask the user for the upper bound and the lower bound and those values will get passed in as parameters to this function and inside the function you need to generate a random integer which will be generated including and between the upper and lower bounds and that value generated is the computer's guess so the value generator can include the upper bound and the lower bound as well so the user should be able to respond to this guess with either correct or higher or lower and when the computer is correct the function will return to the main routine with the score which can be shown to the user but when the commute is not correct the score is going to increment which means just add one and based on the upper and lower response that bound will get updated accordingly for the next guess so think about how you can use if you use telling you it's too high or too low to update the next guess so this task is not easy by any means lots of people have tried this and not everyone has managed to do it in my experience at least first try once you can do it it's not too hard but if you are finding it easy you want to push yourself even more here are some extensions to try so first of all allow the game to have multiple rounds so so far we've only really allowed it to have one round you you know the computer's guessing it gets it correct and the game ends but here we can allow multiple rounds and it only ends when the user decides to quit so when the user does decide to quit the scores from all of the rounds previously should be printed out so in round one vertical might be five in round two the score might be eight and so on and so on and a second possible extension task of course you can think of your own ones if you want to this one is in italics because i'm not going to show you how to do it because this really works in a very similar way except we're doing it in the opposite way so you need to create a second function which works in the opposite way so this time the computer will think of a number or i say think loosely the computer will generate a number and the user guesses and the computer tells the user is too high or too low and then the game can alternate between the different modes and the winner is the one for lowest score of the two modes so initially you could have the user guessing and then you could have computer guessing and going back and forth and the winner is one with the lowest score out of the two okay and before you have a go yourself here is a quick demo because i know there's been a lot of information so far the first thing you'd see is something like this welcome to the game and then you are asked to enter a lower range so let's do one entry an upper range let's do 50 here so now i'm told to think for a number between 1 and 50. let's do 28 i guess it's 44 so i type in l for lower and i guess it's 30 so it's close again i type in l because 17 i now type in h i guess 24 it's higher than 24. it's 125 higher than 27 and finally it guesses 28 so i can type in c for correct press enter and then it kind of completes and says the score is seven so if you were doing the first extension task now you would give the opportunity for the user to quit otherwise have another round and if you're doing a second extension task you can now launch into the user guessing and the computer generating the number and then going back to back like that so pause have a look at our of the requirements again and have a go with yourself and now i'll show you the solution to the main part of this problem okay so the first thing i want to do is define my function which i said was going to be called game and has two parameters the first one being upper and then lower uh if the actual order those two doesn't matter it seems more logical to have lower before upper but anyway and then we're going to have some code down here right and then i'm going to return score and so we can first of all sort of score as a variable and so we need to actually have a value in that variable which of course we're going to change as we go through but we can initialize it to be zero so we can make sure it's always available to be returned in the end and below our definition we can have our sort of main our main program our main routine which is going to call our function and so we're going to call it by saying its name game and we're going to supply some arguments and these arguments are going to come from the user and so let's just for the time being call them up and lower again and because it's returning a value returning score which is an integer we're going to also assign this to be a variable so we are calling our function the function at the top executes and returns a value and the value is stored under score so we've got the same names here which is okay but it may cause some confusion but i think it's probably okay here so in our main we want to well first of all to welcome the user to the game that seems nice and then we're going to ask the user to input the lower range lower and the upper range upper and we can also just we'll validate these maybe later so um our upper value is going to be going to say input and we'll do the same for lower as well so we'll um we'll make sure these have added later because we'll have to because we are expecting these to be integers as like a upper and lower range we can cast these down here but it's wrapping those variables in the int casting function making sure i've got enough brackets there now the issue is if i if i run this into your range if i type in hello we're going to immediately get errors once i do her range as well because we're trying to convert a string into integer so let me i said i was going to do this validation later but let me do it now so um what we can do and i haven't talked with in the tutorials but i have done it in a couple of challenges i believe is do something like well while upper is digit equals equals false because what is digit what method is digit does is checks to see if your value is an integer and if it isn't an integer it's going to give us false i mean really it's a positive integer which is also fine here because we can't have we don't really want a lower range i don't think so um and also we need also well evo if either one is not a digit we're going to get him to ask to enter a game so we need or here not and because it was false and then we're going to get them to put them in again so if they can't proceed we can't do that casting in line 17 until we make sure it's in the right data type so we could just add a message here saying something like is must be positive integers okay all right so that's all of our main program done for now if we do the extension later i'll show you how to we'll build up this a little bit but now the key bit here is inside our function so we need to actually have our game running in this function assuming this code works i should probably check it first i always i'll always move on without checking it okay perfect so um we are going to really this whole this whole game works by repeating repeating so i should say you know probably here print think of a number between and lower and upper now of course this game is relying on the user you know honestly um thinking of one and keeping in my mind if they forget it will be a bit of an issue but now we're going to make a guess and keep asking until the user says it's correct and so we need a while loop for this a for loop is where we have we sort of know how many times it's going to iterate here we don't know exactly it depends on what number of a user thinks of it depends how big this range is and so on so a while loop is more suitable we have a condition the condition being is it correct or not you know we could have a condition like is it correct or not but i think it's easier to have just a boolean toggle i use these a lot in while loops i don't know how brilliant design from a design point of view using them are but i think they're fine so while it's corrected was false and we're going to keep looping until view says it's correct and then we're going to set is correct to be true and it will envelope so we need to make sure we first of all um initialize is correct to be false and you can see down below i should have done two equal signs not one equal sign there one equal sign is for assigning a value two is for comparison so inside this while loop is where the main body of our code will go so first of all we need to make a guess so let's make a guess and this is going to be to make a a random guess unless you want to code it yourself which would be impossible if not well not possible it would be extremely difficult if not impossible um for some people we would need to import a random module so the random module is a whole bunch of different functions methods really which provide random functionality and they're not they're not available by default so i have to import from as a module but now we can use them so after guess i'm going to use a random keyword and then now i can do dot and the function we want here to generate integers in around in a range is randint which can take two arguments at least for lower range which is going to be lower here followed by the upper range which is upper and once we make this guess we're going to increment the score which i haven't actually had assigned yet and i have up here i forgot because we've made a guess we're going to increase the score so in this game a higher score is worse for the person guessing because um you want it to be lower as possible uh okay so um we now need to see if this guess is correct so we first wanted to show the user this guest right so we could do print um i guess guess and we could make it a bit prettier by adding a full stop maybe after this and because we're using concatenation on an integer and a string we need to make sure we cast guess to be a string as well i guess whatever it is full stop um then we could do um is this correct or should it be higher or lower okay and then we need to actually oh we need to get the input first of all so we could do um response equals input like that and now it's probably a good idea to sort of standardize our input by making it all lower case all uppercase depending on well it doesn't matter either way just to reduce the number of conditions we have it's best to try and make things as generic as possible you shouldn't need someone to enter a lowercase h or an uppercase h you know it shouldn't really matter so um we're now in an if statement to see if this response equals equals uh correct or um so that will never be true because i'm just made lowercase so correct lowercase or response equals equals just a like a c like that okay so if it is correct the most important thing to do here because i used this sort of boolean toggle is to then toggle it so that it is now true otherwise we'll be stuck in this loop forever and then we can uh i don't know something like print yes because i got it right the score is and ever the score is like that okay so that is really simple when it is correct it's not quite simple when it's not correct so we'll need an elift here because they're um not um because they're two different conditions so elev response is this time let's do if the response is higher or the response is just h on its own i do h on its own to make it quicker when i'm testing it and here we now need to think more carefully about how we can edit our sort of guess to be uh to be more clever right because we could we could have been told it's higher just guess another random invert original range but here we can now adapt our range to make it a bit smarter it works in a similar way to in a similar way to binary search if you come across that my indentation was off off there a little bit so um if if a response if we are taught so if we make a guess and and we are told it needs to be higher that means we can edit our lower bound because in fact if i just test this up until this point to maybe demonstrate how this works because i think it's fairly obvious but it might be worth demonstrating so if i put my upper range is um 10 and lower range is one i guess 10 so we get so let's say we're thinking of 5 but if i now say lower it's just going to guess again because we haven't coded this yet but if i guess lower then it can exclude 10 right now the range should be one to nine so we um that's for lower but if it's higher so let's say actually we're getting eight and it's guess seven well now the range should be eight to ten or eight to nine really because we have altered um autodown range and so really if i just uncomment this code lower should now be our current guess plus one like i had a go explaining if we are guessing seven and our value is eight we know then if it's if the value is too low because they've said higher we should plus one onto it and the same idea with when it's um lower blower or l we're going to set the upper range to be the guess minus one because you know up here i guess 10 if our number is eight and we say it's lower well then now the range has got to be between one and nine it's not going to include 10. so we can reduce a range like that and it will massively even if our starting range is huge massively cut down based on this so um that is the main sort of premise of our code and in fact our main kind of solution to our base requirements we could test this a couple of times now i've added in my code so upper range let's say 10 i should have really put myself way around so let's say i'm thinking of four so i guess nine well it's lower i get seven again it's still lower i guess two is higher i guess six uh i said four there's a wish you could forget this and lower and then higher again and we finally end up before that managed to get all of it all of them wrong there i panic for a second now i can type in correct and it should end so so the score is seven because it guessed seven times all right let's test that again because that confused me for some reason i've added uh two lines here to actually show us our range each time so hopefully should show us it updating let's not do up a range of 100 no that's not 100 it's too much let's just do 10 again for lack of originality so let's think of a number of five let's guess five straight away let's do number two this is correct no it should be lower uh and now i guess there's two actually it's done really well here but you can see uh it has updated our range so when i say it's five and then it's lower um it has gone one to four let's just do this one more time that's when we do a range of 15 to 5 and let's think of a number 12 guess is 11 so it should be higher okay this is um then i guess 15 lower and now it's guess 12. so you can see this time when it's updating uh based on it being lower it's also working or based on it being higher it's still working as we want it to because our range has gone to 12. okay so our main code is working let's now look at some issues we have with it right so if i now sort of don't really play ball and deliberately i've deliberately or by mistake of course some issues if i type in hello that's fixed because we did that earlier um but if i do uh 15 to 25 this time if i let's say so it's guess 29 let's say i was thinking of 29 but it kind of ignore that and just pretend it's lower i could you know potentially keep pressing in lower until we get an issue here it says the new range of 25 to 24 well how how is it going to generate random number in that range because our low a lower value is higher than our upper value and so you know you could the user not really doing it properly could lead to an error like this and it would cause your program to break so we can do is make sure before we are allowing this random function to generate our numbers because that's what the issue is here if you look at the bottom empty range for round range is coming from our random function here and so we need to kind of protect this function by checking to see if there are any issues before we actually use it so we can do is sort of wrap it in and or not even wrap it in an if because what we can do is we can do if let's say upper equals equals lower well that's an issue first of all in fact we could even just do upper is less than or equal to um lower because first of all they shouldn't be equal we shouldn't really ever have them being equal or certainly in fact no that's not true they can be equal they can be equal if you've guessed all the opportunities but if they become a situation where upper is bigger than lower or sorry upper is smaller than lower that means something's gone wrong here you can see here the upper value is smaller than the lower value which doesn't make sense so we need to if we have this case there's been some issue we could say something like uh i think you have made a mistake and so not only much we can do here i think we need to just get us out of this loop asap so we could set this to be true unless maybe we want to reset the score because otherwise you know the score isn't really valid a bit if we don't have that issue that's fine we can proceed as normal with an else and we can just make sure all of our code down here is now nested within this house apart from return because return is the last thing we're doing so hopefully that's all nested across so fingers crossed this code allows us to check for any issues like this like where we uh to kind of deliberately get it wrong let's have a look and see so let's reset that not sure what's happened there okay let's do a smaller range this time so let's do five and then lower range is one so finger numbers in one and five let's say so it's guessed three straight away let's say i was thinking of three so if it's correct or should it be higher or lower um let's just do lower and you wanted to let's do lower again and i think you made a mistake and we end okay that's good i think we can now comment out our sort of uh new ranges one to two because it's now confusing me a couple of times so where is it down here so i think that is mostly us done except for maybe one other issue is if i just do this again quickly now if i type something other than h or l or c if i type in high here um it's going to keep guessing which is maybe okay actually no i think about it because the score is going up and it's sort of your fault you haven't done it right maybe we could show a message right we could just say um down here else in all of the cases print you must enter h l or c and then it's going to guess again so actually maybe guessing again it's not really a big problem you could sort of wrap this whole code in another while loop to make sure they are entering hlrc and if they're not asking them again because right now it's just going to increase for guesses but i feel like that's kind of okay at this point all right so i think that's our our main code done unless i'm missing something which is possible in terms of our extension which is where we wanted to have multiple rounds like right now if i get it correct the game ends and that's it but actually you may want it to be so that we may want it to be so that we have multiple rounds and so the user can keep going afterwards and this is ultimately why we are using a function right for good format functions is not only are they quite provide a nice clean interface with parameters and return values but we can call our function however many times we want and it will all be absolutely fine we don't have to repeat loads of code if we wanted say five rounds without a function we need to repeat this code five times and it would be really annoying but also if we wanted say an infinite number of rounds we can't copy code infinitely and again having a function makes it a lot cleaner we need another loop so down here at the bottom uh i might i'm gonna quickly edit my upper and lower here because i was irritating me a bit so what we could do before this welcome to the game we could have another while loop and again let's just use a boolean toggle here so while has quit equals equals false again i need to make sure actually uh initialize this just outside so it has quit it's going to initially be initially be false one equal sign there again let's just shift all of this code inside my while loop for the time being because this is our main game um we could now before we uh we could just print for rounds and then and then the number so we could use a counter at the top so round and number could be zero initially don't need to do this but i figure it might make it look a bit nicer around num so at least we know what's going on here maybe we just add a new line to make it a little bit more separate and then we're doing this code as normal is all fine and once we finish the game in this case we're gonna increment the round number so you can keep track of it and then give the user the opportunity to quit right so if we you could say you know quit quitting equals input uh do you want to quit yes or no and then like we did before if quitting like with our yes or no with our higher or lower if quitting equals equals um y we are going to um make sure it's a lowercase we're going to make sure we set has quit what is quitting i should has called it is quitting to be true and we could say thank you for playing right so one of my conditions was we print out the scores thank you for playing uh the scores work now how are we going to print out our scores here because what we've done here so far we've just saved the score so we've called our function we go through the whole rigmarole of our game playing we end it by saying it's correct the value gets saved underscore but you know the whole point here is when we are quitting we want to print out all the scores and right now only one score is being printed at a time which is not really what we want because we can go through five rounds but every single round is just saving any value underscore the previous values are lost so if we you know we could if we were going about over the top like save our save our scores in a file like a text file which a future video will show how to do that feature tutorial but we could also just have a list a list is really nice because i like a variable a variable can only hold one bit of data at a time their list can hold loads of bits of data and you can add on to it right so you you know you don't have the opportunity to um create variables at runtime but list you can just append values to lists whenever you want to so if we just have a list maybe here called scores which we can initialize to be an empty list because nothing's happened yet and now instead of assigning our score our return score to our values to our variable score we can now make sure we are appending uh this to what i call it scores so scores dot append append means just add in um a value to it at the end of the list like so okay and then once we are ready to quit we can then iterate through this scores list which could have one value in it it could have 500 values in it and just print them out as we go okay i think it would be nice to down here use our round numbers in our in our um printing so we can use a for loop here instead of well we're gonna use a for loop anyway instead of saying something like four item in scores or four scoring scores we could say a round num in range zero going up to the length of scores and then we are going to print so round in round round num or maybe our code on there is a bit premature in round say one and then we might want to colon here which means i need to cast this round num and in fact because we start counting our indexes from zero round one will be zero here so in around zero it will be whatever which doesn't really make sense we might wanna hit we might want to do round one plus one here so it starts counting at one and then we can print the score but we need to use our use our list which is scores and index it with ground none in this case okay so hopefully that works how we want it to let's try this i may have made an error here about noticing so welcome to the game round zero so okay right so we need to make sure we around zero seems a bit strange so we could make sure we uh initialize it to be one not zero okay try again from one into a lower range let's do one upper range ten let's say i'm thinking of six so it needs to do lower let's um higher lower again five higher and now it's correct lovely so if score is five in that case do you do i want to quit let's say no uh round two lovely enter low range do one and ten this time uh let's just say again and let's now think of one so eleven seven lower than six eleven five and then it's got one and now let's quit now i've done two rounds i could keep going infinitely but hopefully thank you for playing with scores where round one was five round two was four except now it's uh asked us again i'm not sure why let's see why it's asking us again because i used for wrong the wrong variable here it was has correct i knew it was okay so right now we got stuck in the infinite while loop down here in our has quit loop because i never changed has quit i was changing is quitting which is not the same variable okay but i think the point remains right you can see we could keep playing infinitely we're adding new values to our scores list which is a nice way of keeping track of it and in the end we can um print them out just by iterating through our list so um that is pretty much the solution i believe well done if you have tried it and managed to do most of it if you can do all of it it's fine there's another extension task which i won't show you how to do in terms of actually kind of flipping this having a second function and getting it to now be um the computer generates a round number and you have to guess it so it kind of flips on its head and then you could sort of do a back to back game where round one might be for computer guessing round two might be the user guessing and it works like that i'll leave you to come up with your own solution for that if you have one feel free to share it i'd be interested in seeing it otherwise let me know any questions this solution will be in the description for you to have a look at if you want to otherwise thank you very much for watching
