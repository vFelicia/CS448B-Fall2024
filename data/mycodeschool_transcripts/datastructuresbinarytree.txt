00:00 - In our previous lesson, we introduced you
to tree data structure.
00:03 - We discussed tree as a logical model and talked
briefly about some of the applications of
00:08 - tree.
00:09 - Now, in this lesson we will talk a little
bit more about binary trees.
00:13 - As we had seen in our previous lesson, binary
tree is a tree with this property that each
00:19 - node in the tree can have at most 2 children.
00:23 - We will fist talk about some general properties
of binary tree and then we can discuss some
00:28 - special kind of binary trees like binary search
tree which is a really efficient structure
00:34 - for storing ordered data.
00:36 - In a binary tree as we were saying, each node
can have at most 2 children.
00:41 - In this tree that I have drawn here, nodes
have either 0 or 2 children.
00:45 - We could have a node with just one child.
00:48 - I have added one more node here and now we
have a node with just one child.
00:53 - Because each node in a binary tree can have
at most 2 children, we call one of the children
00:58 - left child and another right child.
01:01 - For the root node, this particular node is
left child and this one is right child.
01:10 - A node may have both left and right child.
01:13 - These 4 nodes have both left and right child
or a node can have either of left and right
01:17 - child.
01:18 - This one has got a left child, but has not
got right child.
01:22 - I'll add one more node here.
01:24 - Now this node has a right child, but does
not have a left child.
01:28 - In a program, we would set the reference or
pointer to left child as NULL.
01:33 - So, we can say that for this node left child
is NULL and similarly for this node, we can
01:39 - say that the right child is NULL.
01:41 - For all the other nodes that do not have children,
that are leaf nodes, a node with 0 child is
01:47 - called leaf node.
01:49 - For all these nodes, we can say that both
left and right child are NULL.
01:54 - Based on properties, we classify binary trees
into different types.
01:58 - I'll draw some more binary trees here.
02:01 - If a tree has just one node, then also its
a binary tree.
02:05 - This structure is also a binary tree.
02:08 - This is also a binary tree.
02:10 - Remember, the only condition is that a node
cannot have more than 2 children.
02:15 - A binary tree is called strict binary tree
or proper binary tree if each node can have
02:20 - either 2 or 0 children.
02:23 - This tree that I am showing here is not a
strict binary tree because we have 2 nodes
02:27 - that have one child.
02:29 - I'll get rid of 2 nodes and now this is a
strict binary tree.
02:33 - We call a binary tree complete binary tree
if all levels except possibly the last level
02:40 - are completely filled and all nodes are as
far left as possible.
02:45 - All levels except possibly the last level
will anyway be filled.
02:48 - So, the nodes at the last level, if its not
filled completely must be as far left as possible.
02:56 - Right now this tree is not a complete binary
tree.
02:59 - Nodes at same depth can be called nodes at
same level.
03:04 - Root node in a tree has depth 0.
03:06 - Depth of a node is defined as length of path
from root to that nodes.
03:11 - In this figure lets say nodes at depth 0 are
nodes at level 0.
03:15 - I can simply say L-0 for level 0.
03:18 - Now, these two nodes are at level 1, these
4 nodes are at level 2 and finally these 2
03:26 - nodes are at level 3.
03:30 - The maximum depth of any node in the tree
is 3.
03:33 - Maximum depth of a tree is also equal to height
of the tree.
03:37 - if we will go numbering all the levels in
the tree like L-0, L-1, L-2 and so on, then
03:43 - the maximum number of nodes that we can have
at some level i, will be equal to 2 to the
03:48 - power i.
03:50 - At level 0, we can have 1 node, 2 to the power
0 is 1.
03:55 - Then at level 1, we can have at max 2 nodes.
03:59 - At level 2 , we can have 2 to the power 2
nodes at max which is 4.
04:04 - So, in general at any level i, we can have
at max 2 to the power i nodes.
04:10 - You should be able to see this very clearly.
04:12 - Because each node can have 2 children, so
if we have x nodes at a level, then each of
04:18 - these x nodes can have 2 children.
04:21 - So, at next level, we can have at most 2x
children.
04:25 - Here in this binary tree, we have 4 nodes
at level 2 which is the maximum for level
04:30 - 2.
04:31 - Now, each of these nodes can possibly have
2 children.
04:34 - I am just drawing the arrows here.
04:37 - So, at level 3, we can have max 2 times 4
i.e 8 nodes.
04:42 - Now, for a complete binary tree, all the levels
have to be completely filled.
04:48 - We can give exception to the last level or
deepest level.
04:51 - It doesn't have to be full.
04:53 - But the nodes have to be as left as possible.
04:56 - This particular tree that I am showing here
is not a complete binary tree because we have
05:00 - 2 vacant node positions in left here.
05:05 - I'll do slight change in this structure.
05:07 - Now this is a complete binary tree.
05:10 - We can have more nodes at level 3, but there
should not be a vacant position left.
05:15 - I have added one more node here and this still
is a complete binary tree.
05:20 - if all the levels are completely filled, such
a binary tree can also be called perfect binary
05:25 - tree.
05:26 - In a perfect binary tree, all levels will
be completely filled.
05:30 - If h is the height of a perfect binary tree,
remember height of a binary tree is length
05:36 - of longest path between root to any of the
leaf nodes or i should say number of edges
05:43 - in longest path from root to any of the leaf
nodes.
05:47 - Height of a binary tree will also be equal
to max depth, Here, for this binary tree,
05:54 - max depth is 3.
05:56 - Maximum number of nodes in a tree with height
h will be equal to, we will have 2 to the
06:01 - power 0 nodes at level 0, 2 to the power 1
nodes at level 1 and we'll go on summing for
06:07 - height h, we will go till 2 to the power h.
06:10 - At deepest level, we will have 2 to the power
h nodes.
06:15 - Now this will be equal to 2 to the power h
plus 1 minus 1.
06:20 - h+1 is number of levels here.
06:23 - We can say that 2 to the power number of levels
minus 1.
06:27 - In this tree, number of levels is 4.
06:29 - We have L0 till L3.
06:32 - So, number of nodes, maximum number of nodes
will be 2 to the power 4 minus 1 which is
06:39 - 15.
06:40 - So, a perfect binary tree will have maximum
number of nodes possible for a height because
06:45 - all levels will be completely filled.
06:47 - Well, I should say maximum number of nodes
in a binary tree with height h.
06:53 - Ok, I can ask you this also.
06:55 - What will be height of a perfect binary tree
with N nodes.
07:00 - Lets say N is number of nodes in a perfect
binary tree.
07:04 - To find out height, we'll have to solve this
equation n = 2^h+1 - 1 because if height is
07:11 - h, number of nodes will be 2 to the power
(h+1) minus 1.
07:16 - We can solve this equation and the result
will be this.
07:21 - Remember n is number of nodes here.
07:23 - I'll leave the maths for you to understand.
07:25 - Height will be equal to log (n+1) to the base
2 minus 1.
07:31 - In this perfect binary tree that I am showing
here, number of nodes is 15.
07:34 - So, n is 15.
07:36 - (n+1) will be 16.
07:38 - So, h will be log 16 to the base 2 minus 1.
07:45 - log 16 to the base 2 will be 4.
07:47 - So, the final value will be 4-1 equal 3.
07:51 - In general, for a complete binary tree, we
can also calculate height as floor of log
07:57 - n to the base 2.
07:58 - So, we need to take integral part of log n
to the base 2.
08:02 - Perfect binary tree is also a complete binary
tree.
08:05 - Here n is 15.
08:07 - log of 15 to base 2 is 3.906891.
08:13 - if we'll take the integral part, then this
will be 3.
08:17 - I'll not go into proof of how height of complete
binary tree will be log n to the base 2.
08:23 - We'll try to see that later.
08:26 - All this maths will be really helpful when
we will analyze cost of various operations
08:30 - on binary tree.
08:32 - Cost of a lot of operations on tree in terms
of time depends upon the height of tree.
08:37 - For example, in binary search tree which is
a special kind of binary tree, the cost of
08:43 - searching, inserting or removing an element
in terms of time is proportional to the height
08:49 - of tree.
08:50 - So, in such case we would want the height
of the tree to be less.
08:54 - Height of a tree will be less if the tree
will be dense, If the tree will be close to
08:59 - a perfect binary tree or a complete binary
tree.
09:03 - Minimum height of a tree with n nodes can
be log n to the base 2 when the tree will
09:08 - be a complete binary tree.
09:10 - if we will have an arrangement like this,
then the tree will have maximum height.
09:15 - With n nodes, minimum height possible is floor
of or integral part of log n to the base 2
09:22 - and maximum height possible with n nodes in
n-1 when we will have a sparse tree like this
09:31 - which is as good as a linked list.
09:33 - Now, think about this.
09:35 - If I'm saying that time taken for an operation
is proportional to height of the tree or in
09:41 - other words I can say that if time complexity
of an operation is big-oh of h where h is
09:47 - height of the binary tree, then for a complete
or perfect binary tree, my time complexity
09:54 - will be big-oh of log n to the base 2 and
in worst case for this sparse tree, my time
10:00 - complexity will be big-oh of n.
10:03 - Order of log n is almost best running time
possible.
10:07 - For n as high as 2 to the power 100, log n
to the base 2 is just 100.
10:15 - With order of n running time, if n will be
2 to the power 100, we won't be able to finish
10:20 - our computation in years even with most powerful
machines ever made.
10:26 - So, here is the thing.
10:27 - Quite often, we want to keep the height of
a binary tree minimum possible or most commonly,
10:34 - we say that we try to keep a binary tree balanced.
10:38 - We call a binary tree balanced binary tree,
if for each node, the difference between height
10:43 - of left and right sub-tree is not more than
some number k.
10:48 - Mostly k would be 1.
10:49 - So, we can say that for each node, difference
between height of left and right sub-tree
10:54 - should not be more than 1.
10:56 - There is something that I want to talk about
height of a tree.
10:59 - We had defined height earlier as number of
edges in longest path from root to a leaf.
11:04 - Height of a tree with just one node where
the node itself will be a leaf node will be
11:10 - 0.
11:11 - We can define an empty tree as a tree with
no node and we can say that height of an empty
11:17 - tree is -1.
11:20 - So, height of tree with just one node is 0
and height of an empty tree is -1.
11:25 - Quite often, people calculate height as number
of nodes in longest path from root to a leaf.
11:33 - In this figure, I have drawn one of the longest
paths from root to a leaf.
11:37 - We have 3 edges in this path.
11:39 - So, the height is 3.
11:41 - If we will count number of nodes in the path,
height will be 4.
11:45 - This looks very intuitive and I have seen
this definition of height at lot of places.
11:51 - if we will count the nodes, height of tree
with just one node will be equal to 1 and
11:55 - then we can say that height of an empty tree
will be 0, but this is not the correct definition
12:00 - and we are not going to use this assumption.
12:02 - We are going to say that height of an empty
tree is -1 and height of tree with one node
12:08 - is 0.
12:10 - The difference between heights of left and
right sub-trees of a node can be calculated
12:14 - as absolute value of height of left subtree
minus height of right subtree and in this
12:21 - calculation, height of a sub-tree can be -1
also.
12:24 - For this leaf node here in this figure, both
left and right sub-trees are empty, so both
12:30 - hleft or height of left sub-tree and hright
or height of right sub-tree will be -1, but
12:36 - the difference overall will be 0.
12:39 - For all nodes in a perfect tree, difference
will be 0.
12:41 - I have got rid of some nodes in this tree
and now by the side of each node, I have written
12:46 - the value of diff.
12:48 - This is still a balanced binary tree because
the maximum diff for any node is 1.
12:53 - Lets get rid of some more nodes in this tree
and now this is not balanced because one of
12:58 - the nodes has diff 2.
13:01 - For this particular node, height of left sub-tree
is 1 and height of right sub-tree is -1 because
13:08 - right sub-tree is empty.
13:10 - So, the absolute value of difference is 2.
13:14 - We try to keep a tree balanced to make sure
its dense and its height is minimized.
13:20 - If height is minimized, cost of various operations
that depend upon height are minimized.
13:25 - Ok, the next thing that I want to talk about
very briefly is how we can store binary trees
13:31 - in memory.
13:32 - One of the ways that we had seen in our previous
lesson which is most commonly used is dynamically
13:39 - created nodes linked to each other using pointers
or references.
13:45 - For a binary tree of integers, in C or C++,
we can define node like this - data type here
13:51 - is integer, so we have a field to store data
and we have two pointer variables, one to
13:57 - store address of left child and another to
store address of right child.
14:02 - This of course is the most common way.
14:05 - Nodes dynamically created at random locations
in memory linked together through pointers,
14:11 - but in some special cases, we use arrays also.
14:15 - Arrays are typically used for complete binary
trees.
14:18 - I have drawn a perfect binary tree here.
14:20 - Lets say this is a tree of integers.
14:22 - What we can do is, we can number these nodes
from 0 starting at root and going level by
14:28 - level from left to right.
14:30 - So, we will go like 0, 1 , 2 , 3 , 4, 5 and
6.
14:37 - Now, I can create an array of 7 integers and
these numbers can used as indices for these
14:44 - nodes.
14:45 - So, at 0th position, I'll fill 2, at 1th position
I'll fill 4, at 2th position, we will have
14:52 - 1 and I'll go on like this.
14:55 - We have filled in all the data in the array,
but how will we store that information about
15:00 - the links.
15:01 - How will we know that the left child of root
has value 4 and the right child of root has
15:07 - value 1?
15:08 - Well, in case of complete binary tree, if
we will number the nodes like this that for
15:13 - a node at index i, the index of left child
will be 2*i+1 and the index of right child
15:20 - will be 2i+2 and remember this is true only
for a complete binary tree.
15:25 - For 0, left child is - 2i+1 for i = 0 will
be 1 and 2i+2 will be 2.
15:34 - Now, for 1, left child is at index 3, right
child is at index 4.
15:41 - For i =2, 2i+1 will be 5 and 2i+2 will be
6.
15:48 - We will discuss array implementation in detail
when we will talk about a special kind of
15:52 - binary tree called heap.
15:54 - Arrays are used to implement heaps.
15:56 - I'll stop here now.
15:58 - In our next lesson, we will talk about binary
search tree which is also a special kind of
16:03 - binary tree that gives us a really efficient
storing structure in which we can search something
16:09 - quickly as well as update it quickly.
16:13 - This is it for this lesson.
16:14 - Thanks for watching !!