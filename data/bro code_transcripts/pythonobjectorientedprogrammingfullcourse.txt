00:00 - hey everybody so we have finally made it
00:02 - to Python objectoriented Programming
00:05 - this is a very important topic in Python
00:08 - an object is a bundle of related
00:10 - attributes and methods attributes are
00:13 - similar to variables to describe what
00:15 - the object has so look around you right
00:18 - now you are surrounded by different Real
00:20 - World objects next to me I have a phone
00:23 - a cup and a book each of these objects
00:26 - can have different attributes to
00:28 - represent it for example
00:30 - an attribute of the phone next to me
00:32 - could be version number I could set that
00:34 - to be 13 is on could be another
00:37 - attribute is the phone powered on or not
00:39 - that could be true or false or even a
00:42 - price I have a cup next to me what
00:45 - liquid is within the cup in this case
00:47 - coffee what's the temperature of the cup
00:49 - is the cup empty is empty or even a book
00:53 - What's the title of the book that could
00:55 - be a string how many pages does the book
00:58 - have Pages could be another attribute
01:00 - now objects also have the capability to
01:03 - do things they have methods which are
01:06 - functions that belong to an object
01:09 - people mix up functions and methods all
01:11 - the time they're technically different
01:13 - even when teaching I tend to make that
01:15 - mistake calling a method a function and
01:17 - a function a method usually people know
01:19 - what you're referring to though a method
01:21 - is a function that belongs within an
01:23 - object what are some actions these
01:25 - objects can perform with a phone you can
01:29 - make a call or receive a call turn the
01:31 - phone on or turn the phone off those
01:34 - could all be functions with a cup you
01:36 - could fill the cup drink from the cup or
01:39 - empty the cup with a book you can open
01:41 - the book read the book and close the
01:44 - book an object is a bundle of related
01:48 - attributes and methods they can
01:50 - represent real world items to create
01:54 - many objects we'll need to utilize a
01:56 - Class A Class is a type of blueprint
01:59 - used to design the structure and layout
02:02 - of an object we need to design what our
02:05 - objects have their attributes and what
02:08 - they can do their methods we will create
02:11 - a class of car we will create some car
02:14 - objects class
02:18 - car to construct a car object we need a
02:21 - special type of method called a
02:23 - Constructor it works similarly to a
02:25 - function we will Define a function
02:30 - of double underscore init meaning
02:33 - initialize double underscore again and
02:36 - then follow this with a set of
02:37 - parentheses this is our Constructor
02:40 - method we need this method in order to
02:42 - construct objects it's a Dunder method
02:45 - Dunder meaning double underscore that's
02:47 - a future topic I don't want you to be
02:50 - overloaded with information right now
02:52 - all you need to know is that we need
02:53 - this method in order to create objects
02:56 - this method behaves similar to a
02:58 - function we need to set up the
03:00 - parameters self is already provided to
03:03 - us self means this object we're creating
03:06 - right now this car so what are some
03:09 - attributes that a car should have a
03:12 - model that could be a string like a
03:16 - BMW a year that could be a
03:19 - number a
03:21 - color let's add a Boolean of for sale is
03:26 - the car for sale or not that's true or
03:29 - false
03:30 - to assign these attributes we're going
03:32 - to access self self dot the name of the
03:36 - attribute self. model equals the model
03:41 - we
03:42 - receive these are parameters when we
03:45 - receive the name of a model we will
03:47 - assign it to this object let's do this
03:50 - with year self. year equals year self.
03:56 - color equals color self
04:00 - do for sale equals for sale this is an
04:05 - example of a few attributes that a car
04:07 - might have a model year color and if
04:10 - it's for sale or not represented by a
04:13 - Boolean now to construct a car object we
04:15 - need a unique name for this car let's
04:18 - just say car one car one equals take the
04:23 - name of the class add a set of
04:25 - parentheses to invoke The Constructor
04:29 - we're going to do this this almost
04:30 - exactly like a function we have
04:32 - parameter set up we need to send a
04:34 - matching number of arguments self is
04:37 - provided to us behind the scenes
04:39 - automatically we need a model year color
04:42 - and if it's for sale or not so pick a
04:45 - car of you're choosing I'll pick my
04:47 - favorite
04:48 - car the model will be a Mustang for the
04:51 - year I'll go with the recent year of
04:54 - 2024 a color I'll pick red is the car
04:59 - for sale
05:00 - I like this car so no I will set that to
05:02 - be false make sure false is
05:05 - capitalized let's see what happens if I
05:08 - attempt to print our car object of car
05:13 - one what we're given is the memory
05:16 - address of this car object where it's
05:19 - located but I would like one of the
05:21 - attributes located at this memory
05:24 - address instead of printing the object
05:26 - itself we're going to access one of the
05:28 - attributes found within this car we will
05:31 - follow the name of the car with a DOT
05:35 - this dot it's known as the attribute
05:37 - access operator I would like the model
05:41 - of car
05:42 - one that would give me
05:45 - Mustang let's access the year take the
05:48 - name of the car car 1 dot the year
05:53 - 2024 followed by the color car1 docolor
06:01 - red car one is it for sale we'll print
06:07 - that that is
06:09 - false now let's create a second car
06:12 - we're going to reuse this class to
06:14 - create a second car we will create Car 2
06:18 - equals car we'll pass in some different
06:21 - arguments a Corvette the year will be
06:25 - 2025 the color will be blue is this car
06:29 - for sale let's say that is
06:32 - true instead of accessing car 1's
06:34 - attributes let's access car 2's
06:38 - attributes that would give us a Corvette
06:41 - the year is 2025 the color is blue for
06:45 - sale is set to
06:46 - true or even a third car car 3 equals a
06:52 - new car we will pass in a
06:55 - string of charger the year 2026
07:00 - the color will be yellow is this car for
07:03 - sale let's say that is true as well then
07:06 - I will print car 3's
07:12 - attributes the model is charger the year
07:14 - is 2026 the color is yellow for sale is
07:18 - set to True with classes they can take
07:21 - up a lot of space for better
07:23 - organization you can place them within a
07:25 - new python file so let's cut our class
07:31 - and we will create a new python file
07:33 - within our project folder file new
07:37 - python file the name of this python file
07:40 - is going to be all lowercase
07:44 - car then we will paste the class that we
07:48 - cut
07:49 - originally class car which has a capital
07:53 - c so from our main python file we're
07:56 - going to import our car file our car
07:59 - module
08:00 - modle from the name of the module car
08:04 - import the name of the class car then
08:07 - when I run this program nothing should
08:09 - change we should still have access to
08:11 - all of our car
08:14 - objects you could either keep your
08:16 - classes within your main python file or
08:19 - import them if you would like to
08:20 - organize things let's talk about methods
08:23 - methods are actions that our objects can
08:26 - perform within our class we will Define
08:28 - a method
08:30 - of Drive self is going to be provided to
08:34 - us when we invoke the drive function
08:36 - let's
08:37 - print you drive the car what other
08:42 - things can cars do let's
08:46 - stop we will
08:50 - print you stop the
08:55 - car let's take car one access the drive
09:01 - method you drive the car car 2 also has
09:05 - a drive method you drive the car same
09:08 - thing with car 3 you drive the car let's
09:12 - access the stop
09:14 - method car one.
09:18 - stop car 2.
09:21 - stop and car 3.
09:24 - stop these methods are identical for
09:27 - each car object instead of printing the
09:30 - word car let's insert the model of the
09:33 - car I will convert these print
09:35 - statements to F
09:38 - strings instead of the word car let's
09:40 - add a
09:41 - placeholder let's add
09:43 - self.
09:45 - model self is referring to the object
09:48 - we're currently working with use the
09:51 - attribute axis operator followed by the
09:53 - name of the attribute let's also do this
09:56 - with the stop method self
10:00 - do
10:03 - model let's take car one use the drive
10:07 - method you drive the Mustang car
10:11 - one.
10:14 - stop you drive the Mustang you stop the
10:17 - Mustang let's do this with Car
10:19 - 2 you drive the Corvette you stop the
10:23 - Corvette car
10:25 - three you drive the charger you stop the
10:28 - charger
10:30 - now within our F strings let's also
10:32 - insert let's insert the
10:35 - color I'll add a placeholder self. color
10:40 - do this with stop as
10:42 - well
10:44 - self.
10:47 - color you drive the yellow charger you
10:50 - stop the yellow charger car one you
10:54 - drive the red Mustang you stop the red
10:56 - Mustang card two you Drive the blue
10:59 - Corvette you stop the blue Corvette
11:02 - let's add one last
11:04 - method let's create a method to describe
11:07 - our car we'll print the details of the
11:10 - car let's print I'll use an F
11:14 - string add three
11:17 - placeholders let's print self
11:22 - doye followed by self.
11:25 - color then self. model
11:31 - we'll take car 1 use the describe method
11:34 - that we
11:35 - created describe car 1 car 1 is a 2024
11:41 - red Mustang describe Car 2 Car 2 is a
11:46 - 2025 blue Corvette car 3 is a 2026
11:51 - yellow charger all right everybody so
11:54 - those are objects in Python an object is
11:57 - a bundle of related attrib attributes
12:00 - attributes are variables that an object
12:02 - has and methods methods are functions
12:07 - that belong to an object they Define
12:09 - what this object can do and well
12:12 - everybody that is a summary of
12:14 - object-oriented programming using python
12:17 - hey everybody today I got to talk about
12:19 - class variables in Python class
12:21 - variables are shared among all instances
12:25 - meaning objects created from a class
12:28 - instance variables are defined inside of
12:30 - the Constructor class variables are
12:32 - defined outside of the Constructor with
12:35 - class variables they allow you to share
12:37 - data among all objects created from the
12:40 - class with instance variables each
12:43 - object has their own version with a
12:45 - class variable all those objects share
12:48 - one variable here's an example we will
12:51 - create a class of
12:54 - student we also need a
12:56 - Constructor when we create a student
12:58 - object object this Constructor is
13:00 - automatically going to be called but we
13:02 - need to pass in some arguments we are
13:05 - provided with self self refers to the
13:08 - object we're currently working with we
13:10 - will set up a name parameter and an age
13:13 - parameter we will assign self the object
13:17 - we're currently working with set the
13:19 - name attribute to equal the data for the
13:22 - name that we receive from this parameter
13:25 - and self. AG equals age
13:29 - let's construct two student objects we
13:32 - will have student one equals then call
13:36 - the Constructor for
13:38 - student so type the name of the class
13:40 - followed by a set of parentheses to
13:42 - invoke it this will automatically call
13:44 - The Constructor but we have to pass in
13:46 - data for the name and the age for the
13:49 - name let's pass in SpongeBob because
13:52 - basically everybody in the world knows
13:53 - who SpongeBob is I don't know how old
13:56 - SpongeBob is we'll say he's 30 we will
13:59 - create another student object which we
14:01 - will refer to as student 2 we will call
14:04 - the Constructor of our student class
14:07 - pass in data for the name and age
14:10 - student two will be Patrick Patrick will
14:13 - be
14:14 - 35 okay let's make sure this works let's
14:18 - print student
14:20 - 1's name followed by student 1's
14:27 - age and we should get SpongeBob and his
14:31 - age is 30 let's print student 2's name
14:34 - and student 2's age Patrick Patrick is
14:38 - 35 now we'll create a class variable
14:41 - class variables are defined outside the
14:43 - Constructor and they are shared among
14:46 - all objects created from that class each
14:49 - object has their own name and age
14:51 - property these are instance variables
14:54 - but class variables are defined outside
14:56 - the Constructor each object will share
14:59 - this one variable so if we're working
15:02 - with students let's say there is a class
15:07 - variable of class year what is the
15:11 - graduating year of this
15:13 - class
15:15 - 2024 now let's print student 1's
15:19 - graduating
15:21 - year print student
15:24 - one.
15:26 - class year
15:32 - okay so SpongeBob has a class year of
15:35 - 2024 that's when he's graduating let's
15:38 - check student
15:42 - two Patrick is ages 35 his graduating
15:46 - class year is
15:48 - 2024 now with class variables you can
15:52 - access them through any one object such
15:54 - as student one or student 2 it's good
15:57 - practice to access a class variable by
15:59 - the name of the class rather than any
16:02 - object created from the class since
16:04 - we're accessing class year we'll access
16:07 - this class variable by the name of the
16:09 - class of student make sure the S is
16:14 - capital this helps with Clarity and
16:17 - readability if I was looking at this
16:19 - print statement I can tell that class
16:21 - year is a class variable because we're
16:24 - accessing it directly from the class and
16:26 - not any instance from this class
16:29 - without looking at this class I can't
16:31 - tell if class year is an instance
16:34 - variable or a class variable but if I
16:36 - access it via the class name it's more
16:39 - explicit so it's good practice to access
16:42 - a class variable by the class name
16:44 - itself and not any one instance of this
16:47 - class let's create another class
16:51 - variable we'll create a class variable
16:53 - to keep track of how many students we
16:55 - have created this class variable will be
16:58 - num students meaning number of students
17:02 - equals zero So within our Constructor we
17:05 - can write any code that we want this
17:08 - code will always be executed when we
17:10 - instantiate an object I would like to
17:13 - take our number of students and
17:15 - increment it by one each time we
17:17 - construct a new student object so
17:19 - instead of using self self refers to the
17:22 - object we're currently working with if
17:24 - we're constructing student one just
17:26 - imagine we're replacing self with
17:28 - student one or student 2 if we were
17:31 - constructing student two if we're going
17:34 - to be modifying a class variable in
17:36 - place of self we'll use the name of the
17:39 - class student access our class of
17:42 - student get the class variable of number
17:45 - of students then I will increment it by
17:48 - one plus equals
17:51 - 1 we are constructing two student
17:55 - objects I will
17:57 - print X access our class of
18:00 - student get the number of students and
18:03 - print it we're constructing two student
18:06 - objects if I print the number of
18:08 - students that we have it should be two
18:11 - then just to be sure that this is
18:13 - working let's construct a third student
18:15 - object student 3 equals student this
18:20 - student will have a name of Squidward
18:23 - Squidward's age will be
18:26 - 55 now we have three
18:29 - students and for good measure let's
18:31 - construct one
18:33 - more student 4 equals we will create a
18:38 - new student with a name of Sandy sy's
18:42 - age will be
18:44 - 27 the number of students is now four
18:47 - just as an
18:49 - exercise using an F string let's print
18:52 - the student classes class year as well
18:55 - as the number of
18:56 - students I will print use an F string my
19:03 - graduating
19:04 - class of let's add a
19:08 - placeholder access the class of
19:11 - student then access the class
19:14 - Year my graduating class of
19:19 - 2024 has then we need the number of
19:22 - students We'll add a
19:23 - placeholder access the class of
19:26 - student access the number of of
19:29 - students has
19:31 - blank
19:34 - students let's see if this works my
19:37 - graduating class of 2024 has four
19:40 - students now if I were to change 2024 to
19:44 - 2025 my graduating class of 2025 has
19:48 - four
19:49 - students let's print the name of each
19:52 - student these are instance variables
19:55 - student one. name
20:00 - then we need Student two three and
20:05 - four my graduating class of 2025 has
20:09 - four students SpongeBob Patrick
20:11 - Squidward Sandy all right everybody so
20:14 - those are class variables class
20:16 - variables are shared among all instances
20:19 - of a class they are defined outside of
20:22 - the Constructor the benefit is that they
20:24 - allow you to share data among all
20:26 - objects created from that class
20:29 - and well everybody those are class
20:30 - variables in
20:32 - Python what is going on everybody so
20:35 - today I got to talk about inheritance in
20:37 - Python inheritance allows a class to
20:40 - inherit the attributes and methods from
20:42 - another class much like how a child in
20:45 - real life can inherit traits from A
20:47 - parent by having a class inherit
20:49 - attributes and methods from another
20:51 - class this helps with code reusability
20:54 - and extensibility in this example we're
20:56 - going to create an animal class the dog
20:59 - cat and mouse class will inherit
21:01 - attributes and methods from the animal
21:03 - class we will create a class of
21:07 - animal then I will Define The
21:12 - Constructor when we construct an animal
21:14 - object let's pass in a name it's not
21:18 - required but it might be good for this
21:20 - example we will assign the attribute of
21:23 - name equal to the name we
21:25 - receive let's also add an attribute of
21:28 - of is alive whenever we create an animal
21:32 - we will set there is alive attribute to
21:34 - be true and that is a capital
21:38 - T all animals can eat Define eat we will
21:43 - print using an F string add a
21:47 - placeholder self. name the name of this
21:50 - animal is eating all animals should be
21:54 - able to sleep Define sleep
21:59 - print I'll use an FST string insert
22:03 - self. name is sleeping and that is all
22:08 - we need for the animal class let's
22:11 - define class dog for a child class to
22:15 - inherit the attributes and methods from
22:17 - another class after the class name
22:19 - that's going to inherit we need to add
22:22 - an inheritance list with the set of
22:24 - parentheses then list the name of the
22:26 - class we're inheriting from the parent
22:28 - parent the dog class is going to inherit
22:31 - all of the attributes and methods of its
22:33 - parent
22:35 - animal for the time being as a
22:37 - placeholder I'll add pass just to
22:39 - demonstrate this class cat is also going
22:43 - to inherit from
22:47 - animal and class Mouse will also inherit
22:51 - from
22:54 - animal okay I will collapse this for now
22:57 - we'll create a dog object dog equals dog
23:01 - then pass it a name for this dog because
23:03 - we have one parameter set up of
23:06 - name this dog will be
23:08 - named Scooby as in
23:12 - Scooby-Doo cat equals call the cat
23:18 - Constructor this cat will be named
23:21 - Garfield and
23:23 - mouse mouse equals Mouse our Mouse will
23:27 - have a name of
23:29 - Mickey even though there's nothing
23:31 - within this dog cat or Mouse class we
23:34 - should still have these attributes and
23:36 - these methods if you inherit the animal
23:39 - class you should have a name attribute
23:41 - and is alive attribute set to true you
23:44 - can eat and you can sleep let's print
23:47 - our dog's name dog.
23:51 - name
23:54 - Scooby print dog. is
24:00 - alive our dog is alive that is
24:03 - true let's have our dog object use the
24:06 - eat
24:08 - method Scooby is eating and sleep dog
24:12 - dos
24:13 - sleep Scooby is sleeping let's replace
24:17 - dog with
24:21 - cat the name of the cat is Garfield
24:24 - Garfield is alive Garfield is eating
24:26 - Garfield is sleeping and
24:29 - Mouse replace any instance of cat with
24:32 - mouse our mouse's name is Mickey Mickey
24:35 - is alive Mickey is eating Mickey is
24:38 - sleeping even though these children
24:40 - classes are empty we're still inheriting
24:43 - these attributes and methods from its
24:44 - parent of animal this is convenient
24:47 - because you don't need to copy and paste
24:50 - these attributes and methods for every
24:51 - single class for example if I were to
24:54 - copy these attributes and methods and
24:56 - paste them
25:00 - well we have a lot more code to write
25:02 - and as a consequence if I need to make a
25:04 - change to one of these methods I would
25:06 - have to do that to every single instance
25:08 - of this method for example let's replace
25:11 - is sleeping with is asleep well now I
25:15 - need to find every single Sleep Method
25:17 - and change it
25:23 - manually it's not too bad if you only
25:25 - have a few classes but imagine if you
25:27 - have hundreds of classes
25:29 - that's going to take a lot of work it's
25:31 - a lot easier to write the code once and
25:33 - then reuse it and I only need to make
25:35 - that change in one place rather than
25:38 - make that change many times so let's
25:40 - change is sleeping to is asleep and see
25:43 - if that works
25:46 - again Mickey is
25:48 - asleep let's replace Mouse with
25:53 - dog Scooby is asleep not only that but
25:57 - with children classes they can have
25:59 - their own attributes and methods that
26:01 - are different from one
26:02 - another so dogs have all these
26:04 - attributes and methods and they can
26:08 - speak let's create a speak method and I
26:11 - will print a unique message for dogs
26:14 - woof cats will also have a speak method
26:17 - but it's going to be
26:19 - different cats will
26:24 - meow then for our Mouse class they will
26:27 - squeak
26:32 - let's have our dog
26:37 - speak woof let's have our cat
26:41 - speak meow and our
26:44 - Mouse
26:45 - squeak all right everybody so that's an
26:47 - introduction to inheritance inheritance
26:50 - allows a class to inherit attributes and
26:53 - methods from another class much like in
26:56 - real life a child can inherit TR trates
26:58 - from a parent these are also known as
27:01 - sub and super classes which is a topic
27:05 - for another day inheritance helps with
27:07 - code reusability and extensibility if
27:10 - all of these children classes inherit
27:12 - these attributes and methods from
27:13 - another class we only need to write that
27:16 - code once and not copy it for every
27:18 - single class that needs it we can write
27:21 - and change the code in one place for
27:23 - better reusability and extensibility and
27:25 - well everybody that is an introduction
27:27 - to inheritance in Python hey everybody
27:30 - so today we got to talk about both
27:32 - multiple and multi-level inheritance
27:34 - we'll begin with multiple inheritance
27:37 - that's when a child class inherits from
27:39 - more than one parent class for example a
27:42 - class of C can inherit the traits from
27:45 - both class A and B in Python you can
27:48 - have more than one parent multi-level
27:51 - inheritance we'll talk about near the
27:52 - end of this topic so in this example
27:55 - we're going to create two parent classes
27:57 - prey
27:59 - I'll write pass for
28:01 - now and
28:06 - Predator we'll create a class of
28:10 - rabbit a class of
28:15 - Hawk then class
28:21 - fish rabbit Hawk and fish are going to
28:24 - be children classes prey and predator
28:28 - will be parents if one of these classes
28:30 - rabbit hawk or fish inherit from prey
28:33 - they get the ability to flee we will
28:36 - Define a method of flee all we'll do in
28:40 - this example is print the following
28:43 - text this animal is fleeing if you're a
28:48 - predator you get the method to hunt
28:51 - Define
28:53 - hunt we will
28:56 - print this animal is
29:01 - hunting rabbits they will inherit from
29:04 - the prey class they're typically not
29:06 - Predators except that one rabbit and
29:08 - montypython and the Holy Grail that's
29:10 - the exception rabbit will inherit the
29:13 - prey class then it gets access to a flea
29:16 - method Hawks are predators they will
29:19 - inherit the Predator class now fish they
29:23 - will hunt smaller fish and flee from
29:26 - bigger fish you could consider fish both
29:29 - prey and predators so they will inherit
29:32 - both classes we will use multiple
29:35 - inheritance they will inherit everything
29:37 - from the prey class and the Predator
29:40 - class now let's see if this does in fact
29:42 - work now we'll create a rabbit object
29:44 - rabbit equals rabbit there are no
29:47 - parameter setup we don't need to send
29:48 - any arguments to the
29:50 - Constructor Hawk equals
29:53 - Hawk and fish equals
29:56 - fish so so let's take our rabbit object
29:59 - and they should have a flea method
30:01 - rabbit. flea method this animal is
30:04 - fleeing but they do not have a hunt
30:06 - method because they're not
30:09 - Predators rabbit object has no attribute
30:12 - hunt Hawks can
30:14 - hunt they Predators they inherited that
30:18 - method this animal is hunting but they
30:21 - can't flee they're not prey Hawk object
30:24 - has no attribute flea fish can do both
30:28 - they inherit from the prey class and the
30:30 - Predator
30:32 - class fish. flee this animal is fleeing
30:36 - fish.
30:38 - hunt this animal is hunting children
30:41 - classes can inherit from more than one
30:43 - parent which is what we did for fish
30:46 - they are both prey and predators whereas
30:49 - in rabbits are just prey Hawks are just
30:51 - Predators if you need to inherit from
30:53 - more than one parent you just add that
30:56 - additional class to The Inheritance
30:58 - list with multi-level inheritance a
31:02 - parent can inherit from another parent
31:05 - we will create a
31:06 - class of
31:08 - animal and for now I'll write pass prey
31:12 - and Predator are going to inherit from
31:14 - the animal class so we need to add
31:16 - animal to each inheritance
31:20 - list let's say if you're an animal you
31:23 - get a method to eat all animals will eat
31:29 - print this animal is eating and you can
31:34 - sleep Define
31:37 - sleep
31:39 - print this animal is
31:44 - sleeping so think of rabbit Hawk and
31:47 - fish as children classes prey and
31:51 - Predator are those class's parents and
31:54 - animal is the grandparent pray and
31:57 - Predator will inherit everything that
31:59 - the animal class has rabbit Hawk and
32:02 - fish will inherit everything the prey
32:04 - and Predator classes have so now our
32:07 - rabbit Hawk and fish classes should have
32:10 - the ability to eat and sleep and we'll
32:12 - test that rabbit.
32:15 - eat this animal is eating rabbit.
32:19 - sleep this animal is sleeping let's
32:22 - check out fish fish. eat this animal is
32:27 - eating fish do
32:29 - sleep this animal is
32:32 - sleeping okay we're going to expand upon
32:34 - our example a little bit let me zoom out
32:38 - each of our objects is going to have a
32:40 - name our rabbit will have a first name
32:43 - of bugs Hawk will be Tony as in Tony
32:47 - Hawk our fish will be
32:51 - Nemo within our classes we don't have
32:53 - any Constructor set up in which class
32:56 - should we assign the name
32:59 - attribute let's do so within our animal
33:02 - class so we will Define a
33:06 - Constructor to assign these
33:08 - attributes we will receive a
33:11 - name we'll assign self. name equals name
33:17 - now with these other classes if you're
33:19 - not assigning any attributes or if you
33:21 - don't need any other initialization
33:23 - logic you don't need a Constructor we'll
33:26 - implicitly use the Constructor RoR we
33:28 - inherit from the
33:29 - parent let's convert each of these print
33:32 - statements to an F
33:36 - string replace animal with
33:39 - self.
33:49 - name now let's have our rabbit use the E
33:55 - method oh we should get rid of this
34:02 - there we go bugs is eating rabbit. sleep
34:08 - bugs is sleeping rabbit.
34:11 - flee bugs is fleeing let's check out our
34:14 - Hawk Hawks don't have a flea method
34:17 - because they're Predators not
34:21 - prey let's eat Tony is eating let's
34:25 - sleep Tony is sleeping
34:28 - let's
34:29 - hunt Tony is hunting let's check our
34:33 - fish next our fish can eat Nemo is
34:36 - eating our fish can
34:38 - sleep Nemo is sleeping they can
34:42 - flee Nemo is fleeing and
34:46 - Hunt Nemo is
34:48 - hunting okay everybody that is both
34:50 - multiple and multi-level
34:52 - inheritance with multiple inheritance a
34:56 - child can inherit from more than one
34:58 - parent class you just add each
35:00 - additional class to The Inheritance list
35:03 - with multi-level inheritance a child can
35:06 - inherit from a parent which inherits
35:09 - from another parent Class C can inherit
35:12 - from B where Class B inherits from a
35:16 - think of C as the child b as the parent
35:18 - and a as the grandparent c will have all
35:21 - the attributes and methods even
35:23 - available within the grandparent class
35:25 - of a and well everybody that that is
35:27 - both multiple and multi-level
35:29 - inheritance in Python hey everyone
35:32 - welcome back so today I got to talk
35:34 - about abstract classes in Python an
35:37 - abstract class is a class that cannot be
35:40 - instantiated on its own abstract classes
35:43 - are meant to be subclassed they're
35:45 - supposed to be parents to children
35:47 - classes they can contain abstract
35:49 - methods which are declared but have no
35:52 - implementation abstract classes have a
35:55 - few benefits we can't create an object
35:57 - from a class that's abstract abstract
36:00 - classes you could say are incomplete we
36:02 - don't want to create an object that's
36:04 - incomplete also any children that
36:07 - inherit from an abstract class if
36:09 - there's any abstract methods we have to
36:11 - implement them so let me give you a
36:13 - demonstration we're going to create a
36:15 - Class A vehicle for now I'll write pass
36:20 - to work with abstract classes we'll need
36:22 - to import
36:24 - ABC ABC meaning abstract base
36:28 - classes we need import ABC all capital
36:33 - meaning abstract Base
36:36 - Class as well as abstract
36:40 - method so my vehicle class it's going to
36:43 - be an abstract class we will inherit
36:46 - from ABC the abstract based class I
36:50 - don't want myself or any other
36:51 - developers to be able to create a
36:53 - vehicle object I will make this vehicle
36:56 - an abstract class also I can add some
36:58 - abstract methods these methods will be
37:01 - inherited by its
37:03 - children to declare an abstract method
37:05 - we need to use a decorator at abstract
37:11 - method so what should all vehicles be
37:14 - able to do let's say go and stop if
37:17 - you're a vehicle you can
37:21 - go with abstract methods we declare them
37:24 - but we don't Define them we'll Define
37:26 - them within each of the children
37:27 - children classes that inherit from
37:29 - vehicle let's create another abstract
37:32 - method abstract method Define
37:38 - stop if you're a vehicle you can stop
37:41 - all right we have finished our abstract
37:43 - class A vehicle just to demonstrate that
37:46 - we can instantiate an object from this
37:48 - class let's attempt to do so and see
37:50 - what happens I will attempt to create a
37:52 - vehicle object vehicle equals
37:55 - vehicle and then run this
37:59 - type error can instantiate abstract
38:01 - class vehicle with abstract methods go
38:04 - and stop this is good this is what we
38:06 - want our vehicle class is incomplete we
38:09 - don't want to accidentally make a
38:10 - vehicle object if we were it's kind of
38:12 - like the invisible boatmobile from
38:14 - SpongeBob instead we will create some
38:17 - children to inherit from this class so
38:20 - now we will create a class of car which
38:24 - will inherit from vehicle car is the
38:27 - child vehicle is the parent but we are
38:30 - receiving a warning Class Car must
38:33 - Implement all abstract methods what
38:35 - we're saying is hey if you inherit from
38:38 - the vehicle class you need to include
38:40 - these abstract methods so I'm not going
38:42 - to currently let's just see what
38:44 - happens I will attempt to create a car
38:48 - object and run
38:50 - it type error can't instantiate abstract
38:53 - class car with abstract methods go and
38:57 - stop if a class is inheriting from a
39:00 - parent that's abstract and there's
39:02 - abstract methods we have to finish
39:05 - defining those
39:06 - methods So within our car class really
39:09 - I'll just copy this because I'm
39:11 - lazy our method is go we will
39:15 - print you drive the car we also need
39:23 - stop I will
39:26 - print you stop the
39:29 - car okay let's see if this
39:31 - works this has run with no problems I
39:34 - will have my car
39:36 - go then stop we're calling the go method
39:39 - then the stop method you drive the car
39:42 - you stop the car let's create a few more
39:45 - children for the vehicle class class
39:50 - motorcycle will inherit from the vehicle
39:55 - class again we have to implement the
39:57 - abstract methods found within the parent
40:00 - go and
40:06 - stop for go I will
40:10 - print you ride the
40:15 - motorcycle then with
40:19 - stop you stop the
40:23 - motorcycle motorcycle equals motorcycle
40:27 - we're calling the
40:30 - Constructor then I will have our
40:33 - motorcycle
40:35 - go then
40:37 - stop you ride the motorcycle you stop
40:40 - the
40:41 - motorcycle all right last example let's
40:44 - say we create a boat class which will
40:47 - inherit from the abstract class A
40:51 - vehicle I will include a go method where
40:55 - I will print
40:58 - you sail the
41:00 - boat but I will forget to add a stop
41:03 - method because I'm not paying attention
41:06 - let's attempt to create a
41:11 - boat well what the heck is this type
41:13 - eror can instantiate abstract class boat
41:16 - with abstract method stop then I'll look
41:19 - over my code and see oh I forgot to
41:22 - include a stop method with including
41:24 - abstract methods within a parent it acts
41:26 - as a set of checks and balances all
41:29 - vehicles should be able to go and stop
41:32 - if I forget to Define one of these
41:34 - methods well we'll receive a type error
41:36 - if we didn't I may not have noticed that
41:39 - we're missing a method so now we need to
41:41 - include that stop
41:44 - method I will
41:46 - print you anchor the
41:51 - boat this seems to have run with no
41:53 - problems I will have my boat go
41:58 - and
42:00 - stop you sail the boat you anchor the
42:03 - boat all right everybody so those are
42:05 - abstract classes it's a class that can't
42:08 - be instantiated on its own we can't
42:11 - create any objects from this class we
42:13 - don't want to because it's well
42:15 - incomplete they're meant to be
42:18 - subclassed they can contain abstract
42:20 - methods which are declared but we don't
42:23 - finish defining them we Define them
42:25 - within the children classes in this
42:27 - example car motorcycle and boat and well
42:30 - everybody those are abstract classes in
42:32 - Python hey everybody so today I got to
42:35 - talk about the super function in Python
42:38 - super is a function it's used within a
42:41 - child class to call methods from a
42:43 - parent class the child class is the
42:46 - subass the parent class is the super
42:49 - class hence why this function is named
42:50 - the super function using the super
42:53 - function it allows you to extend the
42:55 - functionality of the inherent methods
42:58 - here's an example we'll create a few
42:59 - shape objects we'll need to set up the
43:01 - classes though we'll have class
43:05 - Circle for the time being I'll just
43:07 - write pass we'll fill it in later class
43:13 - square and
43:15 - class
43:18 - triangle for each of these classes in
43:20 - order to instantiate objects we'll need
43:22 - a Constructor we will Define our
43:25 - Constructor our innit method
43:29 - when creating circles what sorts of
43:31 - attributes should a circle have let's
43:33 - say a color what's the color of the
43:36 - circle is it filled or not filled will
43:40 - be another attribute and a
43:43 - radius then let's assign
43:45 - these self. color equals the color that
43:49 - we receive
43:51 - self. fil equals
43:55 - filled self
43:57 - radius equals
44:00 - radius let's do this with the square and
44:02 - Triangle really I'll just copy our
44:04 - Constructor and paste it squares don't
44:08 - have a radius with a square the width
44:11 - and the height are the same let's
44:12 - replace radius with width we'll also
44:15 - keep the color and filled attributes
44:18 - self. width equals width now with
44:23 - triangles again let's copy our
44:25 - Constructor we'll need a width and a
44:30 - height self. height equals
44:34 - height so with programming we try not to
44:37 - repeat ourselves if we don't have to
44:39 - what do all of these classes have in
44:41 - common they all share the attributes of
44:44 - color and
44:47 - filled the ways in which they are
44:49 - different is that Circle has a radius
44:51 - attribute square has a width triangle
44:54 - has a width and a height if we have to
44:56 - make any changes to one of these
44:57 - attributes we would have to do so
44:59 - manually for example let's replace filed
45:02 - with is filed now I need to look
45:05 - throughout my code for any instance of
45:07 - filled and replace it with is
45:09 - filled it's a lot of work and I might
45:12 - make a
45:13 - mistake such as here and here it's
45:17 - better to write your code once and try
45:19 - and reuse it so that's where inheritance
45:21 - and the super function can come in handy
45:23 - we're going to take the attributes of
45:24 - color and is filled and place it within
45:26 - a parent class these children classes
45:29 - will inherit those
45:31 - attributes so class what do they all
45:34 - have in common they're all shapes class
45:37 - shape and for now I'll write pass circle
45:41 - is going to inherit from its parent of
45:43 - shape that also applies with square and
45:46 - triangle we'll set up a Constructor for
45:49 - shape Define
45:54 - init we will pass in the color
45:57 - and is
46:01 - filled then we will assign these
46:04 - attributes self. color equals
46:08 - color self. is filled equals is filled
46:14 - we don't need to manually assign these
46:16 - attributes within each of these
46:17 - Constructors for the
46:19 - children instead what we have to do is
46:22 - within the Constructor for each of these
46:24 - children classes we have to call the
46:26 - Constructor structor for the parent also
46:28 - known as the super class of shape so we
46:32 - will eliminate these two lines of
46:34 - code use the super
46:38 - function dot call The Constructor of the
46:41 - parent that is the dunder init method
46:45 - but we need to pass in the color that we
46:48 - receive and is filled this will be a
46:52 - Boolean and let's do this with the
46:54 - square class
46:57 - and the triangle
46:59 - class we still need radius for the
47:01 - circle width for the square width and
47:04 - height for the triangle we're going to
47:06 - call the super function to take care of
47:08 - whatever our attributes all these types
47:10 - of shapes have in common such as color
47:12 - and is filled now let's see if this
47:14 - works let's construct a few objects we
47:17 - will create a circle named
47:19 - circle called a Constructor for Circle
47:22 - we have to pass in a color a Boolean if
47:25 - it's filled or not and a radius
47:27 - so for the color of the circle let's say
47:31 - red is filled let's say that is true and
47:35 - a radius of five you could even use
47:38 - keyword arguments for better readability
47:40 - although not necessary but for clarity
47:43 - let's say color equals
47:45 - red is filled equals
47:48 - true radius equals
47:51 - 5 let's see if this works I will print
47:56 - our Circle
48:00 - color it is
48:04 - red print our colors is filled
48:08 - attribute the circle is filled that is
48:11 - true and the
48:13 - radius print
48:15 - circle. rius the radius of the circle is
48:20 - five we could even convert this to an F
48:23 - string I'll add a placeholder
48:29 - then add
48:32 - centimeters 5 cm let's construct a
48:35 - square
48:37 - object square equals
48:40 - Square we'll need a color is filled and
48:43 - a width I'll just copy what we have and
48:45 - make a few changes replace radius with
48:49 - width the color will be blue is filled
48:53 - will be false the width will be six we
48:56 - don't need the height because squares
48:58 - have an even width and height if we ever
49:00 - need the height we can assume it's the
49:02 - same as the width in this case six let's
49:05 - check out our square square do color
49:08 - square. is filled Square do
49:13 - width our square is blue it's not filled
49:16 - in the width is 6
49:18 - cm let's create a triangle object
49:22 - triangle equals
49:25 - triangle pass in our
49:28 - arguments the color will be yellow is
49:31 - filled will be true the width will be
49:35 - seven and the height will be
49:39 - eight let's print our triangle's color
49:42 - is it filled its width and its
49:50 - height our triangle is yellow it's
49:52 - filled in the width is 7 cm the height
49:56 - is 8
49:57 - cm so that's how you can use the super
50:00 - function to reuse the Constructor of a
50:02 - parent class we don't need to manually
50:05 - assign each of these attributes within
50:07 - each of the children classes we can do
50:09 - that in just one place when we refer to
50:11 - Super imagine that we're replacing this
50:14 - with the parent class name such as
50:17 - shape that might be a good way to think
50:19 - of
50:21 - it use the Constructor of the parent
50:24 - class of shape and pass these arguments
50:27 - in what you could do as well is extend
50:30 - the functionality of a method So within
50:32 - our shape class let's create a method of
50:37 - describe we will describe the attributes
50:39 - of this shape we will
50:42 - print use an FST string when we want to
50:46 - describe our shape let's say it is at a
50:49 - placeholder self. color what is the
50:53 - color of this shape and is it fill or
50:55 - not and add a placeholder we'll use a
50:59 - tary operator print
51:03 - filled if self. is filled is true else
51:09 - we will
51:11 - print not
51:14 - filled each of these types of shapes
51:17 - circle square and triangle will have
51:19 - access to a describe
51:21 - method let's attempt to use it take our
51:25 - Circle use the describe method that's
51:29 - inherited it is red and filled
51:33 - Square it is blue and not filled
51:37 - triangle it is yellow and
51:40 - filled so then we also have method
51:42 - overwriting what if we create a similar
51:45 - method of describe within circle square
51:47 - and triangle let's do
51:50 - that
51:52 - Define a describe method
51:57 - within our Circle let's calculate the
52:00 - area what's the area of the circle I'll
52:02 - use an F string it is a
52:06 - circle with an area of then we'll
52:11 - calculate the area given the
52:13 - radius to calculate the area of a circle
52:16 - we can take Pi I'll just say 3.14 just
52:19 - to keep it simple times the radius
52:22 - squared self. rius time self. rius
52:27 - if I were to call the describe method
52:30 - will we use the parents version of
52:32 - describe or the
52:35 - child so let's take our Circle use the
52:39 - describe
52:40 - method the
52:42 - result it is a circle with an area of
52:46 - 78.5 I should really add cim squar after
52:50 - that cm
52:53 - squared this is called method
52:55 - overwriting if a child child shares a
52:57 - similar method with a parent you'll use
53:00 - the child's version and not the parents
53:03 - this is Method overwriting if you would
53:05 - like to extend the functionality of a
53:07 - method from a parent you can use the
53:10 - super function not only do I want to use
53:12 - the describe method of the child I would
53:14 - also like to use the describe method of
53:16 - the parent So within this function we
53:19 - will use the super function access the
53:23 - describe method of the
53:25 - parent what we're doing is extending the
53:28 - functionality of the describe
53:31 - method it is a circle with an area of
53:34 - 78.5 cm squared the circle is red and
53:38 - it's
53:39 - filled or you can change up the
53:43 - order let's use the parent classes
53:46 - describe method and extend the
53:48 - functionality with our own print
53:50 - statement it is red and filled it is a
53:53 - circle with an area of 78.5 cm squ
53:57 - let's finish this with the square and
53:59 - triangle classes I'll copy what we have
54:01 - for the described method within the
54:02 - circle
54:03 - class but we'll make a different
54:08 - calculation describe the square it is a
54:11 - square with an area of take self. width
54:16 - times self.
54:19 - width the height and the width are going
54:21 - to be the same if it's a
54:23 - square then describe our triangle
54:30 - it is a
54:32 - triangle with an area of width time
54:35 - height we have a height in this case
54:37 - divid two we've already described our
54:40 - Circle let's describe our
54:43 - Square it is a square with an area of 36
54:46 - CM squar it is blue and not filled let's
54:50 - describe our
54:51 - triangle it is a triangle with an area
54:54 - of 28.0 cm squ it is yellow and
54:58 - filled all right everybody that is the
55:00 - super function it's used in a child
55:02 - class to call the methods from a parent
55:05 - class also known as the super class it
55:08 - allows you to extend the functionality
55:10 - of the inherited methods within a child
55:13 - class you could use it within a
55:14 - Constructor to assign any attributes
55:17 - that all of its siblings have in common
55:19 - such as color or if that shape is filled
55:23 - when used within any other method you
55:25 - can extend the fun functionality of that
55:27 - method not only are we printing this
55:30 - message from the parent we're tacking on
55:32 - another print statement before that and
55:34 - well everybody that is the super
55:36 - function in Python what is going on
55:39 - everybody so today I got to talk about
55:41 - polymorphism in Python polymorphism is a
55:45 - programming concept it's a Greek word
55:47 - that means to have many forms or faces
55:50 - poly means many morph means form in
55:53 - programming an object can take one of
55:56 - many forms there's two ways to achieve
55:58 - polymorphism one is through inheritance
56:00 - an object could be treated of the same
56:03 - type as a parent class there's also duck
56:05 - typing which we'll talk about in the
56:07 - next Topic in this video we're more
56:09 - focused on inheritance what we'll do in
56:12 - this video is create a class of shape
56:15 - we'll write pass as a placeholder we
56:18 - will create a class of circle which will
56:21 - inherit from shape again writing pass
56:25 - class class Square inherits from
56:31 - shape class
56:34 - triangle which inherits from
56:39 - shape if I was to create a circle object
56:42 - Circle equals
56:44 - Circle our Circle identifies as a circle
56:48 - and since our Circle class inherits from
56:50 - the shape class our circle is also
56:52 - considered a shape it has two forms it's
56:55 - a circle and it's a shape but our Circle
56:58 - isn't a square or a triangle that could
57:00 - also apply to our Square
57:02 - class our square is a square our square
57:06 - is also considered a shape but our
57:08 - square is not a circle or a triangle
57:10 - those are two possible forms for our
57:12 - Square it's a square and a shape so
57:15 - let's say we would like to create a list
57:17 - of shapes what do they all have in
57:19 - common well they're all shapes a
57:21 - descriptive name for this list would be
57:24 - shapes equals an empty list
57:27 - I will instantiate a circle object a
57:30 - square
57:31 - object and a triangle
57:34 - object our circle is a circle and a
57:38 - shape our square is a square and a shape
57:41 - our triangle is a triangle and a shape
57:44 - each of these objects has two forms or
57:47 - two faces let's fill in some of these
57:49 - classes let's say that with our shape
57:52 - class we will define an area method
57:55 - Define area I'm going to turn this into
57:58 - an abstract method I'll just write pass
58:01 - to work with abstract classes we need to
58:03 - import that from
58:06 - ABC import Capital ABC as well as
58:11 - abstract method preceding the area
58:14 - method I will add a decorator of
58:16 - abstract method our circle square and
58:19 - triangle classes they're all considered
58:21 - shapes they inherit from this class we
58:24 - need to Define an area method for each
58:26 - since they're all considered a shape
58:28 - every shape has an area with our class
58:31 - of circle let's define a
58:34 - Constructor Define in
58:37 - nit we will pass in one argument a
58:40 - radius what is the radius of the circle
58:43 - assign an attribute of radius equals the
58:46 - radius we receive let's do this with
58:49 - square Define in
58:52 - nit one parameter the length of a side
58:57 - self. side equals side then
59:02 - triangle Define
59:06 - init we have two parameters base and
59:12 - height self. Bas equals base self.
59:18 - height equals
59:20 - height all right now let's finish
59:22 - defining these area methods for each
59:24 - class
59:26 - we will
59:29 - return
59:31 - 3.14
59:33 - time self. rius to the power of
59:37 - two so given a radius that's how to
59:40 - calculate the area of a circle then with
59:43 - our
59:45 - Square Define
59:47 - area we will
59:50 - return
59:52 - self. side to the power of two
59:58 - then with our
60:00 - triangle Define
60:04 - area
60:06 - Return self. base times self. height
60:12 - time
60:14 - 0.5 now we have to pass in some
60:16 - arguments for our Circle we need a
60:18 - radius I'll pick four for the square the
60:21 - length of a side will be five then our
60:24 - triangle the base will be six the height
60:26 - will be seven we're going to write a
60:29 - loop to iterate through our shapes for
60:31 - every shape in
60:34 - shapes then we're going to
60:36 - print for every shape called the area
60:43 - method and that would give me these
60:46 - numbers if you would like you can format
60:48 - the output I'll just use an F
60:54 - string I'll add CM
61:03 - squar much better what if we were to
61:06 - create a class that's completely
61:08 - unrelated to
61:10 - shapes I will create a class of
61:15 - pizza I will Define a
61:19 - Constructor to construct a pizza object
61:22 - we need a
61:24 - topping and a radius what is the radius
61:26 - of the
61:28 - pizza self. topping equals
61:33 - topping self. rius equals
61:38 - radius within my list of shapes I'll add
61:41 - a pizza
61:42 - object but I have to pass in a topping
61:45 - such as
61:48 - pepperoni and what is the radius of the
61:51 - pizza let's say 15 cm so our pizza our
61:55 - Pizza class doesn't have an area method
61:58 - here's what happens when I run
62:00 - this we get an attribute error Pizza
62:04 - object has no attribute
62:06 - area our pizza object is considered a
62:09 - pizza but it is not considered a shape
62:12 - it does not inherit from the shape class
62:14 - at the top here you know what a pizza is
62:17 - circular it could be considered a circle
62:20 - so how about this let's take the pizza
62:22 - class it will inherit from the circle
62:25 - class
62:26 - and within our Circle class we're
62:29 - already assigning the radius to the
62:30 - radius attribute so instead of doing
62:33 - that here within the Constructor for our
62:34 - pizza class let's call the super
62:37 - Constructor super which refers to the
62:40 - parent use its
62:42 - Constructor then passing the radius we
62:45 - receive let's see if this works
62:49 - now that does here is the area of our
62:52 - pizza our pizza is considered a pizza it
62:56 - inherits from the circle class so it's
62:58 - also considered a circle and our Circle
63:01 - class inherits from the shape class our
63:04 - pizza has three forms our pizza is
63:07 - considered a pizza it's also considered
63:09 - a circle and it's also considered a
63:11 - shape it would make sense for it to fit
63:13 - into this list of shapes because our
63:16 - pizza also identifies as a shape so
63:19 - that's polymorphism everybody it's a
63:21 - Greek word meaning to have many forms or
63:23 - faces poly meaning many morph meaning
63:26 - form in Python there's two ways to
63:28 - achieve polymorphism one through
63:30 - inheritance an object could be treated
63:32 - of the same type as a parent and there's
63:35 - also duck typing which we'll discuss
63:37 - more in the next topic stay tuned for
63:39 - that and well everybody that's
63:41 - polymorphism in
63:44 - Python hey everybody so today I got to
63:46 - talk about duck typing in Python duck
63:49 - typing is another way to achieve
63:51 - polymorphism besides using inheritance
63:54 - objects can be treated as if they're
63:56 - type as long as they meet the minimum
63:58 - necessary attributes and methods
63:59 - required of them it follows this adage
64:02 - if it looks like a duck and quacks like
64:04 - a duck it must be a duck as long as an
64:08 - object resembles another it could also
64:10 - be treated of that type so in this
64:13 - example let's create a class of
64:16 - animal we will have a class attribute of
64:19 - a live if you're an animal you will have
64:22 - an attribute of aive you're a living
64:25 - creature
64:26 - let's create a class of dog the dog
64:30 - class will inherit from the animal class
64:33 - they will inherit the alive attribute
64:35 - let's also Define a speak method if
64:38 - you're a dog you gain the ability to
64:40 - speak we will
64:43 - print
64:44 - woof then we'll create a cat
64:47 - class class cat inherits from animal for
64:52 - the speak method we will print meow
64:56 - let's create a list of animals what do
64:58 - these two classes have in common they
65:01 - both could be considered animals let's
65:03 - create a list of
65:05 - animals we will construct a dog object
65:08 - and a cat
65:10 - object if I was to write a for Loop for
65:13 - every animal in my list of
65:17 - animals have each animal use its speak
65:21 - method which will result in the dog
65:25 - going woof the cat going meow they're
65:27 - both
65:28 - speaking what if we add a class that has
65:31 - nothing to do with
65:33 - animals like class
65:36 - car cars will have a horn method that's
65:40 - how they
65:41 - speak when you honk the horn you will
65:45 - print
65:47 - honk within my list of animals let's
65:50 - create a car object it really doesn't
65:53 - belong in here but let's see what
65:54 - happens
65:58 - we have an attribute error car object
66:01 - has no attribute
66:03 - speak our car object doesn't have the
66:06 - minimum necessary attributes and
66:09 - methods when iterating through this list
66:11 - of animals we're calling each animal
66:13 - speak method which our car object
66:16 - doesn't have but it does have a horn
66:19 - method so what if we rename our horn
66:21 - method as speak maybe it's an AI car or
66:25 - something
66:27 - something well this would work the dog
66:30 - goes woof the cat goes meow the car goes
66:34 - honk so our car
66:37 - object it quacks like a duck we could
66:40 - consider it a duck it has the minimum
66:43 - necessary methods to be considered an
66:46 - animal animals inherit this alive
66:48 - attribute let's utilize that after the
66:52 - animal
66:53 - speaks let's print their Al live
66:56 - attribute print my animals Al live
67:00 - attribute my car object doesn't have
67:03 - that attribute we get an attribute error
67:06 - car object has no attribute
67:08 - alive but if I was to add that
67:12 - attribute alive equals
67:17 - false we have true for the dog it's
67:20 - living true for the cat it's living but
67:22 - false for the car it's not living it's
67:25 - not a living
67:27 - creature my car meets the minimum
67:29 - necessary requirements to be considered
67:32 - an animal if I were to set this to be
67:36 - alive well then it would be a living car
67:39 - kind of like the movie Cars so with
67:42 - python duct typing is another way to
67:45 - achieve polymorphism besides using
67:47 - inheritance as long as an object has the
67:49 - minimum necessary attributes and methods
67:52 - you could treat it as a different type
67:53 - of object if it looks like a duck and
67:56 - quacks like a duck it must be a duck and
67:59 - well everybody that is duck typing in
68:02 - Python hey what's going on everybody so
68:05 - in today's video I'm going to explain
68:06 - aggregation in Python aggregation
68:09 - represents a relationship where one
68:11 - object contains references to one or
68:14 - more independent objects one object acts
68:17 - as a container the whole which can
68:20 - contain other objects the parts so what
68:23 - we'll do in this demonstration is create
68:25 - a object that's going to act as a
68:26 - container we'll create a class of
68:29 - library for now a right pass now a
68:33 - library can contain books we will create
68:36 - a class of
68:39 - book we'll be creating book objects
68:41 - which we will add to our library object
68:44 - the library object is going to act as
68:46 - the whole the container the books are
68:49 - the independent Parts a library can
68:52 - exist without its books and the books
68:54 - can exist without the library that's the
68:57 - main difference between aggregation and
68:59 - composition these classes are
69:01 - independent of one another they can
69:03 - exist without each other with our class
69:05 - of book we'll need a Constructor we will
69:09 - Define our
69:11 - Constructor if we create a book we need
69:14 - a title and an
69:17 - author we will Define a title attribute
69:21 - equals the title that we receive and
69:24 - self . author equals the author that we
69:28 - receive that's all we need for the book
69:30 - class now with the library class we will
69:33 - also need a
69:34 - Constructor Define
69:37 - init for our library we need a name for
69:41 - the library for example the New York
69:44 - Public
69:45 - Library self. name equals the name that
69:49 - we receive let's construct our library
69:52 - object first Library equals Li Library
69:56 - we need to pass in a name for this
69:58 - Library let's say New York Public
70:04 - Library so this should run with no
70:06 - problems then we'll create a few books
70:09 - let's say book one equals called the
70:13 - book Constructor we have to pass in a
70:15 - title and an author so pick a few books
70:19 - I will pick Harry Potter Happy Harry
70:25 - Harry
70:26 - Potter and the philosopher stone but I
70:29 - don't want to type the whole title let's
70:31 - just say Harry Potter do dot
70:34 - dot the author of this book is JK
70:39 - rolling okay let's create another book
70:42 - book two equals
70:45 - book for my next book I'll pick the
70:49 - Hobbit the author is J R R our
70:57 - token then book three equals book we
71:02 - need a title and an author I will pick
71:05 - the
71:06 - color of
71:09 - Magic by
71:11 - Terry
71:14 - pratchet we have no problems when
71:16 - running this our library and our books
71:20 - can exist without each other our books
71:23 - are independent so now now where
71:25 - aggregation comes in our library object
71:28 - will contain our book objects one way in
71:30 - which we can handle this is that within
71:32 - the Constructor for our library let's
71:35 - create an attribute of
71:37 - books this will be an empty
71:42 - list we'll need a way to add these books
71:46 - to our list of books we will Define a
71:49 - method of add
71:52 - book but we have to pass in a book
71:54 - object when we call this
71:57 - method we're going to access self. books
72:01 - it's a list list have a built-in append
72:05 - method we will append our book to our
72:08 - list of
72:11 - books let's see if this at least runs
72:14 - we're going to take our
72:16 - library call the add book method that we
72:20 - defined then pass in our book object of
72:23 - book
72:23 - one then let's let's do this with book
72:26 - two and book
72:29 - three and this is run with no problems
72:32 - our books can exist independently of our
72:35 - library our library object is just
72:38 - containing them it's housing these books
72:42 - now if I would like to print all the
72:43 - books in my library I could create a
72:46 - method to do that let's define a method
72:49 - of list books there will be no
72:53 - parameters besid self
72:55 - I'm going to return a list
72:59 - comprehension for every book in self.
73:03 - books remember that books is a list for
73:07 - every book in books Let's return an F
73:11 - string where we display the book's title
73:14 - and the book's
73:16 - author display book. tile the word
73:21 - by bookauthor
73:26 - okay let's see if this works first I'm
73:28 - going to print the library's
73:30 - name print
73:34 - libraryname
73:36 - New York Public
73:39 - Library then I'm going to
73:41 - print access the library objects list
73:46 - books
73:48 - method and here is my list of
73:50 - books although I'm going to reformat
73:53 - this so it looks better I'll use a for
73:56 - Loop for every
73:59 - book in Access our library
74:02 - objects list books method this will
74:07 - return a list we can iterate through it
74:10 - for every book in the list of books
74:13 - print each
74:16 - book all right here is our libraries
74:19 - name and each book in our list of
74:22 - books all right everybody so that's agre
74:25 - ation it represents a relationship where
74:27 - one object the whole contains references
74:31 - to one or more independent objects the
74:34 - books they can exist without one another
74:37 - and well everybody that is aggregation
74:39 - in
74:40 - Python all right everybody so today I
74:42 - got to talk about composition in python
74:45 - as we've discussed in the previous topic
74:47 - aggregation is a relationship where one
74:49 - object contains references to other
74:51 - independent objects they have a has a
74:55 - relationship composition on the other
74:57 - hand is when the composed object
74:59 - directly owns its components which
75:02 - cannot exist independently they have a
75:05 - owns a relationship aggregation has
75:09 - things composition owns things kind of
75:12 - like you're renting or you're owning
75:14 - something in this example we'll create
75:16 - three classes a class of
75:21 - engine a class of wheel
75:26 - and the composed object is going to be
75:28 - Class
75:30 - Car within our car class we will
75:33 - construct some engine and wheel objects
75:36 - we'll begin with our engine class we'll
75:38 - need a Constructor we'll Define that
75:40 - Define in knit let's say that with an
75:44 - engine we need a
75:46 - horsepower what is the power of the
75:49 - engine self. horsepower
75:52 - attribute equals the horsep power that
75:55 - we
75:56 - receive with our class of wheel we need
75:58 - a Constructor Define
76:02 - init let's add a size attribute what is
76:06 - the size of the
76:08 - wheel self. size equal
76:13 - size okay now with our car object now
76:17 - within our car class we need a
76:20 - Constructor we will need a make model
76:25 - the horsepower of the
76:28 - engine and size we'll say wheel
76:32 - size remember that you can rename
76:35 - parameters to something
76:36 - different we will assign these
76:38 - attributes self. make equals
76:41 - make self. model equals
76:46 - model here's where composition comes in
76:50 - we will define an
76:51 - attribute of engine then call the engine
76:56 - Constructor we have one argument to pass
76:58 - in
77:00 - Horsepower we will pass in the
77:02 - horsepower that we receive to the engine
77:07 - Constructor then we have to set up our
77:10 - wheels self. wheels equals now to
77:15 - construct a single wheel object we would
77:18 - call the wheel Constructor then pass in
77:21 - the wheel
77:23 - size however car have four wheels we
77:25 - don't want just one wheel so what we
77:28 - could do is write a list
77:32 - comprehension for every
77:34 - wheel in range four to iterate four
77:38 - times let's call the wheel
77:41 - Constructor and pass in our wheel
77:44 - size this list comprehension will create
77:47 - four wheel objects for
77:49 - us the reason that this is considered
77:51 - composition we're creating engine and
77:54 - wheel objects inside of this class car
77:57 - our class car owns an engine and owns
78:01 - four wheels we're not creating these
78:04 - objects outside of the car
78:07 - class let's create a car object car
78:10 - equals car we need a make model
78:14 - horsepower for the engine and wheel size
78:17 - so for my car let's say
78:20 - Ford Mustang for the horsepower I'll
78:24 - make up something
78:26 - 500 for the wheel size 18 in now just to
78:30 - make this more explicit I'm going to use
78:32 - keyword arguments but you don't have to
78:35 - so make equals Ford Model equals
78:40 - Mustang horsepower =
78:44 - 500 wheel size equal
78:48 - 18 let's create a method to display our
78:51 - car I would like the details Define
78:55 - display car no
78:58 - parameters let's return an F string
79:03 - let's begin with the make and model
79:04 - those will be easy display self. make
79:09 - and self.
79:11 - model let's take our car object use the
79:15 - display car
79:19 - method then I got to print it I
79:22 - forgot because we're returning a a
79:24 - string we're not printing it directly we
79:27 - have a Ford
79:29 - Mustang okay let's display the
79:32 - horsepower there's one additional step
79:34 - we are accessing self this car that
79:37 - we're creating but now we need the
79:39 - engine let's access the engine attribute
79:43 - and now with our engine our engine has
79:45 - an attribute of horsepower we'll use the
79:48 - attribute accessor that dot
79:52 - horsepower 500 I'll add HP meaning
79:59 - horsepower all right now for the wheels
80:01 - I'll add another placeholder access self
80:06 - access our
80:07 - Wheels now our Wheels it's a list I
80:11 - don't need all four wheels I just need
80:14 - one if I was to take my list then access
80:18 - the size this is what it'll give me list
80:22 - object has no attribute size
80:25 - so we need to access one of the elements
80:27 - of our list of Wheels let's just say the
80:30 - first wheels at index0 then give me the
80:34 - size 18 and that's going to be
80:40 - inches all right then let's create a
80:42 - second car object before we finish we
80:45 - have car
80:46 - 1 Car 2 equals
80:49 - car we need a make model horsepower for
80:52 - the engine and wheel size for the Wheels
80:56 - I will pick a
80:58 - Chevrolet Corvette and I'm just going to
81:01 - make up some numbers the horsepower is
81:04 - 670 and the wheel size is
81:07 - 19 let's display Car 2 Car 2 called the
81:11 - display car method we have a Chevy
81:15 - Corvette with horsepower of 670 the
81:18 - wheel size is 19
81:20 - in so our car class it owns some objects
81:24 - it owns an engine and it owns four
81:26 - wheels that's why composition is
81:28 - different from aggregation if I were to
81:31 - delete these two cars this engine and
81:34 - the four wheels would stop existing
81:37 - whereas in our library example in the
81:38 - last video if I was to delete the
81:41 - library object the books would still
81:43 - exist all right everybody so that's
81:45 - composition it's where a composed object
81:48 - our car directly owns its components our
81:52 - car owns an engine and it own phones for
81:55 - Wheels we're creating them within the
81:57 - class and well everybody that's
81:59 - composition in
82:01 - Python hey what's going on everybody so
82:04 - in today's video I got to talk about
82:05 - nested classes in Python a nested class
82:08 - is a class defined inside of another
82:11 - class this has a few benefits we can
82:13 - logically group classes that are closely
82:16 - related we can encapsulate private
82:18 - details that aren't relevant outside of
82:20 - the outer class and also it helps keep
82:23 - our namespace clean it reduces the
82:25 - possibility of naming conflicts so for
82:27 - example let's say we have two classes
82:30 - both named
82:32 - employee within this class I'm just
82:35 - going to print
82:36 - something this is the first
82:40 - class then let's copy our employee class
82:43 - paste it
82:45 - again this is the second
82:48 - class we have a naming conflict we have
82:51 - two classes with the same name if I were
82:53 - to run this program
82:55 - we will execute both this is the first
82:57 - class this is the second class it is
82:59 - fairly noticeable that we have two
83:01 - classes with the same name but with
83:03 - python we do a lot of importing and
83:05 - exporting of large files we may not
83:07 - realize there's a name conflict one
83:10 - concept that'll help us avoid naming
83:11 - conflicts is the use of nested classes
83:14 - let's say we have employees for a
83:16 - company and another set of employees for
83:18 - a nonprofit
83:20 - organization I could write something
83:22 - like this we'll create a class of
83:25 - company within this class of company we
83:28 - will have an in class of
83:30 - employee with our second employee class
83:32 - we will create an outer class of
83:40 - nonprofit this is perfectly fine we can
83:42 - have two classes with the same name as
83:45 - long as they're within different
83:47 - Scopes these two employee classes might
83:49 - have different attributes depending on
83:51 - who they work for if they work for a
83:53 - company they might might have one set of
83:55 - attributes if they work for a nonprofit
83:57 - they might have a different set of
83:58 - attributes so by using nested classes
84:01 - this helps keep the namespace clean we
84:03 - can reuse this employee class because
84:06 - they have different Scopes now what
84:07 - we're going to do in this
84:09 - example what we'll do in this example is
84:11 - create some employee objects that belong
84:13 - to a company object as a placeholder for
84:16 - now I'll write pass within the employee
84:19 - class with our class of company let's
84:21 - define a Constructor do pay attention to
84:24 - the indentation we are within the
84:26 - company class but not the employee class
84:29 - this Constructor is for the company the
84:31 - company object we're going to
84:33 - create if we construct a company object
84:36 - we need a company name such as the
84:40 - Crusty
84:41 - Crab I will assign self. company name
84:46 - equals the company name that we
84:48 - receive we are also going to declare an
84:51 - attribute of employees
84:54 - this attribute will be an empty list we
84:57 - will append employee objects to our list
84:59 - of
85:00 - employees then we will create a method
85:03 - to add
85:07 - employee we will need a name meaning
85:09 - name of the employee and a position
85:13 - what's their job for now I'll write pass
85:16 - we'll get back to this
85:18 - later and I will Define a method of list
85:23 - employees
85:26 - and again I'll write pass okay let's be
85:29 - sure that our company name
85:33 - works I'm going to create a company
85:35 - object company equals company but I have
85:39 - to pass in a company
85:41 - name I will pick the Crusty
85:44 - Crab then just to be sure that this
85:47 - works I will display our company's
85:50 - company name attribute
85:55 - that would give me the Crusty
85:57 - Crab so we know that that
86:00 - works within our employe class let's
86:03 - define a Constructor Define
86:06 - innit we need a name and a
86:11 - position self. name equals
86:15 - name
86:18 - self.pos equals
86:20 - position let's create one more method
86:25 - Define get details we will return the
86:29 - details of an employee all we're going
86:32 - to do is return an FST string add two
86:36 - placeholders we will return self.
86:39 - name and
86:43 - self.pos all right now within our ad
86:45 - employee
86:47 - method we will construct a new employee
86:51 - object equals now if if we're going to
86:54 - access this inner class of employee
86:57 - we're going to prefix
86:59 - self self meaning this company object
87:02 - that we're currently working
87:03 - with we need the class of employee then
87:07 - we'll call The Constructor but we have
87:09 - to pass in a name and a position when we
87:12 - receive a name and a position we will
87:16 - pass that to the employee
87:17 - Constructor once we have our new
87:19 - employee object we're going to take our
87:22 - list of employees
87:24 - self.
87:27 - employees use the append method of lists
87:31 - then add our object of new employee to
87:34 - this empty
87:35 - list let's create a few employee objects
87:38 - we'll take our company use the add
87:41 - employee method that we have created we
87:44 - need a name and a
87:47 - position I will pick Eugene for Eugene
87:51 - Krabs his position is that he is the
87:54 - manager let's create two more take our
87:58 - company object use the ad employee
88:01 - method that we have defined I will pass
88:03 - in a name of this employee as SpongeBob
88:07 - his position is that he is a cook then
88:10 - we have Squidward company. add employee
88:14 - method first name
88:18 - Squidward his position is that he is a
88:21 - cashier so this should run with no
88:23 - problem
88:24 - s now I would like to list all of the
88:27 - employees at this company we'll need to
88:30 - rely on this get details
88:32 - method so when we list our employees we
88:36 - will return a list
88:39 - comprehension for every
88:42 - employee in self.
88:45 - employees this is an attribute it's a
88:48 - list of employee objects it is iterable
88:54 - take each employee that we're iterating
88:57 - through call the get details method and
89:01 - return
89:03 - it now if I was to take my company then
89:07 - call the list employees
89:11 - method whoops I forgot to print
89:16 - it we will print each employees name and
89:20 - their
89:21 - position however I think this would look
89:23 - better if we were to use a for
89:25 - Loop for
89:28 - every
89:29 - employee in take our
89:33 - company call the list employees
89:37 - method during each
89:40 - iteration we will print each
89:49 - employee we have Eugene that's Mr Krabs
89:53 - the manager SpongeBob The Cook and
89:55 - Squidward the cashier to demonstrate the
89:58 - reusability of classes let's create a
90:00 - second company object that has its own
90:04 - employees let's rename company as
90:06 - company
90:08 - one then we will create Company
90:13 - 2 Company 2 equals called the company
90:16 - Constructor my second company will be
90:19 - the Chum
90:21 - Bucket we'll take Company 2 then add two
90:25 - employees company 2. add
90:30 - employee we will pick
90:33 - shelden Sheldon is the
90:40 - manager company
90:42 - 2. add
90:46 - employee Karen will be the
90:51 - assistant for every employee in Company
90:54 - 2 list the employees during each
90:57 - iteration print the current
91:01 - employee we have Sheldon that's
91:03 - Plankton's first name he's the manager
91:06 - and Karen is his assistant all right
91:09 - everybody so those are nested classes
91:11 - it's a class defined inside of another
91:13 - class you have an inner class and an
91:15 - outer Class A few of the benefits is
91:18 - that we can logically group classes that
91:20 - are closely related such as having
91:22 - employee objects within a company object
91:25 - we can encapsulate private details that
91:28 - aren't relevant outside of the other
91:29 - class we may have no need to create
91:31 - employee objects outside of this class
91:34 - and by using nested classes it helps
91:36 - keep the name space clean it reduces the
91:39 - possibility of naming conflicts with
91:41 - another type of organization we could
91:43 - create another inner employee class and
91:46 - well everybody those are nested classes
91:48 - in
91:49 - Python hey what's going on everybody
91:52 - today I'm going to talk about static
91:53 - meth methods in Python a static method
91:56 - is a method that belongs to a class
91:59 - rather than any object from that class
92:02 - any instance instance methods we're
92:05 - already familiar with them they are
92:07 - methods that belong to individual
92:08 - objects created from that class they're
92:11 - best for operations on instances of that
92:13 - class any objects whereas static methods
92:17 - they're best for utility functions
92:19 - within a class that do not need access
92:21 - to class data I'll demonstrate the
92:24 - differences between an instance method
92:25 - and a static method we'll Begin by
92:28 - creating a class of
92:31 - employee we'll need a Constructor let's
92:34 - define
92:36 - that to create an employee object we'll
92:38 - need a name and a job
92:41 - position we will assign self. name
92:46 - equals name self.
92:49 - position equals
92:52 - position we will create an instance
92:55 - method of get info we will return
92:58 - employee
92:59 - info we will return an F string where we
93:04 - will display self.
93:07 - name equals
93:13 - self.pos get info is an instance method
93:17 - each object that we create from this
93:19 - class will have their own get info
93:21 - method to return the information on that
93:23 - object object the object's name and the
93:26 - object's position now we'll create a
93:28 - static
93:29 - method to create a static method we need
93:32 - a decorator of static method static
93:36 - methods are best for General utility
93:39 - functions within a class we'll Define a
93:41 - method to check to see if a job a
93:44 - position is valid which we will name is
93:49 - valid
93:51 - position so static methods they don't
93:54 - have self as the first argument we're
93:56 - not working with any objects created
93:58 - from this class to check to see if a
94:00 - position is valid we will pass in a job
94:02 - position which I will name as
94:06 - position I will create a list of
94:10 - valid
94:13 - positions let's assume that our company
94:15 - is the Crusty Crab what are some valid
94:18 - positions a manager is a valid position
94:21 - a cashier
94:24 - a cook then let's say a
94:29 - janitor then we will return we'll use a
94:32 - membership
94:34 - operator check if position that we
94:38 - receive is in our list of valid
94:45 - positions what we have done is that we
94:47 - have created a static method we don't
94:49 - need to rely on any objects to use this
94:52 - method for example
94:55 - to use a static method we will use the
94:57 - name of the class rather than any object
95:01 - that we create from this class such as
95:04 - this we don't need to do
95:07 - that we type the class name followed by
95:10 - the static method is valid
95:16 - position then I did set this up to
95:19 - accept one argument let's check to see
95:22 - if a cook is is a valid
95:26 - position then I do need to print this
95:29 - what is the
95:31 - output a cook is a valid position what
95:35 - about a rocket
95:37 - scientist that would probably be sy's
95:39 - job that is false a rocket scientist is
95:43 - not a valid position at the K crusty
95:46 - crab this is a static method it belongs
95:49 - to the class not any object created from
95:51 - that class now let's let's create a few
95:54 - employee objects let's say employee 1
95:58 - equals a new
96:00 - employee we have to pass in a name and a
96:03 - job Eugene will be the first name that's
96:06 - Mr Krabs he will be a
96:10 - manager employee
96:12 - 2 equals
96:15 - employee
96:18 - Squidward will be a
96:21 - cashier employee 3
96:25 - equals
96:27 - employee employee 3 will be
96:29 - SpongeBob SpongeBob will be a
96:33 - cook to call an instance method we have
96:36 - to access one of the instances of the
96:38 - class in order to use
96:40 - it if I want to check the info on
96:42 - employee 1 I will access that object
96:45 - that
96:46 - instance use the get info method then I
96:51 - need to print it
96:54 - take employee one get the info Eugene is
96:58 - the manager let's do this with employee
97:01 - 2 and employee
97:05 - 3 Eugene Mr Krabs is the manager
97:09 - Squidward is the cashier SpongeBob is
97:11 - the cook for an instance method you
97:14 - access an object then call the instance
97:17 - method with the static method you only
97:20 - need to access that class you don't even
97:22 - need to create any objects from that
97:24 - class it's a general utility
97:27 - method all right everybody those are
97:30 - static methods they're a method that
97:32 - belongs to a class rather than any
97:34 - objects created from that class they're
97:37 - usually used for General utility
97:39 - functions that do not need access to
97:41 - class data and well everybody those are
97:44 - static methods in
97:46 - Python hey what's going on people so
97:48 - today I got to talk about class methods
97:50 - in Python a class method allow
97:53 - operations related to the class itself
97:56 - they take CLS as the first parameter
97:58 - whereas instance methods will take self
98:01 - self refers to any object created from
98:03 - that class CLS meaning class refers to
98:07 - the class not any objects here's an
98:10 - example we will create a class of
98:14 - student we'll need a Constructor to
98:16 - construct some student
98:18 - objects all students will have a name
98:22 - and a GP
98:25 - self. name equals name self. GPA equals
98:32 - GPA we will also create a class variable
98:35 - for this demonstration of count we will
98:38 - count how many students we
98:41 - create whenever we construct a student
98:44 - object we will access the class of
98:46 - student take our count variable
98:50 - increment it by one whenever we create a
98:52 - student object object increase count by
98:56 - one I will create an instance method of
99:00 - get
99:02 - info instance methods have self as the
99:05 - first parameter we're referring to the
99:08 - object we're currently working with I
99:11 - will return an F string where we will
99:15 - display the students name and their GPA
99:18 - self.
99:20 - name self. GPA
99:24 - I'll add a comment that this is an
99:27 - instance
99:29 - method Now to create a class method to
99:33 - work with class data we will declare a
99:35 - class method with a class method
99:38 - decorator class
99:41 - method what we're going to do is Def
99:43 - find a method to get the count the class
99:47 - variable of
99:48 - count this method will be called get
99:52 - count
99:53 - rather than self as the first parameter
99:56 - we'll be working with a class CLS
99:59 - meaning
100:00 - class I will return an F
100:03 - string total number of
100:08 - students add a
100:10 - placeholder CLS
100:13 - count Let's test this to call a class
100:17 - method you take the name of the class
100:19 - followed by the class method get count
100:23 - and then then we do need to print
100:28 - this what is the count of my current
100:30 - students total number of students is
100:33 - zero let's create a few student objects
100:37 - we will create student one equals called
100:39 - the student Constructor we have to pass
100:42 - in a name and a GPA let's say that the
100:45 - name is SpongeBob SpongeBob has a GPA of
100:49 - 3.2 we'll create two more students
100:53 - student two student three student two
100:57 - will be
100:58 - Patrick Patrick has a
101:02 - 2.0 then Sandy Sandy Smart in fact she's
101:06 - a genius she has a perfect
101:09 - 4.0 now let's count the number of
101:12 - students total number of students is
101:15 - three when we call this class
101:18 - method we can access or modify class
101:22 - data this class variable of count rather
101:26 - than using self we use CLS for the
101:29 - class let's create one more class method
101:33 - this time I'll calculate the total GPA
101:35 - of all my
101:37 - students we'll need a class variable to
101:40 - hold that data let's say total GPA
101:45 - equals
101:46 - z whenever we construct a student object
101:50 - we will access our class of student get
101:53 - the total
101:55 - GPA then add plus equals this student's
101:59 - GPA that we have just created basically
102:03 - speaking the total GPA this variable is
102:06 - going to accumulate all of the GPA of
102:08 - every student and store it as a sum to
102:12 - find the average we're going to divide
102:13 - it by the count the number of students
102:16 - we'll do that within a class method to
102:18 - create a class method again we need to
102:20 - use the class method decorator
102:24 - I will Define a method of get average
102:28 - GPA the first parameter is CLS for
102:32 - class I will check if CLS count the
102:37 - count variable of my
102:39 - class is equal to zero that means if we
102:43 - have no students if that's the case if
102:45 - there's no students we're going to
102:47 - return
102:48 - zero because otherwise we're going to
102:50 - divide by zero and we'll get an error
102:54 - else we're going to return an F
102:57 - string follow this formula we're going
103:00 - to take the total GPA of my class class.
103:04 - total GPA divided by class. count the
103:08 - number students we have that's how to
103:11 - calculate the average
103:13 - GPA after getting the count of the
103:15 - number students to access a class method
103:18 - we take the name of the class student
103:21 - call the class method get average
103:24 - GPA then I will print
103:30 - it total number of students is three the
103:34 - average GPA is 3.06
103:38 - repeating after calculating the average
103:40 - I'm going to add a format specifier of
103:43 - 2f just around to two decimal
103:46 - places and I'll add average GPA colon
103:50 - space then we'll calculate the average
103:55 - all right everybody those are class
103:57 - methods instance methods are best for
104:00 - operations on instances of the class any
104:03 - objects static methods are best for
104:06 - General utility functions which do not
104:09 - need access to class data class methods
104:12 - are best used when we're working with
104:14 - class level data or we require access to
104:17 - the class itself such as when we're
104:19 - working with class variables rather than
104:22 - using self as the first parameter we're
104:24 - going to use CLS meaning class and well
104:27 - everybody those are class methods in
104:31 - Python yo what's going on people so
104:34 - today I'm going to explain magic methods
104:36 - in Python magic methods are also known
104:39 - as Dunder methods meaning double
104:41 - underscore you typically find these
104:43 - within classes we're already familiar
104:45 - with one of them are Dunder init method
104:48 - we have double underscores on the left
104:49 - and double underscores on the right but
104:52 - there are others I'll cover a few of the
104:54 - more beginner friendly ones so what
104:56 - these methods do is that they're
104:58 - automatically called by using some of
105:00 - pythons built in operations such as
105:03 - printing an object seeing if two objects
105:05 - are equal greater than or less than when
105:09 - we use many of Python's built-in
105:10 - operations with objects we can Define
105:13 - and customize the behavior of those
105:15 - objects so in this demonstration I'm
105:18 - going to create a class of book we will
105:21 - construct some book objects
105:23 - we will Define a magic method a Dunder
105:26 - method of init to initialize these
105:29 - objects for a book we need a title an
105:33 - author and the number of pages we'll say
105:37 - num
105:39 - Pages self. tile equals
105:43 - title self.
105:46 - author equals
105:48 - author self. number of pages
105:53 - equals number of pages when we call the
105:55 - class of book we Are automatically
105:57 - calling Dunder init so let's create a
106:00 - book object book one equals
106:04 - book we need a title an author and
106:07 - number of pages so since we're dealing
106:09 - with this topic of magic methods I'll
106:11 - pick some fantasy related books for my
106:14 - first book I'll pick the
106:15 - Hobbit that's the title the author is
106:21 - JRR token the number of pages is
106:25 - 310 so for my next
106:28 - book book
106:30 - two I will
106:32 - pick Harry
106:35 - Potter and the philosopher
106:42 - stone the author is JK
106:46 - Rowling the number of pages is
106:50 - 223 then we have book three
106:55 - for my third book I will pick The
106:58 - Lion the
107:00 - Witch and the
107:04 - Wardrobe the author is CS
107:08 - Lewis the number of pages is
107:12 - 172 okay here are my three book objects
107:15 - when we call the class of book and pass
107:17 - an arguments we will call the dunder
107:20 - init method it's a magic method it's
107:23 - automatically called behind the scenes
107:25 - within this magic method we can Define
107:28 - and customize the behavior of objects
107:30 - and in this example we're just assigning
107:32 - the attributes of title author and
107:35 - number of pages that is one built-in
107:38 - operation of python what would happen if
107:40 - I was to print book one directly to the
107:44 - console here's what happens well we're
107:47 - given a memory address here's book two
107:51 - and book three
107:53 - well we can customize this
107:57 - Behavior we will use the dunder string
108:01 - method double underscore St Str meaning
108:04 - string double underscore again we have
108:07 - one parameter of self instead of
108:10 - returning a memory address we can
108:12 - customize this
108:13 - behavior let's instead return an FST
108:17 - string I'll add two placeholders we will
108:20 - display self. tile the title of the book
108:24 - by self.
108:26 - author and I'll place the title within
108:29 - single
108:30 - quotes now let's print book one we have
108:34 - The Hobbit by JRR
108:36 - tolken let's print book
108:39 - two Harry Potter and the philosopher
108:41 - stone by JK Rowling and book three The
108:45 - Lion the Witch and the Wardrobe by CS
108:48 - Lewis so that is thunder string we can
108:51 - return a string represent a of the
108:53 - object when we print it directly to the
108:56 - console here's another Dunder method we
108:59 - can check to see if two objects are
109:01 - equal I will
109:03 - print is book one equal to book
109:08 - two that gives me
109:11 - false if they were to have the same
109:15 - title the same
109:17 - author and the same number of
109:20 - pages then python would say they're not
109:23 - equal still so let's customize this
109:29 - Behavior we will Define a method of
109:32 - Dunder equals which is just
109:35 - EQ for parameters we have self the first
109:37 - book we're examining in this case book
109:40 - one and other other means the other book
109:44 - we're examining two objects for
109:46 - equality to do that we'll see if the
109:49 - title of two books and the author is the
109:52 - same
109:54 - we'll disregard the number of pages you
109:57 - can have two different versions of the
109:58 - same book they might have different font
110:00 - sizes or the dimensions of the physical
110:03 - Pages might be
110:04 - different so we will return a Boolean
110:07 - value we will examine if self that's the
110:11 - first book is the title
110:13 - attribute equal to our other books title
110:18 - and is the author of the first book
110:21 - self. author
110:23 - equal to our other books
110:25 - author if I were to run this we get
110:28 - false book one does not equal book two
110:32 - but if they have the same title I'm
110:34 - going to replace these and the same
110:39 - author then they would be equal and
110:42 - we'll disregard the number of pages
110:44 - let's say that with this version of The
110:46 - Hobbit they're using a smaller font size
110:48 - so there's less
110:50 - Pages we're using under equals to
110:53 - compare if two objects are
110:55 - equal what if I was to print book two is
111:00 - less than book
111:02 - three like what does that even mean and
111:05 - I'm just going to get rid of these two
111:08 - lines type error less than is not
111:11 - supported between instances of book and
111:14 - book so we can't use less than on two
111:17 - objects but we can customize that
111:19 - behavior by using Dunder less than which
111:22 - is just LT we're examining one book and
111:27 - the other
111:27 - book self and
111:30 - other let's compare the number of pages
111:34 - we'll compare if the pages of book two
111:37 - is less than book three we will return a
111:40 - Boolean
111:41 - value is self. number of pages less than
111:47 - other. number of
111:50 - pages so now this should not give us an
111:53 - error book two does not have less Pages
111:57 - than book
111:58 - three another would be greater then I'll
112:01 - just copy what we have Dunder GT for
112:05 - greater than for our first book of self
112:08 - is it greater than the number of pages
112:10 - of the other
112:15 - book well that's true the number of
112:18 - pages of book two is greater than book
112:21 - three let's let's use Dunder add to add
112:24 - the pages of two books together what
112:26 - would happen if I were to add two books
112:28 - together book two plus book
112:30 - three well we get a type error
112:33 - unsupported operand for book and
112:36 - book well to customize the behavior of
112:39 - addition we will Define Dunder
112:43 - add we have self and other for the other
112:47 - object let's add the pages together of
112:49 - two books maybe we need a summer reading
112:52 - list and we would like to see what the
112:53 - total number of pages is I will return
112:58 - self. number of pages attribute plus our
113:02 - other books number of
113:07 - pages that would give me
113:09 - 395 that's 223 + 172 heck I'll even put
113:14 - this within an F string CU why not
113:23 - then I will add the word
113:24 - Pages 395
113:28 - Pages within an object we can search for
113:31 - a keyword within one of the attributes
113:35 - so let's find the word the lion within
113:37 - book three to do that I would write a
113:39 - statement like this Lion in book
113:45 - 3 Type error argument of type book is
113:49 - not
113:50 - iterable we will Define Define Dunder
113:56 - contains besid self we will pass in a
113:59 - keyword a keyword that we're searching
114:03 - for I will return then we'll use the in
114:06 - membership operator is our keyword in
114:11 - self. tile I'm looking for the word lion
114:14 - that's going to return true if lion is
114:17 - in the title of this book or is our
114:20 - keyword
114:22 - in self. author maybe we're searching
114:25 - for an author let's try that
114:29 - again that returns true lion is in book
114:33 - three however lion is not within book
114:36 - one that's
114:38 - false is rolling in book two that's the
114:43 - author that is true is rolling in book
114:48 - three that is
114:50 - false that is thunder contains
114:53 - we are searching for a keyword in an
114:57 - object now we could search for a key
114:59 - given an object for book one we'll use
115:02 - the index operator and look up an
115:05 - attribute let's get the title of book
115:09 - one the default behavior is that we get
115:13 - a type error book object is not
115:17 - subscriptable so to customize this
115:19 - Behavior we will use Dunder get
115:25 - item besides self we have one parameter
115:28 - of key we're accessing book attributes
115:31 - by indexing with this object return the
115:35 - value at this key what's that
115:38 - attribute we will check if our key that
115:41 - we
115:42 - receive is equal to title which it is in
115:47 - this case we will return self. tile
115:51 - What's the title of the
115:53 - book so that would give me The Hobbit
115:56 - here's book two and book
116:00 - three what if the key is
116:05 - author none we didn't set that up
116:09 - yet if key is equal to
116:13 - author then return self.
116:18 - author the author of book three is CS
116:22 - Lewis two is JK
116:26 - rolling book one is JRR
116:30 - tolken what about number of pages num
116:35 - Pages well we're not set up for that
116:37 - yet I'm going to turn this into an else
116:40 - if
116:41 - statement else if
116:44 - key is equal to
116:47 - num
116:49 - Pages then we will return self.
116:53 - num
116:55 - Pages the number of pages in book one is
116:59 - 310 book two is
117:03 - 223 book three is
117:06 - 172 what if there is no key otherwise if
117:09 - there is no matching key I'll add an
117:11 - else statement let's return an F
117:16 - string key
117:19 - placeholder R key that we pass in as an
117:21 - argument
117:23 - was not
117:25 - found what do books not have well they
117:28 - don't have audio I guess unless it's an
117:30 - audio book is there a key of audio in
117:34 - book
117:35 - three there is not key audio was not
117:38 - found and I'll place that within single
117:42 - quotes much better all right everybody
117:45 - so those are magic methods also known as
117:48 - Thunder methods meaning double
117:50 - underscore they are automatic called by
117:53 - many of Python's built-in operations
117:55 - they allow developers to define or
117:58 - customize the behavior of objects when
118:00 - we use those built-in operations and
118:03 - well everybody those are magic methods
118:05 - in
118:06 - Python hey everybody so in today's video
118:08 - I got to talk about the property
118:10 - decorator in Python the property
118:12 - decorator allows us to define a method
118:14 - as a property we can access it like it's
118:17 - an attribute one of the benefits is that
118:19 - when Reading Writing or deleting
118:21 - attributes we can add additional Logic
118:24 - the property decorator gives us a getter
118:26 - method to read a Setter method to write
118:29 - and a deleter method to delete when
118:31 - working with attributes in this example
118:33 - we'll create a class of
118:36 - rectangle we need a Constructor let's
118:38 - define
118:39 - that when constructing a rectangle
118:42 - object we will need a width and a
118:45 - height we will assign the attribute of
118:49 - width equal to the width that we
118:51 - received when constructing this object
118:54 - self. height equals
118:57 - height let's construct a rectangle
118:59 - object rectangle equals
119:04 - rectangle we need to pass in a width and
119:07 - a height then I will print my
119:10 - rectangle's width rectangle. width and
119:13 - the
119:14 - height rectangle.
119:18 - height with my rectangle the width is
119:20 - three the height is four using the
119:22 - property decorator when reading these
119:25 - attributes of width or height I can
119:27 - write some additional logic let's say
119:29 - that when accessing the width or the
119:31 - height I would like to display one digit
119:33 - after the decimal then add centimeters
119:36 - here's one way in which I can do that
119:39 - for each of these attributes I'm going
119:41 - to create a method we will Define a
119:43 - method of width no parameters beside
119:46 - self for now I'll write
119:49 - pass and Define he height preceding each
119:54 - of these methods I will use the property
119:57 - decorator so at
120:00 - property now when accessing the width or
120:03 - the height will be returned with
120:05 - whatever is Within These methods of
120:06 - width and
120:07 - height but there's one change we're
120:09 - going to make to these attributes we'll
120:11 - set these attributes to be private
120:13 - prefix each of these attributes with an
120:17 - underscore this tells you and other
120:19 - developers that these attributes they're
120:22 - meant to be protected they're internal
120:24 - we shouldn't access the width or the
120:26 - height directly outside of this class
120:29 - technically we could I will access the
120:31 - internal version of width and
120:33 - height we get three and four but we do
120:36 - have a warning access to a protected
120:38 - member width of a class that applies to
120:41 - height as well our width and our height
120:44 - are only meant to be used inside of this
120:46 - class if we need to get the width and
120:48 - the height we will do so through these
120:50 - getter methods provided by the property
120:53 - decorator so when accessing the width
120:56 - let's return an F
120:59 - string I will access
121:02 - self. private
121:04 - width add a format specifier to display
121:08 - one digit after the decimal 1f followed
121:11 - by
121:12 - cenm we'll do this with the height as
121:15 - well we will return self. private height
121:22 - so now when we access the width or the
121:25 - height we will do so using these getter
121:28 - methods if I access these private width
121:30 - and height attributes
121:34 - instead again they will be three and
121:36 - four it's kind of like their raw these
121:39 - attributes are meant to be used
121:40 - internally inside of the class so that's
121:43 - the point of a getter method we can add
121:45 - additional logic when reading one of
121:47 - these attributes when we Tred to get
121:50 - them we can also add Setter methods if
121:53 - we would like to set or write these
121:55 - attributes here's how let's take our
121:58 - width we will create a decorator of at
122:01 - width.
122:03 - Setter when attempting to set the width
122:05 - we will do so using this method we will
122:07 - Define our method name of width we will
122:10 - have one parameter a new width we don't
122:14 - want the parameter name to be the same
122:16 - as the method name that's why we're
122:18 - naming it something
122:20 - different when setting the width let's
122:22 - check to see if the new width is greater
122:26 - than
122:27 - zero if so we will take self. private
122:31 - width equals our new
122:34 - width else let's print something let's
122:40 - print width must be greater than
122:46 - zero and let's do this with the height
122:52 - height. Setter
122:55 - Define height pass in a
122:58 - new height if our new height is greater
123:02 - than zero assign self. private height
123:06 - equals the new height else print height
123:11 - must be greater than
123:13 - zero before printing the width and the
123:16 - height let's take our
123:18 - rectangle width set it to be zero then
123:21 - see what happen
123:22 - s well we get that message width must be
123:26 - greater than zero if I were to set width
123:29 - to be
123:30 - five well that does work our width is
123:33 - now five let's change the
123:36 - height rectangle.
123:39 - height I will set this to be Nega
123:42 - 1 height must be greater than zero and
123:45 - the height hasn't changed what about
123:48 - six six does work when using these
123:51 - Setter methods we can add additional
123:54 - logic when writing or changing one of
123:56 - these attributes these are Setter
123:59 - methods now if you need to delete an
124:01 - attribute here's
124:04 - how there is a delete keyword we will
124:07 - delete our rectangle's
124:09 - width and delete our rectangle's height
124:12 - in this series we really won't be using
124:14 - the delete keyword but you should still
124:16 - know that it
124:17 - exists so we will create a deleter
124:20 - method
124:22 - at take one of the attributes in this
124:24 - example with we will create a deleter
124:27 - method the method name will be width the
124:31 - name of the
124:33 - attribute there will be no parameters
124:35 - besides
124:36 - self we will delete
124:40 - self. private width then let's print
124:44 - something just to confirm that this was
124:47 - deleted width has been
124:50 - deleted same thing applies to
124:54 - height take the attribute of height
124:58 - Define height delete private
125:05 - height height has been
125:10 - deleted when deleting our width or our
125:12 - height we get that confirmation message
125:15 - width has been deleted and height has
125:17 - been
125:18 - deleted all right everybody so that is
125:20 - the property decorator we can define a
125:22 - method as a property meaning it can be
125:25 - accessed as if it was an attribute one
125:28 - of the benefits is that we can add
125:29 - additional logic when we read write or
125:32 - delete attributes the property decorator
125:35 - gives us a getter Setter and deleter
125:37 - method getter methods to read Setter
125:40 - methods to write and deleter methods to
125:44 - delete and well everybody that is the
125:46 - property decorator in Python