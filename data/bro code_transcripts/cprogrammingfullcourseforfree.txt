00:00 - all right what's going on everybody it's
00:02 - you bro hope you're doing well and in
00:03 - this video i'm going to explain how we
00:05 - can get started writing code in c so sit
00:08 - back relax and enjoy the show
00:12 - if you wouldn't mind please like comment
00:15 - and subscribe one like equals one prayer
00:18 - for the youtube algorithm
00:20 - i'm going to tell you why you need to
00:22 - learn c c is a middle level language
00:25 - that originated in the 1970s and it is
00:28 - one of the most widely used programming
00:30 - languages to date on a spectrum of
00:33 - high-level languages to low-level
00:35 - languages c is a middle level language
00:39 - low-level languages are efficient they
00:41 - work closely with machine architecture
00:44 - they consume less memory and they're
00:46 - fast as however they're difficult
00:48 - to understand and it takes more time to
00:51 - write code that's in a low level format
00:53 - high-level languages are easier to work
00:56 - with easier to understand they allow for
00:58 - more abstraction but they're slower they
01:00 - use more memory and they're abstract so
01:03 - it's difficult to work with low level
01:05 - hardware and systems a major advantage
01:08 - of middle level languages is that they
01:10 - can act as a bridge between high-level
01:13 - software and applications as well as
01:16 - low-level hardware and embedded systems
01:18 - most compilers kernels and operating
01:21 - systems are written in c
01:24 - nearly all programming languages are
01:26 - influenced by c in some way c is what
01:29 - provided many of the original
01:31 - programming concepts such as variables
01:34 - data types loops arrays functions etc in
01:38 - fact the python language is written with
01:41 - c the default implementation is known as
01:44 - c python if you're already familiar with
01:47 - the programming language learning c will
01:49 - give you an even deeper understanding of
01:51 - how those operate c is literally
01:54 - everywhere from databases to
01:57 - self-driving cars operating systems to
01:59 - embedded systems it's been around for so
02:02 - long and used for so many purposes here
02:04 - are some important notes before we get
02:06 - started c is not an object-oriented
02:09 - language it's procedural not abstract c
02:12 - plus plus is an object-oriented
02:14 - extension of c if you know c you already
02:18 - know some c plus plus however c is a
02:21 - difficult language for beginners don't
02:23 - get discouraged you can do it so what
02:25 - you'll need you'll need an ide an
02:28 - integrated development environment which
02:30 - is basically a fancy text editor to help
02:33 - us write c code as well as a gnu
02:37 - compiler collection which we abbreviate
02:39 - to simply gcc this compiles or otherwise
02:44 - converts c code to machine code you know
02:47 - all those ones and zeros that a machine
02:49 - can read let's begin by downloading an
02:51 - ide i recommend vs code it's flexible
02:54 - and you can use vs code for more than
02:56 - just c
02:57 - all right what you're gonna do is head
02:59 - to code.visualstudio.com
03:02 - and then look for this drop down menu to
03:04 - install for your operating system i'm
03:06 - running windows i'm going to install for
03:08 - windows and then i will simply just open
03:11 - when done
03:12 - okay accept the license agreement next
03:16 - you can create a desktop icon and add to
03:18 - path next
03:20 - then install
03:22 - and then give it a second
03:24 - or a couple minutes
03:26 - then you can launch this if you prefer i
03:28 - think i will okay we are now within
03:30 - visual studio head to the left hand menu
03:32 - for extensions we're going to install
03:34 - two extensions c
03:36 - c plus plus that contains intellisense
03:39 - and a couple other useful things so
03:41 - install that
03:42 - and then next we will install code
03:45 - runner code runner
03:47 - install after installing these
03:49 - extensions you may need to restart vs
03:51 - code
03:54 - okay then we are going to add a new
03:56 - folder go to the left-hand menu add
03:58 - folder i'll create a new folder on my
04:00 - desktop so i'll right click go to new
04:04 - folder
04:06 - i'll name this c files
04:09 - then add
04:11 - i think you might have to click within
04:12 - the folder
04:14 - okay we now have a folder named c files
04:17 - then to create a new c file go to new
04:20 - file after clicking this folder
04:22 - i'll name this hello world and make sure
04:24 - that it ends with the c extension
04:27 - helloworld.c
04:28 - and we now have a c file that we can
04:30 - work with and on this tab at the top
04:33 - this says hello world dot c now the next
04:36 - thing that we'll need is that gcc
04:38 - compiler to convert c code to machine
04:41 - code now if you're running windows this
04:43 - is how to check to see if you have a gcc
04:45 - compiler already installed
04:47 - so you're going to open command prompt
04:51 - and enter this command g plus plus
04:54 - dash dash version i already have a gcc
04:57 - compiler already installed if you're
04:59 - getting an error then you'll probably
05:00 - have to download one here's an
05:02 - interruption from future bro i traveled
05:04 - from the future to the past to deliver
05:06 - you this message so if you need to
05:09 - install gcc on a mac operating system
05:12 - what you're going to do within a
05:14 - terminal window is enter the following
05:16 - command c lang dash dash version if c
05:20 - lang isn't installed enter the following
05:22 - command xcode dash select dash dash
05:26 - install and that's all there is to it if
05:28 - you need additional assistance you can
05:29 - always visit this webpage
05:32 - code.visualstudio.com
05:34 - docs slash cpp and if you're running on
05:37 - linux within a terminal window you'll
05:40 - enter this command instead gcc
05:43 - dash v if gcc isn't installed run this
05:46 - command
05:47 - sudo apt-get update and then next type
05:51 - in this long command and if you need any
05:53 - additional assistance or documentation
05:55 - you can always visit this webpage so
05:57 - google this min gw dash w64
06:01 - install.exe and the first link is for
06:04 - sourceforge so click on that
06:07 - then you can find this underneath home
06:09 - browse development compilers
06:12 - mingw64 for 32 and 64-bit windows and
06:16 - the download should start automatically
06:18 - so click next
06:21 - change the architecture to
06:24 - x8664
06:26 - next and then copy this path for the
06:28 - destination folder it's going to be
06:30 - relevant later
06:32 - then next next and finish
06:34 - now what we're going to do is add our
06:37 - path to our gcc underneath environment
06:39 - variables so open up control panel
06:45 - then go to system and security
06:48 - then system
06:50 - scroll down to advanced system settings
06:54 - underneath the advanced tab
06:56 - go to environment variables
06:58 - underneath path we are going to edit i
07:01 - already have this path configured so i'm
07:03 - going to delete this you probably won't
07:05 - have this setup and then new
07:08 - paste that file path to the gcc compiler
07:12 - then add slash min 64 slash bin then
07:16 - okay
07:18 - okay
07:19 - and then you can close out of everything
07:23 - and now we need to configure our build
07:25 - task so go to a terminal
07:29 - your default build task if nothing
07:31 - appears within the search box you may
07:32 - need to restart vs code i think i do
07:35 - so i'm going to restart it
07:38 - and then let's try that again terminal
07:40 - configure default build task and there
07:42 - it is i will select that
07:45 - this creates a json file that tells vs
07:47 - code how to compile the program and with
07:50 - that out of the way we can begin coding
07:52 - now before we do start coding anything
07:54 - i'm going to increase the font size
07:56 - because as you can see this font size is
07:58 - really small so within vs code to change
08:01 - the font size go to file preferences
08:05 - settings and you can change that here
08:07 - let's try maybe 20. you can also change
08:10 - the font family too if you want and
08:11 - everything
08:12 - uh but let's close out of that and try
08:14 - that again
08:15 - okay that isn't too bad i'll stick with
08:17 - this font size for now i also recommend
08:19 - enabling autosave that's going to save
08:21 - you a lot of headaches later in the
08:22 - future so go to file
08:25 - auto save
08:26 - okay the first thing that we're going to
08:28 - include within our c program is the word
08:31 - hashtag include
08:32 - so this is a pre-processor command that
08:36 - tells the compiler to include the
08:38 - contents of a file and the file that we
08:40 - would like to include is within angle
08:43 - brackets
08:44 - std for standard io input output dot h
08:49 - this file contains some useful functions
08:51 - related to input and output so we'll
08:53 - need that
08:54 - now the entry point of our program is
08:57 - the main function type int
08:59 - main parentheses curly braces anything
09:02 - within our main function is read
09:04 - procedurally starting from the top and
09:06 - working its way down so anything within
09:09 - this set of curly braces is within the
09:11 - main function and at the end of our main
09:13 - function we're going to add the
09:14 - statement return 0 semicolon a semicolon
09:18 - is used to terminate statements kind of
09:20 - like a period at the end of a sentence
09:22 - at the end of our main function we have
09:24 - this return zero statement this returns
09:27 - the exit status of our program we return
09:30 - a zero if our program runs successfully
09:32 - with no errors if there is an error then
09:35 - we'll return a 1. so now we can add
09:37 - anything that we want within this main
09:39 - function but we'll need return 0 at the
09:42 - end to check for any errors
09:44 - so let's print something to our console
09:46 - as output so to display something we're
09:48 - going to type print f parentheses
09:51 - semicolon because we end our statements
09:53 - with a semicolon and within the
09:55 - parentheses add a set of double quotes
09:57 - because we would like to literally print
09:59 - something and you can type in whatever
10:01 - you want let's say
10:02 - i like pizza
10:04 - then to run this code you can either
10:06 - right click then go to run code
10:08 - alternatively there is a run code button
10:11 - in the top right corner of the s code so
10:14 - after running this code this displays my
10:16 - output i like pizza so what if i would
10:19 - like to add a second line well i would
10:21 - just follow these steps again so i need
10:23 - another printf statement
10:25 - print f parentheses semicolon any text i
10:29 - would like to display i'll place that
10:30 - within a set of double quotes this time
10:33 - let's add a second line i like pizza
10:36 - it's really
10:38 - good
10:39 - and then save
10:40 - all right and this is what this looks
10:42 - like
10:44 - i like pizza it's really good so this is
10:47 - all one long line what if i would like
10:50 - my second line of text on the next line
10:52 - well i can add an escape sequence for a
10:55 - new line character so at the end of my
10:57 - printf statement within the double
10:59 - quotes i'll add
11:01 - backslash n for a new line character
11:04 - and let's try that again so i'm going to
11:06 - clear my output make sure i save and
11:09 - then run this again
11:11 - i like pizza it's really good and then
11:14 - we have that extra space at the bottom
11:15 - because we added an additional new line
11:17 - character which is optional
11:19 - also take notice too that we have this
11:21 - message exited with code equal zero so
11:25 - if there are no errors and your program
11:27 - runs successfully this function will
11:29 - return zero if there is an error well
11:31 - then this will return one so let's
11:34 - misspell something let's say instead of
11:36 - printf we just have print
11:38 - so save and then run this again
11:42 - okay it looks like we have an error
11:43 - exited with code equals one
11:46 - all right people well that's your first
11:48 - c program in the next video we'll cover
11:50 - escape sequences and comments i'll post
11:53 - this code to the comments section down
11:55 - below and pin it to the top if you would
11:56 - like a copy for yourself but yeah that
11:59 - is your first c program
12:02 - hey you yeah i'm talking to you if you
12:04 - learned something new then help me help
12:07 - you in three easy steps by smashing that
12:09 - like button drop a comment down below
12:12 - and subscribe if you'd like to become a
12:13 - fellow bro
12:18 - [Music]
12:38 - all right everybody welcome back in this
12:41 - video i'm going to show you all how we
12:42 - can compile and run a c program using
12:45 - command prompt in my text editor i have
12:48 - a simple c program that prints i love
12:50 - pizza it's really good what we'll need
12:52 - to do is open command prompt now before
12:55 - we begin we should make sure that we
12:56 - have a gcc compiler and to check that
12:59 - just type gcc
13:01 - minus minus version
13:04 - and it looks like i have one so if
13:05 - you're missing a gcc compiler check the
13:08 - first video in the series and i'll show
13:09 - you how to download one now step one to
13:12 - compiling a c file is that we need to
13:14 - change our active working directory so
13:16 - that it's pointing to the folder
13:18 - containing our c file an easy way to
13:20 - change that is that we need the file
13:21 - location so i'm going to right click on
13:23 - my c file go to properties copy this
13:26 - location and within command prompt i
13:28 - will type cd to change directory and
13:30 - then paste that location so our current
13:33 - active directory is pointing to that
13:35 - folder containing our c file and to
13:37 - compile a c file you type
13:39 - gcc
13:40 - the name of the file
13:42 - and mine is hello world dot c then hit
13:45 - enter so nothing appears to happen and
13:47 - that's good so let's take a look at the
13:49 - c folder again this is the file that we
13:51 - compiled it is an executable and all we
13:53 - have to do is run that so that is the
13:56 - third step a
13:58 - exe enter
14:00 - i love pizza it's really good so yeah
14:03 - that's how to compile and run a c file
14:05 - in command prompt first make sure that
14:07 - you have a gcc compiler that would be i
14:10 - guess step zero step one is to change
14:12 - the active working directory to the
14:14 - folder containing your c file compile
14:16 - the c file with gcc the name of the file
14:20 - and then run the compiled file a.exe so
14:23 - yeah that is how to compile and run a c
14:26 - file with command prompt if you found
14:27 - this video helpful please be sure to
14:29 - smash that like button leave a random
14:31 - comment down below and subscribe if
14:32 - you'd like to become a fellow bro
14:35 - hey y'all what's going on everybody it's
14:37 - you bro hope you're doing well and in
14:38 - this video i'm going to explain to both
14:40 - comments and escape sequences in c so
14:43 - sit back relax and enjoy the show
14:49 - all right welcome back so we have to
14:51 - discuss comments and escape sequences so
14:54 - a comment is some text that is ignored
14:57 - by the compiler that is used as an
15:00 - explanation description or a note for
15:03 - yourself or anyone else reading over
15:05 - your code so try to comment you will
15:07 - type
15:08 - two forward slashes then anything
15:10 - afterwards is considered a comment and
15:13 - will be ignored by the compiler this is
15:16 - a
15:17 - comment
15:19 - blah so if i was to run this
15:22 - this text will be ignored by the
15:23 - compiler and we do not see that as
15:25 - output i tend to use a lot of comments
15:28 - when explaining things so this is
15:29 - something you'll see fairly often in my
15:31 - videos now if you need a multi-line
15:33 - comment this is only for a single line
15:35 - comment if i was to type this again
15:37 - without those forward slashes this is a
15:39 - comment well our program thinks that
15:42 - this is some sort of code if we need a
15:44 - multi-line comment you will instead type
15:47 - forward slash asterisk then anything
15:49 - after is considered a comment you can
15:51 - see that this is all green now anything
15:53 - up to a asterisk and forward slash will
15:56 - be a multi-line comment
15:58 - this
15:59 - is a
16:01 - multi-line
16:04 - comment
16:05 - and again this is ignored by the
16:07 - compiler so if you need to write a note
16:10 - description or explanation for yourself
16:13 - or for somebody else you can write that
16:15 - within a single line comment or a
16:17 - multi-line comment and i use a lot of
16:19 - these for teaching purposes because i
16:21 - have a lot of explaining to do right
16:23 - okay let's move on to part two of this
16:26 - video we have escape sequences an escape
16:28 - sequence is a character combination
16:31 - consisting of a backslash followed by a
16:34 - letter or combination of digits they
16:37 - specify actions within a line of text
16:40 - otherwise known as a string so we
16:42 - learned in the last video that we can
16:44 - end our printf statement with a
16:47 - backslash n to create a new line this is
16:50 - the escape sequence for a new line and
16:52 - within a string of text a line of text
16:55 - and within a string of text we can add a
16:57 - new line wherever we want and as many as
17:00 - we want let's say that after each word
17:02 - within my line of text i would like to
17:04 - add each word to a new line so i can use
17:08 - the escape sequence for new line after
17:10 - each of these words so that would look
17:12 - like this i like pizza but you may have
17:15 - to work on the spacing though
17:18 - that's a little bit better so wherever
17:20 - you place a backslash n that will create
17:23 - a new line character another escape
17:26 - sequence is backslash t for a tab
17:29 - so let's say i have a few numbers here
17:31 - one two three and i would like to create
17:34 - even spacing between these numbers i can
17:36 - just add an escape sequence for a tab
17:38 - character one backslash t two backslash
17:42 - t
17:44 - and these numbers are spaced evenly
17:47 - or i can get really fancy and add a new
17:49 - line character
17:50 - then maybe a four
17:52 - tab five tab
17:55 - six new line character
17:57 - then maybe a7
17:59 - tab 8
18:01 - tab and then a 9.
18:05 - so now we have a grid of numbers all
18:07 - spaced evenly so that is the new line
18:10 - escape sequence and the tab escape
18:12 - sequence you can use them wherever and
18:14 - however many you want within a string of
18:17 - text within a printf statement what if
18:19 - we need to display quotes like we're
18:21 - quoting somebody
18:22 - i like pizza
18:25 - this is a quote from
18:27 - abraham
18:29 - lincoln
18:30 - probably i need to place quotes around i
18:34 - and pizza
18:36 - so if i were to write it like that well
18:38 - our program doesn't know where our
18:39 - string of text begins and ends it's kind
18:42 - of confused if we need to literally
18:44 - print double quotes we will add an
18:47 - escape sequence
18:48 - backslash then double quote
18:51 - and then add that here as well so this
18:53 - allows us to literally print some quotes
18:56 - as i'll put
18:58 - i like pizza abraham lincoln probably or
19:02 - if you need to display single quotes
19:04 - backslash single quotes
19:07 - so that's how to display single quotes
19:10 - and if you need to display a backslash
19:12 - that would be double backslashes
19:15 - this will literally print backslashes
19:18 - so yeah those are just a few escape
19:20 - sequences here's a list of a bunch of
19:23 - them but a lot of these really aren't
19:24 - going to be relevant to us so yeah those
19:27 - are comments and escape sequences and
19:30 - see if you found this video helpful
19:31 - please be sure to destroy that like
19:33 - button drop a random comment down below
19:35 - and subscribe if you'd like to become a
19:37 - fellow bro
19:39 - hey yeah it's you bro hope you're doing
19:41 - well and yeah we're doing stuff with
19:43 - variables today in c so sit back relax
19:47 - and well enjoy the show
19:50 - welcome back to another video so
19:53 - variables variables are allocated space
19:56 - and memory to store a value we refer to
19:58 - a variable's name to access the stored
20:01 - value
20:02 - that variable now behaves as if it was
20:05 - the value that it contains but to create
20:07 - a variable we first need to declare a
20:09 - name for a variable and then precede it
20:11 - with the type of data that we are
20:13 - storing creating a variable is done in
20:15 - two steps declaration and initialization
20:18 - so we need to first declare a variable
20:20 - to allocate some space in memory to
20:22 - store a value so we need to precede our
20:25 - variable name with the data type of what
20:27 - we plan on storing within this variable
20:30 - if i need to store a whole integer we
20:32 - would precede our variable name withint
20:34 - int for integer and let's say that this
20:37 - is variable x
20:38 - so this step is declaration we are
20:41 - creating space and memory to store a
20:43 - value and to actually store a value that
20:46 - step is initialization so we would take
20:49 - our variable name
20:50 - x in this example and set it equal to
20:52 - some value so we declared that this
20:55 - variable is an integer we can only store
20:57 - whole integers maybe the number one two
21:00 - three
21:01 - so this is
21:02 - initialization or you could combine
21:04 - these steps together and let's create
21:06 - into y into y equals 3 2 1. this is both
21:10 - declaration and initialization so
21:13 - creating and storing a variable takes
21:15 - two steps declaration and initialization
21:18 - and in order to create a variable you
21:20 - have to precede the variable name with
21:22 - the data type of what you plan on
21:24 - storing within that variable int for a
21:26 - whole integer but there's other data
21:28 - types too let's create some more
21:29 - variables what about int age with
21:32 - variable names you're not limited to
21:34 - only just x and y you can really name it
21:36 - whatever you want within some
21:38 - limitations but make sure that the
21:40 - variable name is descriptive of what it
21:42 - does so age is going to store an edge
21:44 - let's say that i am 21 years old so this
21:48 - is an integer a whole number if we need
21:50 - a number containing a decimal portion
21:52 - that would be a float for floating point
21:55 - number so one example of a variable that
21:58 - could contain a floating point number is
22:00 - a gpa grade point average let's say that
22:03 - my grade point average is a
22:05 - 2.05 so this is a floating point number
22:10 - it's a number that contains a decimal
22:12 - portion we can also store single
22:14 - characters with the char data type like
22:17 - you're pronouncing charizard and this
22:19 - will be a letter grade let's say now to
22:22 - store a single character we have to
22:23 - place it within single quotes when we
22:25 - initialize it with my grade variable
22:28 - what about a c like my average grade is
22:31 - a c remember everybody c's get degrees
22:34 - so char stores a single character
22:38 - now c isn't an object-oriented language
22:41 - so there is no string data type because
22:44 - strings are technically objects so if we
22:46 - would like to store like somebody's name
22:48 - we need a series of characters so we can
22:51 - create what is called an array and to
22:53 - create an array we would follow our
22:55 - variable name with a set of square
22:57 - brackets and then assign this equal to
23:00 - some string of text some series of
23:02 - characters place your series of
23:04 - characters within double quotes and we
23:06 - can store more than one character so
23:08 - this data type would be technically an
23:11 - array of characters i'll create a whole
23:14 - separate video on arrays this is
23:16 - basically how you can emulate a string
23:18 - it's really just a whole combination of
23:20 - single characters there's still a lot
23:22 - more data types than just these four i
23:24 - thought i would cover just some of the
23:26 - more basic data types just because in
23:28 - this video we're going to focus more on
23:30 - variables than data types i'm planning a
23:32 - separate video just dedicated to data
23:35 - types because there's way more data
23:37 - types than just these four there's bytes
23:39 - there's doubles there's longs etc now
23:42 - how can we display the value stored
23:45 - within a variable within a printf
23:47 - statement here's how we have to use what
23:49 - is referred to as a format specifier
23:52 - let's say we have a printf statement
23:55 - and i would like to display my age
23:57 - within a message so let's create some
23:59 - text you are
24:01 - age years old if i would like to display
24:05 - the value contained within my edge
24:07 - variable wherever i would like to insert
24:10 - that value i will place a format
24:12 - specifier which is represented by a
24:14 - percent sign and then follow this with a
24:17 - secret character that represents the
24:19 - data type of what we're inserting so if
24:22 - i need to display my age variable i will
24:24 - use a percent sign as a placeholder
24:27 - followed by d for decimal and then after
24:30 - my string of text outside of the double
24:32 - quotes add comma then the name of the
24:35 - variable you would like to insert at
24:37 - this placeholder so at this location i
24:41 - will insert age and then let's try this
24:44 - you are 21 years old so let's try that
24:47 - again with a different variable let's
24:49 - say let's go with name
24:51 - i'll add a second printf statement print
24:54 - f
24:56 - and then let's say hello
24:59 - and i would like to insert my name here
25:01 - so use a percent sign as a placeholder
25:04 - it's a format specifier then to display
25:07 - a character array that would be s for
25:09 - string
25:10 - and then add comma
25:13 - name
25:15 - oh then we may need to add a new line
25:17 - character to the end of these because i
25:19 - forgot let's try that again
25:21 - hello bro you are 21 years old okay
25:24 - let's display our
25:26 - grade printf
25:30 - then within quotes
25:32 - your average
25:34 - grade
25:36 - is
25:36 - then to display a character variable
25:39 - that would be percent c for character
25:42 - then outside of our double quotes add
25:44 - comma the name of the variable we would
25:46 - like to insert at this location so comma
25:49 - grid
25:50 - i think i'm just going to space these
25:52 - out a little bit
25:53 - okay then i will add a new line
25:55 - character to the end of this
25:59 - okay hello bro you are 21 years old your
26:01 - average grade is c
26:04 - then to display a float that would be
26:07 - percent f
26:08 - print f
26:11 - your gpa
26:13 - is
26:15 - percent f
26:16 - then i'll add a new line character
26:19 - so follow this with comma the name of
26:21 - the variable gpa
26:24 - okay your gpa is 2.05
26:28 - so later on we'll discuss more about
26:30 - format specifiers there's ways that we
26:32 - can format how our variables are
26:34 - displayed i just realized that i
26:36 - misspelled average twice so yeah those
26:38 - are variables they are allocated space
26:41 - and memory to store a value we refer to
26:44 - a variable's name to access the stored
26:47 - value
26:48 - that variable now behaves as if it was
26:51 - the value that it contains
26:52 - but to declare a variable we have to
26:54 - state what type of data that we are
26:56 - storing within that variable so yeah
26:59 - those are variables if this video helped
27:01 - you out help me out by smashing that
27:03 - like button leave a random comment down
27:04 - below and subscribe if you'd like to
27:06 - become a fellow bro
27:11 - all right what's going on people let's
27:12 - discuss more about data types we
27:14 - discussed a few in the last video but
27:15 - there's a few more that you should be
27:17 - made aware of so chars they store a
27:19 - single character and use the percent c
27:22 - format specifier to display a single
27:24 - character there's an array of characters
27:25 - which can store one or more characters
27:28 - then to display that you use percent s
27:30 - as the format specifier floats they will
27:32 - store a decimal number and we use the
27:35 - percent f format specifier to display a
27:38 - floating point number and then we have
27:40 - integers which only store a whole
27:42 - integer there is no decimal portion and
27:44 - we use percent d to display an integer
27:47 - now along with floats we have doubles
27:49 - doubles have double the precision of a
27:51 - float we can store even more significant
27:53 - digits floats use four bytes of memory
27:56 - they have 32 bits of precision and we
27:58 - can store between six to seven
28:00 - significant digits doubles they have
28:02 - eight bytes of memory double that of
28:04 - floats and they have 64 bits of
28:07 - precision and we can store between 15 to
28:09 - 16 significant digits with my float and
28:12 - my double i'm storing the first several
28:14 - digits of pi i'm going to attempt to
28:17 - display as many digits of pi as i can
28:20 - with a float so i'm going to display
28:22 - these so to display a float use percent
28:25 - f and lf for a double which means long
28:29 - float now by default when i use printf
28:31 - to display a floating point number or a
28:33 - double this will only display the first
28:36 - six to seven digits but we can actually
28:38 - change that we'll discuss more about
28:39 - these in the next video on format
28:41 - specifiers if i would like to display
28:43 - even more digits after the decimal i
28:45 - will add zero point and the amount of
28:47 - digits i would like to display so i
28:49 - would like to display 15 digits after my
28:52 - decimal and i'll do that for my double
28:54 - as well so after the percent signed 0.1
28:57 - f then add lf and let's take a look at
29:00 - these numbers okay after my two which is
29:03 - i believe the sixth digit after the
29:06 - decimal we actually lose our precision
29:08 - these numbers are not the same but our
29:10 - double will actually retain these
29:12 - numbers so point being a double is even
29:15 - more accurate than a floating point
29:17 - number there is more precision but it
29:19 - uses more memory a double uses eight
29:21 - bytes of memory because of this reason
29:23 - we tend to use doubles a lot more than
29:24 - floats just because they're more precise
29:26 - we don't want to lose our precision next
29:28 - up we have booleans to work with
29:30 - booleans and c include this at the top
29:33 - std bool.h booleans store true or false
29:38 - so they work in binary one represents
29:41 - true and zero represents false so when
29:43 - you need to declare a boolean variable
29:45 - you type bool then a variable name and
29:48 - you set it equal to true or false
29:50 - technically we only need one bit to
29:53 - represent true or false one for true and
29:56 - zero for false but this still uses up
29:58 - one byte of memory and then to display a
30:00 - boolean you can use percent d so if i
30:03 - was to display this boolean variable i
30:05 - would use percent d so one corresponds
30:09 - to true and zero corresponds to false
30:12 - although there are some tricks that we
30:14 - can do in the future where we could
30:15 - display the word to true or the word
30:17 - false but for now we're going to stick
30:19 - with percent d as the format specifier
30:22 - so these work in binary one for true
30:24 - zero for false now another thing that we
30:26 - can do with chars is that we can store a
30:29 - whole integer between the range of
30:31 - negative 128 to positive 127. so in this
30:35 - example we have char f and i will store
30:38 - the integer number 100 we can display
30:40 - this number as either a decimal an
30:43 - integer or a character so if i was to
30:46 - display this number as a character we
30:48 - will use the ascii table to convert this
30:51 - number to a character representation the
30:54 - ascii table has a range between 0 to 127
30:57 - so if i was to display this number as a
30:59 - decimal using the percent d format
31:01 - specifier of course this will display as
31:04 - 100 but if i was to convert this to a
31:07 - character using the percent c format
31:09 - specifier this has a corresponding
31:12 - character and that would be lowercase d
31:14 - so i'm actually going to change this to
31:16 - something else what about i don't know
31:18 - uh 120 so let's see what the character
31:21 - representation of that number is and
31:23 - that would be
31:25 - a lowercase x so you can use chars to
31:28 - store more than single characters you
31:30 - can also use them to store a whole
31:32 - integer however the range is between
31:34 - negative 128 to positive 127 because
31:38 - they have one byte of memory now there
31:41 - is a keyword unsigned so when you
31:43 - declare a variable that is unsigned we
31:46 - disregard any negative numbers so
31:49 - effectively this doubles our range with
31:51 - our positive numbers so if we have
31:54 - unsigned char we can store a number
31:56 - between 0 to positive 255 because we
32:00 - know we're not going to store a negative
32:02 - number so then if you need to display an
32:05 - unsigned character we can use just
32:07 - percent d i'm going to store 255 within
32:10 - my unsigned chart and that would be of
32:13 - course 255. however if we go beyond this
32:16 - range this will overflow and go back to
32:18 - zero
32:19 - so if i was to display this we have a
32:22 - warning unsigned conversion from int to
32:25 - unsigned chart so then this resets back
32:28 - to zero so if you go beyond the maximum
32:30 - range this will reset all the way back
32:32 - to zero whatever the beginning is so if
32:34 - you add this keyword unsigned you can
32:36 - effectively double the range of positive
32:39 - numbers that you can store within a
32:41 - variable by default most data types are
32:44 - already signed but we don't need to
32:46 - explicitly type that so point being with
32:49 - chars you can store more than a single
32:51 - character you can store a whole integer
32:54 - between ranges negative 128 to positive
32:57 - 127 if it's signed if it's unsigned you
33:01 - can store numbers between 0 to 255. you
33:04 - can display them as an integer by using
33:06 - the percent d format specifier or you
33:09 - could convert them to a character using
33:11 - the ascii table by using the percent c
33:14 - format specifier next we have short
33:17 - hints short ins use two bytes of memory
33:20 - they can store a number between negative
33:23 - 32
33:24 - 768 to positive 32
33:28 - 767 because while they use two bytes of
33:30 - memory they can only store a number so
33:33 - large and if it's an unsigned short int
33:36 - the range is instead between 0 to 65 535
33:41 - and we use the percent d format
33:43 - specifier to display a short in so
33:46 - within my printf statement i'm going to
33:48 - display these two numbers so i will
33:50 - display variable h and i h is a short
33:53 - integer and i is an unsigned short
33:56 - integer
33:57 - so these are the maximum values for a
33:59 - short integer and an unsigned short
34:02 - integer and like i discussed with chars
34:04 - if we go beyond this range we will
34:06 - encounter an overflow so i'm going to
34:09 - change this short end to 32768
34:14 - and let's see what number displays
34:17 - so this will overflow and reset this
34:19 - value back to the minimum value which in
34:22 - this case is negative 32
34:25 - 768 and if you do the same thing with
34:27 - the unsigned short integer that would be
34:30 - zero because that's the minimum value
34:32 - for an unsigned short integer so those
34:35 - are short integers they use two bytes of
34:38 - memory and they can store numbers
34:39 - between these ranges depending if it's
34:41 - signed or unsigned oh and another way of
34:44 - writing these you don't necessarily need
34:46 - to declare these with the word and you
34:48 - could just say short and that would do
34:50 - the same thing people usually just call
34:52 - them shorts instead of short ants so
34:55 - those are what shorts are now with
34:56 - integers we kind of discussed this in
34:58 - the last video just briefly integers
35:00 - store a whole number between just under
35:03 - negative 2 billion to just over positive
35:06 - 2 billion because they use 4 bytes of
35:09 - memory and we use the percent d format
35:12 - specifier to display a signed integer if
35:15 - that integer is unsigned the range
35:17 - changes from 0 to just over positive 4
35:21 - billion however there is a different
35:24 - format specifier to display an unsigned
35:27 - integer you instead use percent u so
35:30 - then let's display these percent d for a
35:32 - signed integer and percent u for an
35:36 - unsigned integer
35:38 - and these are the maximum numbers and
35:41 - then if i was to exceed the range
35:45 - this again would cause an overflow and
35:47 - reset these numbers back to their
35:49 - minimum values so those are standard
35:52 - integers they use four bytes of memory
35:54 - so they can store numbers between these
35:57 - ranges depending if they're signed or
35:59 - unsigned all right the last data type
36:01 - we're going to talk about for this topic
36:03 - is a long long integer now the reason
36:06 - that we have long twice is that with
36:08 - standard integers these are already
36:10 - considered longs but we don't need to
36:12 - explicitly type long for standard
36:15 - integers so to represent a really large
36:18 - number we can use a long long integer
36:21 - and these use eight bytes of memory the
36:24 - effective range for a signed long long
36:27 - integer is just underneath nine
36:29 - quintillion to just over nine
36:32 - quintillion and the format specifier for
36:35 - a long long integer one that is signed
36:38 - is percent lld
36:40 - now if it's unsigned that changes the
36:43 - range between zero to just over positive
36:46 - 18 quintillion and the format specifier
36:49 - is percent llu then let's display these
36:52 - so
36:53 - for a signed long long integer that is
36:56 - lld and if it's unsigned that is llu now
37:00 - we'll encounter a warning
37:02 - so this warning applies to our unsigned
37:05 - long long integer
37:07 - integer constant is so large that it is
37:10 - unsigned so one way in which we can
37:12 - prevent that warning is after our number
37:15 - within our unsigned long long integer
37:18 - add a u to the end of this so then we
37:20 - can display this number with no warning
37:22 - so since long long integers use so many
37:25 - bytes they can store a gigantic number
37:28 - we tend to not use long long integers
37:30 - very often because well we don't really
37:32 - have a need for this large of a number
37:34 - but in certain circumstances you might
37:36 - perhaps you're dealing with the speed of
37:38 - light or something you may need to use a
37:40 - long long integer but commonly we use
37:43 - standard integers a lot more well yeah
37:45 - everybody those are even more c data
37:47 - types we likely won't be using most of
37:49 - these but you should still be made aware
37:51 - of their existence i would say that
37:53 - we're going to focus on chars array of
37:56 - chars
37:57 - doubles booleans
37:59 - and integers so pay attention to those
38:02 - ones but you should still be made aware
38:04 - of the existence of other data types
38:06 - just in case you encounter them if you
38:08 - found this video helpful please smash
38:10 - that like button leave a random comment
38:11 - down below and subscribe if you'd like
38:13 - to become a fellow bro
38:18 - all right welcome back everybody in this
38:20 - video i'm going to show you while a few
38:21 - extra things that we can do with format
38:23 - specifiers using a format specifier
38:26 - within a printf statement we can define
38:28 - and format a type of data to be
38:30 - displayed to use a format specifier you
38:33 - use a percent sign then follow that
38:35 - percent sign with a certain character
38:37 - depending on the type of data you would
38:39 - like to display let's say that we have
38:40 - three variables maybe we have an online
38:42 - store or something like that so let's
38:44 - say that these are of the float data
38:47 - type and we'll have three items for sale
38:49 - item one and make up some price let's
38:51 - say that the first item is five dollars
38:53 - and seventy five cents
38:55 - and we have item two
38:58 - and this will be ten dollars even and
39:00 - then we have item three and this will be
39:03 - one hundred dollars and ninety nine
39:04 - cents so let's display item one item two
39:07 - in item three with a print f statement
39:09 - print f and within a string let's say
39:12 - item one colon space then i'll add a
39:17 - dollar sign wherever you would like to
39:19 - insert a value or variable you will use
39:22 - that format specifier the percent sign
39:24 - so after my dollar sign i'll add item
39:27 - one so that would be percent then for
39:29 - floats you need f and then after the
39:31 - string add comma
39:33 - item one then let's just make sure that
39:35 - this works so we're going to be
39:37 - formatting this output what if we don't
39:38 - want all the zeros we can set the
39:40 - decimal precision of a float or double
39:43 - after the format specifier add a dot and
39:46 - the amount of digits you would like to
39:48 - display if i would only like to display
39:50 - two digits after the percent i will add
39:52 - point two and this will only display two
39:55 - digits for the amount of cents that we
39:57 - owe okay now let's do the same thing for
40:00 - items two and three so item two
40:03 - item two
40:04 - item three
40:05 - item three
40:07 - okay then let's add a new line character
40:08 - because i forgot so new line
40:12 - new line and new line
40:15 - much better another thing that we can do
40:17 - with format specifiers is that we can
40:19 - set a minimum field width so just add a
40:22 - number after the percent sign let's say
40:24 - that i would like to allocate eight
40:26 - spaces worth of room to display my
40:28 - number
40:29 - so after the percent sign but before the
40:31 - decimal add how many spaces you would
40:33 - like to set for the minimum field width
40:36 - let's say eight
40:37 - and let's see the new output okay there
40:39 - we go however it's all right aligned if
40:41 - you would like this left aligned you
40:43 - would use a negative sign after the
40:45 - percent to left align all this this
40:47 - would be
40:49 - negative whatever number you would like
40:50 - to allocate so the number is left
40:53 - justified but we still have all of this
40:55 - room after so that's what a format
40:57 - specifier is it defines and formats a
41:00 - type of data to be displayed so place a
41:03 - format specifier within a string use a
41:05 - certain character for the type of dad
41:07 - you would like to display you can set
41:09 - decimal precision for floats and doubles
41:12 - you can set a minimum field width to
41:14 - display your output if you would like to
41:16 - line things up like you can see here and
41:18 - you can left or right align your output
41:20 - so yeah those are format specifiers if
41:23 - you found this video helpful please be
41:24 - sure to smash that like button leave a
41:26 - random comment down below and subscribe
41:28 - if you'd like to become a fellow bro
41:33 - hey everyone so i'm going to attempt to
41:36 - explain constants in about a minute a
41:38 - constant is a fixed value that cannot be
41:41 - altered by the program during its
41:43 - execution i have a variable pi pi equals
41:46 - 3.1415
41:48 - but what if we accidentally or somebody
41:50 - else changes the value of pi it's an
41:52 - important number pi now equals 420 69.
41:56 - since this value was changed this will
41:58 - alter the result of our program to
42:01 - prevent a variable or value from being
42:03 - changed we can turn that variable into a
42:06 - constant by preceding the data type with
42:09 - this keyword const and a common naming
42:11 - convention with constants is that you
42:13 - make all the letters uppercase although
42:15 - it's not necessary but it's considered
42:17 - good practice so if i attempt to take
42:20 - our constant and assign this a different
42:22 - value we'll run into an error error
42:25 - assignment of read-only variable pi that
42:27 - is what a constant is it's a fixed value
42:30 - that cannot be altered by the program
42:32 - during its execution and it provides a
42:34 - little bit of security so if you found
42:36 - this video helpful please be sure to
42:37 - smash that like button leave a random
42:39 - comment down below and subscribe if
42:41 - you'd like to become a fellow bro
42:45 - well well well welcome back so we need
42:48 - to talk about arithmetic operators
42:50 - because well this wouldn't be a full
42:52 - course without them so as you probably
42:53 - know arithmetic operators are well
42:56 - addition subtraction multiplication
42:58 - division and there's a few others too
43:00 - unique with programming such as modulus
43:03 - increment and decrement so let's go over
43:05 - a few let's say that we have int z and
43:08 - if we need to add two numbers we could
43:10 - say x plus y
43:12 - equals z and then display the sum which
43:15 - of course is seven so subtraction is
43:18 - well minus five minus two is three
43:21 - multiplication is an asterisk five times
43:24 - two
43:25 - equals 10. okay now pay attention to
43:27 - this with division so 5 divided by 2
43:30 - equals 2.5 right well that's where
43:33 - you're wrong it's 2 because we're
43:35 - storing the result within an integer and
43:37 - with integers we can only store whole
43:39 - numbers so we will lose that decimal
43:42 - portion it will be truncated there's a
43:44 - few things we'll need to change first
43:46 - we'll need to store the result within a
43:48 - float or a double and then let's display
43:50 - this percent f for a float okay another
43:53 - thing that we need to change too and
43:54 - that involves integer division if we're
43:57 - dividing by an integer we'll truncate
44:00 - that decimal portion there's one of two
44:02 - things we can do we can either change
44:04 - our divisor to a float
44:06 - or a double and that will solve that
44:08 - problem 2.5 or if we would like to keep
44:12 - this as an integer we can convert this
44:14 - integer to a float or double by
44:16 - preceding the divisor with
44:19 - float
44:20 - or double either one
44:23 - so if i would like to keep y as an
44:25 - integer and we divide x by y we will
44:28 - convert 2 into a float so 2.0 and store
44:32 - the result within float z and the result
44:35 - is 2.5 so if you're performing division
44:38 - with any integers you need to pay
44:40 - attention to integer division and you
44:42 - may need to cast your divisor as a float
44:45 - or as a double now we have modulus
44:48 - modulus gives you the remainder of any
44:50 - division 5 does not divide by 2 evenly
44:54 - int z equals x
44:57 - modulus y
44:59 - and if we display z
45:01 - so make sure to change your format
45:03 - specifier if you didn't the remainder of
45:05 - five divided by two is one
45:08 - if this was four four divides by two
45:11 - evenly and the result is going to be
45:13 - zero modulus gives you the remainder of
45:15 - any division it's actually pretty
45:17 - helpful to find if a number is even odd
45:19 - all you do is say modulus 2 or some
45:22 - variable containing the value of 2
45:24 - either way and then we can increment or
45:27 - decrement a number by 1. if i need to
45:30 - increment x for some reason you'll see
45:32 - this when we get to the video on loops i
45:34 - could say x
45:35 - plus plus
45:37 - and then let's display x
45:39 - x incremented by one
45:42 - would be six
45:43 - and then let's decrement y y minus minus
45:47 - and y decremented by one equals one so
45:51 - yeah everybody those are a few
45:53 - arithmetic operators a lot of these are
45:55 - fairly simple you know addition
45:57 - subtraction multiplication and division
45:59 - do pay attention to integer division
46:01 - because that can throw off your program
46:03 - then there's also modulus increment and
46:06 - decrement if you found this video
46:07 - helpful please remember to smash that
46:09 - like button leave a random comment down
46:11 - below and subscribe if you'd like to
46:13 - become a fellow bro
46:17 - hey welcome back everybody here's a
46:19 - super quick video on augmented
46:21 - assignment operators they're used to
46:23 - replace a statement where an operator
46:25 - takes a variable as one of its arguments
46:28 - and then assigns the result back to the
46:29 - same variable now what the heck does
46:31 - that mean okay so let's say that we need
46:33 - to increment the value of x by one
46:36 - without using an increment operator we
46:38 - could say x equals x plus one so writing
46:41 - this out can be somewhat redundant there
46:43 - is a shortcut by using an augmented
46:46 - assignment operator whatever variable
46:47 - you would like to perform an operation
46:49 - on you will list that variable use an
46:51 - arithmetic operator equals and then some
46:54 - value so writing this would increment x
46:56 - by one so let's go over a few examples
46:59 - we have into x equals ten so i could
47:02 - write x equals x plus two to increment x
47:05 - by two right or i could say as a
47:07 - shortcut x plus equals two and that will
47:10 - do the same thing and that's twelve now
47:12 - let's try minus
47:14 - x equals x minus three using the
47:17 - augmented assignment operator that would
47:19 - be x minus equals three which is seven
47:23 - what about x equals x times four well
47:26 - that would be x times equals four x
47:30 - times four
47:31 - is forty and division
47:33 - x equals x divided by five
47:36 - the augmented assignment operator of
47:38 - this equation is x divided by equals
47:42 - five
47:43 - which is two and lastly modulus so what
47:46 - about x equals x modulus two
47:50 - that would be x modulus equals two
47:53 - x modulus two equals zero well yeah
47:57 - everybody those are augmented assignment
47:59 - operators they're basically a shortcut
48:01 - they're used to replace a statement
48:03 - where an operator takes a variable as
48:05 - one of its arguments and then assigns
48:07 - the result back to the same variable
48:09 - it's a shortcut if this video helped you
48:11 - out you can help me out by smashing that
48:13 - like button leave a random comment down
48:15 - below and subscribe if you'd like to
48:16 - become a fellow bro
48:20 - hey uh welcome back in this video i'm
48:23 - going to show you all how we can accept
48:24 - user input in c now if you're using vs
48:27 - code we need to switch from using our
48:29 - output tab to terminal and one way in
48:32 - which we can make that change is by
48:34 - going to file preferences settings
48:37 - search for code runner
48:39 - and then check this run in terminal so
48:41 - then when we run our code it will now
48:43 - display in terminal which accepts user
48:46 - input output doesn't because well it's
48:48 - only for output and you can ignore this
48:50 - this is a powershell command that will
48:52 - compile and run your c program but if
48:54 - you prefer instead of powershell you can
48:56 - use command prompt but you would need to
48:58 - manually compile and run your code since
49:00 - i'm using windows that would be a gcc
49:03 - the name of your c program hello world
49:05 - dot c that will compile your program
49:08 - into an executable named a dot exe
49:10 - then just type that to run it but i'll
49:12 - stick with using powershell just to kind
49:14 - of simplify things okay now how can we
49:16 - accept user input let's declare a
49:18 - variable age but not yet assign it next
49:21 - we're going to create a prompt to ask
49:23 - the user for their age and we'll ask how
49:27 - old are you
49:29 - to accept user input we can use the scan
49:32 - f function it's kind of the inverse of
49:34 - printf printf is used to display
49:36 - something as output scanf is used to
49:39 - read input what we're going to place
49:41 - within our scanf function is the format
49:44 - specifier of the variable we will insert
49:46 - a value into if we need to accept a
49:49 - number an integer as input the
49:51 - corresponding format specifier is
49:54 - percent d
49:56 - then add a comma the name of the
49:58 - variable but precede the variable name
50:01 - with an ampersand that is the address of
50:04 - operator let's print a message that
50:06 - contains the value stored within our
50:08 - variable edge u
50:11 - are
50:12 - percent d
50:14 - years old so this is our format
50:16 - specifier it functions as a placeholder
50:19 - and i would like to display the value
50:21 - contained within my edge variable so
50:23 - things are getting a little bit
50:24 - difficult to read i'm just going to
50:26 - precede this with a new line
50:28 - okay let's try that again how old are
50:30 - you let's say that i'm 21 not anymore
50:33 - but let's pretend that i still am
50:35 - you are 21 years old that's basically
50:39 - how to accept user input you use the
50:41 - scanf function use the format specifier
50:44 - of the variable list the variable
50:46 - appreciated with the address of operator
50:49 - let's try this again but instead accept
50:52 - a string from a user like a name we need
50:54 - to declare an array of characters and
50:56 - set asides so let's create a character
50:58 - array named name
51:01 - now with character arrays we can't
51:03 - change the size of the array after the
51:05 - program is already running let's set a
51:07 - max size of maybe 25 bytes for this
51:10 - array if we go over this limit this will
51:12 - cause a buffer overflow and let's ask a
51:15 - user for their name so we'll create a
51:17 - prompt
51:18 - printf
51:21 - what's your
51:23 - name and i again will use scanf
51:27 - list the appropriate format specifier
51:29 - for character arrays which is percent s
51:32 - then our variable name and use the
51:34 - address of operator then at the end
51:36 - we'll display our name
51:38 - printf
51:41 - hello
51:42 - percent s
51:44 - how are you
51:46 - then comma name and before we run this
51:49 - i'm just going to add some new line
51:50 - characters just to make everything
51:52 - easier to read
51:54 - okay let's try it
51:58 - what's your name i'll type in just my
52:00 - first name not including any white
52:02 - spaces
52:03 - how old are you 21
52:05 - hello bro how are you you are 21 years
52:08 - old so now this time let's type in a
52:10 - first and last name because this is
52:13 - going to act a little bit bizarre what's
52:15 - your name bro
52:16 - code and this is separated with the
52:18 - white space hit enter
52:20 - hello bro it did not include my last
52:22 - name how are you you are zero years old
52:25 - so using the scan f function we will
52:28 - read up to any white spaces so if your
52:31 - user input is going to include a white
52:33 - space we need to use a different
52:35 - function and that is the f gets function
52:39 - f gets
52:41 - parentheses
52:42 - and there are three things we will list
52:44 - within the fgets function
52:47 - the name of the variable and we do not
52:49 - need the address of operator that
52:51 - ampersand for this
52:53 - then we need to set an input size i will
52:56 - set this to 25 to match the size of our
52:58 - array
53:00 - and then std in which means standard
53:03 - input so using this function we can read
53:06 - any white spaces
53:08 - what's your name i'll type in a first
53:10 - name and a last name
53:12 - how old are you 21
53:14 - hello bro code and notice that our
53:16 - output is actually being displayed on
53:18 - the next line that's because when you
53:20 - use the f gets function it will include
53:23 - the new line character when you hit
53:25 - enter if you need to get rid of that new
53:27 - line character at the end so that it's
53:28 - not included with your input here's what
53:30 - we can do it's a little advanced but
53:32 - we'll cover this in future videos we'll
53:34 - include this import
53:36 - include
53:38 - string dot h
53:41 - so using this import we can work with
53:42 - strings all we're going to do is edit
53:45 - our string and get rid of that newline
53:46 - character at the end what i'm about to
53:48 - show you will look a little bit advanced
53:49 - but it's going to make more sense when
53:51 - we get to the video on string functions
53:54 - type the name of the variable followed
53:55 - by a set of straight brackets
53:58 - type str len this gets the length
54:02 - subtract one and we will set the sequel
54:04 - to backslash zero that will get rid of
54:07 - the new line character so again this is
54:09 - a little bit advanced for us but it'll
54:11 - make more sense in future videos when we
54:13 - get to the video on string functions and
54:16 - let's try this one last time
54:18 - what's your name
54:19 - type in a first name and a last name hit
54:22 - enter how old are you 21.
54:24 - hello bro code how are you you are 21
54:27 - years old if you need to accept a string
54:30 - from a user that includes white spaces
54:32 - like a first name and a last name you'll
54:34 - want to use fgets in place of scanf
54:37 - because scanf can't read those white
54:39 - spaces it stops right there but it will
54:41 - include that new line character when you
54:43 - hit enter
54:45 - so you can do some string formatting
54:47 - just to get rid of that new line
54:48 - character and like i said this statement
54:50 - here will make more sense when we reach
54:52 - the video on string functions but yeah
54:54 - basically that's how you can accept user
54:56 - input you can use the scanf function if
54:59 - you need to accept a string of
55:00 - characters that includes white spaces
55:02 - you'll want to use fgets instead so yeah
55:05 - that's how to accept user input and see
55:08 - if you found this video helpful please
55:09 - be sure to smash that like button leave
55:12 - a random comment down below and
55:13 - subscribe if you'd like to become a
55:15 - fellow bro
55:17 - hey what's going on everybody so in this
55:20 - video i'm gonna show you some useful
55:22 - math functions in c now if we include
55:25 - this math header file this contains a
55:27 - lot of the useful functions i'm about to
55:29 - show you one useful function is the
55:31 - square root function let's say that we
55:33 - have a bunch of variables we declared
55:35 - them but we have not yet assigned them i
55:37 - will assign a the square root of nine so
55:40 - after including this math header file i
55:43 - have access to a square root function
55:46 - so type sqrt then add a set of
55:49 - parentheses and within the parentheses
55:51 - we can find the square root of a number
55:53 - let's find what the square root of nine
55:55 - is and then display it with a printf
55:57 - statement
55:59 - so the square root of nine is three so
56:02 - let's move on we can raise a base to a
56:04 - given power by using the pow function
56:07 - the first number is the base let's raise
56:10 - two to the power of four and then
56:12 - display it
56:13 - two to the power of four is 16. we can
56:16 - round a number and i will store this
56:18 - within an integer
56:20 - let's round
56:21 - 3.14
56:23 - oh and then make sure you use the
56:24 - appropriate format specifier for ins
56:29 - 3.14 rounded is 3.
56:33 - now by using the seal short for ceiling
56:35 - function we can always round a number up
56:39 - 3.14 rounded up is 4.
56:43 - likewise there's a floor function where
56:46 - we will always round down
56:48 - 3.99 rounded down
56:52 - is
56:54 - 3. we can find the absolute value of a
56:57 - number that's how far a number is away
56:59 - from zero
57:00 - so it will take any negative numbers and
57:02 - make them positive the absolute value of
57:05 - negative 100
57:08 - and that would be positive 100 if you're
57:11 - familiar with logarithms we can find the
57:14 - logarithm of a number
57:16 - log 3
57:18 - is
57:19 - 1.098612
57:21 - and if you know some trigonometry
57:23 - there's various functions for sine
57:27 - cosine
57:29 - and tangent
57:31 - so what's the tangent of 45
57:35 - that is supposedly this number
57:38 - 1.619775 so yeah everybody those are a
57:41 - few math functions that you might be
57:43 - interested in to use these just include
57:46 - this header file at the top math.h if
57:49 - you found this video helpful please be
57:50 - sure to smash that like button leave a
57:52 - random comment down below and subscribe
57:54 - if you'd like to become a fellow bro
57:59 - hey everyone here's a quick program that
58:01 - we can make to calculate the
58:02 - circumference of a circle i thought this
58:04 - would be good practice for us now that
58:06 - we know how user input works let's
58:08 - declare all of the variables that we'll
58:10 - need i'm going to create a constant
58:12 - variable named pi and it's going to be
58:14 - of the double data type pi equals
58:16 - 3.14159
58:19 - the reason that i'm making this a
58:21 - constant is that i don't want anybody
58:23 - else to be able to change the value of
58:25 - pi and let's declare but not assign a
58:28 - radius quite yet we'll have the user
58:29 - type that in
58:31 - and double circumference
58:34 - this will be calculated and displayed so
58:36 - we will need to prompt the user to enter
58:38 - in a radius i'll proceed this with a new
58:41 - line
58:42 - enter
58:44 - radius
58:45 - of a circle and then i will use scanf to
58:48 - accept some user input we need to list
58:51 - the format specifier of doubles which is
58:54 - lf comma address of operator
58:57 - radius
59:00 - then the formula for radius is 2 times
59:04 - pi times radius and then we will display
59:07 - our circumference using printf
59:10 - circumference
59:12 - then we need a format specifier we're
59:14 - displaying a double so the format
59:16 - specifier is lf
59:19 - comma circumference
59:21 - and let's run it
59:24 - enter well the radius of a circle
59:28 - uh let's say that our radius is 10 maybe
59:30 - this is 10 i don't know meters
59:33 - all right our circumference is
59:35 - 62.83 meters now why not take this a
59:38 - step further let's also calculate the
59:40 - area of the circle i wasn't planning on
59:42 - taking it this far but hey let's
59:43 - calculate that as well for practice so
59:46 - let's declare a double variable named
59:48 - area
59:50 - and we will calculate what area is the
59:52 - formula for the area of the circle is
59:55 - pi times radius squared
59:57 - pi times radius times radius
60:02 - then let's display the area
60:06 - so area
60:08 - we're using the double format specifier
60:10 - and area then let's add some new line
60:13 - characters to separate everything
60:16 - enter the radius of a circle let's say
60:19 - 10 meters
60:21 - the circumference is
60:23 - 62.83 meters and the area is 314
60:28 - meters all right everybody that is a
60:30 - small program to calculate the
60:32 - circumference of a circle and i guess
60:34 - the area as well just because well why
60:37 - not so yeah if you found this video
60:38 - helpful please be sure to smash that
60:40 - like button leave a random comment down
60:42 - below and subscribe if you'd like to
60:44 - become a fellow bro
60:48 - alright welcome back everybody in this
60:50 - video we're going to write a small
60:52 - practice program to find the hypotenuse
60:54 - of a right triangle we'll need the help
60:56 - of our math.h header file because we'll
60:58 - need access to some useful math
61:00 - functions more specifically the square
61:03 - root function let's declare all of the
61:04 - variables that we'll need we'll need
61:06 - sides a b and c and these will be of the
61:09 - double data type
61:10 - a
61:11 - b
61:12 - c
61:13 - we'll ask the user to enter in sides a
61:16 - and b
61:17 - print f
61:19 - enter
61:20 - side
61:21 - a and then we will use scanf
61:25 - so the format specifier for a double
61:28 - is l f then i would like to insert a
61:31 - value within a so i need to use the
61:34 - address of operator then our variable a
61:37 - okay let's do the same thing for side b
61:41 - enter side b and store the user input
61:44 - within variable b the formula to find
61:47 - the hypotenuse of a right triangle is
61:49 - the square root of a squared plus b
61:52 - squared
61:53 - so we will set c
61:54 - equal to the square root function
61:57 - and within the parentheses we will say a
62:00 - times a
62:02 - plus b times b
62:05 - and then we will display c
62:10 - side
62:11 - c
62:12 - and the format specifier for a double is
62:15 - l f and we are displaying c and well
62:19 - let's try it
62:21 - so side a let's say is three side b is
62:24 - four
62:25 - that means side c is five so yeah i
62:28 - thought that would be a good practice
62:30 - program for us to get used to accepting
62:32 - user input if this video helped you out
62:34 - help me out by smashing that like button
62:36 - leave a random comment down below and
62:38 - subscribe if you'd like to become a
62:39 - fellow bro
62:42 - hey let's talk about if statements if
62:45 - statements are used to add some choices
62:47 - to a program let's take the small
62:49 - program for example we have a variable
62:52 - edge and we'll ask a user to enter in
62:54 - their edge what if i would like to check
62:56 - their edge maybe they're signing up for
62:58 - a credit card or something so to check
63:00 - some value we can write an if statement
63:02 - if parentheses then a set of curly
63:05 - braces if some condition that we specify
63:08 - is true we will execute some block of
63:11 - code some subsection of code what sort
63:13 - of condition should we write let's check
63:15 - to see if age is greater than or equal
63:18 - to 18. so there's different comparison
63:21 - operators there's greater than or equal
63:23 - to
63:24 - greater than less than less than or
63:26 - equal to
63:27 - or you could check to see if two values
63:29 - are equal by using double equal signs
63:32 - this is the comparison operator if you
63:34 - use just one this is the assignment
63:37 - operator and this would be the same as
63:38 - assigning age equal to 18 so if you need
63:41 - to compare if two values are equal use
63:44 - the comparison operator which is double
63:46 - equal signs but what i would like to do
63:49 - is check to see if age is greater than
63:51 - or equal to 18. if this condition
63:54 - evaluates to be true we will have our
63:56 - program do something
63:58 - so let's print a message
64:01 - since we're signing up for a credit card
64:03 - let's say you are now signed up
64:07 - and let's run it
64:09 - end to your age let's say that i'm 21 i
64:11 - hit enter boom you are now signed up but
64:14 - what if this condition is false let's
64:16 - say that i'm 12 years old and i'm
64:18 - attempting to sign up for a credit card
64:20 - well we skip this if statement if this
64:22 - condition evaluates to be false we will
64:25 - skip this block of code and continue on
64:28 - with the rest of the program ignoring it
64:30 - or we could do something else by using
64:33 - an else statement if this condition is
64:35 - false we will skip this subset of code
64:38 - and instead perform this let's print a
64:41 - different message instead
64:43 - you are too young to sign up
64:48 - and let's try that again
64:50 - and to your edge i am 12.
64:53 - you are too young to sign up you can
64:55 - check more than one condition before
64:57 - reaching your else statement by using
64:59 - else if blocks and that is by using else
65:02 - if statements we can check another
65:04 - statement before reaching our else
65:06 - statement
65:07 - so let's check to see if age is less
65:10 - than zero so obviously somebody's
65:12 - messing with this program then because
65:14 - you can't be under zero years old right
65:16 - you haven't been
65:19 - born yet
65:20 - so after running this program if i say
65:22 - that i'm negative
65:24 - six
65:26 - you haven't been born yet so we will
65:28 - check our if statement first if this
65:30 - condition is false we will move down to
65:32 - the next block and then check this else
65:35 - if condition if all above statements
65:37 - evaluate to be false we will execute
65:39 - this else block as a last resort so to
65:41 - say and with these else if blocks you
65:43 - can add more than one let's check
65:45 - something else
65:46 - just to demonstrate
65:49 - else if
65:50 - what about age is equal to zero
65:54 - and we will print
65:57 - you can't sign up
66:00 - you were just born
66:05 - and to your age i am zero years old
66:08 - you can't sign up you were just born if
66:10 - one of these conditions evaluates to be
66:12 - true we will skip all of these
66:14 - statements that come after then with our
66:16 - else block if all above statements
66:18 - evaluate to be false we definitely
66:20 - execute whatever's within here
66:22 - so yeah those are if statements they add
66:25 - some choice to a program you can check
66:27 - to see if some condition is true if not
66:29 - you can check something else using else
66:31 - if statements you can perform whatever
66:33 - is within an else block and that's
66:34 - optional so yeah those are if statements
66:37 - and see if you found this video helpful
66:39 - please be sure to help me out by
66:41 - smashing that like button leave a random
66:42 - comment down below and subscribe if
66:44 - you'd like to become a fellow bro
66:48 - all right welcome back people switches a
66:51 - switch is a more efficient alternative
66:54 - to using many else if statements it
66:56 - allows a value to be tested for equality
66:58 - against many cases here's an example of
67:01 - where a switch would be useful i have a
67:03 - small program we will tell a user to
67:05 - enter in a letter grade and depending on
67:08 - their grade we will print a custom
67:10 - message
67:11 - if grade equals a will print perfect
67:13 - else if grade equals b will print a
67:16 - different message so on and so forth so
67:18 - it's considered bad practice to use a
67:21 - lot of else if statements a better
67:23 - alternative is to use a switch here's
67:25 - how we can create one type switch
67:29 - parentheses
67:30 - curly braces whatever value you would
67:33 - like to examine for equality placed
67:35 - within the parentheses i would like to
67:37 - examine my grade and now we need to
67:40 - write some cases
67:42 - case
67:42 - and then some value you would like to
67:44 - test for equality
67:46 - so i am comparing characters i will
67:48 - write the character a
67:50 - colon
67:51 - then if these values match we will
67:53 - execute some subset of code kind of like
67:55 - an if statement
67:57 - let's print
68:00 - perfect
68:03 - and then add a break afterwards
68:06 - then you can add another case
68:10 - so case b
68:13 - you did good
68:17 - casey
68:19 - you did
68:20 - okay
68:23 - case d
68:25 - at least it's not an f
68:31 - case f
68:33 - you failed
68:36 - now you can add a default case this
68:38 - functions like an else statement if no
68:40 - other cases match we will execute
68:42 - whatever's within our default case
68:45 - so that means there are no matching
68:48 - letter grades
68:49 - so let's print
68:50 - please enter only valid grades
68:55 - and let's test it
68:57 - enter a letter grade a
69:00 - this will print perfect whatever's
69:02 - within our matching case
69:04 - let's try it again
69:06 - b you did good
69:10 - see you did okay
69:14 - d at least it's not enough
69:19 - f you failed
69:21 - and if there are no matching cases we
69:23 - will execute our default case uh how
69:26 - about w for win
69:28 - please enter only valid grades the
69:31 - reason that we add breaks after each
69:33 - case is so we can break out of our
69:35 - switch and exit let me show you what
69:37 - this looks like if we do not have any
69:38 - breaks
69:41 - now let's say that we have a c letter
69:44 - grade
69:45 - you did okay at least it's not enough
69:47 - you failed please enter only valid
69:49 - grades
69:50 - so the reason that we have breaks is to
69:52 - exit out of our switch if we have a
69:54 - matching case and there are no breaks we
69:57 - will continue executing each case that
69:59 - comes after so it is important to have
70:01 - those breaks if you want to exit out of
70:03 - your switch well yeah that's a switch
70:05 - everybody it's a more efficient
70:07 - alternative to using many else if
70:09 - statements using a few elsif statements
70:12 - is okay but it's considered poor
70:13 - practice to use a lot of them so yeah
70:16 - those are switches if this video helped
70:18 - you out you can help me out by smashing
70:20 - that like button leave a random comment
70:22 - down below and subscribe if you'd like
70:24 - to become a fellow bro
70:25 - hey uh everybody it's bro hope you're
70:27 - doing well and in this video we're going
70:29 - to create a small program where the user
70:31 - will type in a temperature and we can
70:33 - convert that temperature from fahrenheit
70:35 - to celsius or celsius to fahrenheit so
70:38 - sit back relax and enjoy the show
70:42 - now before we begin this video make sure
70:44 - that you include these two imports at
70:46 - the top we'll be working with string
70:48 - functions and many of them can be found
70:50 - within this import see type dot h so
70:53 - let's declare the variables that we'll
70:55 - need
70:56 - char unit unit will be either c for
71:00 - celsius or f for fahrenheit and float
71:03 - temp short for temperature
71:06 - let's prompt the user to enter in some
71:08 - user input
71:10 - printf is the
71:14 - temperature
71:16 - in
71:18 - f
71:19 - or
71:21 - c
71:23 - and then we will accept some user input
71:26 - so we will be accepting a character so
71:29 - use the appropriate format specifier for
71:32 - characters
71:33 - and we will use the address of operator
71:35 - which is an ampersand
71:37 - unit
71:38 - and then let's use an if statement to
71:40 - check to see
71:42 - if unit
71:43 - is equal to the character c
71:48 - else if
71:51 - unit is equal to f
71:55 - we will use the formula to convert
71:57 - fahrenheit to celsius if it's c celsius
72:00 - to fahrenheit and we should probably add
72:02 - an else statement as well
72:04 - okay let's actually test these right
72:06 - now okay this will only be temporary i'm
72:09 - going to print a message
72:11 - the temp is currently
72:15 - in celsius
72:19 - and with fahrenheit the temperature is
72:20 - currently in fahrenheit
72:23 - so if the user did not type in c or f
72:26 - well then what the heck did they type in
72:28 - so within our else statement let's yell
72:30 - at the user let's say that whatever they
72:32 - entered in is not valid input
72:36 - so format specifier c
72:39 - is not a valid unit of measurement
72:44 - and then we will display whatever the
72:46 - user typed into our unit variable
72:49 - so let's test this is the temperature in
72:52 - f or c
72:53 - so f
72:54 - the temp is currently in f
72:57 - let's try it again
72:59 - is the temperature in f or c see
73:02 - the temp is currently in c
73:04 - okay this time we will not type in f4c
73:07 - how about the word pizza this only
73:09 - accepts the first character
73:11 - p is not a valid unit of measurement
73:14 - here's one situation that we may run
73:16 - into c programs are case sensitive if i
73:19 - type in lowercase f or lowercase c well
73:22 - technically neither of these conditions
73:24 - would be true for example if i type
73:27 - lowercase t
73:28 - c is not a valid unit of measurement to
73:31 - avoid that problem i can take my user
73:33 - input and use the two upper function to
73:36 - make it uppercase or you could set these
73:39 - conditions to check for lowercase
73:41 - characters instead and use the two lower
73:43 - function
73:45 - so let's take our unit variable and i'm
73:47 - going to reassign it after using the to
73:50 - upper function and then pass in our unit
73:53 - to make it uppercase and now if i type
73:56 - in lowercase c or lowercase f
73:59 - this user input will be made uppercase
74:02 - the temp is currently in c
74:04 - so this is optional but i thought it'd
74:06 - be a good thing to add to this program
74:08 - now what we'll work on next depending on
74:11 - the unit there's going to be a different
74:13 - formula a different calculation
74:16 - now we will need the user to enter in
74:18 - the current temperature so let's begin
74:20 - with our if statement if unit is equal
74:23 - to c celsius
74:26 - enter the temp
74:28 - in celsius
74:32 - this time we are accepting a floating
74:34 - point number
74:35 - we will use scanf the format specifier
74:39 - for floating point
74:40 - numbers address of operator
74:44 - temp
74:45 - and then we need to calculate the new
74:47 - temperature after it's converted from
74:49 - celsius to fahrenheit and we will
74:51 - reassign it into the same variable temp
74:54 - temp equals and here's the formula
74:57 - temp
74:58 - times
74:59 - 9 divided by 5
75:02 - plus 32
75:05 - and then let's print the temperature
75:09 - printf
75:11 - the
75:13 - temp
75:15 - in
75:16 - fahrenheit
75:18 - is
75:21 - and i'm going to use a format specifier
75:23 - percent f but i would only like to
75:26 - display one digit after the decimal so i
75:29 - will add dot one
75:31 - and then we will insert our temperature
75:34 - temp okay let's try this enter the
75:37 - temperature in f or c currently we only
75:39 - have the celsius portion set up
75:42 - so see
75:44 - enter the temp in celsius
75:47 - how about zero degrees celsius
75:50 - the temp in fahrenheit is 32.0 okay so
75:54 - we know that it's working
75:56 - let's fill out our else if statement
75:58 - else if unit is equal to f
76:01 - and let's copy some of this
76:05 - enter the temp in
76:07 - fahrenheit
76:08 - we will reassign our temperature
76:10 - variable
76:12 - temp equals
76:14 - and here's the formula
76:16 - temp minus 32
76:19 - times 5
76:21 - and we will divide all of this by 9.
76:26 - [Music]
76:28 - then let's display the temperature in
76:30 - celsius
76:33 - the temp
76:35 - in celsius is
76:37 - our format specifier then the temp
76:40 - variable is the temperature in f or c
76:43 - this time it is in fahrenheit
76:46 - enter the temp in fahrenheit so 32
76:49 - degrees in fahrenheit should translate
76:51 - to zero degrees celsius
76:54 - which it is
76:55 - so yeah everybody i thought that would
76:57 - be a useful practice program for us to
76:59 - get used to accepting user input
77:01 - i'll post all of this code from this
77:03 - program in the comments section down
77:04 - below if you would like a copy
77:06 - so if you found this video helpful you
77:08 - can help me out by smashing that like
77:10 - button leave random comments down below
77:12 - and subscribe if you'd like to become a
77:13 - fellow bro
77:17 - hey yeah what's going on everybody i
77:19 - thought in this video we could create a
77:21 - simple calculator program in c for
77:23 - practice let's begin by declaring all of
77:26 - the different variables that we'll need
77:28 - we'll need a character to store an
77:30 - operator
77:32 - so are we going to add subtract multiply
77:35 - or divide
77:36 - we'll need double num1
77:39 - double num2
77:42 - and double result
77:47 - let's ask the user what type of
77:48 - operation they would like to use
77:52 - enter an operator
77:56 - so we can use addition subtraction
77:59 - multiplication or division
78:02 - and we will use scanf to accept some
78:05 - user input if we're accepting a
78:07 - character the format specifier is c
78:10 - and we will use the address of operator
78:13 - the name of our variable we would like
78:15 - to store some user input into
78:18 - then let's accept num1
78:21 - enter
78:22 - number one
78:25 - then scanf
78:27 - the format specifier for a double
78:30 - is lf
78:33 - num1
78:35 - okay do the same thing with number
78:38 - two replace one with two
78:43 - then to examine our operator let's use a
78:46 - switch
78:48 - switch
78:49 - and we will examine our operator for any
78:52 - matching cases let's add a default case
78:54 - because i might forget to add this later
78:56 - so if a user does not enter in anything
78:59 - that has a matching case one of these
79:01 - four symbols
79:02 - let's print a message
79:04 - let's say that our operator is not valid
79:11 - our first case will be edition so case
79:15 - addition
79:17 - result
79:18 - equals num1 plus num2 and let's display
79:23 - our result
79:26 - result
79:31 - and the format specifier for a double is
79:33 - lf
79:36 - and then at the end of your case you
79:38 - should break to break out of the switch
79:41 - then we can copy this
79:42 - paste it
79:44 - and then change any plus to minus
79:47 - then do the same thing with
79:48 - multiplication
79:52 - and lastly division
79:55 - and that is it so let's try this
79:58 - enter an operator i would like to add
80:01 - enter number one 4.20 plus
80:05 - 3.14
80:06 - that is
80:08 - 7.34 and you can limit the amount of
80:10 - digits after the decimal that is
80:12 - displayed if you would like to adjust
80:14 - that with the format specifier with
80:16 - result type dot than the amount of
80:19 - digits you would like to display so i'm
80:20 - just going to go ahead and change that
80:22 - real quick
80:25 - okay so by adding 0.2 to our format
80:28 - specifier this will only display it two
80:30 - digits after the decimal but you can
80:32 - keep it the original way if you'd like
80:34 - okay let's subtract so minus
80:39 - 4.20 minus 3.14
80:43 - is
80:44 - 1.06 okay multiplication
80:48 - 3.14 times 4.20
80:52 - is 13.19
80:55 - and lastly division
80:57 - 3.14
80:58 - divided by 4.20
81:01 - is
81:02 - 0.75
81:03 - and we do have a default case if there
81:06 - are no matching cases
81:08 - let's type in a character besides one of
81:10 - these four symbols how about
81:12 - i don't know a dollar sign
81:14 - unfortunately we still need to enter
81:16 - into numbers and then this states our
81:19 - operator is not valid
81:22 - so yeah everybody that is a very simple
81:25 - calculator program in c
81:27 - if you would like a copy of all this
81:29 - code i'll post a copy in the comment
81:31 - section down below so this calculator
81:33 - can add subtract multiply and divide
81:36 - there are four cases but you can expand
81:38 - upon this if you'd like so yeah
81:41 - everybody that was a very simple
81:43 - calculator program in c
81:48 - hey yeah what's going on people logical
81:51 - operators there are three logical
81:53 - operators we will discuss in the series
81:56 - and or
81:58 - and not but in this video we're going to
82:00 - focus on and first the and logical
82:03 - operator which is represented by two
82:06 - ampersands checks to see if two or more
82:09 - conditions are true here's an example
82:11 - we're going to create a program that
82:12 - will check to see if a given temperature
82:15 - falls within a range so let's say we
82:17 - have a floating point number named temp
82:19 - temp short for temperature and this will
82:21 - equal some number in celsius let's say
82:24 - 25 to begin with so using an if
82:26 - statement let's check to see if temp
82:29 - is greater than or equal to zero
82:32 - if that is true then we will print
82:34 - something
82:36 - the weather is good
82:39 - else
82:41 - the weather is
82:43 - bad okay so temp is 25 therefore the
82:47 - weather is good
82:49 - okay what if our temperature is
82:50 - something extreme like 1000 degrees
82:53 - celsius so technically this condition
82:56 - would still be true the weather is
82:58 - actually not good it's fairly
83:00 - catastrophic so let's check to see if
83:02 - another condition is also true by using
83:05 - the and logical operator we're checking
83:07 - to see if temp is greater than or equal
83:10 - to 0 and some other condition such as
83:13 - temp
83:14 - is less than or equal to 30.
83:18 - so if temp is at 1000
83:21 - then the weather is bad this condition
83:24 - is true but this one is false using the
83:27 - and logical operator both conditions
83:30 - must be true in order to execute this
83:32 - statement now if our temperature was 25
83:35 - degrees well then both conditions are
83:38 - true and we will execute this statement
83:41 - the weather is good
83:42 - now you can add more than one condition
83:44 - let's throw in another variable let's
83:46 - say that we have a boolean variable
83:48 - named sunny let's say that it's cloudy
83:51 - outside now if we're working with
83:53 - booleans include this header file at the
83:55 - top stdbool.h
83:57 - then let's add another condition
84:00 - and let's check to see if sunny
84:02 - is equal to true if you're checking the
84:06 - value of a boolean variable you don't
84:08 - necessarily have to type out equals true
84:11 - you can say
84:12 - sunny is equal to one or you can just
84:14 - say sunny because this would contain
84:17 - true or false so this time we are
84:19 - checking to see if temp is greater than
84:22 - or equal to zero
84:23 - and temp is less than or equal to 30 and
84:27 - sunny is true the temp is 25 but sunny
84:30 - equals false therefore we do not execute
84:33 - this statement
84:34 - these first two conditions are true but
84:37 - this one is false and using the and
84:39 - logical operator all conditions must be
84:42 - true
84:43 - now if i set this to be true
84:46 - well then all three of these conditions
84:48 - are true and we will execute this
84:50 - statement the weather is good so yeah
84:53 - that is the and logical operator it is
84:56 - represented by two ampersands it checks
84:58 - to see if two or more conditions are
85:01 - true and one example we used is to check
85:04 - to see if our temperature falls within a
85:06 - certain range so yeah that is the and
85:08 - logical operator in the next video we
85:10 - will discuss the or logical operator so
85:13 - if this video helped you out you can
85:15 - help me out by smashing that like button
85:17 - leave a random comment down below and
85:18 - subscribe if you'd like to become a
85:20 - fellow bro
85:24 - hey again it's me so we're gonna talk
85:26 - about the or logical operator the or
85:30 - logical operator which is represented by
85:32 - two vertical bars checks if at least one
85:35 - condition is true let's take the small
85:38 - program for example it's kind of similar
85:40 - to the last video so we have a variable
85:42 - named temperature for temperature we
85:44 - will first check if temp is less than or
85:47 - equal to zero if that's true we will
85:49 - print the weather is bad
85:51 - else if temp is greater than or equal to
85:54 - 30 the weather is bad else the weather
85:57 - is good so you know this program does
85:59 - work the weather is good but another way
86:02 - of writing this is that we can use the
86:04 - or logical operator and we can check to
86:06 - see if at least one of two or more
86:09 - conditions is true so let's take this
86:12 - condition
86:13 - get rid of this else if statement
86:16 - so we will check to see if temp is less
86:18 - than or equal to zero
86:20 - or temp is greater than or equal to 30.
86:24 - so if our temperature is negative 1000
86:27 - degrees celsius then the weather is bad
86:31 - this is true but this is false and using
86:34 - the or logical
86:35 - only one of these conditions needs to be
86:38 - true if both are true that's fine as
86:40 - well or our temperature could be
86:42 - positive 1000 degrees celsius the
86:44 - weather is also bad this is false and
86:47 - this is true and only one of these
86:49 - conditions needs to be true but if our
86:52 - temperature is 25 well neither of these
86:55 - conditions are true at least one
86:57 - condition needs to be true in order to
86:59 - execute the statement so yeah that is
87:02 - the or logical operator it checks to see
87:05 - if at least one condition is true and
87:08 - you can check more than one condition by
87:10 - adding another set of vertical bars for
87:12 - the ore operator so if you found this
87:14 - video helpful please be sure to help me
87:16 - out by smashing that like button leave
87:17 - her in a comment down below and
87:19 - subscribe if you'd like to become a
87:20 - fellow bro
87:24 - hey yeah let's discuss the notch logical
87:26 - operator which is represented by an
87:28 - exclamation point its purpose is to
87:30 - reverse the state of a condition let's
87:32 - write a small program let's say that we
87:34 - have a boolean variable named sunny and
87:36 - this will be either true or false let's
87:39 - say it's true to begin with so to work
87:41 - with boolean variables include this
87:42 - header file at the top and we will write
87:45 - an if-else statement to check to see if
87:46 - it's sunny outside and print a custom
87:48 - message
87:50 - so if sunny
87:52 - is equal to true
87:53 - then we will print
87:57 - it's sunny outside else it must be
88:00 - cloudy outside
88:02 - so this does work it's sunny outside
88:05 - another way of writing this is that we
88:06 - could say sunny is equal to one because
88:09 - true represents one false represents
88:11 - zero this would also work or you could
88:14 - just say sunny this would work as well
88:17 - so by using the not logical operator
88:20 - this will reverse the state of condition
88:22 - by using the not logical operator we're
88:24 - checking to see if something is not true
88:27 - so if i try this again
88:29 - this program states it's cloudy outside
88:32 - so i think it would be better if we were
88:34 - to switch these print statements around
88:37 - now what we're checking is if it's not
88:40 - sunny if it's not sunny then we will
88:42 - print it's cloudy outside
88:44 - else it's sunny outside
88:46 - it is sunny outside and if i change this
88:49 - to be false
88:51 - well then
88:52 - it's cloudy outside so yeah that's the
88:54 - not logical operator you can just
88:56 - precede a condition or a boolean
88:58 - variable with the not logical operator
89:01 - and that gives you a few more options in
89:03 - the way in which you can write a program
89:05 - so yeah that is the not logical operator
89:08 - if you found this video helpful you can
89:10 - help me out by smashing that like button
89:12 - leave random comments down below and
89:13 - subscribe if you'd like to become a
89:15 - fellow bro
89:18 - hey yeah what's going on let's talk
89:20 - about functions a function is a small
89:23 - section of code that is executed
89:25 - whenever we call it also known as
89:27 - invoking a function when we compile and
89:30 - run a c program we begin with invoking
89:33 - the main function so here's our task we
89:36 - need to sing three verses of happy
89:38 - birthday for some reason if we are only
89:41 - using the main function we could write
89:43 - it like this
89:49 - this will be the first verse of happy
89:51 - birthday and if i need to sing three
89:54 - verses i could just copy and paste this
89:57 - one section
89:58 - and then paste it two additional times
90:00 - then i'm just going to add a new line
90:02 - character at the end
90:04 - technically this would work but it's
90:05 - considered poor practice to repeat code
90:08 - more than once if you don't have to
90:10 - wouldn't it be better if we write this
90:11 - code once and then simply reuse it well
90:14 - we can by using a function so let's
90:16 - delete two of these verses
90:18 - and we will create a new function so
90:20 - outside of the main function let's
90:22 - declare a new function so for now we're
90:25 - going to type void and then a unique
90:27 - name for this function let's say that
90:29 - it's the birthday function followed by a
90:31 - set of parentheses and then a set of
90:33 - curly braces so i'm going to take any
90:36 - code i would like to repeat and place it
90:38 - within this new birthday function and if
90:41 - i need to invoke this function all i
90:43 - have to do is type the name of the
90:45 - function followed by a set of
90:47 - parentheses i like to think of the
90:48 - parentheses as a pair of telephones
90:51 - talking to each other that's one trick i
90:53 - used to remember that's how to call a
90:54 - function so follow the function name
90:56 - with the set of parentheses and when i
90:58 - invoke this function once we will
91:00 - execute any code within this function
91:03 - once if i need to repeat this code three
91:05 - times i will just have to call this
91:07 - function three times
91:10 - we are calling our birthday function
91:12 - three times
91:14 - and there we go we have invoked this
91:16 - birthday function three times and we
91:17 - have accomplished our goal of singing
91:19 - three verses of happy birthday so
91:21 - basically that's all what a function is
91:23 - it's some subsection of code that is
91:26 - executed whenever you invoke it also
91:28 - known as calling a function a benefit to
91:30 - using functions is that if you think
91:32 - you're going to use some code more than
91:34 - once you can stick it within a function
91:36 - and then to repeat that code you just
91:38 - call the function as many times as you
91:39 - need so yeah those are functions if you
91:42 - would like a copy of this code i will
91:43 - post this to the comments section down
91:45 - below and in the next video we will
91:47 - discuss arguments and parameters so yeah
91:49 - that's the basics of functions in c
91:55 - hey yeah what's going on people so let's
91:57 - talk about arguments and parameters i
92:00 - have a function named birthday which we
92:02 - discussed in the previous video this
92:04 - will print two lines of text happy
92:06 - birthday dear x you are y years old what
92:10 - i would like to do is replace x with a
92:12 - user's name and y with a user's age so
92:16 - here's how we can write a program like
92:17 - that so let's begin by within the main
92:20 - function declaring two variables a
92:22 - character array named name
92:25 - and assign this your first name and an
92:27 - age and this will be of the int data
92:29 - type and let's say that this will be age
92:32 - and make up some age i like to think
92:34 - that i'm still 21 years old okay so if i
92:36 - try and display a name and age you think
92:39 - this would work right so i'm going to
92:41 - use a format specifier then s to display
92:44 - a string and then i will display our
92:47 - name variable and with y let's display
92:50 - our age so let's use d for our format
92:52 - specifier to display an integer and we
92:55 - will display age now here's the problem
92:57 - you can see that we have some red
92:58 - underlines name is undeclared as well as
93:01 - age here's the deal functions can't see
93:04 - inside of other functions our birthday
93:07 - function is unaware of our name and age
93:10 - variables one way in which we can make
93:12 - our birthday function aware of these is
93:14 - to pass them as arguments when we invoke
93:17 - the birthday function so based on the
93:19 - last topic on functions i mentioned that
93:21 - when we call a function we type the
93:23 - function's name followed by a set of
93:26 - parentheses i like to imagine the set of
93:28 - parentheses as a pair of telephones and
93:30 - these two functions are talking to each
93:32 - other our main function needs to make
93:34 - our birthday function aware of our name
93:36 - and age variables so what we can do is
93:39 - pass these variables as arguments so
93:42 - between the parentheses we can add our
93:44 - variables separated with a comma so
93:47 - let's pass name and age so anything that
93:51 - you're passing to a function are known
93:53 - as arguments but we need a matching set
93:56 - of parameters within the function
93:58 - declaration so between this set of
94:01 - parentheses we will list our name and
94:04 - age variables but precede each with the
94:06 - data type that we're working with so we
94:08 - have name and age so age
94:12 - is an integer so precede the variable
94:14 - name with int and name is a character
94:18 - array so we're going to precede name
94:20 - with char
94:22 - and then add a set of straight brackets
94:24 - after so these are parameters parameters
94:26 - are what this function needs in order to
94:28 - be executed so this does work happy
94:32 - birthday dear bro you are 21 years old
94:35 - so with parameter setup you can only
94:37 - call this function if you pass a
94:39 - character array as well as an integer if
94:42 - i were to remove these arguments we can
94:44 - no longer call this birthday function
94:47 - error too few arguments to function
94:50 - birthday so when you call a function you
94:52 - can pass some arguments but you need a
94:54 - matching set of parameters and the names
94:57 - of these parameters don't necessarily
94:59 - have to be the same what's important is
95:01 - the order of the arguments and the data
95:03 - type so let's say name is x and age is y
95:07 - so let's replace that here as well
95:10 - and that would work too so yeah those
95:12 - are arguments and parameters arguments
95:14 - are what you're sending a function
95:16 - parameters are what a function expects
95:19 - when it's invoked and the benefits of
95:21 - arguments and parameters is that these
95:24 - functions can talk to each other because
95:26 - functions can't see inside of one
95:28 - another so if you have some variables
95:30 - within a function you can pass them to
95:32 - another function as arguments so yeah
95:34 - those are arguments and parameters if
95:36 - you would like a copy of this code i
95:38 - will post this in the comments section
95:40 - down below and well yeah those are
95:42 - arguments and parameters in c
95:48 - hey what's going on people so the return
95:50 - statement the return statement returns a
95:53 - value back to a calling function here's
95:56 - an example i have a function named
95:58 - square square is going to accept one
96:00 - argument a double it's going to square
96:03 - that double and return the result back
96:05 - to the calling function so here's an
96:07 - example let's say we have double x and
96:10 - i'm going to call the square function
96:13 - and then pass in some value
96:15 - let's say 3.14
96:17 - so when we call a function we can also
96:20 - return a value back to the spot in which
96:22 - we call a function so within our square
96:25 - function let's set double result equal
96:28 - to x times x effectively squaring it so
96:32 - to return a value back to the calling
96:34 - function we will use this return keyword
96:37 - followed by some value or variable i
96:39 - would like to return result however we
96:42 - need to list the data type of what we're
96:44 - returning within the function
96:46 - declaration right now it's void so if
96:49 - we're returning a double we will list
96:51 - double here if this was an integer we
96:54 - would return int
96:55 - if it was a character we would return
96:58 - char you kind of get the idea so result
97:00 - is a double so we need to change this
97:03 - from void to double and we will return
97:05 - this result back to the calling function
97:08 - so we're effectively stating that double
97:11 - x equals 3.14 squared and then let's
97:14 - print the result
97:16 - so printf
97:18 - the format specifier for a double is lf
97:21 - and we will print x
97:23 - and 3.14 squared is 9.859
97:27 - now you could shorten this too we could
97:29 - just say return x times x
97:32 - instead of declaring a local variable
97:35 - return x times x
97:38 - and that would work the same so yeah
97:40 - that's basically the return statement
97:42 - you can place it within a function and
97:44 - return a value or variable back to the
97:47 - calling function
97:48 - and the spot in which you invoked that
97:50 - function but if you're going to return a
97:52 - value or variable within the function
97:55 - declaration you need to change void to
97:57 - the data type of what you're returning
98:00 - so yeah that is the return statement and
98:02 - you may have noticed within our main
98:03 - function we're returning zero zero is
98:06 - the exit status if this program runs
98:08 - successfully so instead of void with our
98:11 - main function declaration we have int
98:14 - because zero is technically an integer
98:16 - so yeah that's the return statement if
98:18 - you would like a copy of this code i
98:20 - will post this to the comments section
98:22 - down below well yeah that's the return
98:24 - statement in c
98:29 - hey sup people the trinary operator also
98:32 - known as the conditional operator it's a
98:35 - shortcut to using an if-else statement
98:37 - when assigning or returning a value
98:40 - here's the formula we write a condition
98:42 - followed by a question mark if this
98:45 - condition is true we return some value
98:48 - if true or if that condition is false we
98:51 - return some other value here's an
98:53 - example first we'll use an if-else
98:55 - statement and then later we'll switch to
98:57 - the ternary operator so let's create a
98:59 - function that will find the maximum of
99:02 - two integers and i'm going to assign
99:04 - that to int max
99:06 - and we will invoke a function find max
99:09 - but we'll still need to declare it so
99:10 - let's pass in two integers maybe three
99:13 - and four
99:14 - and then i'm going to display whatever
99:16 - max is
99:18 - okay so let's declare this function so
99:20 - we're returning an integer
99:22 - the name is find max and let's set up
99:25 - some parameters into x and int y so if
99:29 - we're using an if else statement if we
99:31 - need to return x if it's larger we can
99:33 - check to see if
99:35 - x is larger than y
99:38 - if so then return x
99:41 - else
99:43 - return
99:44 - y so this does work
99:47 - so the max between three and four
99:50 - is four
99:51 - so if i switch three to five
99:54 - well then the max is five so a shortcut
99:57 - to writing an if else statement like
99:59 - this if we're returning or assigning a
100:01 - value is that we could instead use the
100:04 - tenary operator so let's return and then
100:07 - we have a condition
100:08 - so this is our condition
100:11 - is x greater than y then we add a
100:13 - question mark
100:16 - then the value we're returning if true
100:19 - so if x is greater than y let's return x
100:23 - colon then our value if this condition
100:26 - is false and here within our else
100:28 - statement we're returning y
100:31 - and we no longer need this if else
100:33 - statement and that's all there is to it
100:35 - so we cut down on all that code and now
100:37 - just have one line of code so it's kind
100:39 - of like a shortcut and this works much
100:41 - the same so the maximum between five and
100:44 - four is five and if i change five back
100:46 - to three well then the max is for so
100:49 - yeah that's the ternary operator it's a
100:51 - shortcut to using an if else statement
100:53 - when assigning or returning a value you
100:56 - write some condition add a question mark
100:58 - like you're asking a question then list
101:01 - some value to return if this condition
101:04 - is true and then some other value if
101:06 - this condition is false so you just
101:09 - follow this formula so yeah that's the
101:11 - trenary operator if you would like a
101:12 - copy of this code i'll post this to the
101:14 - comments section down below and well
101:16 - yeah that's the canary operator nc
101:22 - hey everybody so let's discuss function
101:24 - prototypes a function prototype is a
101:27 - functional declaration without a body
101:30 - before we declare the main function it
101:32 - ensures that calls to a function are
101:35 - made with the correct number and type of
101:37 - arguments it has some benefits which
101:39 - we'll discuss later basically this is
101:41 - another way in which we can declare and
101:43 - define functions in the last few topics
101:46 - when we were declaring functions we were
101:48 - doing so before the main function so
101:51 - let's say void and we have a function
101:53 - named hello and there will be two
101:55 - arguments and ray of characters named
101:57 - name and int age and what i would like
101:59 - this function to do is print a message
102:01 - using our name and age
102:05 - so hello name
102:12 - you are age years old so what we're
102:15 - going to do is now move this function
102:17 - from before the main function to after
102:20 - the main function and let's declare some
102:22 - name and age variables so char name
102:26 - use your first name and int age make up
102:29 - some age now i'm going to invoke my
102:31 - hello function
102:32 - but pass in an incorrect number of
102:35 - arguments now here's one of the benefits
102:37 - of a function of prototype it's going to
102:39 - ensure that we have the correct number
102:41 - of arguments when we invoke a function
102:43 - so the correct arguments for our hello
102:46 - function are an array of characters and
102:48 - an integer what if i'm missing one of
102:50 - these arguments let's say we only pass
102:52 - in a name
102:53 - and then invoke this function
102:55 - so this is going to result in unexpected
102:57 - behavior
102:59 - and we do have a warning here
103:01 - conflicting types for hello but this
103:03 - program will still compile and execute
103:05 - so here's the result hello bro you are
103:09 - million five hundred twelve thousand
103:10 - three hundred and fifty two years old
103:13 - and if i run this again this will
103:14 - probably be a different number so this
103:16 - will result in unexpected behavior we're
103:18 - not ensuring that calls to a function
103:20 - are made with the correct arguments one
103:22 - way in which we can do that is to add a
103:24 - function prototype before the main
103:26 - function and to add a function prototype
103:30 - to a given function we will declare that
103:32 - function but not give it a body before
103:34 - the main function and then we will later
103:36 - add a body and define what this function
103:38 - is going to do so before the main
103:40 - function we will type the return type of
103:43 - this function
103:44 - void
103:45 - the name of the function
103:47 - hello and then add the data type and the
103:50 - order of arguments so we have a
103:52 - character array
103:53 - and an integer then end it with a
103:55 - semicolon so this is a function
103:59 - prototype
104:00 - it ensures that calls to a function are
104:02 - made with the correct arguments so now
104:05 - if i attempt to call the hello function
104:07 - with only one argument when two are
104:10 - required instead of a warning we'll
104:12 - receive an error and it states that
104:14 - there are too few arguments to function
104:16 - hello so this program will not compile
104:19 - and run successfully which is what we
104:21 - want because we made a mistake and if i
104:23 - were to add the correct arguments now
104:26 - well then this program is going to
104:27 - compile and run fine
104:29 - so here's some important notes regarding
104:31 - function prototypes many c compilers do
104:35 - not check for parameter matching that's
104:37 - why this program was still able to
104:39 - compile and run without a function
104:42 - prototype even though we were missing
104:44 - arguments and that can result in
104:46 - unexpected and unwanted behavior such as
104:49 - saying that i was over a million years
104:51 - old so a function of prototype causes
104:54 - the compiler to flag an error if
104:57 - arguments are missing
104:59 - you can write the functions before the
105:01 - main function that's okay too but a few
105:03 - advantages of using a function prototype
105:06 - is that it's easier to navigate a
105:08 - program when the main function is at the
105:10 - top of your file it also helps with
105:12 - debugging and it's commonly used in
105:15 - header files which is something we need
105:16 - to discuss in a future topic so yeah
105:19 - that's basically a function prototype
105:21 - we're going to define any functions
105:24 - after the main function now and before
105:26 - the main function we will declare a
105:28 - function prototype one function
105:30 - prototype for each function we have
105:32 - besides the main function and this
105:34 - ensures that we have the correct number
105:36 - and type of arguments which will prevent
105:39 - any unexpected behavior it's basically
105:42 - just another way to declare functions
105:44 - that you may run into in the future so
105:46 - yeah those are function prototypes if
105:48 - you would like a copy of this code i
105:50 - will post this to the comment section
105:51 - down below and well yeah those are
105:54 - function of prototypes in c
105:59 - hey everybody so now that we know how
106:01 - functions work i thought this would be a
106:03 - good opportunity for us to learn about
106:05 - some useful string functions so there's
106:07 - a lot of string functions that are
106:09 - already written for us just include this
106:11 - header file at the top include string
106:14 - dot h so create two strings one named
106:17 - string one and the other named string
106:19 - two string one will be your first name
106:21 - string two will be your last name and
106:23 - then at the end of this program i am
106:24 - just printing string one using a printf
106:27 - statement so let's begin the first
106:29 - useful string function is string lower
106:33 - so whatever string you pass in as an
106:34 - argument this function will convert a
106:37 - string to lowercase so the first letter
106:40 - in my name is uppercase it's capitalized
106:42 - so after passing in string1 into this
106:45 - function
106:46 - my name is all now lowercase
106:49 - otherwise there's string upper that will
106:52 - convert a string to uppercase
106:54 - and my name is uppercase
106:56 - stringcat will concatenate as in append
107:00 - string2 to the end of string1 so we will
107:03 - append the second argument to the first
107:05 - argument so if i pass in string one then
107:08 - string two this will append my last name
107:11 - to my first name and these strings are
107:13 - now combined or i could append a given
107:16 - amount of characters from string two to
107:18 - string one so the third argument is a
107:20 - number if i append one character from
107:23 - string two to string one then this will
107:25 - take the c from my last name and append
107:28 - it to the end of my first name so that
107:31 - is the string and cat function
107:34 - there's also string copy and this one is
107:36 - actually fairly common
107:37 - so this will copy string two to string
107:40 - one if i print string one well it now
107:43 - displays code instead of bro this will
107:45 - remove the contents from string one and
107:47 - replace them with string two or you
107:49 - could copy a given amount of characters
107:52 - from string two to string one uh let's
107:54 - say that i'm going to copy the first
107:55 - character over so i'm copying the first
107:58 - character from my last name to my first
108:00 - name
108:02 - and my first name is now crow or i could
108:04 - set this to two
108:06 - and this will copy the first two letters
108:08 - over
108:10 - coo all right here's a few more so
108:12 - string set will set all characters of a
108:16 - string to a given character i'm going to
108:18 - set all of the characters from string 1
108:21 - to a question mark all of the characters
108:24 - within my name are all question marks
108:26 - and string and set will set the first
108:29 - and characters of a string to a given
108:31 - character so i'm going to set the first
108:34 - character of my first name to an x
108:37 - so my name is now x bro and string
108:39 - reverse will reverse a string so if i
108:42 - reverse string one
108:44 - my first name is now orb so this next
108:47 - set of functions will return an integer
108:50 - so i'm going to declare a variable int
108:53 - result and this function is really
108:55 - common string length this returns the
108:58 - string length as an integer
109:00 - if i pass in string one this string has
109:03 - a length of three characters and then
109:05 - i'm going to print my result and this is
109:08 - an integer
109:09 - so the length of my first name
109:12 - is three characters this is a fairly
109:15 - common function
109:16 - the string compare function will compare
109:19 - all of the characters within two strings
109:22 - if they're the same they will return
109:24 - zero if they're different they will
109:27 - return a number beside zero so here's an
109:29 - if statement
109:31 - if result is equal to zero we will print
109:34 - these strings are the same else these
109:36 - strings are not the same
109:38 - so my first name is not equal to my last
109:41 - name these characters are different so
109:43 - this code will print
109:46 - these strings are not the same and let
109:47 - me get rid of that printf statement
109:50 - okay now if i make the strings the same
109:54 - then result is going to be zero
109:57 - these strings are the same and you can
109:59 - compare a given amount of characters too
110:02 - so currently i have these strings set to
110:04 - be the same characters so this will
110:06 - compare only the first character
110:08 - these strings are the same even if i
110:10 - change the other characters the first
110:12 - characters will still be the same
110:14 - so this function will return zero there
110:17 - are two additional versions of string
110:19 - compare and string and compare they are
110:22 - string compare i and string n i compare
110:27 - so these will do the exact same things
110:29 - except they ignore case sensitivity so
110:32 - yeah everybody those are just a few
110:34 - useful string functions there's still a
110:36 - lot more located within this header file
110:39 - but we would need to understand how
110:41 - things like pointers work which we have
110:43 - not discussed yet but i thought i would
110:45 - at least cover some of the basics so
110:47 - yeah those are a few useful string
110:49 - functions in c if you would like a copy
110:51 - of all these notes i'll post them to the
110:53 - comment section down below and well yeah
110:55 - those are a few useful string functions
110:58 - in c
111:02 - hey yeah welcome back so we have to talk
111:05 - about for loops a for loop repeats a
111:08 - section of code a limited amount of
111:10 - times here's an example let's say that
111:13 - we would like to count the numbers 1
111:15 - through 10. so we can actually write a
111:17 - for loop to do that for us and here's
111:19 - how to create one type four
111:21 - a set of parentheses then a set of curly
111:23 - braces anything within this set of curly
111:26 - braces we can repeat a limited amount of
111:29 - times but before we do so there's a few
111:31 - statements we have to add to our for
111:33 - loop there are three the first is that
111:35 - we need some sort of counter or index
111:38 - and we can actually declare that within
111:40 - the for loop so we will declare an index
111:43 - int
111:44 - index and set the sql to some number
111:46 - let's say one so we will start at one
111:48 - and count to ten and then finish the
111:50 - statement with a semicolon now a common
111:53 - convention is that a lot of people will
111:55 - shorten index to i because it's easier
111:57 - to work with so this is the first
111:59 - statement there's two more and the
112:01 - second statement is a condition how long
112:04 - should we continue repeating this code
112:06 - so let's continue this for loop as long
112:08 - as i our index is less than or equal to
112:12 - 10 and then add a semicolon at the end
112:15 - so that is the second statement and the
112:17 - third statement is that we can increment
112:19 - or decrement our counter
112:22 - so let's take i and increment it by one
112:25 - after each iteration by using i plus
112:27 - plus so let's just test this so printf
112:32 - i'll just print the word test
112:35 - so this should print the word test ten
112:37 - times
112:38 - uh then we should add a new line
112:39 - character at the end
112:44 - that's much better okay now let's
112:46 - replace test with a format specifier
112:48 - we're displaying an integer
112:51 - and let's display i our index and this
112:54 - should count from one to ten
112:57 - yep just like that one through ten so
113:00 - with this third statement we can
113:02 - increment or decrement by one or a
113:04 - greater number so this time let's count
113:06 - by two so we can set this to i plus
113:09 - equals two and we will now count up by
113:13 - two starting from one one three five
113:15 - seven nine
113:17 - or how about three
113:18 - one four seven ten you can also
113:20 - decrement this time let's count from ten
113:23 - to one so let's set i to equal 10
113:26 - and we will continue this as long as i
113:29 - is greater than or equal to 1
113:32 - and we will decrement i minus minus
113:36 - so this will count from 10 to 1 and then
113:39 - stop or we could count down by two
113:42 - i minus equals two
113:45 - then we have ten eight six four two
113:47 - or even three or a greater number
113:50 - so yeah that's a for loop it repeats a
113:53 - section of code a limited amount of
113:55 - times there's up to three statements
113:57 - that we can add we can declare an index
113:59 - a counter so to say some condition that
114:02 - we check after each iteration and then
114:05 - some way to increment or decrement our
114:07 - index and then place any code you would
114:09 - like to repeat within a set of curly
114:11 - braces so yeah that's a for loop if you
114:14 - would like a copy of this code i will
114:16 - post this to the comment section down
114:17 - below and well yeah those are for loops
114:20 - in c
114:24 - all right we're back at it again so
114:26 - let's talk about while loops a while
114:28 - loop will repeat a section of code
114:30 - possibly unlimited times we will
114:33 - continue some section of code while some
114:36 - condition remains true and it's possible
114:38 - that a while loop might not execute at
114:40 - all depending on what our condition is
114:42 - so here's an example let's create a
114:43 - program that will ask a user for their
114:46 - name if they attempt to skip that prompt
114:48 - then we will keep on asking them for
114:50 - their name indefinitely so here's how we
114:52 - can write a program like that using a
114:53 - while loop we'll need to begin with a
114:55 - character array let's say name and this
114:58 - will be 25 bytes and we will create a
115:00 - prompt using printf
115:04 - what's your name we can use scanf for
115:07 - user input but with names that may
115:09 - contain spaces i'm going to use fgets
115:11 - instead
115:13 - refer to the video on user input to
115:15 - learn more about fgets so i would like
115:18 - to assign my variable name
115:21 - set the size of the user input 25 to
115:23 - match what we have
115:25 - then type stdn for standard input then
115:29 - we just need to get rid of the new line
115:30 - character at the end of our user input
115:33 - so we can write something like this
115:35 - set our character array of name and
115:37 - within the straight brackets we will use
115:40 - the string length function
115:42 - pass in name
115:44 - -1
115:46 - and we will set this equal to a null
115:49 - character and then at the end we will
115:51 - display the user's name printf
115:54 - let's say hello and then use a format
115:57 - specifier for strings which is s and we
116:00 - will display a user's name
116:02 - okay this is what this looks like
116:04 - currently
116:05 - what's your name i'll type my name hit
116:08 - enter
116:09 - and it says hello bro now what if i
116:11 - don't type in anything like i just hit
116:14 - enter
116:15 - what's your name i'm going to hit enter
116:17 - hello and then there is no name here how
116:20 - can i force a user to type in something
116:22 - well i could use a while loop and that
116:24 - will prompt a user to enter their name
116:26 - indefinitely so here's how to create a
116:29 - while loop type while parentheses
116:32 - curly braces and we need a condition
116:34 - what are we going to check we will
116:36 - continue this while loop while some
116:38 - condition remains true
116:40 - our condition to check to see if we have
116:42 - an empty string
116:43 - we could use the string length function
116:46 - pass in name and check to see if this is
116:49 - equal to zero
116:51 - if it is zero that means that somebody
116:53 - just hit enter without typing in
116:55 - anything so let's print a message to
116:57 - yell at them
117:00 - you
117:01 - did not enter your name
117:04 - and then let's copy this section of code
117:06 - and paste it to reprompt the user to
117:08 - type in their name
117:10 - and that's all there is to it so while
117:13 - this condition remains true we will
117:15 - execute this code forever so let's try
117:18 - it again
117:19 - okay what's your name i'm going to hit
117:21 - enter you did not enter your name what's
117:23 - your name no no no no
117:26 - okay i give up
117:28 - hello whatever your name is so yeah
117:31 - that's basically a while loop it repeats
117:33 - a section of code possibly unlimited
117:36 - times there's a lot of overlap where you
117:38 - could use either a for loop or a while
117:40 - loop and we execute some body of code
117:43 - while some condition remains true
117:46 - however a while loop might not execute
117:48 - at all if this condition is false to
117:51 - begin with so if the user actually does
117:53 - type in something well this condition is
117:56 - false and we do not execute this body of
117:58 - code so yeah that's a while loop it
118:00 - repeats a section of code possibly
118:02 - unlimited times if you would like a copy
118:04 - of this code i will post this to the
118:06 - comment section down below and well yeah
118:09 - those are while loops in c
118:14 - hey everybody so let's talk about do
118:17 - while loops a do while loop is a
118:19 - variation of a while loop so a while
118:22 - loop first checks a condition
118:24 - then it executes a block of code if that
118:27 - condition is true so we may not even
118:30 - execute that block of code at all if
118:32 - that condition is false from the get go
118:34 - a do while loop always executes a block
118:37 - of code once and then we checking
118:40 - condition at the end if that condition
118:42 - is true we will continue another loop so
118:45 - here's what i'm thinking for a
118:46 - demonstration we'll create a small
118:47 - program where we will have a user type
118:50 - in as many numbers as they want as long
118:52 - as it's above zero and then we will find
118:54 - a sum so if we're writing a program like
118:56 - that we can first declare two variables
118:58 - int number i'll go ahead and assign
119:01 - these some values right away so we'll
119:03 - set number to zero and int sum equal to
119:06 - zero as well to keep track of the sum
119:08 - we'll first begin by creating a while
119:10 - loop
119:10 - so we will use a while loop
119:13 - and our condition is if number
119:16 - is greater than zero
119:18 - then we will continue to ask the user to
119:20 - type in some numbers
119:22 - if that number is zero or less then we
119:24 - stop so let's ask a user for a number
119:28 - enter a number
119:30 - above zero and then using scanf we will
119:34 - accept some user input
119:36 - and store this within number and let's
119:39 - check to see if
119:40 - number
119:41 - is greater than zero
119:44 - if it is we will take sum set this equal
119:47 - to sum
119:48 - plus number but you can just shorten the
119:50 - statement to plus equals number that's
119:53 - fine too and then at the end we will
119:56 - print whatever the sum is
119:58 - sum
119:59 - we're displaying an integer
120:01 - and we are displaying some so with our
120:04 - number i set this to zero and since our
120:06 - while loop is checking the condition
120:08 - first we're not actually going to
120:10 - execute this body of code
120:13 - so our program skipped this while loop
120:15 - and went straight to the printf
120:17 - statement so a while loop checks a
120:19 - condition first a do while loop will
120:21 - check a condition last so to change this
120:24 - to a do while loop we will take our
120:26 - condition
120:27 - and move it to the end
120:29 - just after the last curly brace and add
120:31 - a semicolon and then before the first
120:34 - curly brace we will add the word do so
120:36 - we will do this once and then check the
120:39 - condition to see if we would like to
120:40 - continue so now if i run this
120:43 - we get that prompt enter a number above
120:46 - zero and i can type in as many numbers
120:48 - as i want so one two three four five so
120:52 - we check the condition at the end
120:54 - so our condition is that if our number
120:57 - is greater than zero we will continue
120:59 - this loop so if i type in negative one
121:01 - we will exit
121:03 - and our sum is 15. so that's the major
121:06 - difference between a while loop and a do
121:08 - while loop a while loop checks a
121:10 - condition first then executes a block of
121:13 - code if that condition is true a do
121:15 - while loop always executes a block of
121:17 - code once
121:19 - then checks a condition if that
121:20 - condition is true then we continue again
121:23 - so yeah that's a do while loop it's a
121:25 - variation of a while loop and if you
121:28 - would like a copy of this code i'll post
121:29 - this to the comments section down below
121:31 - and well that's the do while loop in c
121:37 - hey welcome back so nested loops a
121:40 - nested loop is a loop inside of another
121:43 - loop when you'll encounter them it's
121:45 - really situational so i don't really
121:47 - have one good example but what i'm
121:49 - thinking we'll do is use a nested loop
121:51 - for an exercise what i'm thinking is
121:54 - that we'll let a user type in a number
121:56 - of rows and columns and a symbol and
121:58 - print a rectangle of that given symbol
122:01 - but the user is going to specify a
122:03 - number of rows and columns so let's
122:05 - begin by declaring all of the different
122:07 - variables that we'll need intros and
122:09 - columns and char
122:12 - symbol we'll let the user type in a
122:14 - number of rows and columns
122:18 - enter number of rows
122:20 - then use scanf to accept some user input
122:23 - we are accepting an integer so use d for
122:27 - the format specifier address of operator
122:30 - rows then do the same thing with columns
122:36 - enter number of columns
122:40 - let's create our nested loops you can
122:42 - use either for loops or while loops it's
122:44 - just the concept of one loop inside of
122:46 - another so let's use for loops for our
122:49 - outer loop and inner loop
122:51 - the outer loop is in charge of keeping
122:53 - track of the rows the inner loop will be
122:56 - in charge of keeping track of the
122:57 - columns so i need this outer for loop to
123:00 - iterate once for every row that we have
123:03 - so we could write something like this
123:05 - int i set this equal to one i need to
123:08 - continue this for loop as long as i is
123:11 - less than or equal to rows
123:15 - and then increment i by one after each
123:17 - iteration so now let's create a nested
123:20 - for loop we will declare a loop inside
123:22 - of another loop
123:24 - and this inner for loop is in charge of
123:26 - the columns we should probably not reuse
123:28 - our index of i so let's create a new
123:30 - index and a common naming convention for
123:33 - an inner for loop is to use j because j
123:36 - comes after i in the alphabet
123:38 - so i will set int j equal to one we will
123:41 - continue this as long as j is less than
123:44 - or equal to columns
123:47 - then increment j by one for the time
123:50 - being until we let a user type in a
123:52 - symbol let's just print our index so
123:55 - let's use printf
123:59 - we're displaying an integer
124:01 - and let's display j
124:04 - and let's take a look at this
124:06 - okay enter number of rows how about 3
124:08 - rows and five columns
124:11 - so here's our output we have the numbers
124:13 - one through five three times
124:16 - so to make this more of a rectangle a
124:19 - grid i'm going to add a new line
124:21 - character whenever we finish a row
124:24 - so printf
124:27 - newline character let's try that again
124:31 - enter number of rows three number of
124:33 - columns five
124:35 - so we have three rows and five columns
124:38 - basically speaking to complete one
124:40 - iteration of our outer loop we have to
124:42 - escape our inner loop first
124:45 - once this condition is no longer true
124:47 - then we will escape the inner loop and
124:49 - complete one iteration of the outer for
124:51 - loop but then once we begin in the next
124:54 - iteration of our for loop we're stuck
124:56 - back within our inner for loop again so
124:58 - that's kind of the concept now this time
125:00 - let's let a user type in a symbol and we
125:03 - will create a sort of rectangle
125:07 - enter a symbol to use then scanf we are
125:12 - accepting a character so use the c
125:14 - format specifier address of operator
125:17 - our symbol variable
125:20 - now we're going to replace j with our
125:22 - symbol
125:24 - and the format specifier for a character
125:26 - is c
125:27 - then let's try this again
125:31 - so how about three rows and six columns
125:35 - okay here's the issue so we have all of
125:37 - this empty space
125:38 - now when we entered our number of
125:40 - columns after hitting enter we have the
125:43 - new line character within our input
125:45 - buffer so our next scana function
125:48 - actually picked that up so what we need
125:50 - to do is clear our buffer and one simple
125:52 - way of doing that there's a couple
125:54 - different ways is that we can just use
125:56 - scanf again
125:58 - and we will read a character and that's
126:00 - one way to do it basically with this
126:02 - line we're just getting rid of the new
126:04 - line character after the last time we
126:06 - use scanf because that's still within
126:08 - our buffer okay let's try this one last
126:10 - time what about four rows
126:13 - and five columns enter a symbol to use
126:16 - uh how about the dollar sign
126:18 - there we go here's our rectangle it has
126:21 - five columns and four rows so yeah
126:24 - that's basically a nested loop it's a
126:26 - loop inside of another loop and when
126:28 - you'll encounter them it's really
126:30 - situational i thought this would be good
126:32 - practice to understand how they work to
126:34 - complete one iteration of the outer loop
126:37 - you have to first escape the inner loop
126:40 - and that may involve completing all
126:41 - iterations of the inner loop so yeah
126:44 - those are nested loops if you would like
126:45 - a copy of this code i will post this to
126:47 - the comment section down below and well
126:49 - yeah those are nested loops in c
126:55 - hey people i have a super quick video
126:58 - for you today on the differences between
126:59 - the continue and break statements so
127:02 - when using either statements within the
127:04 - context of a loop a continue statement
127:06 - will skip the rest of a section of code
127:09 - and force the next iteration of a loop a
127:11 - break statement will exit out of a loop
127:13 - entirely another place where you see
127:15 - break statements is when used within a
127:18 - switch after each case so here's an
127:20 - example let's say that we would like to
127:21 - count the numbers 1 through 20 but i
127:24 - would like to skip the number 13 because
127:26 - 13 is considered an unlucky number so if
127:28 - i were to write a program like that that
127:30 - would look something like this
127:32 - so let's use a for loop and i will set
127:35 - an index of i equal to one continue this
127:38 - as long as i is less than or equal to 20
127:41 - and then increment i by one then let's
127:43 - print our index so printf we're
127:46 - displaying an integer
127:47 - and let's display i i'm just going to
127:49 - add a new line character after each
127:51 - iteration when we use a printf statement
127:54 - okay so this is what this looks like we
127:56 - have the numbers 1 through 20. so if i
127:59 - would like to skip the number 13 i can
128:01 - use a continue statement but we need to
128:03 - check to see if i is equal to 13 we can
128:06 - use an if statement
128:09 - so
128:10 - if i is equal to 13
128:13 - then we will continue
128:16 - and let's take a look so we have the
128:17 - numbers 1 through 20 but we are missing
128:21 - 13 so a continue statement will skip the
128:24 - rest of a section of code and force the
128:26 - next iteration of a loop now if this was
128:29 - a break statement this will break out of
128:31 - our loop entirely so once we reach 13
128:36 - then we will exit out of this loop
128:38 - entirely so here we only have the
128:40 - numbers 1 through 12 and then we break
128:43 - we exit out of the loop so that's a
128:46 - quick demonstration of the differences
128:47 - between continue and break the continue
128:50 - statement will skip the rest of a
128:52 - section of code and force the next
128:54 - iteration of a loop a break statement
128:56 - exits out of a loop entirely so yeah
128:59 - that's a super quick video on the
129:01 - differences between the continue and
129:03 - break statements if you would like a
129:04 - copy of this code i'll post this to the
129:06 - comments section down below and well
129:08 - yeah those are the major differences
129:10 - between the continue and break
129:11 - statements in c
129:16 - hey everybody let's talk about arrays an
129:18 - array is a data structure that can store
129:21 - many values of the same data type here's
129:24 - an example let's say i have a variable
129:26 - named price and i have the price of
129:28 - maybe one item in a fictional store of
129:31 - ours so by using an array we can
129:33 - actually store more than one value but
129:35 - it has to be of the same data type so i
129:38 - can turn this variable price into an
129:40 - array and i can do that by following the
129:43 - name of the variable and add a set of
129:45 - straight brackets and then any values i
129:47 - would like to add to this array i will
129:50 - surround with a set of curly braces and
129:52 - there we go we have turned our variable
129:54 - price into an array but i'm going to
129:57 - change the name to prices because i
129:59 - think it would be more descriptive
130:01 - because we can store more than one value
130:03 - now so we can add multiple values each
130:06 - separated with a comma so let's say we
130:08 - have another price that is 10
130:11 - 15
130:13 - 25 and maybe 20. now you may have
130:16 - noticed some parallels when we create a
130:18 - string it's really an array of
130:20 - characters so if i need a name we would
130:22 - say the data type is char
130:25 - and we will create a name array followed
130:27 - by a set of square brackets and i will
130:29 - set this equal to some amount of
130:32 - characters a string is really just an
130:34 - array of individual characters and with
130:37 - my name here i have three individual
130:39 - elements three individual values now if
130:42 - i need to access one of these values i
130:45 - need to use an index number so let's
130:47 - print one of these numbers
130:50 - so printf
130:51 - i'm going to use the format specifier
130:53 - for a double and i'm going to list my
130:56 - array name
130:57 - prices then follow this with a set of
130:59 - straight brackets then i need an index
131:02 - number so each spot within an array is
131:05 - known as an element so we have five
131:07 - elements within our array and to access
131:10 - one of these elements i need to list an
131:12 - index number the first element has an
131:14 - index number of zero because computers
131:17 - always start with zero so if i display
131:19 - prices at index zero
131:22 - this contains the number five i'm
131:24 - actually going to format this let's
131:25 - display it two digits after the decimal
131:28 - and i'll precede this number with a
131:29 - dollar sign
131:31 - much better all right so then if i
131:33 - display prices at index one that is
131:36 - technically our second number of ten
131:38 - dollars
131:39 - so prices at index two
131:41 - is fifteen three
131:44 - is twenty five
131:46 - and four which is our last element
131:49 - is twenty so arrays they have a fixed
131:52 - size we can't change the size after we
131:54 - compile and run our program another
131:56 - thing that you can do too if you do not
131:58 - know what values you would like to
132:00 - initialize your array with you can
132:02 - always just set a size let's say i would
132:04 - like a size of five elements but then
132:06 - i'll assign some values later
132:09 - so later on in our program we can say
132:11 - prices
132:12 - at whatever index let's say index zero
132:14 - i'm going to assign with five and i'll
132:17 - do the same thing for the other elements
132:20 - so prices at index one is maybe ten
132:25 - prices at index two is fifteen
132:30 - three will be twenty five
132:34 - and 4 will be 20.
132:37 - that's another way in which you can
132:38 - initialize an array you can always set a
132:41 - size and then add elements later another
132:44 - option is that you could combine the two
132:46 - we could set a size right away so maybe
132:48 - prices will have a size of 10 and we can
132:51 - right off the bat assign some values
132:53 - right away so we have five elements that
132:56 - are currently filled but then the other
132:58 - five are empty so there's a few
133:00 - different ways in which you can
133:01 - initialize an array so yeah that's
133:03 - basically an array it's a data structure
133:05 - that can store many values of the same
133:08 - data type initializing an array is much
133:10 - like creating a variable except you will
133:12 - add a set of straight brackets after and
133:14 - then you can either add some values
133:16 - right away or later on in your program
133:18 - but you need to list an index number of
133:21 - where you're placing a value within the
133:22 - array and then to access a value within
133:25 - your array you type the array name
133:27 - followed by an index number kind of like
133:29 - a parking spot number so yeah those are
133:31 - arrays in the next video i'm going to
133:33 - show you how we can iterate over the
133:34 - elements in an array using a for loop if
133:37 - you would like a copy of this code i
133:39 - will post this to the comments section
133:40 - down below and well yeah that's an
133:42 - introduction to arrays in c
133:48 - hey welcome back everybody in this video
133:50 - i'm going to show you how we can loop
133:52 - through and print the elements of an
133:54 - array so i have an array of doubles
133:57 - named prices and i just made up some
133:59 - fictional prices to display one of these
134:01 - elements i can use a printf statement i
134:04 - will use the appropriate format
134:06 - specifier for the elements displayed
134:08 - within this array since this array
134:10 - contains doubles i will use the format
134:12 - specifier for a double then to access
134:15 - one of these elements i will type the
134:17 - name of my array followed by a set of
134:19 - straight brackets then an index number
134:21 - so the first element in an array is zero
134:24 - because computers always start with zero
134:26 - then if i need to display the other
134:28 - elements well i would have to manually
134:30 - type prices at index zero then one two
134:34 - three four so on and so forth so this
134:37 - does work if you have a couple elements
134:39 - but what if you have hundreds this
134:41 - method is not going to be practical a
134:43 - better solution is that we could make a
134:45 - for loop and this for loop will iterate
134:47 - once and display each element of this
134:49 - array so let's create a for loop for
134:52 - parentheses curly braces and we'll need
134:55 - an index int i i'll set this equal to
134:57 - zero
134:58 - then we'll need a condition for the time
135:00 - being let's set i less than five but
135:03 - later on we're going to replace five
135:05 - with something else and i'll explain
135:06 - that later and then we will increment i
135:09 - by one so then during each iteration
135:12 - let's use this print statement again
135:14 - and make one change instead of setting
135:17 - an index number let's use our index
135:19 - instead then i'm just going to add a new
135:21 - line character after each printf
135:23 - statement
135:24 - so here we go this for loop should
135:26 - iterate five times
135:28 - and it will display the elements within
135:30 - our array
135:32 - so we have 5 10 15 25 20. maybe i'll add
135:35 - a couple extra things to this format
135:37 - specifier let's display two digits and a
135:40 - dollar sign
135:41 - that's much better so this kind of
135:43 - resembles maybe a receipt of some sort
135:45 - like somebody just bought a bunch of
135:46 - items okay now here's one situation what
135:49 - if we add or remove elements from this
135:52 - array let's say that a user purchases
135:54 - one more item for thirty dollars now the
135:57 - way that this for loop is written it's
135:59 - not going to display this last element
136:02 - because we set this for loop to iterate
136:05 - as long as i is less than or equal to
136:07 - five it's not going to display this last
136:10 - element so we would need some way to
136:12 - update this condition
136:14 - a better solution instead of using a
136:16 - number here is that we could calculate
136:18 - the amount of elements within our array
136:21 - and loop that many times and one way in
136:23 - which we could do that is to use the
136:26 - size of operator so let me demonstrate
136:28 - the size of operator real quick it will
136:30 - return the size of an operand in bytes
136:34 - so let's print this
136:35 - so this will be an integer
136:37 - and we will use the size of operator and
136:41 - pass in our array of prices so this size
136:44 - is going to be in bytes
136:46 - so the size of our ray in bytes is 48
136:50 - bytes we have six elements made up of
136:53 - doubles each double uses up eight bytes
136:56 - so six times eight is 48 so now let's
137:00 - use the size of operator instead size of
137:04 - prices
137:05 - but we are going to divide the size of
137:07 - our array by the size of one of these
137:09 - elements they're all going to be
137:11 - consistent because they all have the
137:13 - same data type so we will take size of
137:16 - prices divided by
137:18 - the size of one of these elements let's
137:20 - say prices at index zero
137:24 - so 48 divided by
137:26 - eight equals six we will iterate through
137:29 - this for loop six times and here's our
137:32 - array we have 5 10 15 25 20 30 and we
137:37 - can add or remove elements freely and
137:39 - there's no need to update our code
137:41 - because we may not remember to do that
137:43 - later on
137:44 - so yeah that's one way to loop through
137:46 - and print the elements of an array you
137:48 - can use a for loop then use a printf
137:51 - statement and for the index of your
137:53 - array you can use the index of your for
137:55 - loop then if you would like your for
137:57 - loop to calculate how many times it's
138:00 - going to iterate through this array you
138:02 - can use the size of operator pass in
138:05 - prices divided by the size of one of the
138:08 - elements and that will calculate how
138:10 - many elements are within your array
138:12 - so yeah that's one way to loop through
138:14 - the elements of an array if you would
138:16 - like a copy of this code i'll post this
138:18 - to the comment section down below and
138:20 - well yeah that's how to loop through and
138:22 - print the elements of an array in c
138:28 - hey everyone two dimensional arrays it's
138:30 - an array where each element is an entire
138:33 - array it's useful if you need a matrix
138:36 - grid or table of data let's begin by
138:39 - creating a simple one-dimensional array
138:41 - of maybe some numbers so the data type
138:44 - is int
138:45 - the array name will be numbers and let's
138:48 - initialize this array with a few numbers
138:50 - 1 two and three something simple so if i
138:53 - would like to store a grid or matrix of
138:56 - data these elements will be the first
138:58 - row and i can add a second row
139:01 - so separate each row with a comma then
139:03 - another set of curly braces and then you
139:06 - can add more values so let's say four
139:08 - five and six and we'll stop here with
139:11 - these separate arrays we will surround
139:13 - with a set of curly braces
139:16 - and preceding the first set of straight
139:18 - brackets we will add a second set of
139:20 - straight brackets so this is now a two
139:23 - dimensional array however with a two
139:25 - dimensional array we have to specify a
139:27 - maximum size of elements within each of
139:30 - these arrays let's say that each of
139:32 - these arrays will have a maximum size of
139:35 - three elements a piece so within the
139:38 - second set of straight brackets i will
139:40 - list three and you can although it's not
139:42 - necessary set a maximum amount of arrays
139:46 - within your two-dimensional array
139:48 - so let's say two because we have two
139:51 - separate arrays within our
139:52 - two-dimensional array now to better
139:54 - visualize how this is more or less a
139:56 - table of data i'm going to rearrange
139:58 - these
140:02 - so this may be a better visualization
140:04 - this first set of straight brackets is
140:06 - for the number of rows and the second
140:08 - set of straight brackets is for the
140:10 - number of columns so we have two rows
140:13 - and three columns within our
140:15 - two-dimensional array now you can
140:17 - declare a two-dimensional array but not
140:19 - assigned values quite yet but you'll
140:21 - need to set a maximum size so right now
140:23 - i'm just going to turn this into one
140:25 - giant comment
140:26 - and let's declare a two-dimensional
140:29 - array with two rows and three columns
140:33 - and here's how to assign some values we
140:35 - will type the name of the array followed
140:37 - by two sets of straight brackets we need
140:40 - a row number and a column number so the
140:42 - first column within the first row is
140:44 - going to be zero zero because computers
140:47 - always start with zero
140:49 - and let's assign this a value of one the
140:51 - second column within the first row
140:54 - would be
140:56 - zero one and let's assign two there
140:59 - then zero two and that will be number
141:02 - three so the first column within the
141:04 - second row would be numbers one zero and
141:08 - this will be four then we will follow
141:10 - the same pattern so where five was that
141:13 - would be one one
141:16 - and six is one two
141:20 - so this is another way to initialize an
141:22 - array you can set a maximum size and
141:24 - then assign some values later or you
141:27 - could assign all of the values right
141:28 - from the beginning if you know what they
141:30 - are okay now how can we display the
141:32 - elements of a two-dimensional array
141:34 - we'll have to use nested loops
141:36 - so let's create a for loop and i will
141:39 - declare an index of i
141:41 - set this equal to zero and for the time
141:43 - being i'm going to say i
141:45 - is less than the number of rows that we
141:47 - have so right now we have two rows but
141:50 - we're going to change this value later
141:51 - to something that's more flexible that
141:53 - will calculate the amount of rows that
141:55 - we have and then i will increment i by
141:57 - one now let's create a nested loop
142:00 - that's in charge of keeping track of the
142:02 - columns
142:03 - and let's use an index of j because we
142:06 - do not want to reuse i
142:08 - so set j equal to zero we will continue
142:12 - this as long as j
142:14 - is less than however many columns we
142:16 - have three a maximum of three and then
142:19 - increment j by one so during each
142:22 - iteration of the inner for loop let's
142:24 - display one of these elements so we will
142:26 - use the format specifier for an integer
142:29 - d is fine
142:30 - followed by our array numbers and then
142:33 - we have two indices so the row is going
142:36 - to be i
142:38 - and this will begin at zero
142:40 - and the columns is j this will also
142:42 - begin at zero so after each iteration of
142:46 - the inner for loop we will increase j
142:48 - when we finish the inner for loop we
142:50 - will increment i by one so by using
142:53 - nested for loops we can iterate over all
142:55 - of the elements of this array so i'm
142:57 - just going to add a space after our
142:59 - number and we should probably add a new
143:02 - line after each row so i'll add a new
143:04 - line let's test this
143:07 - here we go we have our table of two rows
143:10 - and three columns now there's one
143:12 - situation that we may run into what if
143:14 - we change the amount of rows and columns
143:17 - that we have so let's say that we add
143:19 - one more row our 2d array of numbers
143:21 - will have three rows and three columns
143:25 - row two column zero equals seven
143:28 - row two column one will equal eight and
143:32 - row two column two will equal nine so if
143:35 - i were to run this again well this last
143:37 - row is not going to be displayed so it
143:40 - would be better if we can calculate how
143:42 - many rows and columns are within our
143:44 - two-dimensional array and here's one way
143:46 - to do so i'm going to declare two new
143:48 - variables int rows
143:50 - and into columns and i will set the
143:53 - condition of the outer for loop to be as
143:55 - long as i is less than rows and the
143:59 - inner for loop will be j is less than
144:01 - columns
144:02 - now we just need to calculate what these
144:04 - numbers are going to be to calculate
144:06 - rows we can use the size of operator and
144:09 - then pass in the entire size of our
144:12 - two-dimensional rib and we're going to
144:13 - divide this by the size of one of our
144:16 - rows they're all going to have the same
144:18 - size so we can pass in our rain numbers
144:21 - and then specify one of the rows let's
144:23 - say the first row they're all going to
144:25 - be the same okay so that's how we can
144:27 - calculate the number of rows that we
144:28 - have now to find the number of columns
144:30 - we can copy what we have here and then
144:32 - just make a few changes
144:34 - so we will say
144:36 - the size of the first row row 0
144:39 - divided by the size of one of the
144:41 - elements found within the first row
144:44 - so we can say zero zero and let's print
144:47 - the amount of rows and columns that we
144:49 - have just to test it
144:54 - so we have rows
144:56 - and columns
144:59 - i'm just going to add a new line
145:01 - character real quick
145:05 - okay so we have three rows three columns
145:08 - and here's our table three rows with
145:10 - three columns a piece so yeah that's
145:12 - basically a two-dimensional array it's
145:14 - an array of arrays where each element is
145:17 - an entire array it's useful if you need
145:19 - a matrix grid or table of data and in
145:23 - this example we made a table of integers
145:25 - just the numbers one through nine so
145:27 - there's a couple different ways in which
145:29 - you can initialize a two-dimensional
145:31 - array but you'll need two sets of
145:33 - straight brackets it's optional to set a
145:35 - maximum number of rows but it is
145:38 - necessary to set a maximum number of
145:40 - elements within each row and then to
145:42 - access one of the elements you use two
145:44 - indices one for the row one for the
145:47 - column so yeah those are two dimensional
145:49 - arrays if you would like a copy of this
145:50 - code i'll post this to the comment
145:52 - section down below and well yeah those
145:54 - are two dimensional arrays in c
146:00 - hey everyone in this video i'm going to
146:02 - show you how we can create an array of
146:04 - strings let's say we will have an array
146:07 - named cars
146:08 - so we will need a two-dimensional array
146:11 - so we need two sets of straight brackets
146:13 - and within the second set of straight
146:15 - brackets we will specify a maximum size
146:18 - for each of these elements let's say
146:20 - maybe 10 characters so a string is
146:22 - already an array of characters let's add
146:25 - our first string maybe we have a mustang
146:27 - so to add a second element we would
146:29 - separate the next one with a comma then
146:31 - we can add another string
146:33 - let's say we have a corvette and then
146:35 - one more how about a maybe camaro okay
146:38 - so with all of these different strings
146:40 - i'm going to surround with a set of
146:42 - curly braces and here we go we have an
146:44 - array of strings it's basically a 2d
146:47 - array of individual characters except
146:50 - each element is a string now one
146:52 - important difference with an array of
146:54 - strings is that we can't directly change
146:56 - one of the values
146:58 - let's say car's at index zero equals a
147:01 - tesla
147:02 - and then i'm going to try and run this
147:06 - so we can't directly assign a new value
147:08 - one way in which we can do so is to use
147:10 - the string copy function so if you're
147:13 - going to use the string copy function
147:15 - include this import
147:17 - string dot h okay so to update one of
147:20 - the values i will use string
147:23 - copy
147:25 - pass in my array
147:27 - and an index number
147:29 - followed by a string so let's say a
147:32 - tesla and this would work now to display
147:35 - an array of strings we can use a for
147:37 - loop
147:38 - and there's no need for a nested loop so
147:40 - we will create an index i set this equal
147:43 - to zero i would like to continue this as
147:45 - long as i is less than and we will
147:48 - calculate how many elements are within
147:50 - our array so we will use the size of
147:52 - operator pass in our array divided by
147:55 - one of the elements
147:57 - size of
147:59 - cars and maybe the first element of zero
148:02 - and then increment i by one during each
148:04 - iteration so then during each iteration
148:07 - let's display one of these elements
148:08 - using a printf statement
148:10 - let's display a string
148:12 - i'll add a new line after each printf
148:14 - statement
148:15 - and let's display our array cards at
148:18 - index of i
148:19 - so this should display tesla corvette
148:22 - and camaro in that order
148:24 - tesla corvette and a camaro so yeah
148:27 - that's an array of strings it's really a
148:29 - two-dimensional array of characters but
148:32 - it involves less steps because each of
148:34 - these strings is already an array and if
148:36 - you need to update or edit one of the
148:38 - values you can use the string copy
148:40 - function so yeah that's how to work with
148:42 - an array of strings if you would like a
148:44 - copy of this code i'll post this to the
148:46 - comments section down below and well
148:48 - yeah that's how to work with an array of
148:50 - strings in c
148:54 - all right what's going on people so in
148:56 - this video i'm going to show you how we
148:57 - can swap the values of two variables now
149:00 - you may be wondering why the heck do we
149:01 - need to know this so swapping variables
149:04 - is actually very common within sorting
149:06 - algorithms and when we reach the next
149:08 - topic on sorting arrays we'll need to
149:10 - learn how to do this so let's begin i
149:12 - have two variables x and y x contains
149:15 - the letter x y contains the letter y and
149:18 - let's print these values i'll use a
149:20 - printf statement let's display x
149:25 - and y
149:30 - x equals x y equals y so how can we swap
149:33 - these let's try x equals y and see what
149:36 - happens within both x and y the value is
149:39 - y what about y equals x
149:42 - well then both variables contain the
149:44 - character x so what can we do it seems
149:46 - like we're stuck what we could do is
149:48 - that we could introduce a third variable
149:51 - let's say char and let's name this temp
149:53 - because it's a temporary variable so we
149:56 - have a third variable to work with as
149:58 - temporary storage for some value so
150:01 - let's assign
150:02 - temp is equal to x
150:05 - and then we will assign
150:07 - x equals y
150:09 - and then lastly y equals temp
150:12 - and this should work let's try it
150:15 - yep x equals y and y equals x
150:18 - now this is a little bit different if
150:20 - you're working with strings so let's say
150:22 - these are character arrays
150:26 - and we'll pretend that these are maybe
150:27 - glasses holding some fluid x contains
150:30 - water
150:32 - and y contains maybe lemonade
150:35 - and let's make temp a character array as
150:37 - well but we need to declare a size let's
150:40 - say 15. okay so this isn't gonna work
150:42 - we're already receiving problems
150:44 - expression must be a modifiable l value
150:47 - so when working with arrays it's not
150:49 - enough to simply assign values
150:52 - we could use the string copy function so
150:55 - let's get rid of these and we will use
150:58 - string copy oh also make sure that you
151:00 - include this header file okay so we will
151:03 - copy the contents
151:05 - of x
151:07 - over to temp
151:09 - and it's the same procedure as before
151:11 - string
151:12 - copy y
151:15 - over to x
151:16 - and string
151:18 - copy
151:21 - temp over to y
151:23 - and then make sure you change these
151:24 - format specifiers to strings
151:27 - x did contain water now it contains
151:29 - lemonade y did contain lemonade and now
151:32 - it contains water
151:33 - when swapping variables i like to
151:35 - imagine my variables as glasses and they
151:37 - contain some fluid if we pour the
151:40 - contents of one glass into the other
151:42 - well then the contents will be pushed
151:44 - out and overflow so it would be wise of
151:46 - us to introduce a third glass that's
151:48 - empty to hold one of these fluids so
151:51 - then we can pour the contents of one
151:53 - variable into the other now here's one
151:55 - issue that you may run into when using
151:57 - the string copy function if the length
152:00 - of the second argument is less than the
152:03 - first argument this can lead to
152:05 - unexpected behavior i'm going to replace
152:07 - lemonade with soda and let's see what
152:09 - happens
152:10 - so x doesn't contain anything but y
152:12 - contains water one solution is that we
152:15 - can make these character arrays the same
152:17 - size
152:17 - let's say that they're both 15
152:20 - and that should solve that issue so
152:22 - that's something you may need to take
152:23 - into consideration when using the string
152:25 - copy function if you're going to swap
152:27 - strings so yeah everybody that's how to
152:29 - swap the values of two variables if you
152:32 - would like a copy of this code i'll post
152:34 - this to the comment section down below
152:35 - and in the next video i'm gonna show you
152:37 - how we can sort the elements within an
152:39 - array and well yeah that's how to swap
152:41 - the values of two variables in c
152:47 - hey uh what's going on people so in this
152:49 - video we're going to write a small
152:50 - program to sort the elements of an array
152:53 - let's begin with an array of integers
152:55 - and then later we'll create an array of
152:56 - characters the data type will be int and
152:59 - let's name this array
153:01 - and assign some values make sure that
153:03 - they're not in order just make up some
153:05 - numbers that's fine
153:08 - looks good to me now let's calculate the
153:10 - size of our array because we'll need to
153:11 - know how many times we're going to
153:13 - iterate through our array so int size i
153:16 - will set this equal to the size of
153:19 - operator pass in our array this will
153:22 - calculate the size of our array in bytes
153:24 - and to find the number of elements we
153:26 - can divide this by the size of just one
153:29 - element so size of array divided by the
153:32 - size of array at index of zero
153:36 - size will equal the amount of elements
153:38 - within our array and just to keep this
153:40 - code more organized let's declare a
153:42 - function to actually sort all of this
153:44 - for us so we don't have to do that
153:46 - within the main function
153:48 - so let's declare a sort function the
153:51 - return type is void we're not returning
153:52 - anything and let's name this sort
153:56 - and there will be two parameters
153:58 - an array of integers
154:01 - and integer size
154:05 - and let's invoke this function we're
154:06 - invoking sort and then we need to pass
154:08 - in two arguments
154:10 - our array
154:11 - and a size
154:13 - within the sort function we'll need
154:15 - nested loops we can use four loops
154:18 - so the outer for loop will be int i set
154:21 - this equal to zero and we will continue
154:24 - this for loop as long as i is less than
154:27 - the size of our array minus one and then
154:30 - increment i by one and then we need an
154:32 - inner for loop so let's copy our outer
154:34 - for loop paste it and make a few changes
154:38 - so the index for the inner loop will be
154:40 - j
154:41 - and we'll continue this as long as j is
154:44 - less than the size of our array minus
154:46 - one then j plus plus
154:49 - here's what we're doing within our array
154:50 - so we will begin at our first index
154:52 - we're checking to see if the element on
154:54 - the left is greater than the element on
154:56 - the right if so we're going to swap
154:58 - these two values and we'll need the help
155:00 - of a temporary variable much like what
155:02 - we learned in the last topic so let's
155:05 - check to see if the element on the left
155:06 - is greater than the element on the right
155:08 - if it isn't we do nothing
155:10 - so we need an if statement
155:13 - if array
155:15 - at index of j
155:18 - is greater than array at index of j plus
155:23 - one
155:24 - we're adding plus one because we're
155:25 - checking the element directly next to
155:27 - the one that we're currently examining
155:29 - so if the number on the left is greater
155:31 - than the number on the right we will
155:33 - perform a basic variable swap
155:36 - so let's declare a variable in temp to
155:39 - temporarily store some value and i will
155:41 - set the sequel to array at index of j
155:45 - now i need to move the element on the
155:47 - right over to the element on the left
155:50 - array
155:51 - at index of j
155:53 - equals array at index of j
155:56 - plus one and then lastly whatever's
155:58 - within temp i'm moving that to the
156:00 - element on the right so array at index
156:04 - of j plus one
156:06 - equals temp and that's it so if you
156:10 - would like to optimize this you can set
156:12 - size
156:13 - minus i
156:14 - minus one basically this is a bubble
156:17 - sort so depending on the size of this
156:19 - number it's going to find a final
156:20 - resting place since 9 is going to be the
156:23 - largest it's going to be pushed all the
156:25 - way to the right because we will examine
156:27 - 9 against each of these numbers so once
156:30 - 9 is pushed all the way to the right all
156:32 - these other numbers that are less than 9
156:34 - will be on the left so it's already
156:36 - partially organized and now we just need
156:38 - some way to display the elements of our
156:40 - array so let's declare a print function
156:43 - void and let's name this print array
156:47 - and these will have the same parameters
156:49 - an array of integers and into size
156:52 - and this is a basic for loop
156:55 - so for
156:56 - and i set this equal to zero
156:59 - we will continue this loop as long as i
157:01 - is less than the size of our array and
157:04 - increment i by one
157:06 - and i would like to display each integer
157:09 - and maybe i'll separate these with the
157:10 - space and we are displaying our array at
157:13 - index of i and all we have to do is
157:16 - invoke the print array function
157:19 - and then pass in our array and our size
157:23 - and let's take a look fingers are
157:24 - crossed
157:26 - oh yeah there we go our array is now
157:28 - sorted now if you would like this in
157:31 - descending order all we have to do is
157:33 - switch this if statement around from
157:35 - greater than to less than
157:38 - and our array is sorted in reverse order
157:40 - and we could sort an array of other data
157:42 - types too this time let's sort an array
157:44 - of characters so let's declare an array
157:47 - of characters this time
157:50 - and make up some characters
157:57 - so then to sort an array of characters
157:59 - let's change the data type of our array
158:02 - to characters
158:06 - and then when we display each character
158:08 - make sure that we're using the c format
158:10 - specifier because we were using d before
158:13 - and this should now be sorted
158:17 - yep so that's currently in reverse order
158:19 - so then to switch that around just
158:21 - change the sign
158:23 - all right there you go so yeah everybody
158:25 - that is a simple program to sort the
158:28 - elements of an array this is a basic
158:31 - bubble sort and if you're interested in
158:32 - learning more about sorting algorithms i
158:34 - do have a playlist on data structures
158:36 - and algorithms if you would like a copy
158:38 - of this code i'll post this in the
158:40 - comments section down below and well
158:42 - yeah that's how to sort a simple array
158:45 - in c
158:49 - okay everybody so let's talk about
158:51 - structs a struct is short for structure
158:54 - think of it as a collection of related
158:57 - members kind of like variables they can
158:59 - be of different data types unlike with
159:01 - arrays structs are listed under one name
159:04 - in a block of memory in order to refer
159:06 - to that struct we can refer to a
159:08 - variable name and then we have access to
159:10 - that block of memory that contains
159:12 - related members and lastly structs are
159:16 - very similar to classes in other
159:18 - languages if you're familiar with more
159:20 - than just c you'll probably know what a
159:22 - class is but there are no methods within
159:24 - a struct it's only members so we can
159:27 - actually use structs to mimic real world
159:29 - objects let's say that maybe we're
159:31 - playing a game and we need two players
159:34 - each player will have a name and a score
159:37 - these will be the members so to create a
159:39 - struct outside of our main function we
159:41 - will type the keyword struct followed by
159:44 - a tag name let's say we are working with
159:46 - players then we need a set of curly
159:49 - braces then end it with a semicolon so
159:52 - any members think of these like
159:53 - variables so let's say we have a
159:55 - character array named name and i'll give
159:58 - this a size of maybe 12.
160:00 - so we will declare these but not assign
160:02 - them we'll do that later and we have an
160:05 - int named score so each player is going
160:08 - to have a name and a score kind of like
160:11 - we're playing an arcade game now to
160:13 - assign some of these values we're going
160:14 - to create a type of variable and a
160:17 - player is going to be kind of the data
160:19 - type so we will type struct
160:22 - then the tag name
160:23 - which was player
160:26 - and then a variable name let's say we
160:28 - have player 1 and player 2. so with
160:30 - these structs you can reuse them so we
160:32 - have struct player player 1 and struct
160:35 - player player 2. so we can assign values
160:38 - to these members however if we have an
160:40 - array of characters we're going to use
160:42 - the string copy function
160:44 - so let's use the string copy function
160:48 - then to access one of the members you
160:50 - will type the name of that struct so
160:52 - let's say player one and then follow
160:54 - this with a dot the dot is a member axis
160:58 - operator so after typing the dot we have
161:01 - access to a name and score member so
161:04 - let's set the player's name equal to
161:06 - whatever your first name is now if
161:08 - you're not working with an array of
161:09 - characters such as an integer you can
161:11 - just access these directly so let's set
161:14 - player one's score two equal maybe four
161:17 - points and we also have player two but
161:19 - we have not assigned values to its
161:21 - members
161:22 - so this time let's assign player two's
161:25 - name and score
161:27 - so we can just copy what we have but
161:29 - change player 1 to player 2. player 2
161:32 - let's say is bra and player 2's score is
161:36 - 5. now if i would like to display these
161:38 - members i can do so with a print
161:40 - statement so printf let's display our
161:43 - name first so i will use the s format
161:45 - specifier
161:47 - player one dot name and then i'll add a
161:49 - new line then to access player one's
161:52 - score well that's an integer so i will
161:54 - use the d format specifier player one
161:57 - dot score and then let's do the same
162:00 - thing with player two
162:02 - so player two dot name and player two
162:05 - dot score so we have our player one
162:08 - strucks name member as bro and score
162:11 - member set to four and then our player
162:13 - two struct has a name member of bra
162:17 - and a score member of five so yeah
162:20 - that's basically a struct it's a
162:22 - collection of related members think of
162:24 - these kind of like variables they can be
162:27 - of different data types unlike arrays
162:29 - and they are listed under one name in a
162:31 - block of memory so in this example we
162:33 - have player 1 and player 2. player 1 and
162:36 - player 2 refer to different blocks of
162:38 - memory which contain their own unique
162:41 - members if you're familiar with other
162:43 - programming languages they're very
162:45 - similar to classes but they cannot
162:48 - contain any methods so yeah those are
162:50 - structs if you would like a copy of this
162:52 - code i'll post this to the comment
162:53 - section down below and well yeah those
162:56 - are structs in c
163:01 - all right typedef typedef is a reserved
163:04 - keyword that gives an existing data type
163:07 - a nickname here's an example let's
163:09 - create a character array of 25 bytes and
163:13 - we'll say that this is user one so
163:15 - character
163:16 - user one and the size is 25 bytes
163:20 - and then make up some username
163:23 - okay so writing some of the syntax can
163:25 - be somewhat tedious what a lot of c
163:27 - programmers will do is that they will
163:29 - use this type def keyword to give some
163:32 - data type a nickname let's use this type
163:35 - def keyword to give a character array of
163:38 - 25 bytes some nickname so i'll do this
163:40 - outside of the main function we will
163:42 - type type def
163:44 - then our data type
163:46 - so this is a character array of 25 bytes
163:50 - and we need some sort of nickname so
163:51 - let's say that a character array of 25
163:54 - bytes will be known as a user
163:58 - now i don't need all of the syntax now i
164:00 - can type my data type
164:02 - user and then some variable name let's
164:04 - say user one from this point forward if
164:07 - i need a character array of 25 bytes i
164:10 - can call that a user that's my nickname
164:13 - now one place where you see this used a
164:15 - lot is with structs this time let's
164:17 - create a struct at first we won't use
164:20 - the typedef keyword and then i'll show
164:21 - you the benefits later so let's say this
164:24 - is a struct
164:25 - and the tag name is user
164:27 - users will have let's say three members
164:30 - a character array named name of 25 bytes
164:35 - a password of 12 bytes
164:40 - and int id like an id number
164:43 - so to create a struct we would have to
164:45 - type struct
164:47 - then the tag name
164:48 - user
164:49 - and a variable name
164:51 - and let's assign some of these values
164:53 - i'll assign a name password and id
164:59 - looks good to me okay then if i need to
165:01 - create user two
165:04 - i would type again struct user some
165:06 - unique variable name and make up some
165:08 - values
165:11 - okay so with a strut if i would like to
165:13 - use the typedef keyword i will precede
165:16 - the struct keyword with typedef
165:20 - and i don't necessarily need this tag
165:22 - name and after the last curly brace here
165:25 - i will add my nickname i'll call this a
165:27 - user if we need to create a user struct
165:30 - we no longer need to use the struct
165:32 - keyword we can remove this
165:35 - and this should work so let's print some
165:37 - of these members
165:54 - and here are the two users that we
165:57 - created yeah so in conclusion typedef is
166:00 - a reserved keyword that gives an
166:02 - existing data type a nickname and it's
166:05 - mostly used for convenience if we use
166:07 - the typed up keyword when declaring a
166:09 - struct we no longer need to use that
166:12 - struct keyword to create a struct we can
166:14 - just use this nickname as the data type
166:17 - and then come up with some unique
166:19 - variable name so yeah that is the
166:21 - typedef keyword if you found this video
166:23 - helpful please be sure to give this
166:24 - video a thumbs up leave a random comment
166:26 - down below and subscribe if you'd like
166:28 - to become a fellow bro
166:32 - hey everybody so in this video i'm going
166:34 - to show you how we can create an array
166:36 - of structs let's say we're working with
166:38 - students and we need to print each
166:40 - student's name and gpa so let's create a
166:43 - struct outside of our main function type
166:46 - struct and then a tag name for the
166:48 - struct let's say student so each student
166:51 - will have a name and a gpa
166:53 - so let's create a character array named
166:56 - name i'll set a maximum size of maybe 12
166:58 - characters
167:00 - and a gpa that could be a float
167:03 - so float gpa now let's initialize some
167:06 - structs we type struct followed by the
167:09 - tag name and then some variable name to
167:11 - identify each struct so let's say we
167:13 - will have four students overall and i'll
167:16 - go ahead and assign some values right
167:17 - away when we initialize the struct so we
167:20 - need a name and a gpa so the first
167:22 - student let's say is spongebob
167:25 - and spongebob has a gpa of 3.0
167:28 - so we can copy this and create a few
167:31 - more students so student one student two
167:34 - student three and student four
167:37 - next we have patrick
167:39 - patrick has a 2.5
167:42 - then sandy sandy is smart so she has a
167:45 - 4.0 and squidward
167:49 - squidward has a 2.0 so we have four
167:52 - students now we will create an array so
167:55 - the data type of our array what it's
167:56 - containing will be struxx it will be
167:59 - struct student it's kind of like the
168:01 - data type so with an array you have to
168:03 - declare what you're going to be putting
168:04 - within the array struct students and
168:07 - then we need an array name so this will
168:09 - be students and then specify a maximum
168:12 - size if you need one but i'm just going
168:14 - to initialize this array with some
168:16 - students so let's add student 1
168:19 - student 2
168:22 - student 3
168:23 - and student 4 and there we go we have an
168:26 - array of structs
168:28 - now if i would like to display each
168:30 - student's name i can use a for loop to
168:32 - loop through our array
168:34 - so for
168:36 - curly braces we will create an index
168:38 - into i set this equal to zero
168:41 - we will loop through this as long as i
168:43 - is less than and then we need to
168:45 - calculate how many elements are within
168:47 - our array so we have four elements but
168:49 - we can do that by using the size of
168:51 - operator passing our array and then
168:54 - divide this by the size of one of these
168:56 - elements
168:58 - size of students and then pick maybe the
169:00 - first element of zero after each
169:02 - iteration we will increment i by one so
169:05 - then within our for loop let's print
169:07 - each student's name
169:09 - so let's use the s format specifier to
169:12 - display a string and we will display our
169:15 - array at index of i whatever our counter
169:19 - is
169:20 - and we will use the member axis operator
169:23 - of dot so follow students at index of i
169:26 - with a dot then we have access to a name
169:29 - and a gpa so let's display each
169:31 - student's name and then i'll add a new
169:33 - line after each printf statement
169:36 - so there we go we have spongebob patrick
169:38 - sandy and squidward now let's display
169:41 - each student's gpa so let's copy this
169:43 - line
169:44 - we are displaying a float so the format
169:47 - specifier for a float is f
169:49 - students at index of i
169:52 - dot
169:52 - gpa then i'll get rid of that new line
169:55 - character and let's take a look to see
169:57 - what we have
169:58 - okay we can see each student's name and
170:00 - gpa but we may want to format this
170:03 - so after each student's name i'll add a
170:05 - tab and i'll allocate maybe 12
170:08 - characters to display each student's
170:10 - name and then left justify it and then
170:13 - with our gpa let's display two digits
170:15 - after the decimal so i will add
170:17 - dot 2
170:19 - so this should look better
170:20 - yeah that's much more organized so we
170:22 - have spongebob with the gpa of 3.0
170:25 - patrick with 2.5 sandy with 4.0 and
170:29 - squidward with a 2.0 so yeah that's how
170:32 - to create an array of structs if you
170:34 - would like a copy of this code i'll post
170:35 - this to the comment section down below
170:37 - and well yeah that's how to create an
170:39 - array of structs in c
170:44 - well well well welcome back so enums
170:47 - short for enumerations they are a
170:50 - user-defined type of named integer
170:53 - identifiers a benefit is that they help
170:56 - make a program more readable either for
170:58 - us or for somebody else that's looking
171:00 - over our code so here's how to create
171:02 - some enums you can either declare these
171:04 - within the main function or outside of
171:06 - the main function let's do so outside of
171:08 - the main function so to create some
171:10 - enums type the keyword enum followed by
171:13 - a unique identifier let's say we're
171:14 - working with days of the week so let's
171:17 - say day
171:18 - curly braces and then end this with a
171:21 - semicolon so enums are constants and
171:24 - let's declare some constant names let's
171:26 - say the seven days of the week so
171:28 - separate each constant with a comma and
171:30 - we will just go through the days of the
171:31 - week
171:36 - here are the enumerations that we
171:37 - declared the days sunday through
171:40 - saturday the days of the week now each
171:42 - of these constants has an associated
171:44 - integer so beginning with your first
171:46 - constant this will have a value of zero
171:50 - then the next will have one
171:52 - then two then three then you continue on
171:54 - in that pattern but you can give these a
171:57 - unique value let's change it sunday to
171:59 - one because it's the first day of the
172:00 - week then monday will be two and then we
172:03 - will just continue with these
172:06 - now to use one of these enums we would
172:08 - type enum then our identifier name day
172:12 - it's kind of like a data type and then
172:14 - some variable name let's say today and
172:16 - then you can set the sequel to one of
172:18 - these constant names let's say that
172:19 - today is sunday
172:21 - so an important note with these
172:22 - enumerations they're treated as integers
172:25 - and not strings if i need to work with
172:27 - one of these enums we're going to treat
172:29 - them as if they were an integer so just
172:31 - for an example i'm going to print the
172:34 - value contained within today so this is
172:36 - going to be an integer so we will use
172:38 - the d format specifier and we will
172:41 - display today
172:42 - so since today is equal to sunday this
172:45 - has an associated integer value of one
172:48 - and if i display that
172:50 - this will print the number one if i
172:52 - change this to saturday well then it
172:54 - will print the number seven
172:57 - so an important note is that enums are
173:00 - not strings but they can be treated as
173:02 - integers now how does this make a
173:05 - program more readable so let's write an
173:07 - if-else statement that's going to check
173:08 - what today is
173:11 - first we'll begin with using the
173:12 - associated integer value so if today
173:16 - is equal to 1
173:18 - or
173:19 - today
173:20 - is equal to 7
173:22 - then that means it's either sunday or
173:24 - saturday and let's print a message
173:26 - let's say it's the weekend
173:30 - party time
173:31 - else we will print something else
173:35 - i have to work today
173:38 - so today is set to saturday that means
173:41 - that saturday has an associated integer
173:43 - of seven
173:44 - so if today is equal to one or seven
173:48 - well then we will execute this if
173:50 - statement it's the weekend party time i
173:54 - think i'm just going to add a new line
173:55 - real quick
173:57 - now if i set this to a different day of
173:58 - the week let's say monday
174:00 - well then i have to work today so the
174:03 - way that this is written now
174:05 - it's not too readable so instead of
174:07 - using an integer value let's use the
174:10 - associated name with each of these
174:12 - constants so let's replace
174:14 - one with sunday
174:16 - and seven with saturday and i'll change
174:19 - this to maybe sunday
174:21 - so this is a lot more readable
174:23 - especially if somebody else is reviewing
174:25 - your code they may not understand why
174:27 - today is equal to one or today is equal
174:30 - to seven but this makes a lot more sense
174:33 - oh so if today is equal to sunday or if
174:37 - today is equal to saturday then we print
174:40 - it's the weekend party time so that's a
174:43 - huge benefit with enums is that they
174:45 - help make a program more readable so to
174:48 - declare enums you type enum then an
174:51 - identifier and then you can list as many
174:53 - constants as you would like and you can
174:56 - give them an associated integer value
174:58 - too so yeah those are enums if you'd
175:00 - like a copy of this code i'll post this
175:02 - to the comments section down below and
175:04 - well yeah those are enums in c
175:10 - hey uh what's going on everybody so in
175:12 - this video i'm going to show you how we
175:14 - can generate some random numbers in c
175:16 - just as a disclaimer these are
175:18 - pseudorandom numbers they are a set of
175:20 - values or elements that are
175:22 - statistically random so don't use these
175:25 - for any sort of cryptographic security
175:27 - now before we begin include these two
175:29 - header files at the top
175:31 - stdlib and time the first thing that
175:33 - we're going to do is use the current
175:35 - time to generate a seed which we need
175:37 - for random numbers so we can use the s
175:40 - rand function s for seed rand for random
175:44 - and then we will pass in the current
175:46 - time
175:47 - time function pass and zero so we will
175:50 - use the current time as a seed for
175:53 - random numbers and then the function
175:55 - that you need to generate a random
175:56 - number using this seed is the rand
175:59 - function so let's store our number
176:01 - within a variable maybe number one int
176:04 - number one and i will set the sequel to
176:06 - then invoke the rand function now the
176:08 - rand function will give you a random
176:10 - number between 0 and 32 767.
176:14 - so i'm guessing we probably don't need a
176:16 - number that large so depending on the
176:18 - range of numbers that we need we can use
176:20 - modulus and then the maximum number that
176:23 - you would like so if i'm rolling a six
176:25 - sided dice i can say modulus six so the
176:28 - modulus operator gives you the remainder
176:30 - of any division so technically this
176:32 - gives us a random number between zero
176:34 - and five because computers always start
176:36 - with zero but you can add an offset so
176:38 - if i need the numbers one through six i
176:40 - can just add plus one to the end and
176:42 - then maybe i'll surround this section
176:43 - with a set of parentheses just to make
176:45 - this more readable so generate a random
176:47 - number between zero and five add one
176:50 - that gives us a random number between
176:52 - one and six and let's just test that
176:54 - theory so i'm going to use printf and we
176:57 - are displaying an integer
176:59 - and let's display number one so we
177:02 - should have a random number between one
177:04 - and six
177:05 - and our random number is two and if i
177:08 - run this again this will be a different
177:09 - number probably yup six okay now if i
177:12 - need to generate a couple different
177:13 - random numbers i can just use this rand
177:16 - function again so let's say we are
177:18 - rolling three dice
177:19 - number one number two and number three
177:22 - and then i'll print these as well
177:24 - so number one number two and number
177:26 - three and i'll add a new line character
177:29 - after each of these print statements
177:31 - okay so this will give us three random
177:34 - numbers between one and six one three
177:36 - one
177:37 - three five six
177:39 - now it is important that we're
177:40 - generating a random seed let me show you
177:42 - what happens when i take this out
177:44 - so this will give us the same numbers
177:46 - over and over again six six five
177:49 - six six five
177:50 - and six six five so that's why it's
177:52 - important that we use a seed for random
177:55 - numbers now another thing too if you
177:57 - need a larger number you can just change
177:58 - this number for example i play a lot of
178:01 - dungeons and dragons so i may need to
178:02 - roll a 20-sided dice so i can just set
178:05 - this to 20.
178:07 - so 288
178:09 - and let's try this again 12-5-4 so yeah
178:12 - that's how to generate some random
178:14 - numbers in c if you would like a copy of
178:16 - this code i'll post this to the comment
178:17 - section down below and well yeah that's
178:19 - how to generate some random numbers in c
178:23 - hey y'all what's going on everybody it's
178:25 - you bro hope you're doing well and in
178:27 - this video we're going to create a
178:28 - number guessing game in c so sit back
178:31 - relax and enjoy the show
178:35 - if you find this video helpful please
178:37 - remember to like comment and subscribe
178:40 - your support will help keep this channel
178:42 - running hey everybody so now that we
178:44 - know how to generate some pseudo-random
178:46 - numbers in c i thought this would be a
178:48 - good opportunity for us to create a
178:50 - number guessing game if we're working
178:52 - with pseudorandom numbers be sure to
178:54 - include at least these three header
178:56 - files at the top of your program so
178:58 - let's generate two constants min and max
179:02 - const int and a naming convention for
179:04 - constants is to make all of the letters
179:06 - uppercase
179:08 - so minimum will be the minimum number
179:10 - that we will generate when we generate a
179:12 - random number so let's pick a number
179:14 - between maybe one and one hundred so min
179:17 - will be one
179:18 - and max will be 100 but feel free to
179:21 - take the liberty to choose some other
179:23 - numbers and we'll need int guess to
179:26 - store a user's guess
179:28 - int guesses to keep track of the guesses
179:31 - and int
179:33 - answer okay now if we're working with
179:35 - random numbers we'll want to create a
179:37 - seed and to do that we can actually use
179:39 - the current time so use the s rand
179:42 - function and pass in time pass in zero
179:46 - so this uses the current
179:49 - time as a seed to generate some random
179:52 - numbers
179:54 - and if we need a random number between
179:56 - these two constants min and max this is
179:59 - what we can do
180:00 - so we will assign answer set this equal
180:03 - to
180:04 - call the rand function
180:06 - and use the modulus operator
180:09 - and set this to max and then we will add
180:11 - min as an offset
180:14 - so this will generate a random number
180:16 - between these two constants 1 and 100 or
180:20 - some other numbers if you have something
180:22 - different so this line of code will
180:24 - generate a random number
180:27 - between
180:28 - min
180:29 - and max
180:31 - now before we actually move on let's
180:33 - test this just to be sure that
180:34 - everything's working
180:36 - so let's print whatever the answer is so
180:39 - we're displaying an integer we are
180:40 - displaying
180:42 - answer
180:43 - and let's see what this is
180:46 - so my answer this round is 73 if i run
180:48 - this again it is 93. now if i change
180:52 - these values we will adjust the range in
180:54 - which some random numbers will generate
180:56 - so if i set min to 100 and max to 1000
181:00 - that should change the range of numbers
181:02 - and this time i have 334 but i'll change
181:06 - this back to 1 and 100
181:08 - okay so we know that we're generating a
181:10 - random number so let's move on
181:12 - let's create a do while loop so it's
181:14 - going to take at least one guess in
181:16 - order for somebody to guess the correct
181:18 - answer so do curly braces we'll add
181:22 - while and check a condition at the end
181:25 - and the condition is guess
181:27 - does not equal
181:30 - answer so let's create a prompt and ask
181:32 - the user to enter a guess
181:35 - enter a guess
181:37 - and we will use scanf to accept some
181:40 - user input so this is an integer
181:43 - and we are storing this within
181:45 - guess so address of operator guess
181:49 - now that we have our user's guess let's
181:51 - compare it to our answer
181:52 - so we'll use an if statement and check
181:54 - to see if guess
181:56 - is greater than answer so that means a
182:00 - user guessed a number that was a little
182:02 - too high
182:03 - so let's print a message to let the user
182:05 - know
182:07 - to
182:08 - hi
182:10 - and then we can use an else if statement
182:12 - else if
182:14 - guess
182:15 - is less than answer well then their
182:17 - guess was too low
182:21 - print too low
182:24 - so if our guess is not greater than the
182:26 - answer or less than the answer that
182:29 - means they must have got it right
182:31 - so within an else block let's print
182:35 - correct
182:37 - so then after our if else statements
182:40 - let's increase guesses by one guesses
182:43 - plus plus
182:44 - the very best possible score a user can
182:46 - get is one if they guess it on the first
182:48 - try so before we finish a while loop we
182:51 - will increment guesses by one
182:54 - so then once we escape our while loop
182:56 - let's print the user's final score
182:59 - so we will print
183:00 - the answer
183:03 - this is an integer
183:05 - and we are displaying
183:07 - answer
183:11 - and we will display the guesses it took
183:14 - so
183:15 - guesses
183:16 - and display the value found within
183:18 - guesses
183:19 - and this part isn't necessary but i like
183:21 - to add some text decorations
183:24 - so maybe i'll add a bunch of asterisks
183:26 - to make it look nice
183:29 - let's run it
183:32 - enter a guess i'll guess something right
183:34 - in the middle between so maybe 50.
183:37 - so that guess was too low so maybe 75
183:40 - okay that was too high so our numbers
183:42 - between 50 and 75 how about 62
183:48 - that's too low so it's between 62 and 75
183:51 - how about 69
183:53 - that's still too low so between 69 and
183:56 - 75
183:57 - maybe 72
183:59 - that's still too low so it's between 72
184:01 - and 75
184:03 - 73
184:04 - all right that was the right answer i'm
184:06 - just gonna fix one thing real quick
184:08 - uh let's add a new line here okay let's
184:11 - try this again okay until i guess i'll
184:13 - try 50 again that's too high maybe 25
184:17 - that's still too high what about 12
184:19 - 2 low
184:20 - maybe 18
184:22 - 2 low 21
184:24 - that's still too low 23 too low 24
184:28 - and 24 was the correct answer all right
184:31 - everybody so i thought that would be a
184:33 - fun guessing game we could create for
184:34 - practice if you would like a copy of all
184:36 - this i'll post this to the comment
184:38 - section down below and well yeah that is
184:41 - a simple number guessing game in c
184:47 - all right people so now that we know how
184:49 - to create an array of strings i thought
184:51 - this would be a good opportunity for us
184:53 - to create a quiz game so before we begin
184:55 - make sure to include these two header
184:57 - files at the top of your program so
184:59 - let's begin with a 2d array of
185:02 - characters and these will store our
185:04 - questions
185:06 - and i'm going to set a maximum size for
185:08 - each question to 100 bytes
185:11 - and we can go ahead and initialize this
185:13 - array with some questions so remember
185:15 - with strings each string is its own
185:17 - array
185:18 - so let's ask maybe three questions but
185:20 - feel free to pick any amount that you
185:22 - like
185:23 - and come up with any questions you would
185:25 - like as well or you can copy me i don't
185:27 - care
185:31 - what year did the c language debut then
185:34 - separate each string with a comma
185:37 - then just to make this more readable i'm
185:38 - going to go down to the next line
185:40 - so this is question two now
185:44 - who is credited with creating c
185:47 - and one more question
185:52 - what is the predecessor of c so now we
185:55 - have some questions we'll need some
185:56 - options this could be a separate 2d
185:59 - character array
186:02 - char
186:03 - options
186:04 - and i'll copy the dimensions from
186:06 - questions
186:09 - and we'll create four sets of options
186:11 - for each question
186:18 - this is the first set of options for the
186:20 - first question and then let's add a
186:23 - second set of options for the second
186:24 - question
186:36 - and a third set
186:45 - now we'll create an answer key this will
186:47 - be a one-dimensional array
186:49 - so char
186:51 - answers and the size will be three
186:54 - and i will set this equal to
186:56 - my answer key so the correct answers for
186:59 - my quiz are b
187:02 - a
187:03 - b
187:04 - so these will be individual characters
187:06 - all separated with a comma b
187:09 - a
187:10 - b
187:11 - so let's calculate the number of
187:13 - questions that we have
187:14 - so i will declare int
187:16 - number
187:18 - of
187:19 - questions
187:20 - and set this equal to
187:22 - sizeof operator
187:24 - pass in our two-dimensional array of
187:26 - questions
187:28 - and divide this by one of the elements
187:30 - because they all have the same size
187:32 - questions at index zero
187:35 - and let's declare
187:36 - char guess to store our guess
187:40 - and int score to keep track of the
187:42 - player's score
187:43 - so now let's begin this i will print
187:46 - the title quiz game
187:50 - then add a new line
187:52 - okay now we need to loop through all of
187:54 - the questions so let's use a for loop
187:59 - so we will have an index of i set to
188:02 - zero
188:03 - and i would like to loop through this as
188:05 - long as i is less than the number of
188:08 - questions that we have
188:10 - then increment i by one
188:12 - and to test this let's print our
188:14 - questions
188:16 - so printf
188:18 - we're displaying a string so use the s
188:21 - format specifier
188:24 - questions add index of i
188:27 - and then i'll add a new line character
188:29 - after each printf statement okay let's
188:32 - at least test this so we should cycle
188:34 - through our questions
188:36 - okay here are my questions what year did
188:38 - the c language debut who is credited
188:40 - with creating c
188:42 - what is the predecessor of c
188:44 - and this part isn't necessary but i'm
188:46 - going to add some text decorations
188:49 - i'll just display a bunch of asterisks
188:51 - i'll do that before and after the
188:53 - question
188:55 - and let's try that again oh then add a
188:57 - new line character
189:00 - that's a little bit better
189:01 - after our question let's display the
189:04 - possible options
189:06 - so we will need a nested for loop
189:09 - so four
189:11 - now this part's gonna be a little bit
189:12 - tricky
189:13 - we need to begin our for loop at every
189:16 - fourth string
189:19 - within our for loop let's set int j
189:22 - equal to
189:24 - i times four
189:26 - so during the first iteration i will be
189:29 - zero so zero times four is zero but
189:32 - during the next iteration of the outer
189:34 - for loop i is going to equal one so one
189:38 - times four is four
189:40 - so that way we will begin the inner for
189:43 - loop with every fourth string within our
189:46 - 2d array of options
189:49 - and the condition is going to be
189:51 - j is less than
189:54 - i
189:55 - times 4
189:56 - and then we would like to display
189:58 - four strings
189:59 - this for loop will cycle four times
190:02 - beginning at every fourth string
190:05 - and then we need to increment j by one
190:08 - now let's print every option
190:12 - so this is a string i'll add a new line
190:15 - and we are printing
190:17 - options at index of j
190:20 - and let's test this just to be sure that
190:21 - it works
190:22 - okay so we have our question followed by
190:25 - four possible options
190:28 - now let's accept some user input after
190:30 - the nested for loop currently our
190:32 - program isn't going to wait around for
190:34 - any user input that's why i displayed
190:36 - all the questions and options okay we
190:38 - will create a prompt to have a user type
190:40 - in a guess
190:42 - guess and we will use scanf to accept
190:45 - some user input
190:47 - we are accepting a single character
190:50 - and use the address of operator guess
190:53 - now let me show you what happens when we
190:54 - run this real quick
190:56 - so i'm just going to type in anything
190:57 - let's say a
190:59 - okay so we skipped question two
191:01 - that's because after using scanf when we
191:04 - accept a character we have that new line
191:06 - character within the input buffer so we
191:08 - need to clear that
191:10 - so one way in which we can clear that is
191:12 - to use scanf again
191:15 - use the c format specifier and that's it
191:18 - so this will clear the new line
191:21 - character from input
191:23 - buffer
191:24 - so this should no longer just skip
191:26 - question two
191:27 - okay
191:28 - let's say a
191:30 - b
191:30 - c
191:32 - okay so we know we can accept some user
191:34 - input now
191:35 - now here's one thing what if somebody
191:37 - types in a lowercase character i think
191:39 - that should still count even though
191:40 - we're looking for an uppercase character
191:43 - so let's take our guess and use the two
191:46 - upper function to make it uppercase
191:48 - guess equals to upper
191:51 - then pass in guess
191:53 - so basically we're passing in our guess
191:54 - making it uppercase and reassigning it
191:57 - to our guess
191:58 - and let's write an if else statement to
192:00 - check our guess if it's equal to our
192:03 - answer so if else
192:06 - our condition within our if statement if
192:08 - guess
192:09 - is equal to answer at index of i
192:13 - remember that we're still within the for
192:15 - loop the outer for loop so we have that
192:17 - index oh that's answers plural
192:20 - if a user's guess is equal to the answer
192:23 - then let's print correct
192:25 - and then give them one point so printf
192:29 - correct
192:32 - and then increment our score score plus
192:35 - plus
192:37 - else we will print wrong and you can
192:40 - give the correct answer if you would
192:41 - like just do that within here now once
192:43 - we cycle through all of the questions we
192:45 - can display a user score so be sure to
192:48 - do that outside of the for loop the
192:50 - outer for loop that is so let's use
192:52 - printf
192:53 - and display
192:55 - final score
192:57 - so i'm going to display two values
193:00 - so the first will be the player score
193:03 - divided by the number of questions
193:06 - so we have two integers to work with and
193:08 - we are displaying score and number of
193:11 - questions and then if you want you can
193:14 - add some text decoration to make it look
193:16 - cool
193:17 - so i'm going to run through this quiz
193:19 - once and intentionally get one question
193:21 - wrong
193:22 - so what year did the c language debut
193:24 - that would be 1972 that's b who is
193:28 - credited with creating c
193:30 - uh let's say doc brown
193:32 - so d
193:34 - and what is the predecessor of c that
193:36 - would be b
193:39 - okay and my final score is two out of
193:41 - three
193:42 - so let's try that again and this time i
193:44 - will try and get one hundred percent so
193:46 - the correct answer is b
193:49 - a dennis ritchie
193:51 - and b
193:53 - and my final score is three out of three
193:56 - so yeah i thought that would be a simple
193:58 - quiz game in c if you would like a copy
194:00 - of this code i'll post this to the
194:02 - comment section down below and well yeah
194:05 - that's a simple quiz game in c
194:11 - hey everybody let's talk about bitwise
194:13 - operators these are special operators
194:16 - used in a bit level programming
194:18 - knowing binary is important for this
194:20 - topic so if you don't know how binary
194:23 - works i would recommend skipping to the
194:25 - next topic but if you're comfortable
194:27 - with binary well this video is for you
194:29 - so let's begin i'm going to discuss five
194:31 - different bitwise operators and or
194:34 - exclusive or left shift and right shift
194:37 - let's create three variables x y and z
194:40 - x will equal six
194:43 - y will equal twelve
194:46 - and z will store our result and we will
194:48 - set that to be zero
194:50 - so i'm going to give you the binary
194:52 - representation of each of these numbers
194:55 - so six is
194:58 - this number so we have eight bits that's
195:00 - a byte and this is the binary
195:03 - representation of the number six
195:06 - 12 would be this binary number
195:09 - and zero zero is easy
195:12 - that would be all zeros so let's use the
195:15 - and bitwise operator so what we're going
195:17 - to do is set z equal to x
195:21 - and y
195:23 - so imagine this imagine that we're
195:25 - aligning all of these bits in columns
195:28 - using the and bitwise operator we're
195:31 - going to look at our operands x and y if
195:33 - both of these are a one we will assign
195:36 - one to our result
195:37 - and let's begin with the first column on
195:39 - the right both of these are zeros so our
195:41 - result will stay at zero and with the
195:44 - next column we have one and zero and
195:46 - using the and bitwise operator both of
195:49 - these need to be 1 in order to assign
195:51 - one to our result so we will skip this
195:53 - column now with our third column these
195:56 - are both 1 so we will assign 1 to our
195:59 - result the next column is zero and one
196:02 - we skip it and the rest are just zero so
196:05 - this binary number is the binary
196:07 - representation of the number four
196:10 - so let's test that z equals x and y and
196:14 - let's print z
196:17 - and equals we're displaying an integer
196:20 - i'll add a new line
196:22 - and we are displaying z
196:25 - and let's see if this is for
196:27 - yep our result z is equal to four now
196:30 - let's move on to or so let's set this
196:33 - back to zero
196:35 - and we will set z
196:36 - equal to x
196:38 - or y or is represented by a single
196:42 - vertical bar
196:44 - and we will print
196:46 - or let's try and guess what z is going
196:48 - to be before we actually display it
196:51 - with the or bitwise operator only one of
196:53 - these bits needs to be one in order for
196:56 - us to assign one to the result
196:58 - so since these are both zero this will
197:00 - stay at zero
197:02 - this bit is one this one's zero so this
197:04 - would be one and for the next column of
197:07 - bits these are both one so that counts
197:08 - as well
197:09 - and we have a one in here so that is one
197:12 - and the rest are just zero so this is
197:14 - the binary representation of the number
197:17 - fourteen and let's see if z is equal to
197:20 - fourteen
197:22 - yep we got that right
197:23 - so let's set this back to zero
197:26 - now with exclusive ore that is
197:28 - represented by a carrot with exclusive
197:31 - ore only one of these bits can be won if
197:34 - neither or both of these bits are one we
197:37 - don't assign anything so both of these
197:39 - bits are zero they will stay a zero
197:42 - we have one of these bits as one and not
197:44 - the other so that counts as one now with
197:46 - this next column both of these are one
197:48 - and using exclusive ore only one of
197:51 - these can be one so since these are both
197:54 - ones we do not assign anything so we
197:56 - keep that as zero and with the next
197:58 - column only one of these is one so we
198:00 - will set this to be one within the
198:02 - result and this is the binary
198:05 - representation of ten and let's test
198:08 - that
198:09 - z
198:10 - equals x
198:12 - exclusive or y
198:15 - and we will print exclusive or equals z
198:19 - and let's see if that's ten
198:22 - yep z is equal to ten now here's left
198:26 - shift we will shift these bits so many
198:29 - spaces to the left using left shift so
198:31 - we will set z
198:33 - equal to x and then left shift which is
198:37 - represented by two left angle brackets a
198:40 - number of spaces let's begin with one
198:43 - so we have x equal to six
198:45 - what we're doing is shifting these bits
198:48 - one spot to the left
198:50 - and then adding zero at the end
198:52 - and this is the binary representation of
198:55 - the number 12. actually it's the same as
198:57 - y currently these binary numbers are the
198:59 - same
199:00 - and let's print that
199:04 - so
199:05 - shift left
199:07 - and z should equal 12
199:10 - yep
199:11 - and if i shift left twice
199:14 - well then we are just moving these bits
199:16 - one more space and now this is 24.
199:22 - there you go
199:23 - so you probably noticed that there's a
199:25 - pattern every time we shift a binary
199:27 - number to the left it effectively
199:29 - doubles
199:30 - now let's right shift
199:32 - so let's copy this
199:35 - paste it
199:37 - and we will use two right angle brackets
199:40 - and this is shift right
199:43 - and let's set this to 6.
199:46 - if we're right shifting we shift these
199:48 - bits one spot to the right and this is
199:51 - the binary representation of the number
199:53 - three and if i print this
199:57 - after shifting right once our result z
200:00 - is three
200:01 - every time we shift right we're
200:03 - effectively cutting our number in half
200:05 - now if i shift right again
200:07 - we will shift these bits one more spot
200:09 - to the right and we are going to
200:11 - truncate this one at the end and this
200:14 - will give us one that is the binary
200:16 - representation of the number one
200:18 - so technically half of three is 1.5 but
200:21 - we can't store that 0.5 portion so it
200:24 - just gets truncated all right everybody
200:27 - those are just a few bitwise operators
200:30 - they are special operators used in bit
200:33 - level programming there's five that we
200:35 - discussed today but there is another
200:37 - known as the complement operator but
200:39 - that's a little bit more complex and i
200:42 - might save that for another video so
200:44 - yeah those are bitwise operators if you
200:47 - would like a copy of this code i'll post
200:49 - this to the comments section down below
200:51 - and well yeah those are some bitwise
200:53 - operators in c
200:58 - all right everybody so let's talk about
201:00 - memory memory is an array of bytes
201:03 - within ram and a memory block is a
201:06 - single unit in bytes within memory
201:10 - they're used to hold some value and a
201:13 - memory address is the address of where a
201:16 - memory block is located within ram i
201:19 - like to think of memory as a street with
201:22 - a bunch of different houses and each
201:24 - house is a memory block which can hold
201:27 - some value kind of like they're storing
201:29 - a person and a memory address is the
201:32 - house address on that street where that
201:35 - memory block is located so this would be
201:37 - a street address like one two three fake
201:40 - street so when we declare variable let's
201:42 - say we have char a when we declare a
201:45 - variable we are setting some amount of
201:47 - memory blocks aside to store some value
201:51 - so the memory block that this variable
201:53 - is using up has some memory address and
201:56 - if i assign this variable a value let's
201:59 - say maybe x well then if i was to go
202:01 - into my computer's memory and look for
202:04 - this address i would find this character
202:07 - so imagine we're walking down the street
202:09 - and we are looking for somebody's
202:11 - address so we're going house to house
202:12 - and we find a matching address if i were
202:15 - to open their front door i should
202:17 - probably knock first at least then i
202:19 - will find the character x so that's kind
202:22 - of an analogy i like to use when
202:24 - thinking about memory so let's declare a
202:26 - couple other characters we have char b
202:29 - i'll give this a value of y
202:32 - and char c
202:34 - and i'll give this a character of z okay
202:38 - so let's find the size of each of these
202:40 - characters so i'm going to use a printf
202:42 - statement i'm going to display an
202:44 - integer
202:46 - and the size of each of these characters
202:48 - is within bytes
202:49 - so i'm going to use the size of operator
202:53 - and pass in one of my characters so i'm
202:55 - going to pass in a
202:57 - and i'll do the same thing with b and c
203:02 - so the size of each of these characters
203:06 - is one bite and i think i'm just going
203:08 - to add a new line here
203:11 - much better okay now we can actually
203:14 - access the address of each of these
203:16 - variables so each of these variables is
203:19 - using one block of memory a single block
203:23 - of memory is a byte
203:25 - so within a printf statement i would
203:28 - like to display an address so the format
203:30 - specifier is p
203:32 - and i will use the address of operator
203:36 - then the name of one of my variables
203:38 - so i'll display the address of variables
203:40 - a b
203:42 - and c
203:44 - and then display each on a new line
203:47 - so here are the memory addresses for
203:50 - these three variables these addresses
203:52 - are in hexadecimal these are the street
203:55 - addresses of each of our memory blocks
203:57 - on our fictional street
203:59 - hey uh so this is bro from the future
204:02 - just a quick crash course on hexadecimal
204:04 - values with standard decimal values they
204:07 - use the numbers 0 through 9 but with
204:10 - hexadecimal you use the numbers 0
204:13 - through 9 as well as a through f so that
204:17 - gives you a total of 16 different values
204:20 - for each digit so that's why there's a
204:23 - mix of numbers and letters
204:25 - so each of these variables uses one
204:28 - memory block they use one byte of memory
204:30 - so beginning with variable a
204:32 - this has this street address but if we
204:35 - go down to the next memory block you can
204:37 - see that there is just one change f goes
204:40 - down to e and then with variable c
204:43 - this address goes down by one so f e d
204:47 - these are contiguous memory blocks
204:49 - they're all next to each other but now
204:51 - if we switch to a different data type
204:53 - like a short we haven't used these in a
204:55 - long time
204:57 - well shorts use two bytes of memory
205:00 - as we can see here so these hexadecimal
205:02 - addresses are now going down by two e d
205:07 - c
205:08 - b
205:09 - a so each of these variables are using
205:12 - two memory blocks we need an even larger
205:15 - house even more memory blocks and they
205:17 - use up two memory addresses
205:20 - and then if i change these two integers
205:22 - well they're going to use up even more
205:24 - memory
205:25 - so integers use four bytes memory
205:28 - and these are the street addresses of
205:31 - these three variables and doubles use
205:34 - double the size of an integer
205:38 - doubles use eight bytes of memory and
205:40 - these street addresses are decrementing
205:43 - by eight if this was a fictional street
205:46 - with houses well doubles use up eight
205:48 - bytes memory so think of these like
205:51 - mansions they're using up a lot of space
205:53 - now what happens with an array i'm going
205:55 - to declare
205:56 - char a
205:59 - and declare an array this will be an
206:01 - array of characters to begin with so
206:03 - let's say character array b and i'll
206:05 - give this a size of one
206:08 - so i'm going to print the size of a and
206:10 - the size of b
206:12 - as well as their memory addresses
206:14 - our single character a uses one byte and
206:17 - this is the street address of this
206:19 - variable and our array b
206:22 - also uses up one byte
206:24 - and this is the street address of where
206:26 - this array begins if i set the size of
206:29 - this array to 2 well then my array is
206:32 - going to use 2 bytes
206:34 - and now it has a different address to
206:36 - accommodate the increased size of the
206:38 - array and if i change this to 3 it now
206:41 - uses 3 bytes of memory and it has a new
206:44 - address and if i change the data type of
206:46 - the array we'll have to take that into
206:48 - consideration so a short uses two bytes
206:52 - memory and we need three elements so
206:54 - that's a total of six two times three is
206:57 - six and if i change this to int and int
207:00 - uses four bytes so four times three is
207:03 - twelve and a double
207:06 - is eight so eight times three is twenty
207:08 - four so yeah that's kind of the basics
207:10 - of memory so memory is an array of bites
207:14 - within ram think of it like a street and
207:16 - a street contains houses each house is a
207:19 - memory block that can hold some value
207:22 - think of each value as a person living
207:24 - in that house and in order to find a
207:26 - person we have to know their address
207:29 - like a street address c refers to these
207:31 - variables by their street address but
207:33 - that's difficult for us to understand so
207:35 - we just refer to this memory address as
207:38 - a variable name because that's easier
207:40 - for humans to work with so yeah that's
207:42 - some basics of memory and c and in the
207:44 - next video we're going to discuss
207:46 - pointers so if you would like a copy of
207:48 - my notes here i'll post them to the
207:50 - comment section down below and well yeah
207:52 - that's the basics of memory in c
207:56 - hey yeah it's you bro hope you're doing
207:58 - well and in this video i'm going to
208:00 - explain the basics of pointers in c so
208:03 - sit back relax and enjoy the show
208:08 - if you wouldn't mind please like comment
208:10 - and subscribe one like equals one prayer
208:13 - for the youtube algorithm
208:15 - oh yeah we finally made it to pointers
208:18 - we're only about 40 topics in a pointer
208:20 - is a variable like reference that holds
208:24 - a memory address as a value to another
208:27 - variable array etc some tasks are
208:30 - performed more easily with pointers and
208:32 - here's a comprehensive list of a few of
208:34 - the benefits in this video we're going
208:36 - to more or less focus on building a
208:38 - solid foundation with pointers and
208:40 - understanding how they work so let's say
208:42 - we have a variable int edge and i'll
208:44 - give this some value a variable has a
208:47 - value and an address and let's display
208:50 - the value and the address of this
208:52 - variable using two print statements
208:55 - so first i'm going to display the
208:58 - address of this variable
209:00 - address of age then i will use the p
209:04 - format specifier to display an address
209:06 - in hexadecimal and we are displaying the
209:09 - address of age and ampersand is the
209:12 - address of operator address of age and i
209:15 - would also like to display the value of
209:17 - age
209:18 - value of age
209:21 - and this is an integer
209:23 - and we will display age
209:26 - so variables have a value and an address
209:30 - this is the address of this variable and
209:32 - the value at this address
209:35 - as you know there's tons of different
209:36 - things we can do with a value of a
209:38 - variable but there are things that we
209:40 - can do with an address as well so we can
209:42 - actually store this address within a
209:44 - separate variable a variable like
209:47 - reference and that is called a pointer
209:50 - so to create a pointer we will make sure
209:52 - these are of the same data type as the
209:53 - variable we're pointing to age is an
209:56 - integer so we will declare this pointer
209:58 - of the integer data type and the next
210:00 - step to declare a pointer is that we
210:02 - will use an asterisk this is the in
210:04 - direction operator and a common naming
210:07 - convention for pointers is that you type
210:09 - lowercase p the name of the variable
210:12 - you're going to point to but make the
210:14 - first letter uppercase and i'm going to
210:16 - set this equal to
210:18 - the address of age
210:21 - so the address of age and the value at
210:24 - this variable are the same and let's
210:27 - test that theory
210:28 - so this time i'm going to display
210:31 - the address of age and the value of ph
210:37 - and this will display an address so
210:38 - change the format specifier from d to p
210:42 - and i'm going to turn this line into a
210:44 - comment for now okay so these addresses
210:47 - should both be the same the address of
210:50 - age as well as the value stored within
210:53 - ph
210:54 - so our pointer has its own address but
210:56 - the value stored within it is an address
210:59 - and we can access the value at this
211:02 - address by using the indirection
211:03 - operator so this time i'm going to print
211:06 - the value of age
211:08 - and the value
211:09 - at
211:10 - stored
211:12 - address
211:14 - and to dereference a pointer you will
211:16 - type the pointer name ph appreciated
211:20 - with the indirection operator
211:22 - as my own personal nickname for the
211:24 - indirection operator i call it the value
211:27 - at address operator that's not any
211:29 - official name that's just how i think
211:31 - about it so we're extracting a value at
211:34 - the given address within this pointer so
211:37 - if i display the value of age and the
211:40 - value at the stored address using the
211:43 - indirection operator well both of these
211:45 - are going to be the same
211:47 - so we have 21 stored within our edge
211:50 - and after dereferencing this pointer
211:53 - we're extracting the value at this given
211:55 - address
211:56 - so you use the indirection operator when
211:59 - you declare a pointer as well as when
212:01 - you want to access a value at the stored
212:04 - address
212:05 - so with the data types of the pointer
212:07 - you'll want to make sure they're
212:08 - consistent c is a strongly typed
212:10 - language so if i change the data type of
212:13 - my pointer to char
212:15 - using my compiler i'll receive a warning
212:18 - initialization of char from incompatible
212:21 - pointer type int now the actual data
212:24 - type of a pointer is the same they use
212:26 - eight bytes to store an address so i'm
212:28 - going to print the size of our variable
212:31 - as well as our pointer
212:33 - so i'll change this data type back to
212:35 - what it was originally and this time i'm
212:38 - going to print the size of our age
212:39 - variable as well as the size of our
212:41 - pointer
212:42 - size of age
212:45 - and we're displaying an integer and this
212:47 - will be in
212:48 - bytes size of age
212:54 - size of pointer age
212:58 - and then i'm going to display a new line
213:00 - okay so the size of our age variable is
213:03 - 4 bytes it's an integer integers use 4
213:05 - bytes so even though we declared our
213:07 - pointer as an integer
213:09 - the actual size of our pointer is going
213:12 - to be 8 bytes that's enough to store a
213:14 - hexadecimal address
213:16 - so just as good practice since c is a
213:19 - strongly typed language you'll want to
213:21 - be sure that the data type of your
213:22 - pointer is consistent with the variable
213:24 - that it's pointing to
213:26 - now here's one thing that we can do with
213:28 - pointers we can pass a pointer as an
213:31 - argument to a function
213:32 - so outside of my main function i'm going
213:34 - to declare a function
213:36 - void
213:37 - let's say print
213:38 - age
213:39 - first we'll do this with passing and
213:41 - integer so int age
213:44 - and i will display the value of age
213:48 - you
213:49 - are
213:51 - age years
213:53 - old
213:54 - and i will display my age variable
213:57 - then at the end we will pass in our
213:59 - variable
214:02 - print edge and i will pass in age
214:05 - for now i'm just going to turn all of
214:06 - these into comments
214:09 - okay so you know this works
214:11 - you are 21 years old you could also pass
214:14 - in a pointer too
214:16 - so i'm going to this time pass in
214:18 - pointer age
214:20 - and we need to change the parameter from
214:23 - an integer to a pointer
214:26 - so precede the parameter name with the
214:28 - indirection operator
214:30 - and i'll rename this parameter as ph
214:33 - in order to access the value of the
214:35 - address stored within my pointer i need
214:38 - to de-reference
214:41 - so i will use the indirection operator
214:43 - then type my pointer name ph
214:47 - and this will do the same thing as
214:48 - before
214:49 - so yeah those are pointers oh and before
214:52 - i forget you can declare and initialize
214:54 - a pointer in two steps
214:56 - but it would be good practice if you're
214:58 - declaring a pointer to assign a value of
215:01 - null
215:02 - since we already declared this pointer
215:03 - we do not need to use this indirection
215:05 - operator again when assigning a value so
215:08 - p
215:08 - h equals the address of age
215:12 - so it's considered good practice to
215:15 - assign null if you're declaring a
215:17 - pointer and not yet assigning a value so
215:20 - yeah that's basically a pointer it's a
215:23 - variable like reference that has a
215:26 - memory address as value to another
215:29 - variable array etc some tasks are
215:32 - performed more easily with pointers and
215:35 - to declare a pointer you use the
215:37 - indirection operator and if you need to
215:39 - access a value stored within a pointer
215:42 - you type the pointer name preceded with
215:45 - the indirection operator so yeah that is
215:48 - a quick intro to pointers if you found
215:50 - this video helpful please give this
215:52 - video a thumbs up leave a random comment
215:54 - down below and subscribe if you'd like
215:55 - to become a fellow bro
216:01 - all right let's do this here's how we
216:03 - can write to a file in c let's create a
216:06 - file pointer the data type is file and
216:09 - i'll name this pf it's a pointer to a
216:13 - file and i will set this equal to then
216:15 - invoke the f open function we will pass
216:19 - in a name we would like to give our file
216:21 - let's name this test.txt but if you
216:24 - would like this to be a different file
216:26 - extension such as html well you can
216:28 - change it to that then uh we'll keep
216:30 - this as a plain text file just to keep
216:32 - it simple and to write to a file there
216:36 - is a second argument a mode so this
216:38 - could be w for right a for append r for
216:42 - read but we are looking for w for now so
216:45 - it is good practice at the end of your
216:47 - program to close any files that are open
216:50 - so we will use the f close function and
216:53 - pass in our pointer p f make sure to not
216:57 - dereference it now to write a line of
216:59 - text to our file we can use f print f
217:04 - pass in our pointer p f do not
217:06 - dereference it and then some string of
217:08 - text let's say spongebob squarepants
217:13 - so this file will be created in the same
217:15 - folder as my c program so after running
217:18 - this
217:20 - we have a new text file within the same
217:22 - folder and it says spongebob squarepants
217:25 - what if i run this again and write
217:27 - something different like patrick starr
217:31 - so if the mode is w
217:33 - then we will actually overwrite any
217:35 - existing data already within this file
217:38 - if we need to append a file we can use
217:41 - the a mode for append so this time let's
217:44 - append some text to the end of our
217:46 - document
217:48 - spongebob squarepants
217:51 - and you have to keep track of any new
217:53 - lines that you add too so if i run this
217:56 - again and this time i am appending some
217:58 - text
218:00 - well patrick starr is still there and we
218:02 - appended spongebob squarepants to the
218:05 - end of our file
218:06 - now if you would like to delete a file
218:08 - here's how i'm going to turn all of this
218:11 - into one giant comment
218:14 - let's use a little bit of file detection
218:16 - let's check to see if our file does
218:18 - exist
218:19 - within our if statement let's invoke the
218:21 - remove method and we will pass in the
218:24 - name or location to our file
218:27 - test.txt if we remove this file
218:30 - successfully it will return zero so if
218:33 - after invoking the remove function if
218:36 - this returns zero that's its exit code
218:39 - that means that file was deleted
218:41 - successfully let's print a message to
218:43 - let the user know
218:45 - that
218:45 - file
218:47 - was deleted
218:49 - successfully
218:51 - else we will print a different message
218:54 - printf
218:56 - that file was not
218:59 - deleted
219:00 - okay let's try this so here's my file
219:02 - within the same folder if i run this
219:06 - that file was deleted successfully
219:08 - and that file is no longer within the
219:10 - same folder you can see here that this
219:12 - says deleted
219:13 - and if i run this again we will not be
219:15 - able to locate that file because it's
219:17 - not there
219:18 - now you can write a file to a different
219:20 - location let's say i would like to write
219:22 - a file to my desktop i can set a
219:25 - relative file path or an absolute file
219:28 - path i'll use an absolute file path
219:30 - i'm going to get the file location of my
219:32 - desktop so i'm just going to click on
219:35 - one of these folders
219:36 - go to properties
219:38 - and copy this location
219:41 - so with my file name i'm going to
219:44 - precede this with an absolute file path
219:46 - then any backslashes might need to be
219:49 - double backslashes
219:51 - so this time if i write a file
219:53 - then this file will appear at this
219:56 - location on my desktop
219:58 - and here's that file test.txt and it
220:01 - says spongebob squarepants well alright
220:04 - everybody that is how to write append
220:07 - and delete files in c if you found this
220:09 - video helpful be sure to help me out by
220:12 - smashing that like button leave a random
220:14 - comment down below and subscribe if
220:16 - you'd like to become a fellow bro
220:20 - alright people so in this video i'm
220:22 - going to show you how we can read the
220:24 - contents of a file someplace on your
220:26 - computer you can either place this
220:28 - within the same folder as your c program
220:30 - or someplace else i think it would be
220:32 - cool if we read a file from our desktops
220:34 - so i'm going to create a new file and
220:36 - this is going to be a plain text file
220:39 - and i'll write a poem i'll name this
220:40 - poem.txt
220:42 - here's my beautiful poem
220:45 - are red
220:47 - violets are blue
220:51 - booty booty booty booty
220:55 - rockin
220:56 - everywhere
220:58 - okay i'm going to save
221:00 - and then i'll need the file location of
221:02 - where this is located i'm going to right
221:04 - click go to properties and copy this
221:07 - file path and save it for later now to
221:10 - read a file on your computer we'll need
221:12 - to create a pointer the data type is
221:14 - file
221:15 - and i'll name this
221:17 - p f and i will set the sql to then
221:20 - invoke the f open function
221:23 - pass in your file mine is poem.txt
221:27 - so if this file is not within the same
221:30 - folder as your c program you'll need a
221:32 - relative or absolute file path since
221:35 - this file is on my desktop i could use
221:37 - an absolute file path
221:39 - so preceding my file name i will paste
221:42 - that location and then each backslash
221:44 - may need to be a double backslash
221:46 - because that is an escape sequence for a
221:49 - backslash character okay the second
221:51 - argument is the mode this time we are
221:53 - going to read a file so pass in r for
221:57 - the second argument then it's good
221:59 - practice at the end of your program to
222:01 - close any open files
222:03 - we will invoke the f close function pass
222:06 - in our pointer do not dereference it and
222:09 - we will need one more thing a buffer a
222:12 - buffer is going to act as a container an
222:14 - array of characters to hold one line of
222:17 - our text document one line at a time so
222:20 - let's declare an array of characters
222:22 - named buffer and i'll set the size to
222:25 - 255. our buffer is going to hold one
222:28 - line of our file one line at a time and
222:31 - to read a single line from our file we
222:34 - will use the f gets function and there
222:37 - are three arguments our buffer this is
222:40 - what we're inserting a line of text into
222:42 - a maximum input size i'll set this to be
222:45 - 255 to match our buffer and then a
222:48 - pointer to the file that we're opening
222:50 - and again make sure to not dereference
222:52 - it so this will read a single line of
222:55 - text and then let's print our buffer so
222:57 - we're printing a string and we are
223:00 - displaying whatever is currently within
223:02 - our buffer
223:03 - so after running this this will read a
223:05 - single line of text whatever's at the
223:07 - top
223:08 - roses are red
223:10 - now if i need to read all of the
223:11 - contents of my file i can place this
223:14 - section of code within a while loop
223:20 - so with our condition i'm going to move
223:22 - the f gets function within the condition
223:25 - if we reach the end of a file f gets
223:27 - will return null so let's continue this
223:30 - while loop while f gets does not return
223:34 - no if we do not return null then we will
223:36 - print whatever's within our buffer now
223:39 - if i run this this will display all of
223:41 - the lines from my file roses are red
223:44 - violets are blue booty booty booty booty
223:47 - rocking everywhere and if you would like
223:49 - you can add a little bit of file
223:50 - detection so before we reach our while
223:52 - loop let's check to see if that file
223:54 - even exists before we attempt to open
223:57 - and read it so let's check to see if our
223:59 - pointer equals no if it is null that
224:02 - means we could not locate this file so
224:05 - i'm going to print
224:07 - unable to open
224:10 - file
224:11 - and we'll create an else statement
224:14 - else let's read and print the contents
224:17 - of this file
224:20 - okay so let's say i get the file
224:22 - extension wrong let's say i'm looking
224:24 - for an html file named poem and i try
224:27 - and read this
224:28 - unable to open file
224:30 - but if we are able to locate this file
224:33 - we will open it and read the contents
224:35 - and then close this file so yeah
224:37 - everybody that is how to read the
224:39 - contents of a file line by line if you
224:42 - found this video helpful please be sure
224:44 - to help me out by smashing that like
224:45 - button leave a random comment down below
224:47 - and subscribe if you'd like to become a
224:49 - fellow bro
224:51 - oh yeah what's going on everybody it's
224:53 - you bro hope you're doing well and in
224:55 - this video we're going to create a game
224:56 - of tic-tac-toe so sit back relax and
225:00 - enjoy the show
225:03 - if you find this video helpful please
225:04 - remember to like comment and subscribe
225:07 - your support will help keep this channel
225:09 - running all right let's begin so the
225:12 - first thing that you're going to need is
225:13 - to include these files at the top of
225:15 - your c program and we will create seven
225:18 - different function prototypes so the
225:20 - return type of this first function is
225:22 - void and the name of this function will
225:25 - be reset board our board is going to be
225:28 - a 2d character array and our second
225:30 - function is void print board
225:33 - which will print our 2d character array
225:36 - then with this next function this has a
225:38 - return type event and this will check
225:41 - free spaces
225:44 - if after invoking this function this
225:47 - function returns zero that means the
225:49 - game is over there's no more places to
225:51 - move and we will need void player move
225:54 - when it's the player's turn to move
225:57 - void computer move when it's the
226:00 - computer's turn to move
226:02 - char
226:03 - check winner
226:04 - so we have a few different win
226:06 - conditions to check and void print
226:09 - winner
226:11 - and there is one parameter a single
226:13 - character soap char so these are
226:16 - function prototypes we tend to declare
226:18 - these before the main function because
226:20 - they help with readability after the
226:22 - main function we will give each of these
226:23 - a body
226:25 - so copy and paste those functions and
226:28 - then give each a body
226:35 - and with the parameter for print winner
226:37 - the parameter is char
226:39 - winner now let's head back to the top of
226:42 - our program and there's a few global
226:44 - variables that we're going to declare we
226:46 - could declare these as local variables
226:47 - within the main function but this
226:49 - program is going to get really
226:50 - complicated then if we have to pass
226:52 - around pointers to a two-dimensional
226:54 - array so just to keep this simple i'm
226:56 - going to create some global variables
226:58 - there are some downsides to global
227:00 - variables so i tend to not to like to
227:02 - use these so we have a 2d array of
227:04 - characters named board it's our game
227:06 - board and let's create two constants
227:09 - constant char player a naming convention
227:12 - for constants is to make all of the
227:14 - letters uppercase
227:16 - and i will set this to a character of my
227:18 - choice i could be oh or i could be x or
227:21 - something else maybe i could be a dollar
227:23 - sign whatever uh i'll set myself to be
227:25 - an x and then let's create a constant
227:28 - for the computer constant char
227:31 - computer and computers will be o so
227:34 - within the main function we will declare
227:37 - a local variable char
227:39 - winner
227:40 - and i'll go ahead and set this to an
227:42 - empty space so if our winner is in empty
227:45 - space that means there currently is no
227:47 - winner if player wins then that would be
227:50 - an x if computer wins that's a no within
227:53 - our main function this is acting as a
227:55 - driver for our code so the first thing
227:58 - we'll do is reset our board
228:01 - so we are going to initialize all of the
228:03 - different characters within our
228:05 - two-dimensional board so let's head to
228:07 - this function
228:09 - so with our reset board function we need
228:12 - nested loops
228:15 - the outer for loop is for the rows the
228:17 - inner for loop will be for the columns
228:20 - int i set this equal to zero and i need
228:22 - to iterate this for loop three times one
228:25 - for each row that we have
228:27 - and then we need an inner for loop
228:31 - so change the index to j
228:35 - and for each index within our 2d array
228:38 - at index of i
228:40 - and j i will set the sequel to an empty
228:42 - space
228:44 - so when we call the reset board function
228:46 - each element within this 2d array of
228:49 - characters will be an empty space
228:51 - effectively clearing it
228:53 - so back within the main function after
228:55 - resetting our board let's print our
228:57 - board
229:00 - and fill in this function
229:03 - so you can get creative with this
229:05 - here's one thing that i'll use
229:08 - so i'm going to print a space
229:11 - a character a space
229:13 - a vertical bar
229:15 - space
229:16 - character space vertical bar
229:19 - space
229:20 - character
229:22 - these three format specifiers are
229:24 - placeholders the first character i'm
229:26 - going to display is our board at index
229:29 - of zero zero that is row zero column
229:33 - zero followed by board index zero one
229:38 - then board zero two
229:41 - and with the next printf statement let's
229:43 - display something like this
229:45 - a new line
229:47 - three dashes
229:48 - a vertical bar
229:50 - three dashes another vertical bar
229:53 - three dashes then a new line
229:55 - okay so let's copy these
229:58 - paste it once
230:00 - and we need to change these indices
230:02 - so with this third printf statement
230:05 - these indices will be one zero one one
230:09 - one two
230:10 - and then do this again so copy paste
230:15 - two zero
230:16 - two one
230:17 - two two
230:19 - then at the end i'll add a new line
230:21 - printf
230:23 - new line
230:25 - oh let me fix one thing
230:31 - okay so this is what it should be
230:33 - all right now back within our main
230:34 - function we're going to create a while
230:36 - loop and we'll surround our print board
230:38 - function within this while loop
230:44 - so our condition is if winner is equal
230:48 - to an empty space
230:50 - that means there currently is no winner
230:53 - and after invoking the check free spaces
230:57 - function
230:58 - the value returned does not equal zero
231:02 - so let's fill in this check free spaces
231:04 - function
231:06 - within the check free spaces function
231:08 - let's declare a local variable int free
231:11 - spaces and i'll initially set this to
231:13 - nine then we need a nested for loops
231:20 - and i equals 0 we will continue this as
231:23 - long as i is less than 3
231:25 - i plus plus
231:27 - then create an inner for loop
231:30 - change the index from i to j
231:34 - and within the inner forward loop we're
231:36 - going to write an if statement
231:38 - and we are checking to see if our 2d
231:40 - array of characters bored
231:42 - at index of i and j does not equal an
231:46 - empty space
231:48 - if whatever spot we're on is currently
231:50 - occupied we will take our free spaces
231:53 - local variable and decrement it by one
231:56 - then outside of our for loops we will
231:59 - return
232:00 - free spaces
232:03 - if we return zero that means the game is
232:06 - over there's no more places a player can
232:08 - move
232:09 - so heading back to our main function
232:11 - it will be let's say the player's turn
232:13 - to move first
232:14 - so invoke the player move function and
232:18 - we'll need to fill this in
232:20 - with the player move function we will
232:22 - declare two local variables intex into y
232:26 - and we will ask a user to enter in a row
232:29 - number and a column number of where they
232:31 - would like to move to so using a printf
232:34 - statement
232:35 - we will enter
232:36 - row number
232:39 - one through three
232:42 - and then use the scan f function to
232:44 - accept some user input so this will be
232:47 - an integer and use the address of
232:49 - operator x
232:52 - so a user is going to enter in numbers
232:54 - one through three for which row that
232:56 - they need but with arrays they always
232:58 - begin with zero but a user is not going
233:01 - to know that so with whatever the user
233:03 - types in we will decrement x by one
233:06 - so this gives us rows zero through two
233:08 - technically
233:10 - then do the same thing with our columns
233:13 - enter column number one through three
233:17 - address of operator y then decrement y
233:20 - we will check to see if the coordinates
233:22 - that the user gave are occupied or not
233:25 - so using an if statement
233:28 - we will check to see if our board
233:30 - at index of x
233:32 - and y
233:34 - does not equal an empty space that means
233:37 - that this spot is currently occupied by
233:40 - another character
233:41 - so let's print something to let a user
233:43 - know
233:45 - invalid move
233:48 - else that spot is open
233:51 - so take our board
233:53 - at index of x and y
233:56 - set this equal to our player character
233:59 - so we're going to take all of this code
234:01 - and place it within a do while loop so
234:04 - write do
234:05 - while
234:07 - place your code that you just wrote
234:08 - within there
234:13 - and our condition
234:14 - is if our board
234:16 - at index of x
234:18 - and y does not equal an empty space
234:22 - if the spot that the player would like
234:24 - to place their character is currently
234:26 - occupied then we will ask them again to
234:29 - enter some coordinates uh then within
234:31 - our else statement we need to break out
234:33 - of this while loop okay so that is
234:35 - everything for the player move function
234:38 - so then heading back to the main
234:40 - function
234:41 - after the player moves we will check to
234:43 - see if there's a winner
234:45 - winner equals then invoke the check
234:48 - winner function
234:50 - and we will fill in this function next
234:53 - so find the check winner function and we
234:56 - need to check all of the different win
234:58 - conditions
234:59 - so first we will check each row using a
235:02 - for loop so this section of code we will
235:05 - check our rows we'll need a for loop to
235:08 - iterate three times one for each row
235:11 - int i
235:12 - equals zero continue this as long as i
235:15 - is less than three
235:17 - increment i by one so this if statement
235:19 - is going to get a little bit funky we
235:21 - need to check each set of horizontal
235:24 - elements
235:25 - so let's begin with board at index of i
235:30 - and zero so that would be the top left
235:33 - element and we are checking to see if
235:36 - the character here is equal to this
235:38 - character
235:40 - so board at index i
235:43 - and one
235:45 - and we're checking to see if board at
235:48 - index of i and zero is equal to board at
235:52 - index of i and two so here we're
235:55 - checking to see if this element is equal
235:58 - to this element and this element is
236:00 - equal to this element
236:02 - if they're all consistent we have a
236:04 - winner so we will return whatever
236:06 - character is within one of these
236:08 - elements let's say this one so return
236:11 - board at index of i index of zero return
236:14 - whatever character is within here this
236:16 - section of code will check all of the
236:18 - win conditions for each row but now we
236:21 - need columns so check columns
236:25 - and we can copy most of this so copy it
236:27 - and paste it
236:29 - then we just need to change these
236:31 - indices around
236:32 - so if board at index 0
236:36 - i
236:36 - is equal to board at index of one
236:40 - i
236:42 - and board at index of zero
236:46 - i
236:46 - is equal to board at index of two
236:50 - i then we will return whatever character
236:53 - is within board index of zero index of
236:56 - one so this section of code will check
236:59 - for any column when conditions then next
237:02 - we have diagonals there's only two
237:05 - check diagonals
237:08 - so let's copy this section of code
237:11 - paste it so our indices are 0 0
237:15 - is equal to
237:16 - 1
237:17 - 1. 1 1 is in the middle and board at
237:21 - index of zero zero
237:23 - is equal to board at index of two two
237:27 - if so then return zero
237:29 - zero
237:31 - then we have one more diagonal so copy
237:33 - this
237:34 - paste it
237:36 - and here are the elements if board at 0
237:39 - 2
237:40 - is equal to board at
237:42 - 1 1 so 0 2 is the bottom left 1 1 is the
237:46 - middle and
237:48 - board at zero zero equals board at two
237:52 - zero that is the top right corner right
237:55 - here so if we have a diagonal we have a
237:57 - winner so return board at zero
238:00 - 2 let's say if after checking all of
238:03 - these different win conditions there is
238:05 - no winner
238:06 - then let's return an empty character
238:09 - that means there currently is no winner
238:11 - so then head back to the main function
238:13 - after invoking the check winner function
238:16 - let's write an if statement to see if
238:17 - the game is over
238:19 - so our condition is if winner does not
238:23 - equal an empty space that means there is
238:26 - a winner
238:27 - or after invoking the check free spaces
238:30 - function and the value returned is zero
238:34 - then we will break out of this while
238:36 - loop this is everything done for the
238:38 - player now we need to create a section
238:40 - of code within our while loop for the
238:41 - computer
238:42 - so copy this section of code and paste
238:45 - it and this time it will be the
238:48 - computer's move
238:50 - invoke the computer move function and we
238:52 - will need to fill in the computer move
238:54 - function
238:56 - within the computer move function the
238:58 - computer's move will be randomly
239:00 - generated and to generate some random
239:02 - numbers we'll need a seed
239:06 - so to create a seed to generate random
239:08 - numbers
239:10 - invoke the s rand function
239:12 - pass in time
239:14 - invoke it pass in zero
239:17 - and we will declare intex and into y we
239:21 - will generate two random numbers between
239:23 - zero and two now before we generate some
239:26 - random numbers let's check to see if we
239:28 - even have any free spaces available
239:30 - so our if statement is going to be check
239:33 - free spaces invoke it then if this is
239:37 - greater than zero then we will generate
239:39 - some random numbers
239:41 - and we'll do so within a do while loop
239:44 - so within this do while loop we will
239:47 - generate two random numbers between 0
239:49 - and 2.
239:50 - x equals
239:52 - invoke the rand function
239:54 - modulus three
239:56 - then y equals invoke the rand function
240:00 - modulus three with our condition let's
240:02 - check to see if the spot generated is
240:05 - even open
240:06 - so board at index of x
240:09 - and y
240:10 - does not equal an empty space so we will
240:13 - keep on generating random numbers until
240:15 - there is an open space then escape this
240:18 - while loop so if we find an open space
240:21 - let's take our board at index of x and y
240:25 - set the sequel to our computer player
240:28 - this is all within an if statement
240:31 - else if there are no more spaces
240:33 - available
240:34 - we will invoke the print winner function
240:39 - and pass in an empty space
240:41 - this means that there is no winner it's
240:43 - a draw
240:44 - now let's fill in this print winner
240:46 - function this function is fairly easy
240:50 - if winner is equal to player
240:53 - then we will print
240:56 - you win
240:59 - else if
241:01 - winner is equal to computer
241:06 - then we will print
241:09 - you lose
241:12 - else if there is no winner then it's a
241:15 - tie it's a draw
241:20 - it's a tie
241:22 - within the main function we just have a
241:24 - few more things to add so outside of our
241:26 - while loop we will print our board and
241:29 - print the winner
241:31 - print
241:32 - board
241:34 - and print
241:35 - winner
241:37 - there is one argument whoever the winner
241:39 - is
241:40 - so let's run this once
241:43 - enter row numbers one through three uh
241:45 - let's say one
241:46 - and one
241:48 - so i moved here and the computer moved
241:50 - to row three column two
241:53 - uh let's say row three column three
241:56 - okay so i moved here and the computer is
241:58 - up here so i moved to row three column
242:01 - three and our computer is at row one
242:03 - column three
242:04 - uh then i'll move to the middle two
242:07 - two
242:08 - and it looks like i won this round so
242:10 - let's try this again and we will
242:12 - intentionally lose so one one
242:15 - two one
242:17 - one two
242:18 - two two
242:20 - and unfortunately it looks like i lost
242:23 - this time let's attempt to tie
242:30 - and it looks like it's a tie so it looks
242:32 - like this game is working so what if we
242:34 - would like to ask the user if they would
242:35 - like to play again we can easily place
242:37 - our code within a do while loop so
242:39 - within our main function
242:41 - let's create char
242:42 - response
242:44 - and we will create a do while loop
242:46 - so take all of this code after the do
242:49 - while loop beginning with reset board
242:52 - copy it
242:54 - delete it
242:55 - and then paste it within the do while
242:57 - loop
243:01 - at the top of our do while loop let's
243:03 - reset winner and response
243:07 - winner equals an empty space
243:10 - and response equals an empty space
243:13 - then heading to the bottom of our do
243:15 - while loop let's ask if the user would
243:17 - like to play again
243:19 - so after displaying the winner let's
243:21 - create a prompt
243:22 - printf
243:24 - would you like to play again
243:30 - y for yes and for no
243:34 - and i'm just going to clear our buffer
243:36 - by using scanf and accepting a character
243:39 - just in case there is a new line
243:41 - character within our buffer then we will
243:43 - use the scanf function and accept a
243:46 - character after clearing our buffer
243:48 - and we will use the address of operator
243:51 - response
243:52 - now just in case somebody types in
243:54 - lowercase y i would still like to count
243:56 - that as yes so i'm going to take our
243:59 - response
244:00 - set this equal to invoke the to
244:03 - upper function
244:05 - pass in response
244:08 - and with this condition we will continue
244:10 - playing while our response is equal to
244:14 - the character y
244:16 - and at the end let's print
244:18 - thanks for playing okay let's run this
244:21 - one last time
244:25 - all right i win would you like to play
244:27 - again
244:28 - i'll type in y for yes
244:30 - and we have a new game
244:35 - all right it looks like i win so this
244:37 - time i will exit by typing n
244:40 - thanks for playing
244:41 - so yeah everybody that is a game of
244:44 - tic-tac-toe if you would like a copy of
244:46 - this code i'll post this to the comments
244:48 - section down below hey if you found this
244:50 - video helpful you can help me out by
244:52 - smashing that like button leave a random
244:54 - comment down below and subscribe if
244:55 - you'd like to become a fellow bro