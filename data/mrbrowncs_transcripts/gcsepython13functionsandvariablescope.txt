00:00 - hello in video 13 in Veszprem playlist
00:02 - we're now going to talk about functions
00:04 - and also the concept of having the
00:07 - Scopes of variables both of these
00:10 - concepts actually we have talked about
00:12 - in passing at least but it's now time to
00:14 - talk about them in more detail we have
00:16 - talked various stages about how
00:18 - something you may have learnt in class
00:20 - when you're learning programming theory
00:21 - may not always totally apply to
00:25 - programming when you're doing it
00:27 - practically and this topic of functions
00:29 - is quite a good example because if
00:30 - you've learned programming theory maybe
00:32 - we'll ever learn about sub programs also
00:33 - called subroutines
00:35 - or so-called routines on their own but
00:38 - I'm doing a multi-line comment here with
00:41 - frequent mocks as all of this would be
00:43 - ignored by our program if I run it as
00:46 - opposed to just doing one line with a
00:47 - hash tag that symbol hash symbol should
00:49 - say anyway so we have sub programs and
00:51 - subroutines and these are a construct in
00:53 - programming a really really important
00:55 - one which is essentially learn about if
00:58 - you're doing any exams in it but really
00:59 - what these are is a out of line block of
01:04 - code which can be referred to and we
01:08 - call this could be call this calling
01:10 - ionically in the main program so I think
01:15 - sub programs is a more helpful way of
01:16 - putting this subroutines is just a
01:18 - synonym for this so a sub program is
01:21 - just a really a little program within a
01:23 - wider program and using sub programs in
01:28 - code is not mandatory you know if you
01:30 - never uses a program in your life it's
01:32 - not great but you don't need to use them
01:35 - but they are really really important to
01:37 - make your code organized often we solve
01:38 - problems by decomposing a problem into
01:41 - subproblems and a sub program can be a
01:44 - really good way of containing just for
01:46 - code which solves an individual sub
01:47 - problem which may build up to solve your
01:50 - problem into in its entirety so our
01:52 - various having supper abs is a
01:54 - recommended action but if you ever get a
01:56 - job as a developer you'll need to use
01:57 - sub programs everywhere you'll get fired
01:58 - or not even hired in the first place and
02:01 - so but really this use of sub programs
02:03 - and use them heavily is all part of
02:05 - structured programming this is a kind of
02:08 - a style which is developed
02:09 - I mean programming is not on it is not
02:11 - an ancient art it's only been around for
02:13 - so long
02:13 - but it's been around for long enough the
02:15 - program is no wreck making recommend
02:17 - ways of programming and one of the ways
02:19 - is to use lots of sub programs and make
02:21 - sure they have nice interfaces between
02:23 - each other and you do about using
02:25 - parameters and also return statements
02:27 - we'll talk about and if you have learnt
02:29 - about sub programs you may not have
02:31 - learned about two main types of sub
02:33 - programs or subroutines we have
02:35 - functions which is the name of our video
02:37 - now and we have procedures
02:38 - I guess you also have methods which I
02:40 - have talked about as we've gone through
02:42 - all three of these are examples of sub
02:44 - routines or sub programs the difference
02:46 - is a function will generally Y will
02:49 - return so it returned a value a
02:52 - procedure will not and a method belongs
02:56 - to an object so in Python we have
03:00 - functions and we have methods we don't
03:02 - technically have a construct called a
03:04 - procedure where we can replicate your
03:07 - procedure as we go it's a bit like how
03:09 - in Python we haven't really got arrays
03:10 - we've got a list instead which can do
03:13 - the same sort of job and Python as well
03:15 - as all other languages has built-in
03:17 - functions some languages have more than
03:19 - others I won't have mentioned nearly all
03:21 - of them there are loads and loads of
03:23 - Python and you can have more with
03:25 - modules as well but once we've covered
03:27 - are things like prints things like Len
03:32 - things like input as well etc etc so all
03:36 - of these ones have built in we did not
03:38 - write these I did not write for print
03:40 - function which is a good thing because
03:42 - they would be very very hard to write
03:44 - usually these built-in functions I have
03:46 - a really fundamental as an really
03:48 - important to programming or really hard
03:50 - to do but someone has taken the time to
03:51 - do it for everyone there is not a
03:53 - built-in function for every single
03:54 - problem clearly we need to write some
03:56 - ourselves at some point which is what
03:58 - we're going to learn today but for
03:59 - certain things like printing to a screen
04:00 - how on earth would you print to a screen
04:03 - using just alternative constructs write
04:06 - certain things need to be done for you
04:07 - by the creators of Python otherwise it's
04:10 - not really usable print itself is a bit
04:12 - of a funny one because it doesn't really
04:14 - work like a functioning but it doesn't
04:16 - really return a value it said well it
04:18 - does it just show something to the user
04:19 - but we could take input for example as
04:22 - sort of a proper a proper function so if
04:25 - I may be a sign
04:26 - there's two a variable name then
04:28 - afterwards I can print the names to show
04:32 - that it is working maybe inside I just
04:33 - say enter your name
04:36 - so what being function does so here's a
04:38 - function right we have the wave or wave
04:41 - functions instruction Python is we have
04:42 - a name we haven't identified which in
04:44 - this case was not written by us it was
04:45 - written by someone else because it's
04:47 - built in and for following the name we
04:49 - have brackets and inside the brackets
04:51 - are where we can put arguments we always
04:53 - have to have an argument but the
04:55 - argument is some data being supplied to
04:57 - the function to use in this case we're
04:59 - saying in to your name the function is
05:01 - going to take this and show it to the
05:03 - user so the function input I'm sure is
05:05 - calling print within it because it's
05:07 - printing out into your name effectively
05:09 - and now I can type in up step and we go
05:11 - and press ENTER and now we're gonna get
05:13 - Guido printed out because what happened
05:15 - was what this function did was it
05:17 - allowed for user to type something in
05:18 - once a presence of a value is returned
05:21 - by the input function and saved in this
05:25 - case under the name name so under the
05:27 - variable name so input works by taking
05:29 - an argument which has been shown to the
05:31 - user and relatively user types in is
05:33 - returned back to the main program and
05:35 - can be maybe stored in a variable like I
05:37 - have here so let's look at how we can
05:39 - define a function ourself in physical
05:42 - example again of how you know built-in
05:45 - functions so important I don't know how
05:46 - on earth you would program an input
05:48 - function unless you were inventing a
05:49 - whole new language yourself okay so
05:51 - functions in Python have a set syntax
05:55 - like all other constructs and this
05:56 - syntax is when we are defining a
05:58 - function when we are setting up we use
06:01 - for DEF keyword short for definition and
06:04 - then we put our function name we can
06:05 - choose whatever we want to like a
06:06 - variable we have certain restrictions
06:08 - right I can't do two word
06:11 - function names got be singular a
06:13 - singular word I can't use any reserved
06:15 - word so I can't use def again I can use
06:18 - something my function then I follow this
06:21 - with brackets and I can use these I can
06:25 - leave these brackets empty and then you
06:27 - put a colon press ENTER and like with if
06:30 - statements like with while loops we have
06:32 - an indentation in the body of our
06:34 - function here to differentiate what is
06:36 - inside this function and what is outside
06:38 - so we have to do
06:39 - it was done for me by rep lip you can
06:41 - hide it with a tab besides of being
06:43 - there doesn't matter as long as you are
06:45 - consistent so now if I just do something
06:47 - simple like print hello world inside and
06:50 - get out of it makes write backspace to
06:53 - get rid of it indentation and now if I
06:55 - refer to this which we say calling so if
06:58 - I type in my function and with our
07:00 - brackets like this I am calling this sub
07:04 - program fizz subroutine this function so
07:06 - let's run this and check this works so
07:08 - I'm running it we get hello world not
07:10 - very exciting but what's happening first
07:12 - of all the Python interpreter works by
07:15 - going line by line so it's making its
07:17 - way down from line 1 to line 6 in this
07:19 - case most of his lines up or half the
07:20 - lines are empty but it's first of all
07:22 - reading this definition it's not doing
07:24 - anything yet so for print hello world
07:25 - which has shown to me over here is not
07:27 - happening because we have this
07:28 - definition if I comment out this calling
07:31 - statement I get nothing happening
07:33 - because it's only going to run the code
07:35 - inside the function when it's been
07:36 - called which it has done here so it's
07:39 - going right taking note of his
07:40 - definition and then as soon as it comes
07:42 - across something referring to it it's
07:44 - going to sort of jump back to where the
07:46 - function was defined and run the code
07:48 - inside of it it's why it was called why
07:50 - am i definition I called it an out of
07:52 - line Rock of code right clearly it's a
07:56 - block of code a very short one in this
07:57 - case one line but it's out of line so we
07:59 - have our main program down here often
08:01 - called just main or the main routine and
08:05 - whenever we are calling a function we're
08:07 - going to go back and find where it was
08:10 - defined and execute it so function
08:12 - definitions tend to be out of line out
08:14 - of sequence if I get the sequence a bit
08:17 - wrong and instead make this calling
08:21 - statement above my definition it's not
08:24 - going to work we're gonna get an error
08:25 - because it works sequentially at work
08:28 - starting like one and working its way
08:30 - down so it's coming across in line to my
08:32 - function it doesn't know what this is it
08:34 - hasn't seen the definition yet and so it
08:36 - doesn't it can't do anything it's not
08:38 - defined and that's why generally
08:39 - speaking your functions if you have say
08:40 - 20 functions in your massive program
08:43 - you're going to put all of the
08:44 - definitions at the top or even in a
08:46 - separate file sometimes because if you
08:49 - have them sore mixed in with your main
08:50 - program
08:51 - it's gonna be a bit strange and could
08:54 - cause errors so what I have called here
08:56 - a function and what Python would call a
08:57 - function other people may call a
08:59 - procedure because we're just repeating
09:01 - some code we're not we are not returning
09:05 - anything to the user instead what I
09:08 - could do is I could change print and get
09:10 - rid of this that my brackets here and I
09:13 - could just return using another keyword
09:14 - could return a value of hello world in
09:18 - this case so if I print this nothing's
09:20 - gonna happen because we're not in this
09:22 - case we're not printing anything to the
09:24 - user printing is not when you're
09:27 - bringing something you can't then use
09:28 - that print statement it's just been
09:29 - shown to the user when you are returning
09:31 - a value it can be used in your main
09:33 - program so if I set a variable and call
09:34 - this text equals at my function what
09:38 - happen is when I am calling this
09:39 - function the return value which in this
09:41 - case is hello world will get saved under
09:44 - a variable text so it get returned to my
09:46 - main program so I didn't do anything
09:48 - there - fine I'll just print text there
09:50 - like how will you do it in thought what
09:51 - exactly how we were doing with input
09:52 - we're going to get our value which was
09:54 - returned to us and news and return
09:56 - values as opposed to using a print
09:58 - inside a function is definitely a good
10:01 - way of doing it because otherwise you
10:02 - can't really use any value which was
10:04 - created in your function so Connie in my
10:07 - function my brackets are empty which is
10:08 - perfectly fine if you have a proper
10:10 - program and you are following the
10:12 - structured programming style you are
10:14 - going to want to eventually pass in data
10:16 - to a function returning is like passing
10:19 - data out of a function and you also want
10:21 - to be able to input data to a function
10:23 - as in passing data and we do this
10:25 - through something called a parameter so
10:26 - if we want to pass in data we're going
10:29 - to use a parameter to do list or
10:31 - parameters and this and B's are like a
10:34 - variable used only in a subroutine so if
10:38 - I set if I type in is my brackets number
10:42 - this is like me setting a variable call
10:44 - number but only to be used in this
10:46 - subroutine so now if I go back to my
10:48 - calling definition well first of all if
10:50 - I press 1 5 run this now I'm going to
10:53 - get an error because it says I get type
10:55 - error my function missing one required
10:57 - positional argument number because I
10:59 - have defined a parameter is now
11:02 - expecting an argument to this so I
11:04 - possibly
11:05 - way we can maybe talk about to one other
11:10 - issue maybe which would come up so if I
11:12 - just missed put in five in my calling
11:15 - statement and now just maybe could let's
11:18 - just return whatever number is times ten
11:24 - and run this so I said two words where
11:27 - we get fifty because what it's doing is
11:29 - it's passing in five to our function and
11:31 - then inside this function just in our
11:33 - return statement that's using the value
11:36 - of this variable which is 5 multiplied
11:38 - by 10 just 50 misses returned to our
11:40 - main routine so I said two words were
11:44 - said parameter and we also had argument
11:46 - an argument was mentioned in my error
11:47 - message so the distinction between
11:50 - parameter and argument is not the most
11:52 - crucial thing in the world they are used
11:55 - mostly interchangeably technically
11:57 - speaking a parameter is the variable
12:00 - name so in this case number is a
12:02 - parameter to the function my function
12:04 - and the argument is the actual data
12:06 - being passed in so five is an argument
12:09 - not a parameter technically although
12:11 - it's being ret is representing or it's
12:13 - being represented by the parameter
12:15 - number I will often make a mistake I'll
12:17 - accidentally say argument when I mean
12:19 - parameter and vice-versa so it's not a
12:21 - huge deal but if you hear me say
12:23 - argument I'm really meaning the actual
12:25 - data and parameter is this variable we
12:27 - can have as many parameters as we want
12:29 - to or indeed none to make sure they are
12:31 - have different names and are following
12:33 - the same normal variable Walser fine
12:35 - I'll do number one times number two I
12:37 - now have to supply two numbers here so
12:40 - five and seven five times seven is gonna
12:43 - be 35 I can also set a default if I want
12:46 - to so I can set the default for number
12:47 - two to be five that means if I don't
12:50 - supply the second argument is still
12:52 - gonna work when you have five times five
12:53 - is 25 because it was not been given the
12:55 - argument for that parameter because I've
12:58 - set a default it can still use the
13:00 - default but if I add in a second
13:02 - argument let's just do seven again it's
13:04 - gonna override the default and make it
13:06 - 35 also I can't say this is used
13:08 - massively often but you may see it
13:11 - especially in certain programs where if
13:14 - you have an Asterix before a
13:17 - to name well you just have one parameter
13:19 - in this case often written as args short
13:22 - arguments there can be anything here but
13:25 - with the Asterix before it this is where
13:26 - it may be you're not quite sure how many
13:28 - arguments you're going to get so in this
13:31 - case what we could do is change this to
13:33 - be args and we will then index it so
13:38 - then if I follow this within the next
13:39 - number of 0 which is going to be the
13:41 - first argument inputted and then we have
13:43 - maybe next number of 1 if I now type in
13:48 - 5 7 and 6 and then eight and a nine like
13:51 - that so I've now supplied 5 arguments to
13:54 - this function it's only going to use the
13:57 - first two so I'm going to use five and
13:58 - seven because it's being flexible
14:00 - because we have sort of unlimited number
14:03 - of arguments here but it's just going to
14:05 - reference them so really what's being
14:06 - inputted in this case is a tuple
14:08 - so like a list really and we can exit
14:11 - like this this may be useful if you're
14:12 - not quite sure how many arguments you're
14:14 - going to get and you can code based on
14:16 - this topple it's a bit risky bow because
14:19 - if you do something like args and then
14:20 - index of eight unless you are going to
14:22 - put in nine arguments it's going to
14:25 - cause an issue so we get a tuple in this
14:26 - outer range error and I should set this
14:28 - point why using subroutines is a really
14:30 - really good idea and by what I mean if
14:32 - you want to be a decent programmer you
14:33 - should use them absolutely it's not just
14:35 - it goes a bit beyond recommend it which
14:37 - I said up a start so using a subroutine
14:39 - is really good because you can repeat
14:41 - code really really easily now a one-line
14:43 - function like this is not the best
14:44 - example no real program might have quite
14:48 - a long subroutine am i I've say 50 lines
14:50 - in it and those 50 lines may need to be
14:52 - executed may need to be called quite a
14:55 - few times in your code and if you need
14:58 - to reuse it so often having it defined
15:01 - once I've top of your program and then
15:03 - called several times so actually
15:04 - reference several times is saving your
15:07 - program having a bunch of repeated code
15:09 - over and over again with a calling
15:12 - statement or just referring to one
15:13 - definition if you're using it loads and
15:15 - loads of times this is much more
15:16 - efficient than like I say copying and
15:18 - pasting a load of code and parameters
15:20 - are really powerful because we can
15:21 - change what is going on inside our
15:23 - function every time we are calling the
15:26 - likewise return values allow us to take
15:28 - some data take some output from our
15:29 - function and I've said for parameters
15:31 - like variables while python is really
15:33 - relaxed so actually it can be any object
15:35 - so you can have like a list as our
15:37 - parameter which is reducible for list
15:40 - functions if my if I maybe just doing
15:42 - like a turn the length of my list like
15:44 - that I can now make sure I supply a list
15:48 - I don't need to actually define it first
15:50 - I could just change it like this and we
15:52 - should get 5 as our output because we
15:55 - have 5 items in our list like this this
15:57 - is really nice and by the way just
16:00 - speaking of lists and list functions a
16:02 - value something like my length my list
16:05 - dot append and I try to append five to
16:09 - this and run this and see what happens
16:11 - first of all well we get an error so we
16:14 - get an error it says name my list is not
16:16 - defined now a few things we could say
16:17 - about this first of all just just take a
16:19 - slight deviation look at what is going
16:21 - on over here so we have my list I may
16:23 - have a dot and we have append and
16:25 - brackets 5 so this append 5 is what we
16:27 - would call a method like I said of a
16:29 - start method works on an object a list
16:31 - is an object in Python and we leave
16:34 - discussion of objects on how to create
16:36 - our own methods until we talk about
16:38 - object-oriented programming which is a
16:40 - fairly advanced topic it would be an
16:42 - a-level topic if you're studying in the
16:44 - UK but I digress why are we having a
16:46 - name error like this because I've got my
16:49 - list up here I've defined it as a
16:51 - parameter why can't I then use it over
16:53 - here well this is all to do with scope
16:55 - and the order of things really matters
16:57 - like how earlier when I swapped my
16:58 - definition with my calling statement
16:59 - they didn't work the order of how we
17:02 - define things is really important so
17:04 - here we haven't despite a definition up
17:06 - here we haven't defined my list to be
17:07 - anything and when we use a method we
17:10 - need to have the object created
17:11 - beforehand ok I've created a new basic
17:15 - programs to clean up the mess if it was
17:16 - for last bit of code so here I've got a
17:19 - new function which hasn't got a return
17:21 - value but has got two parameters we have
17:23 - name and a birth year as could welcome
17:26 - and first of all we're trying to figure
17:27 - out the age by subtracting the current
17:29 - year just 2020 as I record this
17:31 - whatare by vs. about mr. attractive a
17:33 - birth year from 2020 to work up our age
17:35 - in printing let's try this so I've
17:38 - called it with Guido and 1980 we get
17:40 - welcome Guido you are 40 years old but
17:42 - if a weird message but it's just an
17:44 - example
17:45 - so we are setting a variable inside our
17:47 - function called H using a parameter
17:50 - value and we have called it down out of
17:53 - the body of our function because you can
17:56 - see being done is different over here so
17:58 - now if I try and maybe well let me try
18:00 - and print age and see what age has been
18:02 - set to because up here we are setting
18:04 - age to be 20 20 minus of birth year so
18:08 - in this case when we have called air
18:09 - it's gonna be 20 to 20 minus 1980 which
18:11 - gives us 40 so really age should be 40
18:14 - at this point but when I run it we get
18:16 - an error it says name error name age is
18:18 - not defined and this is because well
18:21 - this is all about scope so scope of
18:23 - variables and the scope of variables
18:27 - refers to their visibility which relates
18:29 - to where they can be accessed from in
18:31 - your program so this variable up here
18:34 - age is what we call a local variable so
18:36 - it's got a local scope it's only
18:38 - available inside this function so age
18:42 - will only exist as long as this function
18:44 - is executed soon this function returns a
18:46 - value or doesn't in this case as soon as
18:48 - function finishes age is lost and no one
18:52 - cares anymore
18:52 - because it's local to this function
18:55 - whereas if I set age at the top to be
18:58 - maybe age by default is initialized to
19:00 - zero this would be what we would call a
19:03 - global variable so its global it's got
19:06 - global scope this means this variable
19:08 - can be accessed by anywhere in the
19:10 - program can we access inside this
19:12 - function they can be accessed outside
19:13 - the function can you access from
19:16 - anywhere where's this local variable can
19:17 - be accessed inside the function say my
19:19 - day with if statement same idea with
19:21 - while loops so now if I print this we
19:24 - get you are 40 years old because inside
19:25 - age has been set to 40 which is
19:27 - perfectly fine but when we don't women
19:30 - print it down here because I have
19:31 - initialized it to be 0 in global scope
19:33 - we get age being 0 so this local
19:36 - variable age is completely separate from
19:38 - the outside world from the main programs
19:41 - to be separate from the variable age up
19:43 - here and that is one of the many
19:45 - advantages of using local variables
19:46 - instead of constantly using only global
19:49 - variables is because you can have
19:50 - multiple variables with the same name as
19:52 - long as you've got different local
19:54 - variables maybe you've got 50 functions
19:56 - it's going to be hard to think of
19:57 - separate name
19:58 - four variables in 50 different functions
20:01 - but it doesn't matter because each each
20:03 - function has got local variables which
20:04 - are kept separate from every other
20:06 - function if you are desperate for this
20:09 - variable age which is first-years inside
20:12 - this to be made global we can proceed
20:15 - our assignment with the keyword global
20:17 - and age and now this variable is made
20:22 - global and so we get 40 as opposed to 0
20:24 - because what's happening is because this
20:26 - variable is now global it's going to
20:28 - overwrite the actual global variable at
20:31 - the top and return 40 in fact I get rid
20:33 - of this age initialization at the top we
20:36 - are still me at 40 because here we are
20:38 - creating global variable even if it is
20:41 - inside a function now a bit like the
20:44 - break and continue keywords we looked at
20:46 - in volute videos using global as a
20:49 - keyword is sort of what's available you
20:51 - can't do it but I'd read not recommend
20:53 - it enough I disadvantages of using local
20:55 - variables like the fact that you can
20:57 - have multiple variables with the same
20:58 - name and also make sure code a little
21:00 - bit Messier I've definitely got into a
21:04 - real mess programming and had to use
21:06 - global variables but that was more down
21:08 - to my lack of design and maybe lack of
21:10 - planning than a deliberate tactic you
21:13 - often only use it when you are sort of
21:15 - really stuck and I've got some issue
21:17 - with your logic if you are probing
21:19 - properly you shouldn't really ever need
21:21 - to use global variables in this way and
21:24 - by that I mean setting a global variable
21:25 - from inside a function it's fine using
21:28 - outside of the function but inside of M
21:30 - setting to be global as opposed to local
21:32 - is a bit of a strange decision it also
21:35 - makes means really confusing if you've
21:36 - got multiple functions with multiple
21:37 - local variables and some are global some
21:39 - are local
21:40 - it just gets really confusing so
21:41 - generally stick with local variables and
21:43 - use for a turn value and the parameters
21:46 - to pass data in and out don't do that by
21:49 - using global variables there are two
21:51 - parts to this try now first of all have
21:53 - a look at this block of code in the top
21:55 - right we have three functions here and
21:58 - trying to figure out based on my calling
22:00 - statement at the bottom what would be
22:03 - outputted two views or what would be
22:05 - printed out of this so this was very
22:07 - easy for me to write but is a little bit
22:08 - harder to figure out so work backwards
22:10 - and see how you do you mean
22:12 - to jot down intermediate steps it's not
22:14 - easy by any means and for question to
22:17 - write a welcoming a fairly short
22:19 - function actually which will return the
22:21 - factorial of a number which you are
22:23 - going to supply via a parameter so you
22:26 - may not have come across what a
22:27 - factorial is usually we write it as an
22:30 - exclamation mark following a number so
22:32 - you might say five factorial or five
22:34 - bang sometimes people say that and what
22:37 - we start so factorial is just giving you
22:40 - the product of all of the integers from
22:42 - your number down to one so five bang or
22:44 - five factorial is 5 times 4 times 3
22:46 - times 2 times 1
22:47 - which gives us 120 0 factorial is a
22:51 - little bit of an odd result because 0
22:52 - factorial gives you one just by
22:54 - following the pattern because if you
22:57 - divide it does follow the pattern if you
22:59 - have negative numbers this does not work
23:00 - so what I did and I wrote this and
23:02 - there'll be a solution in the
23:03 - description is use a loop to keep asking
23:05 - if you use it until they enter a valid
23:08 - number