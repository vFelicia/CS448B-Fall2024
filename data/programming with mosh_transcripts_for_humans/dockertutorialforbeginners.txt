With timestamps:

00:01 - welcome to the ultimate docker course in
00:03 - this course i'm going to take you on a
00:05 - journey and teach you everything you
00:07 - need to know about docker from the
00:08 - basics to more advanced concepts so by
00:10 - the end of this course you'll be able to
00:12 - use it like a pro as part of your
00:14 - software development workflow if you're
00:16 - looking for a comprehensive and highly
00:18 - practical course that takes you from
00:19 - zero to hero this is the docker course
00:22 - for you we're gonna start off with a
00:23 - really simple project so you understand
00:25 - the basics then we'll use docker to run
00:28 - and deploy a full stack application with
00:30 - a front end back end and a database so
00:32 - you learn all the necessary techniques
00:34 - and apply them to your own projects i'm
00:36 - ash hamadani and i've taught millions of
00:38 - people how to advance their software
00:40 - engineering skills through my youtube
00:42 - channel and online
00:43 - onlineschoolcodewithmash.com if you're
00:45 - new here be sure to subscribe as we
00:47 - upload new videos all the time
00:49 - now let's jump in and get started
00:55 - [Music]
01:02 - let's quickly talk about what you need
01:03 - to know to take this course to take this
01:05 - course you don't need any prior
01:07 - knowledge of docker because i'm going to
01:08 - teach you everything from scratch but
01:10 - you should have at least three months of
01:12 - programming experience ideally you
01:14 - should have built at least one
01:15 - application so you should know concepts
01:17 - like front-end back-end api and database
01:20 - it doesn't matter what languages and
01:22 - frameworks or what database engines
01:24 - you're familiar with but you should know
01:25 - what these concepts are all about also
01:28 - you should be familiar with basic git
01:30 - commands like cloning a github
01:31 - repository committing code pushing and
01:34 - pulling just the basics nothing more
01:36 - with all that let's move on to the next
01:38 - lesson
01:40 - [Music]
01:44 - now we all have different ways of
01:46 - learning things but let me tell you what
01:48 - i think is the best way to take this
01:50 - course this course is highly practical
01:52 - so you should be active while watching
01:54 - this course in my opinion it's best if
01:57 - you watch each lesson take some notes
01:59 - you can either take notes on a piece of
02:00 - paper or using your favorite note-taking
02:03 - tool just write some keywords some
02:05 - keywords that help you remember what we
02:07 - talked about then after each lesson go
02:10 - through your notes and repeat the same
02:11 - steps i have taken in that lesson so if
02:14 - i talked about a bunch of commands play
02:15 - with those commands make sure you
02:17 - understand how they work if you follow
02:19 - that i promise you by the end of this
02:21 - course you're gonna master docker and
02:23 - use it like a pro
02:28 - alright our journey to master docker
02:30 - begins here in every section you're
02:32 - going to discover something new about
02:34 - docker in this section we're going to
02:36 - talk about what docker is and why it's
02:38 - so popular then we're going to talk
02:40 - about virtual machines and containers
02:42 - next we're going to talk about the
02:43 - architecture of docker so you understand
02:45 - how it works then we're going to install
02:47 - docker and get our hands dirty i'm going
02:50 - to give you an overview of your
02:51 - development workflow with docker and
02:53 - then we're going to see that in action
02:55 - using a really simple example so by the
02:57 - end of this section you will have an
02:59 - idea what docker is all about i'm so
03:01 - excited about this section i hope you
03:02 - are too so let's jump in and get started
03:05 - [Music]
03:12 - [Music]
03:16 - so what is docker and why is everyone
03:18 - using it these days well docker is a
03:20 - platform for building running and
03:23 - shipping applications in a consistent
03:25 - manner so if your application works on
03:27 - your development machine it can run and
03:29 - function the same way on other machines
03:31 - if you have been developing software for
03:33 - a while you've probably come across this
03:35 - situation where your application works
03:36 - on your development machine but doesn't
03:39 - somewhere else can you think of three
03:40 - reasons why this happens
03:42 - well this can happen if one or more
03:44 - files are not included as part of your
03:46 - deployment so your application is not
03:48 - completely deployed it's missing
03:50 - something this can also happen if the
03:53 - target machine is running a different
03:55 - version of some software that your
03:56 - application needs let's say your
03:58 - application needs node version 14 but
04:00 - the target machine is running node
04:02 - version 9. this can also happen if the
04:04 - configuration settings like environment
04:06 - variables are different across these
04:08 - machines and this is where docker comes
04:10 - to the rescue with docker we can easily
04:13 - package up our application with
04:15 - everything it needs and run it anywhere
04:17 - on any machine with docker so if your
04:19 - application needs a given version of
04:21 - node and mongodb all of these will be
04:23 - included in your applications package
04:25 - now you can take this package and run it
04:28 - on any machine that runs docker so if it
04:30 - works on your development machine it's
04:32 - definitely going to work on your test
04:33 - and production machines now there's more
04:36 - if someone joins your team they don't
04:38 - have to spend half a day or so setting
04:40 - up a new machine to run your application
04:42 - they don't have to install and configure
04:44 - all these dependencies they simply tell
04:46 - docker to bring up your application and
04:48 - docker itself will automatically
04:50 - download and run these dependencies
04:52 - inside an isolated environment called a
04:55 - container and this is the beauty of
04:57 - docker this isolated environment allows
04:59 - multiple applications use different
05:02 - versions of some software side by side
05:04 - so one application may use node version
05:06 - 14 another application may use node
05:09 - version 9. both these applications can
05:11 - run side by side on the same machine
05:13 - without messing with each other so this
05:15 - is how docker allows us to consistently
05:17 - run an application on different machines
05:20 - now there is one more benefit here when
05:22 - we're done with this application and
05:24 - don't want to work on it anymore we can
05:26 - remove the application and all its
05:27 - dependencies in one go without docker as
05:30 - we work on different projects our
05:32 - development machine gets cluttered with
05:34 - so many libraries and tools that are
05:36 - used by different applications and then
05:38 - after a while we don't know if we can
05:39 - remove one or more of these tools
05:41 - because we're always afraid that we
05:43 - would mess up with some application with
05:45 - docker we don't have to worry about this
05:47 - because each application runs with its
05:49 - dependencies inside an isolated
05:51 - environment
05:52 - we can safely remove an application with
05:54 - all its dependencies to clean up our
05:56 - machine isn't that great
05:58 - so in a nutshell docker helps us
06:00 - consistently build run and ship our
06:03 - applications and that's why a lot of
06:05 - employers are looking for people with
06:07 - darker skills these days so if you're
06:09 - pursuing a job as a software or devops
06:11 - engineer i highly encourage you to learn
06:13 - docker and learn it well and that's
06:15 - exactly what this course is all about
06:17 - i'm going to take you on a journey and
06:19 - teach you everything you need to know
06:20 - about docker so you can use it like a
06:22 - pro no copy pasting commands here
06:27 - [Music]
06:31 - so in the last lesson i briefly talked
06:32 - about containers a container is an
06:35 - isolated environment for running an
06:37 - application now one of the questions
06:38 - that often comes up is how are
06:40 - containers different from virtual
06:42 - machines or vms do you know the
06:44 - differences well a virtual machine as
06:46 - the name implies is an abstraction of a
06:49 - machine or physical hardware so we can
06:51 - run several virtual machines on a real
06:53 - physical machine for example we can have
06:56 - a mac and on this mac we can run two
06:58 - virtual machines one running windows the
07:00 - other running linux how do we do that
07:03 - using a tool called hypervisor i know
07:05 - it's one of those computer science names
07:07 - in simple terms a hypervisor is software
07:10 - we use to create and manage virtual
07:12 - machines there are many hypervisors
07:14 - available out there like virtualbox and
07:16 - vmware which are cross-platform so they
07:19 - can run on windows mac os and linux and
07:22 - hyper-v which is only for windows so
07:24 - with a hypervisor we can manage virtual
07:26 - machines now what is the benefit of
07:28 - building virtual machines well for us
07:31 - software developers we can run an
07:33 - application in isolation inside a
07:35 - virtual machine so on the same physical
07:37 - machine we can have two different
07:39 - virtual machines each running a
07:41 - completely different application and
07:43 - each application has the exact
07:45 - dependencies it needs so application 1
07:48 - may use node version 14 and mongodb
07:50 - version 4 while application 2 may use
07:53 - node version 9 and mongodb version 3.
07:56 - all these are running on the same
07:58 - machine but in different isolated
08:00 - environments that's one of the benefits
08:02 - of virtual machines but there are a
08:03 - number of problems with this model each
08:06 - virtual machine needs a full copy of an
08:08 - operating system that needs to be
08:09 - licensed patched and monitored and
08:12 - that's why these virtual machines are
08:13 - slow to start because the entire
08:15 - operating system has to be loaded just
08:17 - like starting your computer
08:19 - another problem is that these virtual
08:21 - machines are resource intensive because
08:23 - each virtual machine takes a slice of
08:25 - the actual physical hardware resources
08:28 - like cpu memory and disk space so if you
08:31 - have 8 gigabytes of memory that memory
08:33 - has to be divided between different
08:35 - virtual machines of course we can decide
08:37 - how much memory to allocate to each
08:39 - virtual machine but at the end of the
08:41 - day we have a limit in terms of the
08:43 - number of vms we can run on a machine
08:45 - usually a handful otherwise we're going
08:47 - to run out of hardware resources now
08:49 - let's talk about containers containers
08:51 - give us the same kind of isolation so we
08:54 - can run multiple applications in
08:55 - isolation but they're more lightweight
08:58 - they don't need a full operating system
09:00 - in fact all containers on a single
09:02 - machine share the operating system of
09:04 - the host so that means we need to
09:06 - license patch and monitor a single
09:09 - operating system
09:10 - also because the operating system has
09:12 - already started on the host a container
09:15 - can start up pretty quickly usually in a
09:17 - second sometimes less and also these
09:20 - containers don't need a slice of the
09:22 - hardware resources on the host so we
09:24 - don't need to give them a specific
09:25 - number of cpu cores or a slice of memory
09:28 - or disk space so on a single host we can
09:31 - run tens or even hundreds of containers
09:34 - side by side so these are the
09:36 - differences between containers and
09:37 - virtual machines
09:41 - [Music]
09:45 - let's talk about the architecture of
09:46 - docker so you understand how it works
09:49 - docker uses a client server architecture
09:51 - so it has a client component that talks
09:53 - to a server component using a restful
09:56 - api
09:56 - the server also called the docker engine
09:59 - sits on the background and takes care of
10:01 - building and running docker containers
10:04 - but technically a container is just a
10:06 - process like other processes running on
10:08 - your computer but it's a special kind of
10:10 - process which we're going to talk about
10:12 - soon now as i told you unlike virtual
10:14 - machines containers don't contain a
10:17 - full-blown operating system instead all
10:20 - containers on a host share the operating
10:22 - system of the host now more accurately
10:25 - all these containers share the kernel of
10:27 - the host what's a kernel a kernel is the
10:30 - core of an operating system it's like
10:32 - the engine of a car it's the part that
10:34 - manages all applications as well as
10:36 - hardware resources like memory and cpu
10:39 - every operating system has its own
10:41 - kernel or engine and these kernels have
10:43 - different apis that's why we cannot run
10:46 - a windows application on linux because
10:48 - under the hood this application needs to
10:50 - talk to the kernel of the underlying
10:52 - operating system okay
10:54 - so that means on a linux machine we can
10:57 - only run linux containers because these
10:59 - containers need linux on a windows
11:02 - machine however we can run both windows
11:04 - and linux containers because windows 10
11:06 - is now shipped with a custom built linux
11:09 - kernel this is in addition to the
11:11 - windows kernel that's always been in
11:13 - windows it's not a replacement so with
11:15 - this linux kernel now we can run linux
11:17 - applications natively on windows so on
11:20 - windows we can run both linux and
11:22 - windows containers our windows
11:24 - containers share the windows kernel and
11:27 - our linux containers share the linux
11:29 - kernel okay
11:30 - now what about mac os well mac os has
11:33 - its own kernel which is different from
11:35 - linux and windows kernels and this
11:37 - kernel does not have native support for
11:40 - continuous applications so docker on mac
11:43 - uses a lightweight linux virtual machine
11:46 - to run linux containers all right enough
11:48 - about architecture next we're going to
11:50 - install docker and that's where the fun
11:52 - begins
11:55 - [Music]
11:59 - all right now let's install the latest
12:00 - version of docker if you have an
12:02 - existing version of docker on your
12:03 - machine i highly encourage you to
12:05 - upgrade to the latest version because
12:07 - your version might be old and not
12:09 - compatible with the version i'm using in
12:11 - this course so here i'm using docker
12:13 - version
12:16 - 20.10.5 okay
12:18 - so to get docker
12:20 - go to this page docs.docker.com
12:24 - get docker or you can just google get
12:26 - docker or install docker now on this
12:28 - page you can see instructions for
12:30 - downloading and installing docker
12:32 - desktop for mac and windows as well as
12:35 - docker engine for linux so on mac and
12:37 - windows we have docker desktop which is
12:40 - the combination of docker engine plus a
12:42 - bunch of other tools at the time of
12:44 - recording this we don't have docker
12:45 - desktop for linux we only have the
12:47 - docker engine but of course that might
12:49 - change in the future
12:50 - so a couple of notes for my mac and
12:53 - windows users let's go to this page
12:56 - so over here you can download the latest
12:58 - version from docker hub but before doing
13:01 - this i highly encourage you to go
13:03 - through a system requirement and make
13:05 - sure your computer satisfies these
13:07 - requirements otherwise you might
13:09 - encounter weird issues so the
13:11 - installation is pretty straightforward
13:13 - when you go to this page you're going to
13:15 - download a dmg file just drag and drop
13:17 - this onto the applications folder and
13:19 - then start it this is very important a
13:22 - lot of people miss that step so when you
13:24 - start docker engine
13:26 - by double clicking on this application
13:28 - you're going to see the docker icon on
13:30 - the top status bar
13:32 - if you don't see this docker engine is
13:34 - not running and there is nothing you can
13:35 - do so you have to wait for this to start
13:38 - the same applies to my windows users so
13:41 - back to this page
13:43 - let's look at the instructions for
13:44 - windows
13:46 - so once again you can download the
13:47 - latest version from docker hub but once
13:50 - again make sure to read system
13:52 - requirements one of the things that is
13:54 - really important is enabling hyper-v
13:57 - and containers windows features so i
13:59 - don't have a windows machine to show you
14:01 - here but just go to the page where you
14:03 - can turn on or turn off windows features
14:05 - there make sure you have enabled hyper-v
14:08 - and containers
14:09 - it's pretty straightforward but if you
14:11 - can't find it just google it i'm pretty
14:13 - sure there are tons of articles out
14:15 - there
14:15 - also at the end of the installation you
14:17 - might get an error saying ws2
14:19 - installation is incomplete basically
14:22 - what this error is saying is that you
14:24 - need to upgrade the linux kernel that is
14:26 - shipped with your windows so just click
14:28 - on this link
14:29 - this is going to take you to this page
14:30 - on microsoft.com where you can download
14:33 - the latest linux kernel so just click on
14:35 - this link to get an msi file run it and
14:38 - then you have to restart your computer
14:40 - now once your computer is restarted you
14:42 - need to wait a little while until docker
14:44 - engine started depending on your machine
14:47 - this might take several seconds or up to
14:48 - a minute
14:50 - so wait a little while then open up a
14:52 - terminal window and run docker
14:55 - version
14:56 - so over here
14:58 - you can see the version of the client
15:00 - and the server if the server which is
15:03 - docker engine is not running you are not
15:06 - going to see this information and this
15:07 - applies to all operating systems windows
15:10 - mac os and linux so make sure docker
15:13 - engine is running before going forward
15:15 - if you encounter any errors you can post
15:17 - your question on our forum at
15:19 - forum.codewithmosh.com
15:21 - or if you want a faster response just
15:23 - google the error message i'm pretty sure
15:25 - hundreds of people have encountered the
15:26 - same problem as you
15:30 - [Music]
15:34 - now let's talk about your development
15:35 - workflow when using docker so to start
15:38 - off we take an application it doesn't
15:40 - matter what kind of application it is or
15:42 - how it's built we take that application
15:44 - and dockerize it which means we make a
15:47 - small change so that it can be run by
15:49 - docker how we just add a docker file to
15:52 - it a docker file is a plain text file
15:54 - that includes instructions that docker
15:56 - uses to package up this application into
15:59 - an image this image contains everything
16:01 - our application needs to run everything
16:04 - typically a cut down operating system a
16:07 - runtime environment like node or python
16:09 - it also contains application files
16:11 - third-party libraries environment
16:13 - variables and so on so we create a
16:15 - docker file and give it to docker for
16:18 - packaging our application into an image
16:20 - once we have an image we tell docker to
16:22 - start a container using that image so a
16:25 - container as i told you is just a
16:27 - process but it's a special kind of
16:28 - process because it has its own file
16:31 - system which is provided by the image so
16:33 - our application gets loaded inside a
16:35 - container or a process and this is how
16:37 - we run our application locally on our
16:40 - development machine so instead of
16:41 - directly launching the application and
16:44 - running it inside a typical process we
16:46 - tell docker to run it inside a container
16:49 - an isolated environment now here's the
16:51 - beauty of docker once we have this image
16:54 - we can push it to a docker registry like
16:56 - docker hop docker hub to docker is like
16:58 - github to git it's a storage for docker
17:01 - images that anyone can use so once our
17:03 - application image is on docker hub then
17:05 - we can put it on any machines running
17:07 - docker this machine has the same image
17:09 - we have on our development machine which
17:11 - contains a specific version of our
17:13 - application with everything it needs so
17:16 - we can start our application the same
17:18 - way we started it on our development
17:19 - machine we just tell docker to start a
17:22 - container using this image so with
17:24 - docker we no longer need to maintain
17:26 - long complex release documents that have
17:29 - to be precisely followed all the
17:31 - instructions for building an image of an
17:33 - application are written in a docker file
17:35 - with that we can package up our
17:37 - application into an image and run it
17:39 - virtually anywhere this is the beauty of
17:41 - docker next we're going to see this
17:42 - workflow in action
17:46 - [Music]
17:50 - in this design i'm going to walk you
17:52 - through a typical development workflow
17:54 - now don't try to memorize anything in
17:55 - this lesson because i just want you to
17:57 - see the big picture so everything i show
17:59 - you in this lesson we're going to cover
18:01 - in depth later in the course so here in
18:03 - this terminal window i'm currently on my
18:05 - desktop i'm going to create a new
18:07 - directory called hello
18:09 - docker
18:10 - then go inside this directory and open
18:13 - it in visual studio code
18:16 - so i'm going to use vs code as my editor
18:18 - but you can use any editor that you
18:20 - prefer okay
18:21 - now in this directory i'm going to add a
18:23 - new file called
18:25 - app.js you're going to write one line of
18:28 - javascript code you don't have to be a
18:29 - javascript developer you don't even need
18:31 - to learn javascript so just follow along
18:34 - with me
18:34 - so here we're going to write console in
18:36 - lowercase dot log
18:39 - hello
18:41 - so with this we're going to print a
18:43 - message on the terminal let's say this
18:44 - is an application and we want to
18:46 - dockerize this application so we want to
18:48 - build run and ship it using docker so
18:51 - typically without docker if you want to
18:53 - ship this application or more accurately
18:56 - this program to a different computer on
18:58 - that computer we need to install node
19:00 - and then we can go to the terminal and
19:02 - type node app.js so we get the output so
19:06 - here are the instructions for deploying
19:08 - this program we need to start with an
19:10 - operating system then we need to install
19:12 - node which is an execution environment
19:14 - for javascript code
19:15 - next we need to copy our application
19:17 - files and finally we need to run node
19:20 - app.js so we have to follow four steps
19:23 - just for a simple program what if you
19:25 - were working with a really complex
19:26 - application you would end up with a
19:28 - complex release document that had to be
19:30 - precisely followed now this is where
19:33 - docker comes to the rescue we can write
19:35 - these instructions inside a docker file
19:38 - and let docker package up our
19:40 - application
19:41 - so back to vs code we're going to add
19:44 - another file to this project called
19:46 - docker file so capital d and all the
19:49 - other letters are lowercase and this
19:51 - file doesn't have any extensions
19:53 - okay
19:54 - now vs code is asking if you want to
19:56 - install the recommended extensions for
19:58 - docker we can go ahead with that
20:01 - good
20:03 - so back to this docker file here we
20:05 - write instructions for packaging our
20:06 - application so typically we start from a
20:09 - base image this base image has a bunch
20:12 - of files we're going to take those files
20:14 - and add additional files to it this is
20:16 - kind of like inheritance in programming
20:18 - okay so what is the base image well we
20:21 - can start from a linux image and then
20:24 - install node on top of it
20:26 - or we can start from a node image this
20:29 - image is already built on top of linux
20:31 - now how do i know these names well these
20:33 - images are officially published on
20:36 - docker hub
20:38 - so if you go to
20:39 - hub.docker.com and search for node you
20:41 - can see the official node image here so
20:44 - docker hub is a registry for docker
20:46 - images now back to our docker file so we
20:49 - start from a node image now if you look
20:51 - at docker hop you will see that there
20:53 - are multiple node images these node
20:56 - images are built on top of different
20:58 - distributions of linux so linux has
21:00 - different distributions or different
21:02 - flavors used for different purposes
21:05 - now here we can specify a tag using a
21:07 - column to specify which linux
21:09 - distribution we want to use for this
21:11 - demo i'm going to use alpine which is a
21:14 - very small linux distribution so the
21:16 - size of the image that we're going to
21:18 - download and build on top of is going to
21:20 - be very small okay
21:22 - so we start from that image then we need
21:24 - to copy our application or program files
21:27 - for that we use the copy instruction or
21:29 - copy command
21:30 - we're going to copy all the files in the
21:32 - current directory
21:34 - into the app directory into that image
21:37 - so that image has a file system and in
21:39 - that file system we're going to create a
21:41 - directory called app okay now finally
21:44 - we're going to use the command
21:46 - instruction to execute a command what
21:49 - command should we execute here
21:51 - node
21:52 - app.js but this file is inside the app
21:55 - directory so we have to prefix it with
21:58 - the directory name alternatively
22:01 - here we could set the current working
22:03 - directory work dir to slash app
22:07 - and then we don't need to prefix this
22:10 - with the directory name so when we use
22:12 - this instruction all the following
22:13 - instructions assume that we're currently
22:15 - inside the app directory okay
22:18 - so
22:19 - these instructions clearly document our
22:22 - deployment process
22:23 - now
22:24 - we go to the terminal and tell docker to
22:27 - package up our application so we say
22:29 - docker build we need to give our image a
22:32 - tag a tag to identify so
22:35 - t
22:36 - here we specify a name like hello docker
22:39 - and then we need to specify where docker
22:41 - can find a docker file so we're
22:44 - currently inside hello docker directory
22:46 - and our docker file is right here so we
22:49 - use a period to reference the current
22:51 - directory
22:52 - let's go with that
22:54 - now you might be expecting an image file
22:57 - inside the current directory but back in
22:59 - vs code look there is nothing here
23:01 - because the image is not stored here and
23:03 - in fact an image is not a single file
23:06 - how docker stores this image is very
23:08 - complex and we don't have to worry about
23:09 - it so back to the terminal to see all
23:12 - the images on this computer we type
23:14 - docker images or
23:17 - docker image ls which is short for list
23:20 - so take a look
23:22 - on this machine we have a repository
23:24 - called hello docker
23:26 - in this repository we have an image with
23:28 - this tag latest so docker added this by
23:31 - default we'll talk about this later in
23:33 - the course but basically we use these
23:35 - tags for versioning our images so each
23:37 - image can contain a different version of
23:40 - our application okay
23:41 - now each image also has a unique
23:44 - identifier
23:45 - here we can see when the image was
23:47 - created and the size of this image so
23:49 - because we used node from linux alpine
23:52 - we ended up with 112 megabytes of data
23:56 - in this image so this image contains
23:58 - alpine linux node and our application
24:01 - files and the total size is 112
24:04 - megabytes now if we used a different
24:06 - node image that was based on a different
24:08 - distribution of linux we would end up
24:10 - with a larger image and then when
24:12 - deploying that image we would have to
24:13 - transfer that image from one computer to
24:15 - another so that's why we use node alpine
24:18 - because this is a very small image okay
24:20 - so we have built this image now we can
24:22 - run this image on any computer running
24:24 - docker so on this machine which is my
24:26 - development machine i can say docker run
24:30 - and then type the image name hello
24:32 - docker and it doesn't matter which
24:34 - directory i'm in because this image
24:36 - contains all the files for running our
24:38 - application
24:39 - now look
24:41 - we see the message on the terminal now i
24:43 - can go ahead and publish this image to
24:45 - docker hub so anyone can use this image
24:47 - then i can go on another machine like a
24:49 - test or a production machine and pull
24:52 - and run this image in fact i've done
24:53 - this before recording this video
24:56 - so back to docker hub look i have this
24:58 - repository code with mosh slash hello
25:01 - docker now we can take this image and
25:03 - run it on any computers let me show you
25:05 - something really cool so
25:07 - let's search for play with docker
25:10 - let's go to this page
25:12 - and log in
25:16 - here we need to sign in with our docker
25:17 - id anyone can create this id on
25:19 - docker.com
25:20 - so let's go ahead
25:23 - and start a lab
25:26 - over here we can start a new virtual
25:28 - machine so let's add a new instance
25:32 - now this virtual machine is a black
25:34 - machine it only has an operating system
25:36 - which is linux and docker so in this
25:39 - terminal window
25:41 - if we type node
25:43 - look node command not found so node is
25:46 - not installed here but because we have
25:48 - docker we can pull and run the image
25:50 - that i published on docker hub so let me
25:53 - maximize this window by pressing alt and
25:56 - enter
25:57 - first let's run docker version
26:02 - so on this machine we're running docker
26:03 - version 20.10.0
26:07 - so to pull and run my program first we
26:10 - type docker pool
26:12 - code with mosh slash hello dash docker
26:18 - alright docker downloaded this image we
26:20 - can verify it by typing docker what
26:23 - command should be run here docker images
26:25 - or
26:26 - image ls
26:29 - so on this machine we have this
26:30 - repository code with mosh slash hello
26:33 - docker and this repository contains a
26:35 - single image with this tag latest so now
26:38 - we can run this application exactly the
26:40 - same way we run it on my development
26:42 - machine so from any directory we can
26:45 - type docker run
26:47 - code with mosh slash hello dash docker
26:53 - and here's the message beautiful of
26:55 - course i had to cut this down in editing
26:57 - it took a little while to start this
26:58 - application on this very slow virtual
27:00 - machine but you got the point
27:02 - so we can take any application and
27:05 - dockerize it by adding a docker file to
27:07 - it this docker file contains
27:09 - instructions for packaging an
27:11 - application into an image once we have
27:13 - an image we can run it virtually
27:14 - anywhere on any machine with docker
27:19 - hey guys mosh here if you're serious
27:20 - about learning docker i actually have a
27:22 - complete docker course on my coding
27:24 - school codewithmosh.com this tutorial
27:27 - you've been watching is a cut down
27:29 - version of the complete course in the
27:31 - full course you will learn how to run
27:33 - and deploy a full stack application with
27:35 - a front-end back-end and a database our
27:38 - application also includes automated
27:39 - tests so it's a great real-world
27:42 - scenario for learning docker just like
27:44 - my other courses you will also receive a
27:46 - 30-day money-back guarantee and a
27:47 - certificate of completion you can add
27:49 - your resume in case you're interested
27:51 - you can find the link down below in the
27:53 - description box
27:59 - all right the next step in our journey
28:00 - is the linux command line but why linux
28:03 - what if you're a windows user well you
28:05 - still need to know a bit of linux for a
28:06 - number of reasons for starters docker
28:09 - has its foundations built on top of
28:11 - basic linux concepts so if you want to
28:13 - be productive and troubleshoot issues
28:15 - easily you need to know some of the
28:17 - basic linux commands also most tutorials
28:20 - online are based on linux commands so if
28:22 - you don't understand these basic
28:24 - commands you're not going to get far in
28:26 - my opinion learning linux is like
28:28 - learning english i think everybody
28:30 - should know some english these days you
28:31 - don't need to speak it or write a book
28:33 - in it but you need to understand it so
28:35 - unless you're a power linux user do not
28:37 - skip this section it's gonna be super
28:39 - easy and extremely useful
28:41 - so let's jump in and get started
28:45 - [Music]
28:51 - let's start up this section by talking
28:53 - about linux distributions also called
28:56 - linux distros
28:57 - so as you probably know linux is open
29:00 - source software and for this reason many
29:02 - individuals and communities have created
29:04 - their own version of linux called linux
29:06 - distributions each of these
29:08 - distributions is made to fit specialized
29:10 - needs like running servers desktop
29:13 - computers mobile phones and so on so we
29:15 - have ubuntu which is one of the most
29:17 - popular linux distributions we also have
29:20 - debian alpine which we briefly talked
29:23 - about it's a very small linux
29:25 - distribution
29:26 - we also have fedora centos and so on
29:29 - believe it or not there are more than a
29:30 - thousand linux distributions out there
29:32 - now most of these distributions support
29:35 - pretty much the same set of commands but
29:37 - sometimes you might discover differences
29:38 - along the way so be aware of that in
29:41 - this section we're going to use ubuntu
29:43 - linux because it's one of the most
29:45 - popular distributions but if you have a
29:47 - preference for another distribution
29:48 - that's totally fine
29:52 - [Music]
29:56 - all right let's see how we can run
29:57 - ubuntu on this machine from this lesson
30:00 - i want you to start taking notes so
30:02 - watch this video take some notes and
30:04 - then after the video repeat the steps i
30:06 - have shown you okay
30:07 - so we go to hub.docker.com
30:10 - and search for ubuntu
30:12 - over here you can see the official
30:14 - ubuntu image that's been downloaded more
30:16 - than 10 million times let's have a quick
30:18 - look here
30:20 - so for each image you can see the
30:21 - command to pull that image onto your
30:24 - machine now in this lesson i'm not going
30:26 - to use the pull command i'm going to
30:27 - show you a shortcut
30:29 - so here in the terminal instead of
30:31 - running docker pool ubuntu
30:34 - i'm going to run docker
30:36 - run ubuntu now if we have this image
30:39 - locally docker is going to start a
30:41 - container with this image otherwise it's
30:43 - going to pull this image behind the
30:45 - scene and then start a container so take
30:47 - a look
30:48 - see
30:49 - docker is unable to find this image
30:51 - locally and now it's pulling it from
30:53 - docker hub
30:55 - now what happened well docker started a
30:57 - container but because we didn't interact
30:59 - with this container the container
31:01 - stopped let me prove this to you so if
31:04 - you run docker ps we can see the list of
31:07 - running processes or running containers
31:10 - look we don't have any containers
31:12 - running here but if we type docker ps
31:15 - dash a for all
31:17 - we can see the stopped containers as
31:19 - well let me increase the size of this
31:21 - window so you can see it clearly good
31:24 - so we have two stopped containers the
31:26 - first one
31:27 - is using the ubuntu image this is the
31:29 - one that we just started and the second
31:31 - one is hello docker which we started
31:34 - earlier in the course so to start a
31:36 - container and interact with it we have
31:38 - to type docker run dash i t that is
31:42 - short for interactive we're going to
31:44 - start a container in the interactive
31:45 - mode
31:46 - and in this container we're going to
31:47 - load the ubuntu image which we have
31:50 - locally
31:52 - good now what we have here is called the
31:54 - shell a shell is a program that takes
31:56 - our commands and passes them to the
31:58 - operating system for execution okay now
32:00 - what we have here is called the shell
32:03 - prompt let me break it down for you so
32:05 - it doesn't look mysterious the first
32:07 - part root
32:08 - represents the currently logged in user
32:10 - so by default i'm logged in as the root
32:12 - user which has the highest privileges
32:15 - then after the add sign we have the name
32:17 - of the machine
32:18 - so this container has this id which is
32:21 - automatically generated by docker and in
32:24 - this case it's like the name of a
32:25 - machine okay and after the colon
32:28 - you can see forward slash that
32:30 - represents where we are in the file
32:32 - system a forward slash represents the
32:35 - root directory that is the highest
32:37 - directory in the file system we'll talk
32:39 - about that soon then we have a pound
32:41 - and this means i have the highest
32:43 - privileges because i've logged in as the
32:45 - root user if i logged in as a normal
32:47 - user instead of a pound we would see a
32:50 - dollar sign okay
32:51 - so in this shell we can execute a bunch
32:54 - of commands for example we can say echo
32:56 - hello
32:57 - and this prints hello on the terminal we
32:59 - can also say who am i
33:02 - this shows the current user
33:04 - so these commands that we're running
33:05 - here this shell program that i told you
33:07 - about takes these commands and passes
33:09 - them to the kernel for execution now let
33:11 - me show you something really cool if we
33:13 - type echo dollar sign 0 we can see the
33:17 - location of this shell program take a
33:19 - look
33:20 - so
33:21 - that is forward slash bin slash bash so
33:24 - bin is a folder or a directory and
33:27 - inside this directory we have a program
33:29 - called bash which is short for born
33:32 - again shell so apparently steve bourne
33:34 - is the first person who created a shell
33:36 - program bash or born again shell is a
33:39 - reference to steve bourne so bash is an
33:42 - enhanced version of the original shell
33:44 - program okay
33:45 - now one thing you probably notice is
33:47 - that in linux we use a forward slash to
33:49 - separate files and directories but in
33:52 - windows we use a backslash so that's one
33:54 - of the first differences
33:56 - the other difference is that linux is a
33:58 - case sensitive operating system so if
34:00 - you type echo with a capital e
34:03 - it's not going to work bash tells us
34:05 - echo command not found so lowercase and
34:08 - uppercase letters are different and this
34:10 - is not limited to commands it's
34:12 - applicable everywhere if you want to
34:13 - reference a file or a directory or a
34:15 - user pretty much anything we should
34:17 - always spell it properly with the right
34:20 - uppercase and lowercase letters now one
34:22 - last thing for this lesson using the up
34:25 - and down arrows
34:27 - we can go through the commands we have
34:28 - executed so far so this is a pretty
34:30 - useful shortcut you need to know because
34:32 - you don't want to type these commands
34:33 - manually all the time okay
34:35 - also using the history command we can
34:37 - see all the commands we have executed
34:39 - lately so take a look so earlier we used
34:42 - who am i we also used echo and so on
34:45 - now we can replay any of this command by
34:47 - typing an exclamation mark followed by
34:49 - the command number so if i type 2
34:52 - this is exactly like running who am i
34:55 - now it's your turn i want you to pause
34:57 - the video go through your note and
34:59 - execute the commands i have shown you in
35:00 - this video
35:04 - [Music]
35:08 - these days most operating systems and
35:10 - development platforms come with a
35:12 - package manager you've probably worked
35:14 - with tools like npm yarn pip and so on
35:18 - here in ubuntu we also have a package
35:20 - manager called apt which is short for
35:22 - advanced package tool so let's execute
35:25 - this command
35:26 - look
35:27 - this command has a bunch of sub-commands
35:30 - so using list we can see the list of
35:32 - packages we can also search for them we
35:34 - can show details about the package we
35:36 - can install reinstall and remove a
35:38 - package and so on
35:40 - now technically apt is the newer package
35:42 - manager we also have apt-get which you
35:45 - see a lot in online tutorials going
35:48 - forward we're going to use apt because
35:49 - it's easier to work with
35:51 - so let's say we want to install a
35:53 - package called nano nano is a basic text
35:56 - editor for linux now if you press enter
35:58 - here we get an error because this image
36:01 - this ubuntu image we are running does
36:03 - not have nano so this is where we use
36:05 - apt to install this package
36:07 - so if we type apt install nano
36:11 - we get an error saying unable to locate
36:13 - package nano why is this happening well
36:16 - here in linux we have a package database
36:18 - and this database might contain hundreds
36:20 - of packages but not all these packages
36:23 - are installed so if you want to see all
36:25 - the packages in this database we type
36:27 - apt list
36:30 - look these are all the packages now in
36:32 - front of these packages you can see some
36:34 - of them are installed but not all
36:36 - packages in this database are installed
36:38 - when we type app install nano
36:41 - this command looks at the package
36:43 - database and in this database it cannot
36:45 - find a package called nano so this is
36:48 - where
36:49 - we use the update command to update the
36:51 - package database
36:52 - now let me press enter
36:55 - then x is going to all these sources
36:57 - like
36:58 - security.ubuntu.com and all these other
37:00 - websites to download the list of
37:02 - packages
37:03 - so now our package database is updated
37:05 - so if we run apt list
37:09 - we see far more packages and as you can
37:12 - see most of these packages are not
37:14 - installed because we don't have
37:15 - installed in front of them so now we can
37:17 - run apt install nano
37:21 - and
37:22 - nano is installed
37:24 - so here's what you need to take away
37:26 - before installing a package you should
37:28 - always run apt update to update your
37:30 - package database and then
37:33 - you can install a package like nano now
37:36 - we'll talk about nano later in this
37:37 - section but before going forward let's
37:40 - make sure that this package is installed
37:42 - properly so if you type nano great so
37:45 - here we have a text editor we can type
37:46 - something let me resize the window
37:50 - so down below you can see the shortcuts
37:52 - to exit we have to press ctrl and x
37:56 - now it's asking if you want to save the
37:58 - changes no so we're going to press n
38:01 - good we're back here we can clear the
38:03 - terminal window by pressing control and
38:06 - l okay
38:07 - so we have installed nano now let's say
38:09 - we want to remove it so we type apt
38:12 - remove nano
38:15 - it's asking for confirmation let's go
38:17 - ahead
38:18 - great so nano is gone if i type nano
38:22 - we get this error saying no such file or
38:24 - directory
38:25 - now here's a little exercise for you in
38:27 - this image we don't have python so we
38:30 - get an arrow so i want you to use apt to
38:32 - install python in this image make sure
38:34 - it works and then remove it
38:38 - [Music]
38:43 - so in linux just like windows our files
38:45 - and directories are organized in a tree
38:48 - in a hierarchical structure so in
38:50 - windows we have a structure like this
38:52 - with c drive on top of the hierarchy
38:54 - then below that we have directories like
38:56 - program files windows and so on
38:59 - in linux we have the root directory on
39:01 - top of the hierarchy below that we have
39:03 - a bunch of standard directories for
39:05 - example we have bin which includes
39:07 - binaries or programs we have boot which
39:10 - includes all the files related to
39:12 - booting then we have dev the first time
39:14 - i saw this i thought this is short for
39:16 - development it's not it's short for
39:18 - devices so in linux everything is a file
39:22 - including devices directories network
39:24 - sockets pipes and so on so the files
39:27 - that are needed to access devices are
39:29 - stored in this directory then we have
39:31 - etsy there are different opinions what
39:33 - is this short for but one common opinion
39:36 - is this is short for editable text
39:38 - configuration so this is where we have
39:40 - configuration files we also have home
39:42 - this is where home directories for users
39:44 - are stored so on a machine with multiple
39:47 - users each user is going to have a home
39:49 - directory here we also have root which
39:51 - is the home directory of the root user
39:54 - only the root user can access this
39:55 - directory then we have lib which is used
39:58 - for keeping library files like software
40:00 - library dependencies we have var which
40:02 - is short for variable and this is where
40:04 - we have files that are updated
40:06 - frequently like log files application
40:08 - data and so on and finally we have proc
40:11 - which includes files that represent
40:13 - running processes so once again in linux
40:16 - everything is a file processes devices
40:19 - even directories are files now you don't
40:21 - need to memorize any of these
40:22 - directories i just listed them here so
40:25 - as we go through the course these
40:26 - directories look familiar to you that's
40:28 - all next i'm going to show you how to
40:30 - navigate the file system and there you
40:33 - will see these directories one more time
40:37 - [Music]
40:41 - let's see how we can navigate the linux
40:42 - file system so the first command we're
40:44 - going to talk about is pwd which is
40:47 - short for print working directory
40:50 - with this we can see where we are in the
40:51 - file system so a forward slash
40:54 - represents the root directory now to see
40:57 - the files and directories here we type
40:59 - ls which is short for list
41:01 - so we have bin which we talked about
41:02 - earlier that is short for binaries this
41:04 - is where we have binary files and
41:06 - programs we have dev which includes
41:08 - files for devices
41:10 - we have boot which includes boot files
41:12 - etsy which includes configuration files
41:14 - and so on now by default ls lists these
41:18 - items on multiple lines if you don't
41:20 - like this layout and want to show one
41:22 - item per line you need to pass an option
41:25 - that is dash one
41:27 - you might prefer this layout we have
41:29 - another option
41:31 - dash l for seeing a long listing
41:34 - this listing includes more details
41:36 - so in the first column
41:38 - we have the permissions of this file or
41:40 - directory the first time you see this it
41:42 - might look really scary but trust me
41:44 - it's easier than you think we'll talk
41:46 - about that later in this section
41:48 - over here you can see the user that owns
41:50 - this file or directory we can see the
41:53 - size we can see the date and so on now
41:56 - to change the current directory
41:58 - we use the cd command we have the same
41:59 - command in windows now here we can type
42:02 - a relative or an absolute path a
42:04 - relative path is relative to where we
42:06 - are so in this root directory we have
42:09 - directories like bin boot and so on so
42:11 - this is a relative path now in contrast
42:14 - an absolute path always starts from the
42:16 - root directory so let's go to a
42:18 - directory starting with e
42:20 - now we can press tab to get auto
42:22 - completion beautiful now let's go to a
42:24 - directory starting with a now if you
42:27 - press tab nothing happens because we
42:29 - have multiple directories starting with
42:31 - a so we have to press tab one more time
42:34 - great so we have three entries three
42:36 - directories add user.conf alternatives
42:40 - and apt
42:41 - so let's type the second letter p and
42:44 - then press tab
42:46 - beautiful now let's see what we have in
42:48 - this directory
42:49 - so these blue items are directories and
42:52 - sources.less is a file
42:54 - now to get out of this directory
42:56 - we can go one level up by typing two
42:59 - periods
43:00 - again i'm pretty sure you're familiar
43:01 - with this but i want to cover it to make
43:03 - this section comprehensive so we can go
43:05 - one level up to get to the etsy
43:07 - directory
43:08 - or two levels up to get to the root
43:11 - directory look we're currently in the
43:14 - root directory
43:15 - now when using ls we can optionally
43:18 - specify a path let's say i'm somewhere
43:20 - in the file system but i want to look at
43:22 - the content of another directory i don't
43:24 - want to navigate to that directory so
43:26 - i'm currently in the root directory i
43:28 - want to know what files and directories
43:30 - we have inside the bin directory so once
43:32 - again we can type a relative path or
43:35 - an absolute path starting from the root
43:37 - directory
43:38 - so here are the binaries in this
43:40 - directory look at pwd
43:42 - that's the command that we just executed
43:45 - so pwd is a program in this directory
43:48 - here's another example
43:50 - look at
43:51 - echo
43:52 - so most of the commands we have been
43:53 - exploring so far are programs or
43:56 - binaries in the bin directory okay
43:59 - now let me show you a shortcut earlier i
44:01 - told you that here we have
44:03 - this home directory where each user has
44:06 - a home directory but the root user
44:09 - has a special home directory called root
44:12 - now to get here there are two options we
44:14 - can type an absolute or relative path
44:17 - and go to root but there is a shortcut
44:19 - so let me get out of this directory
44:22 - so i'm currently
44:23 - in the root directory
44:25 - to get to my home directory
44:27 - i can type a tilde and this applies to
44:30 - all users not just the root user
44:32 - whenever we type cd tilde we go to our
44:35 - home directory now
44:37 - right now there is nothing here but in
44:39 - the next lesson i will show you how to
44:40 - create some files in this directory
44:42 - so before moving on to the next lesson i
44:45 - want you to spend a couple of minutes
44:46 - and play with the commands we explored
44:48 - in this lesson navigate the file system
44:50 - get adventurous see what you can
44:52 - discover i'll see you in the next lesson
44:56 - [Music]
45:00 - let's see how we can manipulate files
45:02 - and directories so i'm currently in the
45:04 - root directory and i want to go to my
45:06 - home directory how can i do that do you
45:09 - remember we type cd tilde great now
45:14 - in this directory i want to create a
45:16 - directory called test so we type mkdir
45:19 - test
45:20 - let's verify it's right here as i told
45:23 - you before blue represents a directory
45:26 - now let's say we want to rename this
45:27 - directory how do we do that
45:30 - we use the move command with this we can
45:32 - rename files and folders or move them
45:34 - somewhere else so we can move or rename
45:37 - test to docker
45:41 - all right beautiful now let's go in this
45:43 - directory
45:46 - to create a new file
45:47 - we use the touch command so we can
45:49 - create hello.txt
45:52 - look we have this new file here this is
45:55 - a new empty file in the next lesson i
45:57 - will show you how to edit files so for
45:59 - now don't worry about it also
46:01 - using the touch command we can create
46:03 - multiple files in one go so we can
46:05 - create file 1 file 2 and file 3.
46:10 - now take a look beautiful now i've got a
46:13 - question for you how do we list these
46:15 - files with a single file per line do you
46:17 - remember we type ls dash 1.
46:21 - now let's say we want to rename
46:23 - hello.txt to something else once again
46:26 - we can use the move command so we type h
46:28 - press tab to get auto completion we can
46:31 - rename this to hello
46:33 - docker.txt
46:34 - or
46:35 - we can move it to a different directory
46:37 - for example we can move it to the etsy
46:39 - directory and here i'm using an absolute
46:42 - path because my path has started from
46:44 - the root directory
46:45 - now in this lesson i don't want to move
46:47 - this anywhere so i just want to rename
46:49 - this to
46:50 - hello
46:51 - docker.txt and if you're wondering how i
46:54 - remove this entire word in one go i
46:57 - press ctrl and w
46:59 - so let's bring it back hello docker.txt
47:03 - take a look good
47:05 - now let's see how we can remove one or
47:06 - more files to do that
47:08 - use the rm command like here we can type
47:11 - one or more files so we can say
47:13 - file1.txt file2.txt or we can use a
47:16 - pattern for example i can say
47:19 - i want to remove all files that start
47:23 - with file let's verify it
47:26 - beautiful we only have hello docker now
47:29 - let's get out of this directory and
47:31 - remove the directory itself so we type
47:34 - rm
47:35 - docker
47:37 - now we get an error saying docker is a
47:39 - directory so to remove directories we
47:42 - have to use the r option which is short
47:44 - for recursive so we want to remove this
47:46 - directory and all its content
47:48 - recursively
47:50 - now we press d tab beautiful so let's
47:53 - verify there is nothing here
47:56 - so let's quickly recap
47:57 - we use mkdir to create a new directory
48:00 - we use touch to create a new file
48:03 - we use move to move or rename files or
48:06 - directories and we use rm to remove
48:09 - files and directories
48:10 - now as an exercise go to your home
48:12 - directory create a bunch of files and
48:14 - directories rename them and then remove
48:16 - them
48:17 - in the next lesson i'm going to show you
48:19 - how to view and edit files
48:23 - [Music]
48:27 - all right let's see how we can edit and
48:29 - view files
48:30 - so earlier we briefly talked about nano
48:33 - now it's a basic text editor for linux
48:35 - now on this image that we are running
48:38 - we don't have nano so we have to install
48:40 - it do you remember the command for
48:41 - installing nano
48:43 - that is apt install nano
48:47 - all right now we have nano so we can
48:50 - launch it
48:51 - and optionally supply a file name let's
48:53 - say file1.txt
48:55 - so here we have a basic text editor we
48:57 - can type
48:59 - whatever we want
49:00 - and when we're done look down below the
49:03 - shortcut for exiting is control and x so
49:05 - i'm going to press that
49:07 - now it's asking if you want to save the
49:09 - changes so we press yes
49:11 - and here we confirm the file name we can
49:13 - keep the same file or change the file
49:15 - name let's go ahead
49:17 - so now in this directory we have file on
49:20 - the txt beautiful now to see the content
49:22 - of this file we have a few different
49:24 - commands
49:25 - the simplest one is cat and this has
49:27 - nothing to do with cats it's short for
49:29 - concatenate
49:30 - so later i will show you how we can use
49:32 - this command to concatenate or combine
49:34 - multiple files but with cat we can also
49:37 - see the content of a file so if we say
49:39 - cat file1.txt
49:42 - we can see the content of this file now
49:44 - cat is useful if our file is short and
49:47 - fits on one page but if you're dealing
49:49 - with a long file it's better to use the
49:52 - more command let me give you an example
49:54 - so
49:55 - i'm going to use cat to show the content
49:57 - of this file slash etsy slash
50:00 - add user.conf
50:03 - this is a really long file so if i
50:05 - scroll up look
50:06 - we have a lot of text
50:08 - now sometimes you don't want to see all
50:10 - the content in one go you want to scroll
50:12 - down you want to go page by page this is
50:14 - where
50:15 - we use the more command so more
50:18 - etsy slash adduser.conf
50:21 - now down below look
50:23 - you can see more 15 percent so we're
50:26 - seeing 15 percent of this file now if we
50:28 - press space we can go to the next page
50:31 - so now we're at the position 33
50:34 - alternatively we can press enter
50:36 - to go one line at a time now the problem
50:39 - with more is that we can only scroll
50:41 - down we cannot scroll up so to do that
50:44 - we have to use a different command
50:45 - called less
50:47 - so to exit here we press q
50:49 - good
50:50 - now in this image we don't have less so
50:53 - once again we have to manually install
50:55 - it so apt install less so less is a
50:58 - newer command that is supposed to
51:00 - replace more
51:02 - let's go ahead
51:04 - great so let's look at the same file
51:07 - using the less command
51:09 - hcl slash adduser.com
51:12 - so now using the up and down arrows
51:15 - we can scroll down or up
51:18 - so just by pressing up and down arrows
51:21 - we also have space we can go to the next
51:23 - page
51:24 - and enter just like the more command and
51:27 - when we are done we can press q
51:30 - now we have a couple more commands for
51:31 - viewing the content of a file we have
51:33 - head which we can use to display the
51:36 - first few lines so here we can supply an
51:38 - option
51:39 - and say the number of lines we want to
51:41 - see is 5.
51:42 - let's look at the same file
51:44 - so this shows the first five lines of
51:47 - this file
51:49 - similarly we have tail which shows the
51:51 - last few lines so let's apply an option
51:54 - and say we want to look at the last
51:56 - five files
51:58 - that's it
51:59 - so to recap we can use nano to write
52:02 - something to a file we can use cat to
52:04 - view the content of small files
52:07 - less to view the content of long files
52:09 - in an interactive way and head and tail
52:13 - to view the first view or the last few
52:14 - lines of a file
52:18 - [Music]
52:22 - one of the important concepts in linux
52:24 - is the concept of standard input and
52:26 - output so standard input represents the
52:28 - keyboard and standard output represents
52:31 - the screen but we can always change the
52:33 - source of the input or the output this
52:35 - is called redirection let me show you
52:37 - using a few examples so we talked about
52:40 - the cat command to see the content of a
52:42 - file let's say file1.txt
52:45 - when we execute this command this
52:47 - command or this program reads data from
52:49 - this file
52:50 - and prints it on the standard output
52:52 - which is the screen that is why we see
52:55 - the content here but using the
52:57 - redirection operator
52:59 - which is the greater than sign we can
53:01 - redirect the output from the screen to
53:03 - let's say
53:05 - a different file
53:06 - so now cat will read the content from
53:08 - this file and write it to this file
53:10 - take a look
53:12 - so we have file to.txt
53:15 - if we view it
53:17 - we see the exact same content as file
53:19 - one okay now what is the point of this
53:22 - well earlier i told you that we can use
53:24 - the cat command to concatenate or
53:26 - combine multiple files
53:28 - so here we can say cat file1.txt
53:32 - and file2.txt
53:33 - if you press enter cat is going to read
53:35 - the data from both these files and print
53:38 - it on the terminal which is the standard
53:40 - output but once again
53:42 - using the redirection operator we can
53:44 - write the result to a different file
53:46 - combined the txt so this is how we can
53:49 - use this command to combine multiple
53:51 - files now the redirectional operator is
53:53 - not limited to the cad command we can
53:55 - use it pretty much anywhere for example
53:58 - earlier we talked about the echo command
54:01 - if we say echo hello
54:02 - we see the result on the terminal but if
54:05 - we say echo
54:06 - hello to
54:08 - hello.txt now we have a new file here
54:11 - hello.txt which contains
54:14 - hello so if you want to write a single
54:17 - line to a file we don't have to use nano
54:19 - we can use the echo command so echo
54:22 - whatever to whatever file the txt okay
54:26 - now here's a little exercise for you i
54:28 - want you to get a long listing of the
54:30 - files in the etsy directory and write
54:32 - the output to a file
54:34 - so pause the video and work on this for
54:36 - a few seconds
54:40 - so here's the solution
54:42 - to get a long listing we type ls-l
54:46 - then we specify the path
54:48 - the exit directory
54:49 - now instead of printing the result on
54:51 - the terminal we're going to write it to
54:52 - a file called
54:54 - files.txt
54:56 - okay
54:56 - now let's view this file
54:59 - perfect
55:00 - now one more thing before we finish this
55:02 - lesson using the greater than sign we
55:04 - can redirect the standard output but we
55:07 - also have the less than sign to redirect
55:09 - the standard input i personally haven't
55:11 - found many use cases for this so i
55:13 - didn't cover it in this lesson all right
55:15 - that's all about redirection next we're
55:17 - going to talk about searching for text
55:19 - and files
55:22 - hey guys mosh here if you're serious
55:24 - about learning docker i actually have a
55:26 - complete docker course on my coding
55:28 - school codewithmosh.com this tutorial
55:31 - you've been watching is a cut down
55:32 - version of the complete course in the
55:34 - full course you will learn how to run
55:36 - and deploy a full stack application with
55:38 - a front-end back-end and a database our
55:41 - application also includes automated
55:43 - tests so it's a great real-world
55:45 - scenario for learning docker just like
55:47 - my other courses you will also receive a
55:49 - 30 day money back guarantee and a
55:51 - certificate of completion you can add
55:52 - your resume in case you are interested
55:54 - you can find the link down below in the
55:56 - description box
55:59 - [Music]

Cleaned transcript:

welcome to the ultimate docker course in this course i'm going to take you on a journey and teach you everything you need to know about docker from the basics to more advanced concepts so by the end of this course you'll be able to use it like a pro as part of your software development workflow if you're looking for a comprehensive and highly practical course that takes you from zero to hero this is the docker course for you we're gonna start off with a really simple project so you understand the basics then we'll use docker to run and deploy a full stack application with a front end back end and a database so you learn all the necessary techniques and apply them to your own projects i'm ash hamadani and i've taught millions of people how to advance their software engineering skills through my youtube channel and online onlineschoolcodewithmash.com if you're new here be sure to subscribe as we upload new videos all the time now let's jump in and get started let's quickly talk about what you need to know to take this course to take this course you don't need any prior knowledge of docker because i'm going to teach you everything from scratch but you should have at least three months of programming experience ideally you should have built at least one application so you should know concepts like frontend backend api and database it doesn't matter what languages and frameworks or what database engines you're familiar with but you should know what these concepts are all about also you should be familiar with basic git commands like cloning a github repository committing code pushing and pulling just the basics nothing more with all that let's move on to the next lesson now we all have different ways of learning things but let me tell you what i think is the best way to take this course this course is highly practical so you should be active while watching this course in my opinion it's best if you watch each lesson take some notes you can either take notes on a piece of paper or using your favorite notetaking tool just write some keywords some keywords that help you remember what we talked about then after each lesson go through your notes and repeat the same steps i have taken in that lesson so if i talked about a bunch of commands play with those commands make sure you understand how they work if you follow that i promise you by the end of this course you're gonna master docker and use it like a pro alright our journey to master docker begins here in every section you're going to discover something new about docker in this section we're going to talk about what docker is and why it's so popular then we're going to talk about virtual machines and containers next we're going to talk about the architecture of docker so you understand how it works then we're going to install docker and get our hands dirty i'm going to give you an overview of your development workflow with docker and then we're going to see that in action using a really simple example so by the end of this section you will have an idea what docker is all about i'm so excited about this section i hope you are too so let's jump in and get started so what is docker and why is everyone using it these days well docker is a platform for building running and shipping applications in a consistent manner so if your application works on your development machine it can run and function the same way on other machines if you have been developing software for a while you've probably come across this situation where your application works on your development machine but doesn't somewhere else can you think of three reasons why this happens well this can happen if one or more files are not included as part of your deployment so your application is not completely deployed it's missing something this can also happen if the target machine is running a different version of some software that your application needs let's say your application needs node version 14 but the target machine is running node version 9. this can also happen if the configuration settings like environment variables are different across these machines and this is where docker comes to the rescue with docker we can easily package up our application with everything it needs and run it anywhere on any machine with docker so if your application needs a given version of node and mongodb all of these will be included in your applications package now you can take this package and run it on any machine that runs docker so if it works on your development machine it's definitely going to work on your test and production machines now there's more if someone joins your team they don't have to spend half a day or so setting up a new machine to run your application they don't have to install and configure all these dependencies they simply tell docker to bring up your application and docker itself will automatically download and run these dependencies inside an isolated environment called a container and this is the beauty of docker this isolated environment allows multiple applications use different versions of some software side by side so one application may use node version 14 another application may use node version 9. both these applications can run side by side on the same machine without messing with each other so this is how docker allows us to consistently run an application on different machines now there is one more benefit here when we're done with this application and don't want to work on it anymore we can remove the application and all its dependencies in one go without docker as we work on different projects our development machine gets cluttered with so many libraries and tools that are used by different applications and then after a while we don't know if we can remove one or more of these tools because we're always afraid that we would mess up with some application with docker we don't have to worry about this because each application runs with its dependencies inside an isolated environment we can safely remove an application with all its dependencies to clean up our machine isn't that great so in a nutshell docker helps us consistently build run and ship our applications and that's why a lot of employers are looking for people with darker skills these days so if you're pursuing a job as a software or devops engineer i highly encourage you to learn docker and learn it well and that's exactly what this course is all about i'm going to take you on a journey and teach you everything you need to know about docker so you can use it like a pro no copy pasting commands here so in the last lesson i briefly talked about containers a container is an isolated environment for running an application now one of the questions that often comes up is how are containers different from virtual machines or vms do you know the differences well a virtual machine as the name implies is an abstraction of a machine or physical hardware so we can run several virtual machines on a real physical machine for example we can have a mac and on this mac we can run two virtual machines one running windows the other running linux how do we do that using a tool called hypervisor i know it's one of those computer science names in simple terms a hypervisor is software we use to create and manage virtual machines there are many hypervisors available out there like virtualbox and vmware which are crossplatform so they can run on windows mac os and linux and hyperv which is only for windows so with a hypervisor we can manage virtual machines now what is the benefit of building virtual machines well for us software developers we can run an application in isolation inside a virtual machine so on the same physical machine we can have two different virtual machines each running a completely different application and each application has the exact dependencies it needs so application 1 may use node version 14 and mongodb version 4 while application 2 may use node version 9 and mongodb version 3. all these are running on the same machine but in different isolated environments that's one of the benefits of virtual machines but there are a number of problems with this model each virtual machine needs a full copy of an operating system that needs to be licensed patched and monitored and that's why these virtual machines are slow to start because the entire operating system has to be loaded just like starting your computer another problem is that these virtual machines are resource intensive because each virtual machine takes a slice of the actual physical hardware resources like cpu memory and disk space so if you have 8 gigabytes of memory that memory has to be divided between different virtual machines of course we can decide how much memory to allocate to each virtual machine but at the end of the day we have a limit in terms of the number of vms we can run on a machine usually a handful otherwise we're going to run out of hardware resources now let's talk about containers containers give us the same kind of isolation so we can run multiple applications in isolation but they're more lightweight they don't need a full operating system in fact all containers on a single machine share the operating system of the host so that means we need to license patch and monitor a single operating system also because the operating system has already started on the host a container can start up pretty quickly usually in a second sometimes less and also these containers don't need a slice of the hardware resources on the host so we don't need to give them a specific number of cpu cores or a slice of memory or disk space so on a single host we can run tens or even hundreds of containers side by side so these are the differences between containers and virtual machines let's talk about the architecture of docker so you understand how it works docker uses a client server architecture so it has a client component that talks to a server component using a restful api the server also called the docker engine sits on the background and takes care of building and running docker containers but technically a container is just a process like other processes running on your computer but it's a special kind of process which we're going to talk about soon now as i told you unlike virtual machines containers don't contain a fullblown operating system instead all containers on a host share the operating system of the host now more accurately all these containers share the kernel of the host what's a kernel a kernel is the core of an operating system it's like the engine of a car it's the part that manages all applications as well as hardware resources like memory and cpu every operating system has its own kernel or engine and these kernels have different apis that's why we cannot run a windows application on linux because under the hood this application needs to talk to the kernel of the underlying operating system okay so that means on a linux machine we can only run linux containers because these containers need linux on a windows machine however we can run both windows and linux containers because windows 10 is now shipped with a custom built linux kernel this is in addition to the windows kernel that's always been in windows it's not a replacement so with this linux kernel now we can run linux applications natively on windows so on windows we can run both linux and windows containers our windows containers share the windows kernel and our linux containers share the linux kernel okay now what about mac os well mac os has its own kernel which is different from linux and windows kernels and this kernel does not have native support for continuous applications so docker on mac uses a lightweight linux virtual machine to run linux containers all right enough about architecture next we're going to install docker and that's where the fun begins all right now let's install the latest version of docker if you have an existing version of docker on your machine i highly encourage you to upgrade to the latest version because your version might be old and not compatible with the version i'm using in this course so here i'm using docker version 20.10.5 okay so to get docker go to this page docs.docker.com get docker or you can just google get docker or install docker now on this page you can see instructions for downloading and installing docker desktop for mac and windows as well as docker engine for linux so on mac and windows we have docker desktop which is the combination of docker engine plus a bunch of other tools at the time of recording this we don't have docker desktop for linux we only have the docker engine but of course that might change in the future so a couple of notes for my mac and windows users let's go to this page so over here you can download the latest version from docker hub but before doing this i highly encourage you to go through a system requirement and make sure your computer satisfies these requirements otherwise you might encounter weird issues so the installation is pretty straightforward when you go to this page you're going to download a dmg file just drag and drop this onto the applications folder and then start it this is very important a lot of people miss that step so when you start docker engine by double clicking on this application you're going to see the docker icon on the top status bar if you don't see this docker engine is not running and there is nothing you can do so you have to wait for this to start the same applies to my windows users so back to this page let's look at the instructions for windows so once again you can download the latest version from docker hub but once again make sure to read system requirements one of the things that is really important is enabling hyperv and containers windows features so i don't have a windows machine to show you here but just go to the page where you can turn on or turn off windows features there make sure you have enabled hyperv and containers it's pretty straightforward but if you can't find it just google it i'm pretty sure there are tons of articles out there also at the end of the installation you might get an error saying ws2 installation is incomplete basically what this error is saying is that you need to upgrade the linux kernel that is shipped with your windows so just click on this link this is going to take you to this page on microsoft.com where you can download the latest linux kernel so just click on this link to get an msi file run it and then you have to restart your computer now once your computer is restarted you need to wait a little while until docker engine started depending on your machine this might take several seconds or up to a minute so wait a little while then open up a terminal window and run docker version so over here you can see the version of the client and the server if the server which is docker engine is not running you are not going to see this information and this applies to all operating systems windows mac os and linux so make sure docker engine is running before going forward if you encounter any errors you can post your question on our forum at forum.codewithmosh.com or if you want a faster response just google the error message i'm pretty sure hundreds of people have encountered the same problem as you now let's talk about your development workflow when using docker so to start off we take an application it doesn't matter what kind of application it is or how it's built we take that application and dockerize it which means we make a small change so that it can be run by docker how we just add a docker file to it a docker file is a plain text file that includes instructions that docker uses to package up this application into an image this image contains everything our application needs to run everything typically a cut down operating system a runtime environment like node or python it also contains application files thirdparty libraries environment variables and so on so we create a docker file and give it to docker for packaging our application into an image once we have an image we tell docker to start a container using that image so a container as i told you is just a process but it's a special kind of process because it has its own file system which is provided by the image so our application gets loaded inside a container or a process and this is how we run our application locally on our development machine so instead of directly launching the application and running it inside a typical process we tell docker to run it inside a container an isolated environment now here's the beauty of docker once we have this image we can push it to a docker registry like docker hop docker hub to docker is like github to git it's a storage for docker images that anyone can use so once our application image is on docker hub then we can put it on any machines running docker this machine has the same image we have on our development machine which contains a specific version of our application with everything it needs so we can start our application the same way we started it on our development machine we just tell docker to start a container using this image so with docker we no longer need to maintain long complex release documents that have to be precisely followed all the instructions for building an image of an application are written in a docker file with that we can package up our application into an image and run it virtually anywhere this is the beauty of docker next we're going to see this workflow in action in this design i'm going to walk you through a typical development workflow now don't try to memorize anything in this lesson because i just want you to see the big picture so everything i show you in this lesson we're going to cover in depth later in the course so here in this terminal window i'm currently on my desktop i'm going to create a new directory called hello docker then go inside this directory and open it in visual studio code so i'm going to use vs code as my editor but you can use any editor that you prefer okay now in this directory i'm going to add a new file called app.js you're going to write one line of javascript code you don't have to be a javascript developer you don't even need to learn javascript so just follow along with me so here we're going to write console in lowercase dot log hello so with this we're going to print a message on the terminal let's say this is an application and we want to dockerize this application so we want to build run and ship it using docker so typically without docker if you want to ship this application or more accurately this program to a different computer on that computer we need to install node and then we can go to the terminal and type node app.js so we get the output so here are the instructions for deploying this program we need to start with an operating system then we need to install node which is an execution environment for javascript code next we need to copy our application files and finally we need to run node app.js so we have to follow four steps just for a simple program what if you were working with a really complex application you would end up with a complex release document that had to be precisely followed now this is where docker comes to the rescue we can write these instructions inside a docker file and let docker package up our application so back to vs code we're going to add another file to this project called docker file so capital d and all the other letters are lowercase and this file doesn't have any extensions okay now vs code is asking if you want to install the recommended extensions for docker we can go ahead with that good so back to this docker file here we write instructions for packaging our application so typically we start from a base image this base image has a bunch of files we're going to take those files and add additional files to it this is kind of like inheritance in programming okay so what is the base image well we can start from a linux image and then install node on top of it or we can start from a node image this image is already built on top of linux now how do i know these names well these images are officially published on docker hub so if you go to hub.docker.com and search for node you can see the official node image here so docker hub is a registry for docker images now back to our docker file so we start from a node image now if you look at docker hop you will see that there are multiple node images these node images are built on top of different distributions of linux so linux has different distributions or different flavors used for different purposes now here we can specify a tag using a column to specify which linux distribution we want to use for this demo i'm going to use alpine which is a very small linux distribution so the size of the image that we're going to download and build on top of is going to be very small okay so we start from that image then we need to copy our application or program files for that we use the copy instruction or copy command we're going to copy all the files in the current directory into the app directory into that image so that image has a file system and in that file system we're going to create a directory called app okay now finally we're going to use the command instruction to execute a command what command should we execute here node app.js but this file is inside the app directory so we have to prefix it with the directory name alternatively here we could set the current working directory work dir to slash app and then we don't need to prefix this with the directory name so when we use this instruction all the following instructions assume that we're currently inside the app directory okay so these instructions clearly document our deployment process now we go to the terminal and tell docker to package up our application so we say docker build we need to give our image a tag a tag to identify so t here we specify a name like hello docker and then we need to specify where docker can find a docker file so we're currently inside hello docker directory and our docker file is right here so we use a period to reference the current directory let's go with that now you might be expecting an image file inside the current directory but back in vs code look there is nothing here because the image is not stored here and in fact an image is not a single file how docker stores this image is very complex and we don't have to worry about it so back to the terminal to see all the images on this computer we type docker images or docker image ls which is short for list so take a look on this machine we have a repository called hello docker in this repository we have an image with this tag latest so docker added this by default we'll talk about this later in the course but basically we use these tags for versioning our images so each image can contain a different version of our application okay now each image also has a unique identifier here we can see when the image was created and the size of this image so because we used node from linux alpine we ended up with 112 megabytes of data in this image so this image contains alpine linux node and our application files and the total size is 112 megabytes now if we used a different node image that was based on a different distribution of linux we would end up with a larger image and then when deploying that image we would have to transfer that image from one computer to another so that's why we use node alpine because this is a very small image okay so we have built this image now we can run this image on any computer running docker so on this machine which is my development machine i can say docker run and then type the image name hello docker and it doesn't matter which directory i'm in because this image contains all the files for running our application now look we see the message on the terminal now i can go ahead and publish this image to docker hub so anyone can use this image then i can go on another machine like a test or a production machine and pull and run this image in fact i've done this before recording this video so back to docker hub look i have this repository code with mosh slash hello docker now we can take this image and run it on any computers let me show you something really cool so let's search for play with docker let's go to this page and log in here we need to sign in with our docker id anyone can create this id on docker.com so let's go ahead and start a lab over here we can start a new virtual machine so let's add a new instance now this virtual machine is a black machine it only has an operating system which is linux and docker so in this terminal window if we type node look node command not found so node is not installed here but because we have docker we can pull and run the image that i published on docker hub so let me maximize this window by pressing alt and enter first let's run docker version so on this machine we're running docker version 20.10.0 so to pull and run my program first we type docker pool code with mosh slash hello dash docker alright docker downloaded this image we can verify it by typing docker what command should be run here docker images or image ls so on this machine we have this repository code with mosh slash hello docker and this repository contains a single image with this tag latest so now we can run this application exactly the same way we run it on my development machine so from any directory we can type docker run code with mosh slash hello dash docker and here's the message beautiful of course i had to cut this down in editing it took a little while to start this application on this very slow virtual machine but you got the point so we can take any application and dockerize it by adding a docker file to it this docker file contains instructions for packaging an application into an image once we have an image we can run it virtually anywhere on any machine with docker hey guys mosh here if you're serious about learning docker i actually have a complete docker course on my coding school codewithmosh.com this tutorial you've been watching is a cut down version of the complete course in the full course you will learn how to run and deploy a full stack application with a frontend backend and a database our application also includes automated tests so it's a great realworld scenario for learning docker just like my other courses you will also receive a 30day moneyback guarantee and a certificate of completion you can add your resume in case you're interested you can find the link down below in the description box all right the next step in our journey is the linux command line but why linux what if you're a windows user well you still need to know a bit of linux for a number of reasons for starters docker has its foundations built on top of basic linux concepts so if you want to be productive and troubleshoot issues easily you need to know some of the basic linux commands also most tutorials online are based on linux commands so if you don't understand these basic commands you're not going to get far in my opinion learning linux is like learning english i think everybody should know some english these days you don't need to speak it or write a book in it but you need to understand it so unless you're a power linux user do not skip this section it's gonna be super easy and extremely useful so let's jump in and get started let's start up this section by talking about linux distributions also called linux distros so as you probably know linux is open source software and for this reason many individuals and communities have created their own version of linux called linux distributions each of these distributions is made to fit specialized needs like running servers desktop computers mobile phones and so on so we have ubuntu which is one of the most popular linux distributions we also have debian alpine which we briefly talked about it's a very small linux distribution we also have fedora centos and so on believe it or not there are more than a thousand linux distributions out there now most of these distributions support pretty much the same set of commands but sometimes you might discover differences along the way so be aware of that in this section we're going to use ubuntu linux because it's one of the most popular distributions but if you have a preference for another distribution that's totally fine all right let's see how we can run ubuntu on this machine from this lesson i want you to start taking notes so watch this video take some notes and then after the video repeat the steps i have shown you okay so we go to hub.docker.com and search for ubuntu over here you can see the official ubuntu image that's been downloaded more than 10 million times let's have a quick look here so for each image you can see the command to pull that image onto your machine now in this lesson i'm not going to use the pull command i'm going to show you a shortcut so here in the terminal instead of running docker pool ubuntu i'm going to run docker run ubuntu now if we have this image locally docker is going to start a container with this image otherwise it's going to pull this image behind the scene and then start a container so take a look see docker is unable to find this image locally and now it's pulling it from docker hub now what happened well docker started a container but because we didn't interact with this container the container stopped let me prove this to you so if you run docker ps we can see the list of running processes or running containers look we don't have any containers running here but if we type docker ps dash a for all we can see the stopped containers as well let me increase the size of this window so you can see it clearly good so we have two stopped containers the first one is using the ubuntu image this is the one that we just started and the second one is hello docker which we started earlier in the course so to start a container and interact with it we have to type docker run dash i t that is short for interactive we're going to start a container in the interactive mode and in this container we're going to load the ubuntu image which we have locally good now what we have here is called the shell a shell is a program that takes our commands and passes them to the operating system for execution okay now what we have here is called the shell prompt let me break it down for you so it doesn't look mysterious the first part root represents the currently logged in user so by default i'm logged in as the root user which has the highest privileges then after the add sign we have the name of the machine so this container has this id which is automatically generated by docker and in this case it's like the name of a machine okay and after the colon you can see forward slash that represents where we are in the file system a forward slash represents the root directory that is the highest directory in the file system we'll talk about that soon then we have a pound and this means i have the highest privileges because i've logged in as the root user if i logged in as a normal user instead of a pound we would see a dollar sign okay so in this shell we can execute a bunch of commands for example we can say echo hello and this prints hello on the terminal we can also say who am i this shows the current user so these commands that we're running here this shell program that i told you about takes these commands and passes them to the kernel for execution now let me show you something really cool if we type echo dollar sign 0 we can see the location of this shell program take a look so that is forward slash bin slash bash so bin is a folder or a directory and inside this directory we have a program called bash which is short for born again shell so apparently steve bourne is the first person who created a shell program bash or born again shell is a reference to steve bourne so bash is an enhanced version of the original shell program okay now one thing you probably notice is that in linux we use a forward slash to separate files and directories but in windows we use a backslash so that's one of the first differences the other difference is that linux is a case sensitive operating system so if you type echo with a capital e it's not going to work bash tells us echo command not found so lowercase and uppercase letters are different and this is not limited to commands it's applicable everywhere if you want to reference a file or a directory or a user pretty much anything we should always spell it properly with the right uppercase and lowercase letters now one last thing for this lesson using the up and down arrows we can go through the commands we have executed so far so this is a pretty useful shortcut you need to know because you don't want to type these commands manually all the time okay also using the history command we can see all the commands we have executed lately so take a look so earlier we used who am i we also used echo and so on now we can replay any of this command by typing an exclamation mark followed by the command number so if i type 2 this is exactly like running who am i now it's your turn i want you to pause the video go through your note and execute the commands i have shown you in this video these days most operating systems and development platforms come with a package manager you've probably worked with tools like npm yarn pip and so on here in ubuntu we also have a package manager called apt which is short for advanced package tool so let's execute this command look this command has a bunch of subcommands so using list we can see the list of packages we can also search for them we can show details about the package we can install reinstall and remove a package and so on now technically apt is the newer package manager we also have aptget which you see a lot in online tutorials going forward we're going to use apt because it's easier to work with so let's say we want to install a package called nano nano is a basic text editor for linux now if you press enter here we get an error because this image this ubuntu image we are running does not have nano so this is where we use apt to install this package so if we type apt install nano we get an error saying unable to locate package nano why is this happening well here in linux we have a package database and this database might contain hundreds of packages but not all these packages are installed so if you want to see all the packages in this database we type apt list look these are all the packages now in front of these packages you can see some of them are installed but not all packages in this database are installed when we type app install nano this command looks at the package database and in this database it cannot find a package called nano so this is where we use the update command to update the package database now let me press enter then x is going to all these sources like security.ubuntu.com and all these other websites to download the list of packages so now our package database is updated so if we run apt list we see far more packages and as you can see most of these packages are not installed because we don't have installed in front of them so now we can run apt install nano and nano is installed so here's what you need to take away before installing a package you should always run apt update to update your package database and then you can install a package like nano now we'll talk about nano later in this section but before going forward let's make sure that this package is installed properly so if you type nano great so here we have a text editor we can type something let me resize the window so down below you can see the shortcuts to exit we have to press ctrl and x now it's asking if you want to save the changes no so we're going to press n good we're back here we can clear the terminal window by pressing control and l okay so we have installed nano now let's say we want to remove it so we type apt remove nano it's asking for confirmation let's go ahead great so nano is gone if i type nano we get this error saying no such file or directory now here's a little exercise for you in this image we don't have python so we get an arrow so i want you to use apt to install python in this image make sure it works and then remove it so in linux just like windows our files and directories are organized in a tree in a hierarchical structure so in windows we have a structure like this with c drive on top of the hierarchy then below that we have directories like program files windows and so on in linux we have the root directory on top of the hierarchy below that we have a bunch of standard directories for example we have bin which includes binaries or programs we have boot which includes all the files related to booting then we have dev the first time i saw this i thought this is short for development it's not it's short for devices so in linux everything is a file including devices directories network sockets pipes and so on so the files that are needed to access devices are stored in this directory then we have etsy there are different opinions what is this short for but one common opinion is this is short for editable text configuration so this is where we have configuration files we also have home this is where home directories for users are stored so on a machine with multiple users each user is going to have a home directory here we also have root which is the home directory of the root user only the root user can access this directory then we have lib which is used for keeping library files like software library dependencies we have var which is short for variable and this is where we have files that are updated frequently like log files application data and so on and finally we have proc which includes files that represent running processes so once again in linux everything is a file processes devices even directories are files now you don't need to memorize any of these directories i just listed them here so as we go through the course these directories look familiar to you that's all next i'm going to show you how to navigate the file system and there you will see these directories one more time let's see how we can navigate the linux file system so the first command we're going to talk about is pwd which is short for print working directory with this we can see where we are in the file system so a forward slash represents the root directory now to see the files and directories here we type ls which is short for list so we have bin which we talked about earlier that is short for binaries this is where we have binary files and programs we have dev which includes files for devices we have boot which includes boot files etsy which includes configuration files and so on now by default ls lists these items on multiple lines if you don't like this layout and want to show one item per line you need to pass an option that is dash one you might prefer this layout we have another option dash l for seeing a long listing this listing includes more details so in the first column we have the permissions of this file or directory the first time you see this it might look really scary but trust me it's easier than you think we'll talk about that later in this section over here you can see the user that owns this file or directory we can see the size we can see the date and so on now to change the current directory we use the cd command we have the same command in windows now here we can type a relative or an absolute path a relative path is relative to where we are so in this root directory we have directories like bin boot and so on so this is a relative path now in contrast an absolute path always starts from the root directory so let's go to a directory starting with e now we can press tab to get auto completion beautiful now let's go to a directory starting with a now if you press tab nothing happens because we have multiple directories starting with a so we have to press tab one more time great so we have three entries three directories add user.conf alternatives and apt so let's type the second letter p and then press tab beautiful now let's see what we have in this directory so these blue items are directories and sources.less is a file now to get out of this directory we can go one level up by typing two periods again i'm pretty sure you're familiar with this but i want to cover it to make this section comprehensive so we can go one level up to get to the etsy directory or two levels up to get to the root directory look we're currently in the root directory now when using ls we can optionally specify a path let's say i'm somewhere in the file system but i want to look at the content of another directory i don't want to navigate to that directory so i'm currently in the root directory i want to know what files and directories we have inside the bin directory so once again we can type a relative path or an absolute path starting from the root directory so here are the binaries in this directory look at pwd that's the command that we just executed so pwd is a program in this directory here's another example look at echo so most of the commands we have been exploring so far are programs or binaries in the bin directory okay now let me show you a shortcut earlier i told you that here we have this home directory where each user has a home directory but the root user has a special home directory called root now to get here there are two options we can type an absolute or relative path and go to root but there is a shortcut so let me get out of this directory so i'm currently in the root directory to get to my home directory i can type a tilde and this applies to all users not just the root user whenever we type cd tilde we go to our home directory now right now there is nothing here but in the next lesson i will show you how to create some files in this directory so before moving on to the next lesson i want you to spend a couple of minutes and play with the commands we explored in this lesson navigate the file system get adventurous see what you can discover i'll see you in the next lesson let's see how we can manipulate files and directories so i'm currently in the root directory and i want to go to my home directory how can i do that do you remember we type cd tilde great now in this directory i want to create a directory called test so we type mkdir test let's verify it's right here as i told you before blue represents a directory now let's say we want to rename this directory how do we do that we use the move command with this we can rename files and folders or move them somewhere else so we can move or rename test to docker all right beautiful now let's go in this directory to create a new file we use the touch command so we can create hello.txt look we have this new file here this is a new empty file in the next lesson i will show you how to edit files so for now don't worry about it also using the touch command we can create multiple files in one go so we can create file 1 file 2 and file 3. now take a look beautiful now i've got a question for you how do we list these files with a single file per line do you remember we type ls dash 1. now let's say we want to rename hello.txt to something else once again we can use the move command so we type h press tab to get auto completion we can rename this to hello docker.txt or we can move it to a different directory for example we can move it to the etsy directory and here i'm using an absolute path because my path has started from the root directory now in this lesson i don't want to move this anywhere so i just want to rename this to hello docker.txt and if you're wondering how i remove this entire word in one go i press ctrl and w so let's bring it back hello docker.txt take a look good now let's see how we can remove one or more files to do that use the rm command like here we can type one or more files so we can say file1.txt file2.txt or we can use a pattern for example i can say i want to remove all files that start with file let's verify it beautiful we only have hello docker now let's get out of this directory and remove the directory itself so we type rm docker now we get an error saying docker is a directory so to remove directories we have to use the r option which is short for recursive so we want to remove this directory and all its content recursively now we press d tab beautiful so let's verify there is nothing here so let's quickly recap we use mkdir to create a new directory we use touch to create a new file we use move to move or rename files or directories and we use rm to remove files and directories now as an exercise go to your home directory create a bunch of files and directories rename them and then remove them in the next lesson i'm going to show you how to view and edit files all right let's see how we can edit and view files so earlier we briefly talked about nano now it's a basic text editor for linux now on this image that we are running we don't have nano so we have to install it do you remember the command for installing nano that is apt install nano all right now we have nano so we can launch it and optionally supply a file name let's say file1.txt so here we have a basic text editor we can type whatever we want and when we're done look down below the shortcut for exiting is control and x so i'm going to press that now it's asking if you want to save the changes so we press yes and here we confirm the file name we can keep the same file or change the file name let's go ahead so now in this directory we have file on the txt beautiful now to see the content of this file we have a few different commands the simplest one is cat and this has nothing to do with cats it's short for concatenate so later i will show you how we can use this command to concatenate or combine multiple files but with cat we can also see the content of a file so if we say cat file1.txt we can see the content of this file now cat is useful if our file is short and fits on one page but if you're dealing with a long file it's better to use the more command let me give you an example so i'm going to use cat to show the content of this file slash etsy slash add user.conf this is a really long file so if i scroll up look we have a lot of text now sometimes you don't want to see all the content in one go you want to scroll down you want to go page by page this is where we use the more command so more etsy slash adduser.conf now down below look you can see more 15 percent so we're seeing 15 percent of this file now if we press space we can go to the next page so now we're at the position 33 alternatively we can press enter to go one line at a time now the problem with more is that we can only scroll down we cannot scroll up so to do that we have to use a different command called less so to exit here we press q good now in this image we don't have less so once again we have to manually install it so apt install less so less is a newer command that is supposed to replace more let's go ahead great so let's look at the same file using the less command hcl slash adduser.com so now using the up and down arrows we can scroll down or up so just by pressing up and down arrows we also have space we can go to the next page and enter just like the more command and when we are done we can press q now we have a couple more commands for viewing the content of a file we have head which we can use to display the first few lines so here we can supply an option and say the number of lines we want to see is 5. let's look at the same file so this shows the first five lines of this file similarly we have tail which shows the last few lines so let's apply an option and say we want to look at the last five files that's it so to recap we can use nano to write something to a file we can use cat to view the content of small files less to view the content of long files in an interactive way and head and tail to view the first view or the last few lines of a file one of the important concepts in linux is the concept of standard input and output so standard input represents the keyboard and standard output represents the screen but we can always change the source of the input or the output this is called redirection let me show you using a few examples so we talked about the cat command to see the content of a file let's say file1.txt when we execute this command this command or this program reads data from this file and prints it on the standard output which is the screen that is why we see the content here but using the redirection operator which is the greater than sign we can redirect the output from the screen to let's say a different file so now cat will read the content from this file and write it to this file take a look so we have file to.txt if we view it we see the exact same content as file one okay now what is the point of this well earlier i told you that we can use the cat command to concatenate or combine multiple files so here we can say cat file1.txt and file2.txt if you press enter cat is going to read the data from both these files and print it on the terminal which is the standard output but once again using the redirection operator we can write the result to a different file combined the txt so this is how we can use this command to combine multiple files now the redirectional operator is not limited to the cad command we can use it pretty much anywhere for example earlier we talked about the echo command if we say echo hello we see the result on the terminal but if we say echo hello to hello.txt now we have a new file here hello.txt which contains hello so if you want to write a single line to a file we don't have to use nano we can use the echo command so echo whatever to whatever file the txt okay now here's a little exercise for you i want you to get a long listing of the files in the etsy directory and write the output to a file so pause the video and work on this for a few seconds so here's the solution to get a long listing we type lsl then we specify the path the exit directory now instead of printing the result on the terminal we're going to write it to a file called files.txt okay now let's view this file perfect now one more thing before we finish this lesson using the greater than sign we can redirect the standard output but we also have the less than sign to redirect the standard input i personally haven't found many use cases for this so i didn't cover it in this lesson all right that's all about redirection next we're going to talk about searching for text and files hey guys mosh here if you're serious about learning docker i actually have a complete docker course on my coding school codewithmosh.com this tutorial you've been watching is a cut down version of the complete course in the full course you will learn how to run and deploy a full stack application with a frontend backend and a database our application also includes automated tests so it's a great realworld scenario for learning docker just like my other courses you will also receive a 30 day money back guarantee and a certificate of completion you can add your resume in case you are interested you can find the link down below in the description box
