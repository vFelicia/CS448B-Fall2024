With timestamps:

00:00 - [Music]
00:01 - so what is object-oriented programming
00:04 - object-oriented programming is a
00:06 - programming paradigm or a style of
00:08 - programming that is centered around
00:10 - objects rather than functions it's
00:13 - nothing new it's been around since the
00:15 - 70s
00:16 - but unlike tools and frameworks that
00:18 - come and go object-oriented programming
00:20 - is still very relevant today that's
00:22 - because it's not a programming language
00:24 - or a tool it's a style of programming or
00:27 - a programming paradigm there are several
00:30 - programming languages out there that
00:32 - support object-oriented programming such
00:34 - as c-sharp Java Ruby Python JavaScript
00:38 - and more now JavaScript is a little bit
00:41 - controversial but I'll get to that later
00:43 - it may interest you to know that many of
00:45 - the popular frameworks out there that
00:47 - you might be using are actually designed
00:50 - with object-oriented programming
00:52 - concepts in mind angular is an example
00:55 - of these frameworks so object-oriented
00:57 - programming is a very popular style of
01:00 - programming and it comes up in many
01:02 - technical interviews so if you really
01:04 - want to be a serious developer you need
01:06 - to understand object-oriented
01:08 - programming as a technical interviewer
01:10 - myself if I see a candidate with
01:12 - object-oriented programming under resume
01:15 - that candidate stands out to me and
01:17 - that's where this crash course comes in
01:19 - in this course you're going to learn and
01:22 - understand object-oriented principles
01:24 - and how to implement them in JavaScript
01:27 - my name is Mohamad ani and i'm going to
01:29 - be your instructor in this course if you
01:31 - enjoyed this video please like and share
01:33 - it with others and be sure to subscribe
01:35 - to my channel for new videos every week
01:38 - you can also follow me on twitter as
01:40 - Masch a Madani so now let's get started
01:48 - a popular interview question concerns
01:50 - the four core concepts in
01:52 - object-oriented programming this
01:54 - concepts are encapsulation abstraction
01:58 - inheritance and polymorphism let's look
02:01 - at each of these concepts before
02:03 - object-oriented programming we had
02:05 - procedure of programming that divided a
02:07 - program into a set of functions so we
02:10 - have data stored in a bunch of variables
02:12 - and functions that operate on the data
02:15 - this style of programming is very simple
02:18 - and straightforward often it's what you
02:20 - learn as part of your first programming
02:22 - subject at a university but as your
02:24 - programs grow it will end up with a
02:26 - bunch of functions that are all over the
02:28 - place you might find yourself copying
02:31 - and pasting lines of code over and over
02:33 - you make a change to one function and
02:35 - then several other functions break
02:37 - that's what we call spaghetti code there
02:40 - is so much interdependence e between all
02:42 - these functions it becomes problematic
02:45 - object-oriented programming came to
02:47 - solve this problem in object-oriented
02:49 - programming we combine a group of
02:51 - related variables and functions into a
02:54 - unit we call that unit an object we
02:57 - refer to these variables as properties
03:00 - and the functions as methods here's an
03:03 - example think of a car a car is an
03:06 - object with properties such as make
03:08 - model and color and methods like start
03:12 - stop and move now you might say what
03:15 - marche
03:15 - we don't have cars in our programs give
03:17 - me a real programming example ok think
03:21 - of the local storage object in your
03:23 - browser's every browser has a local
03:25 - storage object that allows you to store
03:28 - data locally this local storage object
03:31 - has a property like length which returns
03:33 - the number of objects in the storage and
03:35 - metals like set item and remove item so
03:39 - in object-oriented programming we group
03:41 - related variables and functions that
03:44 - operate on them into objects and this is
03:47 - what we call encapsulation let me show
03:50 - you an example of this in action so here
03:52 - we have three variables base salary over
03:55 - time and rate below these we have a
03:58 - function to calculate the wage for an
04:00 - employee
04:02 - we refer to this kind of implementation
04:03 - as procedural so we have variables on
04:06 - one side and functions on the other side
04:08 - they're hard decoupled now let's take a
04:11 - look at the object-oriented way to solve
04:13 - this problem we can have an employee
04:15 - object with three properties a salary
04:19 - over time and rate and a method called
04:21 - get wage now why is this better well
04:25 - first of all look at the get wage
04:27 - function this function has no parameters
04:29 - in contrast in a procedural example our
04:33 - get wage function has three parameters
04:35 - the reason in this implementation we
04:38 - don't have any parameters is because all
04:40 - these parameters are actually modeled as
04:43 - properties of this object all these
04:46 - properties and get wage function they
04:48 - are highly related so they are part of
04:50 - one unit so one of the symptoms of
04:53 - procedure code is functions with so many
04:56 - parameters when you write code in an
04:58 - object-oriented way your functions end
05:00 - up having fewer and fewer parameters as
05:03 - Uncle Bob says the best functions are
05:06 - those with no parameters if fewer the
05:09 - number of parameters the easier it is to
05:11 - use and maintain that function so that's
05:13 - encapsulation now let's look at
05:15 - abstraction think of a DVD player as an
05:19 - object this DVD player has a complex
05:21 - logic board on the inside and a few
05:24 - buttons on the outside that you interact
05:26 - with you simply press the play button
05:28 - and you don't care what happens on the
05:31 - inside all that complexity is hidden
05:33 - from you
05:34 - this is abstraction in practice we can
05:37 - use the same technique in our objects so
05:39 - we can hide some of the properties and
05:41 - methods from the outside and this gives
05:44 - us a couple of benefits first is that
05:46 - we'll make the interface of those
05:48 - objects simpler using an understanding
05:51 - an object with a few properties and
05:53 - methods is easier than an object with
05:56 - several properties and methods the
05:58 - second benefit is that it helps us
06:00 - reduce the impact of change let's
06:03 - imagine that tomorrow we change these
06:06 - inner or private methods none of these
06:09 - changes will leak to the outside because
06:11 - we don't have any code that touches
06:13 - these methods outside of their content
06:15 - object we may delete a method or change
06:18 - its parameters but none of these changes
06:20 - will impact the rest of the applications
06:22 - code so with abstraction we reduce the
06:26 - impact of change now the third core
06:28 - concept in object-oriented programming
06:30 - inheritance inheritance is a mechanism
06:33 - that allows you to eliminate redundant
06:36 - code here is an example think of HTML
06:40 - elements like text boxes drop-down lists
06:42 - checkboxes and so on all these elements
06:45 - have a few things in common it should
06:47 - have properties like hidden and inner
06:49 - HTML and matters like click and focus
06:53 - instead of redefining all these
06:55 - properties and methods for every type of
06:57 - HTML element we can define them once in
07:01 - a generic object call it HTML element
07:04 - and have other objects inherit these
07:06 - properties and methods so inheritance
07:09 - helps us eliminate redundant code and
07:12 - finally polymorphism poly means many
07:16 - morph means form so polymorphism means
07:20 - many forms in object-oriented
07:22 - programming polymorphism is a technique
07:25 - that allows you to get rid of long
07:27 - ethanol's
07:28 - or switch and case statements so back to
07:31 - our HTML elements example all these
07:34 - objects should have the ability to be
07:36 - rendered on a page but the way each
07:38 - element is rendered is different from
07:41 - the others if we want to render multiple
07:43 - HTML elements in a procedural way our
07:46 - code would probably look like this but
07:49 - with object orientation we can implement
07:51 - a render method in each of these objects
07:54 - and the render method will behave
07:56 - differently depending on the type of the
07:59 - object viewer referencing so we can get
08:02 - rid of this nasty switch and case and
08:04 - use one line of code like this you will
08:07 - see that later in the course so here are
08:09 - the benefits of object oriented
08:11 - programming using encapsulation we group
08:14 - related variables and functions together
08:16 - and this way we can reduce complexity
08:19 - now we can reuse these objects in
08:22 - different parts of a program or in
08:24 - different programs with abstraction we
08:27 - hide the details and the complex
08:29 - and show only the essentials this
08:32 - technique reduces complexity and also
08:34 - isolates the impact of changes in the
08:37 - code with inheritance we can eliminate
08:39 - redundant code and with polymorphism we
08:43 - can refactor ugly switch case statements
08:52 - to go through this course all you need
08:55 - is a code editor and a simple web server
08:58 - the editor that I'm gonna use here is
09:00 - Visual Studio code or vs code that you
09:03 - can download from code that Visual
09:06 - Studio calm but feel free to use any
09:08 - editors now with vs code we have this
09:11 - extensions panel here search for live
09:15 - server
09:17 - this is a very simple and lightweight
09:19 - server that we're going to use to serve
09:22 - our application so install is and then
09:25 - here in the files panel let's add a new
09:30 - file
09:31 - index dot HTML now to generate some
09:35 - basic HTML template we can simply type
09:38 - an exclamation mark and press tab so a
09:43 - very basic HTML template now let's add a
09:45 - script element so script with source set
09:50 - to index J s we're gonna write all our
09:53 - JavaScript code inside of this file so
09:56 - let's add a new file and save it as
10:00 - index that J s and finally to make sure
10:04 - that we have setup everything properly
10:06 - let's do a console that log of hello
10:10 - world now when you install live server
10:14 - you should get this menu here in the
10:16 - status bar if you don't see that you
10:18 - probably have to restart vs code and if
10:21 - you still don't see it simply
10:23 - right-click on index.html and select
10:27 - open with live server
10:31 - so this will fire up Chrome pointing to
10:34 - this address now let's open up Chrome
10:37 - developer tools here in the console tab
10:41 - we've got hello world so before going
10:44 - any further I want to emphasize that
10:46 - this course is not for beginners is for
10:48 - intermediate level developers so you
10:50 - should have at least three months of
10:52 - experience programming in JavaScript you
10:54 - should know the basics you should know
10:56 - how to use Chrome developer tools I'm
10:58 - not gonna cover these in this course our
11:00 - focus is purely on object oriented
11:03 - programming with JavaScript
11:09 - javascript is all amount objects so in
11:12 - order to learn object-oriented
11:13 - programming first you need to have a
11:15 - good understanding of objects so in this
11:18 - section I'm gonna cover some fundamental
11:20 - concepts around objects such as creating
11:23 - objects factories and constructors
11:25 - primitives and reference types on how
11:27 - they behave differently working with the
11:30 - properties of an object such as adding
11:32 - removing properties as well as
11:34 - enumerating them you're also gonna learn
11:36 - how to define private properties as well
11:39 - as getters and setters if you know all
11:41 - these topics well feel free to skip this
11:43 - section and move to the next section
11:45 - where I talk about prototypes otherwise
11:47 - continue watching so now let's get
11:50 - started let's start this section by
11:58 - creating an object so I'm gonna use the
12:00 - let keyword in es6 which is the
12:03 - replacement for var so in es5
12:06 - and before we had var for declaring
12:08 - variables but for has a number of issues
12:10 - when it comes to scoping that's beyond
12:13 - the scope of this course I just want to
12:15 - let you know that as a best practice
12:16 - stop using var use either let or Const
12:21 - with cons you're basically defining a
12:23 - constant so you won't be able to
12:25 - reassign it if you want to reassign a
12:27 - variable use let now in this demo I'm
12:30 - gonna use Const
12:31 - to define a constant so let's call this
12:34 - circle and set it to an object here I'm
12:38 - using object literal syntax so these
12:41 - curly braces we refer to them as object
12:44 - literal syntax an object in JavaScript
12:47 - is essentially a collection of key value
12:49 - pairs so inside these curly braces I'm
12:53 - gonna add a few key value pairs let's
12:55 - add radius and set it to 1 let's add
12:59 - another key like location now this time
13:02 - the value can be an object so again I'm
13:06 - using object literal syntax in this
13:08 - object we can have a couple key value
13:11 - pairs like x and y now let's add another
13:17 - key value pair so the keys draw
13:21 - the value is a function that is for
13:24 - drawing the circle so for now let's just
13:26 - do a simple console.log now I want to
13:31 - define a few terms here this circle
13:34 - object has three members radius location
13:38 - and draw if a member is a function we
13:42 - refer to that as a method so here we say
13:45 - draw is a method these other members are
13:49 - what we call properties now in some
13:52 - JavaScript tutorials that refer to all
13:54 - these members as properties whether
13:56 - there are functions or not but
13:58 - technically in object-oriented
13:59 - programming properties and methods are
14:02 - fundamentally different because a
14:03 - property is used to hold values a
14:06 - function or a method is used to define
14:09 - some logic so now that we have this
14:12 - circle object we can access its members
14:14 - using the dot notation so circle dot
14:18 - look here are the members we can call
14:21 - the draw method now note here on the
14:23 - right side I've got Chrome open this is
14:25 - Chrome developer tools as soon as I save
14:28 - my changes here you will see that Chrome
14:30 - is gonna refresh because here with live
14:33 - server we have hot reloading so save and
14:38 - here's the result so as soon as we
14:41 - change our code the new code is loaded
14:43 - inside Chrome so object literal is a
14:47 - simple way to define an object but we
14:49 - can also define objects using factories
14:51 - and constructors and that's the topic
14:53 - for the next lecture
15:00 - all right now let's imagine we want to
15:02 - create another circle with the current
15:05 - implementation we have to duplicate all
15:08 - this code like this now this can be a
15:12 - problem if we have one or more methods
15:15 - in our object in this case we have this
15:18 - draw method here and as you can see we
15:21 - have duplicated that in two different
15:22 - places so if there is a bug in this
15:25 - method we have to come back and fix it
15:27 - in multiple places now this is a very
15:30 - simple object imagine if the circle
15:32 - object had ten methods so object literal
15:36 - syntax is not a good way to create an
15:39 - object and duplicate it if this object
15:41 - has at least one method if an object has
15:45 - one or more methods we say that object
15:48 - has behavior like a person that can do
15:51 - different things so it has behavior now
15:53 - let's imagine here we didn't have this
15:55 - draw method duplicating this object
15:58 - wouldn't be a big deal so basically we
16:01 - would end up with two objects and then
16:04 - here we could use different values so
16:07 - creating objects with the object literal
16:10 - syntax is an issue only if that object
16:13 - has behavior so what's the solution the
16:16 - solution is to use a factory or a
16:19 - constructor function so let me show you
16:21 - how that works I'm going to delete this
16:24 - second circle and define a function
16:28 - called create circle now I'm gonna move
16:35 - all this code inside this new function
16:39 - like this now we don't need to declare a
16:43 - constant we can simply return this
16:46 - object now this circle requires a radius
16:49 - so instead of hard-coding one here I'm
16:52 - gonna add a parameter here radius and
16:54 - then set that here now in es6 we have
16:59 - this new feature so if the key and the
17:02 - value are the same we can remove the
17:04 - noise in the code by removing the value
17:06 - so we can only add radius now to
17:10 - simplify the code
17:11 - so you can focus on what I'm gonna teach
17:12 - you I'm gonna drop this location
17:15 - property we don't really need it instead
17:18 - I'm gonna add our draw method so key
17:21 - value and let's do a simple console nut
17:27 - lock draw okay so this is what we call a
17:32 - factory function now we can simply call
17:37 - this function to create a new circle so
17:40 - constant circle we call create circle
17:44 - and pass one as the radius
17:53 - now there is another way to create an
17:55 - object using a constructor function so
17:59 - let's delete circle draw and define a
18:04 - constructor function I want you to see
18:07 - them side by side so once again we
18:10 - define a function but the naming
18:12 - convention we use for a constructor
18:14 - function is different the first letter
18:16 - should be uppercase so we call it circle
18:20 - with an uppercase C the developers with
18:24 - background in languages like C sharp and
18:26 - Java this kind of looks like a class
18:28 - however as you can see we're defining a
18:31 - function in JavaScript we don't have the
18:33 - concept of classes so our circle
18:37 - function is gonna take a radius
18:40 - parameter but in the body instead of
18:43 - returning an object we're gonna use that
18:46 - this keyword to set the properties of
18:49 - this object what is this this is
18:52 - basically a reference to the object that
18:55 - is executing this piece of code you're
18:57 - gonna see that in a second so imagine we
19:00 - have a new empty object in memory now
19:03 - we're gonna use this to reference that
19:06 - object and then use dot notation to set
19:09 - various properties on that object so we
19:12 - can set the radius property to this
19:14 - radius argument similarly we can define
19:17 - another property draw but this is more
19:21 - accurately a method so we set it to a
19:23 - function and here we do a console dot
19:27 - log of draw okay now we can create a new
19:32 - circle like this we use the new operator
19:36 - to call the circle function and pass one
19:41 - as the argument let me use the new
19:44 - operator a few things happen under the
19:46 - hood this new operator will create an
19:49 - empty object so like this an empty
19:53 - object then it will set this to point to
19:58 - that object because by default this
20:00 - points to the global object
20:03 - if you're running this code inside of a
20:05 - browser the global object is the window
20:07 - object if you're running it inside a
20:09 - node environment the global object is
20:12 - global let me show you so I'm gonna do a
20:16 - console that log of this let's see what
20:22 - happens so save the changes now look
20:26 - this is this circle object here and here
20:31 - we have two members draw and radius this
20:35 - is because we use the new operator here
20:37 - if I remove that let's see what happens
20:40 - so save the changes now this reference
20:43 - is the window object so this is the
20:46 - global object in a browser we don't want
20:48 - to use this we don't want to mess up
20:49 - with this we don't want to define global
20:51 - variables because they're bad practice
20:53 - because they're available everywhere in
20:56 - our application so it is possible that
20:58 - one function or another will modify the
21:00 - value of these variables accidentally
21:03 - and create bug in our application so
21:05 - when we use the new operator to call a
21:08 - function three things happen first
21:11 - this new operator will create an empty
21:14 - object then it will set this to point to
21:18 - that object and finally it will return
21:20 - that object from this function so note
21:24 - that here we don't have an explicit
21:27 - return statement we are not returning
21:29 - this this will happen automatically when
21:32 - we use the new operator so let me delete
21:35 - this also we don't need console that log
21:39 - here so basically we have two ways to
21:41 - create an object we can use a factory
21:44 - function or a constructor there is
21:48 - nothing special about this
21:49 - they're both regular functions in
21:51 - JavaScript if we return an object in
21:54 - this function we refer to that function
21:57 - as a factory function in contrast if we
22:02 - use that this keyword along with the new
22:05 - operator we refer to that function as a
22:08 - constructor function now you might ask
22:11 - what is the difference between these two
22:13 - patterns for creating an object which
22:15 - approach should you
22:17 - well it really depends who you ask
22:19 - developers coming from languages like C
22:22 - sharp and Java preferred the constructor
22:24 - function syntax because this looks like
22:27 - creating an instance of a class
22:29 - but once again in JavaScript we don't
22:31 - really have classes other developers
22:34 - don't like this approach they prefer to
22:36 - use Factory functions and one of their
22:39 - arguments is what if a developer forgets
22:42 - to use the new operator here then we're
22:45 - defining these property methods on the
22:49 - global object which is in this case the
22:51 - window object but this discussion this
22:53 - argument is really outdated with the
22:56 - modern JavaScript and the tools that are
22:57 - available to us we get an error if we
23:00 - forget to use the new operator here so
23:03 - my suggestion to you is not to get hung
23:05 - up and this religious arguments about
23:07 - factories versus constructors as a
23:10 - developer you should be familiar with
23:12 - both these patterns because as you work
23:14 - on different projects and different
23:16 - teams you will see both of these
23:18 - patterns for creating an object so you
23:20 - should understand how they work choose
23:23 - the pattern that you prefer
23:30 - every object in JavaScript has a
23:33 - property called constructor and that
23:36 - references the function that was used to
23:38 - construct or create that object so here
23:42 - we have two objects circle and another
23:45 - let's look at the constructor property
23:48 - so here on the console another dot
23:53 - constructor so as you see this returns
23:57 - our circle function that we use to
23:59 - create this object now let's look at
24:02 - circle dot constructor what is this well
24:07 - you can tell that this is a function
24:10 - because here we have this blue F and as
24:13 - you can see the first letter of this
24:15 - function is uppercase so this is a
24:17 - built-in constructor function in
24:20 - JavaScript when we create an object
24:23 - using the object literal syntax
24:25 - internally the JavaScript engine uses
24:28 - this constructor function let me show
24:30 - you so I'm gonna temporarily delete all
24:33 - this code let's define an object like
24:36 - this let me use this syntax object
24:39 - literal JavaScript engine will translate
24:42 - that to something like this let x equals
24:46 - new object okay so this circle object we
24:51 - created and returned it from our factory
24:53 - function and because we use the object
24:56 - literal syntax internally it was created
24:58 - using this object constructor function
25:01 - in JavaScript we have a few other
25:04 - built-in constructors for example we
25:07 - have string for creating strings but
25:11 - queen' often we use string literals so
25:14 - single code or double quote or backtick
25:17 - using these literals is cleaner and
25:20 - simpler than using the constructor you
25:24 - also have boolean but again we don't use
25:27 - this we either use true or false so we
25:30 - refer to these as boolean literals we
25:33 - also have number but instead we use
25:37 - number literals like 1 2 3 whatever
25:40 - so this is what I want you to take away
25:42 - every object has a constructor property
25:45 - and that references the function that
25:48 - was used to create an object
25:56 - one of the confusing concepts in
25:58 - JavaScript is that here functions are
26:01 - objects so this circle function we have
26:04 - here is actually an object don't believe
26:07 - me let me show you so circle dot look
26:10 - these are all the members of this circle
26:15 - function or circle object so the purple
26:18 - icons are methods like call bind and
26:20 - apply and the blue icons are properties
26:23 - so let's take a look at a few of these
26:25 - members in the console here in the
26:28 - console circle dot name that returns the
26:34 - name of this function circle the length
26:37 - returns the number of arguments now
26:41 - earlier in the last lecture I told you
26:43 - that every object in JavaScript has a
26:45 - constructor property and that references
26:48 - the function that was used to create an
26:51 - object but here's the interesting part
26:53 - who do you think created this object
26:56 - let's have a look so circle dot
26:59 - constructor so here we have another
27:03 - built-in constructor called function and
27:06 - let me declare a function using this
27:09 - syntax internally JavaScript engine will
27:12 - use this function constructor to create
27:15 - this object let me show you so I'm gonna
27:20 - define a constant called circle one two
27:24 - separate from our circle set it to new
27:27 - function now here our function requires
27:30 - one parameter radius so we add that here
27:33 - as a string now as the second argument
27:37 - I'm gonna pass the code inside of this
27:41 - function so to break it up into multiple
27:44 - lines I'm gonna use the backtick
27:48 - character
27:50 - and then simply copy all this code and
27:52 - put it here so when we declare a
27:57 - function internally it's represented
28:00 - like this now we can call this circle
28:02 - one just like calling our circle
28:05 - function so we can create a circle
28:09 - object by newing up circle one and pass
28:13 - one as the radius save the changes now
28:17 - in the console let's log circle look
28:20 - it's a real circle object with these two
28:24 - members now let's take a look at a
28:26 - couple of methods that are available in
28:28 - our functions so I'm gonna delete all
28:32 - this code circle dot here we have this
28:37 - call method and with this we can call a
28:40 - function look at the arguments the first
28:43 - argument is this argument here we need
28:48 - to pass an empty object and this will
28:52 - reference this object that we pass here
28:55 - okay after that we add our arguments
28:59 - explicitly so here we have one argument
29:02 - we pass one if you had multiple
29:04 - arguments we would pass them explicitly
29:07 - like this okay so this expression is
29:12 - exactly like expression on line 11 when
29:17 - we use the new operator this new
29:19 - operator will internally create an empty
29:22 - object and pass them as the first
29:25 - argument to the call method and this
29:28 - object will determine the context for
29:32 - this so this will reference this object
29:35 - earlier I told you that if you don't use
29:37 - the new operator this by default will
29:42 - point to the global object which is
29:43 - window so if I want to rewrite this
29:46 - expression in this way instead of
29:49 - passing an empty object I would pass
29:52 - window of course we don't want to do
29:54 - this I'm just explaining to you what
29:56 - happens under the hood so let's revert
29:59 - this back so the
30:02 - argument here specifies the target of
30:05 - this okay
30:07 - now we have another method called apply
30:12 - it's exactly like the call method with
30:16 - this we can call a function but instead
30:18 - of passing all the arguments explicitly
30:21 - we pass them in an array so this is
30:24 - useful if you already have an array
30:27 - somewhere else in your application and
30:28 - you want to pass an array as the second
30:30 - argument to the apply method so this is
30:34 - the takeaway in JavaScript functions or
30:37 - objects
30:41 - hi guys Marsh here thank you for
30:43 - watching my youtube tutorial I just
30:46 - wanted to quickly let you know that this
30:47 - video you've been watching is actually
30:49 - the first hour of one of my courses
30:51 - called
30:52 - object oriented programming in
30:54 - JavaScript so when you get to the end of
30:56 - this tutorial if you feel like you want
30:58 - to learn more click on the link in the
31:00 - video description and enroll in the
31:02 - course and if not that's perfectly fine
31:04 - continue watching as the next section is
31:06 - coming up in JavaScript we have two
31:13 - categories of types on one side we have
31:16 - value types also called primitives and
31:19 - the other side we have reference types
31:21 - so in the value types category we have
31:24 - number string boolean symbol which is
31:28 - new in es6 we're going to look at that
31:30 - later in the course as well as undefined
31:33 - and know these are the primitive or
31:35 - value types on the other side we have
31:38 - objects functions and arrays so in the
31:42 - last lecture you learned that functions
31:44 - are also objects the same is true about
31:46 - a race so in a nutshell in JavaScript we
31:49 - have primitives and objects now in this
31:52 - lecture I'm gonna show you how
31:54 - primitives and objects behave
31:55 - differently because this is absolutely
31:57 - important for you to understand before
31:59 - we move on to the next section where I
32:01 - talk about prototypes so on this empty
32:05 - canvas I'm gonna define two primitives x
32:09 - and y I'm gonna set Y to X so here Y is
32:15 - 10 now I'm gonna change the value of x
32:18 - to 20 what I want you to note here is
32:21 - that X and y are two independent
32:24 - variables so I save the changes go back
32:28 - in the console let's log X X is 20 and Y
32:33 - is 10 they are independent so when we
32:37 - work with primitives this value is value
32:40 - that we have here is stored inside of
32:43 - this variable when we copy that variable
32:45 - that value that is stored in the
32:48 - variable is copied into this new
32:51 - variable so they are completely
32:53 - independent of each
32:55 - now let's see what happens if we use a
32:58 - reference type or an object here so I'm
33:01 - gonna change this to an object that has
33:04 - a property called value
33:07 - and then instead of setting X to 20 I'm
33:10 - gonna set X code value to 20 so save the
33:14 - changes back in the console let's log X
33:18 - so you can see by the properties 20 now
33:22 - let's log Y we can see the value
33:24 - property of Y is also 20 so this is the
33:27 - takeaway when we use an object the
33:30 - object is not stored in this variable
33:33 - that object is stored somewhere else in
33:35 - the memory and the address of that
33:38 - memory location is stored inside that
33:40 - variable so then when we copy X into y
33:45 - it's the address or the reference that
33:47 - is copied in other words both x and y
33:51 - are pointing to the same object in
33:53 - memory and when we modify that object
33:56 - using either X or Y the changes are
33:59 - immediately visible to the other
34:01 - variable so here's the conclusion
34:04 - primitives are copied by value reference
34:07 - types or objects are copied by the
34:10 - reference let's take a look at another
34:12 - example so I'm gonna define a function
34:16 - called increase that takes a number and
34:21 - here we simply increase this number by 1
34:26 - let's declare a number variable and set
34:30 - it to 10 and then call increase and pass
34:34 - this number now if I log this number on
34:39 - the console what do you think we're
34:41 - going to see let's have a look so save
34:43 - the changes we see 10 but dinner we
34:47 - increase the number well when we call
34:50 - increase and pass this number variable
34:53 - its value is copied into this parameter
34:58 - that is local in this function so this
35:01 - number variable here is completely
35:03 - independent of this other number
35:06 - variable here in this function we
35:08 - increment number by 1 so it will be 11
35:10 - but after this function this number is
35:13 - going to go out of the scope so when we
35:17 - log this number on the console we're
35:19 - essentially dealing
35:21 - with this first number so I told you
35:24 - that primitives are copied by their
35:26 - value so here we're dealing with two
35:28 - independent copies that's why we see ten
35:32 - on the console now let's change this to
35:35 - a reference type or an object so I'm
35:38 - gonna change ten to an object that has a
35:41 - value property okay
35:44 - let's rename this variable to object and
35:48 - similarly I'm going to rename this
35:51 - parameter in this function to object and
35:54 - then increment object dot value now when
35:59 - we log this on the console what do you
36:01 - think we're gonna see we're gonna see
36:03 - eleven see we got this object with value
36:07 - 11 the reason for this is because when
36:10 - we call increase and pass this object
36:13 - this object is passed by its reference
36:16 - so this local parameter that we have
36:18 - here will point to the same object as we
36:22 - defined here so in this case we are not
36:25 - dealing with two independent copies we
36:27 - have two variables that are pointing to
36:29 - the same object so any changes we make
36:31 - to this object will be visible to the
36:34 - other variable so remember this in
36:36 - JavaScript we have value types also
36:39 - called primitives as well as reference
36:41 - types which are objects our primitives
36:44 - are number string boolean symbol
36:48 - undefined and no primitives or value
36:51 - types are copied by their value
36:53 - reference types or objects are copied by
36:56 - the reference
37:02 - all right so here we have our circle
37:05 - constructor function and using that we
37:08 - create a circular object now these
37:11 - objects in JavaScript are dynamic that
37:14 - means after you create them you can add
37:17 - extra properties in them or delete some
37:19 - properties you might be wondering why
37:21 - this is useful in the real world imagine
37:24 - you're working with a user object the
37:26 - client that can be a web or a mobile
37:28 - application is going to send a user
37:30 - object to the server on the server we
37:33 - get this user object and then we add
37:35 - additional stuff to it for example we
37:37 - can add a token property that we
37:40 - generate on the fly on the server so we
37:44 - can always add something extra to an
37:46 - existing object because we don't have
37:48 - classes we don't need to define these
37:50 - properties ahead of time we can add them
37:53 - whenever we need them and this makes
37:55 - JavaScript extremely powerful and easy
37:57 - to work with in languages like C sharp
38:00 - or Java every time we want to implement
38:02 - scenarios like this we have to go back
38:04 - and change our classes so here let me
38:07 - add a new property to our circle object
38:09 - we can set the location here like this
38:14 - save the changes now here on the console
38:18 - let's log circle all right you can see
38:22 - here we have two properties location and
38:25 - radius we also have another notation for
38:28 - accessing properties that is bracket
38:31 - notation so another way to rewrite this
38:34 - code is like this we use brackets and
38:38 - use a string to reference a property so
38:41 - location it's exactly the same as we can
38:46 - see the dot notation is simpler and less
38:49 - verbose than bracket notation but this
38:52 - notation is also useful in certain
38:55 - scenarios for example when you want to
38:57 - dynamically access a property name for
39:00 - example let's imagine we have this
39:04 - constant called property name set to
39:08 - location you have that somewhere in our
39:11 - application now we want to access
39:13 - the location property of a circle if
39:17 - you're dealing with this dynamically at
39:19 - a time of writing the code we don't know
39:21 - what is the name of that property that
39:23 - is calculated at runtime so we can type
39:26 - something like this circle that location
39:29 - but what we can do is use the bracket
39:32 - notation so we use circle brackets
39:38 - property name another use case for using
39:42 - the bracket notation is when you are
39:44 - using the property names that are not
39:47 - valid identifiers for example let's
39:49 - imagine the name of this property is
39:52 - Center - location we can access this
39:56 - property like this circle that Center -
40:00 - location that doesn't work so if you
40:03 - have special characters or a space
40:05 - that's when you use the bracket notation
40:07 - okay now we can also delete a property
40:12 - from an existing object a real word use
40:15 - case for this is when you get a user
40:17 - object from a database and you want to
40:19 - return it to the client but maybe that
40:21 - user object has certain properties you
40:24 - don't want to send to the client you
40:25 - don't want to send the password you
40:27 - don't want to send the credit card info
40:28 - in that case you will dynamically delete
40:31 - one or more properties from an object so
40:35 - we use the delete operator and then
40:38 - reference the property name so circle
40:40 - dot location again here we can use the
40:44 - dot notation or brackets of course here
40:49 - we need a string
40:57 - sometimes you need to iterate over or
40:59 - enumerate the properties in an object we
41:03 - can do that using the for in loop so for
41:08 - let key in circle so in every iteration
41:13 - key will hold the value of one key in
41:16 - this object let's log that on the
41:19 - console okay so look we have radius and
41:24 - draw so it's returning both properties
41:28 - and methods now if you want to get the
41:30 - value of these properties you can use
41:32 - the bracket notation so here and console
41:35 - the log I'm gonna log circle of key you
41:41 - learn in the last lecture lab we can use
41:43 - the bracket notation to access a member
41:46 - okay so say now you can see radius is 10
41:50 - and draw as a function what if we want
41:53 - to get only the properties and not the
41:56 - methods well we can use the type of
41:59 - operator to check the type of this value
42:02 - so if typeof circle of key it's not
42:12 - equal to function then we will display
42:15 - it on the console save the changes now
42:19 - we get only the radius there is another
42:22 - approach to get all the keys and an
42:24 - object so it's object that we have has a
42:30 - method called keys we can pass our
42:33 - circle object here and this will return
42:35 - all the keys in the circle as an array
42:38 - so let's store them here and lock them
42:45 - on the console so here we have an array
42:49 - with two members radius and draw with
42:52 - this approach we cannot separate
42:54 - properties from methods now finally
42:57 - sometimes you want to know if an object
42:58 - has a given property for that we use the
43:01 - in operator so if here we add the name
43:07 - of the proper
43:07 - as a string if radius is in circle we do
43:15 - a console that log of circle has a
43:19 - radius okay save the changes and here's
43:25 - our message so remember to enumerate all
43:28 - the members and an object you can use a
43:31 - four in loop to get all the keys and an
43:34 - object use object that keys and to check
43:37 - for the existence of a property or a
43:39 - method in an object use the in operator
43:47 - all right now let's introduce some
43:49 - complexity in this example so I'm going
43:52 - to define another property called
43:56 - default location set it to an object
44:00 - like this
44:03 - also let's define another method compute
44:08 - optimum location we set this to a
44:12 - function and here we're going to do some
44:15 - magic it doesn't really matter what
44:17 - matters is that we're going to call this
44:19 - method inside of the draw method so we
44:23 - call this dot compute optimum location
44:28 - now there is a problem with this
44:30 - implementation let me show you so here
44:33 - when we create the circle object circle
44:36 - dot these are the members of our circle
44:40 - object not all these members should be
44:43 - accessible to me as the consumer or the
44:46 - client of this object for example what
44:49 - would happen if I set default location
44:52 - to false it's gonna completely mess up
44:55 - with this object or as another example
44:58 - maybe this compute method should only be
45:01 - called
45:02 - inside of the draw method so if I
45:06 - accidentally call it here circle the
45:09 - compute optimum location maybe this will
45:12 - put this object in a bad state and then
45:15 - if I call circle but draw we're gonna
45:18 - get a weird error at runtime so in
45:21 - object-oriented programming we have this
45:23 - core concept called abstraction
45:25 - abstraction means we should hide the
45:28 - details and complexity and show or
45:31 - expose only the essentials in this
45:35 - particular example we should hide this
45:37 - property default location as well as
45:40 - this method these are implementation
45:42 - details these are part of the complexity
45:45 - of this object we want to hide these
45:47 - from the consumers of this object
45:49 - instead we want to expose only the
45:51 - essentials that is the radius and the
45:55 - draw method let me give you a metaphor
45:57 - think of a DVD player a DVD player has a
46:02 - complex logic board on the inside but
46:04 - only a few buttons on the outside that
46:07 - you interact with so what we have on the
46:09 - inside is the implementation detail and
46:12 - what we have on the outside is the
46:14 - public interface of it
46:16 - we player we want our objects to look
46:18 - like this DVD player we want to hide all
46:21 - the details all the unnecessary
46:23 - complexity on the inside and expose only
46:26 - a few members or a few buttons on the
46:28 - outside a lot of developers who have not
46:31 - been able to apply object-oriented
46:33 - programming effectively have failed to
46:35 - comply with this principle everything in
46:38 - their objects is public and accessible
46:40 - from the outside and this will bring a
46:43 - number of issues one issue is that every
46:45 - time you change the implementation of
46:47 - that object you have to go and modify
46:49 - many different places in your code for
46:52 - example let's imagine now this compute
46:55 - method requires an argument let's add a
46:58 - factor argument here with the current
47:02 - implementation because we can access
47:04 - this from the outside everywhere we have
47:06 - used this method you have to come back
47:08 - and pass an argument so one simple
47:12 - change in the implementation of an
47:15 - object results in a number of changes in
47:18 - your source code in contrast
47:20 - imagine if this method was not
47:22 - accessible from the outside then we
47:24 - wouldn't have to modify this line it
47:27 - would only modify line 12 where we have
47:31 - called this function right so remember
47:34 - the abstraction principle of
47:36 - object-oriented programming hide the
47:38 - details and expose only the essentials
47:41 - in the next lecture I'm going to show
47:43 - you how to implement this in JavaScript
47:51 - so how do we implement abstraction here
47:53 - you want to hide certain members from
47:56 - the outside so earlier you learned that
47:59 - this references that new circle object
48:02 - now what happens if I declare a local
48:06 - variable in this function let's say
48:09 - color we set that to red is this going
48:12 - to be part of that object of course not
48:14 - because we have not set that as a
48:16 - property on that object we didn't set
48:19 - this that color to color okay
48:22 - so this is only a local variable inside
48:24 - of this function when we get out of this
48:27 - function this variable goes out of scope
48:29 - and dies
48:30 - now with this technique we can easily
48:32 - hide certain members from the outside so
48:36 - default location is implementation
48:39 - detail we don't want this to be
48:41 - accessible from the outside instead of
48:43 - setting it as a property on our new
48:45 - object we define it as a local variable
48:48 - here okay now we don't need this color
48:52 - anymore by the same token we can convert
48:56 - this method to a private method so let
49:01 - compute be a function now here in the
49:05 - draw method recalling compute optimum
49:09 - location this function will no longer be
49:12 - a method on this new object so we can
49:15 - access it using this you have to access
49:19 - it directly here this will work because
49:21 - in JavaScript we have this concept of
49:23 - closure
49:24 - if you don't know closure let me
49:26 - simplify it for you so here we have one
49:29 - function and another function inside of
49:33 - that function in this function we can
49:35 - declare certain variables like X and Y
49:39 - and these are local variables that are
49:43 - only available in this function their
49:45 - scope is limited to this function so
49:48 - when we finish executing this function x
49:50 - and y will go out of scope in contrast
49:54 - to scope we have closure a closure
49:56 - determines what variables will be
49:59 - accessible to an inner function
50:01 - so this function will be able to access
50:03 - all the local variables defined here as
50:06 - well as the variables defined in its
50:09 - parent function so here we declare it
50:11 - two variables compute optimum location
50:15 - which is a function as well as default
50:18 - location these are the variables that
50:20 - are defined in this parent function they
50:23 - are within the scope of this function
50:25 - but within the closure of this inner
50:29 - function now don't confuse closure with
50:32 - a scope because the scope is temporary
50:35 - and it dies so every time we call the
50:37 - draw method these variables will be
50:39 - recreated and reinitialized and then
50:42 - after this function they will die
50:44 - so scope is temporary but closure stays
50:48 - there so when we call the draw function
50:51 - after we finished executing this
50:53 - function these variables will continue
50:56 - to stay in memory they will preserve
50:58 - their state because they are part of the
51:00 - closure of this draw function okay so
51:05 - back here so in this method if you want
51:09 - to access those private members you
51:11 - simply use them here you can also use
51:14 - default location default location but if
51:20 - you want to access members of this new
51:22 - circle object you need to use this so
51:26 - this dot radius as an example okay now
51:30 - with this simple change we basically
51:33 - replace this with let let's see what
51:36 - happens if I access the members of the
51:39 - circular object we only see draw and
51:42 - radius so the public interface of this
51:46 - object is simpler is easier to work with
51:48 - and this will also prevent issues later
51:51 - down the road
51:57 - so in the last lecture we converted
52:00 - these two members to private members now
52:04 - more accurately these are not private
52:06 - members of the circle object because
52:08 - technically they are not inside of a
52:11 - circle object there are local variables
52:13 - that we have defined inside of this
52:16 - circle function but from an
52:18 - object-oriented point of view we can
52:20 - refer to them as private members of the
52:22 - circle object now I want to simplify the
52:24 - code here so we can focus on a small
52:27 - issue I'm gonna delete this compute
52:30 - function right so we have this private
52:34 - property default location we cannot
52:38 - access this from the outside but what if
52:41 - we want to display that default location
52:43 - somewhere in our application so we don't
52:46 - wanna modify it we just want to be able
52:48 - to read it so one solution is to define
52:52 - a method here this dot get default
52:57 - location we set it to a function and in
53:02 - this function we simply return default
53:05 - location once again we're dealing with
53:08 - an inner function here the closure of
53:11 - this function includes all the variables
53:13 - defined here as well as all the
53:15 - variables defined and its parent
53:17 - functions so here we have access to
53:20 - default location and with this we can
53:24 - call circle dot get default location
53:27 - however I don't like this syntax I don't
53:31 - like the fact that we're calling this as
53:32 - a method it would be nicer if we could
53:36 - access this property like this default
53:38 - location but we shouldn't be able to set
53:42 - this from the outside we can only read
53:45 - it so let me show you how to define a
53:47 - property like that so this object that
53:52 - you have seen so far has a method called
53:54 - define property we have another method
53:58 - called defined properties if you want to
54:00 - define multiple properties in one go now
54:03 - the first argument of this method is the
54:06 - object that we want to add a new
54:08 - pretty - now the object is the one that
54:11 - is referenced by this the new circle
54:14 - object right so we pass that here the
54:18 - second argument is the name of our
54:20 - property we want to call that default
54:23 - location and the third argument is an
54:27 - object
54:29 - in this object we add a key value pair
54:31 - the key is get this is a special keyword
54:35 - for JavaScript and the value is a
54:37 - function so when we access circle dot
54:44 - default location this function will be
54:49 - called okay now here we can simply
54:52 - return default location again this
54:58 - variable is part of the closure of this
55:01 - inner function so here we can access it
55:03 - right now in vs code you don't see that
55:06 - in intellisense so we don't have default
55:10 - location as a property however if we
55:13 - save the changes
55:14 - oops I made a mistake here actually I
55:17 - should have used define property so save
55:22 - the changes all right so now look at the
55:25 - circle object circle so here's our new
55:30 - property default location you can see
55:32 - dot dot dot in front of it because this
55:34 - is a computed property when we click
55:37 - this that get function will be executed
55:40 - and here's the result our default
55:43 - location okay also you can see that
55:47 - function is stored here as a getter so a
55:50 - getter is a function that is used to
55:52 - read a property so this property we have
55:55 - here default location we refer to this
55:58 - as a read-only property now if you want
56:01 - to set the value of this property from
56:03 - the outside we define a setter so in
56:06 - this object we add another key value
56:09 - pair the key is set which is a special
56:12 - keyword and the value is a function now
56:15 - this function takes an argument called
56:17 - value we can set this default location
56:21 - that is value but what is interesting is
56:24 - that because we are using a function in
56:27 - this function we can perform some
56:30 - validation for this value before setting
56:33 - the default location for example
56:38 - we can write a simple logic like this
56:41 - if value that X is falsey or value that
56:48 - Y is false e we can throw a new error
56:53 - again error as a built-in constructor
56:57 - that we use to create error objects we
57:00 - pass a string invalid location so this
57:05 - is the benefit of a setter now we can
57:09 - come here and set circle duck default
57:13 - location let's see what happens if we
57:16 - set this to 1 save the changes and
57:19 - here's our error invalid location so to
57:22 - recap use object at define property to
57:26 - define getters and/or sellers
57:35 - here is a great exercise for you I want
57:38 - you to use what you have learned in this
57:39 - section and design a stopwatch object
57:42 - like this so let me show you how this
57:44 - behaves I'm going to define a constant
57:47 - called SW and set it to a new stop watch
57:51 - so that's our stopwatch object now this
57:56 - object has a few members duration which
57:59 - is a property as well as three methods
58:02 - reset start and stop and the other
58:05 - members you see here they are inherited
58:07 - from the base object okay now initially
58:12 - duration is zero we can start the
58:17 - stopwatch now at this time if we call
58:19 - start again it's gonna scream at us
58:22 - stopwatch has already started so we
58:25 - cannot call start twice now we can call
58:28 - stop and again we cannot call stop twice
58:31 - in a row it's gonna complain because
58:34 - stopwatch is not started now we can
58:37 - access the duration property so
58:40 - stopwatch oops sorry
58:42 - so stopwatch dot duration
58:46 - so this stopwatch counted 19 seconds
58:49 - from the moment I called the start
58:51 - method until I called the stop method
58:54 - now we can repeat so if we call start
58:58 - again now it continues counting and then
59:02 - we call stop and then let's look at the
59:05 - duration again now it's a total of 20
59:08 - seconds we can also call reset and this
59:13 - takes the stopwatch to its initial State
59:15 - so we can call start and then stop and
59:20 - then look at the duration only 2 seconds
59:23 - ok so this is how this stopwatch works
59:26 - now I want you to go ahead and spend
59:29 - about 30 minutes on this exercise use
59:31 - what you have learned and do your best
59:33 - to implement an object that behaves like
59:35 - this
59:36 - in the next lecture I'm going to show
59:38 - you my solution
59:43 - alright here's my implementation of the
59:46 - stopwatch object now don't worry if your
59:48 - implementation is different from mine
59:50 - chances are it's gonna be different
59:52 - because there is no one solution to a
59:54 - given problem as long as your stopwatch
59:56 - behaves like what I showed you in the
59:58 - last lecture and it has a clean
60:00 - implementation your solution is
60:02 - perfectly fine so here we have a
60:04 - function called stopwatch this is a
60:06 - constructor function I have defined a
60:09 - few private variables here start time
60:12 - and time running to see if the stopwatch
60:15 - is running or not and duration which you
60:18 - have initially set to zero you can see
60:21 - we have three methods here start stop
60:24 - and reset and I've also defined a
60:27 - read-only property called
60:29 - duration look here we have a getter
60:32 - which simply returns this duration which
60:34 - is a local variable in this function
60:36 - okay
60:37 - now let's take a look at the
60:39 - implementation of each of these methods
60:41 - so start first we have a validation
60:45 - check if the stopwatch is running we
60:48 - simply throw a new error with this
60:51 - message stopwatch has already started
60:53 - otherwise we set running to true and set
60:58 - start time to the current day time very
61:01 - simple implementation the stop method is
61:04 - very similar so first we have a
61:07 - validation check if it's not running
61:09 - obviously we cannot stop it
61:11 - that's why we throw a new error
61:13 - otherwise we set running to false next
61:17 - we set n time to the current date time
61:19 - and then we calculate the second between
61:23 - the end time and start time so we call n
61:26 - time that get time and subtract it from
61:30 - start time get time this expression
61:33 - returns the milliseconds between these
61:35 - two date objects so we divided by a
61:37 - thousand to get the seconds and then add
61:40 - that to the duration variable which we
61:43 - defined earlier and finally let's take a
61:46 - look at the reset method here we simply
61:49 - set these variables to their initial
61:51 - value so we set start time and end time
61:54 - to null running to false and
61:57 - to zero so once again if your
62:00 - implementation is different don't worry
62:01 - there is no one best solution to a given
62:04 - problem if I come back and solve this
62:06 - problem in a month from now chances are
62:08 - my implementation is gonna be different
62:10 - from what you see right now
62:14 - well hello it's me mash again I wanted
62:17 - to say thank you very much for watching
62:19 - this tutorial to the end I hope you
62:21 - learned a lot please share and like this
62:23 - video to support me if you want to learn
62:25 - more about object-oriented programming
62:26 - as I told you before I have a course
62:28 - called object-oriented programming in
62:30 - JavaScript this video you have been
62:32 - watching is the first hour of that
62:34 - course if you want to learn more click
62:36 - on the link in the video description and
62:38 - enroll in the course if not that's
62:41 - perfectly fine
62:42 - make sure to subscribe to my channel
62:43 - because I upload new videos every week
62:46 - thank you and have a great day

Cleaned transcript:

so what is objectoriented programming objectoriented programming is a programming paradigm or a style of programming that is centered around objects rather than functions it's nothing new it's been around since the 70s but unlike tools and frameworks that come and go objectoriented programming is still very relevant today that's because it's not a programming language or a tool it's a style of programming or a programming paradigm there are several programming languages out there that support objectoriented programming such as csharp Java Ruby Python JavaScript and more now JavaScript is a little bit controversial but I'll get to that later it may interest you to know that many of the popular frameworks out there that you might be using are actually designed with objectoriented programming concepts in mind angular is an example of these frameworks so objectoriented programming is a very popular style of programming and it comes up in many technical interviews so if you really want to be a serious developer you need to understand objectoriented programming as a technical interviewer myself if I see a candidate with objectoriented programming under resume that candidate stands out to me and that's where this crash course comes in in this course you're going to learn and understand objectoriented principles and how to implement them in JavaScript my name is Mohamad ani and i'm going to be your instructor in this course if you enjoyed this video please like and share it with others and be sure to subscribe to my channel for new videos every week you can also follow me on twitter as Masch a Madani so now let's get started a popular interview question concerns the four core concepts in objectoriented programming this concepts are encapsulation abstraction inheritance and polymorphism let's look at each of these concepts before objectoriented programming we had procedure of programming that divided a program into a set of functions so we have data stored in a bunch of variables and functions that operate on the data this style of programming is very simple and straightforward often it's what you learn as part of your first programming subject at a university but as your programs grow it will end up with a bunch of functions that are all over the place you might find yourself copying and pasting lines of code over and over you make a change to one function and then several other functions break that's what we call spaghetti code there is so much interdependence e between all these functions it becomes problematic objectoriented programming came to solve this problem in objectoriented programming we combine a group of related variables and functions into a unit we call that unit an object we refer to these variables as properties and the functions as methods here's an example think of a car a car is an object with properties such as make model and color and methods like start stop and move now you might say what marche we don't have cars in our programs give me a real programming example ok think of the local storage object in your browser's every browser has a local storage object that allows you to store data locally this local storage object has a property like length which returns the number of objects in the storage and metals like set item and remove item so in objectoriented programming we group related variables and functions that operate on them into objects and this is what we call encapsulation let me show you an example of this in action so here we have three variables base salary over time and rate below these we have a function to calculate the wage for an employee we refer to this kind of implementation as procedural so we have variables on one side and functions on the other side they're hard decoupled now let's take a look at the objectoriented way to solve this problem we can have an employee object with three properties a salary over time and rate and a method called get wage now why is this better well first of all look at the get wage function this function has no parameters in contrast in a procedural example our get wage function has three parameters the reason in this implementation we don't have any parameters is because all these parameters are actually modeled as properties of this object all these properties and get wage function they are highly related so they are part of one unit so one of the symptoms of procedure code is functions with so many parameters when you write code in an objectoriented way your functions end up having fewer and fewer parameters as Uncle Bob says the best functions are those with no parameters if fewer the number of parameters the easier it is to use and maintain that function so that's encapsulation now let's look at abstraction think of a DVD player as an object this DVD player has a complex logic board on the inside and a few buttons on the outside that you interact with you simply press the play button and you don't care what happens on the inside all that complexity is hidden from you this is abstraction in practice we can use the same technique in our objects so we can hide some of the properties and methods from the outside and this gives us a couple of benefits first is that we'll make the interface of those objects simpler using an understanding an object with a few properties and methods is easier than an object with several properties and methods the second benefit is that it helps us reduce the impact of change let's imagine that tomorrow we change these inner or private methods none of these changes will leak to the outside because we don't have any code that touches these methods outside of their content object we may delete a method or change its parameters but none of these changes will impact the rest of the applications code so with abstraction we reduce the impact of change now the third core concept in objectoriented programming inheritance inheritance is a mechanism that allows you to eliminate redundant code here is an example think of HTML elements like text boxes dropdown lists checkboxes and so on all these elements have a few things in common it should have properties like hidden and inner HTML and matters like click and focus instead of redefining all these properties and methods for every type of HTML element we can define them once in a generic object call it HTML element and have other objects inherit these properties and methods so inheritance helps us eliminate redundant code and finally polymorphism poly means many morph means form so polymorphism means many forms in objectoriented programming polymorphism is a technique that allows you to get rid of long ethanol's or switch and case statements so back to our HTML elements example all these objects should have the ability to be rendered on a page but the way each element is rendered is different from the others if we want to render multiple HTML elements in a procedural way our code would probably look like this but with object orientation we can implement a render method in each of these objects and the render method will behave differently depending on the type of the object viewer referencing so we can get rid of this nasty switch and case and use one line of code like this you will see that later in the course so here are the benefits of object oriented programming using encapsulation we group related variables and functions together and this way we can reduce complexity now we can reuse these objects in different parts of a program or in different programs with abstraction we hide the details and the complex and show only the essentials this technique reduces complexity and also isolates the impact of changes in the code with inheritance we can eliminate redundant code and with polymorphism we can refactor ugly switch case statements to go through this course all you need is a code editor and a simple web server the editor that I'm gonna use here is Visual Studio code or vs code that you can download from code that Visual Studio calm but feel free to use any editors now with vs code we have this extensions panel here search for live server this is a very simple and lightweight server that we're going to use to serve our application so install is and then here in the files panel let's add a new file index dot HTML now to generate some basic HTML template we can simply type an exclamation mark and press tab so a very basic HTML template now let's add a script element so script with source set to index J s we're gonna write all our JavaScript code inside of this file so let's add a new file and save it as index that J s and finally to make sure that we have setup everything properly let's do a console that log of hello world now when you install live server you should get this menu here in the status bar if you don't see that you probably have to restart vs code and if you still don't see it simply rightclick on index.html and select open with live server so this will fire up Chrome pointing to this address now let's open up Chrome developer tools here in the console tab we've got hello world so before going any further I want to emphasize that this course is not for beginners is for intermediate level developers so you should have at least three months of experience programming in JavaScript you should know the basics you should know how to use Chrome developer tools I'm not gonna cover these in this course our focus is purely on object oriented programming with JavaScript javascript is all amount objects so in order to learn objectoriented programming first you need to have a good understanding of objects so in this section I'm gonna cover some fundamental concepts around objects such as creating objects factories and constructors primitives and reference types on how they behave differently working with the properties of an object such as adding removing properties as well as enumerating them you're also gonna learn how to define private properties as well as getters and setters if you know all these topics well feel free to skip this section and move to the next section where I talk about prototypes otherwise continue watching so now let's get started let's start this section by creating an object so I'm gonna use the let keyword in es6 which is the replacement for var so in es5 and before we had var for declaring variables but for has a number of issues when it comes to scoping that's beyond the scope of this course I just want to let you know that as a best practice stop using var use either let or Const with cons you're basically defining a constant so you won't be able to reassign it if you want to reassign a variable use let now in this demo I'm gonna use Const to define a constant so let's call this circle and set it to an object here I'm using object literal syntax so these curly braces we refer to them as object literal syntax an object in JavaScript is essentially a collection of key value pairs so inside these curly braces I'm gonna add a few key value pairs let's add radius and set it to 1 let's add another key like location now this time the value can be an object so again I'm using object literal syntax in this object we can have a couple key value pairs like x and y now let's add another key value pair so the keys draw the value is a function that is for drawing the circle so for now let's just do a simple console.log now I want to define a few terms here this circle object has three members radius location and draw if a member is a function we refer to that as a method so here we say draw is a method these other members are what we call properties now in some JavaScript tutorials that refer to all these members as properties whether there are functions or not but technically in objectoriented programming properties and methods are fundamentally different because a property is used to hold values a function or a method is used to define some logic so now that we have this circle object we can access its members using the dot notation so circle dot look here are the members we can call the draw method now note here on the right side I've got Chrome open this is Chrome developer tools as soon as I save my changes here you will see that Chrome is gonna refresh because here with live server we have hot reloading so save and here's the result so as soon as we change our code the new code is loaded inside Chrome so object literal is a simple way to define an object but we can also define objects using factories and constructors and that's the topic for the next lecture all right now let's imagine we want to create another circle with the current implementation we have to duplicate all this code like this now this can be a problem if we have one or more methods in our object in this case we have this draw method here and as you can see we have duplicated that in two different places so if there is a bug in this method we have to come back and fix it in multiple places now this is a very simple object imagine if the circle object had ten methods so object literal syntax is not a good way to create an object and duplicate it if this object has at least one method if an object has one or more methods we say that object has behavior like a person that can do different things so it has behavior now let's imagine here we didn't have this draw method duplicating this object wouldn't be a big deal so basically we would end up with two objects and then here we could use different values so creating objects with the object literal syntax is an issue only if that object has behavior so what's the solution the solution is to use a factory or a constructor function so let me show you how that works I'm going to delete this second circle and define a function called create circle now I'm gonna move all this code inside this new function like this now we don't need to declare a constant we can simply return this object now this circle requires a radius so instead of hardcoding one here I'm gonna add a parameter here radius and then set that here now in es6 we have this new feature so if the key and the value are the same we can remove the noise in the code by removing the value so we can only add radius now to simplify the code so you can focus on what I'm gonna teach you I'm gonna drop this location property we don't really need it instead I'm gonna add our draw method so key value and let's do a simple console nut lock draw okay so this is what we call a factory function now we can simply call this function to create a new circle so constant circle we call create circle and pass one as the radius now there is another way to create an object using a constructor function so let's delete circle draw and define a constructor function I want you to see them side by side so once again we define a function but the naming convention we use for a constructor function is different the first letter should be uppercase so we call it circle with an uppercase C the developers with background in languages like C sharp and Java this kind of looks like a class however as you can see we're defining a function in JavaScript we don't have the concept of classes so our circle function is gonna take a radius parameter but in the body instead of returning an object we're gonna use that this keyword to set the properties of this object what is this this is basically a reference to the object that is executing this piece of code you're gonna see that in a second so imagine we have a new empty object in memory now we're gonna use this to reference that object and then use dot notation to set various properties on that object so we can set the radius property to this radius argument similarly we can define another property draw but this is more accurately a method so we set it to a function and here we do a console dot log of draw okay now we can create a new circle like this we use the new operator to call the circle function and pass one as the argument let me use the new operator a few things happen under the hood this new operator will create an empty object so like this an empty object then it will set this to point to that object because by default this points to the global object if you're running this code inside of a browser the global object is the window object if you're running it inside a node environment the global object is global let me show you so I'm gonna do a console that log of this let's see what happens so save the changes now look this is this circle object here and here we have two members draw and radius this is because we use the new operator here if I remove that let's see what happens so save the changes now this reference is the window object so this is the global object in a browser we don't want to use this we don't want to mess up with this we don't want to define global variables because they're bad practice because they're available everywhere in our application so it is possible that one function or another will modify the value of these variables accidentally and create bug in our application so when we use the new operator to call a function three things happen first this new operator will create an empty object then it will set this to point to that object and finally it will return that object from this function so note that here we don't have an explicit return statement we are not returning this this will happen automatically when we use the new operator so let me delete this also we don't need console that log here so basically we have two ways to create an object we can use a factory function or a constructor there is nothing special about this they're both regular functions in JavaScript if we return an object in this function we refer to that function as a factory function in contrast if we use that this keyword along with the new operator we refer to that function as a constructor function now you might ask what is the difference between these two patterns for creating an object which approach should you well it really depends who you ask developers coming from languages like C sharp and Java preferred the constructor function syntax because this looks like creating an instance of a class but once again in JavaScript we don't really have classes other developers don't like this approach they prefer to use Factory functions and one of their arguments is what if a developer forgets to use the new operator here then we're defining these property methods on the global object which is in this case the window object but this discussion this argument is really outdated with the modern JavaScript and the tools that are available to us we get an error if we forget to use the new operator here so my suggestion to you is not to get hung up and this religious arguments about factories versus constructors as a developer you should be familiar with both these patterns because as you work on different projects and different teams you will see both of these patterns for creating an object so you should understand how they work choose the pattern that you prefer every object in JavaScript has a property called constructor and that references the function that was used to construct or create that object so here we have two objects circle and another let's look at the constructor property so here on the console another dot constructor so as you see this returns our circle function that we use to create this object now let's look at circle dot constructor what is this well you can tell that this is a function because here we have this blue F and as you can see the first letter of this function is uppercase so this is a builtin constructor function in JavaScript when we create an object using the object literal syntax internally the JavaScript engine uses this constructor function let me show you so I'm gonna temporarily delete all this code let's define an object like this let me use this syntax object literal JavaScript engine will translate that to something like this let x equals new object okay so this circle object we created and returned it from our factory function and because we use the object literal syntax internally it was created using this object constructor function in JavaScript we have a few other builtin constructors for example we have string for creating strings but queen' often we use string literals so single code or double quote or backtick using these literals is cleaner and simpler than using the constructor you also have boolean but again we don't use this we either use true or false so we refer to these as boolean literals we also have number but instead we use number literals like 1 2 3 whatever so this is what I want you to take away every object has a constructor property and that references the function that was used to create an object one of the confusing concepts in JavaScript is that here functions are objects so this circle function we have here is actually an object don't believe me let me show you so circle dot look these are all the members of this circle function or circle object so the purple icons are methods like call bind and apply and the blue icons are properties so let's take a look at a few of these members in the console here in the console circle dot name that returns the name of this function circle the length returns the number of arguments now earlier in the last lecture I told you that every object in JavaScript has a constructor property and that references the function that was used to create an object but here's the interesting part who do you think created this object let's have a look so circle dot constructor so here we have another builtin constructor called function and let me declare a function using this syntax internally JavaScript engine will use this function constructor to create this object let me show you so I'm gonna define a constant called circle one two separate from our circle set it to new function now here our function requires one parameter radius so we add that here as a string now as the second argument I'm gonna pass the code inside of this function so to break it up into multiple lines I'm gonna use the backtick character and then simply copy all this code and put it here so when we declare a function internally it's represented like this now we can call this circle one just like calling our circle function so we can create a circle object by newing up circle one and pass one as the radius save the changes now in the console let's log circle look it's a real circle object with these two members now let's take a look at a couple of methods that are available in our functions so I'm gonna delete all this code circle dot here we have this call method and with this we can call a function look at the arguments the first argument is this argument here we need to pass an empty object and this will reference this object that we pass here okay after that we add our arguments explicitly so here we have one argument we pass one if you had multiple arguments we would pass them explicitly like this okay so this expression is exactly like expression on line 11 when we use the new operator this new operator will internally create an empty object and pass them as the first argument to the call method and this object will determine the context for this so this will reference this object earlier I told you that if you don't use the new operator this by default will point to the global object which is window so if I want to rewrite this expression in this way instead of passing an empty object I would pass window of course we don't want to do this I'm just explaining to you what happens under the hood so let's revert this back so the argument here specifies the target of this okay now we have another method called apply it's exactly like the call method with this we can call a function but instead of passing all the arguments explicitly we pass them in an array so this is useful if you already have an array somewhere else in your application and you want to pass an array as the second argument to the apply method so this is the takeaway in JavaScript functions or objects hi guys Marsh here thank you for watching my youtube tutorial I just wanted to quickly let you know that this video you've been watching is actually the first hour of one of my courses called object oriented programming in JavaScript so when you get to the end of this tutorial if you feel like you want to learn more click on the link in the video description and enroll in the course and if not that's perfectly fine continue watching as the next section is coming up in JavaScript we have two categories of types on one side we have value types also called primitives and the other side we have reference types so in the value types category we have number string boolean symbol which is new in es6 we're going to look at that later in the course as well as undefined and know these are the primitive or value types on the other side we have objects functions and arrays so in the last lecture you learned that functions are also objects the same is true about a race so in a nutshell in JavaScript we have primitives and objects now in this lecture I'm gonna show you how primitives and objects behave differently because this is absolutely important for you to understand before we move on to the next section where I talk about prototypes so on this empty canvas I'm gonna define two primitives x and y I'm gonna set Y to X so here Y is 10 now I'm gonna change the value of x to 20 what I want you to note here is that X and y are two independent variables so I save the changes go back in the console let's log X X is 20 and Y is 10 they are independent so when we work with primitives this value is value that we have here is stored inside of this variable when we copy that variable that value that is stored in the variable is copied into this new variable so they are completely independent of each now let's see what happens if we use a reference type or an object here so I'm gonna change this to an object that has a property called value and then instead of setting X to 20 I'm gonna set X code value to 20 so save the changes back in the console let's log X so you can see by the properties 20 now let's log Y we can see the value property of Y is also 20 so this is the takeaway when we use an object the object is not stored in this variable that object is stored somewhere else in the memory and the address of that memory location is stored inside that variable so then when we copy X into y it's the address or the reference that is copied in other words both x and y are pointing to the same object in memory and when we modify that object using either X or Y the changes are immediately visible to the other variable so here's the conclusion primitives are copied by value reference types or objects are copied by the reference let's take a look at another example so I'm gonna define a function called increase that takes a number and here we simply increase this number by 1 let's declare a number variable and set it to 10 and then call increase and pass this number now if I log this number on the console what do you think we're going to see let's have a look so save the changes we see 10 but dinner we increase the number well when we call increase and pass this number variable its value is copied into this parameter that is local in this function so this number variable here is completely independent of this other number variable here in this function we increment number by 1 so it will be 11 but after this function this number is going to go out of the scope so when we log this number on the console we're essentially dealing with this first number so I told you that primitives are copied by their value so here we're dealing with two independent copies that's why we see ten on the console now let's change this to a reference type or an object so I'm gonna change ten to an object that has a value property okay let's rename this variable to object and similarly I'm going to rename this parameter in this function to object and then increment object dot value now when we log this on the console what do you think we're gonna see we're gonna see eleven see we got this object with value 11 the reason for this is because when we call increase and pass this object this object is passed by its reference so this local parameter that we have here will point to the same object as we defined here so in this case we are not dealing with two independent copies we have two variables that are pointing to the same object so any changes we make to this object will be visible to the other variable so remember this in JavaScript we have value types also called primitives as well as reference types which are objects our primitives are number string boolean symbol undefined and no primitives or value types are copied by their value reference types or objects are copied by the reference all right so here we have our circle constructor function and using that we create a circular object now these objects in JavaScript are dynamic that means after you create them you can add extra properties in them or delete some properties you might be wondering why this is useful in the real world imagine you're working with a user object the client that can be a web or a mobile application is going to send a user object to the server on the server we get this user object and then we add additional stuff to it for example we can add a token property that we generate on the fly on the server so we can always add something extra to an existing object because we don't have classes we don't need to define these properties ahead of time we can add them whenever we need them and this makes JavaScript extremely powerful and easy to work with in languages like C sharp or Java every time we want to implement scenarios like this we have to go back and change our classes so here let me add a new property to our circle object we can set the location here like this save the changes now here on the console let's log circle all right you can see here we have two properties location and radius we also have another notation for accessing properties that is bracket notation so another way to rewrite this code is like this we use brackets and use a string to reference a property so location it's exactly the same as we can see the dot notation is simpler and less verbose than bracket notation but this notation is also useful in certain scenarios for example when you want to dynamically access a property name for example let's imagine we have this constant called property name set to location you have that somewhere in our application now we want to access the location property of a circle if you're dealing with this dynamically at a time of writing the code we don't know what is the name of that property that is calculated at runtime so we can type something like this circle that location but what we can do is use the bracket notation so we use circle brackets property name another use case for using the bracket notation is when you are using the property names that are not valid identifiers for example let's imagine the name of this property is Center location we can access this property like this circle that Center location that doesn't work so if you have special characters or a space that's when you use the bracket notation okay now we can also delete a property from an existing object a real word use case for this is when you get a user object from a database and you want to return it to the client but maybe that user object has certain properties you don't want to send to the client you don't want to send the password you don't want to send the credit card info in that case you will dynamically delete one or more properties from an object so we use the delete operator and then reference the property name so circle dot location again here we can use the dot notation or brackets of course here we need a string sometimes you need to iterate over or enumerate the properties in an object we can do that using the for in loop so for let key in circle so in every iteration key will hold the value of one key in this object let's log that on the console okay so look we have radius and draw so it's returning both properties and methods now if you want to get the value of these properties you can use the bracket notation so here and console the log I'm gonna log circle of key you learn in the last lecture lab we can use the bracket notation to access a member okay so say now you can see radius is 10 and draw as a function what if we want to get only the properties and not the methods well we can use the type of operator to check the type of this value so if typeof circle of key it's not equal to function then we will display it on the console save the changes now we get only the radius there is another approach to get all the keys and an object so it's object that we have has a method called keys we can pass our circle object here and this will return all the keys in the circle as an array so let's store them here and lock them on the console so here we have an array with two members radius and draw with this approach we cannot separate properties from methods now finally sometimes you want to know if an object has a given property for that we use the in operator so if here we add the name of the proper as a string if radius is in circle we do a console that log of circle has a radius okay save the changes and here's our message so remember to enumerate all the members and an object you can use a four in loop to get all the keys and an object use object that keys and to check for the existence of a property or a method in an object use the in operator all right now let's introduce some complexity in this example so I'm going to define another property called default location set it to an object like this also let's define another method compute optimum location we set this to a function and here we're going to do some magic it doesn't really matter what matters is that we're going to call this method inside of the draw method so we call this dot compute optimum location now there is a problem with this implementation let me show you so here when we create the circle object circle dot these are the members of our circle object not all these members should be accessible to me as the consumer or the client of this object for example what would happen if I set default location to false it's gonna completely mess up with this object or as another example maybe this compute method should only be called inside of the draw method so if I accidentally call it here circle the compute optimum location maybe this will put this object in a bad state and then if I call circle but draw we're gonna get a weird error at runtime so in objectoriented programming we have this core concept called abstraction abstraction means we should hide the details and complexity and show or expose only the essentials in this particular example we should hide this property default location as well as this method these are implementation details these are part of the complexity of this object we want to hide these from the consumers of this object instead we want to expose only the essentials that is the radius and the draw method let me give you a metaphor think of a DVD player a DVD player has a complex logic board on the inside but only a few buttons on the outside that you interact with so what we have on the inside is the implementation detail and what we have on the outside is the public interface of it we player we want our objects to look like this DVD player we want to hide all the details all the unnecessary complexity on the inside and expose only a few members or a few buttons on the outside a lot of developers who have not been able to apply objectoriented programming effectively have failed to comply with this principle everything in their objects is public and accessible from the outside and this will bring a number of issues one issue is that every time you change the implementation of that object you have to go and modify many different places in your code for example let's imagine now this compute method requires an argument let's add a factor argument here with the current implementation because we can access this from the outside everywhere we have used this method you have to come back and pass an argument so one simple change in the implementation of an object results in a number of changes in your source code in contrast imagine if this method was not accessible from the outside then we wouldn't have to modify this line it would only modify line 12 where we have called this function right so remember the abstraction principle of objectoriented programming hide the details and expose only the essentials in the next lecture I'm going to show you how to implement this in JavaScript so how do we implement abstraction here you want to hide certain members from the outside so earlier you learned that this references that new circle object now what happens if I declare a local variable in this function let's say color we set that to red is this going to be part of that object of course not because we have not set that as a property on that object we didn't set this that color to color okay so this is only a local variable inside of this function when we get out of this function this variable goes out of scope and dies now with this technique we can easily hide certain members from the outside so default location is implementation detail we don't want this to be accessible from the outside instead of setting it as a property on our new object we define it as a local variable here okay now we don't need this color anymore by the same token we can convert this method to a private method so let compute be a function now here in the draw method recalling compute optimum location this function will no longer be a method on this new object so we can access it using this you have to access it directly here this will work because in JavaScript we have this concept of closure if you don't know closure let me simplify it for you so here we have one function and another function inside of that function in this function we can declare certain variables like X and Y and these are local variables that are only available in this function their scope is limited to this function so when we finish executing this function x and y will go out of scope in contrast to scope we have closure a closure determines what variables will be accessible to an inner function so this function will be able to access all the local variables defined here as well as the variables defined in its parent function so here we declare it two variables compute optimum location which is a function as well as default location these are the variables that are defined in this parent function they are within the scope of this function but within the closure of this inner function now don't confuse closure with a scope because the scope is temporary and it dies so every time we call the draw method these variables will be recreated and reinitialized and then after this function they will die so scope is temporary but closure stays there so when we call the draw function after we finished executing this function these variables will continue to stay in memory they will preserve their state because they are part of the closure of this draw function okay so back here so in this method if you want to access those private members you simply use them here you can also use default location default location but if you want to access members of this new circle object you need to use this so this dot radius as an example okay now with this simple change we basically replace this with let let's see what happens if I access the members of the circular object we only see draw and radius so the public interface of this object is simpler is easier to work with and this will also prevent issues later down the road so in the last lecture we converted these two members to private members now more accurately these are not private members of the circle object because technically they are not inside of a circle object there are local variables that we have defined inside of this circle function but from an objectoriented point of view we can refer to them as private members of the circle object now I want to simplify the code here so we can focus on a small issue I'm gonna delete this compute function right so we have this private property default location we cannot access this from the outside but what if we want to display that default location somewhere in our application so we don't wanna modify it we just want to be able to read it so one solution is to define a method here this dot get default location we set it to a function and in this function we simply return default location once again we're dealing with an inner function here the closure of this function includes all the variables defined here as well as all the variables defined and its parent functions so here we have access to default location and with this we can call circle dot get default location however I don't like this syntax I don't like the fact that we're calling this as a method it would be nicer if we could access this property like this default location but we shouldn't be able to set this from the outside we can only read it so let me show you how to define a property like that so this object that you have seen so far has a method called define property we have another method called defined properties if you want to define multiple properties in one go now the first argument of this method is the object that we want to add a new pretty now the object is the one that is referenced by this the new circle object right so we pass that here the second argument is the name of our property we want to call that default location and the third argument is an object in this object we add a key value pair the key is get this is a special keyword for JavaScript and the value is a function so when we access circle dot default location this function will be called okay now here we can simply return default location again this variable is part of the closure of this inner function so here we can access it right now in vs code you don't see that in intellisense so we don't have default location as a property however if we save the changes oops I made a mistake here actually I should have used define property so save the changes all right so now look at the circle object circle so here's our new property default location you can see dot dot dot in front of it because this is a computed property when we click this that get function will be executed and here's the result our default location okay also you can see that function is stored here as a getter so a getter is a function that is used to read a property so this property we have here default location we refer to this as a readonly property now if you want to set the value of this property from the outside we define a setter so in this object we add another key value pair the key is set which is a special keyword and the value is a function now this function takes an argument called value we can set this default location that is value but what is interesting is that because we are using a function in this function we can perform some validation for this value before setting the default location for example we can write a simple logic like this if value that X is falsey or value that Y is false e we can throw a new error again error as a builtin constructor that we use to create error objects we pass a string invalid location so this is the benefit of a setter now we can come here and set circle duck default location let's see what happens if we set this to 1 save the changes and here's our error invalid location so to recap use object at define property to define getters and/or sellers here is a great exercise for you I want you to use what you have learned in this section and design a stopwatch object like this so let me show you how this behaves I'm going to define a constant called SW and set it to a new stop watch so that's our stopwatch object now this object has a few members duration which is a property as well as three methods reset start and stop and the other members you see here they are inherited from the base object okay now initially duration is zero we can start the stopwatch now at this time if we call start again it's gonna scream at us stopwatch has already started so we cannot call start twice now we can call stop and again we cannot call stop twice in a row it's gonna complain because stopwatch is not started now we can access the duration property so stopwatch oops sorry so stopwatch dot duration so this stopwatch counted 19 seconds from the moment I called the start method until I called the stop method now we can repeat so if we call start again now it continues counting and then we call stop and then let's look at the duration again now it's a total of 20 seconds we can also call reset and this takes the stopwatch to its initial State so we can call start and then stop and then look at the duration only 2 seconds ok so this is how this stopwatch works now I want you to go ahead and spend about 30 minutes on this exercise use what you have learned and do your best to implement an object that behaves like this in the next lecture I'm going to show you my solution alright here's my implementation of the stopwatch object now don't worry if your implementation is different from mine chances are it's gonna be different because there is no one solution to a given problem as long as your stopwatch behaves like what I showed you in the last lecture and it has a clean implementation your solution is perfectly fine so here we have a function called stopwatch this is a constructor function I have defined a few private variables here start time and time running to see if the stopwatch is running or not and duration which you have initially set to zero you can see we have three methods here start stop and reset and I've also defined a readonly property called duration look here we have a getter which simply returns this duration which is a local variable in this function okay now let's take a look at the implementation of each of these methods so start first we have a validation check if the stopwatch is running we simply throw a new error with this message stopwatch has already started otherwise we set running to true and set start time to the current day time very simple implementation the stop method is very similar so first we have a validation check if it's not running obviously we cannot stop it that's why we throw a new error otherwise we set running to false next we set n time to the current date time and then we calculate the second between the end time and start time so we call n time that get time and subtract it from start time get time this expression returns the milliseconds between these two date objects so we divided by a thousand to get the seconds and then add that to the duration variable which we defined earlier and finally let's take a look at the reset method here we simply set these variables to their initial value so we set start time and end time to null running to false and to zero so once again if your implementation is different don't worry there is no one best solution to a given problem if I come back and solve this problem in a month from now chances are my implementation is gonna be different from what you see right now well hello it's me mash again I wanted to say thank you very much for watching this tutorial to the end I hope you learned a lot please share and like this video to support me if you want to learn more about objectoriented programming as I told you before I have a course called objectoriented programming in JavaScript this video you have been watching is the first hour of that course if you want to learn more click on the link in the video description and enroll in the course if not that's perfectly fine make sure to subscribe to my channel because I upload new videos every week thank you and have a great day
