With timestamps:

00:02 - hi my name is Muhammad Ali and I'm going
00:05 - to be instructor over the next few hours
00:07 - in this course you're going to learn
00:09 - everything about angular from the basic
00:11 - to the advanced topics and you will
00:13 - build and deploy a real ecommerce
00:15 - application using angular firebase and
00:18 - the new awesome bootstrap for let me
00:21 - show you a demo of this application real
00:23 - quick we're gonna build an e-commerce
00:30 - application for an imaginary organic
00:34 - shop so here on the home page we have
00:36 - master detail you can select the
00:39 - category and see all the products in
00:43 - that category you can add a product or a
00:46 - shopping cart
00:48 - change the quantity and the number of
00:52 - items in a shopping cart
00:54 - it's updated in real time and here's our
00:58 - shopping cart again here we can change
01:01 - the quantity for each item and the total
01:05 - price as well as the total number of
01:08 - items in the shopping cart get updated
01:10 - immediately if I open another tab and
01:14 - add another product to our shopping cart
01:17 - what we have on the shopping cart tab
01:19 - gets updated automatically without me
01:23 - having to refresh the page so all the
01:26 - data we show to the user is in sync
01:28 - everywhere in the application and this
01:31 - is the beauty of a real-time application
01:34 - now let's check out here we have a
01:38 - shipping form and the summary of all the
01:41 - products in our shopping cart and again
01:44 - this summary gets updated as soon as I
01:47 - make a change or a shopping cart in
01:49 - another tab once we place this order it
01:53 - will be visible to our admins so I'm an
01:56 - admin user and I have this menu here
01:59 - manage orders
02:01 - here we can see all the orders in the
02:04 - application other users will not see
02:07 - this page here so here we have
02:09 - authentication and authorization as an
02:13 - admin I can also manage the products so
02:17 - here we have all the crud operations we
02:20 - can quickly search for a product you can
02:24 - sort the data resize the columns or
02:29 - navigate to a different page these are
02:33 - the patterns that you see in a lot of
02:36 - real-world applications and in this
02:38 - course you're going to learn how to
02:40 - implement these patterns in your
02:42 - applications
02:45 - so are you excited to learn angular and
02:47 - build this application then let's jump
02:50 - in and get started so in case you're an
02:56 - absolute beginner with angular let me
02:58 - quickly explain in two minutes what
03:00 - angular is and why you should learn it
03:02 - angular is a framework for building
03:04 - client applications
03:06 - in HTML CSS and either JavaScript or a
03:11 - language like typescript that compiles
03:13 - to JavaScript a typescript is more
03:15 - common in the angular community because
03:18 - angular itself has been written with
03:20 - typescript now if you have never worked
03:22 - with typescript before don't worry at
03:23 - all it's very easy and you're gonna get
03:25 - familiar with it in this course now one
03:28 - question that a lot of beginners have is
03:30 - why do we need angular can we not use
03:32 - plain old JavaScript or jQuery we
03:35 - certainly can and that's how a lot of
03:38 - web applications out there are built but
03:40 - as our applications get more complex
03:42 - vanilla JavaScript or jQuery code
03:45 - becomes hard to maintain we need a way
03:48 - to properly structure our application
03:50 - sure there are JavaScript patterns out
03:52 - there that help us with the structuring
03:54 - but these patterns are hard to
03:56 - understand for a lot of beginners to
03:58 - JavaScript plus a lot of applications
04:01 - built with vanilla JavaScript or jQuery
04:03 - are hard to test and that's why over the
04:07 - past few years various frameworks have
04:09 - been built and evolved to make web
04:12 - application development easier angular
04:15 - is an example of such frameworks it
04:17 - gives our applications a clean and
04:19 - loosely coupled structure that is easy
04:21 - to understand and easy to maintain it
04:24 - also brings in a lot of utility code
04:26 - that we can reuse in various
04:28 - applications especially when dealing
04:30 - with the users navigation and the
04:31 - browser history plus applications built
04:34 - with angular are more testable so we can
04:37 - easily write automated tests to test
04:40 - various parts of our application as I
04:42 - will show you later in the course so to
04:44 - answer this question no you don't need a
04:46 - framework like angular to build client
04:48 - applications but using angular makes
04:51 - your life a lot easier
04:54 - all right now that you know what angular
04:57 - is let's take a look at the architecture
04:59 - of angular applications a lot of modern
05:03 - applications have at least two parts a
05:05 - front end and a back end the front end
05:08 - also called the client is the part that
05:11 - runs in a web browser and this is what
05:14 - the user sees and interacts with so it
05:17 - essentially includes the user interface
05:19 - or UI of an application we use HTML CSS
05:24 - typescript and angular to build the
05:26 - front end the back end sits on a web
05:29 - server or multiple web servers in the
05:31 - cloud and is responsible for storing the
05:34 - data and doing any kind of processing
05:37 - our front end or the client app talks to
05:40 - the back end to get or save the data one
05:44 - of the questions that a lot of beginners
05:45 - ask me is maash how do I save my data in
05:48 - angular well you don't in most cases you
05:52 - don't save the data on the client
05:53 - because it can easily disappear as the
05:56 - user clears the browser data or moves to
05:59 - a different computer that's why we store
06:02 - the data on the server so here we often
06:04 - have one or more databases as well as a
06:08 - bunch of HTTP services or api's to make
06:11 - this data available to the clients in
06:14 - case you don't know API stands for
06:16 - application programming interface now if
06:20 - you put this fancy name aside these HTTP
06:23 - services or AP eyes are essentially
06:26 - endpoints that are accessible via the
06:28 - HTTP protocol so we can call them using
06:32 - simple HTTP requests to get or to save
06:35 - the data if that's too much technical
06:37 - jargon here let me give you a metaphor
06:39 - think of a port where ships load or
06:43 - unload these are points to get loads in
06:47 - and out of a town right now imagine
06:50 - these ports are HTTP endpoints ships are
06:53 - HTTP requests and loads are data so just
06:57 - like we can send a ship to a port to get
06:59 - some load and bring to us a client app
07:02 - sends an HTTP request to an endpoint to
07:05 - get some data so this is how the
07:08 - big picture works our web applications
07:10 - have a front end and a back end on the
07:12 - back end we have one or more databases
07:15 - and API is that make the data available
07:18 - to the clients for a larger application
07:21 - around a complex domain this is where we
07:24 - implement the business logic of the
07:26 - application like calculating the tax and
07:29 - shipping cost based on various
07:31 - parameters the front end or the client
07:34 - on the other hand is all about the
07:36 - presentation so here we have our HTML
07:40 - templates as well as the presentation
07:42 - logic of our application this logic is
07:45 - all about displaying data and responding
07:49 - to user actions like what should happen
07:51 - when the user clicks on a button or
07:53 - navigates away from a page these are
07:56 - examples of the presentation logic or
07:59 - the logic that is all about the
08:00 - presentation aspect of an application
08:03 - now in terms of the implementation
08:05 - building the backend requires
08:08 - familiarity with other languages and
08:10 - frameworks and it's completely outside
08:12 - the scope of building client apps with
08:14 - angular
08:15 - so as an angular or a front-end
08:17 - developer you don't have to worry about
08:19 - this this is the job of a back-end
08:21 - developer or a full stack developer who
08:24 - knows both the front end and the back
08:26 - end so for the purpose of this course
08:29 - we're gonna focus on the front end and
08:31 - if you want to learn about the backend
08:33 - development you can always pick up a
08:35 - course later down the road but for now
08:37 - let's just focus on one thing and do it
08:40 - well
08:42 - all right in this lecture I'm gonna show
08:44 - you how to set up your development
08:45 - environment and create your first
08:47 - angular project so the first thing you
08:50 - need to install is the latest version of
08:52 - node in case you have never worked with
08:55 - node before it's basically a runtime
08:57 - environment for executing JavaScript
08:59 - code outside the browser in this course
09:03 - we're not gonna work with node but note
09:05 - provides some tools that we need to
09:07 - build angular projects so if you have an
09:10 - installed node head over to node.js org
09:13 - on this page you can see the latest
09:15 - version of node for your operating
09:17 - system
09:17 - so here the latest stable version is
09:20 - 6.11 and the latest version is version 8
09:24 - now this latest version has more
09:27 - features but it's not quite stable yet
09:29 - so go ahead and install the latest
09:32 - stable version when you do that open up
09:35 - the terminal on Mac or command prompt on
09:38 - Windows and type node - - version so you
09:43 - can see on my machine I'm running node
09:45 - version 6 point the minimum version
09:48 - required for building angular
09:49 - applications is version 6.9 once you
09:53 - have node then we're gonna use a tool
09:55 - called node package manager or NPM to
09:59 - install third-party libraries one of
10:02 - these libraries we're going to install
10:03 - in this lecture is angular CLI which
10:07 - stands for command-line interface so
10:10 - it's a command-line tool that we use to
10:12 - create a new angular project or generate
10:15 - some boilerplate code as well as create
10:17 - deployable packages so once again in the
10:20 - terminal we run NPM install - G which
10:26 - stands for global and finally the name
10:28 - of the package which is at angular slash
10:32 - CLI
10:33 - if you don't put dash G here angular CLI
10:37 - will be installed only in the current
10:38 - folder and it's not going to be
10:40 - accessible anywhere else now if you're
10:42 - on Mac you need to put sudo at the
10:45 - beginning of this command to execute it
10:47 - as an administrator all right next we
10:50 - need to enter our password
10:54 - this process is going to take a little
10:55 - while all right beautiful we installed
10:59 - angular CLI now to ensure that the
11:02 - installation was successful we can type
11:05 - ng - - version so you can see I'm
11:10 - writing angular CLI version one point
11:13 - one point zero and below that you can
11:15 - see the version of node on my machine
11:17 - once again it's 6.10
11:26 - so with angular CLI in place now we can
11:30 - create a new angular project so we type
11:33 - ng new and let's call this project hello
11:37 - - world so this generates a bunch of
11:42 - files and folders and then it's going to
11:44 - use NPM to download the third-party
11:48 - libraries alright
11:50 - our project is successfully created now
11:53 - to start coding we need a code editor
11:56 - the editor I'm gonna use in this course
11:58 - is Visual Studio code or vs code
12:01 - it's a beautiful cross-platform
12:04 - lightweight editor and you can download
12:06 - at code that Visual Studio comm if you
12:09 - don't like this editor feel free to use
12:11 - any editors that you prefer you can use
12:13 - sublime you can use atom or any other
12:16 - editors now if you're going to use vs
12:18 - code I want you to add it to the path so
12:21 - you can easily open it from the terminal
12:23 - so here if you're using Mac press shift
12:27 - command + P or if you're using Windows
12:30 - press shift ctrl + P this opens up the
12:35 - command palette now here type code look
12:40 - at this command here install code
12:42 - command in path with this we can go to
12:47 - the terminal in the folder where we
12:49 - created a new project hello world simply
12:52 - type code period so this opens up vs
12:56 - code pointing to the current folder now
12:59 - in the next lecture we're going to look
13:00 - at this structure you're gonna learn
13:01 - what files and folders we have here but
13:04 - before we get there let's make sure that
13:06 - this application works so back in the
13:09 - terminal once again we use angular CLI
13:11 - to load our application in a web server
13:14 - so we type ng space serve so now we have
13:22 - a live development server listening on
13:24 - localhost port
13:26 - 4200 and angular CLI also compile our
13:30 - application it generated bundles for
13:32 - JavaScript and CSS files so we can open
13:36 - up Chrome and head over to localhost
13:38 - port
13:39 - 42
13:40 - hundred beautiful this is our first
13:43 - angular app next we're going to look at
13:45 - the structure of our new angular project
13:50 - alright now let's see what files and
13:52 - folders we have in this new project so
13:55 - the first folder we have here is e - e
13:57 - which stands for end to end and this is
14:00 - where we write end-to-end tests for our
14:03 - application if you have not worked with
14:05 - end-to-end tests these are basically
14:07 - automated tests that simulate a real
14:10 - user so we can write code to launch our
14:13 - browser navigate to the home page of our
14:15 - application click a few links here and
14:17 - there fill out a form click a button and
14:20 - then assert that there is something on
14:22 - the page this is an example of an
14:23 - end-to-end test now that's beyond the
14:26 - scope of this course so we don't have to
14:27 - worry about it yet below that we have
14:30 - node modules and this is where we store
14:34 - all the third-party libraries that our
14:36 - application may depend upon now this
14:39 - folder is purely for development so when
14:41 - we compile our application parts of
14:43 - these third-party libraries are put in a
14:46 - bundle and deployed with our application
14:48 - so we're not going to deploy this node
14:51 - modules folder to a server you're going
14:54 - to see this later in the course below
14:56 - that we have the source folder and this
14:59 - is where we have the actual source code
15:01 - of our application so we have this app
15:04 - folder here and inside this folder we
15:07 - have a module and a component so every
15:11 - application has at least one module and
15:13 - one component you're going to get
15:15 - familiar with this components and
15:16 - modules very soon below that we have
15:19 - this assets folder where we store the
15:22 - static assets of our application so if
15:25 - you have any image files and it takes
15:27 - files and icons all of these go here
15:30 - below that we have this environments
15:33 - folder and this is where we store
15:35 - configuration settings for different
15:37 - environments so we have one file for the
15:39 - production environment and the other for
15:42 - the development environment
15:44 - now the other files we have in the
15:46 - source folder are favorite icon which is
15:49 - the icon displayed in the browser we
15:51 - have index dot HTML which is a very
15:55 - simple HTML file that contains our
15:57 - angular application so note that here we
15:59 - don't have any references to a script or
16:02 - a stylesheet
16:03 - these references will be dynamically
16:05 - inserted into his page as I will show
16:07 - you later in the course now below that
16:10 - we have this main file which is a
16:12 - typescript file and this is basically
16:14 - the starting point of our application so
16:17 - in a lot of programming languages we
16:19 - have this concept of the main method
16:21 - which is the starting point of a program
16:23 - we have the same concept in our angular
16:26 - applications so all we are doing here is
16:28 - bootstrapping the main module of our
16:31 - application which is in this case app
16:33 - module so angular loads this module and
16:36 - everything else starts from there we
16:40 - have this polyfills file which basically
16:43 - imports some scripts that are required
16:45 - for running angular because the angular
16:47 - framework uses features of JavaScript
16:50 - that are not available in the current
16:51 - version of JavaScript supported by most
16:54 - browsers out there
16:55 - so these polyfills fill the gap between
16:58 - the features of JavaScript and angular
17:00 - needs and the features supported by the
17:03 - current browsers below that we have
17:06 - styles of CSS and this is where we had
17:10 - the global styles for our application
17:12 - and also each page or each component can
17:15 - have its own Styles as you will see
17:16 - later in the course below that we have
17:19 - test the TS which is basically used for
17:22 - sending them our testing environment
17:24 - again for now we don't have to worry
17:26 - about this outside the source folder we
17:31 - have a configuration file for angular
17:32 - CLI it's pretty standard configuration
17:35 - you don't have to worry about this for
17:37 - the most part below that we have editor
17:40 - config so if you're working in a team
17:42 - environment you want to make sure that
17:44 - all developers in the team use the same
17:47 - settings in their editors so this is
17:49 - where you store your settings we have
17:52 - this get ignore file which is basically
17:54 - for excluding certain files and folders
17:57 - from your git repository if you have not
18:00 - worked with git don't worry it's not
18:02 - something that you need to know in order
18:03 - to build applications with angular it's
18:06 - basically a tool for managing and
18:08 - versioning your source code now below
18:11 - that we have karma that config the Jas
18:14 - which is a configuration file for karma
18:17 - we
18:17 - is a test runner for javascript code
18:20 - again we're not going to worry about
18:22 - running tests at this stage now below
18:24 - that we have an important file package
18:27 - JSON now this is a standard file that
18:30 - every node project has apart from a
18:33 - bunch of basic settings here like the
18:36 - name and version of your application we
18:38 - have this setting here dependencies
18:40 - which determines the libraries that your
18:43 - application is dependent upon so here
18:46 - you can see we have nine references to
18:49 - angular libraries all these libraries
18:51 - start with at angular and after that we
18:55 - have the name of the library so the
18:57 - first library here is for animations if
18:59 - you're not going to use animations in
19:01 - your application you can delete this
19:02 - here so in the future as we use
19:05 - third-party libraries you will see them
19:07 - listed here under the dependencies now
19:10 - below that we also have another setting
19:14 - or another key called dev dependencies
19:16 - and these are the libraries that we need
19:19 - in order to develop this application so
19:22 - we don't need these to run our
19:23 - application on a production server these
19:26 - are purely for a developer machine so
19:28 - here we have a reference to angular CLI
19:30 - which are only too familiar with we also
19:33 - have a few other references to karma
19:35 - which is again a test runner for
19:38 - javascript code now below this package
19:40 - that JSON we have protractor that config
19:44 - the Jas which is basically a tool for
19:47 - running end-to-end tests for angular
19:49 - again we're not gonna worry about it the
19:51 - another file here is TS config which has
19:54 - a bunch of settings for your typescript
19:57 - compiler so your typescript compiler
19:59 - looks at these settings and based on
20:01 - these settings is going to compile your
20:03 - typescript code into JavaScript that
20:05 - browsers can understand again for the
20:08 - most part you don't have to change any
20:10 - of this here just be aware that if in
20:12 - the future in a complex project you need
20:14 - to change your typescript compiler
20:16 - settings this is where you need to apply
20:19 - your changes and finally we have TS lint
20:22 - like JSON which includes a number of
20:25 - settings for TS linked in case you don't
20:28 - know TS lint is a static analysis tool
20:31 - for typescript code so it shakes your
20:33 - typescript code for readability
20:35 - maintainability and functionality errors
20:37 - so this is the basic structure of an
20:40 - angular project
20:43 - all right now let's make a tiny change
20:45 - to this application so in the app folder
20:48 - open up app that component the TS now if
20:54 - you have never worked with JavaScript
20:55 - before don't worry about this code as we
20:58 - go through the course I'm gonna break
20:59 - this up for you so you will know exactly
21:01 - what is happening here so all I want you
21:04 - to do here is to change this string from
21:07 - app to angular app now save the file
21:12 - back in the terminal look at this
21:14 - message webpack compiling so angular CLI
21:18 - uses a tool called web pack which is a
21:21 - build automation tool it gets all our
21:24 - scripts and stylesheets combines them
21:27 - puts them in a bundle and then minify
21:29 - that bundle and this is for optimization
21:31 - so here you can see we have a few
21:33 - bundles like polyfills which includes
21:35 - all the scripts to fill the gap between
21:38 - the version of JavaScript that angular
21:40 - needs and the version of JavaScript
21:42 - supported by most browsers out there we
21:45 - have main bundle which is all the source
21:47 - code of our application we have styles
21:49 - bundle which includes all our style
21:51 - sheets and note that here style sheets
21:53 - are actually stored in a JavaScript
21:55 - bundle you're gonna see that in a second
21:58 - we also have this vendor bundle which
22:00 - includes all the third-party libraries
22:03 - now at the time of recording this video
22:05 - unfortunately angular CLI does not allow
22:08 - you to customize the name of these
22:10 - bundles or add additional bundles but
22:13 - there is a discussion going on and guess
22:15 - how chances are this may change in the
22:16 - future now that aside what I want you to
22:19 - note here is that whenever you change
22:21 - one of your files where that file being
22:23 - a stylesheet a typescript file or an
22:26 - HTML file web pack automatically
22:29 - recompile your application and refreshes
22:32 - your bundles so now here at the bottom
22:34 - you can see web pack compiled
22:36 - successfully now if you go back to the
22:39 - browser look without me even refreshing
22:42 - this page now we have the new title
22:44 - welcome to an angular app so this is a
22:47 - feature of web pack called hot module
22:49 - replacement or hot module reloading so
22:52 - whenever one of the source files is
22:54 - modified web pack automatically
22:56 - refreshes your browser
22:57 - now let's right-click on this page and
23:00 - go to view page source at the bottom of
23:05 - this page look at these script tags so
23:08 - all the bundles that webpack generator
23:10 - it also injected them into our index dot
23:14 - HTML so just to refresh your memory here
23:18 - in index dot HTML look we don't have any
23:21 - references to your style sheet or a
23:22 - script file so this is something that
23:24 - happens at runtime so web pack
23:28 - automatically inject these scripts into
23:30 - our index dot HTML now let's take a look
23:34 - at these Styles that bundle the js-- so
23:38 - basically what we have here is some
23:39 - JavaScript and in the middle of this
23:41 - JavaScript code you can find the Styles
23:44 - used in your application now how this
23:46 - works is a little bit complicated so
23:48 - don't worry about it for now what I want
23:50 - you to know is that all your style
23:52 - sheets are compiled into a Java Script
23:55 - bundle
23:58 - one question that often comes up is
24:00 - what's the difference between angularjs
24:03 - angular 2 and angular for and how did we
24:06 - jump from angular 2 to angular 4 well
24:09 - angularjs was introduced in 2010 as a
24:13 - JavaScript framework for building client
24:16 - applications soon it gained popularity
24:18 - an angular team started adding new
24:21 - features to the core but the framework
24:23 - was not designed with the needs of
24:25 - today's applications in mind plus it was
24:28 - overly complex so angular team decided
24:32 - to rewrite the original framework using
24:34 - typescript and as a result angular 2
24:37 - came out in mid 2016 this new version is
24:41 - entirely different from angular 1 to the
24:44 - extent that you can think of it as a
24:45 - completely different framework now this
24:49 - made a lot of developers unhappy because
24:51 - they had a lot of applications built
24:53 - with angular 1 with each application
24:55 - over a few thousand lines of code that
24:58 - had to be rewritten but overall I
25:01 - personally like the direction that
25:03 - angular team took and how they've
25:05 - rebuilt angular with typescript
25:07 - this is a much better framework it's a
25:09 - lot cleaner and it's a lot easier to
25:11 - understand and to work with now after a
25:14 - few minor upgrades to angular 2
25:16 - something strange happened we were up to
25:19 - angular 2.3 and then all of a sudden and
25:22 - your 4 came out so a lot of developers
25:25 - including myself wondered what happened
25:28 - to angular 3 we thought we made
25:30 - something really big here but unlike
25:32 - angular 2 angular 4 was not a new
25:35 - framework with a lot of breaking changes
25:37 - in fact it wasn't even a major upgrade
25:39 - so let me explain what happened
25:42 - angular consists of a few different
25:44 - libraries that are distributed as
25:46 - separate node packages via NPM for
25:50 - example we have the core library that we
25:52 - use in every application we have angular
25:54 - compiler we have angular HTTP for
25:57 - calling HTTP services we have angular
26:00 - router for adding navigation to
26:03 - applications and a few other libraries
26:05 - now all these libraries were version the
26:08 - same except the router library
26:12 - in order to align these versions and
26:13 - avoid confusion in the future angular
26:16 - team decided to go straight to an
26:18 - angular version 4 so in a sense angular
26:21 - 4 is not a major upgrade to angular 2
26:24 - and you can think of it as angular 2.4
26:26 - as simple as that
26:27 - now after all this confusion in the
26:30 - community about angular versions the
26:33 - team decided to drop the version suffix
26:35 - and simply call the framework angular so
26:38 - now we have two kinds of angular we have
26:41 - angularjs which is the first generation
26:43 - of angular written in JavaScript and
26:46 - it's going to die sooner or later and we
26:49 - also have angular which refers to
26:51 - angular 2 or later in our discussions in
26:54 - our articles and whenever we want to
26:57 - talk about angular 2 or later we should
26:59 - really use the word angular like I'm
27:01 - gonna angular developer instead of I'm
27:03 - gonna angular 2 developer or I'm an
27:06 - angular 4 developer see it's really
27:07 - weird we should use versions only when
27:11 - we need to talk about a specific release
27:13 - for example when we want to upgrade
27:15 - angular 4 to angular 5 then everybody
27:19 - knows what is the scope of this upgrade
27:21 - and what are the potential breaking
27:23 - changes that can impact an application
27:26 - so this is all about angular version
27:28 - history
27:31 - right now let me quickly give you an
27:33 - overview of how AB structured this
27:35 - course and how we can get the most out
27:38 - of it in the shortest possible time so
27:41 - in this course we have three parts
27:43 - essentials advanced topics and the final
27:47 - project we're going to start the
27:49 - essential part with an introduction to
27:51 - typescript and an object-oriented
27:53 - programming this will prepare you to
27:56 - build angular applications so then we'll
27:59 - look at angular fundamentals displaying
28:02 - data and handling events components
28:04 - directives template driven forms
28:07 - reactive forms consuming HTTP services
28:11 - routing and navigation authentication
28:14 - and authorization deployment and
28:17 - building real-time applications with
28:20 - firebase so these are the essentials
28:22 - that you will use frequently in
28:25 - real-world applications then we get into
28:27 - the territory of the advanced topics and
28:29 - my advanced I don't mean complicated I
28:32 - mean anything that is beyond the basics
28:34 - so in this part of the course I will
28:37 - cover animations angular material redux
28:41 - architecture unit testing and
28:43 - integration testing and over the last
28:46 - part we'll build that ecommerce
28:49 - application that I showed you at the
28:50 - beginning of the course this part also
28:53 - includes a few sections and in each
28:56 - section we'll build one module of
28:58 - functionality in this application so
29:00 - here we have sections like product
29:02 - management shopping cart checkout and so
29:05 - on now I understand that you might be
29:08 - busy and not have enough time to watch
29:10 - the entire course and that's perfectly
29:13 - fine
29:13 - so I'm gonna give you a shortcut a
29:16 - shortcut that allows you to get the most
29:19 - out of the course within the shortest
29:21 - possible time start with the essentials
29:24 - watch all these sections in sequence but
29:27 - feel free to skip the section called
29:30 - reactive forms because we're not going
29:33 - to use the materials in this section in
29:34 - our final project also you can skip
29:37 - consuming HTTP services as well as
29:40 - authentication and authorization you
29:43 - need to watch these sections if you want
29:45 - to be
29:45 - old back-end for your application using
29:48 - frameworks such as a speed add net
29:50 - Express Django and so on but this
29:53 - ecommerce application will build in this
29:55 - course doesn't have a custom built
29:58 - back-end we use firebase as the backend
30:01 - so things are a little bit different
30:03 - here
30:03 - if this sounds confusing to you don't
30:05 - worry I will clarify it in the section
30:07 - about firebase so here's my suggestion
30:10 - to you watch these sections in the
30:12 - essential part in sequence and then move
30:15 - to the final project part I want you to
30:18 - build this application because that's
30:20 - where you will see all these moving
30:21 - parts coming together plus those
30:24 - sections include tons and tons of tips
30:27 - and techniques that I've shared with you
30:29 - and these are the things I have learned
30:31 - over the past 17 years of working in the
30:34 - industry as a professional software
30:36 - developer they really change your
30:38 - thinking about programming and software
30:40 - engineering I've worked really hard for
30:43 - these sections and I want you to watch
30:44 - them once you finish the project then
30:47 - you will have a good understanding of
30:49 - the big picture then you can come back
30:51 - and learn about the other sections in
30:52 - the course in isolation depending on
30:55 - your needs for example if you want to
30:58 - learn how to add animations to your
30:59 - applications you can simply go watch the
31:02 - animation section or if you want to
31:04 - learn about reactive forms you can just
31:07 - go back to that section so focus on the
31:10 - absolute essentials and then move to the
31:12 - final project hi thank you for watching
31:17 - my angular tutorial if you enjoyed this
31:19 - video please like it and share it with
31:21 - others also you can subscribe to my
31:23 - channel for free new videos every week
31:26 - this video is part of my complete
31:28 - angular course with almost 30 hours of
31:31 - high quality content where you learn
31:34 - everything about angular from the basic
31:36 - to the advanced topics all in one course
31:38 - so you don't have to jump from one
31:40 - tutorial to another in case you're
31:42 - interested you can get this course with
31:44 - a big discount using the link in the
31:46 - video description and if not that's
31:48 - perfectly fine continue watching as the
31:50 - section is coming up in order to build
31:56 - applications with angular you need to be
31:58 - comfortable with type script so in this
32:01 - section I'm going to introduce you to
32:03 - the fundamentals of typescript and
32:05 - object-oriented programming principles
32:07 - so by the end of this section you will
32:10 - have a good understanding of type
32:11 - annotations arrow functions interfaces
32:14 - classes constructors access modifiers
32:18 - properties and modules if you are
32:21 - familiar with this concept and know how
32:23 - to implement them in typescript feel
32:25 - free to skip the section and move on to
32:27 - angular otherwise you really need to
32:29 - watch every lecture in this section so
32:32 - now let's get started
32:36 - so what is typescript typescript is not
32:39 - an entirely new language it's a superset
32:42 - of JavaScript so that means any valid
32:44 - JavaScript code is also valid typescript
32:47 - code but typescript has additional
32:50 - features that do not exist in the
32:52 - current version of JavaScript supported
32:55 - by most browsers out there for example
32:58 - in typescript we have this concept of
33:00 - strong or static typing if you have
33:02 - worked with languages like C sharp and
33:04 - Java you know that in these languages
33:06 - when we define a variable we need to
33:08 - specify the type of that variable now in
33:11 - time script typing is optional so we
33:13 - don't have to use this feature but using
33:15 - this feature makes our applications more
33:18 - predictable and it also makes it easier
33:20 - to debug them when something goes wrong
33:22 - typescript also brings quite a few
33:25 - object-oriented features that we have
33:27 - missed in JavaScript for a long time we
33:29 - have the concept of classes interfaces
33:32 - constructors access modifiers like
33:35 - public and private filled properties
33:38 - generics and so on you're going to learn
33:40 - about this in this section
33:41 - another benefit of using typescript is
33:44 - that with typescript we can catch errors
33:46 - at compile time instead of at runtime
33:49 - well of course not all kinds of errors
33:51 - but a lot of errors so there is a
33:53 - compilation step involved and when we
33:55 - compile our typescript code we can catch
33:57 - these errors and fix them before
33:59 - deploying our application and finally
34:02 - another benefit of using typescript is
34:04 - that we get access to some great tools
34:07 - out there one thing that I personally
34:09 - love about typescript is the
34:11 - intelligence that we get in our code
34:13 - editors again you're gonna see that in
34:14 - this section so typescript is a
34:16 - beautiful language and it's basically a
34:18 - superset of JavaScript so any valid
34:21 - JavaScript code is also valid typescript
34:23 - code now the browsers out there they
34:26 - don't understand typescript and it's
34:28 - very unlikely that they're going to
34:29 - support it in the future
34:31 - so we need to compile or more accurately
34:34 - transpile our typescript code into
34:36 - JavaScript so this is part of building
34:39 - our application whenever we build our
34:41 - application typescript compiler kicks in
34:44 - and it transpires our typescript code
34:47 - into JavaScript code that browsers can
34:49 - understand
34:50 - now that's enough introduction next I'm
34:53 - going to show you how to install
34:54 - typescript and write your first
34:56 - typescript program
34:59 - in this lecture I'm gonna show you how
35:01 - to install time script and write your
35:03 - first typescript program so here we are
35:05 - in the terminal we're not gonna work
35:07 - with angular in this section we're gonna
35:09 - purely focus on typescript so first we
35:12 - need to install typescript globally on
35:14 - our machine so npm install - g which
35:19 - stands for global typescript and of
35:22 - course if you're on Mac get me to put
35:24 - sudo at the front all right beautiful
35:30 - so I've installed the latest version of
35:32 - typescript which is currently version
35:34 - 2.3.4 now we can type TS C which stands
35:38 - for typescript compiler - - version
35:42 - again you can see that I'm running type
35:45 - scribe 2.3.4 alright now I'm going to
35:48 - create a new folder for this section so
35:51 - let's call this TS hello let's go to
35:55 - this folder now here I'm gonna create a
35:57 - new file and open it with vs code so
36:00 - code main TS so now I'm gonna write some
36:06 - plain JavaScript code and I want to show
36:08 - you that all this JavaScript code is
36:10 - also valid typescript code so first I'm
36:13 - going to define a function let's call
36:16 - this log that takes a message and here
36:22 - we simply log that message on the
36:25 - console like this then I'm gonna declare
36:30 - a global variable let's call this
36:33 - message and set it to this string hello
36:36 - world and finally call our log function
36:40 - message so this is just plain JavaScript
36:43 - code right now save back in the terminal
36:48 - we need to transpile this type script
36:50 - file into JavaScript so TSC or
36:54 - typescript compiler may not yes not if
36:58 - you look at the files in this folder
37:00 - look we have main degeus and main dirty
37:03 - s now this transpilation
37:05 - or a compilation step when you're
37:07 - building an angular app happens under
37:10 - the hood so you don't have to manually
37:12 - call the typescript compiler in fact
37:15 - when you've run your application using
37:16 - ng serve angular CLI calls typescript
37:20 - compiler under the hood to transpile all
37:22 - our typescript code
37:24 - alright now let's open our main the J's
37:27 - file so code main is so it's exactly the
37:33 - same code that we wrote but now it's in
37:35 - JavaScript file so all JavaScript code
37:37 - is also valid typescript code now back
37:40 - in the terminal I can execute this code
37:42 - using node so node main is and we got
37:47 - the hello world message on the console
37:49 - so from the next lecture we're going to
37:51 - look at specific features of typescript
37:53 - that we don't currently have in
37:55 - JavaScript
37:58 - all right let's explore typescript by
38:00 - looking at variable declarations so in
38:03 - typescript there are two ways to declare
38:06 - a variable we can use the VAR keyword
38:08 - which you have seen in JavaScript like
38:10 - var number we set it to 1 or we can use
38:13 - the let keyword so let count to be 2 now
38:18 - before I explain the difference I need
38:20 - to clarify that the let keyword is also
38:23 - being added to the JavaScript so
38:25 - JavaScript has a few different versions
38:27 - we have es5 or a chemo script 5 which is
38:31 - the version of JavaScript supported by
38:33 - pretty much all browsers out there it's
38:35 - been around for a long time now we have
38:38 - es6 which is a newer version and it was
38:41 - introduced in year 2015 and from that
38:44 - point the ECMO script team which is the
38:46 - team extending Java Script decided to
38:49 - use the year number instead of the
38:52 - version number so we have a common
38:54 - script 2015 2016 and 2017 now in ECMO
38:59 - script 2015 which is basically es6 we
39:02 - also have this LED keyword but in case
39:05 - you are not familiar with it let me
39:06 - explain how it works so I'm going to
39:10 - define a function let's call it do
39:12 - something it doesn't really matter now
39:15 - here I'm gonna define a for block so var
39:19 - we said I to 0 and as long as I is less
39:23 - than 5 let's increment it here we have a
39:26 - block and then log it on the console now
39:30 - finally at the end of this function I'm
39:32 - gonna log this eye one more time but
39:36 - with the label finally and then I'm
39:41 - gonna call this function here so in the
39:44 - terminal I'm gonna compile this file
39:46 - main that TS and also at the same time
39:49 - run it with node main is note that the
39:55 - value of I at the end is 5 so this is
39:59 - the issue we have when declaring a
40:00 - variable using the VAR keyword so we
40:03 - have declared I here inside this for
40:06 - block but it's also meaningful and
40:08 - available outside the for block now if
40:11 - worked with languages like C sharp or
40:13 - Java you know that we don't have this
40:15 - concept in those languages in JavaScript
40:18 - a variable declared with the VAR keyword
40:21 - is scoped to the nearest function so in
40:24 - this case the nearest function is do
40:26 - something so once we declare I inside
40:29 - this for block it's available anywhere
40:32 - in this function now let's see what
40:34 - happens when we declare this variable
40:36 - using the let keyword so let now look we
40:41 - immediately got and red underline here
40:43 - which indicates a compilation error this
40:46 - is one of the beauties of typescript
40:47 - when you're a writing typescript code
40:50 - you can catch these errors at compile
40:52 - time before you run your application
40:54 - before you deploy it
40:55 - now let's hover our mouse here so this
40:58 - is the error cannot find name I so now I
41:02 - is scoped to the nearest block instead
41:05 - of nearest function and this is the
41:06 - proper way to declare variables which
41:09 - prevents a lot of issues later down the
41:12 - road now I want to clarify something let
41:15 - me see you again Spile back in the
41:17 - terminal first I'm gonna remove main Jas
41:21 - now I'm gonna recompile our main des TS
41:26 - okay we got our error here cannot find
41:28 - name I however if you look at the files
41:32 - in this folder we do have main the GS so
41:35 - even though we have a compilation error
41:37 - the typescript compiler still generated
41:40 - main dejay s let's have a look at the
41:42 - content of this file so this is the code
41:46 - that is generated so by default
41:49 - typescript compiler compiles our
41:51 - typescript code to es 5 or X my script 5
41:54 - which is the older version of JavaScript
41:56 - that is supported by all browsers out
41:58 - there now there we don't have the lead
42:01 - keyword so that's why our compiled code
42:04 - now uses the VAR keyword and this is
42:07 - perfectly valid JavaScript code so I can
42:10 - go into terminal and simply run this
42:13 - code and get the same output as before
42:16 - so what I want to clarify here is the
42:20 - typescript compiler reports these errors
42:22 - but still generate valid
42:25 - scrape coat so here's a takeaway for
42:28 - this lecture from now on anywhere we
42:31 - want to declare a variable we use the
42:32 - lead keyword once again this does not
42:35 - stop the compilation step but at least
42:37 - we can catch the issues earlier during
42:40 - the compile time next we're going to
42:42 - look at different types we have and in
42:44 - typescript
42:46 - in this lecture I'm gonna show you
42:48 - different types we have in typescript so
42:52 - let me start by declaring a variable
42:55 - called count and set it to 5 now if I
42:58 - set this to let's say a character or a
43:01 - string like a note that I immediately
43:04 - get a compilation error here telling me
43:07 - that this a string or a character is not
43:10 - assignable to type number now we can
43:13 - perfectly do this in JavaScript because
43:14 - in JavaScript we can change the type of
43:17 - variables on the fly but in typescript
43:19 - we get a compilation error now once
43:22 - again I want to clarify that we can
43:24 - perfectly compile this using typescript
43:26 - compiler and we will get valid
43:29 - JavaScript code so if I go to terminal
43:32 - and type typescript compiler main the TS
43:35 - now look this is our main de Jas so we
43:39 - have this count variable and we have
43:40 - changed its value we can perfectly
43:42 - execute this no problem
43:44 - however code like this is very likely
43:47 - that it's going to break at some point
43:49 - in the future because chances are we're
43:52 - gonna use this count variable inside a
43:54 - four-block so our program is gonna break
43:56 - at runtime we don't want this to happen
43:58 - right that's one of the reasons it's
44:00 - better to write the same code in
44:02 - typescript so at least we can get a
44:04 - warning during the compilation step now
44:07 - if you hover your mouse over this count
44:10 - variable look at the tooltip you can see
44:14 - a colon and number after a discount so
44:17 - this indicates the type of count
44:19 - variable in our program
44:21 - so here typescript compiler infer that
44:24 - the type of this variable should be a
44:26 - number because we set it to number 5
44:28 - now what if I declare a variable without
44:31 - initializing it let's look at its type
44:34 - its type is now any and that's exactly
44:38 - like the variables
44:39 - with declare in JavaScript so I can set
44:41 - a to one then I can change the value to
44:44 - true and then set it to your string even
44:47 - typescript doesn't complain about this
44:49 - so what's the solution if we don't know
44:52 - the value of a variable ahead of time
44:53 - that's when we use type annotations so
44:57 - here we add : and after that we set the
45:00 - type of this variable like number and
45:03 - then look on the third and fourth lines
45:06 - we got compilation errors now in
45:09 - typescript we have a few different types
45:11 - so we have number which can include any
45:13 - integer or floating-point numbers we
45:17 - have boolean s-- which can be true or
45:19 - false
45:20 - we have strings we have any that you saw
45:25 - earlier we have array so let's say we
45:29 - want to declare an array of numbers we
45:32 - would use a number with square brackets
45:35 - now we can optionally initialize this to
45:38 - an array like this or we can declare an
45:42 - any array and with this we can set this
45:46 - to an array with these values one true a
45:50 - and false of course it's not a good
45:53 - practice we want to avoid this but I'm
45:55 - telling you what is possible with
45:57 - typescript
45:58 - now we also have another type that I
46:01 - absolutely love and that's inna so let's
46:04 - say we are working with a group of
46:05 - related constants like colours so in
46:08 - plain old or vanilla JavaScript we would
46:12 - define constant colours like this so
46:14 - color red we can set this to zero
46:17 - constant color green we set this to one
46:21 - and constant color blue set it to two
46:24 - now this is a little bit verbose in a
46:27 - lot of object-oriented languages we have
46:29 - this concept called enum so we can put
46:32 - all these related constants in a
46:34 - container so in typescript we can
46:37 - declare an enum like this enum all
46:40 - lowercase we give you the name like
46:43 - color now curly braces and here we set
46:46 - the values so red green and blue then we
46:52 - can declare a variable like background
46:55 - color and set it to color dot now look
47:00 - we have intellisense here
47:01 - so this tooltip you see here allows us
47:03 - to complete this code without
47:05 - remembering all the details this is one
47:07 - of the things I love about typescript so
47:10 - let's set the background color to color
47:12 - dot red now in terms of the values the
47:16 - first element here automatically gets
47:19 - the value of zero and each subsequent
47:22 - element gets an incremented value so we
47:26 - don't have to explicitly set these but
47:28 - as a best practice it's better to do so
47:30 - because chances are sometime in the
47:33 - future someone may come here and add a
47:35 - new color here like purple and then
47:37 - purple would automatically become two
47:39 - and the value of blue would change to
47:41 - three so this may break parts of our
47:43 - application so let me revert this by
47:47 - explicitly setting the values if
47:49 - somebody adds a new color here like
47:52 - purple then it will not change the value
47:55 - of blue now let me show you something
47:58 - let's compile this code and see how we
48:00 - get enum in JavaScript so at a script
48:05 - compiler main TS
48:09 - look at this piece of code here this is
48:11 - how we can implement the concept of
48:13 - enums in JavaScript we can see it's very
48:16 - complicated now compare this with how we
48:20 - declare it an enum here it's much
48:22 - cleaner so the more you work with
48:24 - typescript the more you're gonna love
48:26 - this language
48:29 - in this lecture I'm going to show you
48:31 - the concept of type assertions in
48:33 - typescript so I'm gonna start by
48:36 - declaring a variable like message and
48:39 - sitting into your string now here we can
48:42 - type message dot I look we get this
48:45 - beautiful intellisense and in this
48:47 - tooltip we can see all the things we can
48:50 - do with a string so all these items with
48:53 - this purple icons are functions for
48:55 - example we have this function called
48:57 - ends with we can call this and see if
49:01 - this message and let's say we'd see and
49:04 - this returns a boolean so we can store
49:07 - the result in another variable like ends
49:10 - with C however sometimes typescript may
49:17 - be a little bit confused about the type
49:19 - of a variable for example I'm gonna
49:22 - remove this initialization here and
49:25 - initialize this variable on the second
49:27 - line ABC now look at the type of this
49:31 - message variable it's any because by
49:34 - default when we don't set a value the
49:35 - type is any now the problem here is that
49:39 - if I delete this and type period look we
49:44 - don't get that intellisense anymore
49:45 - because ends waste is something that we
49:48 - can do with a string not with an object
49:50 - of type any so what should we do in this
49:54 - case we need to explicitly tell
49:56 - typescript compiler that this message
49:58 - variable is actually a string and this
50:01 - is what we call type assertions now how
50:04 - do we do type assertions there are two
50:06 - ways one way is to prefix this variable
50:09 - with angle brackets and here we put the
50:12 - type like string now we need to enclose
50:16 - both these parts in parenthesis like
50:19 - this then if you press period we get our
50:24 - beautiful intellisense with all the
50:26 - functions or methods available on string
50:28 - objects now there is also another way to
50:32 - do type assertion so let's change the
50:36 - name of this variable to alternative way
50:38 - and here instead of angle brackets
50:42 - u.s. message as string they're exactly
50:47 - the same the approach to shoes is purely
50:49 - your personal preference but the first
50:51 - approach is what you see more in a lot
50:54 - of tutorials and code bases out there I
50:56 - just want to clarify something here this
50:59 - type assertion does not change the type
51:02 - of this variable at runtime in fact it's
51:04 - not going to restructure that object in
51:06 - memory it's purely a way to tell
51:09 - typescript compiler about the type of a
51:11 - variable so we can access the
51:13 - intellisense
51:16 - another concept you need to know when
51:18 - using typescript to build angular
51:20 - applications is the concept of arrow
51:22 - functions so in JavaScript we can
51:25 - declare a function like this let log we
51:29 - set this to a function this function
51:31 - takes a message object and simply logs
51:35 - it on the console like this now in time
51:40 - script there is a shorter way to define
51:42 - this function so let's call the other
51:46 - one do log now we don't need the
51:49 - function keyword anymore we can simply
51:51 - add the parameters in this case message
51:55 - then we add this arrow and that's why we
51:59 - call this an arrow function and finally
52:02 - the code block so console dot log
52:05 - message now if our function has only one
52:09 - line we can even exclude these curly
52:11 - braces so we can make this code a little
52:15 - bit shorter and cleaner like this if I
52:18 - worked with c-sharp we have seen this
52:19 - before
52:20 - and c-sharp we call this a lambda
52:22 - expression in typescript we call it an
52:24 - arrow function it's exactly the same
52:26 - thing now if you have one parameter here
52:28 - you can even exclude the parentheses but
52:31 - I personally don't like this because I
52:33 - think it makes the code a little bit
52:35 - less readable so I always like to put my
52:38 - parentheses here to indicate to the
52:41 - reader of this code that these are the
52:42 - parameters now what if you don't have
52:44 - any parameters we just add empty
52:47 - parentheses and of course here you don't
52:49 - have the message so if you have not seen
52:52 - this before get used to it it's a really
52:54 - nice and clean way to define functions
53:00 - all right now let's see how we can use
53:01 - custom types in typescript so I'm gonna
53:04 - start by declaring a function like draw
53:07 - point so this function takes an x and a
53:11 - y and simply draws it on the screen now
53:15 - we don't want to worry about the actual
53:17 - drawing algorithm we just want to focus
53:19 - on the signature of this function now
53:22 - this function is not too bad here we
53:23 - have only two parameters but sometimes
53:26 - when working with more complex concepts
53:28 - we may end up with a function that has
53:31 - so many parameters like this this is
53:34 - really really bad and it's something you
53:36 - should avoid at all times in those
53:38 - situations it's very likely that a group
53:41 - of these parameters maybe all of them
53:43 - belong to a single concept as an example
53:46 - think of a car a car has so many
53:49 - different properties we don't want to
53:50 - pass all those properties to a function
53:53 - like drive car instead you want to
53:56 - encapsulate them inside an object and
53:58 - only pass that one object here so in
54:02 - this example instead of passing x and y
54:05 - here it's better to pass a point object
54:07 - and then we can call this function like
54:10 - this draw a point we give it an object
54:14 - with two properties x and y so now our
54:19 - function has a cleaner syntax however
54:22 - there is a problem with this
54:23 - implementation instead of a point object
54:25 - I can pass a person object that has a
54:28 - name property I know where here we are
54:32 - getting a compile time error but we know
54:34 - that this code is gonna break at runtime
54:36 - because the algorithm in our drop point
54:39 - function is expecting x and y properties
54:42 - so what's the solution well let me
54:45 - revert this back okay we've got x and y
54:48 - so there are two solutions to solve this
54:51 - problem one way is to use what we call
54:54 - inline annotation so just like we can
54:57 - annotate this parameter with the type
54:58 - like number we can annotate it with a
55:02 - custom type or a custom object so here
55:05 - we add curly braces to indicate an
55:08 - object this object is going to have a
55:10 - property called X which is a number and
55:13 - also
55:14 - another property called Y which is again
55:16 - a number so this is what we call inline
55:19 - annotation it works fine for simple
55:22 - cases but the problem with this as you
55:25 - can see is that this is a little bit
55:27 - verbose also chances are somewhere else
55:31 - we might have another function that
55:32 - expects a point object we don't want to
55:35 - repeat this object literal in multiple
55:37 - places so in those cases a better
55:39 - approach is to use an interface if you
55:42 - worked with object-oriented programming
55:44 - languages like C sharp and Java you know
55:46 - the concept of interfaces we have the
55:49 - same concept in typescript now if you
55:51 - have never worked with interfaces
55:52 - let me show you how they work so on the
55:55 - top I define an interface and I'm gonna
55:59 - call this point curly braces then I add
56:04 - X is a number and Y is a number so with
56:10 - this interface I'm defining the shape of
56:13 - an object and then I can simplify this
56:17 - declaration and set the type of this
56:20 - parameter to point this is much cleaner
56:23 - and we can also reuse this in multiple
56:26 - places just one thing
56:28 - note the naming convention I have used
56:31 - here so because I'm introducing a custom
56:34 - type I've used Pascal naming convention
56:37 - so the first letter of every word in the
56:40 - name of the interface should be
56:42 - capitalized so here we have our per case
56:44 - P not a lowercase P okay so when using
56:47 - interfaces always use Pascal naming
56:50 - convention
56:53 - so in the last lecture we use an
56:56 - interface to define the shape of a point
56:58 - object but there is a problem with this
57:01 - implementation in object-oriented
57:03 - programming languages we have this
57:05 - concept called cohesion which basically
57:08 - means things that are related should be
57:11 - part of one unit they should go together
57:13 - this is what we call cohesion now back
57:16 - to this example on the top we have used
57:19 - an interface to define the shape of a
57:21 - point object and below that we have a
57:23 - standalone function and this is where we
57:26 - have violated the cohesion principle so
57:29 - the concept of drawing a point is highly
57:32 - related to the structure of a point it
57:35 - should not be a separate function now if
57:37 - you're going to build a utility library
57:39 - for working with points chances are
57:41 - you're going to create another function
57:43 - like get distance that calculates the
57:47 - distance between two points so point a
57:50 - of type point and point B of type point
57:54 - and this goes to is code block again we
57:58 - have violated the cohesion principle we
58:01 - have two functions hanging in the air
58:03 - separate from the point object since
58:07 - these concepts are highly related they
58:09 - should be part of one unit in
58:11 - object-oriented languages we call that
58:13 - unit a class so a class groups
58:17 - properties and functions that are highly
58:20 - related now in this implementation
58:23 - unfortunately we cannot move these two
58:25 - functions inside our interface because
58:29 - interfaces are purely for declarations
58:31 - they cannot include an implementation in
58:34 - other words we cannot have the algorithm
58:38 - for calculating the distance between two
58:40 - points or drawing a point inside this
58:43 - interface what we can do instead is to
58:47 - add a function here a function
58:50 - declaration so we're gonna have a draw
58:53 - function that takes no parameters and
58:57 - returns void which means it doesn't
59:00 - return anything now you might be asking
59:02 - why don't we have this point
59:04 - parameter here because if all these
59:07 - members X Y and draw are part of one
59:10 - unit we don't need to pass x and y as
59:13 - parameters to the draw function this
59:16 - function can directly access these
59:18 - properties x and y in the same unit so
59:21 - we don't need this parameter here now in
59:23 - interfaces as I said we cannot have
59:25 - implementation we can only have the
59:28 - signature of a function so with this
59:30 - interface we are telling typescript
59:31 - compiler that our point objects should
59:34 - have two properties x and y and a
59:36 - function called draw the implementation
59:39 - of that is somewhere else so what should
59:41 - we do now to apply the cohesion
59:43 - principle here we need to use a class
59:46 - instead of an interface so on the top
59:49 - I'm gonna change the type to class and
59:51 - here I'm gonna replace is comma with
59:54 - semicolon so our point class has three
59:58 - members the first two members are what
60:01 - we call fields that we use for storing
60:03 - data and the third member is a function
60:06 - now here in this class we can have the
60:08 - actual implementation of this draw
60:10 - function so we can simply define it like
60:13 - this draw and then add all that logic
60:18 - for drawing a point now similarly we can
60:21 - have another function get distance that
60:25 - returns the distance between this point
60:27 - and another point like this again all
60:32 - that logic will end up here now with
60:35 - this restructuring you can see that
60:37 - everything about a point is in one unit
60:39 - in one class so we have the coordinate
60:42 - which includes x and y and two functions
60:45 - draw and get distance now in
60:48 - object-oriented programming terms we
60:50 - refer to these members as fields and to
60:53 - these functions as methods so when a
60:55 - function is part of a class we call it a
60:58 - method alright now with this new
61:00 - implementation you don't want these two
61:02 - functions hanging in the air
61:04 - so delete this is a much better
61:07 - structure also you're not gonna call
61:10 - draw a point like this anymore
61:13 - so here's our point class in the next
61:16 - lecture I'm gonna show you how to create
61:18 - an object of this type and call the draw
61:20 - method
61:21 - you
61:23 - all right so here's our class now let's
61:26 - declare a variable of this type so let
61:29 - point be of type point and then we can
61:35 - type point dot look we have this
61:37 - beautiful intellisense we have two
61:40 - methods draw and get distance and two
61:42 - fields x and y now in time script we
61:46 - also have a concept called property
61:48 - which is different from a field but a
61:51 - lot of people use these terms
61:52 - interchangeably later in this section
61:54 - you're gonna learn the difference
61:56 - between fields and properties now if you
61:58 - wanna call the draw method simply call
62:01 - it like this so this draw method is now
62:05 - part of the concept of a point it's not
62:07 - a function hanging in the air polluting
62:09 - the global namespace now for this demo
62:11 - I'm gonna add a simple console dot log
62:15 - here and display the coordinate at this
62:18 - point so X now here I want to add the X
62:22 - field what we cannot use it like this we
62:26 - need to prefix it with this dot so that
62:29 - refers to this field in this class and
62:31 - then I'm gonna add Y is once again this
62:36 - dot Y now let us compile and run this
62:41 - program and see what happens so TSC
62:44 - what should we type here main the TS and
62:48 - we can shortcut by adding this pipe here
62:51 - type node and then main ajs okay you got
62:58 - a runtime error cannot read property
63:00 - draw of undefined so this is the problem
63:04 - when we call this draw method this point
63:08 - object was undefined because here unlike
63:12 - the basic types we have in typescript
63:13 - like numbers strings billions we're
63:16 - dealing with a custom type when defining
63:19 - an object of a custom type we need to
63:21 - explicitly allocate memory to it how do
63:25 - we do that well here where we declare
63:28 - the point object or the point variable
63:31 - we initialize it using the new operator
63:35 - so this object is a new
63:37 - point and here we add parentheses this
63:42 - is the syntax now you can see that we
63:44 - have repeated this point here twice so
63:48 - we can make this code a little bit
63:49 - cleaner by removing this type annotation
63:53 - because typescript compiler can infer
63:56 - from this assignment here that the type
63:58 - of this object is a point object and
64:00 - let's verify that so look you're working
64:05 - with a point object now one more time
64:07 - save so back in the terminal typescript
64:11 - compiler main the TS and then note main
64:16 - that is okay we didn't get an error but
64:20 - you can see that these x and y fields
64:22 - don't have a value because by default
64:24 - they are undefined so we can get back
64:27 - here and set point that x to let's say 1
64:31 - and point out y - 2 now back in the
64:35 - terminal typescript compiler main dot TS
64:38 - i actually made a mistake earlier so
64:41 - instead of this pipe operator we need to
64:43 - use double ampersand on Mac I don't know
64:46 - the Windows equivalent so with this we
64:50 - can combine multiple comments so note
64:52 - main that is all right beautiful X is 1
64:58 - and Y is 2 so this is how we use the
65:00 - classes that we define in our programs
65:02 - that one highlight something here this
65:05 - point here is a class but this point
65:08 - here is an object an object is an
65:11 - instance of a class
65:13 - as a metaphor think of the concept of a
65:15 - human human could be a class but when we
65:19 - create instances of this class like John
65:21 - Bob Mary these are all objects so that's
65:25 - the difference between a class and an
65:27 - object next we're gonna look at
65:28 - constructors
65:31 - all right so I've simplified the code
65:33 - from the last lecture I simply remove
65:35 - the method get distance because we're
65:38 - not going to use it later in this
65:39 - section so here on the top we define a
65:41 - point class and then below that we
65:43 - initialize a point object now this code
65:46 - is a little bit verbose because we have
65:48 - three lines to create a point object and
65:51 - put it in a valid State what if this
65:54 - point object had a few other properties
65:56 - that we had to initialize like this and
66:01 - maybe a few more here
66:03 - is there a cleaner way absolutely so let
66:07 - me delete this first all right in
66:09 - object-oriented programming languages we
66:12 - have this concept called constructor so
66:15 - every class can have a constructor which
66:17 - is basically a method that is called
66:19 - when we create an instance of that class
66:22 - so let me show you how it works in the
66:25 - class I'm gonna add a method the name of
66:29 - this method is constructor this is a
66:32 - reserved keyword in typescript now this
66:35 - method can have parameters so X which is
66:39 - a number and Y which is also a number
66:41 - and then here in this method we can
66:44 - initialize these fields so what should
66:47 - be right here this dot X we set it to
66:51 - this X argument that we get here and
66:53 - similarly this that Y we set it to Y now
66:59 - look we got a compilation error here
67:00 - because when creating a new point object
67:03 - we need to supply these values look at
67:06 - the error supplied parameters do not
67:08 - match any signature of call target so
67:12 - here we need to supply the values for X
67:14 - and y1 and to and with this we can
67:17 - simplify this code and get rid of these
67:21 - two extra lines and here's the end
67:23 - result
67:24 - now what if somewhere else in our
67:26 - program we don't know the initial
67:28 - coordinate of a point in other words
67:31 - what if I want to create a point object
67:33 - without setting these values is that
67:36 - possible yes absolutely but it's a
67:39 - little bit different from how you have
67:41 - seen that in other languages like C
67:43 - sharp and Java
67:44 - in c-sharp we can have multiple
67:46 - constructors in typescript we can't so
67:49 - the solution for this is to make these
67:51 - parameters optional so here after X I
67:55 - add a question mark and that makes X
67:58 - optional and similarly Y should be
68:02 - optional as well because once you make
68:04 - it parameter optional all the other
68:06 - parameters on the right side of that
68:08 - parameter should also be optional this
68:10 - is a rule by typescript and a lot of
68:12 - other programming languages so now look
68:15 - we don't have a compilation error when
68:17 - creating a point object without initial
68:19 - values
68:22 - all right so here I've created a point
68:24 - object with an initial coordinate now
68:27 - what do you thin our program you want to
68:29 - have this rule such that when we
68:31 - initialize a point object we should not
68:33 - be able to change the X or Y values with
68:38 - this implementation I can always come
68:40 - here and set point that X to a different
68:42 - value how can we avoid this sometimes we
68:46 - need this feature in our programs
68:47 - because it will make them more
68:49 - predictable it reduces the chance for
68:51 - bugs so how should we prevent the
68:54 - coordinate of this point object to
68:56 - change after it's initialized well in
68:59 - object-oriented languages we have this
69:01 - concept called
69:02 - access modifiers an access modifier is
69:06 - basically a keyword that we can apply to
69:08 - a member of a class to control its
69:10 - access from the outside so in typescript
69:13 - we have three access modifiers public
69:16 - private and protected public and private
69:19 - are the most common and by default all
69:22 - members are public let me show you what
69:24 - I mean so here in our point class we
69:27 - have three members right
69:29 - we have two fields and one method so let
69:33 - me create a point object and type point
69:36 - dot look these are the members of the
69:40 - class and because they are all public we
69:42 - can access them here and that's why we
69:44 - can see them in the intellisense
69:46 - however i can go here and prefix this
69:51 - field with the private key word now once
69:56 - we create this point object if I type
69:58 - point dot look X is not in the list it's
70:03 - not accessible it's private so if we try
70:06 - to set point at X 2/3 look we have a
70:08 - compilation error in typescript it says
70:11 - property X is private and only
70:14 - accessible within class point now with
70:17 - this technique I can go here and I
70:21 - applied the private keyword on the Y
70:23 - field as well and now once I initialize
70:28 - a point object I can no longer change is
70:31 - quite innate I can only call the draw
70:33 - method ok so this is why we
70:36 - access modifiers to control access to
70:39 - certain members of a class from the
70:41 - outside you can apply these access
70:43 - modifiers on field properties and
70:46 - methods now by default if you don't set
70:50 - an access modifier is assumed to be
70:52 - public so here the draw method as you
70:55 - know is public I can also add the public
70:58 - key word here but this is redundant it's
71:00 - just making my code noisy so you don't
71:03 - really need to add this it's better to
71:05 - keep your code short and clean and use
71:07 - the private access modifier only when
71:10 - you need to next I'm gonna show you one
71:12 - of my favorite features of typescript
71:14 - around access modifiers as you write
71:19 - code with typescript you see
71:20 - constructors that follow a pattern like
71:23 - what you see here so here we have two
71:25 - parameters in our constructor and we use
71:27 - these two parameters to initialize the
71:30 - fields in this class the code looks a
71:32 - little bit redundant this that x equals
71:34 - x and this dot y equals y typescript as
71:37 - a fantastic feature that helps you
71:40 - achieve the same thing with less code so
71:43 - here we can delete these two fields here
71:46 - and in our constructor we can prefix our
71:51 - parameters with an access modifier so
71:54 - here I want to have two private fields x
71:56 - and y i can simply prefix these with the
72:01 - private keyword like this so typescript
72:06 - compiler will generate these fields for
72:08 - us and also you don't need these ugly
72:12 - repetitive assignments either so if he
72:15 - prefix a constructor parameter with an
72:18 - access modifier with a private or public
72:20 - typescript compiler will generate a
72:23 - field with the exact same name and it
72:25 - would also initialize that field with
72:28 - the value of this argument it's one of
72:30 - my favorite features and you're gonna
72:32 - see that a lot in this course now
72:34 - clarify something before we finish this
72:36 - lecture in this case our fills were
72:38 - private but if they were public we would
72:40 - use the public key word here so this
72:43 - means when we create a pointer object we
72:47 - can access the X field okay so I'm gonna
72:53 - revert this back to the private
73:00 - all right now this implementation has a
73:02 - tiny problem we can set the initial
73:04 - coordinate of this point and we can also
73:07 - draw it but there is no way for us to
73:10 - read the coordinate so I cannot access
73:12 - point that the X here so display to the
73:15 - user
73:15 - what's the workaround well one simple
73:19 - solution is to define a method like this
73:21 - yet
73:22 - X
73:24 - and here we simply return this that X
73:28 - because in this class we do have access
73:31 - to all the private members of this class
73:33 - but we cannot access them from the
73:35 - outside okay
73:37 - now here I can always call point that
73:41 - get X to get the x value and display to
73:45 - the user now let's talk about another
73:47 - use case maybe we want to give the user
73:50 - the ability to set the inertial
73:52 - coordinate here but we also want them to
73:55 - be able to change this coordinate later
73:57 - only if they provide a value within a
74:00 - given range what do I mean by that let
74:03 - me show you I'm gonna define another
74:05 - method here set X
74:09 - now this method is gonna get a value
74:12 - that's the new value for the eggs field
74:15 - let me scroll down now here first we can
74:18 - do some basic validation so if value is
74:21 - less than zero we want to throw an error
74:24 - throw new error value cannot be less
74:30 - than zero otherwise we want to set this
74:35 - well x2 this new value okay
74:38 - now with this implementation we can
74:41 - always change the value of the X field
74:43 - like this point that set X we set it to
74:48 - a new value now if you have a use case
74:50 - like that in your applications you can
74:52 - use what we call a property so in
74:55 - typescript and in a lot of
74:57 - object-oriented programming languages we
74:59 - have a concept called property which is
75:01 - exactly for this very use case so look
75:05 - at how I can define a property here we
75:08 - start with the keyword which is get or
75:11 - set and then the name of the property
75:13 - which is in this case X and after that
75:16 - we're gonna have parentheses just like a
75:18 - method okay now similarly I'm gonna
75:21 - change this to set with a space so we
75:24 - have the set keyword and here it's like
75:26 - we have a function and method now what
75:29 - is the difference the difference is that
75:31 - we can use these properties like fields
75:34 - so here I can read X like this dot note
75:40 - the icon of X it's the same icon we have
75:42 - for fields it's not a method anymore
75:45 - so we can read X and we can also set it
75:50 - like this point that eggs we set it to
75:52 - 10 we don't have to call a method like
75:55 - this it's a cleaner syntax okay so this
76:00 - is what properties are for if you have
76:02 - private fields that you want to give
76:04 - maybe a read-only access to the outside
76:06 - or if you want to give the consumer of
76:08 - your classes the ability to set the
76:10 - values but you want to have some basic
76:12 - validation that's when you use a
76:14 - property now in this case if I want to
76:17 - give only the read-only access to this
76:19 - underlying field I can simply comment
76:22 - out
76:23 - the setter so we call this method a
76:26 - setter and the other method a getter
76:29 - okay I now look at this compilation
76:31 - error we cannot change the value of x
76:34 - now let's bring this back one last thing
76:38 - before we finish this lecture so here I
76:40 - have used a capital X for the name of my
76:43 - X property in JavaScript and in type
76:46 - scrape we use camel notation to name our
76:49 - field so that's why earlier we define
76:52 - this private field here within camel
76:54 - casing notation camel casing means the
76:57 - first letter of the first word is
76:58 - lowercase and the first letter of every
77:01 - word after is uppercase now what should
77:04 - we do to use camel casing notation for
77:07 - our properties if I name this the
77:11 - lowercase eggs it clashes with the
77:14 - existing field so let me revert this
77:16 - back a convention we use to solve this
77:19 - problem is to prefix the name of the
77:22 - underlying field with an underline so
77:24 - let's rename this using f2 and prefix it
77:28 - with an underline okay similarly for the
77:31 - Y parameter or the y field I'm also
77:34 - going to use underline Y then we can
77:37 - rename this property from capital X to
77:40 - lowercase X once again we press f2
77:43 - lowercase X and note that both instances
77:47 - both the getter and the setter are
77:49 - updated now we can work with this X
77:55 - property exactly the same way use the X
77:58 - field so here's the lesson a property
78:01 - looks like your field from the outside
78:03 - but internally it's really a method in
78:06 - the class well more accurately it's
78:09 - either one method which is a getter or a
78:11 - setter or a combination of a getter and
78:13 - a setter
78:18 - all right I've simplified the definition
78:20 - of the point class I remove the
78:22 - properties so we have a simple
78:23 - constructor and a draw method and we're
78:26 - using this point class below its
78:27 - definition now this is a very simple
78:30 - program with only one file but the real
78:32 - world application consists of tens or
78:35 - hundreds of files we don't want to write
78:37 - all the code in one file like main the
78:39 - TS so ideally I want to move the
78:42 - definition of this point class somewhere
78:44 - else in a file like point the TS so here
78:49 - in this project I'm gonna add a new file
78:51 - point a TS now back in Maine the TS I'm
78:57 - gonna select all this code cut it and
79:00 - move it to point a TS now in typescript
79:05 - we have this concept called modules now
79:08 - what a module is requires a little bit
79:10 - more explanation but for now let me give
79:12 - you a simple pragmatic definition in
79:15 - typescript you can think of each file as
79:18 - a module so in this program we can say
79:21 - we have two modules but this is not
79:23 - quite accurate because these files are
79:26 - not modules yet so in point of TS we
79:30 - have defined this class called point but
79:33 - this is not accessible anywhere outside
79:35 - this file so this file defines its own
79:39 - scope in order for us to use this class
79:42 - somewhere else in our program we need to
79:45 - export this to the outside so we add the
79:48 - export keyword here and now this is
79:50 - visible outside this file now that we're
79:54 - exporting something on top of this file
79:56 - from type scripts point of view this
79:58 - file is a module now we need to go back
80:01 - to our main de TS and import this class
80:04 - so we can use it
80:05 - so back in main the TS look we have a
80:09 - compilation error cannot find name point
80:13 - because we have not imported this into
80:16 - main the TS so on the top right import
80:20 - in curly braces we add the name of the
80:23 - types we want to import in this case
80:25 - point now if there are multiple types
80:29 - you want to import we separate them
80:31 - using comma okay so we import point from
80:37 - now here we put the name of the module
80:39 - in quotes what is the name of the module
80:43 - it's the relative pass to that module
80:45 - from this file
80:47 - so both these files are in the same
80:49 - folder we can use period slash which
80:53 - refers to the current folder and then
80:55 - point is the name of our module so it's
80:59 - not point that TS look we get a
81:01 - compilation error so the name of our
81:04 - module is point now we no longer have a
81:07 - compilation error here and we can create
81:09 - an instance of this point class and use
81:11 - it now there is a lot more to talk about
81:14 - when it comes to modularity in
81:16 - typescript
81:16 - but that's all you need to know for now
81:18 - in order to start building applications
81:21 - with angular because in angular
81:23 - framework we have a lot of types that
81:25 - are exported so we need to import these
81:28 - into our typescript files and use them
81:30 - you're gonna see that a lot in this
81:32 - course the only difference is that
81:34 - angular modules are defined in a
81:36 - different way so we don't add the
81:38 - relative path to this module files
81:41 - because these files are not really part
81:43 - of our application they're somewhere
81:45 - inside node underline modules folder so
81:49 - when it comes to importing types defined
81:50 - in angular we use the library name as
81:54 - the module name for example one of the
81:56 - libraries is at angular slash core okay
82:01 - so here's the lesson in typescript we
82:05 - divide our program into multiple files
82:07 - in each file we export one or more types
82:11 - these types can be classes functions
82:14 - simple variables or objects and wherever
82:17 - we need to use these types we need to
82:19 - import them first when we have an import
82:22 - or export statement on top of a file
82:24 - that file is a module from type scripts
82:27 - point of view in angular we also have
82:29 - the concept of modules but angular
82:31 - modules are a little bit different they
82:33 - are not about organization of code in
82:35 - different files they are about
82:37 - organization of your application into
82:39 - smaller functional areas you're going to
82:42 - learn about angular modules in the next
82:44 - section
82:45 - I love your enthusiasm for learning
82:49 - angular as I told you before this
82:52 - tutorial is part of my complete in ela
82:54 - course where you learn everything about
82:56 - angular from the basic to the advanced
82:58 - topics all in one course you seem to be
83:01 - determined enough to learn angular and
83:03 - I'm so excited to see you made it this
83:05 - far so I highly recommend you to click
83:07 - on the link in the video description and
83:09 - enroll in my complete angular course so
83:12 - thank you for watching if you enjoyed
83:14 - this video please like it and share it
83:16 - with others and finally subscribe to my
83:18 - channel for free new videos every week
83:21 - have a great day
83:24 - in this section we're going to look at
83:25 - the fundamentals of building
83:27 - applications with angular by the end of
83:29 - this section you will have a basic
83:31 - understanding of angular building blocks
83:33 - such as components templates directives
83:36 - and services so now let's get started so
83:42 - now that you have some basic familiarity
83:44 - with angular let's look at the building
83:47 - blocks of angular apps at the heart of
83:50 - every angular app we have one or more
83:52 - components in fact in a real world app
83:55 - we have tens or hundreds of components
83:57 - but what is a component a component
84:00 - encapsulate the data the HTML markup and
84:04 - the logic for a view which is the area
84:07 - of the screen that the user sees let's
84:09 - look at the real world example imagine
84:12 - we're gonna build a website like udemy
84:14 - so on this page we have a navigation bar
84:17 - a sidebar and an area to display the
84:21 - list of courses now we can think of all
84:24 - this as one view or one component or we
84:27 - can break this view into smaller more
84:30 - maintainable and potentially reusable
84:33 - components like navbar component sidebar
84:36 - component and courses component
84:38 - similarly in courses component we want
84:41 - to display one or more courses
84:43 - potentially we can break up this
84:45 - component into smaller components and
84:48 - also to take this to the next level each
84:51 - course component can include a rating
84:53 - component now we can reuse this rating
84:56 - component in multiple places in the same
84:58 - app or in an internal different app as
85:00 - you see angular embraces component-based
85:04 - architecture which allows us to work on
85:07 - smaller and more maintainable pieces
85:10 - that can also be reused in different
85:12 - places so once again a component
85:15 - encapsulate the data the HTML markup and
85:18 - the logic for a view which is an area of
85:20 - the screen that the user sees every
85:23 - application has at least one component
85:25 - which we call app component or route
85:28 - component a real word angular app is
85:31 - essentially a tree of components
85:33 - starting from the app component or the
85:35 - route component now in angular
85:37 - also have another concept called modules
85:40 - a module is a container for a group of
85:44 - related components every angular app has
85:47 - at least one module which we call app
85:49 - module as your application grows you may
85:52 - want to break that module into smaller
85:55 - more maintainable modules so in our
85:58 - udemy example we can potentially have
86:00 - modules like course module which
86:02 - includes all the components for
86:04 - displaying courses we can potentially
86:06 - have another module like messaging
86:08 - module which includes a bunch of
86:10 - components for the area of the website
86:12 - where you can send private messages to
86:15 - your instructors we can have an
86:17 - instructor module which includes the
86:19 - components for instructors dashboards
86:21 - that you don't see and potentially an
86:23 - admin module which is the area of the
86:25 - udemy website by the udemy staff as an
86:29 - analogy think of a supermarket in a
86:31 - supermarket we have different aisles for
86:34 - different products we have a section for
86:36 - fruits and vegetables we have another
86:39 - section for snacks
86:40 - another for hardware and so on the
86:43 - bigger the supermarket the more aisles
86:45 - we have in a tiny grocery store we have
86:48 - probably one or two aisles at the most
86:50 - the same applies to our angular apps so
86:54 - if you're building a simple application
86:55 - we have only one module which we call
86:58 - the app module but as our application
87:00 - grows in functionality we may need to
87:03 - break that module into smaller modules
87:05 - with each module responsible for a
87:08 - specific area of our application in that
87:11 - module we have a bunch of related
87:13 - components okay so this is the big
87:15 - picture as we go through this course you
87:18 - will learn about these building blocks
87:19 - in more detail all right now let's see
87:24 - these components in action there are
87:26 - basically three steps you need to follow
87:27 - in order to use a component first you
87:31 - need to create a component second you
87:33 - need to register that component in a
87:34 - module and third you need to add an
87:37 - element in your HTML markup let me show
87:40 - you what I mean by this
87:41 - so back in our first angular project
87:44 - first of all make sure to run and you
87:47 - serve to serve this application
87:53 - so now if you head over to local host
87:56 - port 4200 this is what you see beautiful
87:59 - now back in vs coal I'm gonna create a
88:01 - new component so let's open up the file
88:05 - panel here in the source folder under
88:08 - app here I'm gonna add a new file now
88:13 - let's imagine I want to create a
88:14 - component to display the list of courses
88:16 - so look how I named this file courses
88:20 - dot component dot TS this is the
88:25 - convention that we use when building
88:27 - angular applications now if the name of
88:29 - the component has multiple words we
88:32 - separate them using a hyphen for example
88:34 - if you're building a component called
88:36 - course form it would call this course -
88:39 - form and then dot component TS okay so
88:44 - courses component the TS now here we
88:49 - start by creating a plane type script
88:51 - class so class courses component once
88:58 - again look at the naming convention here
89:00 - I'm using the Pascal naming convention
89:03 - so the first letter of every word should
89:06 - be capital and also by convention we use
89:09 - the suffix component in the name of the
89:12 - class so here's our class in order for
89:16 - angular to see this class first we need
89:18 - to export it now so far we have only a
89:21 - plain typescript class this is not a
89:23 - component in order to convert this to a
89:26 - component we need to add some metadata
89:28 - to it that angular understands we use a
89:31 - decorator to achieve this in angular we
89:34 - have a decorator called component that
89:36 - we can attach to a class to make the
89:39 - class a component so first we need to
89:41 - import this decorator on the top so
89:44 - import curly braces component from now
89:51 - the name of the library so at angular
89:54 - slash core this is the core library of
89:57 - angular that you're going to see a lot
89:58 - in this course so here we import the
90:01 - component decorator and then we need to
90:03 - apply it there is tax
90:05 - class now look at the syntax we use add
90:08 - sign component and then call this like a
90:12 - function so this is what we call a
90:14 - decorator function now this function as
90:17 - you see here takes an argument so here
90:20 - we pass an object and in this object we
90:23 - add one or more properties to tell
90:25 - angular how this component works for
90:28 - example one property that we use quite
90:30 - often is selector so selector and we set
90:35 - this to a CSS selector so in CSS if I
90:38 - want to reference an element like this I
90:41 - use a selector like this if I want to
90:46 - reference an element like a div that has
90:48 - a class called courses my selector would
90:53 - be dot courses right and if I want to
90:56 - reference an element with the ID courses
91:00 - this is my selector just basic CSS okay
91:04 - so here we want to reference an element
91:07 - called courses why because with
91:10 - components we can extend HTML vocabulary
91:14 - so we can define new elements like
91:16 - courses and inside that we will have the
91:19 - list of courses or in the future we can
91:21 - define a custom elements a custom HTML
91:23 - element called rating and wherever we
91:26 - use that angular will render a rating
91:29 - component ok
91:30 - so let's delete this my selector for
91:34 - this component is courses now the second
91:37 - property we add here is template and
91:39 - that's the HTML markup we want to be
91:42 - rendered for this component now here I
91:45 - want to render something very simple so
91:47 - let's just add an h2 element and call
91:52 - this courses in a real world application
91:54 - our templates can be several lines of
91:56 - code in that case we can put them in a
91:58 - separate file and I'm gonna show you how
92:00 - that works later in the course so this
92:03 - is a basic component in angular that was
92:07 - the first step the second step is to
92:09 - register this component in a module that
92:12 - currently our application has only one
92:14 - module which we call app module let me
92:17 - show you where that is
92:18 - so back here in the app folder look we
92:22 - have app but module now once again here
92:27 - we have three import statements on the
92:29 - top so nothing special here on the
92:32 - bottom we have a typescript class called
92:34 - app module and note that this class is
92:37 - decorated with another decorator
92:40 - function called
92:41 - ng module so with this we convert a
92:45 - plane Tasker class to a module from
92:48 - angular point of view now don't worry
92:51 - about all these properties here like
92:53 - declarations import providers and
92:55 - bootstrap you're going to learn about
92:56 - them later in the course what I want you
92:59 - to focus on now is this property
93:01 - declarations and this is where we add
93:04 - all the components that are part of this
93:06 - module so by default when we generate an
93:09 - application we have one component called
93:12 - app component and you can see that
93:13 - component is part of this module now I'm
93:17 - gonna add our new component here so
93:21 - courses component so whenever I type the
93:25 - name of a class here and press ENTER it
93:29 - automatically imported on top of my file
93:31 - so import courses component from and
93:35 - here's the name of our typescript module
93:37 - so period slash which refers to the
93:40 - current folder and here's the name of
93:42 - the file courses that component I know
93:45 - that here we don't have dot TS in fact
93:48 - if you add that typescript compiler it
93:50 - doesn't like that so the name of the
93:52 - module is just the name of the file
93:54 - without the extension so if you want to
93:57 - add this plug-in to vs code simply go
94:00 - here and in the extension search box
94:03 - search for auto import so currently I'm
94:08 - using auto import one point to point to
94:11 - simply install it and then you'll have
94:13 - to restart
94:14 - yes code alright so here's our second
94:17 - step now the third step back to our
94:20 - component so this is the selector for
94:23 - this component which means anywhere we
94:26 - have an element like courses angular is
94:28 - going to render the template for this
94:30 - component inside that element
94:32 - but where are we going to add that
94:34 - element let me show you so back here in
94:38 - the app folder we have this app dot
94:40 - component at HTML this is the external
94:43 - template for our app component let's
94:46 - have a look so all this markup you see
94:50 - here is for rendering the homepage and
94:53 - this is what we get now I want to
94:56 - simplify this I'm gonna get rid of all
94:58 - this markup add a simple h1 call this
95:03 - angular and below that I'm gonna add our
95:06 - custom element courses so when angular
95:11 - sees this element it's going to render
95:13 - the template of our courses component
95:16 - all right now back in the browser this
95:18 - is our new home page so let's right
95:21 - click this courses element and inspect
95:24 - this so look what we have here we have
95:28 - this h1 and below that we have our
95:30 - courses element and inside this you can
95:33 - see we have the template for our courses
95:36 - component so this is how angular
95:38 - applications work as another example
95:41 - look at this app root element inside the
95:45 - body element where is this app root well
95:48 - I can the source folder look at index
95:52 - dot HTML so this is the basic template
95:56 - for our application right now inside the
95:59 - body element we have an element called
96:01 - app - root this is a custom element
96:04 - because we don't have an element in HTML
96:06 - called app - root so from angular point
96:10 - of view we should have a component with
96:13 - a selector for this element and that's
96:15 - our app component let's have a look at
96:18 - that so back in the app folder let's
96:22 - look at an app that component at es so
96:27 - here's our root component or app
96:28 - component look at the selector app
96:31 - that's root
96:32 - so whenever angular sees an element like
96:34 - that it's going to render the template
96:37 - for this component inside that element
96:39 - in this case our template is external
96:42 - so if we have template URL and you can
96:45 - see the name of our template file
96:46 - after component at HTML so that's why
96:50 - inside app - root here we have the
96:53 - template for app component which
96:55 - includes an h1 and the courses element
97:00 - all right let's quickly review what we
97:02 - have done so far so we created this
97:04 - courses component here then we register
97:07 - this in-app module so here in apt of
97:11 - module we added our component inside the
97:14 - declarations array and then finally use
97:17 - this component in the template for app
97:19 - component so let's create a review after
97:21 - the component at HTML added this courses
97:25 - element here three steps okay now there
97:28 - are two problems with this approach the
97:31 - first problem is that this approach is a
97:33 - little bit tedious there are so many
97:35 - steps so first we had to create this
97:38 - typescript class then we had to import
97:41 - this component decorator on the top and
97:43 - next we had to apply it on this tab
97:45 - script class there is so much
97:47 - boilerplate code here now the second
97:49 - issue is that if you forget the second
97:52 - step our application is gonna break let
97:55 - me show you what happens so let's go to
97:57 - app dot module I'm gonna delay it this
98:02 - line here now let's see what happens
98:08 - back in the browser we got a blank page
98:11 - so now we need to look at the console
98:14 - tab of Chrome developer tools so right
98:17 - click anywhere on the page
98:18 - inspect so we can see we have two errors
98:22 - here
98:22 - we can see the details of these errors
98:25 - in the console tab so here's the error
98:29 - courses is not a known element so if you
98:34 - don't register a component in a module
98:35 - angular doesn't know about it and it
98:38 - doesn't know what to do with this
98:39 - courses element because this is not a
98:41 - native HTML element so now let me show
98:44 - you a quicker and more reliable way to
98:47 - create an angular component we need to
98:50 - go back to the terminal
98:51 - but look our terminal is always busy
98:53 - it's serving the application so we
98:56 - either have to open a new terminal
98:57 - window or we can actually open a
99:00 - terminal window inside vs code so back
99:04 - here if you press ctrl and backtick
99:08 - which is the character before the number
99:10 - 1 on your keyboard look we have a term
99:14 - here and this is much easier to access
99:16 - and going back and forth between
99:18 - different windows so here we can use
99:20 - angular CLI to generate a component so
99:24 - just like how we generated an
99:25 - application with ng new we can also
99:28 - generate a component with this ng so the
99:32 - syntax is like this ng space G which is
99:36 - short for generate and C which is short
99:39 - for component and then the name of the
99:41 - component let's say we want to create a
99:43 - component called course so of course
99:47 - look at what happened angular CLI
99:50 - created a directory called course and
99:53 - inside this directory added four files a
99:56 - CSS file for storing the style sheets
99:59 - for this component an HTML file for
100:02 - storing the template a spec file which
100:05 - is for writing unit tests for this
100:07 - component and finally a typescript file
100:09 - which is the actual component itself now
100:13 - what is interesting here is that it also
100:15 - updated app dot module and registered
100:18 - this new component let's have a look so
100:21 - we can close this terminal window using
100:22 - the same shortcut which is control and
100:24 - backtick now we can open the files panel
100:27 - using command + b on mac or control B on
100:31 - windows ok look at after module so look
100:37 - inside the declarations array now we
100:39 - have course component so this way we
100:42 - don't have to remember to come back here
100:45 - and register our new components now
100:47 - before we move on let me just quickly
100:49 - add our courses component that I removed
100:52 - earlier ok now back in the files panel
100:57 - this is the folder for our new component
101:01 - so in this folder we have these four
101:03 - files now let's take a look at the
101:05 - typescript class it has all the
101:08 - boilerplate code that we wrote earlier
101:09 - plus a little bit more so here we're
101:12 - importing the component decorator and on
101:15 - Innes which is an interface we're going
101:17 - to look at this later in the course we
101:19 - have this component decorator apply to
101:20 - our typescript class we have a selector
101:23 - you have the URL of our template file as
101:26 - well as the URL of our
101:28 - style sheet file so angular CLI saves us
101:31 - a lot of time now as we go through this
101:34 - course
101:34 - I will show you how you can use this
101:35 - tool to generate other building blocks
101:38 - for your applications
101:41 - so earlier I told you that a component
101:44 - encapsulate the data the logic and the
101:47 - HTML markup for review so in this
101:50 - example in our courses component we have
101:52 - the HTML markup but we don't have any
101:55 - data or any logic so let's extend this
101:58 - example and take it to the next level I
102:00 - want to define a field in this class to
102:03 - hold the title of this page so title I'm
102:07 - going to set this to list of courses now
102:12 - I'm going to display this title in our
102:14 - template dynamically so I'm gonna remove
102:18 - this hard-coded label here in angular we
102:22 - have this special syntax double curly
102:25 - braces and we use this to render
102:27 - something in our template dynamically so
102:31 - here I can put this title field this
102:33 - expression will be evaluated at runtime
102:35 - and the value of this title field will
102:38 - be placed in our Dom now if the value of
102:41 - this title field changes at some point
102:43 - in the future angular will automatically
102:45 - update the Dom this is one of the
102:47 - beauties of angular framework so here we
102:50 - have this concept of data binding so
102:52 - your binding our view to have filled in
102:55 - this component whenever the value of
102:57 - that field changes the view is
102:58 - automatically notified and updated all
103:01 - right now let's save the changes
103:03 - back in the browser alright here's our
103:06 - new title beautiful now back here we
103:10 - don't always have to put the name of a
103:12 - field here we can write any simple
103:14 - JavaScript expressions for example I can
103:17 - put a string here title colon and then
103:22 - concatenate this with our title field
103:24 - save look this is our new title here we
103:30 - can also call a method in this class to
103:33 - get some value for example let me define
103:36 - a method get title and here I'm gonna
103:40 - return this the title now here we can
103:46 - simply call our new method get title
103:49 - like this and we'll get the exact same
103:52 - result there you go
103:55 - list of courses so this special syntax
103:59 - here we call it string interpolation in
104:03 - the next lecture I'm going to show you
104:04 - how to render a list of courses here
104:09 - alright now let's take this example to
104:11 - the next level instead of displaying a
104:13 - simple title field you want to display
104:16 - the list of courses so first we need a
104:18 - field to hold the list of courses so
104:21 - courses we set this to an array with
104:26 - three items course one course two and
104:30 - course three now this is a simplified
104:34 - example in a real world application
104:35 - instead of simple strings here we would
104:38 - have objects but don't worry we're gonna
104:40 - get there now I want to display these in
104:43 - our template how should we do that first
104:46 - we need to change this single code to
104:49 - the backtick character so delete
104:52 - backtick backtick is the character
104:55 - before number 1 on your keyboard let me
104:58 - change this as well now the benefit of
105:01 - using the backtick is that we can break
105:03 - up this template into multiple lines and
105:05 - make it more readable so I want to put
105:09 - this h2 here and below that I want to
105:13 - add a ul and a bunch of list item
105:18 - elements like this now we want to repeat
105:21 - this Li for each course now for that we
105:24 - need to use one of the angular building
105:26 - blocks called directive we use
105:29 - directives to manipulate the Dom we can
105:32 - use them to add a Dom element or remove
105:35 - an existing Dom element or change the
105:37 - class of a Dom element or its style and
105:40 - so on so here we're going to use a
105:43 - special directive called NG for we use
105:48 - it like an attribute in HTML so we set
105:50 - it to a string and here we're gonna
105:52 - write some expression now before going
105:54 - any further
105:55 - we should prefix this attribute with an
105:58 - asterisk this is a special syntax in
106:01 - angular so whenever you are using a
106:03 - directive that modifies the structure of
106:06 - a dumb you should prefix that directive
106:08 - with an asterisk in case you're curious
106:10 - about the reason I have covered it later
106:12 - in the section about directives so for
106:15 - now just remember whenever you are using
106:16 - a directive that modifies the structure
106:19 - of the Dom by adding or removing an
106:21 - element you need to
106:22 - fix that with an asterisk now here we
106:25 - want to write an expression similar to
106:28 - what we write in for each blocks so let
106:31 - course of courses what does this mean
106:36 - with the lead keyword we are defining a
106:38 - variable so the name of our variable is
106:41 - course this is like a loop variable in
106:43 - JavaScript all is a special keyword and
106:46 - courses is the field in this class that
106:49 - we are iterating over so when angular
106:52 - sees this expression it's going to
106:54 - iterate over the courses field and in
106:57 - each iteration this course variable will
107:00 - hold the value of one course at a time
107:01 - now inside this list I know you want to
107:05 - display this course so once again we use
107:08 - string interpolation double curly braces
107:11 - and add this course variable here let's
107:15 - look at the result save back in the
107:18 - browser and here we have the list of our
107:21 - courses beautiful now in most real-world
107:23 - applications we get this courses from
107:26 - the server and for that we need to use
107:28 - another building block of and get a
107:29 - called a service and that's the topic
107:32 - for the next lecture
107:37 - right now we have the list of courses
107:38 - here but in a real world application
107:40 - most of the time we get these courses
107:43 - from the server so instead of
107:45 - hard-coding them here we need to call an
107:47 - HTTP endpoint to get the list of courses
107:49 - now here we have two options one is to
107:54 - add the logic for calling an HTTP
107:57 - service here in this component but there
108:00 - are a couple of problems with this
108:01 - approach the first problem is that this
108:04 - logic is going to tightly couple this
108:06 - component to that HTTP endpoint now in
108:10 - the future when we want to write unit
108:12 - tests for this class we don't want to be
108:14 - dependent upon a live HTTP endpoint
108:17 - because this is going to make it harder
108:20 - to execute those unit tests so we want
108:23 - to create a fake implementation of an
108:26 - HTTP service so this is the first issue
108:28 - with writing this logic inside this
108:31 - class inside this component it's going
108:33 - to tightly couple this component to that
108:35 - HTTP endpoint the second issue is that
108:38 - maybe somewhere else in the application
108:40 - we're going to have another page where
108:42 - we display the list of courses maybe
108:44 - it's part of a dashboard maybe somewhere
108:47 - for an admin with this implementation we
108:49 - have to repeat this logic the logic for
108:52 - consuming that HTTP service in multiple
108:54 - places and that's not good and finally
108:57 - the third issue with this implementation
108:59 - is that a component should not include
109:02 - any logic other than the presentation
109:05 - logic that is the logic behind this view
109:08 - what should happen when we click upon
109:10 - when we select an item from a drop-down
109:12 - list and so on details of how courses
109:15 - are retrieved should be delegated
109:17 - somewhere else in your application so
109:19 - where should we implement that logic in
109:21 - angular we use services for that so
109:24 - we're going to define a separate class
109:25 - which we call a service and there we'll
109:28 - add this logic for getting the list of
109:30 - courses from an HTTP service then we can
109:33 - reuse this class in multiple places so
109:36 - let me show you how to do that here in
109:39 - the app folder I'm gonna add a new file
109:42 - now look at the naming convention
109:44 - courses dot service the TS
109:49 - so the name of our service is courses
109:52 - and by convention we have the word
109:54 - service in the file name
109:56 - and finally TS when creating a component
109:59 - we use courses does component at TS so
110:03 - note the difference now here once again
110:06 - you want to export a plane type script
110:08 - class so export class courses service so
110:15 - once again by convention we add the word
110:17 - service as a suffix in the class name
110:20 - now when creating components we decorate
110:23 - this class with the component decorator
110:26 - remember component but in angular we
110:29 - don't have a decorator for services so a
110:32 - service is essentially a plane type
110:34 - script class so delete now here we want
110:38 - to add a method for getting the list of
110:40 - courses get courses for now we don't
110:45 - want to get distracted with the
110:46 - complexity of consuming an HTTP service
110:50 - so let's just return the same array that
110:52 - we had in our component and later I will
110:55 - show you how to consume an HTTP service
110:57 - so back in our component
111:02 - I'm going to select this array here cut
111:06 - back in the service and simply return it
111:10 - from this method now imagine here in
111:13 - this method we have that logic for
111:15 - consuming an HTTP service with this
111:18 - implementation we can reuse this class
111:20 - we can reuse this logic in multiple
111:22 - places in our application and also this
111:26 - will separate or decouple our component
111:29 - from this logic so back in our component
111:33 - here we are not going to have any logic
111:35 - for consuming an HTTP service and this
111:38 - allows us to unit test this class
111:40 - without dependency upon that HTTP
111:44 - endpoint
111:45 - so while unit testing in this class we
111:47 - can provide a fake implementation of net
111:49 - service now if that's too complicated
111:51 - don't worry about it your testing is
111:53 - something for the future okay now we
111:56 - have a service we need to use this
111:58 - service in our component how that's the
112:00 - topic for the next lecture
112:04 - okay now we have a service to get the
112:07 - list of courses from the server we need
112:09 - to use this service in this courses
112:11 - component so first we need to add a
112:14 - constructor here constructor because a
112:19 - constructor is where we initialize an
112:21 - object so here we need to create an
112:24 - instance of our courses service
112:26 - something like this let service be new
112:32 - courses service once again I'm using the
112:36 - auto import plug-in so when I press
112:39 - ENTER it automatically adds the import
112:43 - statement here on the top so I'll import
112:45 - courses service from current folder
112:48 - courses dot service all right now back
112:52 - in the constructor so we have a service
112:56 - and then we can initialize this course
112:59 - is filled like this this that courses we
113:03 - set this to service that get courses
113:06 - let's test the application and make sure
113:09 - everything works up to this point save
113:12 - okay we get the same list beautiful
113:15 - however there is a problem with this
113:18 - implementation the first problem is that
113:21 - by using this new operator here we have
113:23 - tightly coupled this courses component
113:26 - to the courses service so this is
113:29 - exactly like the problem we had earlier
113:31 - if we implemented the logic for
113:33 - consuming an HTTP service inside this
113:36 - component we wouldn't be able to unit
113:38 - test this class now we put this logic in
113:41 - a different class courses service but
113:43 - because we're directly creating an
113:45 - instance of this class here we're still
113:47 - tightly coupled to that implementation
113:50 - the other issue here is that if in the
113:53 - future we decide to add a parameter to
113:56 - the constructor of course a service we
113:59 - have to come back here and anywhere else
114:01 - in our application where we have used
114:03 - this courses service and add a new
114:05 - argument like one so any time we change
114:09 - the constructor of this service we end
114:11 - up with multiple changes in our
114:13 - application code so this is very fragile
114:15 - so what should we do well in
114:18 - we creating an instance of the courses
114:20 - service we can ask angular to do that
114:23 - for us so we can delete this line here
114:27 - and add a parameter in this constructor
114:30 - call it service of type courses service
114:37 - with this when anger is going to create
114:40 - an instance or component it looks at
114:42 - this constructor is that this
114:44 - constructor has a dependency this
114:47 - dependency is of type courses service so
114:51 - first it creates an instance of the
114:52 - courses service and then passes that to
114:55 - this constructor
114:56 - now with this implementation if we
114:59 - change the constructor of courses
115:01 - service and add a new parameter we don't
115:04 - have to modify a hundred places in our
115:05 - code to reflect the change angular will
115:08 - automatically instantiate a new courses
115:12 - service object the second benefit of
115:15 - this implementation is that when we're
115:17 - going to unit test this courses
115:18 - component instead of supplying an actual
115:21 - courses service to this constructor we
115:24 - can create a fake implementation of this
115:26 - service that doesn't use at HTTP service
115:29 - on the backend in other words we have
115:32 - decoupled our courses component from
115:35 - courses service so here's the lesson
115:37 - when you use the new operator like this
115:39 - inside a class you have tightly coupled
115:43 - your class to that implementation you
115:46 - cannot change this at runtime but when
115:49 - you add that dependency as a parameter
115:51 - of a constructor you have decoupled that
115:53 - class from that dependency now you're
115:56 - not done yet
115:57 - we need to instruct angular to create an
116:00 - instance of course a service and pass it
116:03 - to our courses component this concept is
116:06 - called
116:06 - dependency injection so we should
116:09 - instruct angular to inject the
116:12 - dependencies of this component into its
116:14 - constructor as simple as that
116:16 - that's dependency injection a lot of
116:18 - people think dependency injection is so
116:20 - complicated but it's really a $25 term
116:23 - for a five-cent concept so dependency
116:26 - injection means injecting or providing
116:29 - the dependencies of a class into its
116:31 - constructor
116:32 - now angular has a dependency injection
116:35 - framework built into it so when it's
116:37 - going to create an instance of a
116:39 - component it can inject the dependencies
116:42 - but in order for that to work we need to
116:45 - register these dependencies somewhere in
116:47 - our module so let's save the changes now
116:52 - we need to go to our app dot module so
116:55 - here's app dot module okay look at this
116:59 - engine module decorator here we have a
117:02 - property called providers which is set
117:05 - to an empty array in this array we need
117:08 - to register all the dependencies that
117:11 - components in this module are dependent
117:13 - upon for example our courses component
117:16 - is dependent upon courses service so we
117:19 - need to register courses service as a
117:21 - provider in this module so here I'm
117:28 - gonna add courses service now if you
117:31 - forget this step dependency injection is
117:33 - not gonna work let me show you what
117:35 - happens so I'm gonna comment out this
117:37 - line save back to the browser we get a
117:42 - blank page so that means something is
117:44 - wrong
117:44 - let's open up chrome developer tools
117:46 - with shift command and I on Mac or shift
117:50 - ctrl I on Windows look at this error no
117:53 - provider for courses service this is an
117:56 - error that you might see quite often
117:58 - when building angular apps so the error
118:00 - is telling us that we have not
118:02 - registered courses service as a provider
118:05 - in our module so back in an app module
118:08 - I'm gonna add this courses service here
118:11 - save back in the browser and we have the
118:15 - list of courses now one more thing
118:16 - before we finish this lecture when you
118:19 - register at dependency as a provider in
118:21 - a module angular will create a single
118:24 - instance of that class for that entire
118:27 - module so imagine in this module we have
118:29 - 100 components and 50 of these
118:32 - components need the courses service in
118:35 - the memory we're gonna have only a
118:37 - single instance of course a service an
118:39 - angular will pass the same instance to
118:42 - all these components this is what we
118:44 - call the single
118:46 - on pattern so a single instance of a
118:48 - given object exists in the memory so a
118:51 - quick roundup vacuumer component we
118:54 - added courses service as a parameter in
118:56 - the constructor or in other words as a
118:58 - dependency of this class and then
119:00 - register this as a provider in our app
119:04 - module with this implementation when
119:07 - angular is going to create an instance
119:09 - of this component first it will
119:11 - instantiate its dependencies and then it
119:14 - will inject those dependencies into the
119:16 - constructor of this class and this is
119:18 - what we call dependency injection all
119:24 - right now let me show you a quick way to
119:25 - create a service in angular so we go to
119:28 - the terminal
119:29 - once again you can switch to the
119:31 - terminal window or you can press ctrl
119:33 - and backtick in vs code so here we have
119:37 - a small terminal window we're gonna use
119:40 - angular CLI to generate a service so ng
119:44 - g4 generate previously we use c4
119:47 - components now we're gonna use s for
119:50 - services imagine we're going to create a
119:53 - service for sending emails this service
119:55 - is going to call an HTTP endpoint
119:57 - somewhere for sending these emails so
120:00 - let's call this email I know that here I
120:03 - just add the service name I don't need
120:05 - to add dot service ok so this generates
120:10 - two files for us one is the actual
120:13 - service file and the other is a spec
120:15 - file which includes some boilerplate
120:17 - code for writing unit tests for that
120:20 - service so in the app folder look here's
120:24 - our new service email that service the
120:26 - TS
120:28 - so we have a plain typescript class
120:30 - called email service but there is
120:32 - something extra here that you didn't see
120:34 - before we have this injectable which is
120:37 - another decorator function similar to
120:39 - the component decorator function what do
120:42 - we need this here we would need this
120:43 - decorator only if this service had
120:46 - dependencies in its constructor for
120:49 - example imagine here we had a dependency
120:52 - lock log service of type log service in
120:56 - this case we need to apply this
120:59 - injectable decorate a function on this
121:02 - class and this tells angular that this
121:04 - class is an injectable class which means
121:07 - angular should be able to inject
121:09 - dependencies of this class into its
121:11 - constructor now we didn't use this
121:13 - decorator when defining components
121:15 - because when we use the component
121:17 - decorator that decorator internally
121:21 - includes this injectable decorator so
121:24 - that's all about injectable and by the
121:26 - way note that this decorator function is
121:28 - defined in angular slash core library
121:33 - right now I want you to use what you
121:36 - have learned in this section and build a
121:38 - page like this so apart from the main
121:40 - heading of our application you have a
121:42 - heading that includes the number of
121:44 - authors so here we have three authors
121:46 - and below that we have the name of these
121:49 - authors rendered using ul and Li so use
121:53 - angular CLI to generate a component and
121:56 - a service and write all the necessary
121:58 - code render a view like this you can see
122:01 - my solution in the next lecture
122:05 - I love your enthusiasm for learning
122:07 - angular as I told you before this
122:10 - tutorial is part of my complete in ela
122:12 - course where you learn everything about
122:14 - angular from the basic to the advanced
122:16 - topics all in one course you seem to be
122:19 - determined enough to learn angular and
122:21 - I'm so excited to see we've made it this
122:23 - far so I highly recommend you to click
122:25 - on the link in the video description and
122:27 - enroll in my complete angular course so
122:30 - thank you for watching if you enjoyed
122:32 - this video please like it and share it
122:34 - with others and finally subscribe to my
122:36 - channel for free new videos every week
122:38 - have a great day

Cleaned transcript:

hi my name is Muhammad Ali and I'm going to be instructor over the next few hours in this course you're going to learn everything about angular from the basic to the advanced topics and you will build and deploy a real ecommerce application using angular firebase and the new awesome bootstrap for let me show you a demo of this application real quick we're gonna build an ecommerce application for an imaginary organic shop so here on the home page we have master detail you can select the category and see all the products in that category you can add a product or a shopping cart change the quantity and the number of items in a shopping cart it's updated in real time and here's our shopping cart again here we can change the quantity for each item and the total price as well as the total number of items in the shopping cart get updated immediately if I open another tab and add another product to our shopping cart what we have on the shopping cart tab gets updated automatically without me having to refresh the page so all the data we show to the user is in sync everywhere in the application and this is the beauty of a realtime application now let's check out here we have a shipping form and the summary of all the products in our shopping cart and again this summary gets updated as soon as I make a change or a shopping cart in another tab once we place this order it will be visible to our admins so I'm an admin user and I have this menu here manage orders here we can see all the orders in the application other users will not see this page here so here we have authentication and authorization as an admin I can also manage the products so here we have all the crud operations we can quickly search for a product you can sort the data resize the columns or navigate to a different page these are the patterns that you see in a lot of realworld applications and in this course you're going to learn how to implement these patterns in your applications so are you excited to learn angular and build this application then let's jump in and get started so in case you're an absolute beginner with angular let me quickly explain in two minutes what angular is and why you should learn it angular is a framework for building client applications in HTML CSS and either JavaScript or a language like typescript that compiles to JavaScript a typescript is more common in the angular community because angular itself has been written with typescript now if you have never worked with typescript before don't worry at all it's very easy and you're gonna get familiar with it in this course now one question that a lot of beginners have is why do we need angular can we not use plain old JavaScript or jQuery we certainly can and that's how a lot of web applications out there are built but as our applications get more complex vanilla JavaScript or jQuery code becomes hard to maintain we need a way to properly structure our application sure there are JavaScript patterns out there that help us with the structuring but these patterns are hard to understand for a lot of beginners to JavaScript plus a lot of applications built with vanilla JavaScript or jQuery are hard to test and that's why over the past few years various frameworks have been built and evolved to make web application development easier angular is an example of such frameworks it gives our applications a clean and loosely coupled structure that is easy to understand and easy to maintain it also brings in a lot of utility code that we can reuse in various applications especially when dealing with the users navigation and the browser history plus applications built with angular are more testable so we can easily write automated tests to test various parts of our application as I will show you later in the course so to answer this question no you don't need a framework like angular to build client applications but using angular makes your life a lot easier all right now that you know what angular is let's take a look at the architecture of angular applications a lot of modern applications have at least two parts a front end and a back end the front end also called the client is the part that runs in a web browser and this is what the user sees and interacts with so it essentially includes the user interface or UI of an application we use HTML CSS typescript and angular to build the front end the back end sits on a web server or multiple web servers in the cloud and is responsible for storing the data and doing any kind of processing our front end or the client app talks to the back end to get or save the data one of the questions that a lot of beginners ask me is maash how do I save my data in angular well you don't in most cases you don't save the data on the client because it can easily disappear as the user clears the browser data or moves to a different computer that's why we store the data on the server so here we often have one or more databases as well as a bunch of HTTP services or api's to make this data available to the clients in case you don't know API stands for application programming interface now if you put this fancy name aside these HTTP services or AP eyes are essentially endpoints that are accessible via the HTTP protocol so we can call them using simple HTTP requests to get or to save the data if that's too much technical jargon here let me give you a metaphor think of a port where ships load or unload these are points to get loads in and out of a town right now imagine these ports are HTTP endpoints ships are HTTP requests and loads are data so just like we can send a ship to a port to get some load and bring to us a client app sends an HTTP request to an endpoint to get some data so this is how the big picture works our web applications have a front end and a back end on the back end we have one or more databases and API is that make the data available to the clients for a larger application around a complex domain this is where we implement the business logic of the application like calculating the tax and shipping cost based on various parameters the front end or the client on the other hand is all about the presentation so here we have our HTML templates as well as the presentation logic of our application this logic is all about displaying data and responding to user actions like what should happen when the user clicks on a button or navigates away from a page these are examples of the presentation logic or the logic that is all about the presentation aspect of an application now in terms of the implementation building the backend requires familiarity with other languages and frameworks and it's completely outside the scope of building client apps with angular so as an angular or a frontend developer you don't have to worry about this this is the job of a backend developer or a full stack developer who knows both the front end and the back end so for the purpose of this course we're gonna focus on the front end and if you want to learn about the backend development you can always pick up a course later down the road but for now let's just focus on one thing and do it well all right in this lecture I'm gonna show you how to set up your development environment and create your first angular project so the first thing you need to install is the latest version of node in case you have never worked with node before it's basically a runtime environment for executing JavaScript code outside the browser in this course we're not gonna work with node but note provides some tools that we need to build angular projects so if you have an installed node head over to node.js org on this page you can see the latest version of node for your operating system so here the latest stable version is 6.11 and the latest version is version 8 now this latest version has more features but it's not quite stable yet so go ahead and install the latest stable version when you do that open up the terminal on Mac or command prompt on Windows and type node version so you can see on my machine I'm running node version 6 point the minimum version required for building angular applications is version 6.9 once you have node then we're gonna use a tool called node package manager or NPM to install thirdparty libraries one of these libraries we're going to install in this lecture is angular CLI which stands for commandline interface so it's a commandline tool that we use to create a new angular project or generate some boilerplate code as well as create deployable packages so once again in the terminal we run NPM install G which stands for global and finally the name of the package which is at angular slash CLI if you don't put dash G here angular CLI will be installed only in the current folder and it's not going to be accessible anywhere else now if you're on Mac you need to put sudo at the beginning of this command to execute it as an administrator all right next we need to enter our password this process is going to take a little while all right beautiful we installed angular CLI now to ensure that the installation was successful we can type ng version so you can see I'm writing angular CLI version one point one point zero and below that you can see the version of node on my machine once again it's 6.10 so with angular CLI in place now we can create a new angular project so we type ng new and let's call this project hello world so this generates a bunch of files and folders and then it's going to use NPM to download the thirdparty libraries alright our project is successfully created now to start coding we need a code editor the editor I'm gonna use in this course is Visual Studio code or vs code it's a beautiful crossplatform lightweight editor and you can download at code that Visual Studio comm if you don't like this editor feel free to use any editors that you prefer you can use sublime you can use atom or any other editors now if you're going to use vs code I want you to add it to the path so you can easily open it from the terminal so here if you're using Mac press shift command + P or if you're using Windows press shift ctrl + P this opens up the command palette now here type code look at this command here install code command in path with this we can go to the terminal in the folder where we created a new project hello world simply type code period so this opens up vs code pointing to the current folder now in the next lecture we're going to look at this structure you're gonna learn what files and folders we have here but before we get there let's make sure that this application works so back in the terminal once again we use angular CLI to load our application in a web server so we type ng space serve so now we have a live development server listening on localhost port 4200 and angular CLI also compile our application it generated bundles for JavaScript and CSS files so we can open up Chrome and head over to localhost port 42 hundred beautiful this is our first angular app next we're going to look at the structure of our new angular project alright now let's see what files and folders we have in this new project so the first folder we have here is e e which stands for end to end and this is where we write endtoend tests for our application if you have not worked with endtoend tests these are basically automated tests that simulate a real user so we can write code to launch our browser navigate to the home page of our application click a few links here and there fill out a form click a button and then assert that there is something on the page this is an example of an endtoend test now that's beyond the scope of this course so we don't have to worry about it yet below that we have node modules and this is where we store all the thirdparty libraries that our application may depend upon now this folder is purely for development so when we compile our application parts of these thirdparty libraries are put in a bundle and deployed with our application so we're not going to deploy this node modules folder to a server you're going to see this later in the course below that we have the source folder and this is where we have the actual source code of our application so we have this app folder here and inside this folder we have a module and a component so every application has at least one module and one component you're going to get familiar with this components and modules very soon below that we have this assets folder where we store the static assets of our application so if you have any image files and it takes files and icons all of these go here below that we have this environments folder and this is where we store configuration settings for different environments so we have one file for the production environment and the other for the development environment now the other files we have in the source folder are favorite icon which is the icon displayed in the browser we have index dot HTML which is a very simple HTML file that contains our angular application so note that here we don't have any references to a script or a stylesheet these references will be dynamically inserted into his page as I will show you later in the course now below that we have this main file which is a typescript file and this is basically the starting point of our application so in a lot of programming languages we have this concept of the main method which is the starting point of a program we have the same concept in our angular applications so all we are doing here is bootstrapping the main module of our application which is in this case app module so angular loads this module and everything else starts from there we have this polyfills file which basically imports some scripts that are required for running angular because the angular framework uses features of JavaScript that are not available in the current version of JavaScript supported by most browsers out there so these polyfills fill the gap between the features of JavaScript and angular needs and the features supported by the current browsers below that we have styles of CSS and this is where we had the global styles for our application and also each page or each component can have its own Styles as you will see later in the course below that we have test the TS which is basically used for sending them our testing environment again for now we don't have to worry about this outside the source folder we have a configuration file for angular CLI it's pretty standard configuration you don't have to worry about this for the most part below that we have editor config so if you're working in a team environment you want to make sure that all developers in the team use the same settings in their editors so this is where you store your settings we have this get ignore file which is basically for excluding certain files and folders from your git repository if you have not worked with git don't worry it's not something that you need to know in order to build applications with angular it's basically a tool for managing and versioning your source code now below that we have karma that config the Jas which is a configuration file for karma we is a test runner for javascript code again we're not going to worry about running tests at this stage now below that we have an important file package JSON now this is a standard file that every node project has apart from a bunch of basic settings here like the name and version of your application we have this setting here dependencies which determines the libraries that your application is dependent upon so here you can see we have nine references to angular libraries all these libraries start with at angular and after that we have the name of the library so the first library here is for animations if you're not going to use animations in your application you can delete this here so in the future as we use thirdparty libraries you will see them listed here under the dependencies now below that we also have another setting or another key called dev dependencies and these are the libraries that we need in order to develop this application so we don't need these to run our application on a production server these are purely for a developer machine so here we have a reference to angular CLI which are only too familiar with we also have a few other references to karma which is again a test runner for javascript code now below this package that JSON we have protractor that config the Jas which is basically a tool for running endtoend tests for angular again we're not gonna worry about it the another file here is TS config which has a bunch of settings for your typescript compiler so your typescript compiler looks at these settings and based on these settings is going to compile your typescript code into JavaScript that browsers can understand again for the most part you don't have to change any of this here just be aware that if in the future in a complex project you need to change your typescript compiler settings this is where you need to apply your changes and finally we have TS lint like JSON which includes a number of settings for TS linked in case you don't know TS lint is a static analysis tool for typescript code so it shakes your typescript code for readability maintainability and functionality errors so this is the basic structure of an angular project all right now let's make a tiny change to this application so in the app folder open up app that component the TS now if you have never worked with JavaScript before don't worry about this code as we go through the course I'm gonna break this up for you so you will know exactly what is happening here so all I want you to do here is to change this string from app to angular app now save the file back in the terminal look at this message webpack compiling so angular CLI uses a tool called web pack which is a build automation tool it gets all our scripts and stylesheets combines them puts them in a bundle and then minify that bundle and this is for optimization so here you can see we have a few bundles like polyfills which includes all the scripts to fill the gap between the version of JavaScript that angular needs and the version of JavaScript supported by most browsers out there we have main bundle which is all the source code of our application we have styles bundle which includes all our style sheets and note that here style sheets are actually stored in a JavaScript bundle you're gonna see that in a second we also have this vendor bundle which includes all the thirdparty libraries now at the time of recording this video unfortunately angular CLI does not allow you to customize the name of these bundles or add additional bundles but there is a discussion going on and guess how chances are this may change in the future now that aside what I want you to note here is that whenever you change one of your files where that file being a stylesheet a typescript file or an HTML file web pack automatically recompile your application and refreshes your bundles so now here at the bottom you can see web pack compiled successfully now if you go back to the browser look without me even refreshing this page now we have the new title welcome to an angular app so this is a feature of web pack called hot module replacement or hot module reloading so whenever one of the source files is modified web pack automatically refreshes your browser now let's rightclick on this page and go to view page source at the bottom of this page look at these script tags so all the bundles that webpack generator it also injected them into our index dot HTML so just to refresh your memory here in index dot HTML look we don't have any references to your style sheet or a script file so this is something that happens at runtime so web pack automatically inject these scripts into our index dot HTML now let's take a look at these Styles that bundle the js so basically what we have here is some JavaScript and in the middle of this JavaScript code you can find the Styles used in your application now how this works is a little bit complicated so don't worry about it for now what I want you to know is that all your style sheets are compiled into a Java Script bundle one question that often comes up is what's the difference between angularjs angular 2 and angular for and how did we jump from angular 2 to angular 4 well angularjs was introduced in 2010 as a JavaScript framework for building client applications soon it gained popularity an angular team started adding new features to the core but the framework was not designed with the needs of today's applications in mind plus it was overly complex so angular team decided to rewrite the original framework using typescript and as a result angular 2 came out in mid 2016 this new version is entirely different from angular 1 to the extent that you can think of it as a completely different framework now this made a lot of developers unhappy because they had a lot of applications built with angular 1 with each application over a few thousand lines of code that had to be rewritten but overall I personally like the direction that angular team took and how they've rebuilt angular with typescript this is a much better framework it's a lot cleaner and it's a lot easier to understand and to work with now after a few minor upgrades to angular 2 something strange happened we were up to angular 2.3 and then all of a sudden and your 4 came out so a lot of developers including myself wondered what happened to angular 3 we thought we made something really big here but unlike angular 2 angular 4 was not a new framework with a lot of breaking changes in fact it wasn't even a major upgrade so let me explain what happened angular consists of a few different libraries that are distributed as separate node packages via NPM for example we have the core library that we use in every application we have angular compiler we have angular HTTP for calling HTTP services we have angular router for adding navigation to applications and a few other libraries now all these libraries were version the same except the router library in order to align these versions and avoid confusion in the future angular team decided to go straight to an angular version 4 so in a sense angular 4 is not a major upgrade to angular 2 and you can think of it as angular 2.4 as simple as that now after all this confusion in the community about angular versions the team decided to drop the version suffix and simply call the framework angular so now we have two kinds of angular we have angularjs which is the first generation of angular written in JavaScript and it's going to die sooner or later and we also have angular which refers to angular 2 or later in our discussions in our articles and whenever we want to talk about angular 2 or later we should really use the word angular like I'm gonna angular developer instead of I'm gonna angular 2 developer or I'm an angular 4 developer see it's really weird we should use versions only when we need to talk about a specific release for example when we want to upgrade angular 4 to angular 5 then everybody knows what is the scope of this upgrade and what are the potential breaking changes that can impact an application so this is all about angular version history right now let me quickly give you an overview of how AB structured this course and how we can get the most out of it in the shortest possible time so in this course we have three parts essentials advanced topics and the final project we're going to start the essential part with an introduction to typescript and an objectoriented programming this will prepare you to build angular applications so then we'll look at angular fundamentals displaying data and handling events components directives template driven forms reactive forms consuming HTTP services routing and navigation authentication and authorization deployment and building realtime applications with firebase so these are the essentials that you will use frequently in realworld applications then we get into the territory of the advanced topics and my advanced I don't mean complicated I mean anything that is beyond the basics so in this part of the course I will cover animations angular material redux architecture unit testing and integration testing and over the last part we'll build that ecommerce application that I showed you at the beginning of the course this part also includes a few sections and in each section we'll build one module of functionality in this application so here we have sections like product management shopping cart checkout and so on now I understand that you might be busy and not have enough time to watch the entire course and that's perfectly fine so I'm gonna give you a shortcut a shortcut that allows you to get the most out of the course within the shortest possible time start with the essentials watch all these sections in sequence but feel free to skip the section called reactive forms because we're not going to use the materials in this section in our final project also you can skip consuming HTTP services as well as authentication and authorization you need to watch these sections if you want to be old backend for your application using frameworks such as a speed add net Express Django and so on but this ecommerce application will build in this course doesn't have a custom built backend we use firebase as the backend so things are a little bit different here if this sounds confusing to you don't worry I will clarify it in the section about firebase so here's my suggestion to you watch these sections in the essential part in sequence and then move to the final project part I want you to build this application because that's where you will see all these moving parts coming together plus those sections include tons and tons of tips and techniques that I've shared with you and these are the things I have learned over the past 17 years of working in the industry as a professional software developer they really change your thinking about programming and software engineering I've worked really hard for these sections and I want you to watch them once you finish the project then you will have a good understanding of the big picture then you can come back and learn about the other sections in the course in isolation depending on your needs for example if you want to learn how to add animations to your applications you can simply go watch the animation section or if you want to learn about reactive forms you can just go back to that section so focus on the absolute essentials and then move to the final project hi thank you for watching my angular tutorial if you enjoyed this video please like it and share it with others also you can subscribe to my channel for free new videos every week this video is part of my complete angular course with almost 30 hours of high quality content where you learn everything about angular from the basic to the advanced topics all in one course so you don't have to jump from one tutorial to another in case you're interested you can get this course with a big discount using the link in the video description and if not that's perfectly fine continue watching as the section is coming up in order to build applications with angular you need to be comfortable with type script so in this section I'm going to introduce you to the fundamentals of typescript and objectoriented programming principles so by the end of this section you will have a good understanding of type annotations arrow functions interfaces classes constructors access modifiers properties and modules if you are familiar with this concept and know how to implement them in typescript feel free to skip the section and move on to angular otherwise you really need to watch every lecture in this section so now let's get started so what is typescript typescript is not an entirely new language it's a superset of JavaScript so that means any valid JavaScript code is also valid typescript code but typescript has additional features that do not exist in the current version of JavaScript supported by most browsers out there for example in typescript we have this concept of strong or static typing if you have worked with languages like C sharp and Java you know that in these languages when we define a variable we need to specify the type of that variable now in time script typing is optional so we don't have to use this feature but using this feature makes our applications more predictable and it also makes it easier to debug them when something goes wrong typescript also brings quite a few objectoriented features that we have missed in JavaScript for a long time we have the concept of classes interfaces constructors access modifiers like public and private filled properties generics and so on you're going to learn about this in this section another benefit of using typescript is that with typescript we can catch errors at compile time instead of at runtime well of course not all kinds of errors but a lot of errors so there is a compilation step involved and when we compile our typescript code we can catch these errors and fix them before deploying our application and finally another benefit of using typescript is that we get access to some great tools out there one thing that I personally love about typescript is the intelligence that we get in our code editors again you're gonna see that in this section so typescript is a beautiful language and it's basically a superset of JavaScript so any valid JavaScript code is also valid typescript code now the browsers out there they don't understand typescript and it's very unlikely that they're going to support it in the future so we need to compile or more accurately transpile our typescript code into JavaScript so this is part of building our application whenever we build our application typescript compiler kicks in and it transpires our typescript code into JavaScript code that browsers can understand now that's enough introduction next I'm going to show you how to install typescript and write your first typescript program in this lecture I'm gonna show you how to install time script and write your first typescript program so here we are in the terminal we're not gonna work with angular in this section we're gonna purely focus on typescript so first we need to install typescript globally on our machine so npm install g which stands for global typescript and of course if you're on Mac get me to put sudo at the front all right beautiful so I've installed the latest version of typescript which is currently version 2.3.4 now we can type TS C which stands for typescript compiler version again you can see that I'm running type scribe 2.3.4 alright now I'm going to create a new folder for this section so let's call this TS hello let's go to this folder now here I'm gonna create a new file and open it with vs code so code main TS so now I'm gonna write some plain JavaScript code and I want to show you that all this JavaScript code is also valid typescript code so first I'm going to define a function let's call this log that takes a message and here we simply log that message on the console like this then I'm gonna declare a global variable let's call this message and set it to this string hello world and finally call our log function message so this is just plain JavaScript code right now save back in the terminal we need to transpile this type script file into JavaScript so TSC or typescript compiler may not yes not if you look at the files in this folder look we have main degeus and main dirty s now this transpilation or a compilation step when you're building an angular app happens under the hood so you don't have to manually call the typescript compiler in fact when you've run your application using ng serve angular CLI calls typescript compiler under the hood to transpile all our typescript code alright now let's open our main the J's file so code main is so it's exactly the same code that we wrote but now it's in JavaScript file so all JavaScript code is also valid typescript code now back in the terminal I can execute this code using node so node main is and we got the hello world message on the console so from the next lecture we're going to look at specific features of typescript that we don't currently have in JavaScript all right let's explore typescript by looking at variable declarations so in typescript there are two ways to declare a variable we can use the VAR keyword which you have seen in JavaScript like var number we set it to 1 or we can use the let keyword so let count to be 2 now before I explain the difference I need to clarify that the let keyword is also being added to the JavaScript so JavaScript has a few different versions we have es5 or a chemo script 5 which is the version of JavaScript supported by pretty much all browsers out there it's been around for a long time now we have es6 which is a newer version and it was introduced in year 2015 and from that point the ECMO script team which is the team extending Java Script decided to use the year number instead of the version number so we have a common script 2015 2016 and 2017 now in ECMO script 2015 which is basically es6 we also have this LED keyword but in case you are not familiar with it let me explain how it works so I'm going to define a function let's call it do something it doesn't really matter now here I'm gonna define a for block so var we said I to 0 and as long as I is less than 5 let's increment it here we have a block and then log it on the console now finally at the end of this function I'm gonna log this eye one more time but with the label finally and then I'm gonna call this function here so in the terminal I'm gonna compile this file main that TS and also at the same time run it with node main is note that the value of I at the end is 5 so this is the issue we have when declaring a variable using the VAR keyword so we have declared I here inside this for block but it's also meaningful and available outside the for block now if worked with languages like C sharp or Java you know that we don't have this concept in those languages in JavaScript a variable declared with the VAR keyword is scoped to the nearest function so in this case the nearest function is do something so once we declare I inside this for block it's available anywhere in this function now let's see what happens when we declare this variable using the let keyword so let now look we immediately got and red underline here which indicates a compilation error this is one of the beauties of typescript when you're a writing typescript code you can catch these errors at compile time before you run your application before you deploy it now let's hover our mouse here so this is the error cannot find name I so now I is scoped to the nearest block instead of nearest function and this is the proper way to declare variables which prevents a lot of issues later down the road now I want to clarify something let me see you again Spile back in the terminal first I'm gonna remove main Jas now I'm gonna recompile our main des TS okay we got our error here cannot find name I however if you look at the files in this folder we do have main the GS so even though we have a compilation error the typescript compiler still generated main dejay s let's have a look at the content of this file so this is the code that is generated so by default typescript compiler compiles our typescript code to es 5 or X my script 5 which is the older version of JavaScript that is supported by all browsers out there now there we don't have the lead keyword so that's why our compiled code now uses the VAR keyword and this is perfectly valid JavaScript code so I can go into terminal and simply run this code and get the same output as before so what I want to clarify here is the typescript compiler reports these errors but still generate valid scrape coat so here's a takeaway for this lecture from now on anywhere we want to declare a variable we use the lead keyword once again this does not stop the compilation step but at least we can catch the issues earlier during the compile time next we're going to look at different types we have and in typescript in this lecture I'm gonna show you different types we have in typescript so let me start by declaring a variable called count and set it to 5 now if I set this to let's say a character or a string like a note that I immediately get a compilation error here telling me that this a string or a character is not assignable to type number now we can perfectly do this in JavaScript because in JavaScript we can change the type of variables on the fly but in typescript we get a compilation error now once again I want to clarify that we can perfectly compile this using typescript compiler and we will get valid JavaScript code so if I go to terminal and type typescript compiler main the TS now look this is our main de Jas so we have this count variable and we have changed its value we can perfectly execute this no problem however code like this is very likely that it's going to break at some point in the future because chances are we're gonna use this count variable inside a fourblock so our program is gonna break at runtime we don't want this to happen right that's one of the reasons it's better to write the same code in typescript so at least we can get a warning during the compilation step now if you hover your mouse over this count variable look at the tooltip you can see a colon and number after a discount so this indicates the type of count variable in our program so here typescript compiler infer that the type of this variable should be a number because we set it to number 5 now what if I declare a variable without initializing it let's look at its type its type is now any and that's exactly like the variables with declare in JavaScript so I can set a to one then I can change the value to true and then set it to your string even typescript doesn't complain about this so what's the solution if we don't know the value of a variable ahead of time that's when we use type annotations so here we add and after that we set the type of this variable like number and then look on the third and fourth lines we got compilation errors now in typescript we have a few different types so we have number which can include any integer or floatingpoint numbers we have boolean s which can be true or false we have strings we have any that you saw earlier we have array so let's say we want to declare an array of numbers we would use a number with square brackets now we can optionally initialize this to an array like this or we can declare an any array and with this we can set this to an array with these values one true a and false of course it's not a good practice we want to avoid this but I'm telling you what is possible with typescript now we also have another type that I absolutely love and that's inna so let's say we are working with a group of related constants like colours so in plain old or vanilla JavaScript we would define constant colours like this so color red we can set this to zero constant color green we set this to one and constant color blue set it to two now this is a little bit verbose in a lot of objectoriented languages we have this concept called enum so we can put all these related constants in a container so in typescript we can declare an enum like this enum all lowercase we give you the name like color now curly braces and here we set the values so red green and blue then we can declare a variable like background color and set it to color dot now look we have intellisense here so this tooltip you see here allows us to complete this code without remembering all the details this is one of the things I love about typescript so let's set the background color to color dot red now in terms of the values the first element here automatically gets the value of zero and each subsequent element gets an incremented value so we don't have to explicitly set these but as a best practice it's better to do so because chances are sometime in the future someone may come here and add a new color here like purple and then purple would automatically become two and the value of blue would change to three so this may break parts of our application so let me revert this by explicitly setting the values if somebody adds a new color here like purple then it will not change the value of blue now let me show you something let's compile this code and see how we get enum in JavaScript so at a script compiler main TS look at this piece of code here this is how we can implement the concept of enums in JavaScript we can see it's very complicated now compare this with how we declare it an enum here it's much cleaner so the more you work with typescript the more you're gonna love this language in this lecture I'm going to show you the concept of type assertions in typescript so I'm gonna start by declaring a variable like message and sitting into your string now here we can type message dot I look we get this beautiful intellisense and in this tooltip we can see all the things we can do with a string so all these items with this purple icons are functions for example we have this function called ends with we can call this and see if this message and let's say we'd see and this returns a boolean so we can store the result in another variable like ends with C however sometimes typescript may be a little bit confused about the type of a variable for example I'm gonna remove this initialization here and initialize this variable on the second line ABC now look at the type of this message variable it's any because by default when we don't set a value the type is any now the problem here is that if I delete this and type period look we don't get that intellisense anymore because ends waste is something that we can do with a string not with an object of type any so what should we do in this case we need to explicitly tell typescript compiler that this message variable is actually a string and this is what we call type assertions now how do we do type assertions there are two ways one way is to prefix this variable with angle brackets and here we put the type like string now we need to enclose both these parts in parenthesis like this then if you press period we get our beautiful intellisense with all the functions or methods available on string objects now there is also another way to do type assertion so let's change the name of this variable to alternative way and here instead of angle brackets u.s. message as string they're exactly the same the approach to shoes is purely your personal preference but the first approach is what you see more in a lot of tutorials and code bases out there I just want to clarify something here this type assertion does not change the type of this variable at runtime in fact it's not going to restructure that object in memory it's purely a way to tell typescript compiler about the type of a variable so we can access the intellisense another concept you need to know when using typescript to build angular applications is the concept of arrow functions so in JavaScript we can declare a function like this let log we set this to a function this function takes a message object and simply logs it on the console like this now in time script there is a shorter way to define this function so let's call the other one do log now we don't need the function keyword anymore we can simply add the parameters in this case message then we add this arrow and that's why we call this an arrow function and finally the code block so console dot log message now if our function has only one line we can even exclude these curly braces so we can make this code a little bit shorter and cleaner like this if I worked with csharp we have seen this before and csharp we call this a lambda expression in typescript we call it an arrow function it's exactly the same thing now if you have one parameter here you can even exclude the parentheses but I personally don't like this because I think it makes the code a little bit less readable so I always like to put my parentheses here to indicate to the reader of this code that these are the parameters now what if you don't have any parameters we just add empty parentheses and of course here you don't have the message so if you have not seen this before get used to it it's a really nice and clean way to define functions all right now let's see how we can use custom types in typescript so I'm gonna start by declaring a function like draw point so this function takes an x and a y and simply draws it on the screen now we don't want to worry about the actual drawing algorithm we just want to focus on the signature of this function now this function is not too bad here we have only two parameters but sometimes when working with more complex concepts we may end up with a function that has so many parameters like this this is really really bad and it's something you should avoid at all times in those situations it's very likely that a group of these parameters maybe all of them belong to a single concept as an example think of a car a car has so many different properties we don't want to pass all those properties to a function like drive car instead you want to encapsulate them inside an object and only pass that one object here so in this example instead of passing x and y here it's better to pass a point object and then we can call this function like this draw a point we give it an object with two properties x and y so now our function has a cleaner syntax however there is a problem with this implementation instead of a point object I can pass a person object that has a name property I know where here we are getting a compile time error but we know that this code is gonna break at runtime because the algorithm in our drop point function is expecting x and y properties so what's the solution well let me revert this back okay we've got x and y so there are two solutions to solve this problem one way is to use what we call inline annotation so just like we can annotate this parameter with the type like number we can annotate it with a custom type or a custom object so here we add curly braces to indicate an object this object is going to have a property called X which is a number and also another property called Y which is again a number so this is what we call inline annotation it works fine for simple cases but the problem with this as you can see is that this is a little bit verbose also chances are somewhere else we might have another function that expects a point object we don't want to repeat this object literal in multiple places so in those cases a better approach is to use an interface if you worked with objectoriented programming languages like C sharp and Java you know the concept of interfaces we have the same concept in typescript now if you have never worked with interfaces let me show you how they work so on the top I define an interface and I'm gonna call this point curly braces then I add X is a number and Y is a number so with this interface I'm defining the shape of an object and then I can simplify this declaration and set the type of this parameter to point this is much cleaner and we can also reuse this in multiple places just one thing note the naming convention I have used here so because I'm introducing a custom type I've used Pascal naming convention so the first letter of every word in the name of the interface should be capitalized so here we have our per case P not a lowercase P okay so when using interfaces always use Pascal naming convention so in the last lecture we use an interface to define the shape of a point object but there is a problem with this implementation in objectoriented programming languages we have this concept called cohesion which basically means things that are related should be part of one unit they should go together this is what we call cohesion now back to this example on the top we have used an interface to define the shape of a point object and below that we have a standalone function and this is where we have violated the cohesion principle so the concept of drawing a point is highly related to the structure of a point it should not be a separate function now if you're going to build a utility library for working with points chances are you're going to create another function like get distance that calculates the distance between two points so point a of type point and point B of type point and this goes to is code block again we have violated the cohesion principle we have two functions hanging in the air separate from the point object since these concepts are highly related they should be part of one unit in objectoriented languages we call that unit a class so a class groups properties and functions that are highly related now in this implementation unfortunately we cannot move these two functions inside our interface because interfaces are purely for declarations they cannot include an implementation in other words we cannot have the algorithm for calculating the distance between two points or drawing a point inside this interface what we can do instead is to add a function here a function declaration so we're gonna have a draw function that takes no parameters and returns void which means it doesn't return anything now you might be asking why don't we have this point parameter here because if all these members X Y and draw are part of one unit we don't need to pass x and y as parameters to the draw function this function can directly access these properties x and y in the same unit so we don't need this parameter here now in interfaces as I said we cannot have implementation we can only have the signature of a function so with this interface we are telling typescript compiler that our point objects should have two properties x and y and a function called draw the implementation of that is somewhere else so what should we do now to apply the cohesion principle here we need to use a class instead of an interface so on the top I'm gonna change the type to class and here I'm gonna replace is comma with semicolon so our point class has three members the first two members are what we call fields that we use for storing data and the third member is a function now here in this class we can have the actual implementation of this draw function so we can simply define it like this draw and then add all that logic for drawing a point now similarly we can have another function get distance that returns the distance between this point and another point like this again all that logic will end up here now with this restructuring you can see that everything about a point is in one unit in one class so we have the coordinate which includes x and y and two functions draw and get distance now in objectoriented programming terms we refer to these members as fields and to these functions as methods so when a function is part of a class we call it a method alright now with this new implementation you don't want these two functions hanging in the air so delete this is a much better structure also you're not gonna call draw a point like this anymore so here's our point class in the next lecture I'm gonna show you how to create an object of this type and call the draw method you all right so here's our class now let's declare a variable of this type so let point be of type point and then we can type point dot look we have this beautiful intellisense we have two methods draw and get distance and two fields x and y now in time script we also have a concept called property which is different from a field but a lot of people use these terms interchangeably later in this section you're gonna learn the difference between fields and properties now if you wanna call the draw method simply call it like this so this draw method is now part of the concept of a point it's not a function hanging in the air polluting the global namespace now for this demo I'm gonna add a simple console dot log here and display the coordinate at this point so X now here I want to add the X field what we cannot use it like this we need to prefix it with this dot so that refers to this field in this class and then I'm gonna add Y is once again this dot Y now let us compile and run this program and see what happens so TSC what should we type here main the TS and we can shortcut by adding this pipe here type node and then main ajs okay you got a runtime error cannot read property draw of undefined so this is the problem when we call this draw method this point object was undefined because here unlike the basic types we have in typescript like numbers strings billions we're dealing with a custom type when defining an object of a custom type we need to explicitly allocate memory to it how do we do that well here where we declare the point object or the point variable we initialize it using the new operator so this object is a new point and here we add parentheses this is the syntax now you can see that we have repeated this point here twice so we can make this code a little bit cleaner by removing this type annotation because typescript compiler can infer from this assignment here that the type of this object is a point object and let's verify that so look you're working with a point object now one more time save so back in the terminal typescript compiler main the TS and then note main that is okay we didn't get an error but you can see that these x and y fields don't have a value because by default they are undefined so we can get back here and set point that x to let's say 1 and point out y 2 now back in the terminal typescript compiler main dot TS i actually made a mistake earlier so instead of this pipe operator we need to use double ampersand on Mac I don't know the Windows equivalent so with this we can combine multiple comments so note main that is all right beautiful X is 1 and Y is 2 so this is how we use the classes that we define in our programs that one highlight something here this point here is a class but this point here is an object an object is an instance of a class as a metaphor think of the concept of a human human could be a class but when we create instances of this class like John Bob Mary these are all objects so that's the difference between a class and an object next we're gonna look at constructors all right so I've simplified the code from the last lecture I simply remove the method get distance because we're not going to use it later in this section so here on the top we define a point class and then below that we initialize a point object now this code is a little bit verbose because we have three lines to create a point object and put it in a valid State what if this point object had a few other properties that we had to initialize like this and maybe a few more here is there a cleaner way absolutely so let me delete this first all right in objectoriented programming languages we have this concept called constructor so every class can have a constructor which is basically a method that is called when we create an instance of that class so let me show you how it works in the class I'm gonna add a method the name of this method is constructor this is a reserved keyword in typescript now this method can have parameters so X which is a number and Y which is also a number and then here in this method we can initialize these fields so what should be right here this dot X we set it to this X argument that we get here and similarly this that Y we set it to Y now look we got a compilation error here because when creating a new point object we need to supply these values look at the error supplied parameters do not match any signature of call target so here we need to supply the values for X and y1 and to and with this we can simplify this code and get rid of these two extra lines and here's the end result now what if somewhere else in our program we don't know the initial coordinate of a point in other words what if I want to create a point object without setting these values is that possible yes absolutely but it's a little bit different from how you have seen that in other languages like C sharp and Java in csharp we can have multiple constructors in typescript we can't so the solution for this is to make these parameters optional so here after X I add a question mark and that makes X optional and similarly Y should be optional as well because once you make it parameter optional all the other parameters on the right side of that parameter should also be optional this is a rule by typescript and a lot of other programming languages so now look we don't have a compilation error when creating a point object without initial values all right so here I've created a point object with an initial coordinate now what do you thin our program you want to have this rule such that when we initialize a point object we should not be able to change the X or Y values with this implementation I can always come here and set point that X to a different value how can we avoid this sometimes we need this feature in our programs because it will make them more predictable it reduces the chance for bugs so how should we prevent the coordinate of this point object to change after it's initialized well in objectoriented languages we have this concept called access modifiers an access modifier is basically a keyword that we can apply to a member of a class to control its access from the outside so in typescript we have three access modifiers public private and protected public and private are the most common and by default all members are public let me show you what I mean so here in our point class we have three members right we have two fields and one method so let me create a point object and type point dot look these are the members of the class and because they are all public we can access them here and that's why we can see them in the intellisense however i can go here and prefix this field with the private key word now once we create this point object if I type point dot look X is not in the list it's not accessible it's private so if we try to set point at X 2/3 look we have a compilation error in typescript it says property X is private and only accessible within class point now with this technique I can go here and I applied the private keyword on the Y field as well and now once I initialize a point object I can no longer change is quite innate I can only call the draw method ok so this is why we access modifiers to control access to certain members of a class from the outside you can apply these access modifiers on field properties and methods now by default if you don't set an access modifier is assumed to be public so here the draw method as you know is public I can also add the public key word here but this is redundant it's just making my code noisy so you don't really need to add this it's better to keep your code short and clean and use the private access modifier only when you need to next I'm gonna show you one of my favorite features of typescript around access modifiers as you write code with typescript you see constructors that follow a pattern like what you see here so here we have two parameters in our constructor and we use these two parameters to initialize the fields in this class the code looks a little bit redundant this that x equals x and this dot y equals y typescript as a fantastic feature that helps you achieve the same thing with less code so here we can delete these two fields here and in our constructor we can prefix our parameters with an access modifier so here I want to have two private fields x and y i can simply prefix these with the private keyword like this so typescript compiler will generate these fields for us and also you don't need these ugly repetitive assignments either so if he prefix a constructor parameter with an access modifier with a private or public typescript compiler will generate a field with the exact same name and it would also initialize that field with the value of this argument it's one of my favorite features and you're gonna see that a lot in this course now clarify something before we finish this lecture in this case our fills were private but if they were public we would use the public key word here so this means when we create a pointer object we can access the X field okay so I'm gonna revert this back to the private all right now this implementation has a tiny problem we can set the initial coordinate of this point and we can also draw it but there is no way for us to read the coordinate so I cannot access point that the X here so display to the user what's the workaround well one simple solution is to define a method like this yet X and here we simply return this that X because in this class we do have access to all the private members of this class but we cannot access them from the outside okay now here I can always call point that get X to get the x value and display to the user now let's talk about another use case maybe we want to give the user the ability to set the inertial coordinate here but we also want them to be able to change this coordinate later only if they provide a value within a given range what do I mean by that let me show you I'm gonna define another method here set X now this method is gonna get a value that's the new value for the eggs field let me scroll down now here first we can do some basic validation so if value is less than zero we want to throw an error throw new error value cannot be less than zero otherwise we want to set this well x2 this new value okay now with this implementation we can always change the value of the X field like this point that set X we set it to a new value now if you have a use case like that in your applications you can use what we call a property so in typescript and in a lot of objectoriented programming languages we have a concept called property which is exactly for this very use case so look at how I can define a property here we start with the keyword which is get or set and then the name of the property which is in this case X and after that we're gonna have parentheses just like a method okay now similarly I'm gonna change this to set with a space so we have the set keyword and here it's like we have a function and method now what is the difference the difference is that we can use these properties like fields so here I can read X like this dot note the icon of X it's the same icon we have for fields it's not a method anymore so we can read X and we can also set it like this point that eggs we set it to 10 we don't have to call a method like this it's a cleaner syntax okay so this is what properties are for if you have private fields that you want to give maybe a readonly access to the outside or if you want to give the consumer of your classes the ability to set the values but you want to have some basic validation that's when you use a property now in this case if I want to give only the readonly access to this underlying field I can simply comment out the setter so we call this method a setter and the other method a getter okay I now look at this compilation error we cannot change the value of x now let's bring this back one last thing before we finish this lecture so here I have used a capital X for the name of my X property in JavaScript and in type scrape we use camel notation to name our field so that's why earlier we define this private field here within camel casing notation camel casing means the first letter of the first word is lowercase and the first letter of every word after is uppercase now what should we do to use camel casing notation for our properties if I name this the lowercase eggs it clashes with the existing field so let me revert this back a convention we use to solve this problem is to prefix the name of the underlying field with an underline so let's rename this using f2 and prefix it with an underline okay similarly for the Y parameter or the y field I'm also going to use underline Y then we can rename this property from capital X to lowercase X once again we press f2 lowercase X and note that both instances both the getter and the setter are updated now we can work with this X property exactly the same way use the X field so here's the lesson a property looks like your field from the outside but internally it's really a method in the class well more accurately it's either one method which is a getter or a setter or a combination of a getter and a setter all right I've simplified the definition of the point class I remove the properties so we have a simple constructor and a draw method and we're using this point class below its definition now this is a very simple program with only one file but the real world application consists of tens or hundreds of files we don't want to write all the code in one file like main the TS so ideally I want to move the definition of this point class somewhere else in a file like point the TS so here in this project I'm gonna add a new file point a TS now back in Maine the TS I'm gonna select all this code cut it and move it to point a TS now in typescript we have this concept called modules now what a module is requires a little bit more explanation but for now let me give you a simple pragmatic definition in typescript you can think of each file as a module so in this program we can say we have two modules but this is not quite accurate because these files are not modules yet so in point of TS we have defined this class called point but this is not accessible anywhere outside this file so this file defines its own scope in order for us to use this class somewhere else in our program we need to export this to the outside so we add the export keyword here and now this is visible outside this file now that we're exporting something on top of this file from type scripts point of view this file is a module now we need to go back to our main de TS and import this class so we can use it so back in main the TS look we have a compilation error cannot find name point because we have not imported this into main the TS so on the top right import in curly braces we add the name of the types we want to import in this case point now if there are multiple types you want to import we separate them using comma okay so we import point from now here we put the name of the module in quotes what is the name of the module it's the relative pass to that module from this file so both these files are in the same folder we can use period slash which refers to the current folder and then point is the name of our module so it's not point that TS look we get a compilation error so the name of our module is point now we no longer have a compilation error here and we can create an instance of this point class and use it now there is a lot more to talk about when it comes to modularity in typescript but that's all you need to know for now in order to start building applications with angular because in angular framework we have a lot of types that are exported so we need to import these into our typescript files and use them you're gonna see that a lot in this course the only difference is that angular modules are defined in a different way so we don't add the relative path to this module files because these files are not really part of our application they're somewhere inside node underline modules folder so when it comes to importing types defined in angular we use the library name as the module name for example one of the libraries is at angular slash core okay so here's the lesson in typescript we divide our program into multiple files in each file we export one or more types these types can be classes functions simple variables or objects and wherever we need to use these types we need to import them first when we have an import or export statement on top of a file that file is a module from type scripts point of view in angular we also have the concept of modules but angular modules are a little bit different they are not about organization of code in different files they are about organization of your application into smaller functional areas you're going to learn about angular modules in the next section I love your enthusiasm for learning angular as I told you before this tutorial is part of my complete in ela course where you learn everything about angular from the basic to the advanced topics all in one course you seem to be determined enough to learn angular and I'm so excited to see you made it this far so I highly recommend you to click on the link in the video description and enroll in my complete angular course so thank you for watching if you enjoyed this video please like it and share it with others and finally subscribe to my channel for free new videos every week have a great day in this section we're going to look at the fundamentals of building applications with angular by the end of this section you will have a basic understanding of angular building blocks such as components templates directives and services so now let's get started so now that you have some basic familiarity with angular let's look at the building blocks of angular apps at the heart of every angular app we have one or more components in fact in a real world app we have tens or hundreds of components but what is a component a component encapsulate the data the HTML markup and the logic for a view which is the area of the screen that the user sees let's look at the real world example imagine we're gonna build a website like udemy so on this page we have a navigation bar a sidebar and an area to display the list of courses now we can think of all this as one view or one component or we can break this view into smaller more maintainable and potentially reusable components like navbar component sidebar component and courses component similarly in courses component we want to display one or more courses potentially we can break up this component into smaller components and also to take this to the next level each course component can include a rating component now we can reuse this rating component in multiple places in the same app or in an internal different app as you see angular embraces componentbased architecture which allows us to work on smaller and more maintainable pieces that can also be reused in different places so once again a component encapsulate the data the HTML markup and the logic for a view which is an area of the screen that the user sees every application has at least one component which we call app component or route component a real word angular app is essentially a tree of components starting from the app component or the route component now in angular also have another concept called modules a module is a container for a group of related components every angular app has at least one module which we call app module as your application grows you may want to break that module into smaller more maintainable modules so in our udemy example we can potentially have modules like course module which includes all the components for displaying courses we can potentially have another module like messaging module which includes a bunch of components for the area of the website where you can send private messages to your instructors we can have an instructor module which includes the components for instructors dashboards that you don't see and potentially an admin module which is the area of the udemy website by the udemy staff as an analogy think of a supermarket in a supermarket we have different aisles for different products we have a section for fruits and vegetables we have another section for snacks another for hardware and so on the bigger the supermarket the more aisles we have in a tiny grocery store we have probably one or two aisles at the most the same applies to our angular apps so if you're building a simple application we have only one module which we call the app module but as our application grows in functionality we may need to break that module into smaller modules with each module responsible for a specific area of our application in that module we have a bunch of related components okay so this is the big picture as we go through this course you will learn about these building blocks in more detail all right now let's see these components in action there are basically three steps you need to follow in order to use a component first you need to create a component second you need to register that component in a module and third you need to add an element in your HTML markup let me show you what I mean by this so back in our first angular project first of all make sure to run and you serve to serve this application so now if you head over to local host port 4200 this is what you see beautiful now back in vs coal I'm gonna create a new component so let's open up the file panel here in the source folder under app here I'm gonna add a new file now let's imagine I want to create a component to display the list of courses so look how I named this file courses dot component dot TS this is the convention that we use when building angular applications now if the name of the component has multiple words we separate them using a hyphen for example if you're building a component called course form it would call this course form and then dot component TS okay so courses component the TS now here we start by creating a plane type script class so class courses component once again look at the naming convention here I'm using the Pascal naming convention so the first letter of every word should be capital and also by convention we use the suffix component in the name of the class so here's our class in order for angular to see this class first we need to export it now so far we have only a plain typescript class this is not a component in order to convert this to a component we need to add some metadata to it that angular understands we use a decorator to achieve this in angular we have a decorator called component that we can attach to a class to make the class a component so first we need to import this decorator on the top so import curly braces component from now the name of the library so at angular slash core this is the core library of angular that you're going to see a lot in this course so here we import the component decorator and then we need to apply it there is tax class now look at the syntax we use add sign component and then call this like a function so this is what we call a decorator function now this function as you see here takes an argument so here we pass an object and in this object we add one or more properties to tell angular how this component works for example one property that we use quite often is selector so selector and we set this to a CSS selector so in CSS if I want to reference an element like this I use a selector like this if I want to reference an element like a div that has a class called courses my selector would be dot courses right and if I want to reference an element with the ID courses this is my selector just basic CSS okay so here we want to reference an element called courses why because with components we can extend HTML vocabulary so we can define new elements like courses and inside that we will have the list of courses or in the future we can define a custom elements a custom HTML element called rating and wherever we use that angular will render a rating component ok so let's delete this my selector for this component is courses now the second property we add here is template and that's the HTML markup we want to be rendered for this component now here I want to render something very simple so let's just add an h2 element and call this courses in a real world application our templates can be several lines of code in that case we can put them in a separate file and I'm gonna show you how that works later in the course so this is a basic component in angular that was the first step the second step is to register this component in a module that currently our application has only one module which we call app module let me show you where that is so back here in the app folder look we have app but module now once again here we have three import statements on the top so nothing special here on the bottom we have a typescript class called app module and note that this class is decorated with another decorator function called ng module so with this we convert a plane Tasker class to a module from angular point of view now don't worry about all these properties here like declarations import providers and bootstrap you're going to learn about them later in the course what I want you to focus on now is this property declarations and this is where we add all the components that are part of this module so by default when we generate an application we have one component called app component and you can see that component is part of this module now I'm gonna add our new component here so courses component so whenever I type the name of a class here and press ENTER it automatically imported on top of my file so import courses component from and here's the name of our typescript module so period slash which refers to the current folder and here's the name of the file courses that component I know that here we don't have dot TS in fact if you add that typescript compiler it doesn't like that so the name of the module is just the name of the file without the extension so if you want to add this plugin to vs code simply go here and in the extension search box search for auto import so currently I'm using auto import one point to point to simply install it and then you'll have to restart yes code alright so here's our second step now the third step back to our component so this is the selector for this component which means anywhere we have an element like courses angular is going to render the template for this component inside that element but where are we going to add that element let me show you so back here in the app folder we have this app dot component at HTML this is the external template for our app component let's have a look so all this markup you see here is for rendering the homepage and this is what we get now I want to simplify this I'm gonna get rid of all this markup add a simple h1 call this angular and below that I'm gonna add our custom element courses so when angular sees this element it's going to render the template of our courses component all right now back in the browser this is our new home page so let's right click this courses element and inspect this so look what we have here we have this h1 and below that we have our courses element and inside this you can see we have the template for our courses component so this is how angular applications work as another example look at this app root element inside the body element where is this app root well I can the source folder look at index dot HTML so this is the basic template for our application right now inside the body element we have an element called app root this is a custom element because we don't have an element in HTML called app root so from angular point of view we should have a component with a selector for this element and that's our app component let's have a look at that so back in the app folder let's look at an app that component at es so here's our root component or app component look at the selector app that's root so whenever angular sees an element like that it's going to render the template for this component inside that element in this case our template is external so if we have template URL and you can see the name of our template file after component at HTML so that's why inside app root here we have the template for app component which includes an h1 and the courses element all right let's quickly review what we have done so far so we created this courses component here then we register this inapp module so here in apt of module we added our component inside the declarations array and then finally use this component in the template for app component so let's create a review after the component at HTML added this courses element here three steps okay now there are two problems with this approach the first problem is that this approach is a little bit tedious there are so many steps so first we had to create this typescript class then we had to import this component decorator on the top and next we had to apply it on this tab script class there is so much boilerplate code here now the second issue is that if you forget the second step our application is gonna break let me show you what happens so let's go to app dot module I'm gonna delay it this line here now let's see what happens back in the browser we got a blank page so now we need to look at the console tab of Chrome developer tools so right click anywhere on the page inspect so we can see we have two errors here we can see the details of these errors in the console tab so here's the error courses is not a known element so if you don't register a component in a module angular doesn't know about it and it doesn't know what to do with this courses element because this is not a native HTML element so now let me show you a quicker and more reliable way to create an angular component we need to go back to the terminal but look our terminal is always busy it's serving the application so we either have to open a new terminal window or we can actually open a terminal window inside vs code so back here if you press ctrl and backtick which is the character before the number 1 on your keyboard look we have a term here and this is much easier to access and going back and forth between different windows so here we can use angular CLI to generate a component so just like how we generated an application with ng new we can also generate a component with this ng so the syntax is like this ng space G which is short for generate and C which is short for component and then the name of the component let's say we want to create a component called course so of course look at what happened angular CLI created a directory called course and inside this directory added four files a CSS file for storing the style sheets for this component an HTML file for storing the template a spec file which is for writing unit tests for this component and finally a typescript file which is the actual component itself now what is interesting here is that it also updated app dot module and registered this new component let's have a look so we can close this terminal window using the same shortcut which is control and backtick now we can open the files panel using command + b on mac or control B on windows ok look at after module so look inside the declarations array now we have course component so this way we don't have to remember to come back here and register our new components now before we move on let me just quickly add our courses component that I removed earlier ok now back in the files panel this is the folder for our new component so in this folder we have these four files now let's take a look at the typescript class it has all the boilerplate code that we wrote earlier plus a little bit more so here we're importing the component decorator and on Innes which is an interface we're going to look at this later in the course we have this component decorator apply to our typescript class we have a selector you have the URL of our template file as well as the URL of our style sheet file so angular CLI saves us a lot of time now as we go through this course I will show you how you can use this tool to generate other building blocks for your applications so earlier I told you that a component encapsulate the data the logic and the HTML markup for review so in this example in our courses component we have the HTML markup but we don't have any data or any logic so let's extend this example and take it to the next level I want to define a field in this class to hold the title of this page so title I'm going to set this to list of courses now I'm going to display this title in our template dynamically so I'm gonna remove this hardcoded label here in angular we have this special syntax double curly braces and we use this to render something in our template dynamically so here I can put this title field this expression will be evaluated at runtime and the value of this title field will be placed in our Dom now if the value of this title field changes at some point in the future angular will automatically update the Dom this is one of the beauties of angular framework so here we have this concept of data binding so your binding our view to have filled in this component whenever the value of that field changes the view is automatically notified and updated all right now let's save the changes back in the browser alright here's our new title beautiful now back here we don't always have to put the name of a field here we can write any simple JavaScript expressions for example I can put a string here title colon and then concatenate this with our title field save look this is our new title here we can also call a method in this class to get some value for example let me define a method get title and here I'm gonna return this the title now here we can simply call our new method get title like this and we'll get the exact same result there you go list of courses so this special syntax here we call it string interpolation in the next lecture I'm going to show you how to render a list of courses here alright now let's take this example to the next level instead of displaying a simple title field you want to display the list of courses so first we need a field to hold the list of courses so courses we set this to an array with three items course one course two and course three now this is a simplified example in a real world application instead of simple strings here we would have objects but don't worry we're gonna get there now I want to display these in our template how should we do that first we need to change this single code to the backtick character so delete backtick backtick is the character before number 1 on your keyboard let me change this as well now the benefit of using the backtick is that we can break up this template into multiple lines and make it more readable so I want to put this h2 here and below that I want to add a ul and a bunch of list item elements like this now we want to repeat this Li for each course now for that we need to use one of the angular building blocks called directive we use directives to manipulate the Dom we can use them to add a Dom element or remove an existing Dom element or change the class of a Dom element or its style and so on so here we're going to use a special directive called NG for we use it like an attribute in HTML so we set it to a string and here we're gonna write some expression now before going any further we should prefix this attribute with an asterisk this is a special syntax in angular so whenever you are using a directive that modifies the structure of a dumb you should prefix that directive with an asterisk in case you're curious about the reason I have covered it later in the section about directives so for now just remember whenever you are using a directive that modifies the structure of the Dom by adding or removing an element you need to fix that with an asterisk now here we want to write an expression similar to what we write in for each blocks so let course of courses what does this mean with the lead keyword we are defining a variable so the name of our variable is course this is like a loop variable in JavaScript all is a special keyword and courses is the field in this class that we are iterating over so when angular sees this expression it's going to iterate over the courses field and in each iteration this course variable will hold the value of one course at a time now inside this list I know you want to display this course so once again we use string interpolation double curly braces and add this course variable here let's look at the result save back in the browser and here we have the list of our courses beautiful now in most realworld applications we get this courses from the server and for that we need to use another building block of and get a called a service and that's the topic for the next lecture right now we have the list of courses here but in a real world application most of the time we get these courses from the server so instead of hardcoding them here we need to call an HTTP endpoint to get the list of courses now here we have two options one is to add the logic for calling an HTTP service here in this component but there are a couple of problems with this approach the first problem is that this logic is going to tightly couple this component to that HTTP endpoint now in the future when we want to write unit tests for this class we don't want to be dependent upon a live HTTP endpoint because this is going to make it harder to execute those unit tests so we want to create a fake implementation of an HTTP service so this is the first issue with writing this logic inside this class inside this component it's going to tightly couple this component to that HTTP endpoint the second issue is that maybe somewhere else in the application we're going to have another page where we display the list of courses maybe it's part of a dashboard maybe somewhere for an admin with this implementation we have to repeat this logic the logic for consuming that HTTP service in multiple places and that's not good and finally the third issue with this implementation is that a component should not include any logic other than the presentation logic that is the logic behind this view what should happen when we click upon when we select an item from a dropdown list and so on details of how courses are retrieved should be delegated somewhere else in your application so where should we implement that logic in angular we use services for that so we're going to define a separate class which we call a service and there we'll add this logic for getting the list of courses from an HTTP service then we can reuse this class in multiple places so let me show you how to do that here in the app folder I'm gonna add a new file now look at the naming convention courses dot service the TS so the name of our service is courses and by convention we have the word service in the file name and finally TS when creating a component we use courses does component at TS so note the difference now here once again you want to export a plane type script class so export class courses service so once again by convention we add the word service as a suffix in the class name now when creating components we decorate this class with the component decorator remember component but in angular we don't have a decorator for services so a service is essentially a plane type script class so delete now here we want to add a method for getting the list of courses get courses for now we don't want to get distracted with the complexity of consuming an HTTP service so let's just return the same array that we had in our component and later I will show you how to consume an HTTP service so back in our component I'm going to select this array here cut back in the service and simply return it from this method now imagine here in this method we have that logic for consuming an HTTP service with this implementation we can reuse this class we can reuse this logic in multiple places in our application and also this will separate or decouple our component from this logic so back in our component here we are not going to have any logic for consuming an HTTP service and this allows us to unit test this class without dependency upon that HTTP endpoint so while unit testing in this class we can provide a fake implementation of net service now if that's too complicated don't worry about it your testing is something for the future okay now we have a service we need to use this service in our component how that's the topic for the next lecture okay now we have a service to get the list of courses from the server we need to use this service in this courses component so first we need to add a constructor here constructor because a constructor is where we initialize an object so here we need to create an instance of our courses service something like this let service be new courses service once again I'm using the auto import plugin so when I press ENTER it automatically adds the import statement here on the top so I'll import courses service from current folder courses dot service all right now back in the constructor so we have a service and then we can initialize this course is filled like this this that courses we set this to service that get courses let's test the application and make sure everything works up to this point save okay we get the same list beautiful however there is a problem with this implementation the first problem is that by using this new operator here we have tightly coupled this courses component to the courses service so this is exactly like the problem we had earlier if we implemented the logic for consuming an HTTP service inside this component we wouldn't be able to unit test this class now we put this logic in a different class courses service but because we're directly creating an instance of this class here we're still tightly coupled to that implementation the other issue here is that if in the future we decide to add a parameter to the constructor of course a service we have to come back here and anywhere else in our application where we have used this courses service and add a new argument like one so any time we change the constructor of this service we end up with multiple changes in our application code so this is very fragile so what should we do well in we creating an instance of the courses service we can ask angular to do that for us so we can delete this line here and add a parameter in this constructor call it service of type courses service with this when anger is going to create an instance or component it looks at this constructor is that this constructor has a dependency this dependency is of type courses service so first it creates an instance of the courses service and then passes that to this constructor now with this implementation if we change the constructor of courses service and add a new parameter we don't have to modify a hundred places in our code to reflect the change angular will automatically instantiate a new courses service object the second benefit of this implementation is that when we're going to unit test this courses component instead of supplying an actual courses service to this constructor we can create a fake implementation of this service that doesn't use at HTTP service on the backend in other words we have decoupled our courses component from courses service so here's the lesson when you use the new operator like this inside a class you have tightly coupled your class to that implementation you cannot change this at runtime but when you add that dependency as a parameter of a constructor you have decoupled that class from that dependency now you're not done yet we need to instruct angular to create an instance of course a service and pass it to our courses component this concept is called dependency injection so we should instruct angular to inject the dependencies of this component into its constructor as simple as that that's dependency injection a lot of people think dependency injection is so complicated but it's really a $25 term for a fivecent concept so dependency injection means injecting or providing the dependencies of a class into its constructor now angular has a dependency injection framework built into it so when it's going to create an instance of a component it can inject the dependencies but in order for that to work we need to register these dependencies somewhere in our module so let's save the changes now we need to go to our app dot module so here's app dot module okay look at this engine module decorator here we have a property called providers which is set to an empty array in this array we need to register all the dependencies that components in this module are dependent upon for example our courses component is dependent upon courses service so we need to register courses service as a provider in this module so here I'm gonna add courses service now if you forget this step dependency injection is not gonna work let me show you what happens so I'm gonna comment out this line save back to the browser we get a blank page so that means something is wrong let's open up chrome developer tools with shift command and I on Mac or shift ctrl I on Windows look at this error no provider for courses service this is an error that you might see quite often when building angular apps so the error is telling us that we have not registered courses service as a provider in our module so back in an app module I'm gonna add this courses service here save back in the browser and we have the list of courses now one more thing before we finish this lecture when you register at dependency as a provider in a module angular will create a single instance of that class for that entire module so imagine in this module we have 100 components and 50 of these components need the courses service in the memory we're gonna have only a single instance of course a service an angular will pass the same instance to all these components this is what we call the single on pattern so a single instance of a given object exists in the memory so a quick roundup vacuumer component we added courses service as a parameter in the constructor or in other words as a dependency of this class and then register this as a provider in our app module with this implementation when angular is going to create an instance of this component first it will instantiate its dependencies and then it will inject those dependencies into the constructor of this class and this is what we call dependency injection all right now let me show you a quick way to create a service in angular so we go to the terminal once again you can switch to the terminal window or you can press ctrl and backtick in vs code so here we have a small terminal window we're gonna use angular CLI to generate a service so ng g4 generate previously we use c4 components now we're gonna use s for services imagine we're going to create a service for sending emails this service is going to call an HTTP endpoint somewhere for sending these emails so let's call this email I know that here I just add the service name I don't need to add dot service ok so this generates two files for us one is the actual service file and the other is a spec file which includes some boilerplate code for writing unit tests for that service so in the app folder look here's our new service email that service the TS so we have a plain typescript class called email service but there is something extra here that you didn't see before we have this injectable which is another decorator function similar to the component decorator function what do we need this here we would need this decorator only if this service had dependencies in its constructor for example imagine here we had a dependency lock log service of type log service in this case we need to apply this injectable decorate a function on this class and this tells angular that this class is an injectable class which means angular should be able to inject dependencies of this class into its constructor now we didn't use this decorator when defining components because when we use the component decorator that decorator internally includes this injectable decorator so that's all about injectable and by the way note that this decorator function is defined in angular slash core library right now I want you to use what you have learned in this section and build a page like this so apart from the main heading of our application you have a heading that includes the number of authors so here we have three authors and below that we have the name of these authors rendered using ul and Li so use angular CLI to generate a component and a service and write all the necessary code render a view like this you can see my solution in the next lecture I love your enthusiasm for learning angular as I told you before this tutorial is part of my complete in ela course where you learn everything about angular from the basic to the advanced topics all in one course you seem to be determined enough to learn angular and I'm so excited to see we've made it this far so I highly recommend you to click on the link in the video description and enroll in my complete angular course so thank you for watching if you enjoyed this video please like it and share it with others and finally subscribe to my channel for free new videos every week have a great day
