With timestamps:

00:00 - [Music]
00:01 - in this section you're going to learn
00:03 - how to write automated tests through
00:06 - angular2 apps whether you're an absolute
00:08 - beginner or have some experience in
00:11 - automated testing I'm going to take you
00:13 - from the ground and teach you how to
00:15 - write automated tests for your angular
00:17 - apps so I'm not assuming any prior
00:20 - knowledge of automated testing so we're
00:23 - going to start with a quick introduction
00:24 - to automatic testing its benefits when
00:27 - to use it and why then we're going to
00:29 - look at different types of automated
00:31 - tests their pros and cons and then we'll
00:34 - get into the mechanics we're going to
00:36 - start with a few simple examples and
00:38 - then as you go through this section the
00:41 - examples get more and more complex
00:43 - these examples are based on the patterns
00:46 - that you see in a lot of real-world
00:48 - applications so for each pattern I will
00:51 - show you what you need to test and how
00:53 - to do it next I'm going to show you how
00:55 - to find out how much of your code is
00:58 - covered by tests and finally at the end
01:01 - of the section I'm going to give you
01:02 - some exercises to put what you learn in
01:04 - practice so there is a lot to cover now
01:07 - let's get started so what is automated
01:13 - testing is it a replacement for manual
01:15 - testing do I really need it how should I
01:18 - do it actually write my tests first
01:20 - which we call test-driven development or
01:22 - should I write the application code
01:24 - first launch I don't know what to test
01:26 - these are the questions that a lot of
01:29 - beginners - automatic testing as well as
01:32 - developers who have some experience
01:33 - having their head so let's start with
01:35 - the first one
01:36 - what is automated testing automatic
01:39 - testing is basically the practice of
01:41 - writing code to test our code and then
01:44 - run those tests in an automated fashion
01:46 - so here is an example imagine we have
01:49 - this function somewhere in our
01:50 - application it's a basic calculate
01:52 - function it takes an input and depending
01:55 - on some conditions and return different
01:57 - values now in light of this function is
01:59 - used somewhere in the application with
02:02 - manual testing we have to launch the
02:04 - application in the browser perhaps you
02:06 - have to login for maybe do a few clicks
02:09 - here and there to get to the target page
02:10 - then we have to enter value us into a
02:13 - few
02:13 - formfields so eventually this function
02:16 - is called now this is very
02:18 - time-consuming this whole cycle to
02:20 - execute this function in a manual
02:22 - fashion may take 30 seconds overtime
02:24 - with automated testing we can write code
02:28 - and directly call this function with
02:30 - different inputs and then we can run
02:32 - this code in an automated fashion and
02:34 - this may take only a fraction of second
02:37 - to test this function with different
02:39 - inputs so with this practice we can test
02:42 - a large part of our application
02:44 - functionality and maybe the internal
02:46 - application in an automated fashion
02:47 - several times faster than a manual
02:50 - tester now here we've got this
02:52 - opinionated developer John Smith and he
02:55 - believes writing all these tests is time
02:58 - consuming because not only do we have to
03:00 - write the application code which we
03:02 - refer to as production code but we also
03:04 - have to write the test code so
03:07 - implementing a new feature with tests
03:09 - will take significantly more time as
03:11 - opposed to implementing it without tests
03:13 - because a part of our development time
03:16 - is spent on writing and maintaining
03:18 - these tests so this is what John Smith
03:21 - argues but you see really right or wrong
03:23 - well let's see
03:25 - let's say we don't have any automated
03:27 - tests as we add new features and our
03:30 - application grows in complexity the time
03:32 - required to test all the application
03:35 - functions with various arguments
03:37 - increases exponentially if you have
03:40 - worked in a larger application with a
03:41 - lot of features that have been built
03:43 - over years you know that sometimes no
03:46 - one in the team knows how these
03:47 - functions work and how they should be
03:49 - tested nobody knows the requirements
03:51 - because those developers were initially
03:53 - built those features are no longer part
03:56 - of the company so there are a lot of
03:58 - legacy functions around and nobody dares
04:00 - to touch them now if you implement
04:03 - automated testing we can test a large
04:05 - part of applications functionality
04:07 - giving automated tests and the time
04:09 - required to do manual testing will be
04:11 - far less in fact some companies do not
04:14 - have any manual testing at all they
04:16 - automate everything now whether that's a
04:19 - good practice or not it's debatable but
04:21 - irrespective of that some level of
04:24 - automated testing can definitely reduce
04:26 - the manual testing effort but there is
04:29 - also one more benefit to automated
04:31 - testing with automated tests you can
04:34 - catch the effect before releasing your
04:36 - software and this can save you from a
04:39 - lot of nightmare have you ever been in
04:41 - this situation where you deployed the
04:43 - application to the production you were
04:44 - happy you went home and then 30 minutes
04:47 - later you got a call from your boss
04:49 - saying that the critical function in
04:51 - that application is not working and then
04:53 - you have to log in remotely or go back
04:55 - to the office and spend several hours
04:57 - till very late at night trying to fix
05:00 - the bug most if not all developers have
05:03 - that kind of experience at some point in
05:05 - their career now with automated test you
05:08 - catch more bugs before releasing your
05:10 - application into production now I just
05:13 - want to clarify something here I'm not
05:14 - saying that with automated tests you're
05:16 - going to release bug-free code that's
05:19 - not true but what you release is often
05:21 - software of better quality
05:23 - now as you talk to various developers
05:26 - about automated testing you come across
05:28 - two extreme view points on one side of
05:31 - the spectrum we have developers like our
05:34 - John Smith put things automatic testing
05:37 - is useless
05:38 - on the other side of the spectrum we
05:40 - have this guy who thinks you're not a
05:42 - coder if you don't write tests what I
05:45 - want you to do is ignore both these
05:48 - extreme viewpoints instead take the
05:51 - middle ground and be pragmatic the
05:54 - reality is even though automatic testing
05:57 - has a lot of benefits it doesn't fit
05:59 - every project and every team for the
06:02 - starter your team needs to have a
06:04 - discipline in writing clean tests and
06:07 - maintaining them if you don't work in a
06:09 - team like that writing automated tests
06:11 - ends up costing you more than the value
06:14 - you get out of them because you will
06:15 - spend a lot of time fixing broken tests
06:18 - that are hard to read and hard to
06:20 - understand in those cases it's better
06:22 - not to write tests at all another factor
06:25 - is the time and budget of your project
06:28 - let's say you're part of a startup
06:30 - company and you have three months to
06:32 - turn a concept into real working
06:34 - software in this situation I argue that
06:37 - you should not spend your time writing
06:39 - tests initially because you don't know
06:41 - if the fabrication or this business is
06:44 - going to succeed most startup companies
06:47 - have a small budget and they want to
06:49 - produce something quickly so they can
06:51 - show it to a mass audience and then
06:53 - attract venture capitalists to raise
06:55 - funds if you want to spend three months
06:58 - writing tests chances are your
07:00 - application may not even make it to the
07:01 - production so what's the point of
07:03 - writing all these tests plus in a lot of
07:06 - startup companies the requirements
07:08 - change frequently if you spend a lot of
07:11 - time writing tests a lot of these tests
07:13 - break as you modify the application code
07:16 - to implement the new requirements so in
07:19 - those projects it's better to write
07:21 - tests only for parts of the application
07:23 - that would take more time to test
07:25 - manually so use it as a practice to help
07:28 - you increase your productivity and go
07:30 - faster as opposed to hard and fast rules
07:33 - that you need to apply everywhere
07:35 - remember the real world is different
07:37 - from books and courses in the real world
07:40 - we have constraints and most of the time
07:42 - these constraints are money and time you
07:46 - cannot code forever you cannot code for
07:48 - fun your job is to build real working
07:51 - software
07:52 - and solve a problem your job is to
07:54 - deliver value to the world if you cannot
07:57 - deliver working software in time within
07:59 - the budget
08:00 - nobody cares about all your fancy
08:02 - automated tests so once again I want you
08:05 - to be pragmatic and use automatic
08:08 - testing when it makes sense even if you
08:10 - cannot practice automatic testing in
08:13 - your current project or team I strongly
08:15 - recommend you to watch the section
08:17 - thoroughly and learn automated testing
08:19 - because it will help you become a better
08:21 - developer it will enforce you to write
08:24 - better and more reliable code all right
08:27 - ma Sh
08:27 - I got it now tell me how should I write
08:30 - tests well that's the topic for this
08:32 - section so next let's take a look at the
08:34 - different types of tests
08:37 - alright now let's take a look at the
08:40 - different types of tests
08:41 - so in general we have three types of
08:44 - tests unit tests integration tests and
08:47 - end-to-end tests with unit tests we test
08:51 - a component in isolation without
08:53 - external resources like file system
08:56 - database HCM points and so on now this
08:59 - is the classic definition of unit test
09:01 - irrespective of angular in angular terms
09:04 - that means testing a component in
09:07 - isolation without this template and any
09:10 - other resources that touch the file
09:12 - system the database API endpoint the
09:15 - browser and so on so if our component is
09:18 - using a service to talk to an API
09:20 - endpoint you're going to give it a fake
09:22 - instance of that service we assume that
09:24 - service is doing its job properly and we
09:26 - just want to focus and the functionality
09:28 - of the component or similarly if the
09:31 - component is using a router again we're
09:34 - going to give it a fake router not a
09:36 - real router that works with the browser
09:37 - API to take the user to a different page
09:41 - unit tests are easiest to write there
09:44 - are superfast but they don't give us
09:46 - much confidence about the functionality
09:48 - of our application so let's take a look
09:50 - at an example
09:51 - here we have this simple boat component
09:54 - that you saw in my beginners angular
09:55 - course now I've simplified the code here
09:58 - but basically we have this property
10:00 - total votes and this method that would
10:03 - change the value of this property now we
10:05 - can test this component in isolation so
10:08 - we think of it as a plain type script
10:10 - class not an angular component so we
10:12 - don't care that it has a template we
10:14 - just look at it as a simple type script
10:16 - class so this method is responsible for
10:19 - changing the state of this class so we
10:22 - can call this method in our tests and
10:24 - then inspect the value of the total
10:27 - votes property if it's updated properly
10:29 - that means this method is working so
10:32 - writing this test is very easy as you
10:34 - will see later in this section however
10:36 - if there is a problem in the bindings in
10:38 - the template for this component we will
10:40 - not know until run time for example if
10:43 - you forget to bind the click event of
10:45 - this button to the upload method our
10:47 - component is not going to function
10:49 - properly and that's when we use an
10:52 - integration test with an integration
10:54 - test we test the component with external
10:57 - resources once again this is the classic
11:00 - definition of integration test in the
11:02 - angular world that means testing a
11:04 - component along with this template so
11:07 - instead of looking at this class as a
11:09 - plain type script class we need to look
11:11 - at it as an angular component and that
11:13 - means we need to run our test in an
11:16 - angular environment so we need to
11:18 - instruct angular to compile this class
11:20 - along with this template as you might
11:23 - guess this kind of test requires a
11:25 - little bit more code than a simple unit
11:27 - test there is some setup code because we
11:30 - have to put this class in an angular
11:32 - environment we need to deal with modules
11:34 - dependency injection and so on
11:36 - however we get more confidence about the
11:39 - functionality of our components so this
11:41 - is the integration test now if our
11:44 - component is using a service to talk to
11:46 - an API endpoint again similar to our
11:48 - unit tests you want to give it a fake
11:50 - implementation now in some ways this
11:53 - looks a little bit like unit tests and
11:54 - some developers can argue that this is
11:57 - actually kind of unit test because we're
12:00 - still testing this component in
12:01 - isolation without a real service or a
12:04 - real router however I still see this in
12:07 - the category of integration test because
12:10 - our test involves testing a couple of
12:12 - pieces together a component and it's
12:15 - template which is often in a separate
12:17 - file so that's why I personally see this
12:20 - kind of test as an integration test
12:22 - because we're testing the integration of
12:24 - our component class it is template now
12:28 - you made the second with me and still
12:29 - think of this as a unit test that's
12:31 - perfectly fine
12:32 - but let's not get hung up on the
12:34 - terminology but for the rest of the
12:36 - course I'm going to refer to the test
12:38 - that involves the integration of a
12:40 - component and is template as integration
12:43 - tests and tests that work with a
12:45 - component in isolation without this
12:47 - template as unit test
12:50 - now we can write f integration tests for
12:52 - this component and all these tests may
12:54 - pass however when you run the
12:57 - application and use it like an end user
12:59 - the application may still not work as we
13:02 - expect because we're still looking at
13:04 - individual components not the entire
13:06 - application as a whole so let's let me
13:09 - use end-to-end tests so with end-to-end
13:12 - tests we test the interpretation as a
13:14 - whole so we simulate a real user we
13:18 - launch the application in the browser
13:19 - perhaps we log in put in the user and
13:22 - password click here and then navigate to
13:24 - the target page click on this upload
13:26 - button and then ensure that the total
13:29 - votes is updated in our HTML page
13:31 - properly now with this kind of test we
13:34 - get a lot more confidence about the
13:36 - functionality of our application however
13:38 - these tests are very slow because each
13:42 - test is going to launch the application
13:43 - in the browser navigate to the home page
13:46 - then perhaps do a few clicks here and
13:48 - there to get to a target page and do
13:50 - something so that's why these tests are
13:52 - slow but they're also very fragile if
13:55 - simple change in our HTML markup can
13:58 - easily break these tests even if the
14:01 - application is working properly so
14:03 - ideally you want to spend most of our
14:05 - time writing unit and integration tests
14:07 - and write very few end-to-end tests only
14:11 - for the key functions of the application
14:13 - but you're not going to test all the
14:15 - edge cases with end-to-end tests like
14:17 - something they know something being out
14:19 - of range and so on we use unit tests for
14:22 - those scenarios so here are the three
14:25 - main types of text now if I told you
14:27 - unit tests are easier to write so in
14:30 - this section we're going to focus
14:31 - entirely on unit tests and then I will
14:33 - cover integration tests in the next
14:35 - section all right next we're going to
14:37 - look at the fundamentals of unit testing
14:41 - alright now let's take a look at the
14:43 - fundamentals of unit testing the first
14:46 - thing you need to know is that tests are
14:48 - first-class citizens so all the
14:51 - practices you have learned about writing
14:53 - clean and maintainable code applies to
14:56 - your tests as well so here are some
14:58 - examples your functions or methods
15:00 - should be a small preferably less than
15:03 - ten lines of code you should have proper
15:05 - names and they should have a single
15:07 - responsibility the same principle
15:10 - applies to your test code so each test
15:12 - should be less than ten lines of code
15:14 - you should have a proper name that
15:16 - perfectly describes what it's doing and
15:18 - you should have a single responsibility
15:20 - you should test only one thing all right
15:24 - now download the zip file I have
15:26 - attached to this lecture there you'll
15:28 - find this new angular project in this
15:30 - project we have these folders where I
15:33 - have included some code that we're going
15:34 - to use throughout this section we start
15:36 - with very simple examples and gradually
15:39 - as we go through this section the
15:41 - examples get more and more complex now
15:45 - the first thing you need to do after you
15:46 - download this project is NPM install and
15:50 - then ng test so instead of ng serve we
15:54 - run ng test so this is going to build
15:58 - the application and then it launches
16:00 - karma which is our test Runner all right
16:03 - now back here we want to write our first
16:05 - unit test so in the fundamentals folder
16:08 - here we have this compute function a
16:11 - very simple function if you give it a
16:14 - negative number it returns zero
16:15 - otherwise it increments the number by
16:18 - one you may think this is really so
16:20 - simple and it looks nothing like angular
16:22 - I didn't understand that but bear with
16:24 - me we're going to start with very simple
16:25 - examples and gradually these examples
16:28 - get more complex so if you do have some
16:31 - experience but unit testing feel free to
16:33 - skip the next few lectures depending on
16:35 - your knowledge but if you're an absolute
16:37 - beginner you need to look at all the
16:39 - examples all right now to create a unit
16:42 - test for this function and the same
16:44 - folder we're going to create a new file
16:46 - look at the naming convention compute
16:49 - dot spec dot t-- f
16:52 - so all our test files should have ducks
16:55 - bag TS this is the pattern the Karma or
16:59 - test runner is looking for so any time
17:02 - we find files that match this pattern it
17:05 - looks at the test in this files and runs
17:07 - those tests for us now in the projects
17:10 - that we create with angular CLI we use
17:12 - Jasmine as our testing framework which
17:14 - provides a bunch of functions that we
17:16 - use to write tests the two functions
17:19 - that we use most of the time are
17:21 - described and it we use described to
17:26 - define a suite which is a group of
17:28 - related tests and we have it to define a
17:32 - spec or a test so let's see how we can
17:35 - use this subscribe we give our suite a
17:39 - name which is often the name of the
17:41 - system under test so here we're writing
17:44 - tests for the compute function I'm going
17:48 - to call the suite compute now the second
17:51 - argument here is a function that our
17:54 - test Runner is going to call so we can
17:56 - use this function syntax like this or we
18:01 - can use the arrow function syntax which
18:03 - is shorter and cleaner so like this now
18:09 - here we have one or more tests or specs
18:12 - so define a test or a spec we call the
18:15 - ate function and similarly we give it a
18:19 - name test name and a function so this is
18:26 - the body of our test this is what we're
18:28 - going to write and our test Runner is
18:30 - going to call this function and then it
18:32 - will tell us if the test succeeds or not
18:34 - now which is we call this test test main
18:37 - is a very bad name it doesn't tell me
18:40 - what we're going to test here but look
18:42 - at the implementation of this function
18:44 - when writing tests here we need to test
18:47 - all execution paths so here we have two
18:50 - execution paths one is for a negative
18:53 - number and the other is for a positive
18:55 - number so we need to write two tests
18:57 - here so I'm going to change this to
19:01 - should return zero if input
19:06 - is negative now you can read this as a
19:08 - speck of the compute function it should
19:11 - return zero if input is negative alright
19:15 - let's test this so first I'm going to
19:17 - import this function from the top now
19:25 - here I'm going to call it with negative
19:27 - one get the result now we need to assert
19:33 - that this result is zero to do that we
19:37 - use the expect function that comes with
19:39 - jasmine so we expect this result to be
19:45 - zero this is the API that comes with
19:49 - jasmine now we have a bunch of other
19:51 - methods here let me show you so we have
19:54 - to be defined to be false e to be
19:56 - greater than to be less than and so on
19:59 - so depending on what you're going to
20:01 - expect you can call one of these methods
20:03 - you're going to see more examples
20:05 - throughout this section all right now
20:08 - let's run this test so save now because
20:13 - karma is watching our test and source
20:15 - files and soon as it detects a change it
20:17 - runs the test again so here you can see
20:20 - it executed our test and the result was
20:22 - successful now if you have a big monitor
20:25 - you can put this terminal window on the
20:26 - side and as you're coding and saving
20:29 - files you can see if all tests are
20:31 - passing or something is failing
20:33 - alternatively if you have double
20:35 - monitors you can dedicate one monitor
20:38 - purity to your test it's much easier now
20:41 - if you don't like this terminal window
20:42 - you can see the report of your tests in
20:45 - the browser so when you run ng test this
20:48 - will launch a browser window connected
20:50 - to karma now here if you click this T
20:53 - button and open Chrome developer tools
20:56 - on the console tab you can see the list
21:00 - of all tests and their status so here we
21:03 - have one test compute should return zero
21:06 - if input is negative and you can see
21:08 - that this test is successful now let me
21:11 - show you what happens when it tests
21:12 - fails so back to our test code I'm going
21:15 - to change this and say it should be one
21:19 - save now in the terminal you can see we
21:23 - have one failed test and if you get back
21:25 - here and refresh this tab look our test
21:30 - failed expected zero to be one
21:33 - now if we click this line here this
21:37 - takes us to the failed test so here's
21:40 - the line where our expectation failed
21:43 - now like here let's fix this test now we
21:47 - need to write the second test so I'm
21:49 - going to select this test here hold down
21:53 - shift alt and the down arrow to
21:56 - duplicate the code modify the test name
21:59 - should increment the input if it is
22:03 - positive now I'm going to give it a
22:06 - positive number like 1 and we expect the
22:10 - result to be to save back here refresh
22:15 - beautiful we have two passing tests next
22:20 - we're going to look at testing strings
22:21 - and arrays
22:24 - all right now let's see how we can test
22:26 - strings and arrays so in the second
22:30 - folder arrays on strings
22:32 - let's take a look and this grade
22:34 - function so a very simple function we
22:37 - give it a name and it returns
22:39 - welcome plus that name so once again I'm
22:43 - going to create a new file greet let's
22:46 - pack the TS and to save time I'm going
22:49 - to copy a describe block here now what
22:52 - are we going to test here well what I am
22:56 - sure that the name that we give to this
22:58 - function is in the output so it should
23:03 - include the name in the message or the
23:06 - output once again I'm going to port the
23:11 - function on the top
23:13 - okay now that here call greet has much
23:17 - to it and then we expect the result to
23:21 - be welcome wash now there is a problem
23:27 - with this test this test is too specific
23:30 - so if one day I come back here and I
23:34 - decide to add an exclamation mark here
23:39 - this test is going to break we don't
23:41 - want fragile tests that break often so
23:44 - instead of checking for the exact
23:46 - message I'm going to check for the
23:48 - existence of my name in the output so
23:51 - I'm going to replace this with to
23:54 - contain wash now this test is a little
23:59 - bit more general and if I change the
24:01 - message from welcome to hi in the future
24:03 - this test will still pass the same
24:06 - principle applies when testing arrays
24:08 - let's take a look at another example so
24:12 - here we have gate currencies
24:16 - that returns an array of three strings
24:18 - if I want to write two tests for this
24:20 - function
24:21 - I just want to assert that the result
24:23 - includes these items u.s. dollars
24:25 - Australian dollars and Euro but I don't
24:28 - care about their exact position because
24:30 - if in the future I decide to change the
24:33 - order of these items in this array and
24:34 - sort them alphabetically I don't want my
24:37 - test to break so once again get
24:43 - currencies that's back 30s now once
24:48 - again I'm going to
24:49 - paid some code but from the next lecture
24:51 - you're going to have you spec files
24:53 - ready for you so you don't have to type
24:55 - it from scratch here is our test suite
24:58 - now let's write the test it should
25:02 - return the supported currencies I'm
25:09 - going to import the function on the top
25:10 - and then call it here get currencies
25:15 - store the result here now I'm going to
25:20 - expect this result to contain US dollars
25:25 - duplicate Australian dollar and Europe
25:29 - their order does not matter alright from
25:32 - the next lecture you're going to start
25:34 - testing angular components now from this
25:38 - lecture we're going to start testing
25:40 - angular components in each lecture
25:42 - you're going to see a pattern that you
25:44 - see in a lot of real-world applications
25:46 - so let's start with the first pattern in
25:48 - the folder called setup and teardown
25:51 - open this both components so this is a
25:55 - simplified version of the both component
25:57 - that you have seen in my beginners
25:59 - angular course you have a property total
26:02 - votes and methods that modify the value
26:05 - of this property the pattern we have
26:07 - here is state change so in a lot of
26:10 - components we have methods that modify
26:12 - the state of the component now in a real
26:15 - world scenario chances are after
26:17 - modifying the state here you may use a
26:19 - service to make an API call to save the
26:22 - changes on the server that's a different
26:24 - pattern and we're going to get that
26:25 - later in this section so for now let's
26:28 - just focus on the state change pattern
26:31 - now back here we have a spec file here
26:35 - we have some
26:36 - boilerplate code so you're gonna have to
26:38 - write everything from scratch note that
26:40 - the name of our suite is both components
26:42 - that's the system under test now let's
26:45 - write a couple of specs so this both
26:48 - component should increment total loads
26:52 - when uploaded so here I'm going to
26:56 - create an instance of the both component
27:01 - call the upload method
27:04 - expect that component the total votes to
27:09 - be won this is how we test this method
27:12 - now these three lines you see here
27:15 - represent a structure that you see in a
27:17 - lot of unit tests we call this structure
27:20 - Triple A which stands for arrange act
27:23 - and assert so the first line here is
27:28 - their range part where we initialize the
27:31 - system under test in this case we're
27:33 - creating an instance of the gold
27:35 - component the second part is the Act
27:39 - which often involves calling a method or
27:41 - function and the third part is the
27:46 - assertion
27:48 - best practice to make your tests clean
27:50 - and readable always put a vertical line
27:53 - between these lines like this all right
27:58 - now let's write the second test so I'm
28:01 - going to simply select this duplicate
28:05 - you don't need this one here all right
28:08 - now let's change the name of the test so
28:11 - should Dickerman total votes when
28:14 - downloaded I'm going to change the call
28:17 - to download method
28:20 - and then total votes should be minus one
28:23 - now look at these two tests
28:27 - these two tests have something in common
28:29 - the initialization of our both
28:32 - components now this initialization is
28:34 - only one line of code and it's not a big
28:36 - deal but sometimes when working with
28:38 - more complex objects the initialization
28:40 - may involve few lines of code we can
28:43 - refactor these tests and move this
28:45 - initialization to a single place so
28:47 - we're not duplicating it in each test so
28:51 - I'm going to cut this line here and move
28:55 - it inside the body of our sweet
28:58 - delete and delete now each set is only
29:04 - two lines of code however there is a
29:06 - problem with this test if you run this
29:08 - says the second one is going to fail
29:10 - because in the first one we're uploading
29:13 - so the value of total votes is going to
29:16 - be one and this means in the second test
29:19 - the value of total votes is going to be
29:21 - zero not negative one so the problem we
29:24 - have here is that our tests have side
29:26 - effects the execution of one test can
29:29 - impact the execution of other tests and
29:32 - with this our test will break quite
29:34 - often which is really painful
29:36 - we don't want fragile tests remember
29:40 - how can we solve this problem well when
29:42 - writing automated tests remember each
29:45 - test should run in an isolated work as
29:48 - if it's the only test that exists in the
29:51 - world nothing else so we're going to
29:53 - start with a clean state how can we do
29:56 - that now previously we didn't have this
29:58 - problem because we created this
30:00 - component inside each test but now that
30:03 - we move this line inside the body of our
30:05 - suite you have this problem the solution
30:08 - is to use before each function so in
30:11 - Jasmine we have another function called
30:14 - before each as the argument we pass a
30:17 - function here and our test Runner is
30:22 - going to call this function before each
30:25 - test and this is a perfect opportunity
30:27 - for us to initialize our objects so I'm
30:31 - going to change this so the type of
30:34 - components both components so we'll have
30:36 - intelligence throughout this module and
30:39 - then do the actual initialization here
30:43 - now in Jasmine we have three other
30:46 - functions that are similar to before
30:48 - each we also have after each
30:53 - the same signature so it takes a
30:55 - function that will be called after each
30:58 - test and this is a place where you do
31:00 - clean up now in this case we don't need
31:02 - to do any cleanup but in your test if
31:04 - you need to do clean up after your test
31:06 - this is where you add your clean up code
31:08 - we have two other similar functions
31:11 - before all which is executed once before
31:15 - all tests and after all which is
31:19 - executed once after all tests so in
31:23 - automated testing terms we refer to what
31:25 - we write in the before each function as
31:27 - the setup and what we write in the after
31:30 - each function as the turndown these are
31:33 - the terms that you hear in a lot of unit
31:35 - testing frameworks irrespective of the
31:37 - language next we're going to take a look
31:39 - at an example of a form hey thank you
31:43 - for watching my youtube video my name is
31:45 - Mohammad Ani and I'm a full-stack
31:47 - developer applause I'd author and in
31:50 - getting the instructor with about 14
31:52 - courses at the time of recording this
31:54 - video so I've got lots of courses on
31:56 - both front end and back end development
31:58 - including c-sharp energy framework a
32:01 - statment MVC angular architecture in it
32:04 - testing and so on this video watch is
32:07 - actually part of my angular course on
32:09 - udemy that you can get with its discount
32:12 - using the link in the video description
32:13 - and if you want to see my other courses
32:16 - simply head over to program with watch
32:18 - comm slash courses you can also
32:21 - subscribe to my youtube channel
32:23 - get free videos every week have a great
32:25 - day and also back show
32:27 - [Music]

Cleaned transcript:

in this section you're going to learn how to write automated tests through angular2 apps whether you're an absolute beginner or have some experience in automated testing I'm going to take you from the ground and teach you how to write automated tests for your angular apps so I'm not assuming any prior knowledge of automated testing so we're going to start with a quick introduction to automatic testing its benefits when to use it and why then we're going to look at different types of automated tests their pros and cons and then we'll get into the mechanics we're going to start with a few simple examples and then as you go through this section the examples get more and more complex these examples are based on the patterns that you see in a lot of realworld applications so for each pattern I will show you what you need to test and how to do it next I'm going to show you how to find out how much of your code is covered by tests and finally at the end of the section I'm going to give you some exercises to put what you learn in practice so there is a lot to cover now let's get started so what is automated testing is it a replacement for manual testing do I really need it how should I do it actually write my tests first which we call testdriven development or should I write the application code first launch I don't know what to test these are the questions that a lot of beginners automatic testing as well as developers who have some experience having their head so let's start with the first one what is automated testing automatic testing is basically the practice of writing code to test our code and then run those tests in an automated fashion so here is an example imagine we have this function somewhere in our application it's a basic calculate function it takes an input and depending on some conditions and return different values now in light of this function is used somewhere in the application with manual testing we have to launch the application in the browser perhaps you have to login for maybe do a few clicks here and there to get to the target page then we have to enter value us into a few formfields so eventually this function is called now this is very timeconsuming this whole cycle to execute this function in a manual fashion may take 30 seconds overtime with automated testing we can write code and directly call this function with different inputs and then we can run this code in an automated fashion and this may take only a fraction of second to test this function with different inputs so with this practice we can test a large part of our application functionality and maybe the internal application in an automated fashion several times faster than a manual tester now here we've got this opinionated developer John Smith and he believes writing all these tests is time consuming because not only do we have to write the application code which we refer to as production code but we also have to write the test code so implementing a new feature with tests will take significantly more time as opposed to implementing it without tests because a part of our development time is spent on writing and maintaining these tests so this is what John Smith argues but you see really right or wrong well let's see let's say we don't have any automated tests as we add new features and our application grows in complexity the time required to test all the application functions with various arguments increases exponentially if you have worked in a larger application with a lot of features that have been built over years you know that sometimes no one in the team knows how these functions work and how they should be tested nobody knows the requirements because those developers were initially built those features are no longer part of the company so there are a lot of legacy functions around and nobody dares to touch them now if you implement automated testing we can test a large part of applications functionality giving automated tests and the time required to do manual testing will be far less in fact some companies do not have any manual testing at all they automate everything now whether that's a good practice or not it's debatable but irrespective of that some level of automated testing can definitely reduce the manual testing effort but there is also one more benefit to automated testing with automated tests you can catch the effect before releasing your software and this can save you from a lot of nightmare have you ever been in this situation where you deployed the application to the production you were happy you went home and then 30 minutes later you got a call from your boss saying that the critical function in that application is not working and then you have to log in remotely or go back to the office and spend several hours till very late at night trying to fix the bug most if not all developers have that kind of experience at some point in their career now with automated test you catch more bugs before releasing your application into production now I just want to clarify something here I'm not saying that with automated tests you're going to release bugfree code that's not true but what you release is often software of better quality now as you talk to various developers about automated testing you come across two extreme view points on one side of the spectrum we have developers like our John Smith put things automatic testing is useless on the other side of the spectrum we have this guy who thinks you're not a coder if you don't write tests what I want you to do is ignore both these extreme viewpoints instead take the middle ground and be pragmatic the reality is even though automatic testing has a lot of benefits it doesn't fit every project and every team for the starter your team needs to have a discipline in writing clean tests and maintaining them if you don't work in a team like that writing automated tests ends up costing you more than the value you get out of them because you will spend a lot of time fixing broken tests that are hard to read and hard to understand in those cases it's better not to write tests at all another factor is the time and budget of your project let's say you're part of a startup company and you have three months to turn a concept into real working software in this situation I argue that you should not spend your time writing tests initially because you don't know if the fabrication or this business is going to succeed most startup companies have a small budget and they want to produce something quickly so they can show it to a mass audience and then attract venture capitalists to raise funds if you want to spend three months writing tests chances are your application may not even make it to the production so what's the point of writing all these tests plus in a lot of startup companies the requirements change frequently if you spend a lot of time writing tests a lot of these tests break as you modify the application code to implement the new requirements so in those projects it's better to write tests only for parts of the application that would take more time to test manually so use it as a practice to help you increase your productivity and go faster as opposed to hard and fast rules that you need to apply everywhere remember the real world is different from books and courses in the real world we have constraints and most of the time these constraints are money and time you cannot code forever you cannot code for fun your job is to build real working software and solve a problem your job is to deliver value to the world if you cannot deliver working software in time within the budget nobody cares about all your fancy automated tests so once again I want you to be pragmatic and use automatic testing when it makes sense even if you cannot practice automatic testing in your current project or team I strongly recommend you to watch the section thoroughly and learn automated testing because it will help you become a better developer it will enforce you to write better and more reliable code all right ma Sh I got it now tell me how should I write tests well that's the topic for this section so next let's take a look at the different types of tests alright now let's take a look at the different types of tests so in general we have three types of tests unit tests integration tests and endtoend tests with unit tests we test a component in isolation without external resources like file system database HCM points and so on now this is the classic definition of unit test irrespective of angular in angular terms that means testing a component in isolation without this template and any other resources that touch the file system the database API endpoint the browser and so on so if our component is using a service to talk to an API endpoint you're going to give it a fake instance of that service we assume that service is doing its job properly and we just want to focus and the functionality of the component or similarly if the component is using a router again we're going to give it a fake router not a real router that works with the browser API to take the user to a different page unit tests are easiest to write there are superfast but they don't give us much confidence about the functionality of our application so let's take a look at an example here we have this simple boat component that you saw in my beginners angular course now I've simplified the code here but basically we have this property total votes and this method that would change the value of this property now we can test this component in isolation so we think of it as a plain type script class not an angular component so we don't care that it has a template we just look at it as a simple type script class so this method is responsible for changing the state of this class so we can call this method in our tests and then inspect the value of the total votes property if it's updated properly that means this method is working so writing this test is very easy as you will see later in this section however if there is a problem in the bindings in the template for this component we will not know until run time for example if you forget to bind the click event of this button to the upload method our component is not going to function properly and that's when we use an integration test with an integration test we test the component with external resources once again this is the classic definition of integration test in the angular world that means testing a component along with this template so instead of looking at this class as a plain type script class we need to look at it as an angular component and that means we need to run our test in an angular environment so we need to instruct angular to compile this class along with this template as you might guess this kind of test requires a little bit more code than a simple unit test there is some setup code because we have to put this class in an angular environment we need to deal with modules dependency injection and so on however we get more confidence about the functionality of our components so this is the integration test now if our component is using a service to talk to an API endpoint again similar to our unit tests you want to give it a fake implementation now in some ways this looks a little bit like unit tests and some developers can argue that this is actually kind of unit test because we're still testing this component in isolation without a real service or a real router however I still see this in the category of integration test because our test involves testing a couple of pieces together a component and it's template which is often in a separate file so that's why I personally see this kind of test as an integration test because we're testing the integration of our component class it is template now you made the second with me and still think of this as a unit test that's perfectly fine but let's not get hung up on the terminology but for the rest of the course I'm going to refer to the test that involves the integration of a component and is template as integration tests and tests that work with a component in isolation without this template as unit test now we can write f integration tests for this component and all these tests may pass however when you run the application and use it like an end user the application may still not work as we expect because we're still looking at individual components not the entire application as a whole so let's let me use endtoend tests so with endtoend tests we test the interpretation as a whole so we simulate a real user we launch the application in the browser perhaps we log in put in the user and password click here and then navigate to the target page click on this upload button and then ensure that the total votes is updated in our HTML page properly now with this kind of test we get a lot more confidence about the functionality of our application however these tests are very slow because each test is going to launch the application in the browser navigate to the home page then perhaps do a few clicks here and there to get to a target page and do something so that's why these tests are slow but they're also very fragile if simple change in our HTML markup can easily break these tests even if the application is working properly so ideally you want to spend most of our time writing unit and integration tests and write very few endtoend tests only for the key functions of the application but you're not going to test all the edge cases with endtoend tests like something they know something being out of range and so on we use unit tests for those scenarios so here are the three main types of text now if I told you unit tests are easier to write so in this section we're going to focus entirely on unit tests and then I will cover integration tests in the next section all right next we're going to look at the fundamentals of unit testing alright now let's take a look at the fundamentals of unit testing the first thing you need to know is that tests are firstclass citizens so all the practices you have learned about writing clean and maintainable code applies to your tests as well so here are some examples your functions or methods should be a small preferably less than ten lines of code you should have proper names and they should have a single responsibility the same principle applies to your test code so each test should be less than ten lines of code you should have a proper name that perfectly describes what it's doing and you should have a single responsibility you should test only one thing all right now download the zip file I have attached to this lecture there you'll find this new angular project in this project we have these folders where I have included some code that we're going to use throughout this section we start with very simple examples and gradually as we go through this section the examples get more and more complex now the first thing you need to do after you download this project is NPM install and then ng test so instead of ng serve we run ng test so this is going to build the application and then it launches karma which is our test Runner all right now back here we want to write our first unit test so in the fundamentals folder here we have this compute function a very simple function if you give it a negative number it returns zero otherwise it increments the number by one you may think this is really so simple and it looks nothing like angular I didn't understand that but bear with me we're going to start with very simple examples and gradually these examples get more complex so if you do have some experience but unit testing feel free to skip the next few lectures depending on your knowledge but if you're an absolute beginner you need to look at all the examples all right now to create a unit test for this function and the same folder we're going to create a new file look at the naming convention compute dot spec dot t f so all our test files should have ducks bag TS this is the pattern the Karma or test runner is looking for so any time we find files that match this pattern it looks at the test in this files and runs those tests for us now in the projects that we create with angular CLI we use Jasmine as our testing framework which provides a bunch of functions that we use to write tests the two functions that we use most of the time are described and it we use described to define a suite which is a group of related tests and we have it to define a spec or a test so let's see how we can use this subscribe we give our suite a name which is often the name of the system under test so here we're writing tests for the compute function I'm going to call the suite compute now the second argument here is a function that our test Runner is going to call so we can use this function syntax like this or we can use the arrow function syntax which is shorter and cleaner so like this now here we have one or more tests or specs so define a test or a spec we call the ate function and similarly we give it a name test name and a function so this is the body of our test this is what we're going to write and our test Runner is going to call this function and then it will tell us if the test succeeds or not now which is we call this test test main is a very bad name it doesn't tell me what we're going to test here but look at the implementation of this function when writing tests here we need to test all execution paths so here we have two execution paths one is for a negative number and the other is for a positive number so we need to write two tests here so I'm going to change this to should return zero if input is negative now you can read this as a speck of the compute function it should return zero if input is negative alright let's test this so first I'm going to import this function from the top now here I'm going to call it with negative one get the result now we need to assert that this result is zero to do that we use the expect function that comes with jasmine so we expect this result to be zero this is the API that comes with jasmine now we have a bunch of other methods here let me show you so we have to be defined to be false e to be greater than to be less than and so on so depending on what you're going to expect you can call one of these methods you're going to see more examples throughout this section all right now let's run this test so save now because karma is watching our test and source files and soon as it detects a change it runs the test again so here you can see it executed our test and the result was successful now if you have a big monitor you can put this terminal window on the side and as you're coding and saving files you can see if all tests are passing or something is failing alternatively if you have double monitors you can dedicate one monitor purity to your test it's much easier now if you don't like this terminal window you can see the report of your tests in the browser so when you run ng test this will launch a browser window connected to karma now here if you click this T button and open Chrome developer tools on the console tab you can see the list of all tests and their status so here we have one test compute should return zero if input is negative and you can see that this test is successful now let me show you what happens when it tests fails so back to our test code I'm going to change this and say it should be one save now in the terminal you can see we have one failed test and if you get back here and refresh this tab look our test failed expected zero to be one now if we click this line here this takes us to the failed test so here's the line where our expectation failed now like here let's fix this test now we need to write the second test so I'm going to select this test here hold down shift alt and the down arrow to duplicate the code modify the test name should increment the input if it is positive now I'm going to give it a positive number like 1 and we expect the result to be to save back here refresh beautiful we have two passing tests next we're going to look at testing strings and arrays all right now let's see how we can test strings and arrays so in the second folder arrays on strings let's take a look and this grade function so a very simple function we give it a name and it returns welcome plus that name so once again I'm going to create a new file greet let's pack the TS and to save time I'm going to copy a describe block here now what are we going to test here well what I am sure that the name that we give to this function is in the output so it should include the name in the message or the output once again I'm going to port the function on the top okay now that here call greet has much to it and then we expect the result to be welcome wash now there is a problem with this test this test is too specific so if one day I come back here and I decide to add an exclamation mark here this test is going to break we don't want fragile tests that break often so instead of checking for the exact message I'm going to check for the existence of my name in the output so I'm going to replace this with to contain wash now this test is a little bit more general and if I change the message from welcome to hi in the future this test will still pass the same principle applies when testing arrays let's take a look at another example so here we have gate currencies that returns an array of three strings if I want to write two tests for this function I just want to assert that the result includes these items u.s. dollars Australian dollars and Euro but I don't care about their exact position because if in the future I decide to change the order of these items in this array and sort them alphabetically I don't want my test to break so once again get currencies that's back 30s now once again I'm going to paid some code but from the next lecture you're going to have you spec files ready for you so you don't have to type it from scratch here is our test suite now let's write the test it should return the supported currencies I'm going to import the function on the top and then call it here get currencies store the result here now I'm going to expect this result to contain US dollars duplicate Australian dollar and Europe their order does not matter alright from the next lecture you're going to start testing angular components now from this lecture we're going to start testing angular components in each lecture you're going to see a pattern that you see in a lot of realworld applications so let's start with the first pattern in the folder called setup and teardown open this both components so this is a simplified version of the both component that you have seen in my beginners angular course you have a property total votes and methods that modify the value of this property the pattern we have here is state change so in a lot of components we have methods that modify the state of the component now in a real world scenario chances are after modifying the state here you may use a service to make an API call to save the changes on the server that's a different pattern and we're going to get that later in this section so for now let's just focus on the state change pattern now back here we have a spec file here we have some boilerplate code so you're gonna have to write everything from scratch note that the name of our suite is both components that's the system under test now let's write a couple of specs so this both component should increment total loads when uploaded so here I'm going to create an instance of the both component call the upload method expect that component the total votes to be won this is how we test this method now these three lines you see here represent a structure that you see in a lot of unit tests we call this structure Triple A which stands for arrange act and assert so the first line here is their range part where we initialize the system under test in this case we're creating an instance of the gold component the second part is the Act which often involves calling a method or function and the third part is the assertion best practice to make your tests clean and readable always put a vertical line between these lines like this all right now let's write the second test so I'm going to simply select this duplicate you don't need this one here all right now let's change the name of the test so should Dickerman total votes when downloaded I'm going to change the call to download method and then total votes should be minus one now look at these two tests these two tests have something in common the initialization of our both components now this initialization is only one line of code and it's not a big deal but sometimes when working with more complex objects the initialization may involve few lines of code we can refactor these tests and move this initialization to a single place so we're not duplicating it in each test so I'm going to cut this line here and move it inside the body of our sweet delete and delete now each set is only two lines of code however there is a problem with this test if you run this says the second one is going to fail because in the first one we're uploading so the value of total votes is going to be one and this means in the second test the value of total votes is going to be zero not negative one so the problem we have here is that our tests have side effects the execution of one test can impact the execution of other tests and with this our test will break quite often which is really painful we don't want fragile tests remember how can we solve this problem well when writing automated tests remember each test should run in an isolated work as if it's the only test that exists in the world nothing else so we're going to start with a clean state how can we do that now previously we didn't have this problem because we created this component inside each test but now that we move this line inside the body of our suite you have this problem the solution is to use before each function so in Jasmine we have another function called before each as the argument we pass a function here and our test Runner is going to call this function before each test and this is a perfect opportunity for us to initialize our objects so I'm going to change this so the type of components both components so we'll have intelligence throughout this module and then do the actual initialization here now in Jasmine we have three other functions that are similar to before each we also have after each the same signature so it takes a function that will be called after each test and this is a place where you do clean up now in this case we don't need to do any cleanup but in your test if you need to do clean up after your test this is where you add your clean up code we have two other similar functions before all which is executed once before all tests and after all which is executed once after all tests so in automated testing terms we refer to what we write in the before each function as the setup and what we write in the after each function as the turndown these are the terms that you hear in a lot of unit testing frameworks irrespective of the language next we're going to take a look at an example of a form hey thank you for watching my youtube video my name is Mohammad Ani and I'm a fullstack developer applause I'd author and in getting the instructor with about 14 courses at the time of recording this video so I've got lots of courses on both front end and back end development including csharp energy framework a statment MVC angular architecture in it testing and so on this video watch is actually part of my angular course on udemy that you can get with its discount using the link in the video description and if you want to see my other courses simply head over to program with watch comm slash courses you can also subscribe to my youtube channel get free videos every week have a great day and also back show
