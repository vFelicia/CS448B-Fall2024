With timestamps:

00:00 - Hi, my name is Mosh Hamedani, and I'm 
00:04 - super excited to be your instructor. In this three hour course, you're going to learn everything 
00:08 - you need to get started with SQL or SQUEL. First I'm going to
00:12 - give you a three minute introduction to SQL, then we're going to install the necessary 
00:16 - tools and write our first SQL query. This course
00:20 - is ideal for anyone who wants to learn SQL from scratch, but also 
00:24 - anyone with some basic knowledge who wants to fill in the missing gaps. By the end 
00:28 - of this course, you'll be able to retrieve insert, update, and 
00:32 - delete data in databases. We'll talk about tables, relationships, 
00:36 - different types of joints, sub-queries regular expressions and 
00:40 - much, much, more. These are the essential concepts every software developer 
00:44 - or data scientist must know. This SQL course is packed with tons 
00:48 - of exercises that help you both learn and remember the SQL syntax.
00:52 - Also, there is a table of content below this video so you can quickly jump
00:56 - to specific tutorials, now let's jump in and get started. 
01:04 - Let's start the course with a quick overview of databases, what they are and 
01:08 - how we use them. A database is a collection of data stored 
01:12 - in a format that can be easily accessed. In order to manage our
01:16 - databases, we use a software application called database management system, 
01:20 - or, DBMS. We connect to a DBMS and give it 
01:24 - instructions for querying or modifying data. The DMBS will
01:28 - execute our instructions and send results back. Now we have 
01:32 - several database management systems out there, and these are classified into
01:36 - two categories, relational and non relational, also 
01:40 - called NoSQL. In relational databases, we store data
01:44 - in tables that are linked to each other using relationships. That's
01:48 - why we call these databases relational databases, each table 
01:52 - stores data about a specific type of object, like customer
01:56 - product, order and so on. SQL or SQUEL is
02:00 - the language that we use to work with these relational database
02:04 - management systems. It looks like this. We use SQL to query
02:08 - or modify our data. In this course you're going to learn everything there is to know about this powerful 
02:12 - language. Now, there are many different relational database management systems, 
02:16 - out there, some of the most popular ones are MySQL,
02:20 - SQL Server my Microsoft, and Oracle. But of course, there are plenty 
02:24 - more. Each database management system has a different flavor of SQL. 
02:28 - But all these implementations are very similar and are based on
02:32 - the standard SQL specification. So most of the SQL 
02:36 - code that you will learn in this course will work with any database management system. 
02:40 - In this course, we'll be using MySQL, which is the most popular 
02:44 - open source database in the world. Okay, now back to this diagram, 
02:48 - what about non relational databases? In non relational databases, 
02:52 - we don't have tables or relationships, these databases are
02:56 - different from relational databases, but that's a topic for an entirely different course. 
03:00 - What you need to know is non relational database systems 
03:04 - don't understand SQL. They have their own query language. 
03:08 - So, we use SQL to work with relational database management 
03:12 - systems. Now, before we jump in and install MySql, let me clarify 
03:16 - something quickly, as you talk to different people, you will hear two different pronunciations 
03:20 - of SQL. SQUEL, or SQL. 
03:24 - What is the correct way? Well, it depends on who you ask, and
03:28 - of course everybody thinks their way of pronouncing this word is the right way. But here's a 
03:32 - history about this language. SQL was originally developed at IBM
03:36 - in the 70s and back then it was initially called SQUEL
03:40 - short for structured English query language. But they changed
03:44 - the acronym to SQL, because SQUEL was the trademark of an airplane 
03:48 - company. So to this day, there has been an argument about what is the right
03:52 - generally speaking, people in non-English speaking 
03:56 - countries call it SQL. I'm used to calling it SQUEL
04:00 - because it's shorter and sweeter than SQL. But if you prefer to
04:04 - call it SQL, that's totally fine with me, I'm not going to get mad at you. So that's
04:08 - the history behind this language. But what about MySQL as a 
04:12 - software product? Developers of this product prefer to call it MySQL rather
04:16 - than mySQL. But they don't mind if they call it MySQL. 
04:20 - In this course, I'll be teaching you SQL with MySQL. 
04:24 - Hey guys, Mosh here. I just wanted to let you know that 
04:28 - you really don't have to memorize anything in this course, because I've created a 
04:32 - complete cheat sheet with summary notes for you. You can find it below this video 
04:36 - in the description box. So I have done my best to create
04:40 - the best possible, most comprehensive SQL course for you, and
04:44 - I would really appreciate it if you would support my hard work by liking and sharing this 
04:48 - video. Thank you so much, now, let's continue. 
04:52 - In this tutorial, 
04:56 - I'm going to show you how to install MySQL on your computer. Now
05:00 - I'm using a Mac, so first I will show you how to install MySQL on a Mac 
05:04 - computer, and then I will show you how to install it on Windows. So if you're a Windows user, 
05:08 - feel free to skip this tutorial. Now, open up your browser and
05:12 - head over to MySQL.com. Then, go to the
05:16 - downloads page, and scroll down to the bottom.
05:20 - Here you should see MySQL community edition, this is absolutely 
05:24 - free, and we're going to use that throughout this course. So let's go ahead 
05:28 - and look at that, now on this page, click on MySQL, 
05:32 - community server, and then on this page, 
05:36 - you should see available releases for Mac OS. 
05:40 - So, in this list, download the first item which is a dmg archive. 
05:44 - Alright, now, on the next page, click
05:48 - on no thanks, just start my download. Okay, as you can
05:52 - see, we are getting a dmg file, which is basically a setup wizard. 
05:56 - Alright, now the DMG is downloaded, so let's open it, 
06:00 - and then double click on this package, this
06:04 - will launch an installation wizard which is pretty easy to use, so simply 
06:08 - click on continue and again, and again, 
06:12 - agree with the license agreement, and 
06:16 - install MySQL, it's going to ask for your password, this is the password 
06:20 - that you used to log into your computer, so let's put that here, 
06:24 - alright, now here we need to set a password to the root
06:28 - for the admin user. So click next, and 
06:32 - in this box, type a complex password, 
06:36 - alright, now, let's finish the installation, 
06:40 - and enter your computer's password one more time, 
06:44 - and we are done! 
06:48 - That was super easy and sweet. 
06:52 - Alright, we installed MySQL community server, now we 
06:56 - need the graphical tool to connect with this server and manage our databases. 
07:00 - So, back to the downloads page, one more time, 
07:04 - scroll to the bottom, and go to MySQL 
07:08 - community addition, and on this page, somewhere 
07:12 - you should see MySQL workbench. This is a graphical tool that we use to
07:16 - connect to our database server. So let's go ahead and 
07:20 - download this as well. Now once again on this
07:24 - page, we need to download a dmg archive, so, 
07:28 - download, and, again we have 
07:32 - to say no we don't want to login or sign up, so let's go ahead and download 
07:36 - the dmg, and then 
07:40 - open it, alright, you're going to see something like this, so 
07:44 - drag this MySQL workbench and drop it onto the applications folder. 
07:48 - So, let's go ahead with that, now it's going to copy 
07:52 - this into the applications folder, beautiful, 
07:56 - so we're done with the installation, that was super easy, now press
08:00 - command and space, and search for MySQL, 
08:04 - work bench, there you go, let's open it, now the 
08:08 - first time we get this message, because this is an application we downloaded from the internet. 
08:12 - So, we need to tell Mac that we trust this, let's go ahead with that, 
08:16 - so this is MySQL workbench, now by default 
08:20 - you see a connection here, if you don't see that, you need to create it.
08:24 - Let me show you how to do that. So for this demo I'm going to right click this and
08:28 - delete this connection, alright, 
08:32 - now let's create a connection from scratch. So click on this plus icon, 
08:36 - on this page, give this connection a name, let's 
08:40 - say local instance, now the connection method 
08:44 - we're going to use is tcip, which is set by default, the 
08:48 - host name is 127.0.0.1, which 
08:52 - is the address of the local machine, and the port is 33
08:56 - 06, this is the default port for MySQL server, that is
09:00 - the user name of the admin, now we need to enter the password. This is
09:04 - the password that we set during the installation. So, click on 
09:08 - store in keychain, and in this box, type the 
09:12 - password for the MySQL server. Alright 
09:16 - and finally, let's test the 
09:20 - connection, okay, we successfully connected to MySQL
09:24 - server on the local machine, beautiful, let's click okay, 
09:28 - and here we have a connection on the homepage of MySQL
09:32 - workbench, every time we open MySQL workbench, we use this
09:36 - connection to connect to our local server. Alright, we're done
09:40 - with the installation of MySQL on a Mac, next I will talk about
09:44 - MySQL on a Windows computer, so feel free to skip that tutorial.
09:52 - In this tutorial, I'm going to show you how to install
09:56 - MySQL on Windows. So open up your browser and head over to
10:00 - MySQL.com, then, go to the downloads page
10:04 - now here, scroll down to the bottom, 
10:08 - we're going to use MySQL community edition which is absolutely 
10:12 - free. So, let's go with this, now, 
10:16 - select MySQL community server, 
10:20 - and then scroll down so here you should see
10:24 - something like this, MySQL installer for Windows. This is the 
10:28 - recommended method for installing MySQL on Windows. So, 
10:32 - click on this, alright, on the next page, scroll down, 
10:36 - and 
10:40 - download the first installer here. On the next page 
10:44 - scroll downs nd click on no thanks just start my 
10:48 - download. Otherwise you have to create an account and log, which is unnecessary for
10:52 - knowing this course, so, let's go with this, 
10:56 - and save this file to our computer, and then 
11:00 - run it. 
11:04 - Alright, we're going to use this setup wizard to install MySQL, 
11:08 - on our computer.  This is very easy, all you have to do is click next, 
11:12 - but there are a couple places where you need to enter a password, let me show you.
11:16 - So, on the first page, for the setup type we're going to use the 
11:20 - developer default setup. Go to the next page.
11:24 - Now here we're getting a little warning, because this installation wizard wants to
11:28 - install the connector for python 3.7, but I
11:32 - don't have Python on this machine, so that's why I'm getting this warning, now on your 
11:36 - machine, you might or you might not get this error, just click 
11:40 - next, and one more time, so here are
11:44 - the products that I want to get installed the first one is MySQL server, 
11:48 - the second one is MySQL workbench, this is the graphical
11:52 - tool that we use to connect to our database server, and manage our database. 
11:56 - You're going to see that soon. So click on execute, 
12:00 - now this is going to take about 5-10 minutes, so, 
12:04 - I'm going to pause the recording. 
12:08 - Alright, all the products are installed, beautiful, let's go to the next page, 
12:12 - and again, here our the group replication 
12:16 - page, also click on next, and the next page which is 
12:20 - about networking, leave all the default settings, so, 
12:24 - let's go to the next page, now we should set a password for the root for 
12:28 - the admin user. So, click on next, 
12:32 - and in this box, type a password for the admin user. 
12:36 - Alright, and then 
12:40 - let's go to the next page, once again leave all the default settings, 
12:44 - and click on next, and execute one more time, 
12:48 - alright, and now 
12:52 - let's finish our installation, once again we have to click on next, 
12:56 - and then finish. One more time, 
13:00 - there are so many steps. Now here's the page where you need to enter the
13:04 - admin password, so the page is called connect to server, you can
13:08 - see the username is root, which represents the admin user, 
13:12 - so in this box enter the password that you said earlier, 
13:16 - then click on check, okay, connection was successful 
13:20 - beautiful, let's go to the next page, and 
13:24 - click on execute, and finally finish. 
13:28 - There you go, we have one more step, next the 
13:32 - finally after all these steps the installation is complete.
13:36 - Now, this is going to start, MySQL workbench, which is the graphical
13:40 - tool we use to manage our database and run SQL queries. 
13:44 - So, click on finish, so now we have a command 
13:48 - prompt window, where we can type instructions to talk to our MySQL server, 
13:52 - we don't really need this, so close it, 
13:56 - and here's MySQL workbench, now the first time you open this page, 
14:00 - by default you should see a connection here, if you don't see it, 
14:04 - click on this plus icon, 
14:08 - on this page give this connection a name, let's say local 
14:12 - instance, now leave all their settings to their default value, 
14:16 - but here for the password click on store involved. 
14:20 - And in this box, type the password that you used for the admin user. 
14:24 - So, I'm going to put that here, okay, 
14:28 - now click on test connection, 
14:32 - alright, we successfully connected to the MySQL server on this 
14:36 - computer, alright, then, click on okay, 
14:40 - now we click on this connection to connect to our database server. 
14:44 - Alright, so here's the interface you'll be using throughout this course, 
14:48 - on the left hand side we have the navigator panel, in the middle we have the
14:52 - query editor which we can resize 
14:56 - this is where we're going to write our SQL queries, and on the right side we have 
15:00 - additions. So we're done with MySQL 
15:04 - on our computer, next, I'm going to show you how to create our databases for this query. 
15:12 - In this tutorial, I'm going to show you how to
15:16 - create the databases for this course. So here I've got MySQL
15:20 - workbench open, let me quickly give you an overview of this interface because 
15:24 - the first time you open it it might appear a little bit intimidating. 
15:28 - But actually it's not that difficult. So here on the top we have this tool
15:32 - bar with these buttons for creating a new tab for writing SQL code 
15:36 - as well as opening a SQL file. And next to that 
15:40 - we've got a bunch of buttons for creating a database, creating new tables and 
15:44 - so on. On the left side, we've got the navigator panel with two tabs 
15:48 - administration and schemas. We use the administration tab
15:52 - to do administrative work, such as starting or stopping our server.
15:56 - Importing or exporting data and so on. The schemas 
16:00 - tab shows the databases that we have in the current database server. 
16:04 - So currently we only have one database, that is sis, and this is
16:08 - the database that MySQL uses internally to do it's work. 
16:12 - Now, in the middle we've got this query editor window, this is where we write our
16:16 - SQL code, so we'll be spending most of our time in this course, in this
16:20 - window, and on the right side we've got another panel with two tabs, 
16:24 - contacts held, and snippets, now chances are this interface 
16:28 - might look slightly different on Windows, but what I'm showing you here is 
16:32 - almost identical to what we have on Windows. So don't get hung up if it 
16:36 - looks slightly different on your machine. It doesn't really matter. Now up here, 
16:40 - we've got these buttons for showing or hiding these panels, so
16:44 - to clean this interface, I'm going to hide this panel on the right side. 
16:48 - As well as the panel on the bottom. That is better. Now, 
16:52 - to create the databases for this course, download the zip file attached, 
16:56 - below this video. When you extract the (?) you're going to see a bunch of
17:00 - SQL files like this. So the main one you'll be using in this tutorial
17:04 - is called create databases.SQL. So this
17:08 - file contains all the SQL code to create all the databases that we need 
17:12 - in this course, now we also have individual files for creating 
17:16 - individual databases, I've just added these files in case you need to recreate 
17:20 - one of these databases in the future. But for now don't worry about them. Now, 
17:24 - back to MySQL work bench, let's open 
17:28 - the main SQL file. That is create databases. 
17:32 - So this is an example of SQL code. 
17:36 - Now this may look complex at the beginning, but trust me, as you go through the course 
17:40 - you're going to understand exactly how everything works here. You're going to be able to
17:44 - write SQL code like this. So, you want to execute 
17:48 - this, to create all the databases for this course. To do that, we click 
17:52 - on this icon, this yellow thunder icon that we have 
17:56 - on this tool bar here. This will execute either the selection or the 
18:00 - entire code if there is nothing selected for example, if I select this line here, 
18:04 - and click on this icon, this will execute only this line. In this case
18:08 - we want to execute the entire code, so we shouldn't select anything, 
18:12 - and now let's execute this, beautiful, now here down on the bottom, 
18:16 - we have this panel called the output window that shows all the 
18:20 - operations perform in our database server, so we can see 
18:24 - all the operations completed successfully, or something went wrong. 
18:28 - As you can see you've got these green ticks next to each operation. 
18:32 - Beautiful, so I'm going to close this panel, that's better. 
18:36 - Now on the left side in this schemas tab you don't see this new database 
18:40 - so we'll have to refresh this view, beautiful. 
18:44 - So we've got all these databases that are prefixed with SQL
18:48 - or SQL, I decided to prefix them with SQL so we know that 
18:52 - these are the databases for this course, they don't accidentally clash with 
18:56 - a database on the same name of your database server. Now, 
19:00 - at the time of recording this video, there are only 4 databases here, but as we go through 
19:04 - the course, I'm going to update the script for creating the databases, so, 
19:08 - when you watch this course, chances are you're going to see more databases here. Don't worry 
19:12 - worry about the difference. Now as an example let's explore 
19:16 - these databases. And by the way we don't need this tab anymore so let's close it. 
19:20 - That's better. Let's expand the SQL store
19:24 - database, now in every database we have these objects, we have 
19:28 - tables, this is where we store our data, we have views, 
19:32 - which are kind of like virtual cables, so we can combine data from multiple 
19:36 - tables, and put them in a view. And this is especially powerful 
19:40 - for creating reports, you're going to learn about them in the future. You also have 
19:44 - store procedures and functions, and these are little programs that we 
19:48 - stored inside of our database for querying data. For example, 
19:52 - you can have a store procedure for getting all the customers in a given city. 
19:56 - So we call that procedure and we say hey, give me all the customers in San Francisco 
20:00 - And this will return all the customers in San Francisco. 
20:04 - Okay, now, let's expand the tables, 
20:08 - so here are the tables in this database. We have customers, 
20:12 - we have orders, products, shippers and so on. 
20:16 - Now, select this customers table whenever you hover your mouse 
20:20 - over this item and see these three items on the right side. 
20:24 - Click on the right most icon, that looks like a table with a 
20:28 - thunder. With this we can see all the data, in this 
20:32 - table. So this is our customers table. In this
20:36 - table, we have these columns like customer id which we use to uniquely identify 
20:40 - customers. We all have first name, last name, birth 
20:44 - date, phone, address and so on. So these are the columns 
20:48 - in this table and every row is called a 
20:52 - record. So every row represents one customer and these are the pieces of 
20:56 - information we know for each customer. Now let's look at 
21:00 - another table, let's open the orders table, 
21:04 - in this table we have these columns like order ID, customer ID, 
21:08 - order date, status, and so on. What is this customer ID here. 
21:12 - We use this column to identify who has placed 
21:16 - each order. Now what is interesting here is you have referred to this customer 
21:20 - using their customer ID which uniquely identifies that. 
21:24 - In other words, if Jon Smith has placed an order, we don't 
21:28 - store John Smith here, we only store John's customer ID. 
21:32 - Why is that? Here is the reason. It is possible 
21:36 - John Smith might have placed multiple orders in our system. 
21:40 - Now every time John places his order, we need to look up his address and 
21:44 - phone to ship his order. Now it is possible that some of this information 
21:48 - might change in the future. John might move to a new place or change his 
21:52 - phone number, he might even change his name, if you repeat all that information
21:56 - next to each order, then we'll have to come back and make changes
22:00 - in multiple places. In contrast, with this design we only 
22:04 - store the ID of john here, so anytime we want to change 
22:08 - any information about John, instead of changing that here. We go back
22:12 - to our customers table, so let's look at 
22:16 - customer with ID 6, that is actually called (?)
22:20 - So here is all the information about Elka. This is her phone number, this is
22:24 - her address, and by the way this is all dummy data that I created using a tool. 
22:28 - So, if any information about elka changes in the future, 
22:32 - this is the only place that we need to modify. So 
22:36 - this is how these databases work. We refer to these databases as 
22:40 - relational databases. That basically means in these kind of databases we have 
22:44 - multiple tables that are related to each other using 
22:48 - a relationship. So internally there is a relationship between
22:52 - the customers table, and the orders table. So the customer 
22:56 - ID column in the customers table is related 
23:00 - or linked or associated with the customer ID column. 
23:04 - In the orders table. Here's the orders table, and here we have 
23:08 - the customer ID column. So this was a brief introduction to 
23:12 - relational databases, you learned about databases, tables, 
23:16 - columns, rows and relationships. In the next section I'm going to show you
23:20 - how to retrieve data from a single table in this database. 
23:24 - But, before going any further as an exercise I want you to explore 
23:28 - the invoicing database. Look at the all the tables, look at all the data to
23:32 - get an id of the kind of data that we have in this database. You're going to use this database 
23:36 - a lot in the future, so let's spend a couple minutes to explore this
23:40 - database. 
23:44 - In this tutorial I'm going to show you how 
23:48 - to retrieve data from a single panel. Now look at the navigator panel. 
23:52 - Currently none of our databases is displayed in bold, and that
23:56 - means none of these databases are selected for query. So the first step to
24:00 - rate a query to get data from a database, is to select a database. 
24:04 - The query that we'll write will be executed against that database. 
24:08 - In this demo, we're going to use the SEQUEL store database. 
24:12 - So we type our use SQL_
24:16 - store. Now use is a keyword in the SQL language, and that's 
24:20 - displayed in blue. Now SQL is not a case sensitive language, 
24:24 - and that means we can use upper case or lower case characters, it doesn't really 
24:28 - matter, but as a best practice, we should capitalize the 
24:32 - SQL keywords, and use lower case characters for everything else. 
24:36 - So now, let's go ahead and execute this query. Alright, 
24:40 - Look, the SQL store database is now displayed in bold. 
24:44 - Now in MySQL workbench, we can also select a database 
24:48 - by double clicking that, so now I double click SQL invoice 
24:52 - and it's the current database. Now if we run this query again, 
24:56 - the SQL store database becomes selected. 
25:00 - Alright, now let's write our first query to retrieve all the customers in this
25:04 - database. So after the you statement we're going to use 
25:08 - select statement. Here is the basic syntax or basic structure 
25:12 - of the select statement, we type out select in front 
25:16 - of that we specify the columns that we want to retrieve, for example we can retrieve 
25:20 - the customer ID column as well as the first name column or 
25:24 - we can retrieve all columns using an asterisk. 
25:28 - Now after that we use the from clause and this is where we specify the 
25:32 - table that we want to query, in this case the customer's table. 
25:36 - So this is the simplest query to select all the customers in a given table, 
25:40 - now whenever you have multiple SQL statements you
25:44 - need to terminate each statement using a semicolon. So, 
25:48 - look, we have a red underline here that indicates an error, if you hover your mouse over here, 
25:52 - you can see this tool tip saying select is not valid at this position. 
25:56 - Because we didn't terminate the first statement with a semi colon. 
26:00 - Okay, now let's execute this query one more time, once again, 
26:04 - we can click on this button here, or we can use a short cut, 
26:08 - so look at the query menu on the top, the first line is execute.
26:12 - Now here's the shortcut for this command, on Mac, it's shift 
26:16 - command and enter. On Windows its going to be different honestly 
26:20 - I'm not sure. So whatever it is, use that. So I'm going to press 
26:24 - shift command enter, and here are 
26:28 - all the customers in this table. So this 
26:32 - next statement has two clauses, the select clause and the 
26:36 - from clause. But there are other clauses we can use to filter 
26:40 - and sort data. For example, you can use the wear clause 
26:44 - to filter the result and get the customer with ID
26:48 - one. So we can write an expression like this. Where 
26:52 - _ID = 1. Now when we execute this 
26:56 - query, we'll only get the customer with ID 
27:00 - 1. So this is the where clause. We can also sort 
27:04 - the data so after wear we use the order by 
27:08 - clause and here we specify the columns that we're going to sort the results from
27:12 - on. Let's say we want to sort these customers by their first name so we type out 
27:16 - first_name. That is the name of one of the columns in this 
27:20 - table, right? Now if you execute this query this order by doesn't really have 
27:24 - an impact, because we only get one record in the result 
27:28 - so let me temporarily take out the where clause, 
27:32 - to do that we can put two hyphens in front of this line, now this line, 
27:36 - is treated as a comment, which means the SQL engine is not going to
27:40 - execute this, okay, so let's execute this query one more time, 
27:44 - now all the customers that we get our sorted 
27:48 - based on their first name. So that's the basic idea. 
27:52 - Now over the next few tutorials your'e going to learn more about
27:56 - these clauses in detail. But what you need to take away in this tutorial is that 
28:00 - is that these 3 clauses from where an order by are 
28:04 - optional. As you can see in this example, I'm not using the where clause, 
28:08 - we can also comment out the order by clause, we can also comment 
28:12 - out the from clause, so instead of selecting all the columns, 
28:16 - in a given table, we can select some values like one and two. Now, 
28:20 - if you execute this query one more time, in the result, we get something like
28:24 - this. Two columns called one and two, and in these columns 
28:28 - we have these values. So all these clauses are optional but in the 
28:32 - real world we quite often use all of them. Now what you need to understand here is that 
28:36 - the order of these clauses matter, so we always have select first, 
28:40 - then we have from, then where, and finally order by. 
28:44 - We cannot change the order of these clauses, otherwise we get a syntax error. 
28:48 - Which basically means the syntax, or the grammar or the structure 
28:52 - of our simple statement is incorrect. So it cannot be executed. 
28:56 - And one last thing before we finish this tutorial, you can
29:00 - see I've listed all these clauses on a  new line, now technically you don't have to
29:04 - do this, because line breaks, white spaces and tabs are ignored 
29:08 - when executing SQL statements. So we could come back here and 
29:12 - put from in front of select, so select store 
29:16 - from customers all in one line, and that's perfectly acceptable for simple queries, 
29:20 - but as your queries get more complex, it's better to put each clause
29:24 - on a new line. So that's all for this tutorial. In the next 
29:28 - tutorial, we'll explore the select  clause in detail. 
29:36 - In this tutorial, we're going to look at the select clause in detail. 
29:40 - So, since our current database is SQL store, to 
29:44 - clean things up I'm going to remove the first statement, you don't really need it now, 
29:48 - also, I'm going to delete these two comments, we just want 
29:52 - to focus on the select clause. Alright, so what
29:56 - can we do with this select clause? Well in the last tutorial we learned that if you use 
30:00 - an asterisk, this will return all the columns. Alternatively we can specify 
30:04 - the columns that we want and this is helpful in situations where you have a 
30:08 - big table with so many columns and perhaps millions of record. 
30:12 - If you want to bring back all that data, that's going to put a lot of pressure 
30:16 - on the database server, in this case MySQL, as well as the network. 
30:20 - So, that's when we explicitly specify the columns that we 
30:24 - want to get. Let's say we want to get the first name 
30:28 - and last name columns. Execute
30:32 - the query, as you can see, we only get these two columns. 
30:36 - And they are in the same order we specified here. So if we 
30:40 - change the order and put the last name first and execute the 
30:44 - query again, now we can see the last name column comes first. 
30:48 - Now let's add a new column, at the end, let's get
30:52 - the points for each customer as well, run the query, so these are
30:56 - the points for each customer which are calculated based on their shopping. 
31:00 - Now let's say we want to get these points and put them in a mathematical formula 
31:04 - to calculate the discount that we can give to each customer. 
31:08 - So here we can use an arithmetic expression, that's points plus ten. 
31:12 - This is an arithmetic expression. So now we can execute this query 
31:16 - for the first record you can see that their points will end up
31:20 - being 2283. Let's run the query one more time
31:24 - there you go. Now we can put the original points column here for clarity. 
31:28 - So points, points plus 10. Let's run the
31:32 - query one more time, now you can see the original points, and next 
31:36 - to that you can see the value that we're going to use to calculate the discount. 
31:40 - Now here we're using the plus operator which is for addition, we also have 
31:44 - multiplication, division, subtraction, and 
31:48 - module which is the remainder of the division. So let's change this to something 
31:52 - more complex. Let's say we want to get the points, multiply by 10, 
31:56 - and then add 100 to it. 
32:00 - Now we can immediately see that this line one is getting too long 
32:04 - and it doesn't fit on the screen, in situations like this, you can break
32:08 - up the select clause by placing each column on a new line, so, 
32:12 - select last name, then first name 
32:16 - points finally points times 10, 
32:20 - plus 100. So let's execute this query one more time. 
32:24 - So this is our new column with the new calculated value. 
32:28 - Now one thing you need to understand in this arithmetic expression is the order 
32:32 - of operators, and this is based on the order of operators in math. 
32:36 - So in math, the multiplication and division 
32:40 - operators have nighter precedence then addition
32:44 - and subtraction, so in this expression, points is
32:48 - multiplied by 10 and then the result is added 
32:52 - to 100. If this is not what you want you can always change the order
32:56 - by using parenthesis, as an example, let's change this
33:00 - multiplication to addition and then put that 
33:04 - multiplication here. In this expression, first 10 is 
33:08 - multiplied by 100, and then the result is added to the points. 
33:12 - Now let's say this is not what we want, so we can change the order by
33:16 - using parenthesis here. 
33:20 - With these parenthesis, first we get the points add 10 to them 
33:24 - and then multiply the result by 100. So this
33:28 - parenthesis are useful for changing the order of operations as well as 
33:32 - adding clarity to our code. So someone else reading this code can easily understand. 
33:36 - the order of these operations. Now let's execute this query one more time, 
33:40 - alright, now look at the name of this column here, 
33:44 - its set to the expression that we have on line 5. 
33:48 - That doesn't quite make sense you want to have a clear descriptive name, 
33:52 - so we can give this column an alias using the as keyword. 
33:56 - So, as and then we give it a name like discount 
34:00 - discount _factor. Let's run the query again. 
34:04 - now the name of this column has changed, so this is the 
34:08 - benefit of using an alias, we can give descriptive names to the 
34:12 - columns and the results sets. Now if you want to have a space in the 
34:16 - column name, you need to surround it with quotes, either 
34:20 - single, or double quotes. So we put quotes here and then 
34:24 - we can add a space in between these two words. Let me 
34:28 - execute the query one more time. Now we have discount
34:32 - factor. So let's quickly recap everything you learned about the select 
34:36 - clause. We cause an asterisk to return the columns, or 
34:40 - we can explicitly specify the columns that you want to return. 
34:44 - We can also use, arithmetic expressions here, and optionally, we can even
34:48 -  gibe an alias to each column in the results set. Now there is one more
34:52 - thing you need to know about the select clause. So let's delete this query 
34:56 - and select the state column, 
35:00 - of the customers table. Take a look. These are the 
35:04 - states in which our customers our located. Now currently in the sample 
35:08 - data we don't have any duplicates, in other words we don't have multiple customer
35:12 - in any of these states. But for this demo I want to change the 
35:16 - state of the first customer to Virginia, so we end up with duplicates 
35:20 - in the result set. So let's open up navigator panel
35:24 - here's our customers table, let's look at all the data, 
35:28 - and here's our first customer, 
35:32 - here a you can see, it's located in the state of Massachusetts 
35:36 - now I want to change this to Virginia. So double click
35:40 - VA for Virginia, enter, now 
35:44 - on the bottom right corner of the screen, you should see two buttons, 
35:48 - apply and revert. Unfortunately I cannot show you this button 
35:52 - because the recording window is a bit smaller then MySQL 
35:56 - But look down in the bottom right hand corner, click
36:00 - and apply. You're going to see a dial up box like this asking you to
36:04 - review the changes, so go ahead and click that button one more time
36:08 - alright, now, let's
36:12 - go back to our first query window, and execute this query one more time. 
36:16 - As you can see, the first two customers are located
36:20 - in Virginia. What if you wanted to get a unique list of
36:24 - states in the results set, that's when we use a distinct 
36:28 - keyword. So select distinct set. 
36:32 - With his query, we'll retrieve a unique list of states from the 
36:36 - customers table. So with the distinct keyword we can remove 
36:40 - let's execute the query one more time, now you can see
36:44 - Virginia is not duplicated. 
36:48 - Alright here's an exercise for you. 
36:52 - I want you to write a SQL query to return all the products in our database 
36:56 - in the result set. I want to see three columns, name, 
37:00 - unit price, and a new column called new
37:04 - price which is based on this expression, unit price 
37:08 - times 1.1. So let's say you want to increase the price of each product by
37:12 - 10%. With this query you want to get all the products 
37:16 - the original price and the new price. So pause the video and spend 
37:20 - one or two minutes on this exercise, when you are done come back and see my solution. 
37:28 - Alright this is pretty easy, so we start with select 
37:32 - now what columns do we want to select? Name, unit
37:36 - _price and then here we're going to use an arithmetic 
37:40 - expression to calculate the new price. So we type 
37:44 - out unit price times 1.1 and then give it a 
37:48 - alias, o as new_price or we can put this in quotes 
37:52 - and put a space between new and price. Now where do we want to
37:56 - select these columns from? From the products table, so from 
38:00 - products. Note that I've used upper case characters for all
38:04 - the SQL keywords and lowercase characters for everything else. So, 
38:08 - let's go ahead and execute tis query, this is what we get 
38:12 - so these are all the products, you can see their original price 
38:16 - as well as the new price which is 10 % more expensive. 
38:24 - In this tutorial, we're going to look at the where clause
38:28 - in SQL. So earlier I told you that we use the where clause to filter 
38:32 - data. For example, let's say we only want to get the customers with 
38:36 - points greater than 3000. So here in the where clause you can type out
38:40 - the condition like this. Points, greater than 
38:44 - 3000. When we execute this query, the query execution
38:48 - engine in MySQL is going to iterate over all the customers 
38:52 - in the customers table. For each customer it's going to evaluate this condition 
38:56 - if this condition is true, it will return that customer in the 
39:00 - result set. So let's go ahead and execute this, 
39:04 - and here's the result, as you can see you only have two customers 
39:08 - with points greater than 3000. 
39:12 - So, thesis what we call the greater than operator which is one of the 
39:16 - comparison operators in SQL. Let me show you the completeness of comparison 
39:20 - operators, so, we have 
39:24 - greater than, greater than, or equal to, we have less then, 
39:28 - less than or equal to, here's the equality 
39:32 - operator, and for not equality, we can use an exclamation 
39:36 - followed by an equal sign, or something like this. So both 
39:40 - of these are not equal operators. Let me show you examples of 
39:44 - these operators. So I'm going to delete all these and bring back
39:48 - the previous query, let's say we want to get only the customers in the
39:52 - state of Virginia. So we can change our condition to something like this. 
39:56 - Where state equals Virginia. 
40:00 - Note that I've put Virginia in quotes, because this is what we call a 
40:04 - string. A string is a sequence of characters. So whenever you're dealing
40:08 - with a sequence of characters, or basically textural data, we 
40:12 - need to enclose your values with either single or double quotes. 
40:16 - But quite often, by convention, we use single quotes 
40:20 - so let's execute this query and here's
40:24 - the result, you can see we only have these two customers with ID 1
40:28 - and 2, who are located in Virginia. And it doesn't matter
40:32 - if you use upper case or lower case characters, so if you type out
40:36 - the a in lower case and execute the query you get the
40:40 - exact same result. Now what if you want to get all the customers 
40:44 - outside of the state of Virginia, you can use the not equal operator. 
40:48 - So, we can either prefix this with an exclamation 
40:52 - or use this other notation. 
40:56 - Either way we get the same result. So these are 
41:00 - the customers that are not located in Virginia. Now we can 
41:04 - use these comparison operators for date values as well. For example, 
41:08 - let's say you want to get only the customers born after January 
41:12 - 1st, 1990. So we change out condition to
41:16 - first date, greater then, once again we use quotes, 
41:20 - for representing date values even though dates are actually not 
41:24 - strings. But in the sequel language, we should enclose dates with quotes, 
41:28 - so, here we type out 1990, 
41:32 - 01 for January, -01 for
41:36 - date. So this is the standard or default format for representing 
41:40 - dates in MySQL. 4 digits for the year, two digits for the
41:44 - month, and 2 digits for the day. So let's go ahead and execute
41:48 - this query. I actually made a mistake here, so we don't see the 
41:52 - result, instead we see the action output, or the output window.
41:56 - If you scroll to the bottom, you can see the details of the error. So here I used 
42:00 - the wrong name for the column, which should separate these two words
42:04 - with an underscore. That is the name of our column. So, 
42:08 - let's execute the query one more time, so we only have 3 customers
42:12 - born after January 1st 1990. So these 
42:16 - are examples of comparison operators in SQL. In the next tutorial
42:20 - I'm going to show you how to combine multiple conditions when filtering data. 
42:28 - Alright, here's your exercise. I want you to write a query to get the 
42:32 - orders that are placed this year, so look at the orders table, see
42:36 - what columns to do we have there, and based on that write query with a  where clause. 
42:44 - So here's the orders table, in this table we have this column, order
42:48 - date. We can use this problem to see the orders that are placed this year 
42:52 - so here's our query, select, start from order 
42:56 - where order_date, is 
43:00 - greater than or equal to 2019, assuming 
43:04 - this is the current yer, so 2019, 0101. 
43:08 - Now since currently we are in the year 2019, this query will
43:12 - return all the orders placed this year. But next year this query 
43:16 - is not going to give us the right result. But don't worry about it, later in the course I will show
43:20 - you how to write a query to get the orders placed in the current year, 
43:24 - so for the purpose of the new exercise, this is a valid solution. Now let's
43:28 - execute this query and see what we get. So, we have 
43:32 - only one order, order ID 1, that is placed in the current 
43:36 - year. 
43:40 - In this tutorial I'm going to show you how to
43:44 - combine multiple search conditions when filtering data. So,
43:48 - let's say you want to get all the customers that were born after
43:52 - January 1st, 1990, who also happen to have more then 
43:56 - 1000 points. So this is where we use the and operator. 
44:00 - So we type out and, and after we type out another condition. 
44:04 - Like points, greater than 1000. 
44:08 - Now when we execute this query, we only get customers who have 
44:12 - both these conditions. Let's take a look, so execute 
44:16 - we only have 2 customers and if you look both these people
44:20 - are born after 1990, and they have more then 
44:24 - 1000 points. So this is the and operator. When we use this 
44:28 - operator, both these conditions should be true. In contrast to the and 
44:32 - operator, we have the or operator. So with or if
44:36 - at least one of these conditions is true, that row will be returned in the 
44:40 - result set. Let's take a look. Now we execute this query again, 
44:44 - 2 records we have quite a few records. So for example, 
44:48 - we have this person who's not born after 1990 
44:52 - but if you look at their points they have more then 1000 points. 
44:56 - So any customer records that satisfies at least one of these conditions
45:00 - will be returned. Now let's take this to the next level. Let's say we want to get
45:04 - customers who are either born after 1990, or 
45:08 - they should have at least 1000 points and live in Virginia 
45:12 - so this is how we do this, we type out and 
45:16 - and then we add another condition, state equals 
45:20 - Virginia. Let's execute this query and see what we get. We only get
45:24 - 4 records, so these are the customers that are either born after
45:28 - 1990 or they have more then 1000 points and live 
45:32 - in Virginia. If you look at the first customer here this
45:36 - person is not born after 1990. But you can see that she lives
45:40 - in Virginia and she has more than 1000 points. So the last two conditions. 
45:44 - are true for this customer. Now when combining multiple
45:48 - logical operators. You need to be aware of the order of these operators. 
45:52 - So earlier I talked about he order of arithmetic operators. I told you that
45:56 - multiplication have a higher order then addition and 
46:00 - subtraction. And we can use parenthesis to override 
46:04 - the default order. We have the same concept in logical operator 
46:08 - So the and operator is always evaluated first. 
46:12 - So when this query is executed, the query execution engine 
46:16 - first evaluates this condition, because here we're using an and
46:20 - it doesn't matter that we typed out this condition after the first condition. 
46:24 - Because the and operator has a higher precedence. Now you can always
46:28 - change the order using parenthesis. And this also makes your code cleaner 
46:32 - and easier to understand. So here we can put parenthesis, 
46:36 - around these last two conditions, 
46:40 - and also we can put these in a  new line for 
46:44 - clarity. Something like this. So anyone 
46:48 - who reads this code can easily understand what is the intent of this query. 
46:52 - Now we also have logical operator called 
46:56 - not. And we use that to negate a condition. So, 
47:00 - I'm going to simplify our where clause. Let's say
47:04 - we're searching for customers who were born after 1990 or 
47:08 - we have more then 1000 points. If we execute this query 
47:12 - we get these people. Customers with 
47:16 - ID 1, 3, 5 and so on. Now we can use the not operator 
47:20 - to negate this condition. So we apply not here, and 
47:24 - preferably we also put parenthesis around this condition. 
47:28 - Now when we execute this query, we see other customers that are not 
47:32 - in the current results set. Let's take a look. So, 
47:36 - instead of customers with id's 1356
47:40 - and so on, we get customers with id's 2 4 and 10. 
47:44 - Now technically these customers were born before 1990.
47:48 - And we have less then 1000 points. So if you look here, 
47:52 - this first customer was born before 1990 and 
47:56 - he has less then 1000 points. How do they know that? Let me show
48:00 - you a trick that I learned in math. Whenever you have a not 
48:04 - operator. You can simplify your expression like this. We apply the not operator 
48:08 - to the first condition. People who were born after
48:12 - 1990, how can we negate this condition? Well, 
48:16 - the greater than operator becomes less then or equal to. 
48:20 - That is the inverse of that condition. Now we 
48:24 - apply the not to or to negate the or. What do we get?
48:28 - We get and. Finally apply
48:32 - the not operator on the last condition. We both have more then 1000 points. 
48:36 - When we negate this condition we get customers with less then or equal 
48:40 - to 1000 points. Now, you can remove the not operator 
48:44 - to simplify this, we don't need parenthesis anymore because we 
48:48 - only have 2 conditions that are combined with an end. Here is the result. 
48:52 - As you can see, this is much easier to read and understand 
48:56 - people who were born before this day and they have less then 1000 points 
49:04 - Alright, here's your exercise. From the order items 
49:08 - table, get the items for order number 6, 
49:12 - where the total price for the total item is greater then 
49:16 - 30. 
49:20 - Alright, here's the order items table, in
49:24 - this table we have these columns order id, product id, quality, and unit 
49:28 - price. If we multiply the quantity by unit price we can 
49:32 - get the total cost of that item. And then we can compare it with 
49:36 - 30. So, let's go ahead and write this query. 
49:40 - Select star 
49:44 - from order items. Where 
49:48 - here we need two conditions one is for order, so order 
49:52 - _id should be 6, and the second condition 
49:56 - we want to calculate the total price. So we get the unit price
50:00 - multiply it by quantity and this 
50:04 - value should be greater than 30. So as you can see, 
50:08 - we can use an arithmetic expression in the where clause. It's not limited 
50:12 - to the select clause. Okay? Now let's execute this query and see
50:16 - what we get. We should get only 1 item, 
50:20 - that is for product 1, here in quantities 4 and unit price 
50:24 - is just over 8 dollars, so the total price for this item, is greater than 30. 
50:28 - Hey guys, Mosh here. 
50:32 - In case you haven't seen my website yet, head over to codewithmosh.com. 
50:36 - This is my coding school where you can find plenty of courses 
50:40 - on web and mobile application development. In fact recently I 
50:44 - published a complete SQL course that is about 10 hours long, 
50:48 - and it teaches you everything you need to know from the basic to advanced topics 
50:52 - such as database design, security, writing complex queries, 
50:56 - transactions, events, and much much more. These are the
51:00 - topics that every software engineer must master. This YouTube course 
51:04 - you're watching, is the first 3 hours of my complete SQL
51:08 - course that is about 10 hours long. So if you want to master SQL
51:12 - and get job ready, I highly encourage you to enroll in my 
51:16 - complete SQL course. You can watch it anytime, anywhere, as many times as you
51:20 - want, you can watch it online or download the videos. The course comes 
51:24 - with a 30 day money back guarantee, and a certificate of completion 
51:28 - that you can add to your resume. The price for this course is $149
51:32 - dollars, but the first 200 students can get it for just over 
51:36 - 10 dollars. So if you're interested the link is below this video. 
51:44 - In this tutorial I'm going to show you how to use the 
51:48 - in operator in SQL. So, as an example, let's say
51:52 - you want to get the customers that are in Virginia or
51:56 - Florida, or Georgia. One way to write this query is like this.
52:00 - So, where state equals Virginia, or 
52:04 - a state equals Georgia, or a state equals
52:08 - Florida. Now people who are new to the SQL language or 
52:12 - programming in general find this expression a little bit strange. 
52:16 - They ask, "Mosh, why can't we write this expression like this?"
52:20 - where state equals Virginia or Georgia or 
52:24 - Florida. Here's the reason, we use the or operator 
52:28 - to combine multiple conditions. So here we have a condition 
52:32 - or an expression more accurately, but on the right side of this or operator 
52:36 - we have a string. In SQL we cannot combine a string 
52:40 - with a boolean expression that expresses a boolean value which can be 
52:44 - true or false. So that is why we have to write our query 
52:48 - like this. So we have multiple expressions or multiple conditions 
52:52 - and we're combining them using the or operator. 
52:56 - So, now if we execute this query we get these customers here. 
53:00 - customers here but there is a shorter and cleaner way to get the same result. 
53:04 - Instead of combining multiple conditions using the or operator we can
53:08 - use the in operator. So, where state 
53:12 - is in and then in parenthesis we add all the values, 
53:16 - like Virginia, comma, Florida, comma
53:20 - Georgia and the order doesn't matter, this query is exactly equivalent 
53:24 - to what we had earlier, but a you can see it's shorter and easier to understand. 
53:28 - So, let's execute it, look, we get the exact same result.
53:32 - Now here we can also use the not operator. Let's say you want to get the
53:36 - customer's outside of these states, so we can use 
53:40 - rare state, not in this list. 
53:44 - Now if you execute this query, we get customers who are located in Colorado, 
53:48 - Texas and so on. So use the in operator whenever 
53:52 - you want to compare an attribute to a list of values. 
53:56 - Now here is your 
54:00 - exercise. I want you to write a query to get the products where 
54:04 - their quantity in stock equals on of these values. 
54:08 - 49, 38, and 72, so pause the video, do this exercise, and 
54:12 - then come back and continue watching. 
54:16 - Alright, this is pretty easy, so we do a 
54:20 - select star to get all the columns from the products table, 
54:24 - where quantity in stock 
54:28 - in we use the in operator to compare this attribute with these values. 
54:32 - 49, 38, and 72, let's execute the query, 
54:36 - we get only 2 records because we 
54:40 - don't have a product with quantity in stock equal to 72. 
54:48 - In this tutorial, we're going to look at the between operator 
54:52 - in SQL, so that means we want to get the customers who have more
54:56 - then 1000 and less then 3000 points. What made you
55:00 - write these queries like this? Where, points, greater than
55:04 - thousand, more accurately greater than or equal to 1000. 
55:08 - And, points less then or equal to 
55:12 - 3000. When we execute this query we get 
55:16 - how many, we get 4 people that satisfy my criteria. 
55:20 - Now whenever you're comparing an attribute with a range of values, 
55:24 - you can use the between operator, and that makes your code shorter and cleaner. 
55:28 - So, we can rewrite this expression like this, where points, 
55:32 - between 1000 and 3000. 
55:36 - This is exactly equivalent to what we had before, so these
55:40 - range values are also inclusive, so that means points is going to be 
55:44 - greater than or equal to 1000 or greater than or equal to 
55:48 - 3000. Let's execute the query, we get the exact same result. 
55:56 - Alright, now as an exercise, I want you to write a query, to get the customers 
56:00 - that are born between January 1st 1990 and January 
56:04 - 21st, 2000. 
56:08 - Alright, so we start the 
56:12 - select star from customers, 
56:16 - where birth_date between 
56:20 - so what matters here is we can use the between operator 
56:24 - as well. It's not limited to using numbers. So with birth date between
56:28 - now we need to supply two date values, so as I told you before, 
56:32 - the format for dates is four digits for the year, so 
56:36 - 1990, two digits for the month, and two digits for the date. 
56:40 - So, the birthdate should be between this value and 
56:44 - here's a second value. 2000, 0, 1, and 
56:48 - 01. Let's execute this query, we get 
56:52 - only 3 people who match this criteria. 
57:00 - In this tutorial, I'm going to show you how to retrieve 
57:04 - rows that match a specific string pattern, for example, 
57:08 - let's say we only want to get to customers who's last name start with 
57:12 - 3. So, here in the where clause we type out
57:16 - where last name this is where we use the like operator, 
57:20 - and right after that we have a string pattern, so, 
57:24 - you want to get the customers who's last name start with b and we have 
57:28 - any number of characters after b. So use the 
57:32 - percent sign to indicate any number of characters, you may have 
57:36 - one character after b or no characters or 10 characters, with this
57:40 - pattern, you get all the customers who's patterns start with b. 
57:44 - And also it doesn't matter if it's an upper case or lower case b. 
57:48 - So, let's execute this query, there you go, so you only have 
57:52 - 3 customers who's last name starts with b. As another 
57:56 - example, let's say we only want to get the customers who's last name starts with 
58:00 - brush. So, we change our pattern to brush, 
58:04 - percent. Now, let's execute the query, we only get 
58:08 - this one customer here. Now this percent sign doesn't have to be 
58:12 - at the end of the pattern, it can be anywhere. For example, let's say we want 
58:16 - to search for customers who have an e in their last name, whether it's at the beginning 
58:20 - in the middle or at the end, so we change our pattern to 
58:24 - percent e percent this pattern means we can 
58:28 - have any number of characters before or after b. Let's
58:32 - execute the query, these are the customers that have a b 
58:36 - somewhere in their last name. It doesn't matter if b is in the beginning 
58:40 - or in the middle or at the end. Let's look at another example, 
58:44 - I want to get all the customers who's last names end 
58:48 - with y, so here's the pattern we use, 
58:52 - let's execute this query, so we have 5 customers 
58:56 - who's last name ends with a y. So this is how we use the 
59:00 - percent sign. Now we also have an underscore and 
59:04 - that matches a single character so with this pattern you get customer 
59:08 - who's last name is exactly two characters long, 
59:12 - we don't care what the first character is, but the second character should be y. 
59:16 - Let's execute his for you. Obviously we don't have any customers who's last 
59:20 - name matches this pattern. But if you change this pattern to 
59:24 - 5 under score, so 1234
59:28 - 5, followed by a y we should get 
59:32 - these customers. So their last name is exactly 
59:36 - 6 characters, we don't care about the first 5 characters, but all
59:40 - of them end with a y. Now, as another example, 
59:44 - we can replace the first underscore with b, and that means 
59:48 - we want to get the customers who's last names start with b, and 
59:52 - after b we have exactly 4 characters followed by a 
59:56 - y. Let's execute this query. So we only have one customer, 
60:00 - that matches this pattern. So this is how we use the 
60:04 - light operator, use the percent sign to represent 
60:08 - any number of characters and an underscore 
60:12 - to represent a single character. 
60:16 - Now this like operator in MySQL is an older operator 
60:20 - but we also have a newer one that is more powerful and it allows us to search for
60:24 - any string patterns. And that's what I'm going to show you next. 
60:28 - Alright. 
60:32 - Here I'm going to give you two exercises for the like operator. 
60:36 - First, I want you to get the customers who's addresses contain trade
60:40 - or avenue, and next I want you to get the customers who's phone 
60:44 - numbers end with 9. 
60:52 - Alright, let's get started with the first exercise. So 
60:56 - start from customers where address
61:00 - like now here we want to use a search pattern like this. 
61:04 - You want to have tray (?) but tray can be anywhere in the address. So, 
61:08 - we put a percent before and after tray. 
61:12 - Next, we should use the or operator to search for another pattern. 
61:16 - Or address like, let me 
61:20 - put this on a new line that is better, address
61:24 - once again, percent, avenue percent, that's it. 
61:28 - So, let's execute this query, 
61:32 - here is the result, you should get the customers with ID's 
61:36 - 2, 9, and 10. If you look at their addresses, all of them
61:40 - have either tray or avenue in their
61:44 - address. Now let's work on the second exercise, you want to get 
61:48 - the customers who's phone numbers end with 9. That is pretty easy, 
61:52 - so, let me change our where clause. Where 
61:56 - phone once again we use the like operator and a percent, 
62:00 - followed by a 9. That's all you have to do. Let's execute the 
62:04 - query. So, here's the result, customers with 
62:08 - id's 3 and 7, their phone numbers, and 
62:12 - 9. So this is how we use the like operator. And by the way
62:16 - you can always use the not operator here let's say you want to get the 
62:20 - customers who's phone numbers don't end with 9, 
62:24 - so we simply prefix like with not. Now, 
62:28 - if we execute this query one more time, we get all the other 
62:32 - customers in the database. 
62:36 - In the last tutorial you
62:40 - learned about the like operator in SQL. So as another example 
62:44 - let's say you want to search for the customers who have the word 
62:48 - field in their last name. So we type out the where clause like this, 
62:52 - where last name, like, percent, 
62:56 - field, percent, so the word field, 
63:00 - can be anywhere in the last name. Let's execute this query, we get 
63:04 - only one customer, beautiful. Now we also have another
63:08 - operator in MySQL, that is reg x which is 
63:12 - short for regular expression, and regular expressions are extremely 
63:16 - powerful when it comes to searching for strings. So they allow us to
63:20 - search for more complex patterns. Here's an example. If I want to
63:24 - rewrite this last where clause using a regular 
63:28 - expression it looks like. Where last name 
63:32 - ragexp now here in our string pattern 
63:36 - we don't have to type out the person's size we only type 
63:40 - out field so what we have on line 4 is exactly 
63:44 - identical to what we have on line 3, let's execute this query 
63:48 - we get the same result, beautiful, now here in regular 
63:52 - expressions, we have additional characters that we don't have when we use the 
63:56 - like operator. For example, we can use the carrot sign to indicate
64:00 - the beginning of a string. So if I put a carrot 
64:04 - just before the word field, that means our 
64:08 - last name must start with field. Obviously, if you execute
64:12 - this query, we don't get anyone that matches this criteria, so we use the 
64:16 - carrot sign to represent the beginning of a string. We 
64:20 - also have a dollar sign to represent the end of a string. 
64:24 - So this pattern means the last name must end with field. 
64:28 - Let's execute this query, you get the same result as before. Now
64:32 - we can also search for multiple words here, for example let' say we want to find 
64:36 - the customers who have the word field or mac in their last name
64:40 - So, we use a pipe, a vertical bar, 
64:44 - and type out another pattern. Let's execute
64:48 - this query, so here we have two customers, one of them has the word 
64:52 - mac, the other has the word field and the last name. 
64:56 - Now we can take this to the next level. Let's say we want  to find the customers who
65:00 - have the words field, or Mac, or rows 
65:04 - in their last name. Let's execute the query we get 3 customers. 
65:08 - Beautiful. So we use a pipe or a vertical board 
65:12 - to represent multiple search patterns. Now as another example, 
65:16 - we can change our first search pattern to something like this.
65:20 - Now this pattern means this last name should either start 
65:24 - with the word field, or it should have the word
65:28 - mac in it or it should have the word rows. Let'sexecute
65:32 - the query, now we get only two customers, because our customer
65:36 - with the last name brush field doesn't match this pattern. 
65:40 - However, if we change our first pattern to field 
65:44 - $ and execute the query we get 3 people here, 
65:48 - 3 customers. So this is how we can combine multiple special characters
65:52 - when building a complex pattern. Now let's look at another 
65:56 - example, let's say you want to search for customers who have an e in their last name. 
66:00 - So these are all the people, alright, now let's say 
66:04 - you want to make sure that before the letter e, we should either have a 
66:08 - g or an i. So this is where we use square brackets. 
66:12 - And inside the brackets we add multiple characters like
66:16 - g, i, m and that matches any customers who have 
66:20 - ge or ie or me 
66:24 - in their last name. So any of these characters can come before e. 
66:28 - Now, let's execute this query, 
66:32 - there you go, we only get 2 customers, and the first
66:36 - example before e we have i which is one of the characters 
66:40 - inside the brackets, in the second example, before e we have 
66:44 - a g which is also another valid character before 
66:48 - and once again the square brackets don't have to be before
66:52 - we could add them after e, any customers who have e 
66:56 - followed by an f or an m or a q in their last 
67:00 - name, can be returned with this pattern, 
67:04 - if we don't have anyone in the database so this is how we use square brackets, 
67:08 - now we can also supply a range of characters, for example 
67:12 - we can have e and just before e you can have 
67:16 - as many characters from a to h, you don't have to
67:20 - type them out explicitly like abcdefg, that's very 
67:24 - verbose, so, we can type out a to h. 
67:28 - And then if we execute this query we get these three people. 
67:32 - So, let's quickly recap everything you learned about regular expressions
67:36 - in this tutorial. Use a carrot to represent the beginning of
67:40 - a string, so beginning, we use a dollar sign to represent 
67:44 - the end of a string, we use a vertical bar or pipe, 
67:48 - to represent a logical or so we can supply multiple
67:52 - search patterns, we use square brackets to 
67:56 - match any single characters listed in the brackets, and finally 
68:00 - we use square brackets with a  hyphen to represent a range. 
68:04 - So any characters from a to f. 
68:08 - Technically MySQL supports more special characters but quite
68:12 - honestly, the ones that I've listed in this tutorial are the ones that you'll be using 90% of the
68:16 - time. So just memorize these and you're good to go.
68:24 - With honesty a lot of beginners find the syntax for regular
68:28 - expressions confusing, so in this video I'm going to give you 4 exercises that I have carefully 
68:32 - designed to help you quickly learn about this syntax. Here's
68:36 - the first exercise, get the customer's who's first names are Elka 
68:40 - or Ambur. And note that this is Ambur with a U. 
68:44 - Now for the second episode return the customer's who's names 
68:48 - end with ei or on. 
68:52 - Here's the third exercise get the customer's who's last names start with
68:56 - my or it contains se, and finally 
69:00 - as the last exercise return the customer's who's last names
69:04 - contain e followed by r or a u. 
69:08 - So, go ahead and spend 2-3 minutes on this exercise, 
69:12 - when you're done come back and continue watching. 
69:20 - Alright, let's knock out the first exercise. So we'll get 
69:24 - allows, there's a c here, so let's start from 
69:32 - regular expression, and here's our pattern, you're going to search 
69:36 - for two words either Elka or Ambur. 
69:40 - As simple as that. Let's execute this query, we should get two
69:44 - customers, there you go, Ambur and Elka. Alright.
69:48 - Now, let's knock out the second exercise. So I'm going to delete these 
69:52 - we don't need them anymore. So we want to get the customers 
69:56 - select start from customers, where 
70:00 - last name should end with either ey or 
70:04 - om. So, in the search pattern we type out 
70:08 - ey followed by a dollar sign to indicate the end of a string
70:12 - then we add a vertical bar to supply the second
70:16 - search pattern. So On and once again dollar sign. 
70:20 - Let's execute this query, oops I forgot to type out
70:24 - regular expression, there you go. So, 
70:28 - Let's execute this query, and you should get 
70:32 - these four customers with ID's one 
70:36 - three, five and seven. The first three, five, and seven, the first three, their last names 
70:40 - end with ey, and the last customer, his or her last 
70:44 - name ends with on. Alright, Now, let's 
70:48 - work on the third exercise. So I'm just going to change the regular expression 
70:52 - here, we want to get the customers whose last names start with
70:56 - my or contains se. So we use 
71:00 - a carrot to indicate the beginning of a string so 
71:04 - it should start with my, or it should contain se, 
71:08 - again, very easy, let's execute this query 
71:12 - and we get the customer's with ID's 
71:16 - 4, 8, and 10 and finally 
71:20 - we want to get the customers who's last names contain e 
71:24 - so, let's change the search pattern, we should have a b, 
71:28 - followed by r or u. Now there are two ways to write 
71:32 - this regular expression, we can use square brackets so 
71:36 - we have b followed by r or u, that's one way, or
71:40 - the other way is to use a vertical bar. So b
71:44 - r or bu. These are both valid solutions.
71:48 - So, I hope you knocked out these exercises, in the next tutorial I'm going to show you 
71:52 - how to get the records with missing values. 
72:00 - In this tutorial, I'm going to show you how to look for records that miss 
72:04 - an attribute. For example, if you select all the customers in our database, 
72:08 - you can see that the customer with id 5 doesn't have 
72:12 - a full number. So if you look closely here, you can see the value of
72:16 - null. Null means the absence of a value. Now let's say
72:20 - we want to search for all the customers who don't have a phone. Perhaps you want to send them an email
72:24 - and say hey, your phone is missing in our system. So how can
72:28 - we get these customers? That is very easy? We use the is null
72:32 - operator, so in the where clause, we type out 
72:36 - where phone is null. Now let's execute 
72:40 - this query, we only get one customer who doesn't have a phone, 
72:44 - now here we can also use the not operator to get 
72:48 - the customers who do have a phone. So we change the conditions to
72:52 - is not null. Let's execute the query, 
72:56 - now in the query results, every customer 
73:00 - does have a phone number. 
73:04 - For this exercise, I want you to write a query 
73:08 - to get the orders that are not shipped yet. This is a very useful query 
73:12 - that is used in a  lot of real applications. For example, let's say you're an admin for
73:16 - online shop. You want to see the orders that are not shipped yet, so you can see 
73:20 - them all. So write a query, and get these orders. 
73:28 - So here we have the orders table, let's have a quick look at the
73:32 - data in this table. So if you pay close attention 
73:36 - you see some of these orders don't have a
73:40 - date. And these orders also don't have a shipper id which 
73:44 - is a unique number for identifying the shippers. So any order
73:48 - that misses the value for the ship date or shipper ID, 
73:52 - is considered an order that is not shipped. So let's go ahead and write 
73:56 - a query to get these orders. So back to our query editor 
74:00 - select star from orders where 
74:04 - ship_date is 
74:08 - null. You could also write shipper id is null. They're both
74:12 - equally correct. So let's execute this query, and you should get 
74:16 - 5 orders. Orders 1, 3, 4, 6, 
74:20 - and 8. 
74:24 - In this tutorial I'm going to
74:28 - show you how to sort data in your sequel queries. So here in your
74:32 - have a query to select all the customers from the customers table, if you look at 
74:36 - the query result, you can see that our customer's or sorted by id, 
74:40 - so we have customers 1, 2, 3, 4, and so on. This is the 
74:44 - default sort column. But we can always change this using the 
74:48 - order by clause. But first, let me explain 
74:52 - why the customer id column is the default sort column. So first of all
74:56 - the first I'm going to open up the navigators panel on the left side here's the customers
75:00 - table, now let's click on this middle icon here that looks like 
75:04 - tool. This opens up our customers table in the design mode, 
75:08 - here we can change our columns we cana dd new column or 
75:12 - remove existing ones or change that name and order and so on. 
75:16 - Now if you pay close attention you can see a yellow key just before 
75:20 - This means that this column is the primary key column. 
75:24 - For this query. So in relational databases every
75:28 - table should have a primary key column, and the values in that column 
75:32 - should uniquely identify the records in that table. So 
75:36 - back to our query window, you can see that the values in this column
75:40 -  uniquely identify each customer, so the customer id column 
75:44 - is the primary key column in this table, and that is why when you write a 
75:48 - query against this table, our customers will sort it by id by default. 
75:52 - Now, let me show you how to sort customers by a different column. 
75:56 - So, here in the order by clause, you type out the name of another
76:00 - column, like first name. Let's execute the query, now we can 
76:04 - see our customers are no longer sorted by their id, instead 
76:08 - they are sorted by their first name in ascending order. Now, 
76:12 - if you want to reverse the sort order, simply type out de, 
76:16 - e, sc, which is short for descending. Now, 
76:20 - you're sorting the customers in this order, okay, 
76:24 - we can also sort data by multiple columns, for example, 
76:28 - let's say first we want to sort customers based on their state, 
76:32 - and then within each state, we want to sort them by their first name. 
76:36 - So, we type out multiple columns here, state 
76:40 - and first name. Let's execute the query 
76:44 - now, you can see that the first state we have here is california, followed 
76:48 - by Colorado, and new here in Florida, you have two customers 
76:52 - and these customers are sorted by their first name. Let's have a 
76:56 - close look here, so first we have Ambur and then we have other
77:00 - customers here. Now we can also use the descending argument anywhere here. 
77:04 - For example, we can sort these customers by their state in descending 
77:08 - order. And then sort them by their first name in ascending order 
77:12 - or once, again in descending order. So there are various ways we can
77:16 - sort data. Now one of the differences between MySQL, and 
77:20 - other database management systems, is that in MySQL you can sort
77:24 - data by any columns whether that column is in the select clause 
77:28 - or not. For example, let's say you only want to select 
77:32 - the first and last name for each customer. Now we can sort
77:36 - the result by any columns in this table, they don't have to be first name and last names
77:40 - For example, we can sort them by their birthdate, 
77:44 - take a look, so this is a valid query in MySQL, but other databases
77:48 - management sometimes yell at you when you update a query like this. 
77:52 - Now we can also sort data by an alias for example, here in
77:56 - out select clause let's add the number ten and give it a 
78:00 - alias. As let's say points, so points is
78:04 - not a valid column in this table, it's simply an alias 
78:08 - or expression, in this case a simple number. And here we could have a complex 
78:12 - mathematical expression, it doesn't really matter, we can still sort 
78:16 - data by Alias, so we can order by points 
78:20 - and then first name. Once again this is a valid, 
78:24 - query from MySQL's point of view. Now one last thing before we finish 
78:28 - this tutorial, I've seen some tutorials that teach you how to sort data by
78:32 - calling positions, for example, here we can order it by 
78:36 - 1, 2, and that basically means sort the data by the first name, 
78:40 - and then, the last name. So these are the orders of these columns, 
78:44 - if you execute this query, you can see that our customers are sorted by their first 
78:48 - name and then last name. Why this approach works, it's something that
78:52 - you should avoid. Because if in the future you come back here and add 
78:56 - a new column, in front of the first name column, let's say 
79:00 - first, date. Now our customers are no longer sorted 
79:04 - in this order. So sorting data by calling positions 
79:08 - produces unexpected results and is something you should avoid. 
79:12 - always sort by column names like first, 
79:20 - Alright, here's your exercise for this tutorial. In this database, we have this table, 
79:24 - called order items, where we find the items for each order. Now, 
79:28 - I've written the query that you cannot see here, because that's the solution to the exercise 
79:32 - I'm going to give you, that query produces this results. So 
79:36 - we only have the items for the order with ID 2, and we 
79:40 - have sorted these items based on the total price 
79:44 - for each item. So the total price for each item equals quantity times
79:48 - unit price. In this case the total price of product 1 is just 
79:52 - over 18 dollars. So go ahead and write a query 
79:56 - to select all the items for order with ID2. And 
80:00 - sort them by their total price in descending order. 
80:08 - Alright, let's select everything from order 
80:12 - items, where order id equals 2. 
80:16 - that returns all the items for this order. Now we want to make sure 
80:20 - to sort them by their total price, so, 
80:24 - here in order by clause, we write an expression. Quantity times 
80:28 - unit price, this returns the total price for each item. 
80:32 - And then we add the descending argument here. So, 
80:36 - once again the expression that we use in the order by clause doesn't have to be 
80:40 - column name, it can be an alias or an arithmetic expression like this. 
80:44 - Let's go ahead and execute this query. This is what we get 
80:48 - now for clarity, I would like to add another column in the result 
80:52 - So, let's say quantity times unit
80:56 - _price. We give it an alias like total 
81:00 - price. Let's execute the query, you can clearly 
81:04 - see, that this data ia sorted by the total rice in descending order. 
81:08 - However, there is a bit of duplication in our query, you have to
81:12 - repeated this expression in two places. So now we can simplify our 
81:16 - by clause, by using an alias that is total price. 
81:20 - And we gwet the exact same result. Net I'm going to show you
81:24 - how to mimic the number of records returned form your queries. 
81:32 - In this tutorial, I'm going to show you how to limit the 
81:36 - records returned from the query. For example, when we return this query 
81:40 - we get all the customers in the customer, table, so we have to 
81:44 - ten customers here. Now what if we only want to get, 
81:48 - the first 3 customers. That's where we use the limit clause. 
81:52 - Let me show you. So, after from, you type out
81:56 - limit 3, and this will return only the first 3 
82:00 - customers. Now if the argument that we pass here is
82:04 - greater than the number of records that our query produces, we'll get 
82:08 - the records in the query result. For example, if I pass 300 here, 
82:12 - obviously we don't have 300 customers in this table, so when
82:16 - we execute this query. We get all the ten customers in this table. 
82:20 - So this is how the limit clause works. 
82:24 - Now here we can optionally supply an offset, and this is very 
82:28 - useful in situations where you want to paginate the data. For example, 
82:32 - let's say we have a website, and on this website we have a web page for
82:36 - the user to see all the customers int he database. Now for simplicity 
82:40 - let's imagine, we want to show only there customers per page. So, 
82:44 - what are the customer's you're going to have on page 1? We're going to have 
82:48 - customers 123. On page
82:52 - 2 we're going to have customers 456 and on
82:56 - page 3 we're going to have customers 789. 
83:00 - Now, let's say we want to write a query to retrieve the customers on page 3. 
83:04 - How can we do that? Well, you want to skip the first 
83:08 - 6 records and then pick 3 records. So, 
83:12 - we change our limit clause to something like this. 6
83:16 - and 3. So 6 is what we call an offset. 
83:20 - And that basically tells MySQL to skip the first records 
83:24 - and then take 3 records. Let's execute this
83:28 - query. Alright, now we get 
83:32 - customers 789. 
83:36 - Now, for your 
83:40 - exercise, I want you to get the top 3 loyal customers. These
83:44 - are the customers that have more points then everyone else. 
83:52 - Alright, first we select everything from the customers table, 
83:56 - now we need to order these customers by their points, 
84:00 - in descending order. So if you look at the query result 
84:04 - you can see that customers are sorted by their loyalty. So, 
84:08 - the most loyal customers come first, now we want to pick 
84:12 - only the first three customers, and that's where 
84:16 - we sue the limit clause, so limit, 
84:20 - let's execute this query. And these are the 
84:24 - most loyal customers, customers with id's 56
84:28 - and 3. Now, here's one thing I want you to remember and that is 
84:32 - the order of the limit clause. The limit clause should always 
84:36 - come at the end. So first we have the select clause and then
84:40 - we have from optionally you can have where followed by
84:44 - order by and finally limit. Order of these clauses matter 
84:48 - If you change the order MySQL is going to yell at you. So
84:52 - pay attention to the order when writing your queries. 
85:00 - So far you have only selected columns from a single but in a real 
85:04 - world, we quite often select columns from multiple tables. And that's what I'm going to show you
85:08 - over the next few tutorials, so on the left side if you put 
85:12 - our orders table. Let's select all the data here, 
85:16 - in this table we're using the customer id column to identify the customer 
85:20 - that has placed each order. Now as I have told you before 
85:24 - we don't store customers information here like their phone number, their email their address, 
85:28 - because this information can change in the future. And if 
85:32 - even a customer has placed multiple orders then we have to
85:36 - change multiple records, you don't want to do that. That's why we have separate tables 
85:40 - for customers and orders. Now in this tutorial I'm going to show you
85:44 - how to select the orders in the orders table, but instead of showing the customer
85:48 - id, we showed full name for each customer. So lets go back
85:52 - to our query window. Okay, so, 
85:56 - we want to select everything from the orders table. Now we should combine the 
86:00 - columns in this table with he columns in the customers table. That 
86:04 - is where we use the join keyword. And here we can optionally 
86:08 - type inner join, because we in SQL we have two types of join
86:12 - inner join and over join. You'll look at outer joins later in this section, 
86:16 - so for now we are only using inner join and these inner keyword, 
86:20 - is actually optional, so we don't have to type it.
86:24 - So, you want to join the orders table with the customer
86:28 - table. Now, on what basis do we want to join these tables? 
86:32 - Well, here in the customers table, we have this customer id column. 
86:36 - So if you put these two tables next to each other you want to line up the records 
86:40 - such that the customer ID's are equal. That is where 
86:44 - we use the on phrase. So after
86:48 - we type out a condition, here's a condition we need to type out, 
86:52 - orders.customer_id. Should be equal to 
86:56 - customers.customer id. 
87:00 - Now, this is getting outside of the screen, so let's break up the line, 
87:04 - that's better, so with this query, we're
87:08 - telling MySQl that hey, whenever you're going the orders table 
87:12 - with the customers table, make sure that the customer ID column, 
87:16 - in the orders table, equals the customer ID 
87:20 - column, in the customers table. Now let's execute this query, 
87:24 - look at the result, 
87:28 - since we are selecting everything here, the first few columns are
87:32 - from the orders table, because we have listed that first 
87:36 - now after all the columns in the 
87:40 - customer table. So customer ID first name, last name and so on. 
87:44 - Now let's simplify the result set and select only 
87:48 - border id, first name, and last name, so query 
87:52 - we select order ID, first 
87:56 - name, and last name. Now let's execute the query 
88:00 - that is better. So next to each order ID, you can see the 
88:04 - name of the customer that placed that order. Now what if you want to display 
88:08 - the customer ID here as well. Well, let's put that here and 
88:12 - see what happens. Customer ID, execute the query 
88:16 - we get an error, so if you look at the output window, down at the bottom, 
88:20 - we should see an error saying column, customer id, field this is
88:24 - ambiguous. Now unfortunately I cannot show you this error, because the size of my
88:28 - recording window is smaller then MySQL workbench. But
88:32 - that aside, let me explain why we're getting this error. Because we have this customer ID 
88:36 - column in both the orders and the customers table, 
88:40 - so MySQL is not sure which table we want to select this
88:44 - column from. That is why it's saying this column is ambiguous 
88:48 - so we need to qualify this column by prefixing it with a table name. 
88:52 - We can either pick it from order table or 
88:56 - the customers table, it doesn't really matter, because the values are
89:00 - equal, right? So, in situations where you have 
89:04 - the same column in multiple tables, you need to qualify them, 
89:08 - by prefixing them with the name of the table, okay, now, 
89:12 - we say tot he query one more time, there you go, you have order ID, 
89:16 - customer ID and the full name. Now one more thing 
89:20 - before we finish this tutorial, if you pay close attention we have repeated the word 
89:24 - orders in multipel places, you have it here, as well as 
89:28 - in the join condition, the same is true about he customers table, you
89:32 - have repeated that here. We can get rid of this repetition 
89:36 - and make our code simpler by using an alias. So write 
89:40 - after each table you can do it in alias, 
89:44 - as a short for orders, so by convention we abbreviate the table's name. 
89:48 - Now, wherever we have orders you should replace that with 
89:52 - o. So here in the join condition, we're going to replace orders 
89:56 - with o, and also one more time, in the select 
90:00 - clause. There you go. You can also apply an alias for 
90:04 - a customer's table, call it c, and then simplify 
90:08 - our join condition like this. So this is how we can join 
90:12 - columns for multiple tables. 
90:16 - Now for your 
90:20 - exercise, I want you to look at the order items table. 
90:24 - So, in this table we have these columns, order ID, column ID, 
90:28 - product id, quantity, and unit price. Now I want you to write a query 
90:32 - and join this table with the products table so for each order 
90:36 - return both the product id as well as this name, followed by the 
90:40 - quantity, and the unit price form the order items table. And by the way 
90:44 - make sure to use an alias to simplify your code, 
90:52 - Alright, first let's select everything from the order 
90:56 - items table, and then join it with the 
91:00 - products table. How are we going to join this table. On
91:04 - order_items. Well actually 
91:08 - let's just keep this on Alias right away, so we use oi, 
91:12 - as an abbreviation for order items. And p as 
91:16 - a short for products. So oi.product
91:20 - id, should be equal to p or products.
91:24 - product id. And by the way, remember that
91:28 - alias for table, you have to use that alias everywhere. So here
91:32 - I cannot type out product, MySQL is going to yell at me. So
91:36 - let's use the abbreviation. Alright, this is how we join these tables, 
91:40 - let's execute this query up to this point. Alright, 
91:44 - so we see all the items form the order items table, followed by 
91:48 - from the products table. Now, you want 
91:52 - to explicit select a few column here. So, to 
91:56 - order items table you want to select order_id. 
92:00 - We take it then we don't have to prefix it with a table name 
92:04 - because this calumnies not repeated in multiple places, so it's not ambiguous. 
92:08 - So, let's make the code shorter, that's better, now 
92:12 - we want to select the product ID column, but because this column exists
92:16 - in both tables, you have to both prefix it with a column name.
92:20 - Either oi or p it doesn't really matter. So, 
92:24 - next, we want to select quantity, and finally you want 
92:28 - price. Now actually here, you have this unit price column. 
92:32 - In both tables, so this is the unit price in order items table 
92:36 - and this is the unit price in the products table, 
92:40 - now you might be curious why we have this column in 2 places, 
92:44 - is that the price of product can change, so for each 
92:48 - order item, you want to have the price at the time the user 
92:52 - placed the order. So this is a snapshot of the price 
92:56 - at a given point in time. The unit price that we have for the products table 
93:00 - is the current price right now. This is very important for the 
93:04 - recording, otherwise we cannot calculate the sales properly. So, 
93:08 - because we have the unit price column in two places, in this case we should pick it
93:12 - from the quarter items table because this is the price at the time of
93:16 - now, let's execute query. So here's 
93:20 - the final result. 
93:24 - In the real world, when you
93:28 - work as a developer or a data base administrator quite often you will 
93:32 - have to work with multiple databases. In this tutorial I'm going to show you how
93:36 - to combine columns from tables in multiple places. 
93:40 - That's pretty easy. So, in the SQL store database, you have this tables 
93:44 - that you're fairly familiar with. Now imagine this products table
93:48 - was not here. Now, if you look at the 
93:52 - database, you can see here another products table, this
93:56 - products table is exactly the same as the products table that we have 
94:00 - in a SQL store database, so it has the same columns and the same data. 
94:04 - Now technically this is not a good design, you don't want to have the same table 
94:08 - repeated in multiple places. But for this demo, let's just imagine 
94:12 - that we don't have the products table here, so we want to join the 
94:16 - order items table, with the products table in the SQL
94:20 - inventory database. Let's get started. So select 
94:24 - everything from the order items table, 
94:28 - let's give it an alias straight away, you want to join this with
94:32 - the products table. This products table is part of the products inventory 
94:36 - database. So we'll have to prefix this with the name of it's database. 
94:40 - So, we type out SQL inventory.
94:44 - Now once again we can give this an alias like p, 
94:48 - then type out our joint condition, so oi.product 
94:52 - id should be the same as p.product id. 
94:56 - Let's run the query there you go, so we successfully joined 
95:00 - tables across multiple databases. Now note that
95:04 - we're prefixing the products table with the name of the database because 
95:08 - the current database that we're writing this query with is the SQL stored 
95:12 - database. Take a look, in the navigator panel, in the SQL 
95:16 - store database is displayed in full. Because earlier, the 
95:20 - root we use statement to select 
95:24 - a database, that will SQL store. Now what if we select 
95:28 - the SQL inventory database. So, let's see what happens SQL 
95:32 - inventory, now because we have multiple statements we have 
95:36 - to terminate this with a semi colon. Now we want to select everything with a 
95:40 - order items table. But we don't have this table inside of this 
95:44 - database. So now we'll have to prefix this table 
95:48 - with the name of it's database, that is SQL underline 
95:52 - story. Let's execute the query, okay, 
95:56 - everything works, beautifully. So here's the lesson. You only have to 
96:00 - prefix the tables that are not part of the current database. In other words
96:04 - the query will be different depending on the database. 
96:12 - In SQL we can also join a table with
96:16 - itself. Let me show you an example. Take a look at this database. 
96:20 - SQL hr, in this database we have 
96:24 - these two tables, employees and offices. Let's take a look at the 
96:28 - data int he employees table. 
96:32 - There you go. So here we have these columns, 
96:36 - employee id, first name, last name, salary 
96:40 - and reports 2. This is the id of 
96:44 - the manager for this person or this employee. Now once again, 
96:48 - you don't want to repeat the managers information here, like the phone number, the address
96:52 - because this information can change in the future, so we are only using 
96:56 - your identifier or their id to refer to them in this table, 
97:00 - now where can we find information about this
97:04 - This manager is actually an employee of the same organization, so, 
97:08 - look at this example, the manager ID is 37
97:12 - 370. Now if you look on the website, here is the ID of
97:16 - that manager which is another employee. That was the manager for this
97:20 - employee. We don't have any values here so 
97:24 - the value for the sale is null. So this employee doesn't have a manager 
97:28 - and that means they are the CEO. So let's go ahead and 
97:32 - write a query to join this table with itself so we can select the name of
97:36 - each employee and their manager. Back to our query window, 
97:40 - first we need to select the SQL hr database. 
97:44 - Next, we select everything from 
97:48 - the employees table, we give an alias like
97:52 - b now we need to join this table with itself. So once again we type 
97:56 - out the employees, but we need a different alias. What should we 
98:00 - call this alias. Well you want to join this table with itself so we can 
98:04 - find the managers right? So we can use m as a shortcut 
98:08 - for managers. Now, let's type our our joint condition. 
98:12 - So from the employees table, we need to join 
98:16 - the reports_2 column. To the manager 
98:20 - table which is basically an employees table itself, and 
98:24 - that is employee_
98:28 - id. Now let's execute this query and see what we get. 
98:32 - So, we see all the columns from the employees table 
98:36 - repeated the first set of columns, represent the information about the 
98:40 - employees, and after that, we have the information about the managers
98:44 - in this case we have only one manager in this table. 
98:48 - But with this technique we can easily create an organization trial. We can have 
98:52 - a hierarchy of managers. Now let's 
98:56 - only the name of the employee and the manager. So, 
99:00 - right here, since every column in the employees table is 
99:04 - repeated twice we need to prefix each column with a table name. 
99:08 - For example, from the employee's table you want to get
99:12 - employee ID, as well as the first 
99:16 - name, and then for the managers table, we want to select 
99:20 - the first name as well. So every column 
99:24 - should be prefixed with a table name or more accurately the alias because
99:28 - all these columns exist in two tables, right? 
99:32 - Let's go ahead and execute this query, so, 
99:36 - this is what we get, employee id, and here's the managers 
99:40 - first name. We can improve this query by giving an alias to this
99:44 - column. Because it doesn't make sense to have two first name columns. 
99:48 - So, let's give an alias to the third column, 
99:52 - manager. Now, let's execute it one more time. 
99:56 - And, here's the end result. So, we have
100:00 - the empty ID first name, and object. So, 
100:04 - joining a table with itself is pretty much the same as joining a table with
100:08 - another table. The only difference is that we have to use 
100:12 - different alias's. And we have to prefix each column with an alias. 
100:16 - This is what we call a self join. Next, I'm going to show you
100:20 - how to join more then two tables. 
100:24 - In this tutorial, 
100:28 - I'm going to show you how to join more then two tables in writing a 
100:32 - query. For example, back to our SQL database, look at the 
100:36 - orders table, now you know how to write a query to join this
100:40 - table with the customers table to return information about the customer
100:44 - to place each order. But here we also have another column, 
100:48 - status, which is similar to the customer ID status. So the name of the 
100:52 - status's are not stored in this table, they are somewhere else in the 
100:56 - order status's table. Let's have a quick look here. 
101:00 - Our orders can be either processed, shipped or delivered. And these are
101:04 - the identifiers for each of these status's. Now back to our
101:08 - orders table. In the status column you store
101:12 - status id. So now we should write a query to join the orders
101:16 - table, be two tables. The customers table and orders 
101:20 - status's table. The result of this query is going to look like this. 
101:24 - So for each order we see the order id, the date, 
101:28 - the first and last name of the customer, and finally the status of the order. 
101:32 - This is a beautiful report we can create for our users. So let me
101:36 - show you how to write this query. Back to our query editor, first we need to select 
101:40 - the SQL store database, now, we need to select 
101:44 - everything from the orders table, that's going to be the alias, 
101:48 - next we need to join this with the customers table. 
101:52 - On, that customer id should 
101:56 - be equal to see the customer id. Nothing 
102:00 - new so far. Exactly like before. Now here we can write another
102:04 - joint keyword. To join the others keyword 
102:08 - order status's table. So we type out order status's. 
102:12 - And also give it an alias, OS, 
102:16 - what is our join condition? Well, back in the 
102:20 - orders table, here we have the status column. So the 
102:24 - value in this column should be equal to the order status ID, 
102:28 - column in order status's table. Right? So back
102:32 - to the query, so orders table.status
102:36 - should be equal to order status's.order status
102:40 - ID. Make sure to get the name right, otherwise you're going to get
102:44 - an error So this is how we can join three tables. 
102:48 - Now in the real world as you work on more complex problems, you'll end up joining 
102:52 - even ten tables. So this is not uncommon in the SQL world. 
102:56 - Now let's go ahead and execute this query. First we get the column 
103:00 - from the orders table, followed by the orders from the customers table, 
103:04 - and so on. This result is so complex and hard to extract information. 
103:08 - from. So, let's explicitly select 
103:12 - a few columns here. From the orders table, you want to select 
103:16 - the order iD column, as well as the order
103:20 - date. Then, from the customers table, we want to select 
103:24 - the first name, and last name.
103:28 - And finally form the order status's, we select the name 
103:32 - column. So we can give this an alias like status
103:36 - that's better. Let's execute the query one more time. 
103:40 - So, here's the end result, we have order ID, 
103:44 - order date, the name of the customer, followed by the status of the order. 
103:52 - Alright, for exercise, take a look at the SQL
103:56 - invoicing database. Here we have this table, payments, 
104:00 - and these are the payments that each client has made towards either invoice 
104:04 - Let's take a look at the data, so we have these columns, 
104:08 - like client id, that identifies the client, so we can join this table 
104:12 - with the client's table to see the name of the clients. Next we 
104:16 - have invoice ID, we also have date, 
104:20 - payment method. So similarly we can join this table with the payment method 
104:24 - table here, let's have a look at the data in this table, these are the 
104:28 - payment methods, credit card, cash, PayPal, wire transfer. So, 
104:32 - back to the payments table, I want you to write a query and join this table 
104:36 - with the payment methods table as well as the client's table. 
104:40 - Produce a report that shows the payments, with more details, such as the name of the client, 
104:44 - and the payment method. 
104:48 - Alright, first we need to
104:52 - use, the SQL invoicing database, now we can 
104:56 - select everything from the payments table which we call
105:00 - e, next we need to join this with the client's table which we call
105:04 - c, on p.clientid 
105:08 - should eb equal to c.client id. Let me double 
105:12 - check the column name to make sure I got it right, so back to the payments table
105:16 - the column is called client item. You also have a column called 
105:20 - payment method, that we should join to the payment 
105:24 - method ID column of the payment methods table. 
105:28 - So, back to the query, once again we use a joint 
105:32 - statement here, join with payment methods, we give it an alias 
105:36 - pm, on p.
105:40 - payment _method should be equal to pm. 
105:44 - payment method id. Make sure to type it out correctly 
105:48 - otherwise you're going to get an error. So let's go ahead and execute the query 
105:52 - up to this point, finally let's hand pick 
105:56 - the columns that make the most sense. So, 
106:00 - from the payments table, let's select the
106:04 - date, followed by invoice id, 
106:08 - what else do we have here. So we have client id, invoice 
106:12 - id, date, and now the payment method, I'm going to pick the amount 
106:16 - column from here as well, so back to the query, p 
106:20 - .amount. Now we need to add information about the client. 
106:24 - Let's take a look at this table, clients, 
106:28 - so here we have columns like name, address, 
106:32 - city and so on. All we need here is the name column. So back to the query, 
106:36 - of the client's table let's select the name column and 
106:40 - finally form the payment method table, let's select, what is that column called
106:44 - it's called name. So back to the query
106:48 - pm.name. So here's the end result. 
106:52 - Now we can put this column in any order that we want, it doesn't really matter, 
106:56 - let's execute the query, and make sure everything works. 
107:00 - So, on this date, on this invoice, 
107:04 - we have a payment for this amount by this client using a 
107:08 - credit card. 
107:12 - Ina let he examples you have seen so far, 
107:16 - we use a single column to uniquely identify the rows 
107:20 - in a given table. For example, for example, in the customers table, 
107:24 - we have this customer ID column which uniquely identifies 
107:28 - the rows in this table. But there are times where we cannot use a single 
107:32 - column to uniquely identify columns in a given table. For example,
107:36 - look at the order items table. In this
107:40 - table, we have columns like order id, product id, and so on. Now if you look at 
107:44 - the data, you can see that the values in the order id column are repeated. 
107:48 - They are duplicated. You have 2226 and so on.
107:52 - So we cannot use this column on it's own to uniquely identify each record. 
107:56 - The same is true for the product id. The values for this column 
108:00 - are also duplicated. So in this table we use the combination of
108:04 - the values in both these columns to uniquely identify 
108:08 - each oder item. As an example, in this order we have 
108:12 - 3 items, for products, 1, 4, and 6, and 
108:16 - for each product, we have a quantity and unit price.
108:20 - So if we use the combination of the values in both these values, 
108:24 - we can uniquely identify each order item, in other words, we don't have 
108:28 - two records for order ID 2, and product ID 1, 
108:32 - we only have a single record for that item, 
108:36 - now let's open this table in the design mode. So over here we 
108:40 - find this middle icon that looks like a tool. Note that this yellow 
108:44 - key that represents the primary key exists on both these columns. 
108:48 - This is what we call a composite primary key. The composite primary key 
108:52 - contains more then one column. Now why does this matter? 
108:56 - Well, when you have a table with a composite primary key. 
109:00 - You need to learn how to join that table with other tables. For example, 
109:04 - here we have this table, order item notes, that we use to keep
109:08 - notes in each order item. Let's look at the data here. 
109:12 - So we have this column note id, right? Which uniquely identifies the 
109:16 - records in this table, next to that we have order ID and product ID. 
109:20 - you learn that the combination of these two columns uniquely represents 
109:24 - and order ID. So here for order number 2, 
109:28 - for product number 1, we have two notes. Now let me show you how
109:32 - join this table with the order items table. So, back to our 
109:36 - query, you can see that I have already selected the SQL store
109:40 - database, so I'm not going to type out a U statement. Alright, let's select 
109:44 - like everything from the order 
109:48 - items table. Give it an alias, now we need to
109:52 - join this with order item notes, also 
109:56 - we give it an alias. How are we going to join these tables? 
110:00 - Based on two columns, back to the order items table 
110:04 - these are the columns that we need to use in our joint condition. 
110:08 - So, in the order items table we have this 
110:12 - order ID column, these should be equal to the
110:16 - same column in order item notes table. So, 
110:20 - in.order id. But this is not enough, 
110:24 - we should also join these tables based on the product ID number. 
110:28 - So, we type out and, and then type out the 
110:32 - second condition, so order items.
110:36 - product ID should be equal to order item notes.product 
110:40 - id. This is what we call a compound joint 
110:44 - condition. So we have multiple conditions to join these
110:48 - two tables. 
110:52 - In this tutorial 
110:56 - I'm going to talk about the implicit joint syntax in MySQL. 
111:00 - So here we have a basic inner join, we're selecting everything from the orders table, 
111:04 - joining it with customers table on, orders.customer
111:08 - id. Equal to customers.customerid. Pretty basic. 
111:12 - There is another way to write this query using implicit join 
111:16 - syntax. Let me show you how this works. So, 
111:20 - we select everything 
111:24 - from now here we can type out multiple table names. 
111:28 - so, orders, customers. 
111:32 - And we can also give them an alias, so c and 
111:36 - o. And then we move this join condition, 
111:40 - to the where clause, so I'm going to copy this from here, 
111:44 - type out the where clause, and paste the condition. These two queries, 
111:48 - are equivalent. What we have here is called implicit 
111:52 - joint syntax. Now even though MySQL supports the syntax 
111:56 - it's something that I suggest you not to use, because if you accidentally forget 
112:00 - to type out the where clause, you will get a cross join. Let me show you
112:04 - what I mean. So first I'm going to delete the first query. 
112:08 - And execute this 
112:12 - so we get ten records because we have 
112:16 - 10 orders in this database. So far so good. What happens
112:20 - if you accidentally type out
112:24 - the where clause. Instead of 10 records we're going to get 
112:28 - probably 100 records. Because every record
112:32 - in the order table, is now joined with every record in the 
112:36 - customers table. This is what we call a cross turn. Now later in this
112:40 - section I'm going to talk about cross joins in more detail, but what I want to talk about 
112:44 - in this tutorial, is that it's better to use an explicit 
112:48 - joint syntax, so, we use, join 
112:52 - because this syntax forces you to type out the joint condition, if 
112:56 - you simply join orders with customers, without typing 
113:00 - the join condition, you're going to get a syntax error. So to recap, 
113:04 - be aware of the implicit join syntax, but write all of 
113:08 - your joints using the explicit syntax. 
113:16 - Earlier in this section I told you that in SQL we have two types of forms. 
113:20 - Inner joins and outer joins. And so far you have 
113:24 - only seen examples of inner joins. And I also told you that this inner keyword is 
113:28 - optional, so whenever you type out a join, you're using an inner join. 
113:32 - In this tutorial, we're going to look at outer joins and the problems they
113:36 - solve. So, let's start by writing a query that uses an 
113:40 - inner join, and then we'll convert hat inner join and outer join. 
113:44 - So, select everything from the customers table 
113:48 - join it in the orders table, 
113:52 - on c.customer id should be equal to 
113:56 - o.customer ID. Pretty basic 
114:00 - right? Now for clarity, let's pick a few columns from these
114:04 - two tables .So for the customers table I want to pick customer 
114:08 - id. And first name, 
114:12 - and from the orders table, I want to pick order id. 
114:16 - Now finally, let's sort the results so we can clearly see what 
114:20 - we get. So order by c.customer 
114:24 - id. Let's execute that query and see what we get. 
114:28 - So, here' the result. For customer number 2 called 
114:32 - inis or inis whatever, you have 2 orders, order 4, 
114:36 - and order 7. Similarly for customer number 5, we have 
114:40 - 2 orders and so on. Now there is something missing in this result. 
114:44 - We only see customers who have an order in our system, these are 
114:48 - customers 2, 5, 6, 7, 8, and 10. But
114:52 - if you look at the customers table, you can see that 
114:56 - you have other customers like customer number 10, customers number 3, and so on. 
115:00 - Currently we don't have any orders for these customers, and that's the reason 
115:04 - we don't see them in this results set. But what if you want to see all the 
115:08 - customers whether they have an order or not? That's when we use an 
115:12 - outer join. Let me show you how that works. So back to our query 
115:16 - the reason we only saw customers who have an order was because 
115:20 - of this join condition, When joining these two tables, you are only 
115:24 - returning records that match his condition. So for a
115:28 - given customer, if we do have an order, that record
115:32 - is returned. But as you saw a second ago, some customers don't have 
115:36 - an order. So for those customers this condition is not 
115:40 - valid. And that is the reason they are not returned in the result set. 
115:44 - To solve this problem we use an outer join. Now in SQL we 
115:48 - have two types of outer joins. We have left joins and right 
115:52 - joins. When we use a left join, 
115:56 - all the records from the left table, in this case customers are 
116:00 - returned whether this condition is true or not. So we 
116:04 - get all the customers, and if they do have an order, we'll see the order id 
116:08 - as well. Let's execute this query and see what we get. So, 
116:12 - there you go. Customer number 1, 
116:16 - doesn't have an order and that's why we get null in this cell. 
116:20 - Customer number 2 has two orders, 4, and 7, customer 
116:24 - number 3 also doesn't have an order so we get null for order id. 
116:28 - This is the result of a left join. So back to our query 
116:32 - when we use a left join, all the records from the left 
116:36 - table are returned whether this condition is true or not. 
116:40 - Now what if we use a right join. In this 
116:44 - case, all the records from the orders table are returned whether this condition is 
116:48 - true or not. Let's execute this query and see what we get. 
116:52 - So, we get he same result as before. 
116:56 - when we use an inner join, because we are selecting all the records from the right table 
117:00 - which is the orders table, so we don't see all the customers 
117:04 - we see all the orders. Now if you want to use a right join, and 
117:08 - still see all the customers, you need to swap the order of these tables. So, 
117:12 - we put the orders table first that's going to be our left table. 
117:16 - And then, we put the customers on the right side, 
117:20 - so now with this query we'll return all the records from the right table 
117:24 - which is the customers table. We execute this we get 
117:28 - all the customers whether they have an order or not. 
117:32 - Beautiful. Now one last thing before we finish this tutorial, 
117:36 - I've seen developers use the outer keyword here. So either 
117:40 - right outer join or left outer join. But technically 
117:44 - the outer keyword is optional just like the inner keyword, so you don't have to type it out. 
117:48 - So I'm going to remove this to make this code shorter and easier to 
117:52 - understand. So to recap, if you have the join keyword directly, and 
117:56 - if you do a left or right join you're doing a 
118:00 - inner outer join. 
118:04 - Here's your exercise for this tutorial. I want you
118:08 - to write a query that produces this result. So we should have three columns here. Product 
118:12 - ID, name, and quantity that I picked from the 
118:16 - order items table, so here we need to join the products table. 
118:20 - With order items table. So we can see how many times each product is ordered. 
118:24 - However, in an inner join we will only see the products that 
118:28 - have an order, but here I'm doing an outer join, so, 
118:32 - product number 7, has never been ordered, but still exists in the result. 
118:36 - Is it null, or the quantity? So go ahead and write an outer 
118:40 - join, or use this result. 
118:44 - Alright, first we select 
118:48 - everything from the products table and then 
118:52 - to a left join with the order items table. 
118:56 - Our join condition is p.product 
119:00 - id equals oi.product id. 
119:04 - So because we'll get all the products 
119:08 - in the products table whether this condition is true or not. If you have never 
119:12 - been ordered, you still see them in the result. Now, let's 
119:16 - pick a few columns for clarity. So p.productid 
119:20 - p.name and oi.
119:24 - quantity. That's it. Let's execute the query.
119:28 - We get the same result as before. So all the products are here. 
119:32 - And product number 7 has never been ordered so we see 
119:36 - null for the quantity. 
119:40 - Similar 
119:44 - to inner joins, we can use outer joins between multiple tables. Let me show
119:48 - you. So here's the query that we wrote in the last tutorial, you are doing a 
119:52 - left join between customers and orders tables. 
119:56 - So when we execute this query, you get all the customer 
120:00 - whether they have an order or not. If you have an order you see
120:04 - the order id. Beautiful. Now if you look at the orders
120:08 - table, you can see that some of our orders have a
120:12 - shipper id. These are the orders that have been shipped. So now let's join 
120:16 - orders table with the shippers table to display the name of the shipper in the result. 
120:20 - So back to our query, after this left join, 
120:24 - let's write another join, here I'm doing an inner join. 
120:28 - So let's inner join the orders table with the shippers table. 
120:32 - Join shippers, we call it sh, on 
120:36 - what is the join condition. Well, oh.shipper 
120:40 - id, should be equal to sh.shipper 
120:44 - id. Alright? So in this query we have 
120:48 - a left outer join and inner join. Let's see 
120:52 - what we get, alright, we only 
120:56 - see 5 records. But you have more orders. So here you have the same problem 
121:00 - we have before. Some of our orders don't have a shipper, and that is why 
121:04 - they are not returned here. In other words, this join condition
121:08 - is not true, for some of our orders. So back to the orders table, 
121:12 - a an example, this first order doesn't have a shipper
121:16 - shipper id is null, and that is why it is not returned with a query result. 
121:20 - So to solve this problem, you should use a left join, you want to make sure
121:24 - that all orders are returned whether they have a shipper or not. 
121:28 - So back to the query, you need to replace this inner join 
121:32 - with the left join, so let's execute the query and see what happens. 
121:36 - Now we should have quite a few more orders, there
121:40 - you go, now to make this example more interesting, I'm going to add the ship
121:44 - -per name here. So back to our select
121:48 - boss, let's add a new column, shipper.name. 
121:52 - Now we can give it an alias like shipper
121:56 - let's execute the query and here's the result.
122:00 - So we get all the customers whether they have an order or 
122:04 - not. And for those who do have an order, we get all the orders
122:08 - whether we have a shipper or not. This is the power
122:12 - of outer joins. Now in the last tutorial, you learned that you can get the
122:16 - same result, in both the left join or the right join, you just have to
122:20 - swap the order of the tables. However, as a best practice of what
122:24 - to avoid using right joins, because when you're joining multiple tables and you have 
122:28 - left and right and inner join, things get really complex. So, 
122:32 - someone else reading your code, will have difficulty visualizing how you're joining these tables. 
122:36 - As an example, if you have a right join here and then a left join 
122:40 - after, it will be harder to visualize how these tables are getting joined. 
122:44 - So, as a best practice, avoid right joins, and use left joins 
122:48 - instead. 
122:52 - And, here is your exercise for this tutorial. 
122:56 - I want you to write a query that produces this result. So here you have these columns 
123:00 - order date, order id, the first name of the customer
123:04 - the shipper and we can see that some of our orders are not shipped yet. 
123:08 - So here we have null, and here finally, we have the status. 
123:12 - So go ahead, spend 2-3 minutes on this exercise, when you're done continue 
123:16 - watching. 
123:20 - Alright, let's select everything 
123:24 - from the orders table, now you should join this with
123:28 - customers, on, hold.customerid. 
123:32 - Should be equal to c.customer id. Here I'm using
123:36 - an inner join, because every order does have a customer. So, 
123:40 - this condition is always valid, it doesn't matter if we use a left join or a 
123:44 - inner join here, now, okay? Now before going any further let's 
123:48 - take our columns. So from the orders table, I'm going to pick order id. 
123:52 - Followed by order date. And then, 
123:56 - customer.firstname. 
124:00 - Which we can optionally rename to customer. 
124:04 - Alright, next we need to select the shipper. So, we
124:08 - join the result with the shippers table, 
124:12 - on order.shipperid equal 
124:16 - to shipper.shipperid. However, if we use an inner join here,
124:20 - because some of our orders don't have a shipper, we are only 
124:24 - going to see the orders that have been shipped. Let me show you. So, 
124:28 - for clarity, I'm going to add the shippers name here, so shipper
124:32 - .name as shipper. Let's execute the query 
124:36 - there you go, we only see the orders that have been shipped. 
124:40 - But we want to see all the orders, right? So, we need to 
124:44 - change the second joint to a left join. 
124:48 - So all orders are returned whether they have a shipper or not. 
124:52 - Let's execute the query one more time, 
124:56 - there you go. Now we see all the orders from number 1-10. 
125:00 - Beautiful. Finally, we need to add the status comment here. 
125:04 - So, we need to do another join here, join
125:08 - with order status's, which we aggregate 
125:12 - as os, on oh.status equals 
125:16 - to os.orderstatusid. 
125:20 - We can see that I have designed our database such that sometimes our column names 
125:24 - are exactly identical, but in other cases they don't match. 
125:28 - So in order table we call this column, status, as opposed to 
125:32 - order status id, and this is deliberate because a lot of 
125:36 - real databases are like that. Alright, now let's add
125:40 - the status name here, so order, status.name as
125:44 - status. Execute the query, 
125:48 - and we can see all the orders here, 
125:52 - for each order we have the data, the customer, the supper and the status. 
126:00 - Earlier, we talked about self joins in
126:04 - SQL. So here in the SQLhr database, we have this
126:08 - employees table, we rote a query to get 
126:12 - all the employees and their manager. So here we have this column, reports 
126:16 - to that specifies the manager for each employee. So let's go back
126:20 - and rewrite this query to get all the employees and their manager. 
126:24 - Back to our query editor window, first let's use
126:28 - a SQL hr database. Then select everything 
126:32 - from the employees table,
126:36 - we give it an alias and then join it with itself. 
126:40 - So this is what we call a self join. Now we're going to use a different alias 
126:44 - like m for managers. Now, what
126:48 - is the joint condition e.reports to, should be equal to 
126:52 - m.employee ID, right? 
126:56 - Now for clarity, let's pick only three columns, so either the id 
127:00 - employee.first name. 
127:04 - And m.firstname which we rename to 
127:08 - manager. Alright, let's execute this query and see what we get. 
127:12 - So, here's the result 
127:16 - as you can see all these employees have the same manager. 
127:20 - However, there is something missing here. We don't have a record for this person, this 
127:24 - manager himself. So what is missing is a record where 
127:28 - we can see the employee id for this person, their name and their 
127:32 - manager which should be null because this person is the CEO or the 
127:36 - head of the company. But why is this happening? The reason is, 
127:40 - our inner join, because this condition we have here will only 
127:44 - return people who have manager. We can solve this problem by using a 
127:48 - left join. So, we do a left join, because we want to get every
127:52 - employee in this table whether they have a manager or not. 
127:56 - Okay, now let's execute the query one more time. 
128:00 - There you go. Now we have a record for this person 
128:04 - the manager, as you can see this person does not have a manger, that's why
128:08 - we have null here. 
128:12 - Back to our SQL store database 
128:16 - here we have a simple query that joins the orders table, 
128:20 - with a customers table. And here's our join condition. We have several examples 
128:24 - of this before. Now as our queries get more complex 
128:28 - these joint conditions get in the way, they make our queries hard to read, but the good news 
128:32 - is that in MySQL, we have a powerful feature for simplifying 
128:36 - these queries. If the column name is exactly the same 
128:40 - across these two tables, we can replace the on clause. 
128:44 - With a using clause which is simpler and shorter. 
128:48 - So I'm going to comment out this line and instead type out using 
128:52 - in parenthesis, we type out the column name, that is custom. 
128:56 - customer id. What we have in line 7 is exactly identical to what we have 
129:00 - on line 6. That is shorter and easier to read. So, 
129:04 - let me delete this line. We can add another join
129:08 - statement here to join the orders for the shippers here, so join with 
129:12 - shippers using 
129:16 - shipper id. In both these tables we have a column with the exact 
129:20 - same name. Alright, now let's execute this query 
129:24 - this is what we get, you have the order id followed by the 
129:28 - first name of the customer. Let's add a new column here, 
129:32 - so, I'm going to add sh 
129:36 - .name that is the name of the shipper, 
129:40 - now obviously because some of our orders are not shipped, we have to replace this 
129:44 - inner join to the left join. So we can
129:48 - use the using keyword with both inner and outer joins. Let's execute 
129:52 - the query one more time. There you go. 
129:56 - Now, we have the name of the shipper next to each order, beautiful, 
130:00 - however, we cannot use this technique to join the result with the 
130:04 - order status's table. Because in the orders table we have 
130:08 - this column called status, but in order status's table, this column has a different 
130:12 - name. It's order status id. Let me show you. So, 
130:16 - order status's. columns, there you go, order status id. 
130:20 - So the using keyword only works if the column name is 
130:24 - exactly the same across different tables. Now what if we have multiple 
130:28 - columns in our join condition. For example, earlier we talked about 
130:32 - tis order items table, I told you that in this table we have 
130:36 - a composite primary key, which basically means a primary key that consists 
130:40 - of multiple columns. So the combination of these two columns uniquely 
130:44 - identifies each record in this table. Now if I join this table, 
130:48 - with order item notes table. In our join 
130:52 - join condition, we should compare both these columns with their corresponding 
130:56 - columns in the order item notes table. So let's quickly 
131:00 - write that query and then simplify it with the using keyword. 
131:04 - So, select everything from 
131:08 - order items, now, join it with order 
131:12 - item notes on 
131:16 - so here we need to compare oi.order 
131:20 - id with yn.orderid, and 
131:24 - oi.productid=
131:28 - to oin.productid. This join 
131:32 - condition is kind of messy, it's hard to read this query. Now let's
131:36 - simplify this query with the using keyword. So we type out using. In parenthesis 
131:40 - we add both columns and then separate them using a comma. 
131:44 - So, ordered and product 
131:48 - id. Isn't that better? 
131:52 - Now, for our exercise, back to our
131:56 - SQL invoicing database write a query to select the payment 
132:00 - from the payments table and produce something like this. So in this table we have the date 
132:04 - the client, the amount and the payment method, we can see. 
132:08 - On what date who has paid how much using what payment method. 
132:16 - Alright, I'm going to use the SQL
132:20 - invoicing database, and then select everything from the 
132:24 - payments table, join it with the clients table. 
132:28 - Using client id because in 
132:32 - both these tables, you have the client id table. Next we need to join this with 
132:36 - payment methods, however, they 
132:40 - column name between these two tables is different, so in the payment 
132:44 - table we have a column called payment method. But in payment 
132:48 - methods table, our column is called payment method ID. So here we 
132:52 - cannot use the using keyword, and we'll have to use
132:56 - the on clause. So on p.payment 
133:00 - underline method equals pm. 
133:04 - paymentmethodid. Now let's pick our columns. 
133:08 - So, payment.date client.name. 
133:12 - And we rename this as client, next we pick
133:16 - m out, and finally, the payment method, 
133:20 - so, let's rename that to payment_method 
133:24 - and execute the query, there we go, this is what we get. 
133:28 - The date, the client, the amount, and the payment method. 
133:36 - In MySQL, we also have another 
133:40 - simpler way, to join two tales, it's called a natural join, and it's
133:44 - easier to code, but it's not something to recommend, because sometimes it produces unexpected
133:48 - results. But let me quickly show you how it works in case you see it somewhere
133:52 - so at least you're familiar with it. So back to the previous example, 
133:56 - let's select everything from the orders table, that
134:00 - we should do a natural join with the customer's table. 
134:04 - Now with this natural join, we don't exactly specify the column name. 
134:08 - So the database engine will look at these two tables and it will join 
134:12 - them based on the common columns. The columns don't have the same 
134:16 - name. And that is the reason this query is shorted right. 
134:20 - So, for clarity, let's pick a couple of columns here, o.order 
134:24 - id and c. let's say first name. 
134:28 - Let's execute the query, there you go. 
134:32 - so we see all the orders and the customers replace them. 
134:36 - So natural joins are really easy to code but they can 
134:40 - be a little bit dangerous, because we're letting the database engine 
134:44 - guess the join, you don't have control over it. For this very reason, 
134:48 - natural joins can produce unexpected results, and that's why
134:52 - I discourage you to use them. 
134:56 - In this tutorial, 
135:00 - were going to look at cross joins in SQL. We use cross joins to
135:04 - mine or join every record from the first table, with every record, 
135:08 - in a second table. Here is an example, let's select 
135:12 - everything from the customers table to 
135:16 - now here we do a cross join with the products table. 
135:20 - So every record in the customers table, will be combined with 
135:24 - every record in the products table. And that is why we don't have 
135:28 - a condition here. Okay? So this is what we call a cross join 
135:32 - now for clarity let's pick a couple of columns like
135:36 - see that first name we rename it as customer
135:40 - and then product.name which we rename to 
135:44 - product. Also, let's sort the result 
135:48 - by customer. first name. 
135:52 - Now, let's execute the query, here's the result of the cross join, 
135:56 - so first we have amber as the customer, and here are all
136:00 - combinations of amber with different products. 
136:04 - Next we have Barbara or whatever it is, and again we have the combination of this custom 
136:08 - with all the products. Now in this particular example, it doesn't really make
136:12 - sense to use a cross join, a real example for using 
136:16 - cross join is where you have a table of sizes like small, 
136:20 - medium, large, and a table of colors, like red, blue, green whatever. 
136:24 - And then you want to combine all the sizes with all the 
136:28 - colors. That is when you use a cross join. 
136:32 - Wha we have here is called the explicit syntax for cross join, you also
136:36 - have the implicit syntax which looks like this. Instead of typing out
136:40 - the cross join, you type out multiple tables in the 
136:44 - from clause. So customers and orders. 
136:48 - Both these queries produce the same result. But I personally prefer to use 
136:52 - the explicit syntax because it's more clear. 
137:00 - And here's a simple exercise for you. Do a cross join between shippers and 
137:04 - products. First do it using the implicit syntax, 
137:08 - and then using the explicit syntax. It's pretty straight forward, I just want you to 
137:12 - get your hands dirty in the code and get used to this syntax. 
137:20 - Alright, first I'm going to use the explicit syntax, and then I'm going to
137:24 - place the syntax. So let's start by selecting everything from 
137:28 - 2 tables, shippers and products, 
137:32 - now for clarity I'm going to pick two columns, shipper.
137:36 - name which we rename to the shipper. And product.name which we 
137:40 - order everything by 
137:44 - shipper
137:48 - Let's execute the query, this is what we get. So the combination of all shippers
137:52 - and all products beautiful,  now let's use the 
137:56 - explicit syntax, so we select everything from the base table, 
138:00 - in this case shippers and then do a cross join with products. 
138:04 - That produces the same exact result. 
138:12 - We covered everything about joins, you learned 
138:16 - that with joins we can combine columns with multiple tables, but 
138:20 - in SQL we can also combine rows with multiple tables, and this
138:24 - is extremely powerful. And let me show you how this works. First we have 
138:28 - a quick look at our orders table, and select everything from the order 
138:32 - table. Now if you look at the data, 
138:36 - we can see that the first order was placed in the current year, 
138:40 - 2019, all the other orders were placed in previous years. Now
138:44 - let's say you want to create a report, get all the orders, and next to each order, 
138:48 - add a label. If the order is placed in the current year, the table is 
138:52 - going to be active, and if the order is placed in previous years, you want to label it 
138:56 - as archives. So, let's change our 
139:00 - query and change our condition here. First you want to get all
139:04 - the orders in the current year. So where order 
139:08 - date is greater than or equal to 2019, 
139:12 - 0101. Now I just want to highlight that this is 
139:16 - not the ideal way to get the orders in the current year, because here we have hard 
139:20 - coded 2019. So if you execute this query next year, we are not 
139:24 - going to get the right result. But don't worry about this for now. Later in the course I will show you how to 
139:28 - get the orders in the current year, without hard coding a date here. 
139:32 - So, let's execute this query, now we get 
139:36 - only one order. Let's hand pick a couple of columns here. 
139:40 - So, order id, 
139:44 - and order date. And also I want to add a string, 
139:48 - literal here, like active. Right? 
139:52 - Let's execute this query, this is what we get. We get 3 
139:56 - columns, order id, order date, and active, and in this column, 
140:00 - argument we have this string value. Active. Now let's
140:04 - rename this column to status, alright?
140:08 - And execute the query, that is better, 
140:12 - now we want to write another query similar to this that will return the order 
140:16 - in the previous year, but with a different label, archive. 
140:20 - So, to save time, I'm going to copy this
140:24 - few lines and paste them right after our first
140:28 - select statement. Now note that here we have a syntax error, because we didn't 
140:32 - terminate the first select statement with a semi colon, but don't
140:36 - worry about it, we're going to get back to this in a second so for the second 
140:40 - query, we want to return a different a different label, archive, and we want 
140:44 - to change our condition to less then 
140:48 - 2019. Now, select only these few lines. 
140:52 - And execute this query, either by clicking on this icon here, 
140:56 - or using the keyword shortcut you learned earlier in the course. 
141:00 - There you go, here are all the 
141:04 - orders from the previous year, with the label archive. 
141:08 - This query returns 9 records. The previous query returned 1 record. 
141:12 - now using the union operator we can combine data from
141:16 - these two queries, so, in between 
141:20 - our select statement we type out union 
141:24 - now let's execute the query one more time, so here's our first 
141:28 - order in the current year that is active and below that we have 
141:32 - the orders in the previous years. So using the union operator we can combine
141:36 - records for multiple queries. Now in this example, both our queries are
141:40 - against the same table, but we can also have queries against different 
141:44 - tables and then combine the result into one result set. 
141:48 - Let me show you another example. So I'm going to delete everything here.
141:52 - Let's select the first name, 
141:56 - from the customers table, and then we can union that with select 
142:00 - the name from the shippers table. 
142:04 - Let's execute the query's in one result set
142:08 - we can see all the customers and the shippers. Now as far as 
142:12 - I know, there is no real world care for this particular query. But what I
142:16 - Want to point out is that with union we can combine results from multiple 
142:20 - query's. These query's can be against the same table or different 
142:24 - tables. In your database, you can have a table like archive
142:28 - orders, and another table like order 
142:32 - and then you could combine all the archive and active orders into one 
142:36 - result set. Just remember, that the number of columns that the query 
142:40 - returns should be equal, otherwise you're going to get an error. For example, 
142:44 - let's select the first name and last name from customers 
142:48 - and then union that with the name of 
142:52 - shippers. When we execute this query, we get an error, because the first part 
142:56 - of this query returns two columns, but the second part returns one column. 
143:00 - So MySQL doesn't know how to combine these records. 
143:04 - And one last thing before we finish this tutorial. If you look at the result here, 
143:08 - the name of this column is based on this
143:12 - first query, so the first query returns first name, and that's why this column is called 
143:16 - first name. If you change the order of these queries, 
143:20 - and move this union up here, now let's run this query 
143:24 - as you can see our column is called name. 
143:28 - So whatever we have in this first query is used to determine the name of 
143:32 - columns. Here we can also rename the column to full name. 
143:36 - There you go. 
143:44 - Here's your exercise for this tutorial. Write a query for this report. 
143:48 - So here we have four columns, customer ID, points, and 
143:52 - title. Now as you know we don't have this column in the customers table, 
143:56 - so we have calculated the values of this column, based on 
144:00 - the points each customer had. If they have less then 2,000 points, 
144:04 - their type is bronze. If they have between 2,000 and 
144:08 - 3,000 points they are silver customers, and if they have more then 
144:12 - 3,000 points, they are gold customers. Also note that here we have sort 
144:16 - the result by the first name. So go ahead and spend
144:20 - two minutes to write this query. 
144:24 - Alright, first let's get the bronze customers, 
144:28 - so select everything from customers where 
144:32 - points is less then 2,000. 
144:36 - Now here we want to pick 3 columns, customer id, 
144:40 - first name, end points. And finally we 
144:44 - add a new column to a string literal, bronze 
144:48 - let's run this query and see what we get. So these are all the bronze 
144:52 - customers, but the name of this column in bronze, we don't want that.
144:56 - So, let's rename this to type. Now this is off the screen so 
145:00 - I'm going to break this up into multiple lines 
145:04 - that makers our query bigger and easier to read. 
145:08 - There you go, let's run the query one more time, now the column is called type. 
145:12 - Beautiful. Now we should do union 
145:16 - and repeat this query, but extract the silver customers. 
145:20 - So I'm going to paste this query here and then make a 
145:24 - couple of changes here, I'm going to replace bronze with silver, 
145:28 - and change the condition to between 2,000 
145:32 - and 3,000 let's run our query, see what we get 
145:36 - so, we have all the bronze customers first, 
145:40 - followed by all the silver customers. So the order of these records is based 
145:44 - on our queries. In our first query we got the bronze customers, which is why 
145:48 - they are listed first. But this is not what we want. You want 
145:52 - to order the result by the first name of our customers. So, 
145:56 - let's apply an order by at the end
146:00 - so order by first name. Now there is one more piece remaining. 
146:04 - You should do a union one more time and write a query to get 
146:08 - the gold customers. SO I'm going to select these few lines. 
146:12 - And paste them here. 
146:16 - Now let's change silver to gold, 
146:20 - and the condition to (?) greater then 3000. 
146:24 - And finally we do an imported by. Let's run the query one more time. 
146:28 - And here's the end result, our customers 
146:32 - are sorted by first name, bronze, silver and
146:36 - gold customers. 
146:40 - In this section I'm going to teach you how
146:44 - to insert, update, and delete data. Before we get started 
146:48 - let's have a closer look at our customers table. So click on 
146:52 - this middle icon to open this table in the design mode. 
146:56 - What you see here might look a little bit intimidating at first, but trust me 
147:00 - it's so easy, and in this tutorial, I'm going to explain exactly what we have in
147:04 - these columns. So on the left side, you can see the column 
147:08 - next to that you can see the data type for each column, so our customer id column 
147:12 - can only accept integer value. Integers are whole numbers
147:16 - like 1234 and so on. You don't have decimal points, etc. 
147:20 - First thing is a var chart which is short for variable 
147:24 - character. And in parenthesis, you can see 50, that basically 
147:28 - means in this column you can have a maximum 
147:32 - of characters now if the name of a customer is only 5 characters long the only 
147:36 - store those 5 characters. So even though the max 
147:40 - length for this column is 50, you're not going to waste the space if this customer 
147:44 - name is less then 50 characters. That is why here we have 
147:48 - 4char which is short for variable. In contrast we have 
147:52 - another data type that is character. If you had character 50 here, 
147:56 - and the name of the customer was only 5 characters long, MySQL 
148:00 - will insert additional 45 spaces to fill this column. 
148:04 - So this is a waste of space. So as a best practice, 
148:08 - Most oft he type we use var char to store strings 
148:12 - or textural values. Now here on the right side we have this column 
148:16 - pk, which is short for primary key. So customer 
148:20 - id is marked as the primary key, and that is why we have this yellow key here, 
148:24 - so the values in this column uniquely identify each 
148:28 - customer. Next to that we have nn which is short for not null
148:32 - and that determines if this column can except null values or not. 
148:36 - In this case, every customer record, must have the customer id. 
148:40 - First name, last name, as well as these other attributes. 
148:44 - But birthdays and phone are optional. So in these columns we 
148:48 - can have null values, Now we have another calling here, ai, 
148:52 - which is short for auto increment and this is often used 
148:56 - with primary key columns, so every time we insert a new 
149:00 - record in this table, we let MySQL or our database engine insert 
149:04 - a value in this column, so essentially it gets the customer id 
149:08 - for the last row, and it will increment it by 1, by the time
149:12 - you serve a new record. So if you look at the data you can 
149:16 - see that currently we only have 10 customers here. So if you have a new customer here, 
149:20 - MySQL will sign 11 to the new customer, okay?
149:24 - And finally here we have another column that specifies 
149:28 - the default value for each column. For example, for birthday 
149:32 - and phone columns, the default values or null, 
149:36 - So if you don't supply a value MySQL will supply the null values 
149:40 - for these columns. Similarly we have another null value, 
149:44 - for the points column, so if we don't supply the points for a customer, MySQL
149:48 - will use 0, now we have a few other columns here which are not important 
149:52 - at this stage, you will learn about them later in this course. So now 
149:56 - you understand the attribute of each column, let's go ahead 
150:00 - and insert data into this table. 
150:04 - In this tutorial, 
150:08 - you're going to learn how to insert a row into a table. For that we're going to use 
150:12 - the insert into statement. Where are we going to 
150:16 - insert this row? Into the customers table, so we type out 
150:20 - the name of the table here followed by the values clause. 
150:24 - And here in parenthesis we supply the values for every 
150:28 - column in this table, so back to our table definition, 
150:32 - these are all the columns, first we need to supply a value for the customer id 
150:36 - column. However, in this column, the auto increment 
150:40 - attribute is enabled, and as I told you before, if we don't supply a value, 
150:44 - MySQL will generate a unique value for us. 
150:48 - So we can go back to our statement and either assign 
150:52 - an explicit value or use default to let MySQL 
150:56 - take care of generating this value. This is the preferred approach. Because if we use this value 
151:00 - an explicit value like 200 it is possible that you might have 
151:04 - another customer with the same id. So when you execute the statement, you're going to get an error. 
151:08 - Because you cannot have duplicate values in this column. Every value
151:12 - should be unique, so here we're going to use the default keyword to let you generate
151:16 - a unique value for the customer id, and after that we need to 
151:20 - supply a value or the first name and last name columns. 
151:24 - So, let's say Jon Smith. 
151:28 - Note that I have enclosed these values with quotes, because as I have told you, 
151:32 - string and for in SQL, we should always enclose string and
151:36 - values with quotes. Either single or double quotes, okay? 
151:40 - Now, what else? Back to our customer table, 
151:44 - after the last name you have birthdate, however, 
151:48 - as we can see, this column is optional because this check box is not checked. So 
151:52 - here we can use null or an explicit value. Null means the absence 
151:56 - of a value. So back t our statement, you can type out 
152:00 - the birthdate, like 1990 January 1st or 
152:04 - you can use the null keyword to leave out this value. 
152:08 - Now in this demo, I'm going to use a value date, 
152:12 - now to make this code cleaner and more readable, I'm going to break it up into 
152:16 - multiple lines. That's better, 
152:20 - now back to our table, next we have phone and phone is 
152:24 - also optional, because this checkboxes not checked, and null is the 
152:28 - default value for this column. So here we can explicitly pass 
152:32 - null, or use the default keyword and then put null into this 
152:36 - column. It's exactly the same. So, back to our 
152:40 - statement, you can pass null or default. 
152:44 - Both these keywords will have the same result. In this case I'm going to use the null 
152:48 - keyword. Alright, let's have one more look at our table, 
152:52 - next we have 4 more columns that are 
152:56 - required, so address, city, state, and points. And note that points 
153:00 - has the default value of 0, so we can either use an explicit value like 
153:04 - total value like 200, or use the default keyword and let MySQL generate
153:08 - 0. So, back to our statement, let's type out 
153:12 - an address, it doesn't really matter. 
153:16 - Followed by a city, and a state, let's say california, 
153:20 - and finally points, again we use explicit value 
153:24 - or default, so this is how we can insert a row into 
153:28 - a table. However, in this example, you're only 
153:32 - supplying values for first name, last name, birthdate and 
153:36 - these address fields. So you're leaving out phone number 
153:40 - the customer id and the points. So there's another way 
153:44 - to write the statement. Let me show you. So after the table name you can 
153:48 - optionally supply the stuff columns that you want 
153:52 - to insert values into. In this case first name, 
153:56 - last name, birthdate 
154:00 - and once again I'm going to break up this statement into multiple lines 
154:04 - So 3 more columns, 
154:08 - address, city, and state, 
154:12 - so these are the 6 columns that we're going to supply values
154:16 - for. With this change, we don't have to use these default 
154:20 - or null values, we only supply values for these columns. 
154:24 - So I'm going to remove default from here, and null, and finally 
154:28 - this last default keyword. 
154:32 - So, the 6 values that you supplied here are used for the 6th column. 
154:36 - Now with this change, you can also reorder the columns. 
154:40 - We don't have to list them in the same order, they were defined 
154:44 - in the customers table, for example you can put the last name first, 
154:48 - and then obviously we should also swap the order of these values, 
154:52 - so we can list them in any orders. Now we can execute 
154:56 - the statement, now if you look at the output window 
155:00 - down on the bottom you should see the statement followed by one rows 
155:04 - unfortunately I cannot resize this window to show you this message, but if you look down
155:08 - below you can see that one word was affected, which basically means 
155:12 - one record was inserted into this table. Now, 
155:16 - let's look at the data in the customers table 
155:20 - so the last row is the one that we inserted, we can see that the 
155:24 - MySQL automatically generated the value 11, this is the effect 
155:28 - of auto increment attribute. So it takes the value of the last row, 
155:32 - and incrememnts it by 1. So here we have the first name. Last name, 
155:36 - birthdate, you didn't supply a value for the phone attribute, so, 
155:40 - that's why we have null here, we also have address, city 
155:44 - state, and the default value of 0 for the points. 
155:52 - In this tutorial, you're going to learn how to 
155:56 - insert multiple rows in one go. For this we're going to use the shippers 
156:00 - table, let's have a quick look at the table definition 
156:04 - so here we have 2 columns, shipper id and name. Shipper id is 
156:08 - primary key, it's not nullable, and it's an auto incremented 
156:12 - column. So we're going to let MySQL generate values for this column. Easy. 
156:16 - You only need to supply a value for the name column. So back to our 
156:20 - query editor window, we type out insert 
156:24 - into shippers in parenthesis we specify the name of the column 
156:28 - we want to insert values into, in this case name 
156:32 - followed by the values clause. Here we add a pair of 
156:36 - parenthesis with a value like shipper one. Now
156:40 - insert multiple rows all you have to do is insert a comma 
156:44 - followed by another pair of parenthesis. So, 
156:48 - shipper 2, one more time, comma, shipper 3, 
156:52 - this is how you can insert multiple rows in 1 row, 
156:56 - now let's execute this statement, alright, 
157:00 - and then inspect the data in the shippers data. 
157:04 - There you go. So initially we only had
157:08 - 5 shippers and here are the 3 new shippers that we inserted. Note that MySQL 
157:12 - automatically generated the values for the shipper id column. 
157:16 - So we have 67 and 8. 
157:20 - Alright, here's your exercise
157:24 - for this tutorial. Write a statement to insert three rows 
157:28 - in the products table, it's really easy you can knock it out in a minute, 
157:36 - So here's our products table, we only have 4 columns, 
157:40 - we're going to leave out the first column because it's an auto increments  column 
157:44 - so we only have to supply values for name, quality, unit price. 
157:48 - Back to our query editor window, let's insert 
157:52 - into products the columns are 
157:56 - name, quanitty in stock, and unit 
158:00 - price. And the values are going to be let's say product 1, 
158:04 - stock is going to be 10 and the unit price is going to be 1, 
158:08 - .95. Now I'm going to select these values.
158:12 - copy, paste it, like this, 
158:16 - change the values accordingly, and 
158:20 - finally the last row for the 3 
158:24 - there you go, let's execute this statement, alright 
158:28 - and then verify the result so
158:32 - in the products table, now we should have 3 new records, 
158:36 - now the id's you see here are 15, 16, and 17. 
158:40 - Because before recording this video I actually inserted a few records in this table and then 
158:44 - deleted them. So I had product ID's 11, 12
158:48 - 13, and 14. And even though they're actually deleted from 
158:52 - this table, MySQL remembers their id's so instead of incrementing 
158:56 - 10 x 11, it incremented 14 which is the last record 
159:00 - from before. And that's why you generated 15. On your computer, 
159:04 - the items are going to be 11, 12, 13. 
159:12 - So far you have only learned how to insert data into a singular table. 
159:16 - In this tutorial, I'm going to show you how to insert data into multiple tables. Here's 
159:20 - a really good example, look at the orders table, what columns do we have? 
159:24 - We have the order id, we have the customer 
159:28 - id, so we know who has placed the order, we know the date of the order, 
159:32 - you know the status, comments, as well as shipping 
159:36 - information, but the actual items for this order are not in this table, they 
159:40 - are in the order items table. So in this table, we have 4 columns 
159:44 - we have the order id, so we know what order these items 
159:48 - for. We have the product id, so we know what product 
159:52 - order, in what quantity, and in what price. So an actual 
159:56 - order can have 1 or more order items. 
160:00 - This is what we call a parent child relationship. So this relationship 
160:04 - the orders table is the parent, and the order items table is the 
160:08 - child. So one row in the orders table can have 1 or more children 
160:12 - inside the order items table. Now in this tutorial, I'm going to show you 
160:16 - how to insert an order and all it's items. So you will learn 
160:20 - how to insert data into multiple cables. alright, back 
160:24 - to our query editor window. First we need to insert the order, 
160:28 - so insert, into, let me close 
160:32 - the navigator panel, we want to insert a record into the order 
160:36 - table, now what columns do we have here?
160:40 - So we have these columns but only the first four are the 
160:44 - and actually the first one, we don't want to worry about, because that's an auto increment column. 
160:48 - So we only want to supply values for customer id, order date, 
160:52 - and status. So back to our query, specifying those
160:56 - columns here, customer id, order date, 
161:00 - and status, now let's supply the value. 
161:04 - In the customer id column, we need to add a 
161:08 - valid customer id. So let's have a quick look at our customers 
161:12 - table, there you go. In this table, 
161:16 - we have 11 records. So these are the valid customer id's. 
161:20 - Now back to our query, let's use 1 for customer query 
161:24 - and then 2019, January the 2nd 
161:28 - for the order date, and one for the order status, once again 
161:32 - in this column, we need to insert a valid order status 
161:36 - id. If you don't supply a valid id, MySQL is going to get
161:40 - ahead of us. So we insert an order here, 
161:44 - the items, now back to our order items table, 
161:48 - in this table, we have this order id column, so here's the 
161:52 - as soon as we insert an order, MySQL is going to generate 
161:56 - an id for our new order now we need to access that id in 
162:00 - order to insert the items in this table. How can we do that? 
162:04 - Well, back to our query editor window, 
162:08 - in MySQL, we have a bunch of built in functions, and a function 
162:12 - is basically a piece of code that we use ourself. Just like a function is a feature 
162:16 - in your tv. Every tv comes with a bunch of functions like 
162:20 - power on, power off, change the volume, change the channel so on. 
162:24 - So MySQL and other database engines come with a  bunch of built in functions 
162:28 - that we can use in our programs. One of these funcitons
162:32 - is last insert id. We can call or 
162:36 - execute this function, by adding parenthesis here, and this will return the ID 
162:40 - that MySQL generates when we insert a new row. 
162:44 - So, before going any further, let's just select these, 
162:48 - and make sure you get the right result. Now we have a syntax error here because we didn't terminate 
162:52 - the first statement with a semi colon, alright, now let's execute this query, 
162:56 - alright, so the id of the new order is 
163:00 - 12. Let's verify that. So back to the orders 
163:04 - table let's look at the data. On my machine I have 
163:08 - 12 records here, I actually created 1 just before recording this video, so on your 
163:12 - machine you're going to have 11 orders. 
163:16 - Now back to our query window now that we know how to  get the id of the newly inserted 
163:20 - record, we can use that id to insert the child records. 
163:24 - So, we're going to write another insert statement, 
163:28 - insert into order items, let's have 
163:32 - another look at the columns in this table. So we have 4 columns 
163:36 - on all of them are required, so there's really no need to specify the column name 
163:40 - in our insert statement, you simply supply values or order id, 
163:44 - product id, quantity and unit price. So, here 
163:48 - in the values clause, we add parenthesis, 
163:52 - what is our order id? That is the value returned 
163:56 - from calling this function. So I'm going to cut this from here and 
164:00 - next we need to supply a valid photo id, 
164:04 - but let's say product 1, quantity, let's say 1. 
164:08 - And the unit price 2.95 dollars. 
164:12 - Now let's delete this select we don't really need it anymore 
164:16 - let's add another set of values, so once again, we're going to call
164:20 - last insert id, to get the id of a new order, we're going to 
164:24 - change the product to product number 2, and add a different price. 
164:28 - That's it. Now let's execute this 
164:32 - statement and see what we get. Alright, so, 
164:36 - back to our orders table, let's refresh the records here, alright 
164:40 - so we have a new order, order number 13, 
164:44 - beautiful, now let's look at the orders items table, here's the order
164:48 - items, let's open the table. So we should have 
164:52 - 2 items, or order number 13. Beautiful. 
164:56 - So this is how you insert hierarchical data in SQL. 
165:04 - In this tutorial, I'm going to show you how to copy data from one 
165:08 - table to another. For example, in our orders table, currently we have 
165:12 - about a dozen records. Now let's say we want to create a copy of this table 
165:16 - called orders archive and you want to insert every row that we have 
165:20 - in this table into that new table. If you have 10 orders, 
165:24 - we don't want to quote an insert statement with a ten set of values, 
165:28 - that is very time consuming, so I want to show you a powerful technique to 
165:32 - uniquely copy data from one table to another. First we need to create this new table, order 
165:36 - archive. For that we're going to use the create 
165:40 - table as statement. So create table 
165:44 - orders archive as. 
165:48 - Now right after that we write a select statement 
165:52 - to get everything from the orders table. 
165:56 - Now let's see what happens when we execute this query, there you go.
166:00 - So back in the navigator panel, we have to refresh this view
166:04 - by clicking on this icon over here, now we 
166:08 - have a new table, orders archive, let's look at the data, 
166:12 - so you can see all the orders are here and we have the exact same column 
166:16 - as the orders table. However, if you open this table in the 
166:20 - design mode, you cans ee that in this table, we don't have a primary key. 
166:24 - So the order id column is not marked as a primary key. 
166:28 - And also it's not marked as an auto increment column, so when we create a table
166:32 - using this technique MySQl will ignore these attributes, 
166:36 - and that means if you want to explicitly insert the record 
166:40 - into this new table, you have to supply a value for order id, 
166:44 - because this column is no longer an auto increment column. 
166:48 - So, using create table as statement you can quickly create 
166:52 - a copy of a table, now we refer to this select statement 
166:56 - as a sub query, so a subquery is a select statement 
167:00 - that is part of another SQL statement. 
167:04 - Now we can also use a sub query and an insert statement and that is a very
167:08 - powerful technique. It allows us to do really cool things. Let me show you. 
167:12 - So first, let's right click the orders archive table, 
167:16 - and click on truncate table, because we want to delete 
167:20 - all the data in this table. Alright, it's asking for confirmation 
167:24 - let's truncate the table, so now back to this table. 
167:28 - Let's refresh the table, we don't have any records here, alright? 
167:32 - Now back to our query editor, let's say you want to copy 
167:36 - only a subset of records from the orders table into this table, 
167:40 - like all the orders placed before 2019. So first let's select 
167:44 - everything from the orders table where 
167:48 - order date is less then 2019, January 1st. 
167:52 - So, these are all the orders, order
167:56 - s
168:00 - copy these orders into he orders archive table. So
168:04 - we can use this select statement as a subquery  
168:08 - in an insert statement, we write insert 
168:12 - into orders archive 
168:16 - now we don't need to supply the column names, because we're going to 
168:20 - play values for every column that we have in this query. 
168:24 - So, we did that, and 
168:28 - this is ane xample of using a select statement as a subquery 
168:32 - in an insert statement. Let's execute this, 
168:36 - alright, now back to the table, let's refresh the records 
168:40 - we only have the orders placed before 2019. 
168:48 - Alright, here's a really, really, really coo exercise 
168:52 - back to our SQL invoicing database. Look at the invoices table. 
168:56 - So in this table, we have these columns, 
169:00 - (?) id number, client id number which is associated or related 
169:04 - to the client id column, in the clients table, followed by 
169:08 - a few other columns, now let's say you want to create a copy of the record 
169:12 - in this table, and put them in a new table called invoices archive. 
169:16 - However in that table, instead of the client id
169:20 - column, we want to have the client name column, so you want to join 
169:24 - table with the clients table, and then use that query as a sub query in a create table statement. 
169:28 - Also, to mae the exercise more interesting, 
169:32 - I want you to copy only the invoices that do have a payment. So if 
169:36 - you look over here, this payment data column here, determines 
169:40 - if a payment has been made, towards this invoice or not. So select 
169:44 - only the invoices that do have a payment date, it's a really really good 
169:48 - exercise, spend two to three minutes on this and then come back and continue watching. 
169:56 - Alright, first I'm going to use the SQL invoicing data, 
170:00 - base, now let's select everything from the 
170:04 - invoices table and join it to the clients table. 
170:08 - here I'm going to use the using statement to simplify 
170:12 - my join. What column are we going to use for joining? The client id 
170:16 - column. Let's execute this query up to this point. 
170:20 - Alright, so first we see client id column 
170:24 - is used for joining these tables, after that we have the columns from 
170:28 - the invoices table like invoice id number and so on. Followed by 
170:32 - the columns from the clients table. Name 
170:36 - address and so on. Obviously we don't want all these columns, we only want 
170:40 - the columns from the invoices table but we should replace the client id 
170:44 - column with he client name column. So let's have 
170:48 - a quick look at the design of the invoices table 
170:52 - here we have invoices id, number, 
170:56 - client id, we want to replace this column with the client name. 
171:00 - Back to our query, I'm going to pick, 
171:04 - invoice id, number 
171:08 - and then client.name, let's rename it to client 
171:12 - what other columns do we have here? We have 
171:16 - invoice total and payment total so let's add those as well, 
171:20 - invoice total as well as payment total, 
171:24 - we also have three columns, 
171:28 - for dates, invoice date, due date, and payment date, 
171:32 - so, let me close the navigator panel. Invoice 
171:36 - date payment date and 
171:40 - due date. Now technically because these columns only exist 
171:44 - in the invoices table, we don't have to prefix them with the
171:48 - table alias. So we can simplify the code like this, however, 
171:52 - I personally prefer to prefix them, because that gives me a clear 
171:56 - picture of how I'm joining these tables. It's just a personal preference 
172:00 - another developer might disagree and that's fine, so whatever you prefer.
172:04 - That's perfectly fine, let's execute the query and make sure 
172:08 - we get the right result, so we have the invoice 
172:12 - ID  number client beautiful, followed by these other 
172:16 - columns, now I want to filter the result, and return 
172:20 - only the invoices that do have a payment. So we can either 
172:24 - return records that have a payment date, or the records that have 
172:28 - a payment total of greater then 0. Both are perfectly 
172:32 - fine, so back to our query, 
172:36 - down at the bottom, let's add the where clause, where payment 
172:40 - date is not null. That's better. 
172:44 - Let's execute the query one more time, now we get only these 
172:48 - handful of invoices, beautiful, finally let's use our 
172:52 - query, as a subquery in a create table as
172:56 - statement. So right before 
173:00 - select we type create table, invoices, 
173:04 - archive, as there you go, let's execute 
173:08 - the query beautiful, now back to the navigator panel, 
173:12 - let's refresh the view, so here's our new table, 
173:16 - invoice and archive, let's look at the data, there you go. 
173:20 - You only have the invoices page and here's the name of the
173:24 - client for each invoice. Beautiful. Now just note that 
173:28 - if you execute this query one more time, you're going to get an error because we already have a 
173:32 - table called invoices archive. Later in the course I will show you how 
173:36 - to draw tables, that's pretty easy, but for now you can just right click
173:40 - and go to draw table and then confirm 
173:44 - alright, and then you can run the query one more time. 
173:52 - In this tutorial I'm going to show you how to update data in
173:56 - SQL. So back to our invoices table, 
174:00 - look at the first record here. The payment total for 
174:04 - this record is 0, and obviously there is no payment date. 
174:08 - Now let's imagine that there was a problem int he system that recorded this information. 
174:12 - Let's say the client paid ten dollars for the invoice. So we should update this
174:16 - record in this table. That is very easy, back ti our query editor, 
174:20 - window, we use the update statement to update one or more records
174:24 - in a table. What table? In this case invoices. 
174:28 - Next we add a seth clause and this is where we specify a new value 
174:32 - for one more or columns. In this case we want to update
174:36 - payment total. Let's say to ten dollars. We should also update 
174:40 - payment date. So here's a column to add more columns 
174:44 - we set this to date value, let's say 
174:48 - 2019, March 1st, and then we type 
174:52 - out a condition, with this condition we identify 
174:56 - the record or the records that need to be updated. In this case we want to
175:00 - update the invoice number 1. So, 
175:04 - back to our query, we type out invoice id 
175:08 - equal to 1. Let's execute this. Beautiful, 
175:12 - Now back to our table, let's refresh the data by clicking on this icon. 
175:16 - Alright, we can see that payment total is updated to ten. 
175:20 - And we also have a payment date. Beautiful. Now lets say we actually 
175:24 - updated the wrong record, maybe we should have updated invoice 
175:28 - number 3, so we should update this table one more time, and restore the 
175:32 - original values in this column, back to our query 
175:36 - we can set the payment total to 0, and 
175:40 - the payment date to null. So we can use the null
175:44 - keyword to insert the null value in a column that accepts 
175:48 - null values. Now back to the navigator panel, let's open the 
175:52 - table in the design mode. We can see that the payment total column 
175:56 - has a default value of 0, and the payment date column 
176:00 - has the default value of null. So back in our query 
176:04 - we can also set payment total tod default and MySQL 
176:08 - will use the default value for this column, which is in this case 0. 
176:12 - So, let's execute this statement one more time, beautiful. 
176:16 - Now, back to the table, let's refresh the data, so payment total is set
176:20 - to 0. And payment date is null. Beautiful. 
176:24 - Now let's go ahead and update the third payment. Look at the
176:28 - invoice total. That is $147. For this example let's 
176:32 - imagine that the client made 50% of the total 
176:36 - amount on the due date. So, back to our query 
176:40 - editor window, instead of using a literal value window here like $70
176:44 - we can write an expression, we want to calculate 50%
176:48 - of invoice total. So invoice total, 
176:52 - x 0.5. Now let me break this code into multiple 
176:56 - lines so we can see clearly, now we should 
177:00 - set the payment date, as I told you this client made the payment 
177:04 - on the due date, so we can set this to due date. 
177:08 - Whatever value we have in this column will be used to set the payment date. 
177:12 - Now obviously we need to update the invoice id, 
177:16 - number 3, now back in the table, let's refresh the data. 
177:20 - Alright look, payment total is updated, and it's set
177:24 - to almost 50% of he invoice total. However, 
177:28 - this number is truncated so we don't have the digits after the decimal point. 
177:32 - Don't worry about it for now, we'll come back to this when we talk about data points 
177:36 - later in the course. Also we can see that payment date is set 
177:40 - to the same value we have in the due date column. 
177:48 - In the last tutorial we learned how to update a single record using the updates
177:52 - statement. Now if you want to update multiple records, the syntax is 
177:56 - exactly the same, but the condition you type out here, has to be more general. 
178:00 - For example, back to the invoices table, you can see that we have multiple 
178:04 - invoices for client number 3. You can write a statement 
178:08 - to update all the invoices for this client. So back to our
178:12 - query editor window, we change our condition to, 
178:16 - where client id equals 3. However, if 
178:20 - you execute this statement with MySQL workbench which is the software we've been using 
178:24 - in this course, you're going to get an error, because by default, MySQL workbench 
178:28 - runs in the safe update mode. So it allows you to update only 
178:32 - a single record. You're not going to have this problem if you use another client for 
178:36 - MySQL or if you write this statement in your application code 
178:40 - this is only specific for MySQL workbench. Now
178:44 - let me show you how to get around this. On the top we go to
178:48 - MySQl workbench menu and then preface this. 
178:52 - On this dial up box, on the left side, click on SQL editor 
178:56 - and then down on the bottom, 
179:00 - untick this checkbox, save updates, so this 
179:04 - prevents you from accidentally updating or deleting a bunch of records in a table, 
179:08 - so let's goa head with this, now we need to 
179:12 - reconnect to this instance of MySQL. So, let's copy 
179:16 - all the code here, and close this local instance 
179:20 - window. Alright? Now, on the home page, double click this
179:24 - connection to reconnect, there you go, and then paste 
179:28 - all that Sql code. Now let's 
179:32 - execute this, beautiful, all the invoices for client number 3 are updated. 
179:36 - Here we can also use the in operator, let's say 
179:40 - we want to update all the invoices for clients number 3 and number 4. 
179:44 - So all the operators you learned to use in the where clause also 
179:48 - apply here. Now technically this where clause is optional, so if you want 
179:52 - to update all the records in a table, you simply leave it out. 
180:00 - Alright here's your exercise for this tutorial. Back to our SQL store database, 
180:04 - write a SQL statement to give any customers, 
180:08 - born before 1990, 15 extra points. 
180:16 - Alright first we're going to use SQL 
180:20 - store, then, write an update statement. To update the customers table, 
180:24 - set the points to point 
180:28 - plus 15, so here we're using the expression to update 
180:32 - the points column, for anyone born before 
180:36 - 1990. So where birth date is less then 
180:40 - 1990, January 1st. 
180:44 - Alright, let's execute this query, alright, now 
180:48 - let's open up the customers table one more time, 
180:52 - so anyone who was born before 1990 now has an extra 
180:56 - 50 points. 
181:00 - In this tutorial we're going to learn how to 
181:04 - use subqueries in an update statement, it's extemely powerful, 
181:08 - so we're going to continue with the example from the last tutorial, but we're going to
181:12 - make it more interesting. Here we're updating all the invoices for 
181:16 - client number 3, but what if we don't have the id of the client? We only have the
181:20 - name? For example, you might even have an application, and in that application
181:24 - the user types in the name of the client, so first we should find the 
181:28 - id for that client, and then use that id to update all the invoices. 
181:32 - How do we do that? Well, let's have a quick look at our clients 
181:36 - table, so here we have this client 
181:40 - my words, let's say you have the name, you want to find the id. 
181:44 - So back to our query window. After our update statement 
181:48 - I'm going to write the select statement to select the client id column, 
181:52 - from the clients table, where name equals 
181:56 - my works. Now here we have 
182:00 - a syntax error, because we didn't terminate the last 
182:04 - don't worry about that, we're going to get back to that in a second. Let's just select these few lines and 
182:08 - execute this query. The idea of this client is 
182:12 - 2. Beautiful. Now we can use this select statement as 
182:16 - a subquery in a update statement. So as I told you before, 
182:20 - a subquery is a select statement that is within another SQL 
182:24 - statement. So, instead of hard coding 3 here, 
182:28 - we're going to use this select statement as a subquery, but 
182:32 - we need to put it in parenthesis, so MySQL will 
182:36 - execute this query first, it will return the client ID and then
182:40 - use it in this condition. So for clarity 
182:44 - let's remove the line break and indent 
182:48 - these few lines. So this is the end result. Now 
182:52 - we execute this query, and this updated all the invoices for this client. 
182:56 - Now, what if this query returns multiple clients? 
183:00 - For example, back to the clients table, let's imagine you want to update 
183:04 - the invoices for all clients located in New York or California. 
183:08 - So, we need to update our subquery, 
183:12 - like this, where state 
183:16 - in California, and 
183:20 - New York. Now before executing the entire statement, 
183:24 - let's just select our subquery and execute it to see what we get. 
183:28 - So we get two client ID's, one and 
183:32 - three, beautiful, now because this query, this subquery 
183:36 - returns mutliple records, we cannot use an equal sign 
183:40 - here anymore, so we need to replace this with an in operator. 
183:44 - And now this statement updates the invoices for all the clients 
183:48 - located in these two statements. Let's execute it, 
183:52 - beautiful, everything worked. So as a best practice, before executing your 
183:56 - update statement, run your query to see what records you're going to update. So you don't 
184:00 - accidentally update the records that shouldn't be updated. Now here we 
184:04 - have a subquery but even if we didn't have a subquery, you could still
184:08 - query the records that we're going to update. Let me show you. So let's imagine 
184:12 - we're going to update all the invoices where payment 
184:16 - date is null. Before executing this entire update 
184:20 - statement, I would run a query like this. Select, start 
184:24 - I would start from invoices where payment date is null. 
184:28 - Now let's execute this query, 
184:32 - these are the two records that don't have payment date, so once we're confident that
184:36 - we're updating the right records, then, we come back here, 
184:40 - and get rid of this select statement, and just attach the where clause 
184:44 - to our update statement. 
184:48 - Alright, here's your 
184:52 - exercise for this tutorial, back to our SQL store database, look at the 
184:56 - orders table, as you can see, several orders don't have a 
185:00 - comment, I want you to write a SQL statement to update the comments or orders
185:04 - for customers who have more then 3000 points. 
185:08 - So customers who have more then 3000 points, regard
185:12 - them as gold customers. Find their orders, if they have placed an order
185:16 - update the comments column and set it to gold customer. 
185:20 - That's a really good exercise. 
185:24 - Alright, first we need to find 
185:28 - the gold customers, so select everything from the customers table, 
185:32 - where points is greater then 3000. 
185:36 - And by the way, because current database is SQL invoice 
185:40 - we either have to type out a use statement on the top, or 
185:44 - double click this database before executing this query. So, 
185:48 - there you go. We have three gold customers 
185:52 - now we need to get the ID of these customers to use them in an update 
185:56 - statement. So, we only select customers 
186:00 - Id here and then select this statement as a subquery 
186:04 - in an update statement. So, 
186:08 - update, orders, set comments to 
186:12 - gold customer, where 
186:16 - customer id because we're dealing with multiple customer id's 
186:20 - we need to use the in operator and then to use it, 
186:24 - as a subquery, we need to enclose it in parenthesis. 
186:28 - Let's indent the code, that's better, so here 
186:32 - is the final solution. 
186:40 - So you have learned how to insert and update data, in this lecture, we're going to finish this section 
186:44 - by learning how to delete data. That is very easy. We use the delete 
186:48 - from statement to delete records from a table. 
186:52 - Let's say the invoices table. Now optionally we can add a search condition 
186:56 - to identify the records we want to delete. If you don't write
187:00 - this where clause with this statement, we delete all the records in this table. 
187:04 - And obviously, that's very dangerous, so be very careful when executing this
187:08 - statement. Now here let's say we want to delete the invoice 
187:12 - with the id 1, so where invoice id goes to 1. 
187:16 - Now here we can also use subqueries, let's say we want to delete all the invoices for 
187:20 - the client called my works. First let's 
187:24 - find this client, so select everything from the client's table 
187:28 - where name equals to my works. 
187:32 - Let's execute the second query, so
187:36 - here's our client,  now we can get this client 
187:40 - id and use it in our search condition. So where 
187:44 - client id equals 2, this is where we add
187:48 - our subquery, there you go, just like before, 
187:52 - beautiful. So this is how we can delete data, 
187:56 - in SQL. 
188:04 - Alright, we're done with this section, but before going to the next section, I want you to
188:08 - restore all these databases to their original state. Because in this section we 
188:12 - added some data, we updated some data, we deleted some records, 
188:16 - so if you don't restore these databases you may see different results going forward. 
188:20 - So, restoring these databases is pretty easy. Here in My
188:24 - SQL workbench, on the top go to the file menu 
188:28 - and open SQL script. Then navigate to the directory 
188:32 - where you stored the SQL scripts for this course, in case you lost 
188:36 - that directory, go back to the first section, you have a lecture for downloading the
188:40 - supplementary materials. So in this directory open 
188:44 - create databases.SQL. 
188:48 - Now execute this script to recreate all of our databases. 
188:52 - Alright, beautiful, now let's open up the navigator panel, you can see the 
188:56 - databases disappear from here, simply click on this refresh icon. 
189:00 - Beautiful. Alright, we're done with this section, I will see you in the next 
189:04 - section. Hey guys, Mosh here, 
189:08 - in case you haven't seen my website yet, head over to codewithmosh
189:12 - .com. This is my coding school where you can find plenty of courses 
189:16 - on web and mobile application development. In fact recently I 
189:20 - published a complete SQL course that is about 10 hours long, 
189:24 - and it teaches you everything you need to know from the basic to advanced topics
189:28 - such as database design, security, writing complex queries, 
189:32 - transactions, events and much, much more. These are the topics 
189:36 - that every software engineer must master. This Youtube 
189:40 - course you've been watching is the first three hours of my complete SQL
189:44 - course that is about 10 hours long. So if you want to master SQL 
189:48 - and get job ready, I highly encourage you to get involved in my complete 
189:52 - SQL course. You can watch it anytime, anywhere, as many times as you
189:56 - want, you can watch it online or download the videos. The course comes with 
190:00 - a 30 day money back guarantee and a certificate of completion 
190:04 - that you can add to your resume. The price for this course is $149
190:08 - but the first 200 students can get it for just
190:12 - over $100. So if you're interseted, the link is below this video. 

Cleaned transcript:

Hi, my name is Mosh Hamedani, and I'm super excited to be your instructor. In this three hour course, you're going to learn everything you need to get started with SQL or SQUEL. First I'm going to give you a three minute introduction to SQL, then we're going to install the necessary tools and write our first SQL query. This course is ideal for anyone who wants to learn SQL from scratch, but also anyone with some basic knowledge who wants to fill in the missing gaps. By the end of this course, you'll be able to retrieve insert, update, and delete data in databases. We'll talk about tables, relationships, different types of joints, subqueries regular expressions and much, much, more. These are the essential concepts every software developer or data scientist must know. This SQL course is packed with tons of exercises that help you both learn and remember the SQL syntax. Also, there is a table of content below this video so you can quickly jump to specific tutorials, now let's jump in and get started. Let's start the course with a quick overview of databases, what they are and how we use them. A database is a collection of data stored in a format that can be easily accessed. In order to manage our databases, we use a software application called database management system, or, DBMS. We connect to a DBMS and give it instructions for querying or modifying data. The DMBS will execute our instructions and send results back. Now we have several database management systems out there, and these are classified into two categories, relational and non relational, also called NoSQL. In relational databases, we store data in tables that are linked to each other using relationships. That's why we call these databases relational databases, each table stores data about a specific type of object, like customer product, order and so on. SQL or SQUEL is the language that we use to work with these relational database management systems. It looks like this. We use SQL to query or modify our data. In this course you're going to learn everything there is to know about this powerful language. Now, there are many different relational database management systems, out there, some of the most popular ones are MySQL, SQL Server my Microsoft, and Oracle. But of course, there are plenty more. Each database management system has a different flavor of SQL. But all these implementations are very similar and are based on the standard SQL specification. So most of the SQL code that you will learn in this course will work with any database management system. In this course, we'll be using MySQL, which is the most popular open source database in the world. Okay, now back to this diagram, what about non relational databases? In non relational databases, we don't have tables or relationships, these databases are different from relational databases, but that's a topic for an entirely different course. What you need to know is non relational database systems don't understand SQL. They have their own query language. So, we use SQL to work with relational database management systems. Now, before we jump in and install MySql, let me clarify something quickly, as you talk to different people, you will hear two different pronunciations of SQL. SQUEL, or SQL. What is the correct way? Well, it depends on who you ask, and of course everybody thinks their way of pronouncing this word is the right way. But here's a history about this language. SQL was originally developed at IBM in the 70s and back then it was initially called SQUEL short for structured English query language. But they changed the acronym to SQL, because SQUEL was the trademark of an airplane company. So to this day, there has been an argument about what is the right generally speaking, people in nonEnglish speaking countries call it SQL. I'm used to calling it SQUEL because it's shorter and sweeter than SQL. But if you prefer to call it SQL, that's totally fine with me, I'm not going to get mad at you. So that's the history behind this language. But what about MySQL as a software product? Developers of this product prefer to call it MySQL rather than mySQL. But they don't mind if they call it MySQL. In this course, I'll be teaching you SQL with MySQL. Hey guys, Mosh here. I just wanted to let you know that you really don't have to memorize anything in this course, because I've created a complete cheat sheet with summary notes for you. You can find it below this video in the description box. So I have done my best to create the best possible, most comprehensive SQL course for you, and I would really appreciate it if you would support my hard work by liking and sharing this video. Thank you so much, now, let's continue. In this tutorial, I'm going to show you how to install MySQL on your computer. Now I'm using a Mac, so first I will show you how to install MySQL on a Mac computer, and then I will show you how to install it on Windows. So if you're a Windows user, feel free to skip this tutorial. Now, open up your browser and head over to MySQL.com. Then, go to the downloads page, and scroll down to the bottom. Here you should see MySQL community edition, this is absolutely free, and we're going to use that throughout this course. So let's go ahead and look at that, now on this page, click on MySQL, community server, and then on this page, you should see available releases for Mac OS. So, in this list, download the first item which is a dmg archive. Alright, now, on the next page, click on no thanks, just start my download. Okay, as you can see, we are getting a dmg file, which is basically a setup wizard. Alright, now the DMG is downloaded, so let's open it, and then double click on this package, this will launch an installation wizard which is pretty easy to use, so simply click on continue and again, and again, agree with the license agreement, and install MySQL, it's going to ask for your password, this is the password that you used to log into your computer, so let's put that here, alright, now here we need to set a password to the root for the admin user. So click next, and in this box, type a complex password, alright, now, let's finish the installation, and enter your computer's password one more time, and we are done! That was super easy and sweet. Alright, we installed MySQL community server, now we need the graphical tool to connect with this server and manage our databases. So, back to the downloads page, one more time, scroll to the bottom, and go to MySQL community addition, and on this page, somewhere you should see MySQL workbench. This is a graphical tool that we use to connect to our database server. So let's go ahead and download this as well. Now once again on this page, we need to download a dmg archive, so, download, and, again we have to say no we don't want to login or sign up, so let's go ahead and download the dmg, and then open it, alright, you're going to see something like this, so drag this MySQL workbench and drop it onto the applications folder. So, let's go ahead with that, now it's going to copy this into the applications folder, beautiful, so we're done with the installation, that was super easy, now press command and space, and search for MySQL, work bench, there you go, let's open it, now the first time we get this message, because this is an application we downloaded from the internet. So, we need to tell Mac that we trust this, let's go ahead with that, so this is MySQL workbench, now by default you see a connection here, if you don't see that, you need to create it. Let me show you how to do that. So for this demo I'm going to right click this and delete this connection, alright, now let's create a connection from scratch. So click on this plus icon, on this page, give this connection a name, let's say local instance, now the connection method we're going to use is tcip, which is set by default, the host name is 127.0.0.1, which is the address of the local machine, and the port is 33 06, this is the default port for MySQL server, that is the user name of the admin, now we need to enter the password. This is the password that we set during the installation. So, click on store in keychain, and in this box, type the password for the MySQL server. Alright and finally, let's test the connection, okay, we successfully connected to MySQL server on the local machine, beautiful, let's click okay, and here we have a connection on the homepage of MySQL workbench, every time we open MySQL workbench, we use this connection to connect to our local server. Alright, we're done with the installation of MySQL on a Mac, next I will talk about MySQL on a Windows computer, so feel free to skip that tutorial. In this tutorial, I'm going to show you how to install MySQL on Windows. So open up your browser and head over to MySQL.com, then, go to the downloads page now here, scroll down to the bottom, we're going to use MySQL community edition which is absolutely free. So, let's go with this, now, select MySQL community server, and then scroll down so here you should see something like this, MySQL installer for Windows. This is the recommended method for installing MySQL on Windows. So, click on this, alright, on the next page, scroll down, and download the first installer here. On the next page scroll downs nd click on no thanks just start my download. Otherwise you have to create an account and log, which is unnecessary for knowing this course, so, let's go with this, and save this file to our computer, and then run it. Alright, we're going to use this setup wizard to install MySQL, on our computer. This is very easy, all you have to do is click next, but there are a couple places where you need to enter a password, let me show you. So, on the first page, for the setup type we're going to use the developer default setup. Go to the next page. Now here we're getting a little warning, because this installation wizard wants to install the connector for python 3.7, but I don't have Python on this machine, so that's why I'm getting this warning, now on your machine, you might or you might not get this error, just click next, and one more time, so here are the products that I want to get installed the first one is MySQL server, the second one is MySQL workbench, this is the graphical tool that we use to connect to our database server, and manage our database. You're going to see that soon. So click on execute, now this is going to take about 510 minutes, so, I'm going to pause the recording. Alright, all the products are installed, beautiful, let's go to the next page, and again, here our the group replication page, also click on next, and the next page which is about networking, leave all the default settings, so, let's go to the next page, now we should set a password for the root for the admin user. So, click on next, and in this box, type a password for the admin user. Alright, and then let's go to the next page, once again leave all the default settings, and click on next, and execute one more time, alright, and now let's finish our installation, once again we have to click on next, and then finish. One more time, there are so many steps. Now here's the page where you need to enter the admin password, so the page is called connect to server, you can see the username is root, which represents the admin user, so in this box enter the password that you said earlier, then click on check, okay, connection was successful beautiful, let's go to the next page, and click on execute, and finally finish. There you go, we have one more step, next the finally after all these steps the installation is complete. Now, this is going to start, MySQL workbench, which is the graphical tool we use to manage our database and run SQL queries. So, click on finish, so now we have a command prompt window, where we can type instructions to talk to our MySQL server, we don't really need this, so close it, and here's MySQL workbench, now the first time you open this page, by default you should see a connection here, if you don't see it, click on this plus icon, on this page give this connection a name, let's say local instance, now leave all their settings to their default value, but here for the password click on store involved. And in this box, type the password that you used for the admin user. So, I'm going to put that here, okay, now click on test connection, alright, we successfully connected to the MySQL server on this computer, alright, then, click on okay, now we click on this connection to connect to our database server. Alright, so here's the interface you'll be using throughout this course, on the left hand side we have the navigator panel, in the middle we have the query editor which we can resize this is where we're going to write our SQL queries, and on the right side we have additions. So we're done with MySQL on our computer, next, I'm going to show you how to create our databases for this query. In this tutorial, I'm going to show you how to create the databases for this course. So here I've got MySQL workbench open, let me quickly give you an overview of this interface because the first time you open it it might appear a little bit intimidating. But actually it's not that difficult. So here on the top we have this tool bar with these buttons for creating a new tab for writing SQL code as well as opening a SQL file. And next to that we've got a bunch of buttons for creating a database, creating new tables and so on. On the left side, we've got the navigator panel with two tabs administration and schemas. We use the administration tab to do administrative work, such as starting or stopping our server. Importing or exporting data and so on. The schemas tab shows the databases that we have in the current database server. So currently we only have one database, that is sis, and this is the database that MySQL uses internally to do it's work. Now, in the middle we've got this query editor window, this is where we write our SQL code, so we'll be spending most of our time in this course, in this window, and on the right side we've got another panel with two tabs, contacts held, and snippets, now chances are this interface might look slightly different on Windows, but what I'm showing you here is almost identical to what we have on Windows. So don't get hung up if it looks slightly different on your machine. It doesn't really matter. Now up here, we've got these buttons for showing or hiding these panels, so to clean this interface, I'm going to hide this panel on the right side. As well as the panel on the bottom. That is better. Now, to create the databases for this course, download the zip file attached, below this video. When you extract the (?) you're going to see a bunch of SQL files like this. So the main one you'll be using in this tutorial is called create databases.SQL. So this file contains all the SQL code to create all the databases that we need in this course, now we also have individual files for creating individual databases, I've just added these files in case you need to recreate one of these databases in the future. But for now don't worry about them. Now, back to MySQL work bench, let's open the main SQL file. That is create databases. So this is an example of SQL code. Now this may look complex at the beginning, but trust me, as you go through the course you're going to understand exactly how everything works here. You're going to be able to write SQL code like this. So, you want to execute this, to create all the databases for this course. To do that, we click on this icon, this yellow thunder icon that we have on this tool bar here. This will execute either the selection or the entire code if there is nothing selected for example, if I select this line here, and click on this icon, this will execute only this line. In this case we want to execute the entire code, so we shouldn't select anything, and now let's execute this, beautiful, now here down on the bottom, we have this panel called the output window that shows all the operations perform in our database server, so we can see all the operations completed successfully, or something went wrong. As you can see you've got these green ticks next to each operation. Beautiful, so I'm going to close this panel, that's better. Now on the left side in this schemas tab you don't see this new database so we'll have to refresh this view, beautiful. So we've got all these databases that are prefixed with SQL or SQL, I decided to prefix them with SQL so we know that these are the databases for this course, they don't accidentally clash with a database on the same name of your database server. Now, at the time of recording this video, there are only 4 databases here, but as we go through the course, I'm going to update the script for creating the databases, so, when you watch this course, chances are you're going to see more databases here. Don't worry worry about the difference. Now as an example let's explore these databases. And by the way we don't need this tab anymore so let's close it. That's better. Let's expand the SQL store database, now in every database we have these objects, we have tables, this is where we store our data, we have views, which are kind of like virtual cables, so we can combine data from multiple tables, and put them in a view. And this is especially powerful for creating reports, you're going to learn about them in the future. You also have store procedures and functions, and these are little programs that we stored inside of our database for querying data. For example, you can have a store procedure for getting all the customers in a given city. So we call that procedure and we say hey, give me all the customers in San Francisco And this will return all the customers in San Francisco. Okay, now, let's expand the tables, so here are the tables in this database. We have customers, we have orders, products, shippers and so on. Now, select this customers table whenever you hover your mouse over this item and see these three items on the right side. Click on the right most icon, that looks like a table with a thunder. With this we can see all the data, in this table. So this is our customers table. In this table, we have these columns like customer id which we use to uniquely identify customers. We all have first name, last name, birth date, phone, address and so on. So these are the columns in this table and every row is called a record. So every row represents one customer and these are the pieces of information we know for each customer. Now let's look at another table, let's open the orders table, in this table we have these columns like order ID, customer ID, order date, status, and so on. What is this customer ID here. We use this column to identify who has placed each order. Now what is interesting here is you have referred to this customer using their customer ID which uniquely identifies that. In other words, if Jon Smith has placed an order, we don't store John Smith here, we only store John's customer ID. Why is that? Here is the reason. It is possible John Smith might have placed multiple orders in our system. Now every time John places his order, we need to look up his address and phone to ship his order. Now it is possible that some of this information might change in the future. John might move to a new place or change his phone number, he might even change his name, if you repeat all that information next to each order, then we'll have to come back and make changes in multiple places. In contrast, with this design we only store the ID of john here, so anytime we want to change any information about John, instead of changing that here. We go back to our customers table, so let's look at customer with ID 6, that is actually called (?) So here is all the information about Elka. This is her phone number, this is her address, and by the way this is all dummy data that I created using a tool. So, if any information about elka changes in the future, this is the only place that we need to modify. So this is how these databases work. We refer to these databases as relational databases. That basically means in these kind of databases we have multiple tables that are related to each other using a relationship. So internally there is a relationship between the customers table, and the orders table. So the customer ID column in the customers table is related or linked or associated with the customer ID column. In the orders table. Here's the orders table, and here we have the customer ID column. So this was a brief introduction to relational databases, you learned about databases, tables, columns, rows and relationships. In the next section I'm going to show you how to retrieve data from a single table in this database. But, before going any further as an exercise I want you to explore the invoicing database. Look at the all the tables, look at all the data to get an id of the kind of data that we have in this database. You're going to use this database a lot in the future, so let's spend a couple minutes to explore this database. In this tutorial I'm going to show you how to retrieve data from a single panel. Now look at the navigator panel. Currently none of our databases is displayed in bold, and that means none of these databases are selected for query. So the first step to rate a query to get data from a database, is to select a database. The query that we'll write will be executed against that database. In this demo, we're going to use the SEQUEL store database. So we type our use SQL_ store. Now use is a keyword in the SQL language, and that's displayed in blue. Now SQL is not a case sensitive language, and that means we can use upper case or lower case characters, it doesn't really matter, but as a best practice, we should capitalize the SQL keywords, and use lower case characters for everything else. So now, let's go ahead and execute this query. Alright, Look, the SQL store database is now displayed in bold. Now in MySQL workbench, we can also select a database by double clicking that, so now I double click SQL invoice and it's the current database. Now if we run this query again, the SQL store database becomes selected. Alright, now let's write our first query to retrieve all the customers in this database. So after the you statement we're going to use select statement. Here is the basic syntax or basic structure of the select statement, we type out select in front of that we specify the columns that we want to retrieve, for example we can retrieve the customer ID column as well as the first name column or we can retrieve all columns using an asterisk. Now after that we use the from clause and this is where we specify the table that we want to query, in this case the customer's table. So this is the simplest query to select all the customers in a given table, now whenever you have multiple SQL statements you need to terminate each statement using a semicolon. So, look, we have a red underline here that indicates an error, if you hover your mouse over here, you can see this tool tip saying select is not valid at this position. Because we didn't terminate the first statement with a semi colon. Okay, now let's execute this query one more time, once again, we can click on this button here, or we can use a short cut, so look at the query menu on the top, the first line is execute. Now here's the shortcut for this command, on Mac, it's shift command and enter. On Windows its going to be different honestly I'm not sure. So whatever it is, use that. So I'm going to press shift command enter, and here are all the customers in this table. So this next statement has two clauses, the select clause and the from clause. But there are other clauses we can use to filter and sort data. For example, you can use the wear clause to filter the result and get the customer with ID one. So we can write an expression like this. Where _ID = 1. Now when we execute this query, we'll only get the customer with ID 1. So this is the where clause. We can also sort the data so after wear we use the order by clause and here we specify the columns that we're going to sort the results from on. Let's say we want to sort these customers by their first name so we type out first_name. That is the name of one of the columns in this table, right? Now if you execute this query this order by doesn't really have an impact, because we only get one record in the result so let me temporarily take out the where clause, to do that we can put two hyphens in front of this line, now this line, is treated as a comment, which means the SQL engine is not going to execute this, okay, so let's execute this query one more time, now all the customers that we get our sorted based on their first name. So that's the basic idea. Now over the next few tutorials your'e going to learn more about these clauses in detail. But what you need to take away in this tutorial is that is that these 3 clauses from where an order by are optional. As you can see in this example, I'm not using the where clause, we can also comment out the order by clause, we can also comment out the from clause, so instead of selecting all the columns, in a given table, we can select some values like one and two. Now, if you execute this query one more time, in the result, we get something like this. Two columns called one and two, and in these columns we have these values. So all these clauses are optional but in the real world we quite often use all of them. Now what you need to understand here is that the order of these clauses matter, so we always have select first, then we have from, then where, and finally order by. We cannot change the order of these clauses, otherwise we get a syntax error. Which basically means the syntax, or the grammar or the structure of our simple statement is incorrect. So it cannot be executed. And one last thing before we finish this tutorial, you can see I've listed all these clauses on a new line, now technically you don't have to do this, because line breaks, white spaces and tabs are ignored when executing SQL statements. So we could come back here and put from in front of select, so select store from customers all in one line, and that's perfectly acceptable for simple queries, but as your queries get more complex, it's better to put each clause on a new line. So that's all for this tutorial. In the next tutorial, we'll explore the select clause in detail. In this tutorial, we're going to look at the select clause in detail. So, since our current database is SQL store, to clean things up I'm going to remove the first statement, you don't really need it now, also, I'm going to delete these two comments, we just want to focus on the select clause. Alright, so what can we do with this select clause? Well in the last tutorial we learned that if you use an asterisk, this will return all the columns. Alternatively we can specify the columns that we want and this is helpful in situations where you have a big table with so many columns and perhaps millions of record. If you want to bring back all that data, that's going to put a lot of pressure on the database server, in this case MySQL, as well as the network. So, that's when we explicitly specify the columns that we want to get. Let's say we want to get the first name and last name columns. Execute the query, as you can see, we only get these two columns. And they are in the same order we specified here. So if we change the order and put the last name first and execute the query again, now we can see the last name column comes first. Now let's add a new column, at the end, let's get the points for each customer as well, run the query, so these are the points for each customer which are calculated based on their shopping. Now let's say we want to get these points and put them in a mathematical formula to calculate the discount that we can give to each customer. So here we can use an arithmetic expression, that's points plus ten. This is an arithmetic expression. So now we can execute this query for the first record you can see that their points will end up being 2283. Let's run the query one more time there you go. Now we can put the original points column here for clarity. So points, points plus 10. Let's run the query one more time, now you can see the original points, and next to that you can see the value that we're going to use to calculate the discount. Now here we're using the plus operator which is for addition, we also have multiplication, division, subtraction, and module which is the remainder of the division. So let's change this to something more complex. Let's say we want to get the points, multiply by 10, and then add 100 to it. Now we can immediately see that this line one is getting too long and it doesn't fit on the screen, in situations like this, you can break up the select clause by placing each column on a new line, so, select last name, then first name points finally points times 10, plus 100. So let's execute this query one more time. So this is our new column with the new calculated value. Now one thing you need to understand in this arithmetic expression is the order of operators, and this is based on the order of operators in math. So in math, the multiplication and division operators have nighter precedence then addition and subtraction, so in this expression, points is multiplied by 10 and then the result is added to 100. If this is not what you want you can always change the order by using parenthesis, as an example, let's change this multiplication to addition and then put that multiplication here. In this expression, first 10 is multiplied by 100, and then the result is added to the points. Now let's say this is not what we want, so we can change the order by using parenthesis here. With these parenthesis, first we get the points add 10 to them and then multiply the result by 100. So this parenthesis are useful for changing the order of operations as well as adding clarity to our code. So someone else reading this code can easily understand. the order of these operations. Now let's execute this query one more time, alright, now look at the name of this column here, its set to the expression that we have on line 5. That doesn't quite make sense you want to have a clear descriptive name, so we can give this column an alias using the as keyword. So, as and then we give it a name like discount discount _factor. Let's run the query again. now the name of this column has changed, so this is the benefit of using an alias, we can give descriptive names to the columns and the results sets. Now if you want to have a space in the column name, you need to surround it with quotes, either single, or double quotes. So we put quotes here and then we can add a space in between these two words. Let me execute the query one more time. Now we have discount factor. So let's quickly recap everything you learned about the select clause. We cause an asterisk to return the columns, or we can explicitly specify the columns that you want to return. We can also use, arithmetic expressions here, and optionally, we can even gibe an alias to each column in the results set. Now there is one more thing you need to know about the select clause. So let's delete this query and select the state column, of the customers table. Take a look. These are the states in which our customers our located. Now currently in the sample data we don't have any duplicates, in other words we don't have multiple customer in any of these states. But for this demo I want to change the state of the first customer to Virginia, so we end up with duplicates in the result set. So let's open up navigator panel here's our customers table, let's look at all the data, and here's our first customer, here a you can see, it's located in the state of Massachusetts now I want to change this to Virginia. So double click VA for Virginia, enter, now on the bottom right corner of the screen, you should see two buttons, apply and revert. Unfortunately I cannot show you this button because the recording window is a bit smaller then MySQL But look down in the bottom right hand corner, click and apply. You're going to see a dial up box like this asking you to review the changes, so go ahead and click that button one more time alright, now, let's go back to our first query window, and execute this query one more time. As you can see, the first two customers are located in Virginia. What if you wanted to get a unique list of states in the results set, that's when we use a distinct keyword. So select distinct set. With his query, we'll retrieve a unique list of states from the customers table. So with the distinct keyword we can remove let's execute the query one more time, now you can see Virginia is not duplicated. Alright here's an exercise for you. I want you to write a SQL query to return all the products in our database in the result set. I want to see three columns, name, unit price, and a new column called new price which is based on this expression, unit price times 1.1. So let's say you want to increase the price of each product by 10%. With this query you want to get all the products the original price and the new price. So pause the video and spend one or two minutes on this exercise, when you are done come back and see my solution. Alright this is pretty easy, so we start with select now what columns do we want to select? Name, unit _price and then here we're going to use an arithmetic expression to calculate the new price. So we type out unit price times 1.1 and then give it a alias, o as new_price or we can put this in quotes and put a space between new and price. Now where do we want to select these columns from? From the products table, so from products. Note that I've used upper case characters for all the SQL keywords and lowercase characters for everything else. So, let's go ahead and execute tis query, this is what we get so these are all the products, you can see their original price as well as the new price which is 10 % more expensive. In this tutorial, we're going to look at the where clause in SQL. So earlier I told you that we use the where clause to filter data. For example, let's say we only want to get the customers with points greater than 3000. So here in the where clause you can type out the condition like this. Points, greater than 3000. When we execute this query, the query execution engine in MySQL is going to iterate over all the customers in the customers table. For each customer it's going to evaluate this condition if this condition is true, it will return that customer in the result set. So let's go ahead and execute this, and here's the result, as you can see you only have two customers with points greater than 3000. So, thesis what we call the greater than operator which is one of the comparison operators in SQL. Let me show you the completeness of comparison operators, so, we have greater than, greater than, or equal to, we have less then, less than or equal to, here's the equality operator, and for not equality, we can use an exclamation followed by an equal sign, or something like this. So both of these are not equal operators. Let me show you examples of these operators. So I'm going to delete all these and bring back the previous query, let's say we want to get only the customers in the state of Virginia. So we can change our condition to something like this. Where state equals Virginia. Note that I've put Virginia in quotes, because this is what we call a string. A string is a sequence of characters. So whenever you're dealing with a sequence of characters, or basically textural data, we need to enclose your values with either single or double quotes. But quite often, by convention, we use single quotes so let's execute this query and here's the result, you can see we only have these two customers with ID 1 and 2, who are located in Virginia. And it doesn't matter if you use upper case or lower case characters, so if you type out the a in lower case and execute the query you get the exact same result. Now what if you want to get all the customers outside of the state of Virginia, you can use the not equal operator. So, we can either prefix this with an exclamation or use this other notation. Either way we get the same result. So these are the customers that are not located in Virginia. Now we can use these comparison operators for date values as well. For example, let's say you want to get only the customers born after January 1st, 1990. So we change out condition to first date, greater then, once again we use quotes, for representing date values even though dates are actually not strings. But in the sequel language, we should enclose dates with quotes, so, here we type out 1990, 01 for January, 01 for date. So this is the standard or default format for representing dates in MySQL. 4 digits for the year, two digits for the month, and 2 digits for the day. So let's go ahead and execute this query. I actually made a mistake here, so we don't see the result, instead we see the action output, or the output window. If you scroll to the bottom, you can see the details of the error. So here I used the wrong name for the column, which should separate these two words with an underscore. That is the name of our column. So, let's execute the query one more time, so we only have 3 customers born after January 1st 1990. So these are examples of comparison operators in SQL. In the next tutorial I'm going to show you how to combine multiple conditions when filtering data. Alright, here's your exercise. I want you to write a query to get the orders that are placed this year, so look at the orders table, see what columns to do we have there, and based on that write query with a where clause. So here's the orders table, in this table we have this column, order date. We can use this problem to see the orders that are placed this year so here's our query, select, start from order where order_date, is greater than or equal to 2019, assuming this is the current yer, so 2019, 0101. Now since currently we are in the year 2019, this query will return all the orders placed this year. But next year this query is not going to give us the right result. But don't worry about it, later in the course I will show you how to write a query to get the orders placed in the current year, so for the purpose of the new exercise, this is a valid solution. Now let's execute this query and see what we get. So, we have only one order, order ID 1, that is placed in the current year. In this tutorial I'm going to show you how to combine multiple search conditions when filtering data. So, let's say you want to get all the customers that were born after January 1st, 1990, who also happen to have more then 1000 points. So this is where we use the and operator. So we type out and, and after we type out another condition. Like points, greater than 1000. Now when we execute this query, we only get customers who have both these conditions. Let's take a look, so execute we only have 2 customers and if you look both these people are born after 1990, and they have more then 1000 points. So this is the and operator. When we use this operator, both these conditions should be true. In contrast to the and operator, we have the or operator. So with or if at least one of these conditions is true, that row will be returned in the result set. Let's take a look. Now we execute this query again, 2 records we have quite a few records. So for example, we have this person who's not born after 1990 but if you look at their points they have more then 1000 points. So any customer records that satisfies at least one of these conditions will be returned. Now let's take this to the next level. Let's say we want to get customers who are either born after 1990, or they should have at least 1000 points and live in Virginia so this is how we do this, we type out and and then we add another condition, state equals Virginia. Let's execute this query and see what we get. We only get 4 records, so these are the customers that are either born after 1990 or they have more then 1000 points and live in Virginia. If you look at the first customer here this person is not born after 1990. But you can see that she lives in Virginia and she has more than 1000 points. So the last two conditions. are true for this customer. Now when combining multiple logical operators. You need to be aware of the order of these operators. So earlier I talked about he order of arithmetic operators. I told you that multiplication have a higher order then addition and subtraction. And we can use parenthesis to override the default order. We have the same concept in logical operator So the and operator is always evaluated first. So when this query is executed, the query execution engine first evaluates this condition, because here we're using an and it doesn't matter that we typed out this condition after the first condition. Because the and operator has a higher precedence. Now you can always change the order using parenthesis. And this also makes your code cleaner and easier to understand. So here we can put parenthesis, around these last two conditions, and also we can put these in a new line for clarity. Something like this. So anyone who reads this code can easily understand what is the intent of this query. Now we also have logical operator called not. And we use that to negate a condition. So, I'm going to simplify our where clause. Let's say we're searching for customers who were born after 1990 or we have more then 1000 points. If we execute this query we get these people. Customers with ID 1, 3, 5 and so on. Now we can use the not operator to negate this condition. So we apply not here, and preferably we also put parenthesis around this condition. Now when we execute this query, we see other customers that are not in the current results set. Let's take a look. So, instead of customers with id's 1356 and so on, we get customers with id's 2 4 and 10. Now technically these customers were born before 1990. And we have less then 1000 points. So if you look here, this first customer was born before 1990 and he has less then 1000 points. How do they know that? Let me show you a trick that I learned in math. Whenever you have a not operator. You can simplify your expression like this. We apply the not operator to the first condition. People who were born after 1990, how can we negate this condition? Well, the greater than operator becomes less then or equal to. That is the inverse of that condition. Now we apply the not to or to negate the or. What do we get? We get and. Finally apply the not operator on the last condition. We both have more then 1000 points. When we negate this condition we get customers with less then or equal to 1000 points. Now, you can remove the not operator to simplify this, we don't need parenthesis anymore because we only have 2 conditions that are combined with an end. Here is the result. As you can see, this is much easier to read and understand people who were born before this day and they have less then 1000 points Alright, here's your exercise. From the order items table, get the items for order number 6, where the total price for the total item is greater then 30. Alright, here's the order items table, in this table we have these columns order id, product id, quality, and unit price. If we multiply the quantity by unit price we can get the total cost of that item. And then we can compare it with 30. So, let's go ahead and write this query. Select star from order items. Where here we need two conditions one is for order, so order _id should be 6, and the second condition we want to calculate the total price. So we get the unit price multiply it by quantity and this value should be greater than 30. So as you can see, we can use an arithmetic expression in the where clause. It's not limited to the select clause. Okay? Now let's execute this query and see what we get. We should get only 1 item, that is for product 1, here in quantities 4 and unit price is just over 8 dollars, so the total price for this item, is greater than 30. Hey guys, Mosh here. In case you haven't seen my website yet, head over to codewithmosh.com. This is my coding school where you can find plenty of courses on web and mobile application development. In fact recently I published a complete SQL course that is about 10 hours long, and it teaches you everything you need to know from the basic to advanced topics such as database design, security, writing complex queries, transactions, events, and much much more. These are the topics that every software engineer must master. This YouTube course you're watching, is the first 3 hours of my complete SQL course that is about 10 hours long. So if you want to master SQL and get job ready, I highly encourage you to enroll in my complete SQL course. You can watch it anytime, anywhere, as many times as you want, you can watch it online or download the videos. The course comes with a 30 day money back guarantee, and a certificate of completion that you can add to your resume. The price for this course is $149 dollars, but the first 200 students can get it for just over 10 dollars. So if you're interested the link is below this video. In this tutorial I'm going to show you how to use the in operator in SQL. So, as an example, let's say you want to get the customers that are in Virginia or Florida, or Georgia. One way to write this query is like this. So, where state equals Virginia, or a state equals Georgia, or a state equals Florida. Now people who are new to the SQL language or programming in general find this expression a little bit strange. They ask, "Mosh, why can't we write this expression like this?" where state equals Virginia or Georgia or Florida. Here's the reason, we use the or operator to combine multiple conditions. So here we have a condition or an expression more accurately, but on the right side of this or operator we have a string. In SQL we cannot combine a string with a boolean expression that expresses a boolean value which can be true or false. So that is why we have to write our query like this. So we have multiple expressions or multiple conditions and we're combining them using the or operator. So, now if we execute this query we get these customers here. customers here but there is a shorter and cleaner way to get the same result. Instead of combining multiple conditions using the or operator we can use the in operator. So, where state is in and then in parenthesis we add all the values, like Virginia, comma, Florida, comma Georgia and the order doesn't matter, this query is exactly equivalent to what we had earlier, but a you can see it's shorter and easier to understand. So, let's execute it, look, we get the exact same result. Now here we can also use the not operator. Let's say you want to get the customer's outside of these states, so we can use rare state, not in this list. Now if you execute this query, we get customers who are located in Colorado, Texas and so on. So use the in operator whenever you want to compare an attribute to a list of values. Now here is your exercise. I want you to write a query to get the products where their quantity in stock equals on of these values. 49, 38, and 72, so pause the video, do this exercise, and then come back and continue watching. Alright, this is pretty easy, so we do a select star to get all the columns from the products table, where quantity in stock in we use the in operator to compare this attribute with these values. 49, 38, and 72, let's execute the query, we get only 2 records because we don't have a product with quantity in stock equal to 72. In this tutorial, we're going to look at the between operator in SQL, so that means we want to get the customers who have more then 1000 and less then 3000 points. What made you write these queries like this? Where, points, greater than thousand, more accurately greater than or equal to 1000. And, points less then or equal to 3000. When we execute this query we get how many, we get 4 people that satisfy my criteria. Now whenever you're comparing an attribute with a range of values, you can use the between operator, and that makes your code shorter and cleaner. So, we can rewrite this expression like this, where points, between 1000 and 3000. This is exactly equivalent to what we had before, so these range values are also inclusive, so that means points is going to be greater than or equal to 1000 or greater than or equal to 3000. Let's execute the query, we get the exact same result. Alright, now as an exercise, I want you to write a query, to get the customers that are born between January 1st 1990 and January 21st, 2000. Alright, so we start the select star from customers, where birth_date between so what matters here is we can use the between operator as well. It's not limited to using numbers. So with birth date between now we need to supply two date values, so as I told you before, the format for dates is four digits for the year, so 1990, two digits for the month, and two digits for the date. So, the birthdate should be between this value and here's a second value. 2000, 0, 1, and 01. Let's execute this query, we get only 3 people who match this criteria. In this tutorial, I'm going to show you how to retrieve rows that match a specific string pattern, for example, let's say we only want to get to customers who's last name start with 3. So, here in the where clause we type out where last name this is where we use the like operator, and right after that we have a string pattern, so, you want to get the customers who's last name start with b and we have any number of characters after b. So use the percent sign to indicate any number of characters, you may have one character after b or no characters or 10 characters, with this pattern, you get all the customers who's patterns start with b. And also it doesn't matter if it's an upper case or lower case b. So, let's execute this query, there you go, so you only have 3 customers who's last name starts with b. As another example, let's say we only want to get the customers who's last name starts with brush. So, we change our pattern to brush, percent. Now, let's execute the query, we only get this one customer here. Now this percent sign doesn't have to be at the end of the pattern, it can be anywhere. For example, let's say we want to search for customers who have an e in their last name, whether it's at the beginning in the middle or at the end, so we change our pattern to percent e percent this pattern means we can have any number of characters before or after b. Let's execute the query, these are the customers that have a b somewhere in their last name. It doesn't matter if b is in the beginning or in the middle or at the end. Let's look at another example, I want to get all the customers who's last names end with y, so here's the pattern we use, let's execute this query, so we have 5 customers who's last name ends with a y. So this is how we use the percent sign. Now we also have an underscore and that matches a single character so with this pattern you get customer who's last name is exactly two characters long, we don't care what the first character is, but the second character should be y. Let's execute his for you. Obviously we don't have any customers who's last name matches this pattern. But if you change this pattern to 5 under score, so 1234 5, followed by a y we should get these customers. So their last name is exactly 6 characters, we don't care about the first 5 characters, but all of them end with a y. Now, as another example, we can replace the first underscore with b, and that means we want to get the customers who's last names start with b, and after b we have exactly 4 characters followed by a y. Let's execute this query. So we only have one customer, that matches this pattern. So this is how we use the light operator, use the percent sign to represent any number of characters and an underscore to represent a single character. Now this like operator in MySQL is an older operator but we also have a newer one that is more powerful and it allows us to search for any string patterns. And that's what I'm going to show you next. Alright. Here I'm going to give you two exercises for the like operator. First, I want you to get the customers who's addresses contain trade or avenue, and next I want you to get the customers who's phone numbers end with 9. Alright, let's get started with the first exercise. So start from customers where address like now here we want to use a search pattern like this. You want to have tray (?) but tray can be anywhere in the address. So, we put a percent before and after tray. Next, we should use the or operator to search for another pattern. Or address like, let me put this on a new line that is better, address once again, percent, avenue percent, that's it. So, let's execute this query, here is the result, you should get the customers with ID's 2, 9, and 10. If you look at their addresses, all of them have either tray or avenue in their address. Now let's work on the second exercise, you want to get the customers who's phone numbers end with 9. That is pretty easy, so, let me change our where clause. Where phone once again we use the like operator and a percent, followed by a 9. That's all you have to do. Let's execute the query. So, here's the result, customers with id's 3 and 7, their phone numbers, and 9. So this is how we use the like operator. And by the way you can always use the not operator here let's say you want to get the customers who's phone numbers don't end with 9, so we simply prefix like with not. Now, if we execute this query one more time, we get all the other customers in the database. In the last tutorial you learned about the like operator in SQL. So as another example let's say you want to search for the customers who have the word field in their last name. So we type out the where clause like this, where last name, like, percent, field, percent, so the word field, can be anywhere in the last name. Let's execute this query, we get only one customer, beautiful. Now we also have another operator in MySQL, that is reg x which is short for regular expression, and regular expressions are extremely powerful when it comes to searching for strings. So they allow us to search for more complex patterns. Here's an example. If I want to rewrite this last where clause using a regular expression it looks like. Where last name ragexp now here in our string pattern we don't have to type out the person's size we only type out field so what we have on line 4 is exactly identical to what we have on line 3, let's execute this query we get the same result, beautiful, now here in regular expressions, we have additional characters that we don't have when we use the like operator. For example, we can use the carrot sign to indicate the beginning of a string. So if I put a carrot just before the word field, that means our last name must start with field. Obviously, if you execute this query, we don't get anyone that matches this criteria, so we use the carrot sign to represent the beginning of a string. We also have a dollar sign to represent the end of a string. So this pattern means the last name must end with field. Let's execute this query, you get the same result as before. Now we can also search for multiple words here, for example let' say we want to find the customers who have the word field or mac in their last name So, we use a pipe, a vertical bar, and type out another pattern. Let's execute this query, so here we have two customers, one of them has the word mac, the other has the word field and the last name. Now we can take this to the next level. Let's say we want to find the customers who have the words field, or Mac, or rows in their last name. Let's execute the query we get 3 customers. Beautiful. So we use a pipe or a vertical board to represent multiple search patterns. Now as another example, we can change our first search pattern to something like this. Now this pattern means this last name should either start with the word field, or it should have the word mac in it or it should have the word rows. Let's execute the query, now we get only two customers, because our customer with the last name brush field doesn't match this pattern. However, if we change our first pattern to field $ and execute the query we get 3 people here, 3 customers. So this is how we can combine multiple special characters when building a complex pattern. Now let's look at another example, let's say you want to search for customers who have an e in their last name. So these are all the people, alright, now let's say you want to make sure that before the letter e, we should either have a g or an i. So this is where we use square brackets. And inside the brackets we add multiple characters like g, i, m and that matches any customers who have ge or ie or me in their last name. So any of these characters can come before e. Now, let's execute this query, there you go, we only get 2 customers, and the first example before e we have i which is one of the characters inside the brackets, in the second example, before e we have a g which is also another valid character before and once again the square brackets don't have to be before we could add them after e, any customers who have e followed by an f or an m or a q in their last name, can be returned with this pattern, if we don't have anyone in the database so this is how we use square brackets, now we can also supply a range of characters, for example we can have e and just before e you can have as many characters from a to h, you don't have to type them out explicitly like abcdefg, that's very verbose, so, we can type out a to h. And then if we execute this query we get these three people. So, let's quickly recap everything you learned about regular expressions in this tutorial. Use a carrot to represent the beginning of a string, so beginning, we use a dollar sign to represent the end of a string, we use a vertical bar or pipe, to represent a logical or so we can supply multiple search patterns, we use square brackets to match any single characters listed in the brackets, and finally we use square brackets with a hyphen to represent a range. So any characters from a to f. Technically MySQL supports more special characters but quite honestly, the ones that I've listed in this tutorial are the ones that you'll be using 90% of the time. So just memorize these and you're good to go. With honesty a lot of beginners find the syntax for regular expressions confusing, so in this video I'm going to give you 4 exercises that I have carefully designed to help you quickly learn about this syntax. Here's the first exercise, get the customer's who's first names are Elka or Ambur. And note that this is Ambur with a U. Now for the second episode return the customer's who's names end with ei or on. Here's the third exercise get the customer's who's last names start with my or it contains se, and finally as the last exercise return the customer's who's last names contain e followed by r or a u. So, go ahead and spend 23 minutes on this exercise, when you're done come back and continue watching. Alright, let's knock out the first exercise. So we'll get allows, there's a c here, so let's start from regular expression, and here's our pattern, you're going to search for two words either Elka or Ambur. As simple as that. Let's execute this query, we should get two customers, there you go, Ambur and Elka. Alright. Now, let's knock out the second exercise. So I'm going to delete these we don't need them anymore. So we want to get the customers select start from customers, where last name should end with either ey or om. So, in the search pattern we type out ey followed by a dollar sign to indicate the end of a string then we add a vertical bar to supply the second search pattern. So On and once again dollar sign. Let's execute this query, oops I forgot to type out regular expression, there you go. So, Let's execute this query, and you should get these four customers with ID's one three, five and seven. The first three, five, and seven, the first three, their last names end with ey, and the last customer, his or her last name ends with on. Alright, Now, let's work on the third exercise. So I'm just going to change the regular expression here, we want to get the customers whose last names start with my or contains se. So we use a carrot to indicate the beginning of a string so it should start with my, or it should contain se, again, very easy, let's execute this query and we get the customer's with ID's 4, 8, and 10 and finally we want to get the customers who's last names contain e so, let's change the search pattern, we should have a b, followed by r or u. Now there are two ways to write this regular expression, we can use square brackets so we have b followed by r or u, that's one way, or the other way is to use a vertical bar. So b r or bu. These are both valid solutions. So, I hope you knocked out these exercises, in the next tutorial I'm going to show you how to get the records with missing values. In this tutorial, I'm going to show you how to look for records that miss an attribute. For example, if you select all the customers in our database, you can see that the customer with id 5 doesn't have a full number. So if you look closely here, you can see the value of null. Null means the absence of a value. Now let's say we want to search for all the customers who don't have a phone. Perhaps you want to send them an email and say hey, your phone is missing in our system. So how can we get these customers? That is very easy? We use the is null operator, so in the where clause, we type out where phone is null. Now let's execute this query, we only get one customer who doesn't have a phone, now here we can also use the not operator to get the customers who do have a phone. So we change the conditions to is not null. Let's execute the query, now in the query results, every customer does have a phone number. For this exercise, I want you to write a query to get the orders that are not shipped yet. This is a very useful query that is used in a lot of real applications. For example, let's say you're an admin for online shop. You want to see the orders that are not shipped yet, so you can see them all. So write a query, and get these orders. So here we have the orders table, let's have a quick look at the data in this table. So if you pay close attention you see some of these orders don't have a date. And these orders also don't have a shipper id which is a unique number for identifying the shippers. So any order that misses the value for the ship date or shipper ID, is considered an order that is not shipped. So let's go ahead and write a query to get these orders. So back to our query editor select star from orders where ship_date is null. You could also write shipper id is null. They're both equally correct. So let's execute this query, and you should get 5 orders. Orders 1, 3, 4, 6, and 8. In this tutorial I'm going to show you how to sort data in your sequel queries. So here in your have a query to select all the customers from the customers table, if you look at the query result, you can see that our customer's or sorted by id, so we have customers 1, 2, 3, 4, and so on. This is the default sort column. But we can always change this using the order by clause. But first, let me explain why the customer id column is the default sort column. So first of all the first I'm going to open up the navigators panel on the left side here's the customers table, now let's click on this middle icon here that looks like tool. This opens up our customers table in the design mode, here we can change our columns we cana dd new column or remove existing ones or change that name and order and so on. Now if you pay close attention you can see a yellow key just before This means that this column is the primary key column. For this query. So in relational databases every table should have a primary key column, and the values in that column should uniquely identify the records in that table. So back to our query window, you can see that the values in this column uniquely identify each customer, so the customer id column is the primary key column in this table, and that is why when you write a query against this table, our customers will sort it by id by default. Now, let me show you how to sort customers by a different column. So, here in the order by clause, you type out the name of another column, like first name. Let's execute the query, now we can see our customers are no longer sorted by their id, instead they are sorted by their first name in ascending order. Now, if you want to reverse the sort order, simply type out de, e, sc, which is short for descending. Now, you're sorting the customers in this order, okay, we can also sort data by multiple columns, for example, let's say first we want to sort customers based on their state, and then within each state, we want to sort them by their first name. So, we type out multiple columns here, state and first name. Let's execute the query now, you can see that the first state we have here is california, followed by Colorado, and new here in Florida, you have two customers and these customers are sorted by their first name. Let's have a close look here, so first we have Ambur and then we have other customers here. Now we can also use the descending argument anywhere here. For example, we can sort these customers by their state in descending order. And then sort them by their first name in ascending order or once, again in descending order. So there are various ways we can sort data. Now one of the differences between MySQL, and other database management systems, is that in MySQL you can sort data by any columns whether that column is in the select clause or not. For example, let's say you only want to select the first and last name for each customer. Now we can sort the result by any columns in this table, they don't have to be first name and last names For example, we can sort them by their birthdate, take a look, so this is a valid query in MySQL, but other databases management sometimes yell at you when you update a query like this. Now we can also sort data by an alias for example, here in out select clause let's add the number ten and give it a alias. As let's say points, so points is not a valid column in this table, it's simply an alias or expression, in this case a simple number. And here we could have a complex mathematical expression, it doesn't really matter, we can still sort data by Alias, so we can order by points and then first name. Once again this is a valid, query from MySQL's point of view. Now one last thing before we finish this tutorial, I've seen some tutorials that teach you how to sort data by calling positions, for example, here we can order it by 1, 2, and that basically means sort the data by the first name, and then, the last name. So these are the orders of these columns, if you execute this query, you can see that our customers are sorted by their first name and then last name. Why this approach works, it's something that you should avoid. Because if in the future you come back here and add a new column, in front of the first name column, let's say first, date. Now our customers are no longer sorted in this order. So sorting data by calling positions produces unexpected results and is something you should avoid. always sort by column names like first, Alright, here's your exercise for this tutorial. In this database, we have this table, called order items, where we find the items for each order. Now, I've written the query that you cannot see here, because that's the solution to the exercise I'm going to give you, that query produces this results. So we only have the items for the order with ID 2, and we have sorted these items based on the total price for each item. So the total price for each item equals quantity times unit price. In this case the total price of product 1 is just over 18 dollars. So go ahead and write a query to select all the items for order with ID2. And sort them by their total price in descending order. Alright, let's select everything from order items, where order id equals 2. that returns all the items for this order. Now we want to make sure to sort them by their total price, so, here in order by clause, we write an expression. Quantity times unit price, this returns the total price for each item. And then we add the descending argument here. So, once again the expression that we use in the order by clause doesn't have to be column name, it can be an alias or an arithmetic expression like this. Let's go ahead and execute this query. This is what we get now for clarity, I would like to add another column in the result So, let's say quantity times unit _price. We give it an alias like total price. Let's execute the query, you can clearly see, that this data ia sorted by the total rice in descending order. However, there is a bit of duplication in our query, you have to repeated this expression in two places. So now we can simplify our by clause, by using an alias that is total price. And we gwet the exact same result. Net I'm going to show you how to mimic the number of records returned form your queries. In this tutorial, I'm going to show you how to limit the records returned from the query. For example, when we return this query we get all the customers in the customer, table, so we have to ten customers here. Now what if we only want to get, the first 3 customers. That's where we use the limit clause. Let me show you. So, after from, you type out limit 3, and this will return only the first 3 customers. Now if the argument that we pass here is greater than the number of records that our query produces, we'll get the records in the query result. For example, if I pass 300 here, obviously we don't have 300 customers in this table, so when we execute this query. We get all the ten customers in this table. So this is how the limit clause works. Now here we can optionally supply an offset, and this is very useful in situations where you want to paginate the data. For example, let's say we have a website, and on this website we have a web page for the user to see all the customers int he database. Now for simplicity let's imagine, we want to show only there customers per page. So, what are the customer's you're going to have on page 1? We're going to have customers 123. On page 2 we're going to have customers 456 and on page 3 we're going to have customers 789. Now, let's say we want to write a query to retrieve the customers on page 3. How can we do that? Well, you want to skip the first 6 records and then pick 3 records. So, we change our limit clause to something like this. 6 and 3. So 6 is what we call an offset. And that basically tells MySQL to skip the first records and then take 3 records. Let's execute this query. Alright, now we get customers 789. Now, for your exercise, I want you to get the top 3 loyal customers. These are the customers that have more points then everyone else. Alright, first we select everything from the customers table, now we need to order these customers by their points, in descending order. So if you look at the query result you can see that customers are sorted by their loyalty. So, the most loyal customers come first, now we want to pick only the first three customers, and that's where we sue the limit clause, so limit, let's execute this query. And these are the most loyal customers, customers with id's 56 and 3. Now, here's one thing I want you to remember and that is the order of the limit clause. The limit clause should always come at the end. So first we have the select clause and then we have from optionally you can have where followed by order by and finally limit. Order of these clauses matter If you change the order MySQL is going to yell at you. So pay attention to the order when writing your queries. So far you have only selected columns from a single but in a real world, we quite often select columns from multiple tables. And that's what I'm going to show you over the next few tutorials, so on the left side if you put our orders table. Let's select all the data here, in this table we're using the customer id column to identify the customer that has placed each order. Now as I have told you before we don't store customers information here like their phone number, their email their address, because this information can change in the future. And if even a customer has placed multiple orders then we have to change multiple records, you don't want to do that. That's why we have separate tables for customers and orders. Now in this tutorial I'm going to show you how to select the orders in the orders table, but instead of showing the customer id, we showed full name for each customer. So lets go back to our query window. Okay, so, we want to select everything from the orders table. Now we should combine the columns in this table with he columns in the customers table. That is where we use the join keyword. And here we can optionally type inner join, because we in SQL we have two types of join inner join and over join. You'll look at outer joins later in this section, so for now we are only using inner join and these inner keyword, is actually optional, so we don't have to type it. So, you want to join the orders table with the customer table. Now, on what basis do we want to join these tables? Well, here in the customers table, we have this customer id column. So if you put these two tables next to each other you want to line up the records such that the customer ID's are equal. That is where we use the on phrase. So after we type out a condition, here's a condition we need to type out, orders.customer_id. Should be equal to customers.customer id. Now, this is getting outside of the screen, so let's break up the line, that's better, so with this query, we're telling MySQl that hey, whenever you're going the orders table with the customers table, make sure that the customer ID column, in the orders table, equals the customer ID column, in the customers table. Now let's execute this query, look at the result, since we are selecting everything here, the first few columns are from the orders table, because we have listed that first now after all the columns in the customer table. So customer ID first name, last name and so on. Now let's simplify the result set and select only border id, first name, and last name, so query we select order ID, first name, and last name. Now let's execute the query that is better. So next to each order ID, you can see the name of the customer that placed that order. Now what if you want to display the customer ID here as well. Well, let's put that here and see what happens. Customer ID, execute the query we get an error, so if you look at the output window, down at the bottom, we should see an error saying column, customer id, field this is ambiguous. Now unfortunately I cannot show you this error, because the size of my recording window is smaller then MySQL workbench. But that aside, let me explain why we're getting this error. Because we have this customer ID column in both the orders and the customers table, so MySQL is not sure which table we want to select this column from. That is why it's saying this column is ambiguous so we need to qualify this column by prefixing it with a table name. We can either pick it from order table or the customers table, it doesn't really matter, because the values are equal, right? So, in situations where you have the same column in multiple tables, you need to qualify them, by prefixing them with the name of the table, okay, now, we say tot he query one more time, there you go, you have order ID, customer ID and the full name. Now one more thing before we finish this tutorial, if you pay close attention we have repeated the word orders in multipel places, you have it here, as well as in the join condition, the same is true about he customers table, you have repeated that here. We can get rid of this repetition and make our code simpler by using an alias. So write after each table you can do it in alias, as a short for orders, so by convention we abbreviate the table's name. Now, wherever we have orders you should replace that with o. So here in the join condition, we're going to replace orders with o, and also one more time, in the select clause. There you go. You can also apply an alias for a customer's table, call it c, and then simplify our join condition like this. So this is how we can join columns for multiple tables. Now for your exercise, I want you to look at the order items table. So, in this table we have these columns, order ID, column ID, product id, quantity, and unit price. Now I want you to write a query and join this table with the products table so for each order return both the product id as well as this name, followed by the quantity, and the unit price form the order items table. And by the way make sure to use an alias to simplify your code, Alright, first let's select everything from the order items table, and then join it with the products table. How are we going to join this table. On order_items. Well actually let's just keep this on Alias right away, so we use oi, as an abbreviation for order items. And p as a short for products. So oi.product id, should be equal to p or products. product id. And by the way, remember that alias for table, you have to use that alias everywhere. So here I cannot type out product, MySQL is going to yell at me. So let's use the abbreviation. Alright, this is how we join these tables, let's execute this query up to this point. Alright, so we see all the items form the order items table, followed by from the products table. Now, you want to explicit select a few column here. So, to order items table you want to select order_id. We take it then we don't have to prefix it with a table name because this calumnies not repeated in multiple places, so it's not ambiguous. So, let's make the code shorter, that's better, now we want to select the product ID column, but because this column exists in both tables, you have to both prefix it with a column name. Either oi or p it doesn't really matter. So, next, we want to select quantity, and finally you want price. Now actually here, you have this unit price column. In both tables, so this is the unit price in order items table and this is the unit price in the products table, now you might be curious why we have this column in 2 places, is that the price of product can change, so for each order item, you want to have the price at the time the user placed the order. So this is a snapshot of the price at a given point in time. The unit price that we have for the products table is the current price right now. This is very important for the recording, otherwise we cannot calculate the sales properly. So, because we have the unit price column in two places, in this case we should pick it from the quarter items table because this is the price at the time of now, let's execute query. So here's the final result. In the real world, when you work as a developer or a data base administrator quite often you will have to work with multiple databases. In this tutorial I'm going to show you how to combine columns from tables in multiple places. That's pretty easy. So, in the SQL store database, you have this tables that you're fairly familiar with. Now imagine this products table was not here. Now, if you look at the database, you can see here another products table, this products table is exactly the same as the products table that we have in a SQL store database, so it has the same columns and the same data. Now technically this is not a good design, you don't want to have the same table repeated in multiple places. But for this demo, let's just imagine that we don't have the products table here, so we want to join the order items table, with the products table in the SQL inventory database. Let's get started. So select everything from the order items table, let's give it an alias straight away, you want to join this with the products table. This products table is part of the products inventory database. So we'll have to prefix this with the name of it's database. So, we type out SQL inventory. Now once again we can give this an alias like p, then type out our joint condition, so oi.product id should be the same as p.product id. Let's run the query there you go, so we successfully joined tables across multiple databases. Now note that we're prefixing the products table with the name of the database because the current database that we're writing this query with is the SQL stored database. Take a look, in the navigator panel, in the SQL store database is displayed in full. Because earlier, the root we use statement to select a database, that will SQL store. Now what if we select the SQL inventory database. So, let's see what happens SQL inventory, now because we have multiple statements we have to terminate this with a semi colon. Now we want to select everything with a order items table. But we don't have this table inside of this database. So now we'll have to prefix this table with the name of it's database, that is SQL underline story. Let's execute the query, okay, everything works, beautifully. So here's the lesson. You only have to prefix the tables that are not part of the current database. In other words the query will be different depending on the database. In SQL we can also join a table with itself. Let me show you an example. Take a look at this database. SQL hr, in this database we have these two tables, employees and offices. Let's take a look at the data int he employees table. There you go. So here we have these columns, employee id, first name, last name, salary and reports 2. This is the id of the manager for this person or this employee. Now once again, you don't want to repeat the managers information here, like the phone number, the address because this information can change in the future, so we are only using your identifier or their id to refer to them in this table, now where can we find information about this This manager is actually an employee of the same organization, so, look at this example, the manager ID is 37 370. Now if you look on the website, here is the ID of that manager which is another employee. That was the manager for this employee. We don't have any values here so the value for the sale is null. So this employee doesn't have a manager and that means they are the CEO. So let's go ahead and write a query to join this table with itself so we can select the name of each employee and their manager. Back to our query window, first we need to select the SQL hr database. Next, we select everything from the employees table, we give an alias like b now we need to join this table with itself. So once again we type out the employees, but we need a different alias. What should we call this alias. Well you want to join this table with itself so we can find the managers right? So we can use m as a shortcut for managers. Now, let's type our our joint condition. So from the employees table, we need to join the reports_2 column. To the manager table which is basically an employees table itself, and that is employee_ id. Now let's execute this query and see what we get. So, we see all the columns from the employees table repeated the first set of columns, represent the information about the employees, and after that, we have the information about the managers in this case we have only one manager in this table. But with this technique we can easily create an organization trial. We can have a hierarchy of managers. Now let's only the name of the employee and the manager. So, right here, since every column in the employees table is repeated twice we need to prefix each column with a table name. For example, from the employee's table you want to get employee ID, as well as the first name, and then for the managers table, we want to select the first name as well. So every column should be prefixed with a table name or more accurately the alias because all these columns exist in two tables, right? Let's go ahead and execute this query, so, this is what we get, employee id, and here's the managers first name. We can improve this query by giving an alias to this column. Because it doesn't make sense to have two first name columns. So, let's give an alias to the third column, manager. Now, let's execute it one more time. And, here's the end result. So, we have the empty ID first name, and object. So, joining a table with itself is pretty much the same as joining a table with another table. The only difference is that we have to use different alias's. And we have to prefix each column with an alias. This is what we call a self join. Next, I'm going to show you how to join more then two tables. In this tutorial, I'm going to show you how to join more then two tables in writing a query. For example, back to our SQL database, look at the orders table, now you know how to write a query to join this table with the customers table to return information about the customer to place each order. But here we also have another column, status, which is similar to the customer ID status. So the name of the status's are not stored in this table, they are somewhere else in the order status's table. Let's have a quick look here. Our orders can be either processed, shipped or delivered. And these are the identifiers for each of these status's. Now back to our orders table. In the status column you store status id. So now we should write a query to join the orders table, be two tables. The customers table and orders status's table. The result of this query is going to look like this. So for each order we see the order id, the date, the first and last name of the customer, and finally the status of the order. This is a beautiful report we can create for our users. So let me show you how to write this query. Back to our query editor, first we need to select the SQL store database, now, we need to select everything from the orders table, that's going to be the alias, next we need to join this with the customers table. On, that customer id should be equal to see the customer id. Nothing new so far. Exactly like before. Now here we can write another joint keyword. To join the others keyword order status's table. So we type out order status's. And also give it an alias, OS, what is our join condition? Well, back in the orders table, here we have the status column. So the value in this column should be equal to the order status ID, column in order status's table. Right? So back to the query, so orders table.status should be equal to order status's.order status ID. Make sure to get the name right, otherwise you're going to get an error So this is how we can join three tables. Now in the real world as you work on more complex problems, you'll end up joining even ten tables. So this is not uncommon in the SQL world. Now let's go ahead and execute this query. First we get the column from the orders table, followed by the orders from the customers table, and so on. This result is so complex and hard to extract information. from. So, let's explicitly select a few columns here. From the orders table, you want to select the order iD column, as well as the order date. Then, from the customers table, we want to select the first name, and last name. And finally form the order status's, we select the name column. So we can give this an alias like status that's better. Let's execute the query one more time. So, here's the end result, we have order ID, order date, the name of the customer, followed by the status of the order. Alright, for exercise, take a look at the SQL invoicing database. Here we have this table, payments, and these are the payments that each client has made towards either invoice Let's take a look at the data, so we have these columns, like client id, that identifies the client, so we can join this table with the client's table to see the name of the clients. Next we have invoice ID, we also have date, payment method. So similarly we can join this table with the payment method table here, let's have a look at the data in this table, these are the payment methods, credit card, cash, PayPal, wire transfer. So, back to the payments table, I want you to write a query and join this table with the payment methods table as well as the client's table. Produce a report that shows the payments, with more details, such as the name of the client, and the payment method. Alright, first we need to use, the SQL invoicing database, now we can select everything from the payments table which we call e, next we need to join this with the client's table which we call c, on p.clientid should eb equal to c.client id. Let me double check the column name to make sure I got it right, so back to the payments table the column is called client item. You also have a column called payment method, that we should join to the payment method ID column of the payment methods table. So, back to the query, once again we use a joint statement here, join with payment methods, we give it an alias pm, on p. payment _method should be equal to pm. payment method id. Make sure to type it out correctly otherwise you're going to get an error. So let's go ahead and execute the query up to this point, finally let's hand pick the columns that make the most sense. So, from the payments table, let's select the date, followed by invoice id, what else do we have here. So we have client id, invoice id, date, and now the payment method, I'm going to pick the amount column from here as well, so back to the query, p .amount. Now we need to add information about the client. Let's take a look at this table, clients, so here we have columns like name, address, city and so on. All we need here is the name column. So back to the query, of the client's table let's select the name column and finally form the payment method table, let's select, what is that column called it's called name. So back to the query pm.name. So here's the end result. Now we can put this column in any order that we want, it doesn't really matter, let's execute the query, and make sure everything works. So, on this date, on this invoice, we have a payment for this amount by this client using a credit card. Ina let he examples you have seen so far, we use a single column to uniquely identify the rows in a given table. For example, for example, in the customers table, we have this customer ID column which uniquely identifies the rows in this table. But there are times where we cannot use a single column to uniquely identify columns in a given table. For example, look at the order items table. In this table, we have columns like order id, product id, and so on. Now if you look at the data, you can see that the values in the order id column are repeated. They are duplicated. You have 2226 and so on. So we cannot use this column on it's own to uniquely identify each record. The same is true for the product id. The values for this column are also duplicated. So in this table we use the combination of the values in both these columns to uniquely identify each oder item. As an example, in this order we have 3 items, for products, 1, 4, and 6, and for each product, we have a quantity and unit price. So if we use the combination of the values in both these values, we can uniquely identify each order item, in other words, we don't have two records for order ID 2, and product ID 1, we only have a single record for that item, now let's open this table in the design mode. So over here we find this middle icon that looks like a tool. Note that this yellow key that represents the primary key exists on both these columns. This is what we call a composite primary key. The composite primary key contains more then one column. Now why does this matter? Well, when you have a table with a composite primary key. You need to learn how to join that table with other tables. For example, here we have this table, order item notes, that we use to keep notes in each order item. Let's look at the data here. So we have this column note id, right? Which uniquely identifies the records in this table, next to that we have order ID and product ID. you learn that the combination of these two columns uniquely represents and order ID. So here for order number 2, for product number 1, we have two notes. Now let me show you how join this table with the order items table. So, back to our query, you can see that I have already selected the SQL store database, so I'm not going to type out a U statement. Alright, let's select like everything from the order items table. Give it an alias, now we need to join this with order item notes, also we give it an alias. How are we going to join these tables? Based on two columns, back to the order items table these are the columns that we need to use in our joint condition. So, in the order items table we have this order ID column, these should be equal to the same column in order item notes table. So, in.order id. But this is not enough, we should also join these tables based on the product ID number. So, we type out and, and then type out the second condition, so order items. product ID should be equal to order item notes.product id. This is what we call a compound joint condition. So we have multiple conditions to join these two tables. In this tutorial I'm going to talk about the implicit joint syntax in MySQL. So here we have a basic inner join, we're selecting everything from the orders table, joining it with customers table on, orders.customer id. Equal to customers.customerid. Pretty basic. There is another way to write this query using implicit join syntax. Let me show you how this works. So, we select everything from now here we can type out multiple table names. so, orders, customers. And we can also give them an alias, so c and o. And then we move this join condition, to the where clause, so I'm going to copy this from here, type out the where clause, and paste the condition. These two queries, are equivalent. What we have here is called implicit joint syntax. Now even though MySQL supports the syntax it's something that I suggest you not to use, because if you accidentally forget to type out the where clause, you will get a cross join. Let me show you what I mean. So first I'm going to delete the first query. And execute this so we get ten records because we have 10 orders in this database. So far so good. What happens if you accidentally type out the where clause. Instead of 10 records we're going to get probably 100 records. Because every record in the order table, is now joined with every record in the customers table. This is what we call a cross turn. Now later in this section I'm going to talk about cross joins in more detail, but what I want to talk about in this tutorial, is that it's better to use an explicit joint syntax, so, we use, join because this syntax forces you to type out the joint condition, if you simply join orders with customers, without typing the join condition, you're going to get a syntax error. So to recap, be aware of the implicit join syntax, but write all of your joints using the explicit syntax. Earlier in this section I told you that in SQL we have two types of forms. Inner joins and outer joins. And so far you have only seen examples of inner joins. And I also told you that this inner keyword is optional, so whenever you type out a join, you're using an inner join. In this tutorial, we're going to look at outer joins and the problems they solve. So, let's start by writing a query that uses an inner join, and then we'll convert hat inner join and outer join. So, select everything from the customers table join it in the orders table, on c.customer id should be equal to o.customer ID. Pretty basic right? Now for clarity, let's pick a few columns from these two tables .So for the customers table I want to pick customer id. And first name, and from the orders table, I want to pick order id. Now finally, let's sort the results so we can clearly see what we get. So order by c.customer id. Let's execute that query and see what we get. So, here' the result. For customer number 2 called inis or inis whatever, you have 2 orders, order 4, and order 7. Similarly for customer number 5, we have 2 orders and so on. Now there is something missing in this result. We only see customers who have an order in our system, these are customers 2, 5, 6, 7, 8, and 10. But if you look at the customers table, you can see that you have other customers like customer number 10, customers number 3, and so on. Currently we don't have any orders for these customers, and that's the reason we don't see them in this results set. But what if you want to see all the customers whether they have an order or not? That's when we use an outer join. Let me show you how that works. So back to our query the reason we only saw customers who have an order was because of this join condition, When joining these two tables, you are only returning records that match his condition. So for a given customer, if we do have an order, that record is returned. But as you saw a second ago, some customers don't have an order. So for those customers this condition is not valid. And that is the reason they are not returned in the result set. To solve this problem we use an outer join. Now in SQL we have two types of outer joins. We have left joins and right joins. When we use a left join, all the records from the left table, in this case customers are returned whether this condition is true or not. So we get all the customers, and if they do have an order, we'll see the order id as well. Let's execute this query and see what we get. So, there you go. Customer number 1, doesn't have an order and that's why we get null in this cell. Customer number 2 has two orders, 4, and 7, customer number 3 also doesn't have an order so we get null for order id. This is the result of a left join. So back to our query when we use a left join, all the records from the left table are returned whether this condition is true or not. Now what if we use a right join. In this case, all the records from the orders table are returned whether this condition is true or not. Let's execute this query and see what we get. So, we get he same result as before. when we use an inner join, because we are selecting all the records from the right table which is the orders table, so we don't see all the customers we see all the orders. Now if you want to use a right join, and still see all the customers, you need to swap the order of these tables. So, we put the orders table first that's going to be our left table. And then, we put the customers on the right side, so now with this query we'll return all the records from the right table which is the customers table. We execute this we get all the customers whether they have an order or not. Beautiful. Now one last thing before we finish this tutorial, I've seen developers use the outer keyword here. So either right outer join or left outer join. But technically the outer keyword is optional just like the inner keyword, so you don't have to type it out. So I'm going to remove this to make this code shorter and easier to understand. So to recap, if you have the join keyword directly, and if you do a left or right join you're doing a inner outer join. Here's your exercise for this tutorial. I want you to write a query that produces this result. So we should have three columns here. Product ID, name, and quantity that I picked from the order items table, so here we need to join the products table. With order items table. So we can see how many times each product is ordered. However, in an inner join we will only see the products that have an order, but here I'm doing an outer join, so, product number 7, has never been ordered, but still exists in the result. Is it null, or the quantity? So go ahead and write an outer join, or use this result. Alright, first we select everything from the products table and then to a left join with the order items table. Our join condition is p.product id equals oi.product id. So because we'll get all the products in the products table whether this condition is true or not. If you have never been ordered, you still see them in the result. Now, let's pick a few columns for clarity. So p.productid p.name and oi. quantity. That's it. Let's execute the query. We get the same result as before. So all the products are here. And product number 7 has never been ordered so we see null for the quantity. Similar to inner joins, we can use outer joins between multiple tables. Let me show you. So here's the query that we wrote in the last tutorial, you are doing a left join between customers and orders tables. So when we execute this query, you get all the customer whether they have an order or not. If you have an order you see the order id. Beautiful. Now if you look at the orders table, you can see that some of our orders have a shipper id. These are the orders that have been shipped. So now let's join orders table with the shippers table to display the name of the shipper in the result. So back to our query, after this left join, let's write another join, here I'm doing an inner join. So let's inner join the orders table with the shippers table. Join shippers, we call it sh, on what is the join condition. Well, oh.shipper id, should be equal to sh.shipper id. Alright? So in this query we have a left outer join and inner join. Let's see what we get, alright, we only see 5 records. But you have more orders. So here you have the same problem we have before. Some of our orders don't have a shipper, and that is why they are not returned here. In other words, this join condition is not true, for some of our orders. So back to the orders table, a an example, this first order doesn't have a shipper shipper id is null, and that is why it is not returned with a query result. So to solve this problem, you should use a left join, you want to make sure that all orders are returned whether they have a shipper or not. So back to the query, you need to replace this inner join with the left join, so let's execute the query and see what happens. Now we should have quite a few more orders, there you go, now to make this example more interesting, I'm going to add the ship per name here. So back to our select boss, let's add a new column, shipper.name. Now we can give it an alias like shipper let's execute the query and here's the result. So we get all the customers whether they have an order or not. And for those who do have an order, we get all the orders whether we have a shipper or not. This is the power of outer joins. Now in the last tutorial, you learned that you can get the same result, in both the left join or the right join, you just have to swap the order of the tables. However, as a best practice of what to avoid using right joins, because when you're joining multiple tables and you have left and right and inner join, things get really complex. So, someone else reading your code, will have difficulty visualizing how you're joining these tables. As an example, if you have a right join here and then a left join after, it will be harder to visualize how these tables are getting joined. So, as a best practice, avoid right joins, and use left joins instead. And, here is your exercise for this tutorial. I want you to write a query that produces this result. So here you have these columns order date, order id, the first name of the customer the shipper and we can see that some of our orders are not shipped yet. So here we have null, and here finally, we have the status. So go ahead, spend 23 minutes on this exercise, when you're done continue watching. Alright, let's select everything from the orders table, now you should join this with customers, on, hold.customerid. Should be equal to c.customer id. Here I'm using an inner join, because every order does have a customer. So, this condition is always valid, it doesn't matter if we use a left join or a inner join here, now, okay? Now before going any further let's take our columns. So from the orders table, I'm going to pick order id. Followed by order date. And then, customer.firstname. Which we can optionally rename to customer. Alright, next we need to select the shipper. So, we join the result with the shippers table, on order.shipperid equal to shipper.shipperid. However, if we use an inner join here, because some of our orders don't have a shipper, we are only going to see the orders that have been shipped. Let me show you. So, for clarity, I'm going to add the shippers name here, so shipper .name as shipper. Let's execute the query there you go, we only see the orders that have been shipped. But we want to see all the orders, right? So, we need to change the second joint to a left join. So all orders are returned whether they have a shipper or not. Let's execute the query one more time, there you go. Now we see all the orders from number 110. Beautiful. Finally, we need to add the status comment here. So, we need to do another join here, join with order status's, which we aggregate as os, on oh.status equals to os.orderstatusid. We can see that I have designed our database such that sometimes our column names are exactly identical, but in other cases they don't match. So in order table we call this column, status, as opposed to order status id, and this is deliberate because a lot of real databases are like that. Alright, now let's add the status name here, so order, status.name as status. Execute the query, and we can see all the orders here, for each order we have the data, the customer, the supper and the status. Earlier, we talked about self joins in SQL. So here in the SQLhr database, we have this employees table, we rote a query to get all the employees and their manager. So here we have this column, reports to that specifies the manager for each employee. So let's go back and rewrite this query to get all the employees and their manager. Back to our query editor window, first let's use a SQL hr database. Then select everything from the employees table, we give it an alias and then join it with itself. So this is what we call a self join. Now we're going to use a different alias like m for managers. Now, what is the joint condition e.reports to, should be equal to m.employee ID, right? Now for clarity, let's pick only three columns, so either the id employee.first name. And m.firstname which we rename to manager. Alright, let's execute this query and see what we get. So, here's the result as you can see all these employees have the same manager. However, there is something missing here. We don't have a record for this person, this manager himself. So what is missing is a record where we can see the employee id for this person, their name and their manager which should be null because this person is the CEO or the head of the company. But why is this happening? The reason is, our inner join, because this condition we have here will only return people who have manager. We can solve this problem by using a left join. So, we do a left join, because we want to get every employee in this table whether they have a manager or not. Okay, now let's execute the query one more time. There you go. Now we have a record for this person the manager, as you can see this person does not have a manger, that's why we have null here. Back to our SQL store database here we have a simple query that joins the orders table, with a customers table. And here's our join condition. We have several examples of this before. Now as our queries get more complex these joint conditions get in the way, they make our queries hard to read, but the good news is that in MySQL, we have a powerful feature for simplifying these queries. If the column name is exactly the same across these two tables, we can replace the on clause. With a using clause which is simpler and shorter. So I'm going to comment out this line and instead type out using in parenthesis, we type out the column name, that is custom. customer id. What we have in line 7 is exactly identical to what we have on line 6. That is shorter and easier to read. So, let me delete this line. We can add another join statement here to join the orders for the shippers here, so join with shippers using shipper id. In both these tables we have a column with the exact same name. Alright, now let's execute this query this is what we get, you have the order id followed by the first name of the customer. Let's add a new column here, so, I'm going to add sh .name that is the name of the shipper, now obviously because some of our orders are not shipped, we have to replace this inner join to the left join. So we can use the using keyword with both inner and outer joins. Let's execute the query one more time. There you go. Now, we have the name of the shipper next to each order, beautiful, however, we cannot use this technique to join the result with the order status's table. Because in the orders table we have this column called status, but in order status's table, this column has a different name. It's order status id. Let me show you. So, order status's. columns, there you go, order status id. So the using keyword only works if the column name is exactly the same across different tables. Now what if we have multiple columns in our join condition. For example, earlier we talked about tis order items table, I told you that in this table we have a composite primary key, which basically means a primary key that consists of multiple columns. So the combination of these two columns uniquely identifies each record in this table. Now if I join this table, with order item notes table. In our join join condition, we should compare both these columns with their corresponding columns in the order item notes table. So let's quickly write that query and then simplify it with the using keyword. So, select everything from order items, now, join it with order item notes on so here we need to compare oi.order id with yn.orderid, and oi.productid= to oin.productid. This join condition is kind of messy, it's hard to read this query. Now let's simplify this query with the using keyword. So we type out using. In parenthesis we add both columns and then separate them using a comma. So, ordered and product id. Isn't that better? Now, for our exercise, back to our SQL invoicing database write a query to select the payment from the payments table and produce something like this. So in this table we have the date the client, the amount and the payment method, we can see. On what date who has paid how much using what payment method. Alright, I'm going to use the SQL invoicing database, and then select everything from the payments table, join it with the clients table. Using client id because in both these tables, you have the client id table. Next we need to join this with payment methods, however, they column name between these two tables is different, so in the payment table we have a column called payment method. But in payment methods table, our column is called payment method ID. So here we cannot use the using keyword, and we'll have to use the on clause. So on p.payment underline method equals pm. paymentmethodid. Now let's pick our columns. So, payment.date client.name. And we rename this as client, next we pick m out, and finally, the payment method, so, let's rename that to payment_method and execute the query, there we go, this is what we get. The date, the client, the amount, and the payment method. In MySQL, we also have another simpler way, to join two tales, it's called a natural join, and it's easier to code, but it's not something to recommend, because sometimes it produces unexpected results. But let me quickly show you how it works in case you see it somewhere so at least you're familiar with it. So back to the previous example, let's select everything from the orders table, that we should do a natural join with the customer's table. Now with this natural join, we don't exactly specify the column name. So the database engine will look at these two tables and it will join them based on the common columns. The columns don't have the same name. And that is the reason this query is shorted right. So, for clarity, let's pick a couple of columns here, o.order id and c. let's say first name. Let's execute the query, there you go. so we see all the orders and the customers replace them. So natural joins are really easy to code but they can be a little bit dangerous, because we're letting the database engine guess the join, you don't have control over it. For this very reason, natural joins can produce unexpected results, and that's why I discourage you to use them. In this tutorial, were going to look at cross joins in SQL. We use cross joins to mine or join every record from the first table, with every record, in a second table. Here is an example, let's select everything from the customers table to now here we do a cross join with the products table. So every record in the customers table, will be combined with every record in the products table. And that is why we don't have a condition here. Okay? So this is what we call a cross join now for clarity let's pick a couple of columns like see that first name we rename it as customer and then product.name which we rename to product. Also, let's sort the result by customer. first name. Now, let's execute the query, here's the result of the cross join, so first we have amber as the customer, and here are all combinations of amber with different products. Next we have Barbara or whatever it is, and again we have the combination of this custom with all the products. Now in this particular example, it doesn't really make sense to use a cross join, a real example for using cross join is where you have a table of sizes like small, medium, large, and a table of colors, like red, blue, green whatever. And then you want to combine all the sizes with all the colors. That is when you use a cross join. Wha we have here is called the explicit syntax for cross join, you also have the implicit syntax which looks like this. Instead of typing out the cross join, you type out multiple tables in the from clause. So customers and orders. Both these queries produce the same result. But I personally prefer to use the explicit syntax because it's more clear. And here's a simple exercise for you. Do a cross join between shippers and products. First do it using the implicit syntax, and then using the explicit syntax. It's pretty straight forward, I just want you to get your hands dirty in the code and get used to this syntax. Alright, first I'm going to use the explicit syntax, and then I'm going to place the syntax. So let's start by selecting everything from 2 tables, shippers and products, now for clarity I'm going to pick two columns, shipper. name which we rename to the shipper. And product.name which we order everything by shipper Let's execute the query, this is what we get. So the combination of all shippers and all products beautiful, now let's use the explicit syntax, so we select everything from the base table, in this case shippers and then do a cross join with products. That produces the same exact result. We covered everything about joins, you learned that with joins we can combine columns with multiple tables, but in SQL we can also combine rows with multiple tables, and this is extremely powerful. And let me show you how this works. First we have a quick look at our orders table, and select everything from the order table. Now if you look at the data, we can see that the first order was placed in the current year, 2019, all the other orders were placed in previous years. Now let's say you want to create a report, get all the orders, and next to each order, add a label. If the order is placed in the current year, the table is going to be active, and if the order is placed in previous years, you want to label it as archives. So, let's change our query and change our condition here. First you want to get all the orders in the current year. So where order date is greater than or equal to 2019, 0101. Now I just want to highlight that this is not the ideal way to get the orders in the current year, because here we have hard coded 2019. So if you execute this query next year, we are not going to get the right result. But don't worry about this for now. Later in the course I will show you how to get the orders in the current year, without hard coding a date here. So, let's execute this query, now we get only one order. Let's hand pick a couple of columns here. So, order id, and order date. And also I want to add a string, literal here, like active. Right? Let's execute this query, this is what we get. We get 3 columns, order id, order date, and active, and in this column, argument we have this string value. Active. Now let's rename this column to status, alright? And execute the query, that is better, now we want to write another query similar to this that will return the order in the previous year, but with a different label, archive. So, to save time, I'm going to copy this few lines and paste them right after our first select statement. Now note that here we have a syntax error, because we didn't terminate the first select statement with a semi colon, but don't worry about it, we're going to get back to this in a second so for the second query, we want to return a different a different label, archive, and we want to change our condition to less then 2019. Now, select only these few lines. And execute this query, either by clicking on this icon here, or using the keyword shortcut you learned earlier in the course. There you go, here are all the orders from the previous year, with the label archive. This query returns 9 records. The previous query returned 1 record. now using the union operator we can combine data from these two queries, so, in between our select statement we type out union now let's execute the query one more time, so here's our first order in the current year that is active and below that we have the orders in the previous years. So using the union operator we can combine records for multiple queries. Now in this example, both our queries are against the same table, but we can also have queries against different tables and then combine the result into one result set. Let me show you another example. So I'm going to delete everything here. Let's select the first name, from the customers table, and then we can union that with select the name from the shippers table. Let's execute the query's in one result set we can see all the customers and the shippers. Now as far as I know, there is no real world care for this particular query. But what I Want to point out is that with union we can combine results from multiple query's. These query's can be against the same table or different tables. In your database, you can have a table like archive orders, and another table like order and then you could combine all the archive and active orders into one result set. Just remember, that the number of columns that the query returns should be equal, otherwise you're going to get an error. For example, let's select the first name and last name from customers and then union that with the name of shippers. When we execute this query, we get an error, because the first part of this query returns two columns, but the second part returns one column. So MySQL doesn't know how to combine these records. And one last thing before we finish this tutorial. If you look at the result here, the name of this column is based on this first query, so the first query returns first name, and that's why this column is called first name. If you change the order of these queries, and move this union up here, now let's run this query as you can see our column is called name. So whatever we have in this first query is used to determine the name of columns. Here we can also rename the column to full name. There you go. Here's your exercise for this tutorial. Write a query for this report. So here we have four columns, customer ID, points, and title. Now as you know we don't have this column in the customers table, so we have calculated the values of this column, based on the points each customer had. If they have less then 2,000 points, their type is bronze. If they have between 2,000 and 3,000 points they are silver customers, and if they have more then 3,000 points, they are gold customers. Also note that here we have sort the result by the first name. So go ahead and spend two minutes to write this query. Alright, first let's get the bronze customers, so select everything from customers where points is less then 2,000. Now here we want to pick 3 columns, customer id, first name, end points. And finally we add a new column to a string literal, bronze let's run this query and see what we get. So these are all the bronze customers, but the name of this column in bronze, we don't want that. So, let's rename this to type. Now this is off the screen so I'm going to break this up into multiple lines that makers our query bigger and easier to read. There you go, let's run the query one more time, now the column is called type. Beautiful. Now we should do union and repeat this query, but extract the silver customers. So I'm going to paste this query here and then make a couple of changes here, I'm going to replace bronze with silver, and change the condition to between 2,000 and 3,000 let's run our query, see what we get so, we have all the bronze customers first, followed by all the silver customers. So the order of these records is based on our queries. In our first query we got the bronze customers, which is why they are listed first. But this is not what we want. You want to order the result by the first name of our customers. So, let's apply an order by at the end so order by first name. Now there is one more piece remaining. You should do a union one more time and write a query to get the gold customers. SO I'm going to select these few lines. And paste them here. Now let's change silver to gold, and the condition to (?) greater then 3000. And finally we do an imported by. Let's run the query one more time. And here's the end result, our customers are sorted by first name, bronze, silver and gold customers. In this section I'm going to teach you how to insert, update, and delete data. Before we get started let's have a closer look at our customers table. So click on this middle icon to open this table in the design mode. What you see here might look a little bit intimidating at first, but trust me it's so easy, and in this tutorial, I'm going to explain exactly what we have in these columns. So on the left side, you can see the column next to that you can see the data type for each column, so our customer id column can only accept integer value. Integers are whole numbers like 1234 and so on. You don't have decimal points, etc. First thing is a var chart which is short for variable character. And in parenthesis, you can see 50, that basically means in this column you can have a maximum of characters now if the name of a customer is only 5 characters long the only store those 5 characters. So even though the max length for this column is 50, you're not going to waste the space if this customer name is less then 50 characters. That is why here we have 4char which is short for variable. In contrast we have another data type that is character. If you had character 50 here, and the name of the customer was only 5 characters long, MySQL will insert additional 45 spaces to fill this column. So this is a waste of space. So as a best practice, Most oft he type we use var char to store strings or textural values. Now here on the right side we have this column pk, which is short for primary key. So customer id is marked as the primary key, and that is why we have this yellow key here, so the values in this column uniquely identify each customer. Next to that we have nn which is short for not null and that determines if this column can except null values or not. In this case, every customer record, must have the customer id. First name, last name, as well as these other attributes. But birthdays and phone are optional. So in these columns we can have null values, Now we have another calling here, ai, which is short for auto increment and this is often used with primary key columns, so every time we insert a new record in this table, we let MySQL or our database engine insert a value in this column, so essentially it gets the customer id for the last row, and it will increment it by 1, by the time you serve a new record. So if you look at the data you can see that currently we only have 10 customers here. So if you have a new customer here, MySQL will sign 11 to the new customer, okay? And finally here we have another column that specifies the default value for each column. For example, for birthday and phone columns, the default values or null, So if you don't supply a value MySQL will supply the null values for these columns. Similarly we have another null value, for the points column, so if we don't supply the points for a customer, MySQL will use 0, now we have a few other columns here which are not important at this stage, you will learn about them later in this course. So now you understand the attribute of each column, let's go ahead and insert data into this table. In this tutorial, you're going to learn how to insert a row into a table. For that we're going to use the insert into statement. Where are we going to insert this row? Into the customers table, so we type out the name of the table here followed by the values clause. And here in parenthesis we supply the values for every column in this table, so back to our table definition, these are all the columns, first we need to supply a value for the customer id column. However, in this column, the auto increment attribute is enabled, and as I told you before, if we don't supply a value, MySQL will generate a unique value for us. So we can go back to our statement and either assign an explicit value or use default to let MySQL take care of generating this value. This is the preferred approach. Because if we use this value an explicit value like 200 it is possible that you might have another customer with the same id. So when you execute the statement, you're going to get an error. Because you cannot have duplicate values in this column. Every value should be unique, so here we're going to use the default keyword to let you generate a unique value for the customer id, and after that we need to supply a value or the first name and last name columns. So, let's say Jon Smith. Note that I have enclosed these values with quotes, because as I have told you, string and for in SQL, we should always enclose string and values with quotes. Either single or double quotes, okay? Now, what else? Back to our customer table, after the last name you have birthdate, however, as we can see, this column is optional because this check box is not checked. So here we can use null or an explicit value. Null means the absence of a value. So back t our statement, you can type out the birthdate, like 1990 January 1st or you can use the null keyword to leave out this value. Now in this demo, I'm going to use a value date, now to make this code cleaner and more readable, I'm going to break it up into multiple lines. That's better, now back to our table, next we have phone and phone is also optional, because this checkboxes not checked, and null is the default value for this column. So here we can explicitly pass null, or use the default keyword and then put null into this column. It's exactly the same. So, back to our statement, you can pass null or default. Both these keywords will have the same result. In this case I'm going to use the null keyword. Alright, let's have one more look at our table, next we have 4 more columns that are required, so address, city, state, and points. And note that points has the default value of 0, so we can either use an explicit value like total value like 200, or use the default keyword and let MySQL generate 0. So, back to our statement, let's type out an address, it doesn't really matter. Followed by a city, and a state, let's say california, and finally points, again we use explicit value or default, so this is how we can insert a row into a table. However, in this example, you're only supplying values for first name, last name, birthdate and these address fields. So you're leaving out phone number the customer id and the points. So there's another way to write the statement. Let me show you. So after the table name you can optionally supply the stuff columns that you want to insert values into. In this case first name, last name, birthdate and once again I'm going to break up this statement into multiple lines So 3 more columns, address, city, and state, so these are the 6 columns that we're going to supply values for. With this change, we don't have to use these default or null values, we only supply values for these columns. So I'm going to remove default from here, and null, and finally this last default keyword. So, the 6 values that you supplied here are used for the 6th column. Now with this change, you can also reorder the columns. We don't have to list them in the same order, they were defined in the customers table, for example you can put the last name first, and then obviously we should also swap the order of these values, so we can list them in any orders. Now we can execute the statement, now if you look at the output window down on the bottom you should see the statement followed by one rows unfortunately I cannot resize this window to show you this message, but if you look down below you can see that one word was affected, which basically means one record was inserted into this table. Now, let's look at the data in the customers table so the last row is the one that we inserted, we can see that the MySQL automatically generated the value 11, this is the effect of auto increment attribute. So it takes the value of the last row, and incrememnts it by 1. So here we have the first name. Last name, birthdate, you didn't supply a value for the phone attribute, so, that's why we have null here, we also have address, city state, and the default value of 0 for the points. In this tutorial, you're going to learn how to insert multiple rows in one go. For this we're going to use the shippers table, let's have a quick look at the table definition so here we have 2 columns, shipper id and name. Shipper id is primary key, it's not nullable, and it's an auto incremented column. So we're going to let MySQL generate values for this column. Easy. You only need to supply a value for the name column. So back to our query editor window, we type out insert into shippers in parenthesis we specify the name of the column we want to insert values into, in this case name followed by the values clause. Here we add a pair of parenthesis with a value like shipper one. Now insert multiple rows all you have to do is insert a comma followed by another pair of parenthesis. So, shipper 2, one more time, comma, shipper 3, this is how you can insert multiple rows in 1 row, now let's execute this statement, alright, and then inspect the data in the shippers data. There you go. So initially we only had 5 shippers and here are the 3 new shippers that we inserted. Note that MySQL automatically generated the values for the shipper id column. So we have 67 and 8. Alright, here's your exercise for this tutorial. Write a statement to insert three rows in the products table, it's really easy you can knock it out in a minute, So here's our products table, we only have 4 columns, we're going to leave out the first column because it's an auto increments column so we only have to supply values for name, quality, unit price. Back to our query editor window, let's insert into products the columns are name, quanitty in stock, and unit price. And the values are going to be let's say product 1, stock is going to be 10 and the unit price is going to be 1, .95. Now I'm going to select these values. copy, paste it, like this, change the values accordingly, and finally the last row for the 3 there you go, let's execute this statement, alright and then verify the result so in the products table, now we should have 3 new records, now the id's you see here are 15, 16, and 17. Because before recording this video I actually inserted a few records in this table and then deleted them. So I had product ID's 11, 12 13, and 14. And even though they're actually deleted from this table, MySQL remembers their id's so instead of incrementing 10 x 11, it incremented 14 which is the last record from before. And that's why you generated 15. On your computer, the items are going to be 11, 12, 13. So far you have only learned how to insert data into a singular table. In this tutorial, I'm going to show you how to insert data into multiple tables. Here's a really good example, look at the orders table, what columns do we have? We have the order id, we have the customer id, so we know who has placed the order, we know the date of the order, you know the status, comments, as well as shipping information, but the actual items for this order are not in this table, they are in the order items table. So in this table, we have 4 columns we have the order id, so we know what order these items for. We have the product id, so we know what product order, in what quantity, and in what price. So an actual order can have 1 or more order items. This is what we call a parent child relationship. So this relationship the orders table is the parent, and the order items table is the child. So one row in the orders table can have 1 or more children inside the order items table. Now in this tutorial, I'm going to show you how to insert an order and all it's items. So you will learn how to insert data into multiple cables. alright, back to our query editor window. First we need to insert the order, so insert, into, let me close the navigator panel, we want to insert a record into the order table, now what columns do we have here? So we have these columns but only the first four are the and actually the first one, we don't want to worry about, because that's an auto increment column. So we only want to supply values for customer id, order date, and status. So back to our query, specifying those columns here, customer id, order date, and status, now let's supply the value. In the customer id column, we need to add a valid customer id. So let's have a quick look at our customers table, there you go. In this table, we have 11 records. So these are the valid customer id's. Now back to our query, let's use 1 for customer query and then 2019, January the 2nd for the order date, and one for the order status, once again in this column, we need to insert a valid order status id. If you don't supply a valid id, MySQL is going to get ahead of us. So we insert an order here, the items, now back to our order items table, in this table, we have this order id column, so here's the as soon as we insert an order, MySQL is going to generate an id for our new order now we need to access that id in order to insert the items in this table. How can we do that? Well, back to our query editor window, in MySQL, we have a bunch of built in functions, and a function is basically a piece of code that we use ourself. Just like a function is a feature in your tv. Every tv comes with a bunch of functions like power on, power off, change the volume, change the channel so on. So MySQL and other database engines come with a bunch of built in functions that we can use in our programs. One of these funcitons is last insert id. We can call or execute this function, by adding parenthesis here, and this will return the ID that MySQL generates when we insert a new row. So, before going any further, let's just select these, and make sure you get the right result. Now we have a syntax error here because we didn't terminate the first statement with a semi colon, alright, now let's execute this query, alright, so the id of the new order is 12. Let's verify that. So back to the orders table let's look at the data. On my machine I have 12 records here, I actually created 1 just before recording this video, so on your machine you're going to have 11 orders. Now back to our query window now that we know how to get the id of the newly inserted record, we can use that id to insert the child records. So, we're going to write another insert statement, insert into order items, let's have another look at the columns in this table. So we have 4 columns on all of them are required, so there's really no need to specify the column name in our insert statement, you simply supply values or order id, product id, quantity and unit price. So, here in the values clause, we add parenthesis, what is our order id? That is the value returned from calling this function. So I'm going to cut this from here and next we need to supply a valid photo id, but let's say product 1, quantity, let's say 1. And the unit price 2.95 dollars. Now let's delete this select we don't really need it anymore let's add another set of values, so once again, we're going to call last insert id, to get the id of a new order, we're going to change the product to product number 2, and add a different price. That's it. Now let's execute this statement and see what we get. Alright, so, back to our orders table, let's refresh the records here, alright so we have a new order, order number 13, beautiful, now let's look at the orders items table, here's the order items, let's open the table. So we should have 2 items, or order number 13. Beautiful. So this is how you insert hierarchical data in SQL. In this tutorial, I'm going to show you how to copy data from one table to another. For example, in our orders table, currently we have about a dozen records. Now let's say we want to create a copy of this table called orders archive and you want to insert every row that we have in this table into that new table. If you have 10 orders, we don't want to quote an insert statement with a ten set of values, that is very time consuming, so I want to show you a powerful technique to uniquely copy data from one table to another. First we need to create this new table, order archive. For that we're going to use the create table as statement. So create table orders archive as. Now right after that we write a select statement to get everything from the orders table. Now let's see what happens when we execute this query, there you go. So back in the navigator panel, we have to refresh this view by clicking on this icon over here, now we have a new table, orders archive, let's look at the data, so you can see all the orders are here and we have the exact same column as the orders table. However, if you open this table in the design mode, you cans ee that in this table, we don't have a primary key. So the order id column is not marked as a primary key. And also it's not marked as an auto increment column, so when we create a table using this technique MySQl will ignore these attributes, and that means if you want to explicitly insert the record into this new table, you have to supply a value for order id, because this column is no longer an auto increment column. So, using create table as statement you can quickly create a copy of a table, now we refer to this select statement as a sub query, so a subquery is a select statement that is part of another SQL statement. Now we can also use a sub query and an insert statement and that is a very powerful technique. It allows us to do really cool things. Let me show you. So first, let's right click the orders archive table, and click on truncate table, because we want to delete all the data in this table. Alright, it's asking for confirmation let's truncate the table, so now back to this table. Let's refresh the table, we don't have any records here, alright? Now back to our query editor, let's say you want to copy only a subset of records from the orders table into this table, like all the orders placed before 2019. So first let's select everything from the orders table where order date is less then 2019, January 1st. So, these are all the orders, order s copy these orders into he orders archive table. So we can use this select statement as a subquery in an insert statement, we write insert into orders archive now we don't need to supply the column names, because we're going to play values for every column that we have in this query. So, we did that, and this is ane xample of using a select statement as a subquery in an insert statement. Let's execute this, alright, now back to the table, let's refresh the records we only have the orders placed before 2019. Alright, here's a really, really, really coo exercise back to our SQL invoicing database. Look at the invoices table. So in this table, we have these columns, (?) id number, client id number which is associated or related to the client id column, in the clients table, followed by a few other columns, now let's say you want to create a copy of the record in this table, and put them in a new table called invoices archive. However in that table, instead of the client id column, we want to have the client name column, so you want to join table with the clients table, and then use that query as a sub query in a create table statement. Also, to mae the exercise more interesting, I want you to copy only the invoices that do have a payment. So if you look over here, this payment data column here, determines if a payment has been made, towards this invoice or not. So select only the invoices that do have a payment date, it's a really really good exercise, spend two to three minutes on this and then come back and continue watching. Alright, first I'm going to use the SQL invoicing data, base, now let's select everything from the invoices table and join it to the clients table. here I'm going to use the using statement to simplify my join. What column are we going to use for joining? The client id column. Let's execute this query up to this point. Alright, so first we see client id column is used for joining these tables, after that we have the columns from the invoices table like invoice id number and so on. Followed by the columns from the clients table. Name address and so on. Obviously we don't want all these columns, we only want the columns from the invoices table but we should replace the client id column with he client name column. So let's have a quick look at the design of the invoices table here we have invoices id, number, client id, we want to replace this column with the client name. Back to our query, I'm going to pick, invoice id, number and then client.name, let's rename it to client what other columns do we have here? We have invoice total and payment total so let's add those as well, invoice total as well as payment total, we also have three columns, for dates, invoice date, due date, and payment date, so, let me close the navigator panel. Invoice date payment date and due date. Now technically because these columns only exist in the invoices table, we don't have to prefix them with the table alias. So we can simplify the code like this, however, I personally prefer to prefix them, because that gives me a clear picture of how I'm joining these tables. It's just a personal preference another developer might disagree and that's fine, so whatever you prefer. That's perfectly fine, let's execute the query and make sure we get the right result, so we have the invoice ID number client beautiful, followed by these other columns, now I want to filter the result, and return only the invoices that do have a payment. So we can either return records that have a payment date, or the records that have a payment total of greater then 0. Both are perfectly fine, so back to our query, down at the bottom, let's add the where clause, where payment date is not null. That's better. Let's execute the query one more time, now we get only these handful of invoices, beautiful, finally let's use our query, as a subquery in a create table as statement. So right before select we type create table, invoices, archive, as there you go, let's execute the query beautiful, now back to the navigator panel, let's refresh the view, so here's our new table, invoice and archive, let's look at the data, there you go. You only have the invoices page and here's the name of the client for each invoice. Beautiful. Now just note that if you execute this query one more time, you're going to get an error because we already have a table called invoices archive. Later in the course I will show you how to draw tables, that's pretty easy, but for now you can just right click and go to draw table and then confirm alright, and then you can run the query one more time. In this tutorial I'm going to show you how to update data in SQL. So back to our invoices table, look at the first record here. The payment total for this record is 0, and obviously there is no payment date. Now let's imagine that there was a problem int he system that recorded this information. Let's say the client paid ten dollars for the invoice. So we should update this record in this table. That is very easy, back ti our query editor, window, we use the update statement to update one or more records in a table. What table? In this case invoices. Next we add a seth clause and this is where we specify a new value for one more or columns. In this case we want to update payment total. Let's say to ten dollars. We should also update payment date. So here's a column to add more columns we set this to date value, let's say 2019, March 1st, and then we type out a condition, with this condition we identify the record or the records that need to be updated. In this case we want to update the invoice number 1. So, back to our query, we type out invoice id equal to 1. Let's execute this. Beautiful, Now back to our table, let's refresh the data by clicking on this icon. Alright, we can see that payment total is updated to ten. And we also have a payment date. Beautiful. Now lets say we actually updated the wrong record, maybe we should have updated invoice number 3, so we should update this table one more time, and restore the original values in this column, back to our query we can set the payment total to 0, and the payment date to null. So we can use the null keyword to insert the null value in a column that accepts null values. Now back to the navigator panel, let's open the table in the design mode. We can see that the payment total column has a default value of 0, and the payment date column has the default value of null. So back in our query we can also set payment total tod default and MySQL will use the default value for this column, which is in this case 0. So, let's execute this statement one more time, beautiful. Now, back to the table, let's refresh the data, so payment total is set to 0. And payment date is null. Beautiful. Now let's go ahead and update the third payment. Look at the invoice total. That is $147. For this example let's imagine that the client made 50% of the total amount on the due date. So, back to our query editor window, instead of using a literal value window here like $70 we can write an expression, we want to calculate 50% of invoice total. So invoice total, x 0.5. Now let me break this code into multiple lines so we can see clearly, now we should set the payment date, as I told you this client made the payment on the due date, so we can set this to due date. Whatever value we have in this column will be used to set the payment date. Now obviously we need to update the invoice id, number 3, now back in the table, let's refresh the data. Alright look, payment total is updated, and it's set to almost 50% of he invoice total. However, this number is truncated so we don't have the digits after the decimal point. Don't worry about it for now, we'll come back to this when we talk about data points later in the course. Also we can see that payment date is set to the same value we have in the due date column. In the last tutorial we learned how to update a single record using the updates statement. Now if you want to update multiple records, the syntax is exactly the same, but the condition you type out here, has to be more general. For example, back to the invoices table, you can see that we have multiple invoices for client number 3. You can write a statement to update all the invoices for this client. So back to our query editor window, we change our condition to, where client id equals 3. However, if you execute this statement with MySQL workbench which is the software we've been using in this course, you're going to get an error, because by default, MySQL workbench runs in the safe update mode. So it allows you to update only a single record. You're not going to have this problem if you use another client for MySQL or if you write this statement in your application code this is only specific for MySQL workbench. Now let me show you how to get around this. On the top we go to MySQl workbench menu and then preface this. On this dial up box, on the left side, click on SQL editor and then down on the bottom, untick this checkbox, save updates, so this prevents you from accidentally updating or deleting a bunch of records in a table, so let's goa head with this, now we need to reconnect to this instance of MySQL. So, let's copy all the code here, and close this local instance window. Alright? Now, on the home page, double click this connection to reconnect, there you go, and then paste all that Sql code. Now let's execute this, beautiful, all the invoices for client number 3 are updated. Here we can also use the in operator, let's say we want to update all the invoices for clients number 3 and number 4. So all the operators you learned to use in the where clause also apply here. Now technically this where clause is optional, so if you want to update all the records in a table, you simply leave it out. Alright here's your exercise for this tutorial. Back to our SQL store database, write a SQL statement to give any customers, born before 1990, 15 extra points. Alright first we're going to use SQL store, then, write an update statement. To update the customers table, set the points to point plus 15, so here we're using the expression to update the points column, for anyone born before 1990. So where birth date is less then 1990, January 1st. Alright, let's execute this query, alright, now let's open up the customers table one more time, so anyone who was born before 1990 now has an extra 50 points. In this tutorial we're going to learn how to use subqueries in an update statement, it's extemely powerful, so we're going to continue with the example from the last tutorial, but we're going to make it more interesting. Here we're updating all the invoices for client number 3, but what if we don't have the id of the client? We only have the name? For example, you might even have an application, and in that application the user types in the name of the client, so first we should find the id for that client, and then use that id to update all the invoices. How do we do that? Well, let's have a quick look at our clients table, so here we have this client my words, let's say you have the name, you want to find the id. So back to our query window. After our update statement I'm going to write the select statement to select the client id column, from the clients table, where name equals my works. Now here we have a syntax error, because we didn't terminate the last don't worry about that, we're going to get back to that in a second. Let's just select these few lines and execute this query. The idea of this client is 2. Beautiful. Now we can use this select statement as a subquery in a update statement. So as I told you before, a subquery is a select statement that is within another SQL statement. So, instead of hard coding 3 here, we're going to use this select statement as a subquery, but we need to put it in parenthesis, so MySQL will execute this query first, it will return the client ID and then use it in this condition. So for clarity let's remove the line break and indent these few lines. So this is the end result. Now we execute this query, and this updated all the invoices for this client. Now, what if this query returns multiple clients? For example, back to the clients table, let's imagine you want to update the invoices for all clients located in New York or California. So, we need to update our subquery, like this, where state in California, and New York. Now before executing the entire statement, let's just select our subquery and execute it to see what we get. So we get two client ID's, one and three, beautiful, now because this query, this subquery returns mutliple records, we cannot use an equal sign here anymore, so we need to replace this with an in operator. And now this statement updates the invoices for all the clients located in these two statements. Let's execute it, beautiful, everything worked. So as a best practice, before executing your update statement, run your query to see what records you're going to update. So you don't accidentally update the records that shouldn't be updated. Now here we have a subquery but even if we didn't have a subquery, you could still query the records that we're going to update. Let me show you. So let's imagine we're going to update all the invoices where payment date is null. Before executing this entire update statement, I would run a query like this. Select, start I would start from invoices where payment date is null. Now let's execute this query, these are the two records that don't have payment date, so once we're confident that we're updating the right records, then, we come back here, and get rid of this select statement, and just attach the where clause to our update statement. Alright, here's your exercise for this tutorial, back to our SQL store database, look at the orders table, as you can see, several orders don't have a comment, I want you to write a SQL statement to update the comments or orders for customers who have more then 3000 points. So customers who have more then 3000 points, regard them as gold customers. Find their orders, if they have placed an order update the comments column and set it to gold customer. That's a really good exercise. Alright, first we need to find the gold customers, so select everything from the customers table, where points is greater then 3000. And by the way, because current database is SQL invoice we either have to type out a use statement on the top, or double click this database before executing this query. So, there you go. We have three gold customers now we need to get the ID of these customers to use them in an update statement. So, we only select customers Id here and then select this statement as a subquery in an update statement. So, update, orders, set comments to gold customer, where customer id because we're dealing with multiple customer id's we need to use the in operator and then to use it, as a subquery, we need to enclose it in parenthesis. Let's indent the code, that's better, so here is the final solution. So you have learned how to insert and update data, in this lecture, we're going to finish this section by learning how to delete data. That is very easy. We use the delete from statement to delete records from a table. Let's say the invoices table. Now optionally we can add a search condition to identify the records we want to delete. If you don't write this where clause with this statement, we delete all the records in this table. And obviously, that's very dangerous, so be very careful when executing this statement. Now here let's say we want to delete the invoice with the id 1, so where invoice id goes to 1. Now here we can also use subqueries, let's say we want to delete all the invoices for the client called my works. First let's find this client, so select everything from the client's table where name equals to my works. Let's execute the second query, so here's our client, now we can get this client id and use it in our search condition. So where client id equals 2, this is where we add our subquery, there you go, just like before, beautiful. So this is how we can delete data, in SQL. Alright, we're done with this section, but before going to the next section, I want you to restore all these databases to their original state. Because in this section we added some data, we updated some data, we deleted some records, so if you don't restore these databases you may see different results going forward. So, restoring these databases is pretty easy. Here in My SQL workbench, on the top go to the file menu and open SQL script. Then navigate to the directory where you stored the SQL scripts for this course, in case you lost that directory, go back to the first section, you have a lecture for downloading the supplementary materials. So in this directory open create databases.SQL. Now execute this script to recreate all of our databases. Alright, beautiful, now let's open up the navigator panel, you can see the databases disappear from here, simply click on this refresh icon. Beautiful. Alright, we're done with this section, I will see you in the next section. Hey guys, Mosh here, in case you haven't seen my website yet, head over to codewithmosh .com. This is my coding school where you can find plenty of courses on web and mobile application development. In fact recently I published a complete SQL course that is about 10 hours long, and it teaches you everything you need to know from the basic to advanced topics such as database design, security, writing complex queries, transactions, events and much, much more. These are the topics that every software engineer must master. This Youtube course you've been watching is the first three hours of my complete SQL course that is about 10 hours long. So if you want to master SQL and get job ready, I highly encourage you to get involved in my complete SQL course. You can watch it anytime, anywhere, as many times as you want, you can watch it online or download the videos. The course comes with a 30 day money back guarantee and a certificate of completion that you can add to your resume. The price for this course is $149 but the first 200 students can get it for just over $100. So if you're interseted, the link is below this video.
