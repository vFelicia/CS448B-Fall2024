With timestamps:

00:01 - [Music]
00:05 - so what is Redux Redux is a library that
00:09 - helps you manage the state of your
00:11 - application and is something that you
00:13 - should use in medium to large single
00:16 - page applications with complex data
00:19 - flows so if you're building a simple
00:21 - application with simple data flow you
00:23 - don't necessarily need redux
00:25 - and in fact Redux can add extra
00:28 - unnecessary complexity your application
00:31 - so what do I mean by these large single
00:33 - page applications well in a typical
00:36 - angular app without the Redux archit
00:38 - without the Redux architecture you know
00:41 - that each component maintains the state
00:44 - and the logic behind the view this model
00:47 - aligns perfectly with the encapsulation
00:49 - principle of object-oriented programming
00:51 - however it can be a problem when you
00:54 - have multiple views that are working
00:56 - with the same piece of data and do not
00:59 - have a parent-child relationship in this
01:02 - situation we often have multiple copies
01:05 - of the same data that are independent of
01:08 - each other so whenever you update the
01:10 - model we need to do some extra work to
01:14 - keep the other views in sync for example
01:17 - think of Facebook on Facebook we have
01:19 - three views that represent the current
01:21 - state of users messages on the
01:24 - navigation bar we have this icon that
01:26 - shows the number of new messages and if
01:29 - we're on the messages page we have a
01:31 - view like this and irrespective of what
01:34 - page we are on we can also have multiple
01:36 - chat tabs on the bottom of the screen
01:39 - these are independent views that need to
01:42 - be in sync and what is important here is
01:45 - that they do not have a parent-child
01:47 - relationship so this navigation bar is
01:49 - not a parent or child of other views
01:52 - here if it was the passing data would be
01:54 - simple it will simply use the input
01:57 - properties of the child components to
01:59 - pass the data down the subtree but since
02:02 - these views are independent if you want
02:05 - to keep them in sync we have to do some
02:07 - extra work a common solution is to use
02:10 - events and sooner or later that will
02:13 - turn
02:13 - to an event spaghetti in a large code
02:16 - base we have events published all over
02:18 - the place and then to track what happens
02:20 - to the application state we have to jump
02:23 - all over the code to see what's going on
02:24 - the problem with this approach is that
02:27 - data can be updated in an unpredictable
02:30 - way when there is a bug we have to jump
02:33 - all over the code to figure out how the
02:35 - data is flowing and how the application
02:37 - state is updated in multiple places so
02:40 - it's unpredictable
02:42 - also adding a new feature becomes a
02:45 - challenge because once again we don't
02:47 - know what is the impact of this new
02:49 - feature on the application space if it's
02:51 - touching the same piece of data that is
02:53 - in different places that needs to be
02:55 - kept in sync again we have to do a lot
02:58 - of hard work so Facebook had this
03:01 - problem back in 2014 and that's why they
03:04 - introduced the flux architecture now
03:07 - Redux is a simplified and lightweight
03:10 - implementation of this architecture that
03:13 - provide a clean and elegant solution to
03:15 - this problem maintaining the application
03:18 - state in predictable way so there's no
03:21 - surprises now apart from this Redux
03:24 - provides a number of other benefits the
03:27 - first one is that it decouples your
03:29 - application from a presentation
03:31 - framework like angular so you can
03:34 - implement a big chunk of your
03:35 - application and its presentation logic
03:37 - using simple functions that are
03:39 - completely decoupled from angular or any
03:42 - other presentation frameworks and then
03:45 - you can decide if you want to use
03:46 - angular or maybe you want to use react
03:49 - so it allows you to postpone decisions
03:53 - about external libraries and frameworks
03:55 - which is one of the attributes of clean
03:57 - architecture as you might have heard
03:59 - from Uncle Bob the second benefit is
04:03 - that it makes it easier to test your
04:05 - application without marks spice and any
04:08 - other tricks that can make testing both
04:10 - complex and error prone because Redux is
04:13 - heavily based on functional programming
04:15 - so as you will see in this section we'll
04:18 - be writing simple functions take your
04:20 - state and return a new state that's all
04:22 - these functions are really easy to test
04:24 - and this means you can write
04:26 - your tests before your production code
04:28 - which basically means test-driven
04:30 - development or TDD the third benefit is
04:34 - that you can get some really cool tools
04:36 - as part of your development one such
04:38 - example is Redux developer tools
04:40 - extension that you can add to Chrome
04:42 - Firefox and other browsers it makes it
04:46 - incredibly easy to debug your
04:48 - application by allowing you to inspect
04:51 - the application state in such a way that
04:53 - we have never seen before this is
04:55 - actually one of the features that I was
04:58 - really impressed with and you're going
05:00 - to see that in this section and the last
05:03 - benefit is that redux makes it
05:05 - incredibly easy to implement features
05:07 - like undo and redo so if you need this
05:10 - functions in your application yes you
05:12 - can implement it without redux but using
05:14 - redux makes your life much easier now
05:18 - all these fancy benefits of course
05:20 - become really cut just like many other
05:23 - architectural patterns you're going to
05:25 - write a bit more code and you'll have
05:27 - more moving parts in your application so
05:30 - use redux only if you're building and
05:32 - medium to large single page application
05:35 - with complex views and data flows here
05:38 - are some scenarios you have independent
05:41 - copies of the same data in multiple
05:43 - places you have multiple views that need
05:46 - to work with the same data and be in
05:47 - sync
05:48 - the users can collaborate and work on
05:51 - the same piece of data so data can be
05:53 - changed by user a and at the same time
05:55 - user B can change the same data or data
05:59 - can be updated by multiple actors so it
06:01 - can be changed as a result of user
06:03 - actions and at the same time it may
06:05 - arrive from the server either for
06:07 - polling or push notifications so if you
06:10 - have these scenarios in your application
06:11 - it would potentially benefit from redux
06:14 - so remember when building a new app you
06:18 - don't need to automatically reach for
06:20 - redux you can always start simple and as
06:23 - your application grows then you can
06:25 - refactor existing components and use
06:27 - Redux to manage the application state in
06:29 - a predictable and deterministic way next
06:33 - we're going to look at the building
06:34 - blocks of redux
06:38 - in Redux we have three pieces the store
06:42 - actions and reducers let's explore these
06:45 - one by one the store is a single
06:48 - javascript object that contains the
06:51 - state of the application you can think
06:53 - of it as a local client-side database so
06:57 - here we can have properties like the
06:59 - list of messages number of new messages
07:01 - to be displayed on the navigation bar
07:03 - whether chat sounds are enabled and so
07:06 - on different views and components use
07:10 - different parts or different slices of
07:12 - the application state depending on their
07:14 - functionality and this also means if
07:17 - different components need to work with
07:20 - the same slice there is only one copy of
07:23 - that slice throughout the application so
07:26 - once a component modifies that slide the
07:28 - changes are immediately visible to other
07:31 - components we don't have multiple
07:33 - independent copies now the first
07:36 - question you might have is wouldn't it
07:39 - consume too much memory not really
07:41 - unless you're storing 10,000 or more
07:44 - objects in this store and then I would
07:46 - ask you why would you do that anyway so
07:49 - for the most part is ok to have a single
07:51 - object to store the application States
07:55 - the second piece is the actions actions
07:57 - are playing javascript objects that we
08:00 - present something that has happened in
08:02 - the application so semantically they're
08:05 - more like events if you have some
08:08 - background in CQRS
08:09 - architectural style you should know the
08:11 - difference between commands and events
08:14 - commands or actions represent something
08:17 - that should happen like posting a
08:19 - message
08:20 - whereas events indicate that something
08:23 - has happened like a message was posted
08:26 - actions in redux are semantically events
08:29 - here are a couple of examples when the
08:33 - user reads the message we can represent
08:35 - this event using an action like this as
08:38 - another example if the user posts a
08:41 - message we can have an action like this
08:43 - so these are simple data structures and
08:46 - don't have any logic and by convention
08:49 - we use a type property to specify the
08:52 - type of each action an action can have
08:55 - additional properties related to the
08:57 - event
08:58 - it just happens and the last piece
09:01 - reducer the reducer is a term that often
09:05 - confuses a lot of beginners to redux
09:07 - unfortunately the terms used in the
09:09 - redux library are not very helpful
09:11 - so actions are really events and
09:14 - reducers can be a little bit confusing
09:16 - to beginners now reducer is basically a
09:19 - function that specifies how the state
09:22 - changes in response to an action you can
09:25 - think of it as an action handler or an
09:28 - event handler that determines how this
09:30 - state is changed now what is critical
09:33 - here is that the reducer does not modify
09:37 - the state it only returns the new state
09:39 - and then the store will internally
09:42 - update the state so nowhere in the
09:45 - application we're going to directly
09:46 - modify the state this is the
09:48 - responsibility of the store it keeps the
09:50 - state and updates it whenever necessary
09:53 - so these are the building blocks of
09:55 - redux
09:56 - now it's reducers should be pure
09:59 - functions but what do I mean by pure
10:02 - well that's the topic for the next
10:04 - lecture
10:06 - so what is a pure function well a
10:10 - function is pure if we give it the same
10:12 - input we always get the same output no
10:15 - matter how many times we call that
10:17 - function so it shouldn't have any side
10:19 - effects let's take a look at a few
10:22 - examples so this function is impure
10:25 - because every time we call it its
10:27 - modifying its argument so if the value
10:31 - of the count property of the input is
10:33 - initially zero and we call this function
10:35 - ten times to increment it instead of
10:38 - getting one we get ten so in a pure
10:41 - function we should not mutate or modify
10:44 - any of the arguments here's another
10:46 - example in this function we're making
10:49 - back end calls by a disservice and this
10:52 - is an example of a side effect so every
10:55 - time we call this function our
10:56 - application state store it in a database
10:58 - on the server it's modified and here's
11:01 - the third example in this function we
11:04 - are updating the value of the count
11:05 - property based on a random number
11:08 - generated by the math class so with this
11:11 - function if they give it the same input
11:13 - we cannot ensure that we always get the
11:15 - same output the output is different
11:18 - every time because we are using an
11:20 - impure function so in a pure function we
11:23 - should not use math dot random or data
11:25 - now or any other functions that return a
11:27 - different value every time we color now
11:30 - let's take this first example and change
11:33 - it to a pure function so instead of
11:35 - incrementing this count property you
11:38 - return a new object with accounts
11:41 - property and the value of this count
11:43 - property would be the value of the
11:45 - original count plus 1 if we call this
11:48 - function 10 times and give it the same
11:50 - input we always get the same output so
11:53 - if count is initially 0 and we call this
11:55 - function 10 times we'll get 1 because
11:58 - this function is not modifying its
12:00 - argument so in redux our reducers should
12:04 - be pure functions now let's take this
12:06 - example and modify it a little bit so it
12:09 - looks like a reducer function in redux
12:11 - in redux
12:14 - user functions always take two arguments
12:16 - the current state and an action then
12:20 - based on the action type they return a
12:23 - new state so typically use a switch
12:26 - statement on the type property of the
12:29 - action and based on the value of the
12:31 - type property we return a new state so
12:35 - let's imagine action the type is
12:37 - increment then we return a new state
12:40 - with the updated property so you're not
12:42 - going to modify the original state pass
12:45 - the dysfunction now if you have never
12:47 - done functional programming before this
12:49 - concept is new and confusing to you I
12:51 - totally understand that so you might be
12:54 - asking what is the point of this why are
12:57 - we not allowed to mutate or modify the
12:59 - state you always have to return a new
13:01 - state well there are a number of
13:03 - benefits to this approach the first
13:06 - benefit is that pure functions are
13:08 - really easy to test imagine you want to
13:11 - write a test for this function you don't
13:13 - need any marks any spies or any other
13:15 - tricks you simply call this function
13:18 - give it an input and make an assertion
13:20 - about the output as simple as that the
13:24 - second benefit is that this approach
13:26 - makes it really easy to implement
13:27 - features like undo and redo because we
13:31 - always keep the previous state instead
13:33 - of modifying it and the third benefit is
13:36 - that it gives us a powerful tool which
13:38 - we call time travel debugging so using
13:41 - the tool that I will show you later in
13:43 - this section we can travel back in time
13:45 - and look at our application state as
13:47 - different actions are triggered in the
13:49 - application we can see how the
13:51 - application state is modified in every
13:54 - step and this makes it really easy to
13:56 - find bugs and fix them but once again it
13:59 - only makes sense if you're building a
14:01 - complex application with complex
14:03 - dataflow for a calculator application he
14:06 - doesn't need Redux but if you have
14:08 - complex views complex data structures
14:10 - and things have to be modified in
14:12 - different places then you can look at
14:13 - the application state and see exactly
14:15 - how its modified
14:20 - all right now let me show you how to add
14:22 - Redux to an angular app there are many
14:25 - implementations for Redux but the two
14:28 - common implementations are mg RX / Store
14:31 - and ng - - Redux these are the most
14:35 - popular ones and they're very very
14:36 - similar in terms of their API angel -
14:40 - Redux is built on top of the real Redux
14:43 - library and it's compatible with most of
14:46 - the redux ecosystem
14:47 - it adds bindings for angular 2 so you
14:50 - can easily connect your angular
14:51 - components with redux ng IX flash store
14:55 - on the other hand has done the routes of
14:57 - reimplemented the Redux pattern in an
15:00 - angular 2 and rx friendly way this means
15:03 - it's not compatible with other libraries
15:06 - build for redux so in this section I'm
15:09 - going to use ng 2 - redux but I wanted
15:12 - you to be aware of ng RX / store because
15:16 - there are a lot of blog posts and
15:17 - questions on Stack Overflow that are
15:19 - centered around this implementation
15:22 - alright now before we get started make
15:25 - sure you have the latest version of
15:27 - angular CLI so on my machine I'm using
15:32 - angular CLI version 1 beta 26 if yours
15:37 - is older simply do NPM install angular -
15:41 - CLI - JEE all right now I'm going to
15:45 - create a new folder Redux - demo going
15:49 - to this folder and run ng in it all
15:55 - right now if you look at package that
15:57 - JSON you'll notice that we're using
16:00 - angular 2 point 3 point 1 this is very
16:03 - important if you want to follow along
16:05 - with this lecture otherwise when you add
16:07 - Redux you're going to get an error in
16:09 - NPM because the latest version of redux
16:12 - is not compatible with older versions of
16:15 - angular so make sure you've got angular
16:16 - 2 point 3 point 1 or higher now back in
16:20 - terminal npm install redux so this is
16:23 - the main redux library for JavaScript
16:25 - it's got nothing to do with angular then
16:28 - we add n - 2 - redux
16:31 - which provides an angular module for
16:33 - dependency injection as well as some
16:35 - other helpers that we're going to use in
16:37 - this section so add this to the project
16:40 - now if for any reasons you're having
16:43 - difficulty creating a new angular
16:45 - project and adding these dependencies
16:47 - I've attached this project for you to
16:49 - this lecture so simply download it and
16:52 - then do NPM install and then NGS serve
16:57 - now if you head over to localhost port
17:01 - 4200 you get our familiar angular 2 app
17:04 - so now let's start implementing redux in
17:07 - this application first I'm going to go
17:10 - in the source folder under app add a new
17:14 - file store the TF here I'm going to
17:19 - export an interface called a app state
17:23 - so this interface determines the shape
17:26 - of our store for now we're going to
17:28 - leave it empty but as we go through this
17:30 - section we're going to add some
17:32 - properties to this interface so this
17:34 - interface will determine what properties
17:36 - we're going to have in our store now I'm
17:40 - also going to export a function which I
17:43 - call route reducer so we start with one
17:47 - reducer function here and as our
17:49 - application grows we can break down this
17:51 - function into smaller more maintainable
17:54 - functions each focusing on one domain in
17:57 - the application now as you saw in the
18:00 - last lecture each reducer takes two
18:02 - parameters the current state and an
18:05 - action and it returns a new state so for
18:11 - now I'm just going to return the state
18:12 - that we get here we are not going to
18:14 - implement a switch case here yet that's
18:17 - going to come in the next lecture so
18:18 - this is a very basic reducer it doesn't
18:21 - do anything all right save now let's go
18:25 - to app the module on the top we need to
18:30 - import a couple of types from ng to -
18:33 - Redux so import from
18:37 - ng to - redux first one is ng redux
18:41 - and the second is ng redux module now we
18:45 - need to import this module into our main
18:48 - module and that's use or dependency
18:50 - injection so ng Redux module now we want
18:57 - to create a constructor for app module
19:03 - this constructor should get an object
19:06 - called ng Redux which is of type ng
19:10 - Redux that we imported on the top now
19:14 - this type is generic so we need to
19:16 - specify a generic parameter here in
19:18 - angle brackets and what we pass here is
19:21 - the interface that we declared earlier
19:23 - so this interface determines the shape
19:26 - of our store so I'm going to go on the
19:29 - top import I app state and route reducer
19:36 - from current folder slash store now back
19:42 - in the constructor I'm going to use I
19:45 - app state as the generic argument for ng
19:49 - Redux and the final step we use this
19:53 - injury Dex object here and call
19:56 - configure store this is to initialize
20:00 - our store now the first argument to this
20:03 - method should be our route reducer so
20:06 - route reducer and the second argument is
20:09 - our initial store so I'm going to pass
20:12 - an empty JavaScript object this is our
20:16 - store object that will eventually get
20:18 - updated as we go through this section
20:20 - with this if you save the changes and
20:24 - get back to the browser the application
20:26 - should still work and we shouldn't have
20:28 - any errors in the console so let's
20:30 - double check that okay here's the
20:32 - console there is absolutely no errors
20:34 - perfect so we have successfully
20:37 - installed Redux in this project next
20:41 - we're going to work with action all
20:44 - right now let's see how we can use an
20:46 - action so here in app component template
20:48 - I'm going to add a button call it
20:51 - increment
20:53 - handle the colliculus and bind this to
20:58 - the increment method of our components
21:00 - I'm also going to add a counter here so
21:06 - when we click this button this counter
21:08 - is going to be incremented now let's go
21:11 - to add component stickler counter here
21:15 - and initialize it to zero I'm going to
21:19 - add the increment method so in a typical
21:22 - angular app this is how we implement
21:25 - this method you modify the state
21:27 - directly here however when using the
21:31 - Redux architecture we don't modify the
21:33 - state here instead with dispatch and
21:36 - action this action goes into the store
21:39 - the store knows our route reducer so it
21:43 - passes action to the route reducer and
21:45 - then the reducer looks at the action and
21:47 - based on the type of the action it will
21:50 - return a new state and then the store
21:54 - will update its state internally so
21:57 - let's see how we can implement this
21:59 - first I'm going to go on top of this
22:01 - file and import mg Redux from ng to -
22:07 - Redux
22:08 - so this is the primary type that the
22:11 - worked with in Redux applications now
22:14 - I'm going to create a constructor and
22:19 - inject ng Redux here ng Redux now you
22:24 - remember that this is a generic type so
22:26 - here we need to specify a generic
22:28 - argument which is I app state that's the
22:32 - interface that determines the shape of
22:35 - our store so I'm going to import I have
22:38 - state on the top
22:45 - like this
22:48 - constructor I'm going to apply the
22:51 - private modifier here so we can access
22:53 - this in the increment method now instead
22:57 - of modifying the state directly you're
23:00 - going to call this that injury ducks
23:02 - that's dispatch here we need to pass an
23:06 - action object and as you learn earlier
23:09 - an action is a simple object that has a
23:12 - type property so this is how we dispatch
23:17 - an action now some actions may carry
23:20 - extra data about the event that just
23:22 - happen for example if the user posted a
23:25 - message here you can have properties
23:28 - like body subject and so on but in this
23:33 - example we don't have to worry about
23:34 - that so delete every time we define a
23:40 - new action we need to go to our reducer
23:42 - and determine how the state will change
23:45 - in response to the action so let's go to
23:48 - the store here I'm going to add a switch
23:53 - statement on action that type and it is
23:58 - increment I'm going to return a new
24:01 - state with updated counter so currently
24:04 - it's not clear what is the type of this
24:07 - data object so I'm going to apply a type
24:09 - here this should be of type I app state
24:12 - so we get the current state of the store
24:15 - and then we return a new state so again
24:19 - I'm going to add a type here this
24:21 - function will return I AB state and now
24:26 - because we need to work with a counter
24:28 - we need to store its current value in
24:30 - the store so in I app state interface
24:33 - I'm going to declare a property counter
24:36 - of type number okay and now in response
24:40 - to the increment action I'm going to
24:43 - return a new object with counter set to
24:48 - state that counter which is the current
24:49 - value of the counter plus one
24:53 - so note that I'm not modifying the
24:55 - original state here I'm returning a new
24:58 - state and the final step earlier in app
25:02 - module here we passed the initial state
25:06 - of our store now we have a red underline
25:09 - here because our store now has a counter
25:13 - property that we have not initialized so
25:17 - back in app module I'm going to counter
25:20 - to zero so let's quickly review the
25:23 - steps and then I will show you how to
25:25 - improve this code in the app component
25:28 - we injected ng Redux in the constructor
25:31 - and in the increment method instead of
25:35 - modifying the state directly we dispatch
25:37 - an action then we went to our store we
25:42 - modified the route reducer and added
25:44 - support for the increment action then as
25:47 - part of this we also have to modify I
25:49 - app state so now we have this counter
25:51 - property and finally in the app module
25:55 - we modified this line here to set the
25:58 - initial state of our store now there are
26:01 - a couple of things we can improve in
26:02 - this code the first issue I see here is
26:05 - the use of this magic string in two
26:08 - different places we have uses in the app
26:11 - component and also in the store now the
26:14 - problem with this is that we have
26:15 - duplicated this in two different places
26:17 - and if we have a typo in the code our
26:21 - code is not going to work so it's better
26:23 - to extractives into one place define it
26:25 - as a constant so this way we won't have
26:28 - a type of problem and if you want to
26:30 - change this to something else in the
26:31 - future there is only one place we need
26:33 - to change so in the app folder I'm going
26:37 - to add a new file called actions and
26:41 - here I'm going to export a constant
26:43 - called
26:44 - increments and set it to increment now
26:48 - we can replace those two magic strings
26:50 - with this constant so first in the store
26:54 - on the top I'm going to import increment
26:58 - from actions and then I'm going to
27:02 - replace this magic string here increment
27:06 - now at the save time I'm going to copy
27:08 - this line and go to app component on the
27:13 - top paste it and once again replace this
27:18 - magic string with a constant that's the
27:21 - first improvement now the second
27:23 - improvement you notice that when we
27:26 - changed I app state here we had to go to
27:29 - the app module and modify this initial
27:33 - state object here so we are going back
27:35 - and forth between different files and
27:37 - this is really not good practice so
27:40 - let's go back to the store here I'm
27:42 - going to export a constant and call it
27:46 - initial State this is a type I app state
27:51 - and I'm going to set this so this object
27:54 - would counter set to zero now time we're
27:58 - going to modify the I app state
28:00 - interface we could immediately modify
28:02 - this initial State if necessary we don't
28:04 - have to jump back and forth between the
28:06 - store and the app module so now let's go
28:09 - to the app module and import initial
28:13 - state from the store and then replace
28:16 - this object here with initial State
28:21 - now if you run
28:23 - vacation at this point and click this
28:24 - button the counter is not incremented
28:28 - because we have only implemented the
28:30 - part for updating the state reading the
28:33 - state from the store is something else
28:35 - and that's what we're going to look at
28:37 - in the next lecture
28:39 - hey thank you for watching my youtube
28:41 - video my name is Maha Madani and I'm a
28:44 - full-stack developer applause I'd author
28:47 - and in getting the instructor with about
28:49 - 14 courses at the time of recording this
28:51 - video so I've got lots of courses on
28:54 - both front end and back end development
28:56 - including three sharp energy framework a
28:58 - selectman MVC angular architecture unit
29:02 - testing and so on
29:03 - this video watch is actually part of my
29:06 - angular course on udemy that you can get
29:08 - with a discount using the link in the
29:10 - video description and if you want to see
29:13 - my other courses simply head over to
29:15 - programming with mass comm slash courses
29:17 - you can also subscribe to my YouTube
29:20 - channel to get free videos every week
29:22 - have a great day and I'll be back show
29:24 - [Music]

Cleaned transcript:

so what is Redux Redux is a library that helps you manage the state of your application and is something that you should use in medium to large single page applications with complex data flows so if you're building a simple application with simple data flow you don't necessarily need redux and in fact Redux can add extra unnecessary complexity your application so what do I mean by these large single page applications well in a typical angular app without the Redux archit without the Redux architecture you know that each component maintains the state and the logic behind the view this model aligns perfectly with the encapsulation principle of objectoriented programming however it can be a problem when you have multiple views that are working with the same piece of data and do not have a parentchild relationship in this situation we often have multiple copies of the same data that are independent of each other so whenever you update the model we need to do some extra work to keep the other views in sync for example think of Facebook on Facebook we have three views that represent the current state of users messages on the navigation bar we have this icon that shows the number of new messages and if we're on the messages page we have a view like this and irrespective of what page we are on we can also have multiple chat tabs on the bottom of the screen these are independent views that need to be in sync and what is important here is that they do not have a parentchild relationship so this navigation bar is not a parent or child of other views here if it was the passing data would be simple it will simply use the input properties of the child components to pass the data down the subtree but since these views are independent if you want to keep them in sync we have to do some extra work a common solution is to use events and sooner or later that will turn to an event spaghetti in a large code base we have events published all over the place and then to track what happens to the application state we have to jump all over the code to see what's going on the problem with this approach is that data can be updated in an unpredictable way when there is a bug we have to jump all over the code to figure out how the data is flowing and how the application state is updated in multiple places so it's unpredictable also adding a new feature becomes a challenge because once again we don't know what is the impact of this new feature on the application space if it's touching the same piece of data that is in different places that needs to be kept in sync again we have to do a lot of hard work so Facebook had this problem back in 2014 and that's why they introduced the flux architecture now Redux is a simplified and lightweight implementation of this architecture that provide a clean and elegant solution to this problem maintaining the application state in predictable way so there's no surprises now apart from this Redux provides a number of other benefits the first one is that it decouples your application from a presentation framework like angular so you can implement a big chunk of your application and its presentation logic using simple functions that are completely decoupled from angular or any other presentation frameworks and then you can decide if you want to use angular or maybe you want to use react so it allows you to postpone decisions about external libraries and frameworks which is one of the attributes of clean architecture as you might have heard from Uncle Bob the second benefit is that it makes it easier to test your application without marks spice and any other tricks that can make testing both complex and error prone because Redux is heavily based on functional programming so as you will see in this section we'll be writing simple functions take your state and return a new state that's all these functions are really easy to test and this means you can write your tests before your production code which basically means testdriven development or TDD the third benefit is that you can get some really cool tools as part of your development one such example is Redux developer tools extension that you can add to Chrome Firefox and other browsers it makes it incredibly easy to debug your application by allowing you to inspect the application state in such a way that we have never seen before this is actually one of the features that I was really impressed with and you're going to see that in this section and the last benefit is that redux makes it incredibly easy to implement features like undo and redo so if you need this functions in your application yes you can implement it without redux but using redux makes your life much easier now all these fancy benefits of course become really cut just like many other architectural patterns you're going to write a bit more code and you'll have more moving parts in your application so use redux only if you're building and medium to large single page application with complex views and data flows here are some scenarios you have independent copies of the same data in multiple places you have multiple views that need to work with the same data and be in sync the users can collaborate and work on the same piece of data so data can be changed by user a and at the same time user B can change the same data or data can be updated by multiple actors so it can be changed as a result of user actions and at the same time it may arrive from the server either for polling or push notifications so if you have these scenarios in your application it would potentially benefit from redux so remember when building a new app you don't need to automatically reach for redux you can always start simple and as your application grows then you can refactor existing components and use Redux to manage the application state in a predictable and deterministic way next we're going to look at the building blocks of redux in Redux we have three pieces the store actions and reducers let's explore these one by one the store is a single javascript object that contains the state of the application you can think of it as a local clientside database so here we can have properties like the list of messages number of new messages to be displayed on the navigation bar whether chat sounds are enabled and so on different views and components use different parts or different slices of the application state depending on their functionality and this also means if different components need to work with the same slice there is only one copy of that slice throughout the application so once a component modifies that slide the changes are immediately visible to other components we don't have multiple independent copies now the first question you might have is wouldn't it consume too much memory not really unless you're storing 10,000 or more objects in this store and then I would ask you why would you do that anyway so for the most part is ok to have a single object to store the application States the second piece is the actions actions are playing javascript objects that we present something that has happened in the application so semantically they're more like events if you have some background in CQRS architectural style you should know the difference between commands and events commands or actions represent something that should happen like posting a message whereas events indicate that something has happened like a message was posted actions in redux are semantically events here are a couple of examples when the user reads the message we can represent this event using an action like this as another example if the user posts a message we can have an action like this so these are simple data structures and don't have any logic and by convention we use a type property to specify the type of each action an action can have additional properties related to the event it just happens and the last piece reducer the reducer is a term that often confuses a lot of beginners to redux unfortunately the terms used in the redux library are not very helpful so actions are really events and reducers can be a little bit confusing to beginners now reducer is basically a function that specifies how the state changes in response to an action you can think of it as an action handler or an event handler that determines how this state is changed now what is critical here is that the reducer does not modify the state it only returns the new state and then the store will internally update the state so nowhere in the application we're going to directly modify the state this is the responsibility of the store it keeps the state and updates it whenever necessary so these are the building blocks of redux now it's reducers should be pure functions but what do I mean by pure well that's the topic for the next lecture so what is a pure function well a function is pure if we give it the same input we always get the same output no matter how many times we call that function so it shouldn't have any side effects let's take a look at a few examples so this function is impure because every time we call it its modifying its argument so if the value of the count property of the input is initially zero and we call this function ten times to increment it instead of getting one we get ten so in a pure function we should not mutate or modify any of the arguments here's another example in this function we're making back end calls by a disservice and this is an example of a side effect so every time we call this function our application state store it in a database on the server it's modified and here's the third example in this function we are updating the value of the count property based on a random number generated by the math class so with this function if they give it the same input we cannot ensure that we always get the same output the output is different every time because we are using an impure function so in a pure function we should not use math dot random or data now or any other functions that return a different value every time we color now let's take this first example and change it to a pure function so instead of incrementing this count property you return a new object with accounts property and the value of this count property would be the value of the original count plus 1 if we call this function 10 times and give it the same input we always get the same output so if count is initially 0 and we call this function 10 times we'll get 1 because this function is not modifying its argument so in redux our reducers should be pure functions now let's take this example and modify it a little bit so it looks like a reducer function in redux in redux user functions always take two arguments the current state and an action then based on the action type they return a new state so typically use a switch statement on the type property of the action and based on the value of the type property we return a new state so let's imagine action the type is increment then we return a new state with the updated property so you're not going to modify the original state pass the dysfunction now if you have never done functional programming before this concept is new and confusing to you I totally understand that so you might be asking what is the point of this why are we not allowed to mutate or modify the state you always have to return a new state well there are a number of benefits to this approach the first benefit is that pure functions are really easy to test imagine you want to write a test for this function you don't need any marks any spies or any other tricks you simply call this function give it an input and make an assertion about the output as simple as that the second benefit is that this approach makes it really easy to implement features like undo and redo because we always keep the previous state instead of modifying it and the third benefit is that it gives us a powerful tool which we call time travel debugging so using the tool that I will show you later in this section we can travel back in time and look at our application state as different actions are triggered in the application we can see how the application state is modified in every step and this makes it really easy to find bugs and fix them but once again it only makes sense if you're building a complex application with complex dataflow for a calculator application he doesn't need Redux but if you have complex views complex data structures and things have to be modified in different places then you can look at the application state and see exactly how its modified all right now let me show you how to add Redux to an angular app there are many implementations for Redux but the two common implementations are mg RX / Store and ng Redux these are the most popular ones and they're very very similar in terms of their API angel Redux is built on top of the real Redux library and it's compatible with most of the redux ecosystem it adds bindings for angular 2 so you can easily connect your angular components with redux ng IX flash store on the other hand has done the routes of reimplemented the Redux pattern in an angular 2 and rx friendly way this means it's not compatible with other libraries build for redux so in this section I'm going to use ng 2 redux but I wanted you to be aware of ng RX / store because there are a lot of blog posts and questions on Stack Overflow that are centered around this implementation alright now before we get started make sure you have the latest version of angular CLI so on my machine I'm using angular CLI version 1 beta 26 if yours is older simply do NPM install angular CLI JEE all right now I'm going to create a new folder Redux demo going to this folder and run ng in it all right now if you look at package that JSON you'll notice that we're using angular 2 point 3 point 1 this is very important if you want to follow along with this lecture otherwise when you add Redux you're going to get an error in NPM because the latest version of redux is not compatible with older versions of angular so make sure you've got angular 2 point 3 point 1 or higher now back in terminal npm install redux so this is the main redux library for JavaScript it's got nothing to do with angular then we add n 2 redux which provides an angular module for dependency injection as well as some other helpers that we're going to use in this section so add this to the project now if for any reasons you're having difficulty creating a new angular project and adding these dependencies I've attached this project for you to this lecture so simply download it and then do NPM install and then NGS serve now if you head over to localhost port 4200 you get our familiar angular 2 app so now let's start implementing redux in this application first I'm going to go in the source folder under app add a new file store the TF here I'm going to export an interface called a app state so this interface determines the shape of our store for now we're going to leave it empty but as we go through this section we're going to add some properties to this interface so this interface will determine what properties we're going to have in our store now I'm also going to export a function which I call route reducer so we start with one reducer function here and as our application grows we can break down this function into smaller more maintainable functions each focusing on one domain in the application now as you saw in the last lecture each reducer takes two parameters the current state and an action and it returns a new state so for now I'm just going to return the state that we get here we are not going to implement a switch case here yet that's going to come in the next lecture so this is a very basic reducer it doesn't do anything all right save now let's go to app the module on the top we need to import a couple of types from ng to Redux so import from ng to redux first one is ng redux and the second is ng redux module now we need to import this module into our main module and that's use or dependency injection so ng Redux module now we want to create a constructor for app module this constructor should get an object called ng Redux which is of type ng Redux that we imported on the top now this type is generic so we need to specify a generic parameter here in angle brackets and what we pass here is the interface that we declared earlier so this interface determines the shape of our store so I'm going to go on the top import I app state and route reducer from current folder slash store now back in the constructor I'm going to use I app state as the generic argument for ng Redux and the final step we use this injury Dex object here and call configure store this is to initialize our store now the first argument to this method should be our route reducer so route reducer and the second argument is our initial store so I'm going to pass an empty JavaScript object this is our store object that will eventually get updated as we go through this section with this if you save the changes and get back to the browser the application should still work and we shouldn't have any errors in the console so let's double check that okay here's the console there is absolutely no errors perfect so we have successfully installed Redux in this project next we're going to work with action all right now let's see how we can use an action so here in app component template I'm going to add a button call it increment handle the colliculus and bind this to the increment method of our components I'm also going to add a counter here so when we click this button this counter is going to be incremented now let's go to add component stickler counter here and initialize it to zero I'm going to add the increment method so in a typical angular app this is how we implement this method you modify the state directly here however when using the Redux architecture we don't modify the state here instead with dispatch and action this action goes into the store the store knows our route reducer so it passes action to the route reducer and then the reducer looks at the action and based on the type of the action it will return a new state and then the store will update its state internally so let's see how we can implement this first I'm going to go on top of this file and import mg Redux from ng to Redux so this is the primary type that the worked with in Redux applications now I'm going to create a constructor and inject ng Redux here ng Redux now you remember that this is a generic type so here we need to specify a generic argument which is I app state that's the interface that determines the shape of our store so I'm going to import I have state on the top like this constructor I'm going to apply the private modifier here so we can access this in the increment method now instead of modifying the state directly you're going to call this that injury ducks that's dispatch here we need to pass an action object and as you learn earlier an action is a simple object that has a type property so this is how we dispatch an action now some actions may carry extra data about the event that just happen for example if the user posted a message here you can have properties like body subject and so on but in this example we don't have to worry about that so delete every time we define a new action we need to go to our reducer and determine how the state will change in response to the action so let's go to the store here I'm going to add a switch statement on action that type and it is increment I'm going to return a new state with updated counter so currently it's not clear what is the type of this data object so I'm going to apply a type here this should be of type I app state so we get the current state of the store and then we return a new state so again I'm going to add a type here this function will return I AB state and now because we need to work with a counter we need to store its current value in the store so in I app state interface I'm going to declare a property counter of type number okay and now in response to the increment action I'm going to return a new object with counter set to state that counter which is the current value of the counter plus one so note that I'm not modifying the original state here I'm returning a new state and the final step earlier in app module here we passed the initial state of our store now we have a red underline here because our store now has a counter property that we have not initialized so back in app module I'm going to counter to zero so let's quickly review the steps and then I will show you how to improve this code in the app component we injected ng Redux in the constructor and in the increment method instead of modifying the state directly we dispatch an action then we went to our store we modified the route reducer and added support for the increment action then as part of this we also have to modify I app state so now we have this counter property and finally in the app module we modified this line here to set the initial state of our store now there are a couple of things we can improve in this code the first issue I see here is the use of this magic string in two different places we have uses in the app component and also in the store now the problem with this is that we have duplicated this in two different places and if we have a typo in the code our code is not going to work so it's better to extractives into one place define it as a constant so this way we won't have a type of problem and if you want to change this to something else in the future there is only one place we need to change so in the app folder I'm going to add a new file called actions and here I'm going to export a constant called increments and set it to increment now we can replace those two magic strings with this constant so first in the store on the top I'm going to import increment from actions and then I'm going to replace this magic string here increment now at the save time I'm going to copy this line and go to app component on the top paste it and once again replace this magic string with a constant that's the first improvement now the second improvement you notice that when we changed I app state here we had to go to the app module and modify this initial state object here so we are going back and forth between different files and this is really not good practice so let's go back to the store here I'm going to export a constant and call it initial State this is a type I app state and I'm going to set this so this object would counter set to zero now time we're going to modify the I app state interface we could immediately modify this initial State if necessary we don't have to jump back and forth between the store and the app module so now let's go to the app module and import initial state from the store and then replace this object here with initial State now if you run vacation at this point and click this button the counter is not incremented because we have only implemented the part for updating the state reading the state from the store is something else and that's what we're going to look at in the next lecture hey thank you for watching my youtube video my name is Maha Madani and I'm a fullstack developer applause I'd author and in getting the instructor with about 14 courses at the time of recording this video so I've got lots of courses on both front end and back end development including three sharp energy framework a selectman MVC angular architecture unit testing and so on this video watch is actually part of my angular course on udemy that you can get with a discount using the link in the video description and if you want to see my other courses simply head over to programming with mass comm slash courses you can also subscribe to my YouTube channel to get free videos every week have a great day and I'll be back show
