With timestamps:

00:00 - [Music]
00:01 - no js' or note is an open source and
00:04 - cross-platform runtime environment for
00:08 - executing JavaScript code outside of a
00:11 - browser quite often we use no to build
00:13 - back-end services also called api's or
00:17 - application programming interfaces these
00:20 - are the services that power our client
00:23 - applications like a web app running
00:25 - inside of a web browser or mobile app
00:28 - running on a mobile device these client
00:31 - apps are simply what the user sees and
00:33 - interacts with they're just the surface
00:36 - they need to talk to some services
00:38 - sitting on the server or in the cloud to
00:41 - store data send emails or push
00:44 - notifications kick off workflows and so
00:46 - on node is ideal for building highly
00:50 - scalable data intensive and real-time
00:53 - back-end services that power our client
00:56 - applications now you might ask but mosh
00:58 - there are other tools and frameworks out
01:01 - there for building back-end services
01:03 - such as a speed a bed rails Django and
01:06 - so on so what's so special about no well
01:09 - note is easy to get started and can be
01:12 - used for prototyping and agile
01:15 - development but it can also be used for
01:17 - building super fast and highly scalable
01:20 - services it's used in production by
01:23 - large companies such as PayPal uber
01:25 - Netflix Walmart and so on in fact at
01:29 - PayPal that rebuilt one of their Java
01:31 - and spring based applications using node
01:34 - and it found that the node application
01:36 - was built twice as fast with fewer
01:39 - people in 33% fewer lines of code and
01:43 - 40% fewer files and more importantly
01:47 - they double the number of requests
01:49 - served per second while decreasing the
01:52 - average response time by 35% so node is
01:56 - an excellent choice for building highly
01:58 - scalable services another reason for
02:01 - using node is that in old applications
02:03 - we use JavaScript so if you're a
02:06 - front-end developer and know JavaScript
02:08 - you can reuse your JavaScript skills and
02:11 - - a full-stack developer and get a
02:14 - better job with better pay you don't
02:16 - have to learn a new programming language
02:17 - also because you can use JavaScript both
02:21 - on the front end and on the back end
02:23 - your source code will be cleaner and
02:25 - more consistent so you will use the same
02:28 - naming conventions the same tools and
02:30 - the same best practices and finally
02:32 - another reason for using node is that it
02:35 - has the largest ecosystem of open source
02:37 - libraries available to you so for pretty
02:40 - much any features or building blocks you
02:42 - want to add your application there is
02:44 - some free open source library out there
02:47 - that you can use so you don't have to
02:49 - build this building blocks from scratch
02:51 - and instead you can focus on the core of
02:54 - your application next we're going to
02:56 - look at the architecture of node
03:02 - so in the last video you learned that
03:05 - note is a runtime environment for
03:07 - executing JavaScript code but what is a
03:09 - runtime environment really well before
03:12 - node we use JavaScript only to build
03:15 - applications that run inside of a
03:17 - browser so every browser out there has
03:20 - what we call a JavaScript engine that
03:23 - takes our JavaScript code and converts
03:25 - it to code that a computer can
03:27 - understand for example Microsoft eight
03:30 - uses chakra Firefox uses spider monkey
03:33 - and chrome uses v8 and it's because of
03:36 - these varieties of engines that
03:39 - sometimes JavaScript code can behave
03:41 - differently in one browser or another
03:43 - now a browser provides a runtime
03:46 - environment for JavaScript code for
03:49 - example you probably know that in
03:51 - browsers we have the window or the
03:53 - document object these objects allow us
03:56 - to work with the environment in which
03:58 - our code is running now up to 2009 the
04:01 - only way to execute JavaScript code was
04:04 - inside of a browser in 2009
04:07 - Brian Dahl the creator of node came up
04:10 - with a brilliant idea he thought it
04:13 - would be great to execute JavaScript
04:15 - outside of a browser so he took Google's
04:17 - v8 engine which is the fastest
04:20 - JavaScript engine out there and embedded
04:23 - it inside a C++ program and called that
04:26 - program node so similar to a browser
04:29 - node is a runtime environment for
04:31 - JavaScript code it contains a JavaScript
04:34 - engine that can execute our JavaScript
04:36 - code but it also has certain objects
04:39 - that provide an environment for our
04:41 - JavaScript code but these objects are
04:44 - different from the environment objects
04:45 - we have in browsers for example we don't
04:48 - have the document object instead we have
04:50 - other objects that give us more
04:52 - interesting capabilities for example we
04:54 - can work with the file system listen for
04:57 - requests and a given port and so on we
05:00 - can't do stuff like that inside of a
05:01 - browser right so in essence node is a
05:05 - program that includes the v8 JavaScript
05:08 - engine plus some additional modules that
05:11 - give us capabilities not available
05:14 - inside
05:14 - browsers we can work with the file
05:16 - system or the network and so on both
05:19 - chrome and note share the same
05:21 - JavaScript engine but they provide
05:23 - different runtime environments for
05:25 - JavaScript now I've seen people
05:27 - comparing no to c-sharp or Ruby or some
05:31 - other programming languages but this
05:33 - comparisons are fundamentally wrong
05:35 - because node is not a programming
05:38 - language it's like comparing a car with
05:40 - an apple by the same token note should
05:43 - not be compared with frameworks such as
05:45 - a spool of meth or rails or Django and
05:48 - so on these are frameworks for building
05:51 - web applications note is not a framework
05:54 - it's a runtime environment for executing
05:57 - JavaScript code next we're going to look
05:59 - at how node works
06:05 - so earlier I mentioned that note
06:08 - applications are highly scalable and
06:10 - this is because of the non-blocking or
06:12 - asynchronous nature of note what do you
06:15 - mean by asynchronous let me give you a
06:17 - metaphor imagine you go to a restaurant
06:20 - a waiter comes to your table takes your
06:22 - order and gives it to the kitchen then
06:25 - they move on to serve another table
06:27 - while the chef is preparing your meal so
06:30 - the same person can serve many different
06:32 - tables they don't have to wait for the
06:34 - chef to cook one meal before they serve
06:37 - another table this is what we call
06:39 - non-blocking or asynchronous
06:42 - architecture and this is how node
06:44 - applications work the waiter is like a
06:47 - thread allocated to handle a request so
06:51 - a single thread is used to handle
06:53 - multiple requests in contrast to
06:56 - non-blocking
06:57 - or asynchronous architecture we have
06:59 - blocking or synchronous architecture
07:02 - let's see how that works so back to our
07:05 - restaurant example imagine you go to
07:07 - another restaurant and in this
07:09 - restaurant a waiter is allocated to you
07:11 - they take your order and give it to the
07:13 - kitchen now they are sitting in the
07:15 - kitchen waiting for the chef to prepare
07:18 - your meal at this time they're not doing
07:20 - anything else they're just waiting
07:21 - they're not going to take an order from
07:24 - another table until your meal is ready
07:26 - this is what we call blocking or
07:29 - synchronous architecture and that's how
07:32 - applications built with frameworks like
07:34 - a speed net or rails work out of the box
07:37 - so when we receive a request on the
07:39 - server a thread is allocated to handle
07:42 - that request as part of handling that
07:44 - requests and is likely that we're going
07:46 - to query a database and as you know
07:48 - sometimes it may take a little while
07:50 - until the result is ready when the
07:53 - database is executing the query that
07:55 - thread is sitting there waiting it can't
07:58 - be used to serve another client so we
08:00 - need a new thread to serve another
08:02 - client imagine what would happen if we
08:05 - have a large number of concurrent
08:07 - clients at some point we're going to run
08:09 - out of threads to serve these clients so
08:12 - new clients have to wait until three
08:15 - threads are available
08:17 - or if we don't want them to wait we need
08:19 - to add more hardware so with this kind
08:22 - of architecture we are not utilizing our
08:24 - resources efficiently this is the
08:27 - problem with blocking or synchronous
08:29 - architecture and as I explained that's
08:31 - how applications built with frameworks
08:34 - like a speed a that worked by default of
08:36 - course in asp.net it is possible to use
08:39 - asynchronous architecture what you will
08:41 - have to do extra work for now in
08:44 - contrast no the applications are
08:46 - asynchronous by default so you don't
08:49 - have to do anything extra
08:50 - in node we have a single thread to
08:53 - handle all requests when a request
08:55 - arrives that single thread is used to
08:58 - handle that request if we need to query
09:00 - a database or thread doesn't have to
09:03 - wait for the database to return the data
09:05 - while the database is executing our
09:07 - query that thread will be used to serve
09:10 - another client when the database
09:12 - prepares the result it puts a message in
09:15 - what we call an event queue node is
09:18 - continuously monitoring this queue in
09:20 - the background
09:21 - when it finds an event in this queue it
09:23 - will take it out and process it this
09:26 - kind of architecture makes node ideal
09:29 - for building applications that include a
09:31 - lot of disk or network access we can
09:34 - serve more clients without the need to
09:36 - throw in more hardware and that's why no
09:39 - the applications are highly scalable in
09:42 - contrast node should not be used for CPU
09:45 - intensive applications like a video
09:48 - encoding or an image manipulation
09:50 - service in this kind of applications we
09:53 - have a lot of calculations that should
09:55 - be done by CPU and few operations that
09:58 - touch the file system or the network
10:00 - since no the applications are single
10:03 - threaded when performing the
10:05 - calculations to serve one client other
10:07 - clients have to wait and that's why node
10:10 - should not be used or CPU intensive
10:12 - applications it should only be used for
10:15 - building data intensive and real-time
10:18 - applications okay
10:20 - enough theory Nix I'm gonna show you how
10:22 - to install node and build your first
10:25 - node application
10:27 - you
10:31 - in this lecture I'm going to show you
10:32 - how to install note if you're on Windows
10:35 - open up command prompt if you're on Mac
10:37 - or Linux open up the terminal first
10:40 - let's see if you already have node on
10:42 - your machine or not so run note space -
10:46 - - version you can see on this machine
10:50 - I'm running node version 6.0 point three
10:53 - this is an earlier version of node the
10:56 - latest stable version is version eight
10:58 - now on your machine chances are you may
11:01 - not have known or you might have an
11:02 - earlier version either way I want you to
11:05 - install the latest version of node
11:08 - so open up your browser and head over to
11:11 - note J s org on this home page you can
11:14 - see we have two versions for note one is
11:18 - the latest stable version which is
11:20 - recommended for most users at the time
11:23 - of recording this video test version
11:24 - eight point nine point one and there's
11:27 - always a newer version which is
11:29 - experimental and it might not be stable
11:31 - so I want you to install the latest
11:33 - stable version also take into account
11:37 - that in the future when you're watching
11:38 - this video chances are the latest stable
11:41 - version might be newer if you're worried
11:43 - that this course is going to get
11:44 - outdated don't worry because in this
11:47 - course we're going to focus on the
11:48 - fundamentals so I'm going to work with
11:51 - the core modules of note these core
11:53 - modules are stable they have been there
11:55 - for a long time so the code that we're
11:57 - going to write in this course will
11:59 - continue to work with the future
12:00 - versions of note once you master the
12:03 - fundamentals you can always learn about
12:05 - the new features that come in every
12:07 - version by looking at the change lock so
12:10 - let's not worry about the fancy new
12:12 - features in node and focus on the
12:14 - fundamentals so let's go ahead and
12:16 - install the latest stable version
12:20 - you can see here I get a package we run
12:22 - it it's an installer take a look very
12:25 - simple just continue continue continue
12:31 - install you need to enter our password
12:37 - and the installation is complete it took
12:42 - only a few seconds so now back in the
12:46 - terminal let's run node - - version one
12:50 - more time you can see I upgraded my node
12:53 - to version eight point nine point one
12:55 - next we're going to build our first node
12:58 - application
13:03 - alright now we're ready to build our
13:05 - first node application so I'm gonna
13:08 - create a new folder call it first app
13:13 - let's go to this folder now I'm going to
13:17 - open this folder inside of Visual Studio
13:19 - code which is my preferred code editor
13:22 - so code period so this is Visual Studio
13:28 - code or vs code it's a free powerful
13:31 - editor but you can use any editors that
13:33 - you prefer you can use sublime you can
13:36 - use atom or any other editors so here in
13:39 - this folder I'm gonna add in your file
13:42 - app is in this file we can write regular
13:47 - JavaScript just like the JavaScript that
13:49 - we write for the browsers so I'm gonna
13:51 - define a function say hello that takes a
13:55 - parameter name and simply logs a message
14:00 - on the console so hello + name and then
14:05 - we can call this function like this
14:07 - Marsh now to execute this code we're
14:13 - going to go back to the terminal and run
14:15 - node and pass the name of the file as an
14:17 - argument so app the jas so node as I
14:21 - told you before is a C++ program it
14:24 - includes Chrome's v8 JavaScript engine
14:27 - so this app the J's file that we're
14:29 - gonna pass to node node is going to give
14:31 - it to v8 for execution so you can see we
14:35 - got hello Marsh on the console now let
14:37 - me show you something
14:38 - so back in vs code
14:42 - temporarily comment out this line and do
14:45 - it console that log of window let's see
14:49 - what happens so back in the terminal
14:51 - let's run node app a Jas you got an
14:56 - exception window is not defined so as I
15:00 - told you before in node we don't have
15:02 - the window or document objects these are
15:05 - part of the runtime environment that we
15:07 - get with browsers in node we have other
15:10 - objects to work with files with the
15:12 - operating system with the network and so
15:14 - on and that's what you're gonna learn
15:16 - about in the next section I hope you
15:18 - enjoyed this section and thank you for
15:19 - watching
15:24 - in this section we're going to look at
15:27 - the module system in node you will learn
15:29 - what modules are why we need them and
15:32 - how they work throughout this section
15:34 - we'll explore a feel of the modules
15:37 - built into the core of node such as
15:39 - operating system file system events and
15:43 - HTTP you will also learn how to create
15:46 - your own modules now let's get started
15:54 - so in the last section we use this
15:57 - console that log function to lock
16:00 - something on the console now this
16:03 - console object is what we call a global
16:06 - object so it's part of the global scope
16:08 - which means we can access it anywhere in
16:11 - any files we have a bunch of other
16:14 - objects and functions that are also
16:16 - globally available in node for example
16:18 - we have set timeout which you have
16:21 - probably seen before we use this to call
16:24 - a function after a delay like one second
16:27 - two second whatever so this is just part
16:29 - of the standard JavaScript we can use
16:31 - this on the client we can use this
16:33 - inside of a browser or inside of node
16:36 - we also have clear timeout
16:40 - similarly we have set interval which we
16:44 - use to repeatedly call a function after
16:47 - a given delay we also have clear
16:50 - interval which we use to stop that
16:52 - function from being called repeatedly
16:54 - so these are the global objects in
16:56 - JavaScript now he node we have a couple
16:59 - other global objects that you're going
17:01 - to learn about later in this section now
17:04 - in browsers we have this window object
17:07 - that represents our global scope so all
17:10 - the variables and functions that are
17:12 - defined globally we can access them via
17:15 - this window object so we can call window
17:18 - that console that log or simply just
17:21 - console that lock the JavaScript engine
17:24 - will prefix this statement with window
17:27 - that console dot lock because that's
17:30 - where this object is defined similarly
17:33 - all these other functions you see here
17:35 - they belong to the window object so we
17:38 - can call window that's set timeout or
17:41 - call it directly by the same token when
17:44 - we declare a variable let's say message
17:48 - that variable is also available via the
17:52 - window object okay however in the last
17:56 - section I told you that in node we don't
17:59 - have this window object instead we have
18:01 - another object called global so all
18:05 - these functions and objects we have here
18:07 - we can
18:07 - access them find the global object so we
18:10 - can do global that console dot log or
18:13 - global that set timeout and so on of
18:16 - course it's easier to use the shorthand
18:18 - instead of prefix in them with this
18:20 - global but one thing you need to know
18:22 - about note is that these variables that
18:25 - we define here they are not added to the
18:28 - global object in other words if we do a
18:31 - console dot log of global that message
18:37 - we are going to see undefined on the
18:40 - console so let me show you I'm gonna
18:42 - delete all the code here now back in the
18:45 - terminal let's run note app j s so we
18:50 - get undefined in the console so as you
18:54 - can see the variables and functions that
18:57 - we defined here they are not added to
18:59 - the global object they're only scoped to
19:02 - this fire app dot j s so they are not
19:05 - available outside of this file and this
19:07 - is because nodes modular system that
19:10 - you're going to learn about in the next
19:11 - lecture
19:13 - you
19:17 - so in the last section you'll learn that
19:19 - in the client-side JavaScript that we
19:21 - run inside of browsers when we declare a
19:24 - variable or a function that is added to
19:26 - the global scope for example when we
19:30 - define a function like say hello that
19:35 - function is added to the global scope
19:37 - and it's available via the window object
19:41 - now there is a problem with this
19:44 - behavior in a real world application we
19:47 - often split our JavaScript code into
19:49 - multiple files so it is possible that we
19:52 - have two files and in both these files
19:54 - we define this function say hello with
19:57 - the exact same name because this
20:00 - function is added to the global scope
20:01 - when we define this function in another
20:04 - file that new definition is going to
20:07 - overwrite the previous definition so
20:09 - this is the problem with the global
20:11 - scope so in order to build reliable and
20:14 - maintainable applications we should
20:16 - avoid defining variables and functions
20:19 - in the global scope instead we need
20:21 - modularity we need to create small
20:24 - building blocks or modules where we
20:27 - define our variables and functions so
20:29 - two variables or two functions with the
20:31 - same name don't overwrite another
20:33 - variable or function defined somewhere
20:35 - else that encapsulated inside of that
20:39 - module now at the core of node we have
20:42 - this concept called module so every file
20:45 - in a node application is considered a
20:47 - module the variables and functions would
20:49 - define in that file or that module are
20:51 - scoped to that file in object-oriented
20:54 - programming terms we say there are
20:56 - private they are not available outside
20:58 - that container outside that module if
21:01 - you want to use a variable or a function
21:03 - defined in a module outside that module
21:06 - you need to explicitly export it and
21:08 - make it public and we're going to look
21:10 - at that in the next lecture so what I
21:13 - want you to take away from this lecture
21:14 - is that every node application has at
21:17 - least one file or one module which we
21:20 - call a main module so in this case is
21:22 - after J s is our main module now let me
21:26 - show you this module so I'm going to
21:27 - delete all this code here and do
21:30 - a console that log of module
21:35 - now this module object here may appear
21:38 - to be global so you may think we can
21:40 - access it while the global object like
21:44 - global console but actually this is not
21:47 - a global object it appears to be global
21:49 - but it's not global and you will find
21:51 - out why very soon so let's just lock
21:55 - this module object and see what we see
21:57 - in the console back in the terminal node
22:01 - app the jas so you can see we have an
22:04 - object module it's a JSON object with
22:08 - these key value pairs so we have ID
22:09 - every module has an ID or a unique
22:12 - identifier we have exports parent file
22:16 - name which is the complete pass to that
22:18 - file loaded which is a boolean that
22:21 - determines if this module is loaded or
22:23 - not we have children and paths now for
22:26 - now don't worry about these properties
22:28 - as we go through this section you will
22:31 - gradually become familiar with this
22:32 - properties so in node every file is a
22:36 - module and the variables and functions
22:39 - defined in that file are scoped to that
22:42 - module they are not available outside of
22:44 - that module in the next lecture you're
22:46 - going to learn how to create and load a
22:48 - module
22:54 - alright now let's add a new module to
22:56 - this application so I'm gonna add a new
23:00 - file logger dot J s let's imagine we're
23:04 - going to create a module for login
23:07 - messages and we're gonna reuse this
23:08 - module in various parts of this
23:10 - application or potentially in other
23:12 - applications so loggernet J s now in
23:17 - this module let's imagine that we're
23:19 - going to use one of those remote logging
23:21 - services for login our messages so there
23:25 - are websites out there there provide
23:27 - logging as a service they give us a URL
23:29 - and we can send an HTTP request to that
23:32 - URL to log messages in the cloud so here
23:36 - I'm gonna declare a variable like URL
23:41 - and set it to something like this HTTP
23:44 - my lager dot io / lock and of course I'm
23:48 - making this up it may not be a true
23:50 - service out there but let's imagine in
23:53 - this implementation we're going to send
23:54 - an HTTP request to this endpoint to this
23:58 - URL now we also need a function called
24:03 - log that takes a message and in this
24:07 - function we're going to send an HTTP
24:10 - request however to keep things simple
24:13 - here we just want to focus on the
24:15 - modularity we don't want to get
24:16 - distracted with all the details of
24:18 - sending HTTP requests so for now I just
24:21 - want to log this message on the console
24:24 - so console that log message okay
24:30 - now this variable and this log function
24:34 - they're both scoped to this module
24:37 - they're private they're not visible from
24:39 - the outside
24:40 - however in after j/s which is our main
24:44 - module we want to use this logger module
24:47 - so we should be able to access this log
24:51 - function we should be able to call it
24:53 - from the app module so we need to make
24:55 - this public we need to make it visible
24:57 - from the outside
24:59 - now in the last lecture you saw this
25:02 - module object one of the properties we
25:04 - have here is exports you can see this
25:08 - property is set to an empty object
25:10 - anything that we add to this object will
25:13 - be exported from this module and it will
25:16 - be available outside of this module so
25:19 - back in our lager module I'm gonna set
25:23 - module dot exports dot log so I'm adding
25:28 - a method called log to this exports
25:31 - object and simply setting it to this log
25:35 - function we have defined here okay in
25:39 - other words the object that we're
25:41 - exporting here has a single method
25:43 - called lock now similarly if you want to
25:47 - export this URL we could do something
25:49 - like this
25:50 - so module that exports that URL we set
25:55 - it to URL and of course we could change
25:58 - the name that is exported to the outside
26:00 - for example internally we may call this
26:03 - variable URL but when we export it we
26:06 - may call it endpoint okay now in this
26:13 - case we don't need to export this URL
26:16 - variable because this is purely
26:18 - implementation detail so in real world
26:21 - applications every module might have
26:23 - several variables and functions we only
26:26 - want to export a subset of these members
26:29 - to the outside because we want to keep
26:30 - this module easy to use let me give you
26:34 - a metaphor think of a DVD player a DVD
26:37 - player has a few buttons on the outside
26:39 - and these are the buttons or objects
26:41 - that we interact with so these objects
26:44 - represent the public interface of a DVD
26:48 - player okay but inside the box there are
26:51 - lots of other objects or complex objects
26:53 - we don't need to know anything about
26:55 - these objects their implementation data
26:58 - and they can change significantly from
27:00 - one model to another but what you see on
27:03 - the outside is almost stable or static
27:06 - across different models so in our lager
27:09 - module this URL is implementation detail
27:13 - modules don't need to know anything
27:15 - about this they only need to call the
27:17 - log function so we export these make it
27:20 - public but keep the URL private so I'm
27:23 - gonna delete this last line okay so
27:26 - we're done with our logger module now we
27:28 - need to load this module and use it
27:31 - inside app j/s
27:38 - to load the module we use the require
27:41 - function this is one of the functions in
27:44 - node we don't have this in browsers this
27:46 - function takes one argument and that's
27:49 - the name or path of the target module we
27:52 - want to load so here we want to load the
27:55 - logger module now you can see both the
27:58 - app module and longer module are in the
28:00 - same folder so we use period slash to
28:05 - indicate the current folder and then we
28:08 - add the name of our module that is
28:10 - logger ojs or we can make it shorter and
28:13 - just use logger because node assumes
28:16 - this is a JavaScript file and it
28:18 - automatically asked the GS extension now
28:22 - if this logger was in a subfolder we
28:24 - could add that soft folder here or if it
28:27 - was in the parent folder we could use
28:29 - dot dot slash so here we are using the
28:32 - relative path to the target module in
28:35 - this case that module is in the same
28:37 - folder now this required function
28:41 - returns the object that is exported from
28:43 - this target module
28:45 - so this exports object here this is what
28:49 - we get when we call the require function
28:51 - let me show you so I'm gonna declare a
28:55 - variable call it lager the name of the
28:58 - module and set it to the return value of
29:01 - the require function now let's log this
29:05 - logger and see what we get so node
29:12 - object s look we get an object this
29:17 - object has a single method called log
29:20 - can see that's a function so we can call
29:24 - this function or this method in app J s
29:27 - so back here we call logger dot and look
29:31 - here we have intelligence in BS code so
29:34 - we call log and pass a message now I can
29:41 - terminal let's run this app and we get
29:47 - message on the console so this is how we
29:50 - work with modules in node
29:52 - when we define a module we export one or
29:55 - more members and then to load the module
29:58 - we use the require function now in the
30:02 - recent versions of JavaScript we have
30:04 - the ability to define constants so as a
30:08 - best practice when loading a module
30:11 - using the required function it's better
30:13 - to store the result in a constant like
30:17 - this the reason for this is because we
30:20 - don't want to accidentally overwrite the
30:23 - value of logger like this here if we set
30:27 - this to one then when we call the log
30:30 - method we're going to get an exception
30:31 - let me show you so one more time
30:36 - look you got logger that log is not a
30:39 - function now in contrast if we define
30:43 - this as a constant now back in the
30:47 - terminal let's run this program one more
30:50 - time look we got a different kind of
30:53 - error assignment two constant variable
30:56 - now there are tools out there that check
30:59 - our JavaScript code for errors like that
31:01 - so by using this constructs properly we
31:04 - can prevent these errors from happening
31:06 - at runtime
31:07 - so one of these popular tools is J's
31:09 - hint if you have never used it before
31:11 - don't worry I'm just gonna show you a
31:13 - quick demo so if you're on J's hint 1/2
31:17 - Jas we get this error attempting to
31:21 - overwrite logger which is a constant so
31:24 - with tools like jeaious hint we can scan
31:26 - all our JavaScript code for errors like
31:28 - that so that's the benefit of using a
31:31 - constant as opposed to a variable here
31:33 - if you accidentally reset this object
31:36 - then we're gonna get an error at compile
31:39 - time instead of at run time
31:40 - okay and one last thing before we finish
31:43 - this lecture sometimes instead of
31:46 - exporting an object from a module you
31:49 - may want to export only a single
31:51 - function for example here in our lager
31:54 - module we don't necessarily need an
31:56 - object because we have a single method
31:59 - an object would be useful if we had
32:01 - multiple methods or properties here but
32:05 - in this case instead of
32:06 - sporting an object we can export a
32:08 - single function so we can reset this
32:11 - exports to the log function so initially
32:16 - it was an empty object but we reset it
32:19 - to just a function with that I can op j
32:23 - s the logger is no longer an object it's
32:27 - a function that we can call directly
32:29 - like this so logger we call it and give
32:35 - it an argument now a better name for
32:37 - this function is LOC so I'm gonna press
32:40 - f2 to rename these log like this now
32:45 - back in terminal let's run node FJ s and
32:49 - we get the same result so in your
32:53 - modules you can export a single function
32:55 - or an object
33:02 - so now you know the variables and
33:05 - functions we define in a module are
33:07 - scoped to that module they're private
33:09 - and not visible from the outside but you
33:12 - might be wondering how node does this so
33:15 - let me show you on the very first line
33:17 - of the logger jeaious module I'm going
33:20 - to create a syntactical error so define
33:23 - a variable X and set it to nothing like
33:26 - this so make sure to write this code on
33:29 - the very first line in other words if
33:31 - you have a line break here and do this
33:34 - on a second line you're not going to see
33:36 - what I'm gonna show you now so put this
33:38 - back on the first line here we have a
33:41 - syntactical error now back in the
33:44 - terminal let's run the application again
33:48 - okay we got on
33:50 - touken semicolon right but look above
33:53 - this line you see this function
33:56 - declaration so this function has a few
34:00 - parameters exports require module file
34:05 - name and surname so let me copy this
34:10 - code here
34:12 - now basically what happens under the
34:14 - hood is that note does not execute this
34:17 - code directly it wraps it inside of a
34:21 - function and that's the function you saw
34:23 - so at runtime our code is going to be
34:26 - converted to something like this so we
34:30 - have this function declaration here is
34:33 - the body of that function now for now
34:35 - I'm gonna remove this error here so this
34:39 - is our code and then we have the end of
34:42 - this function now the actual code is
34:44 - slightly more complicated than this but
34:47 - we don't want to get distracted with
34:48 - that complexity if you're a more
34:50 - advanced JavaScript developer you
34:52 - probably know this is an immediately
34:54 - invoked function expression or if you if
34:58 - you don't know that don't worry that's
34:59 - not really the scope of note what I want
35:02 - you to take away here is that note does
35:04 - not execute our code directly it always
35:08 - wraps the code inside each module and
35:10 - something like this inside of a function
35:12 - now look at these arguments to this
35:15 - function so you have seen the required
35:18 - function I told you that this required
35:20 - function appears to be global but
35:22 - actually it's not global in fact it's
35:25 - local to each module so in every module
35:27 - require is one of the arguments that is
35:30 - passed to this function we call this
35:33 - function the module wrapper function
35:36 - okay so you have seen the require
35:39 - function you have also seen module that
35:42 - is what we're using here so we have
35:44 - module that exports we also have exports
35:48 - which is a shortcut to module dot export
35:51 - so if you want to add a function to
35:53 - module that exports object you can
35:55 - either write module that exports dot log
35:58 - equals log or you can write exports that
36:02 - log equals log but you cannot reset this
36:07 - export
36:09 - like what we did earlier in other words
36:11 - you cannot write export equals lock
36:15 - because this export is a reference to
36:19 - module and exports we can
36:22 - change that reference okay so these are
36:27 - the first three arguments we also have
36:30 - filename and Durning which represent the
36:33 - name of this file and the pass so let's
36:37 - have a quick look at this argument on
36:39 - the top I'm gonna do a console that log
36:42 - of underline underline file name and
36:47 - also
36:49 - underline underline Durning now we're
36:53 - not going to have this function this
36:54 - module wrapper function this was purely
36:56 - for demonstration so I'm gonna revert
36:59 - the code back to what we had before
37:01 - okay so now we don't have any errors in
37:05 - this module let's go back to the
37:07 - terminal and run this program
37:10 - so note op j s so here on the first line
37:14 - we have file name which is the complete
37:16 - path to that file that is lager a s and
37:18 - on the second line we have the path to
37:22 - the directory that contains and module
37:24 - so now you have a basic idea about node
37:27 - modules and how they work you know how
37:29 - to create them how to load them but
37:31 - knowing itself comes with a bunch of
37:33 - useful modules that we can use in a lot
37:36 - of applications and that's what we're
37:37 - going to look at in the next lecture
37:42 - hi guys thank you for watching my Noah
37:45 - tutorial I wanted to let you know that
37:47 - this tutorial is the first hour of my
37:50 - complete note course where you will
37:52 - learn how to build a real restful api
37:55 - using node Express and MongoDB all of
37:59 - that recorded with the latest version of
38:01 - node and modern JavaScript so you will
38:04 - learn new and modern ways of building
38:06 - applications with node
38:07 - unlike other courses that only show you
38:10 - simple the only examples like how to
38:12 - build a to-do app we're gonna work on a
38:15 - real-world project a restful api for a
38:18 - video rental application if you have
38:20 - taken any of my courses you know I don't
38:22 - waste your time by explaining the
38:24 - obvious like what a code editor or
38:26 - command prompt is we're gonna get
38:28 - straight to the business and as part of
38:31 - this I'll be touching on various
38:32 - important topics that you need to
38:34 - understand really well including working
38:37 - with node package manager or NPM
38:40 - asynchronous JavaScript including
38:42 - callbacks promises async and await
38:45 - implementing crud operations data
38:48 - validations authentication and
38:50 - authorization using JSON web tokens
38:52 - including role management handling and
38:55 - login errors unit and integration
38:57 - testing test-driven development so you
39:00 - will see I will build a feature from A
39:02 - to Z using test-driven development or
39:05 - TDD and finally we'll deploy this
39:07 - application to the cloud throughout the
39:10 - course I will share with you lots of
39:12 - clean coding and refactoring techniques
39:14 - security best practices useful libraries
39:17 - to use as part of your development
39:19 - common mistakes that many node
39:21 - developers make and much much more
39:23 - the course is currently 14 hours long
39:26 - and I'm planning to add more content to
39:28 - it in the future you can watch this
39:30 - course as many times as you want and if
39:32 - you watch it to the end you will get a
39:34 - certificate of completion that we can
39:36 - add to your resume so if you're serious
39:39 - about adding no to your resume I highly
39:42 - encourage you to enroll in the course
39:44 - and don't waste your time jumping from
39:46 - one tutorial to another so click on the
39:49 - link in the video description to enrol I
39:51 - hope to see you in the course
39:53 - you
39:57 - so in the last lecture I told you that
39:59 - in node we have a few useful modules
40:02 - that are built into the core of node
40:04 - with these modules we can work with
40:07 - files with the operating system with a
40:09 - network and so on so let's have a quick
40:12 - look at this built in modules head over
40:14 - to node J s
40:15 - org then go to Docs on the left side go
40:21 - to version eight point nine point three
40:23 - that's the current stable release
40:25 - chances are by the time you're watching
40:27 - this video this version might be
40:28 - different so that doesn't really matter
40:30 - just pick that version now hearing the
40:33 - table of contents we can see the built
40:36 - in modules of course not
40:38 - everything you see here is a module for
40:39 - example we have console which is our
40:41 - console object we have buffer which
40:44 - we're going to learn about in the future
40:45 - in this course again that's a global
40:47 - object but you can see that this is a
40:49 - fairly short list and some of the items
40:52 - in this list are built in modules in no
40:55 - so just that you can see there are not
40:58 - many modules built into note I'm gonna
41:01 - highlight a few very useful modules that
41:04 - you should be aware of for example we
41:06 - have file system to work with files we
41:09 - have HTTP that you're going to learn
41:11 - about later in this section so with this
41:13 - we can create web servers that listen
41:15 - for HTTP requests we have OS to work
41:19 - with the operating system we have path
41:22 - which gives us a bunch of utility
41:24 - functions for working with paths we have
41:27 - process that gives us information about
41:29 - the current process we have query
41:31 - strings which is very useful in building
41:33 - HTTP services we have a stream which
41:37 - allows us to work with streams of data
41:38 - again you're going to learn about this
41:40 - in the future and a bunch of other
41:42 - modules now in this lecture we're going
41:44 - to look at is passed module so on the
41:48 - documentation you can see all the
41:51 - functions defined in this module in this
41:53 - lecture we're going to use the parse
41:56 - method now if you
41:58 - scroll down you can see how you can use
42:01 - this module so I've seen the required
42:04 - function before we call the module using
42:07 - the required function get the result
42:09 - which is an object and store it in a
42:12 - constant so back in vs code in app Jas
42:16 - let's call require and as the argument
42:19 - use half now the argument that we gave
42:24 - to this require function no it assumes
42:26 - that this is a built in module if there
42:30 - is no built in module by the name
42:32 - specified here then node looks for the
42:35 - existence of a relative path to a file
42:37 - in this application so if we have period
42:40 - / or period period / whatever then
42:44 - notice oome this is a file in this
42:47 - application now in this case we're going
42:49 - to load the building path module and
42:51 - store it in a constant called pass so
42:55 - this is an object with a bunch of useful
42:57 - methods the method we're going to use is
43:01 - the parse method so I'm gonna give it
43:04 - this underline underline file name which
43:07 - is one of the arguments and the module
43:10 - wrapper function that you saw in the
43:11 - last lecture so let's call this and
43:14 - store the result in pass object and then
43:20 - finally log it on the console has object
43:25 - now back in the terminal let's run this
43:29 - application so this is the path object
43:31 - it has a few useful properties we have
43:34 - root we have dur which specifies the
43:37 - path to the folder containing this file
43:41 - here's the name of the file after jas
43:44 - here's the extension
43:47 - the name of the file without the
43:49 - extension so if you want to work with
43:50 - pads it's much easier to use the past
43:53 - module as opposed to working with
43:55 - strings in the next lecture we're going
43:57 - to look at another built-in module that
44:00 - gives us information about the operating
44:02 - system
44:07 - in this lecture I'm going to show you
44:09 - how to get information about the current
44:11 - operating system so if I can no
44:13 - documentation in the list of modules if
44:17 - you scroll down you can see this OS
44:19 - module let's have a quick look here so
44:22 - these are the methods that are available
44:24 - in this module for example we have free
44:27 - mem which returns the amount of free
44:30 - memory on this machine
44:31 - you also have total mem which is the
44:33 - total memory we can get information
44:35 - about the current user we can get the
44:38 - uptime of this machine and so on so
44:41 - let's use a couple of these methods here
44:42 - so if you scroll down you can see this
44:45 - is how we load this OS module just like
44:49 - loading other modules we call the
44:50 - required function and store the result
44:52 - in a constant called OS or anything so
44:56 - my can be a scone I'm gonna delete all
44:58 - the code here and define a new constant
45:01 - OS and study to require OS now we can
45:07 - call total mem method
45:11 - or free mem or other methods so let me
45:16 - declare a variable and store the result
45:19 - here
45:22 - and similarly for the free memory free
45:26 - memory and finally let's lock these
45:28 - values on the console so console dot log
45:33 - single code we add total memory and app
45:39 - and this total memory here now we can
45:44 - simplify this expression by using a
45:46 - template string which is available in
45:49 - more recent versions of JavaScript that
45:52 - we refer to as es6 or ES 2015 which is
45:58 - short for ACMA script 6 or 2015
46:03 - that's the specification that defines
46:04 - what features are available in
46:07 - JavaScript so every year Ahmed defines
46:10 - new features that should be added to
46:11 - JavaScript and as you know different
46:14 - browsers implement different set of
46:16 - these features but the v8 engine that we
46:19 - have inside of node that's pretty
46:21 - up-to-date and it implements a lot of
46:23 - new features of JavaScript that is
46:25 - defined in Eggman script so in Eggman
46:29 - script six or eight most script 2015 we
46:32 - have a feature called template string
46:34 - which helps us build a string without
46:37 - concatenations let me show you how that
46:40 - works so console dot log now instead of
46:45 - a single quote we use the backtick
46:48 - character backtick is the character
46:51 - before number 1 on your keyboard so here
46:54 - we add some static text like total
46:57 - memory now we want to add something here
47:01 - dynamically so we use dollar sign and
47:04 - curly braces to add a placeholder for an
47:08 - argument in this case our argument is
47:11 - this total memory variable so we can see
47:15 - with a template string we don't have
47:17 - concatenation okay now I'm gonna
47:20 - duplicate this line and change total to
47:24 - free and here let's add free memory okay
47:29 - now we don't need this first console log
47:32 - we're done with this let's go back to
47:34 - the terminal and run this app
47:36 - occasion so note app but Jas and you can
47:41 - see the total and free memory on my
47:43 - machine now what is interesting here is
47:45 - that before node we could not get this
47:48 - kind of information using javascript
47:50 - javascript used to run only inside of a
47:53 - browser and we could only work with the
47:55 - window or document objects we couldn't
47:57 - get information about the operating
47:59 - system but when using node our
48:01 - JavaScript code is executed outside of a
48:04 - browser or as some people say on the
48:07 - server with this we can get information
48:09 - about the operating system we can work
48:11 - with files we can work with the network
48:14 - for example we can build a web server
48:16 - that listens for HTTP requests on a
48:18 - given port and I'm going to show you all
48:20 - this later in this section
48:28 - and it's lecture I'm gonna show you how
48:30 - to work with files in node so I can no
48:33 - documentation and the list of modules
48:36 - here we have a module called file system
48:39 - in this module we have a comprehensive
48:42 - set of methods for working with files
48:45 - and directories now in this course I'm
48:47 - not gonna waste your time showing you
48:49 - every single method here because that
48:51 - would be very repetitive but let me show
48:53 - you an example so you see how to work
48:56 - with files in node
48:58 - so back in vs code first we need to
49:01 - require the FS module we get the result
49:06 - and store it in this constant now FS dot
49:10 - look almost every operation defined here
49:14 - comes in two forms synchronous or
49:17 - blocking and asynchronous or non
49:19 - blocking for example look we have access
49:22 - which is an asynchronous method we also
49:25 - have access sync which is a synchronous
49:27 - method now even though we have these
49:29 - synchronous methods here you should
49:32 - avoid using them these are there purely
49:34 - for simplicity in a real world
49:36 - application you should use asynchronous
49:38 - methods because these are non blocking
49:41 - so as I told you in the last section a
49:43 - node process has a single thread if
49:46 - you're using node to build the backend
49:48 - for your application you might have
49:50 - several hundreds or thousands of clients
49:52 - connecting to that back-end if you keep
49:55 - that single thread busy you won't be
49:57 - able to serve many clients so always use
50:00 - asynchronous methods now that aside
50:03 - let's take a look at an example we're
50:05 - going to look at rate dir or directory
50:09 - method first I'm going to show you the
50:11 - synchronous form because that's easier
50:13 - to understand so as the first argument
50:17 - we specify the path period slash
50:20 - represents the current folder and this
50:23 - will return all the files and folders in
50:25 - the current folder so files will be a
50:30 - string array now we can display that on
50:33 - the console very simple
50:38 - so note fjs so we can see we get an
50:42 - array of strings and these are the files
50:45 - in this folder on my machine now let's
50:48 - take a look at the asynchronous form of
50:50 - this method so FS dot read directory
50:55 - just like before the first argument is
50:59 - the path so the current folder now all
51:02 - these asynchronous methods take a
51:04 - function as their last argument no it
51:08 - will call this function when that
51:10 - asynchronous operation completes we call
51:13 - this function a callback so here look in
51:17 - the intellisense the second parameter is
51:19 - a callback and this is a function with
51:22 - two parameters an error and result which
51:26 - is in this case a string array so here
51:30 - we need to pass a function or a callback
51:33 - function with an error and the result
51:36 - which is a string array we can call that
51:39 - files so here we need to check if we
51:42 - have an error or the result only one of
51:45 - these arguments will have a value and
51:47 - the other will be not so if we have
51:49 - error
51:50 - we're going to display it on the console
51:54 - error error now this is not how we
51:57 - handle errors in a real world
51:59 - application but don't worry about this
52:01 - later in the course we have a complete
52:03 - section about error handling in note for
52:05 - now we just want to display this error
52:07 - on the console so if you have an error
52:09 - we display otherwise we display the
52:12 - result so console dot log result and we
52:17 - can display this string array so I'm
52:21 - gonna comment out these two lines so we
52:24 - can only look at the result of this
52:26 - asynchronous read directory now note up
52:30 - j/s so we got resolved and this is
52:33 - exactly the string array that we had
52:36 - before
52:36 - now let's simulate an error so I'm going
52:40 - to go back in the code and change this
52:42 - argument to let's say a dollar sign save
52:47 - back in the terminal node fjs this time
52:51 - we go
52:52 - and error no such file or directory
52:56 - so to recap in order to work with files
52:59 - and directories in node first you need
53:01 - to require the FS module and then use
53:04 - one or more of the methods defined in
53:06 - this module all these methods come in
53:09 - pairs asynchronous and synchronous
53:11 - always prefer to use asynchronous
53:13 - methods
53:19 - one of the core concepts in node is the
53:21 - concept of events in fact a lot of nodes
53:25 - core functionality is based on this
53:28 - concept of events an event is basically
53:30 - a signal that indicates that something
53:34 - has happened in our application for
53:37 - example in node we have a class called
53:39 - HTTP that we can use to build a web
53:42 - server so we listen on a given port and
53:45 - every time we receive a request on that
53:47 - port that HTTP class raises an event now
53:51 - our job is to respond to that event
53:54 - which basically involves reading that
53:56 - request and returning the right response
53:58 - so as you go through note documentation
54:01 - you can see that several classes in node
54:04 - raises different kinds of events and in
54:07 - your code you might be interested to
54:09 - respond to those events so in this
54:12 - lecture I'm gonna show you how to work
54:14 - with the events module now back in notes
54:18 - documentation once again in the list of
54:20 - modules you can see here we have this
54:24 - events module so in this module we have
54:28 - one class that is called event emitter
54:31 - it's one of the core building blocks of
54:33 - node and a lot of classes are based on
54:36 - this event emitter so let's see how we
54:39 - can work with this event emitter
54:42 - I can be ESCO first let's load the
54:45 - events module so require events here
54:50 - when we call the require function we get
54:53 - the event emitter class so constant
54:56 - event emitter note that here in terms of
55:01 - the naming the first letter of every
55:03 - word is uppercase this is the convention
55:07 - that indicates that this event emitter
55:10 - is a class it's not a function it's not
55:13 - a simple value it's a class a class is
55:16 - container for properties and functions
55:19 - which we call methods so in this event
55:21 - emitter class
55:24 - we have these metals that you see here
55:26 - in the documentation so a class is a
55:28 - container for a bunch of related methods
55:31 - and properties now here in order to use
55:35 - this event emitter first we need to
55:37 - create an instance of this class so
55:40 - constant emitter we set this to new
55:44 - event emitter so here this emitter is an
55:48 - object in case you don't know the
55:50 - difference between a class and an object
55:52 - let me give you a metaphor a class is
55:55 - like human and an object is like an
55:57 - actual person like John Mary and so on
56:01 - so a class defines the properties and
56:04 - behavior of a concept like a human but
56:07 - an object is an actual instance of that
56:11 - class okay so here this first event
56:15 - emitter is a class it's a blueprint it
56:18 - defines what an event emitter can do but
56:21 - this second emitter is an actual object
56:23 - this is the one that we're going to use
56:25 - in our application so this emitter has a
56:30 - bunch of methods look these are all the
56:33 - metals that you saw in the documentation
56:36 - now even though here we have more than
56:38 - ten metals most of the time we use only
56:40 - two of these methods one is emit that we
56:44 - use to raise an event the first time I
56:47 - saw this method it didn't make sense to
56:49 - me because English is my second language
56:51 - and I didn't know what emit means so if
56:55 - you're in the same boat ma it basically
56:57 - means making a noise or produce
56:59 - something in this case you're making a
57:02 - noise in your application you're
57:04 - signaling that an event has happened
57:07 - okay so that's the meaning of Emmet and
57:10 - here we pass an argument that is the
57:13 - name of the event let's say message
57:16 - locked
57:18 - in the future we're going to extend our
57:20 - lager module and every time we log a
57:23 - message we're going to raise an event
57:25 - called message locked okay now if you
57:29 - run this application nothing is going to
57:31 - happen let me show you back in the
57:33 - terminal node app J gasps look nothing
57:36 - happened because we have raised an event
57:39 - here but nowhere in our application we
57:43 - have registered a listener that is
57:45 - interested in that event a listener is a
57:48 - function that will be called when that
57:50 - event is raised
57:52 - okay so let's register a listener that
57:55 - will be called when the message log
57:58 - event is raised so register a listener
58:03 - so emitter dot look here we have this
58:07 - method add listener but we have an alias
58:09 - for this that we use more often that is
58:12 - on if you're worked with jQuery you have
58:14 - seen this before
58:15 - so on or add listener they're exactly
58:18 - the same but quit often reused on method
58:21 - now this method takes two arguments the
58:24 - first one is the name of the event in
58:26 - this case message locked and the second
58:31 - one is a callback function or the actual
58:34 - listener so here we pass a function and
58:36 - this function will be called when that
58:39 - event is raised okay now for now I just
58:43 - want to lock a message in the console so
58:45 - console let's say listener called like
58:51 - this now let's run this application so
58:56 - node FJ guess and we got this message
58:58 - listener call so this indicates that
59:02 - when we raise this event
59:06 - function or listener was called okay and
59:09 - of course the order is important here if
59:12 - you register this listener after calling
59:16 - the Amit method nothing would have
59:17 - happened because when we call the Amit
59:19 - method this eMeter iterates over all the
59:23 - registered listeners and calls them
59:25 - synchronously okay so this is the basic
59:28 - of raising events and handling them
59:31 - using the eve an emitter class
59:38 - now quite often when you want to raise
59:41 - an event we also want to send some data
59:43 - about that event for example in our
59:47 - lager module when we log a message
59:49 - perhaps our remote login service will
59:52 - generate an ID for that message perhaps
59:55 - we want to return that ID to the client
59:58 - or it may give us a URL to access that
60:01 - log message directly so here when
60:04 - raising an event we can add additional
60:06 - arguments which we refer to as event
60:09 - arguments so we can add an ID like one
60:13 - and we can add a URL but as you can see
60:18 - these magic values here are a little bit
60:20 - confusing if you want to send multiple
60:22 - values about an event it's a better
60:25 - practice to encapsulate those values
60:28 - inside an object so here we have an
60:32 - object we give it a couple of properties
60:34 - like ID we set it to ID of this message
60:37 - that is logged and another property URL
60:41 - like this okay so we're referring to
60:44 - this object as event argument now when
60:50 - registering a listener here this
60:52 - callback function this actual listener
60:54 - can also receive this event argument so
60:58 - here we add a parameter called arc we
61:02 - can call it anything the name doesn't
61:04 - matter
61:04 - but by convention we often use arc or
61:07 - some people use e to refer to the event
61:10 - or event arc whatever you prefer is
61:14 - perfectly fine so here we have arc now
61:17 - let's log in on the console very simple
61:22 - let's run this application so note okay
61:27 - look listen are called and here's our
61:30 - event arc and with this technique we can
61:33 - pass data about the event that just
61:35 - happened
61:37 - now one last thing to make this code a
61:39 - little bit simpler in es6 or equal
61:42 - script six we have this feature called
61:44 - arrow function with an arrow function we
61:49 - can get rid of this function keyword so
61:52 - here we have the arguments and after
61:54 - that we have the body of that function
61:56 - now to separate the two we use an arrow
62:00 - and that's why we call this arrow
62:02 - function you can see this syntax is a
62:04 - little bit simpler and a lot of people
62:06 - prefer to use arrow functions in es6 now
62:10 - here's a simple exercise for you let's
62:12 - imagine in our lager module just before
62:15 - calling our remote service to log the
62:18 - message we're going to raise an event
62:21 - called logging and while raising this
62:25 - event we also want to send some data
62:28 - that is the message that we're going to
62:31 - lock so what I want you to do is to use
62:34 - what you have learned in this lecture
62:36 - and raise and handle is logging event
62:39 - it's a very simple exercise I just want
62:41 - you to get used to this syntax
62:48 - now in the real world is quite rare that
62:51 - you would work with this event emitter
62:54 - object directly instead you want to
62:57 - create a class that has all the
62:59 - capabilities of the event emitter and
63:02 - then you will use that class in your
63:04 - code let me explain what I mean by that
63:06 - and why so let's open up our lager
63:10 - module so in this module we're exporting
63:13 - a simple function log right and here we
63:17 - log that message on the console now
63:19 - after this we want to raise an event and
63:23 - then later in app module we will listen
63:25 - for that event and do something so let's
63:28 - go back to our app module and copy some
63:31 - code into the lager module so on the top
63:34 - I'm gonna copy these two lines to bring
63:37 - the event emitter in this module okay
63:41 - now back in app module I'm also gonna
63:44 - move these two lines for raising an
63:47 - event into the lager module because this
63:49 - code should not be here it's the lager
63:51 - module that emits or signals an event
63:55 - saying the message is locked so cut so
63:59 - here after we log the message you raise
64:02 - an event like this okay
64:05 - now back in app module we don't need
64:09 - this comment here we need to load the
64:11 - lager module and call the log function
64:14 - so constant log we call the require
64:19 - function and set the path to the lager
64:22 - module and here we simply call the log
64:26 - function with a message okay now when we
64:31 - run this application we are only going
64:33 - to see this message on the console in
64:36 - other words this event listener will not
64:39 - be caught let's verify that and then I
64:42 - will explain why that happens
64:44 - so back in terminal node app J s look we
64:50 - only got the message on the console so
64:53 - our event listener was not caught the
64:56 - reason for this is because here we're
64:59 - working with two different event
65:02 - emitters in app j/s we have this even
65:05 - emitter object and in longer module we
65:09 - have another event emitter object so
65:13 - earlier I told you that a class is like
65:15 - a blueprint and an object is an actual
65:18 - instance as a metaphor I said we could
65:21 - have a class called
65:22 - human or person but the objects could be
65:25 - Jack John Mary Bob whatever so in this
65:28 - case we have two different objects in
65:30 - the logger module you're using this
65:33 - emitter object to emit an event whereas
65:37 - in app module we're using another event
65:40 - emitter object to handle that event
65:43 - these are completely different so when
65:46 - we register a listener here that
65:49 - listener is only registered with this
65:51 - event emitter which is completely
65:53 - different from the other event emitter
65:56 - so that's why I told you in your
65:59 - applications it's very rare that you
66:01 - would want to work with this event
66:02 - emitter directly instead you want to
66:04 - create a class that has all the
66:06 - capabilities of this event emitter but
66:09 - it has additional capabilities in this
66:12 - case we want to create a class called
66:14 - logger that has this additional method
66:17 - lock okay so the first thing you want to
66:21 - do here is to define a class in es6 we
66:24 - have this keyword class which is a
66:26 - syntactical sugar for creating a
66:29 - constructor function with this we can
66:31 - define a class logger note that the
66:34 - first letter of every word in a class
66:37 - should be uppercase this is the Pascal
66:39 - case convention that we use for naming
66:42 - classes so class logger we have a code
66:46 - block now we need to move this log
66:49 - function inside this logger class so cut
66:53 - paste it here now we have an error
66:56 - because when we define a function inside
66:58 - a class we don't need this function
67:00 - keyword and from now on we refer to this
67:03 - function as a method so when a function
67:06 - is inside a class we say that's a method
67:09 - in that class okay so here we have this
67:11 - logger class now at the end
67:15 - I'm exporting the log function we're
67:17 - going to export the logger class okay
67:21 - now we want this logger class to have
67:23 - all the capabilities of this event
67:26 - emitter the way we do that is by using
67:29 - the extends keyword that comes in es6 so
67:33 - extends and here we add the name of the
67:36 - parent or the base class so event
67:40 - emitter and with this simple change this
67:44 - logger class will have all the
67:46 - functionality that is defined in event
67:49 - emitter so here when raising this event
67:52 - instead of using this emitter object
67:55 - we're going to use this so in this class
67:59 - we can directly omit or raise events
68:03 - okay and now we no longer need this
68:06 - actual emitter object because we have
68:09 - not used it anywhere in this code so
68:12 - delete we're done with the logger module
68:15 - now back in the app module
68:18 - so here when requiring the logger module
68:21 - we get a class so I'm gonna rename this
68:24 - to lager with capital L that's a class
68:28 - now we create an object so new lager
68:37 - and then to log a message recall logger
68:40 - deadlock now similar to the change that
68:44 - we made in the logger module we no
68:47 - longer need this event a meter object
68:49 - here we want to work directly with this
68:52 - logger object so we're gonna register
68:55 - this listener on this logger object okay
68:59 - so I'm gonna move this code after
69:05 - creating the logger we say hey logger
69:09 - when you raise this message log event I
69:13 - want to execute this code okay and
69:16 - finally you can see we no longer need
69:18 - this event emitter object it's not used
69:21 - anywhere delete now when you run this
69:25 - application we're going to see this
69:27 - message on the console but also because
69:30 - we're using the same logger object for
69:33 - registering an event listener and also
69:35 - raising an event we're going to see this
69:38 - message on the console so note fjs look
69:44 - this is the message on the console and
69:47 - you can see our listener was
69:49 - successfully caught so let's quickly
69:51 - recap if you want to raise events in
69:55 - your application to signal that
69:57 - something has happened you need to
69:58 - create a class that extend event emitter
70:02 - with this that class will have all the
70:05 - functionality defined in event emitter
70:07 - but you can also add additional
70:10 - functionality in this case we have the
70:12 - ability to log a message and then inside
70:15 - that class whenever you want to raise an
70:17 - event you use this that emit because
70:20 - this references this longer class itself
70:23 - which extends event emitter so all the
70:27 - methods defined an event emitter will
70:29 - also be part of this class okay and
70:32 - finally in app module again instead of
70:36 - using an instance of event emitter you
70:40 - will use an instance of the custom class
70:43 - that you have defined that extends event
70:46 - emitter
70:51 - one of the powerful building blocks of
70:53 - node is the HTTP module that we use for
70:57 - creating networking applications for
71:00 - example we can create a web server that
71:02 - listens for HTTP requests on a given
71:05 - port and with this we can easily create
71:07 - a back-end service for our client
71:10 - applications like a web application that
71:12 - we build with react or angular or a
71:15 - mobile application running on a mobile
71:17 - device so once again back in the note
71:20 - documentation in the list of modules we
71:22 - can find this HTTP module in this module
71:27 - you can see various classes like HTTP
71:29 - that agent HTTP that client requests and
71:33 - so on each of this classes has a bunch
71:35 - of properties methods and events so back
71:39 - in vs code let's load the HTTP module so
71:43 - constant HTTP we set it to require HTTP
71:49 - okay now here we can call HTTP dot
71:53 - create server this is one of the
71:57 - functions defined in this module and
71:59 - with this we can create a web server so
72:03 - let's store the result in a server
72:05 - object now what is interesting is that
72:09 - this server is an event emitter so it
72:13 - has all the capabilities of event
72:15 - emitter that you saw earlier in this
72:17 - section so look server dot we have the
72:21 - on method or add listener or omit and so
72:25 - on also if you look at the documentation
72:29 - for the HTTP module on this page you can
72:32 - see HTTP that's server class here the
72:36 - documentation says that this class
72:37 - inherits from net dot server so this is
72:40 - another class defined in the net module
72:43 - let's have a look now here the
72:47 - documentation says that net the server
72:49 - is an event emitter so that's why I said
72:53 - a bunch of notes core functionality is
72:55 - based on if an emitter so back to our
72:59 - server object now we can call server
73:02 - that listen
73:05 - and give it a port let's say port 3000
73:08 - now following that I'm gonna add a
73:11 - console deadlock saying listening on
73:16 - port 3000 okay now when we run this
73:20 - application this server will listen on
73:22 - port 3000 as I told you before every
73:25 - time there is a new connection or new
73:27 - request this server raises an event so
73:31 - we can use the own method to handle that
73:34 - event so before listening we want to
73:36 - register a listener or a handler so
73:39 - server dot on the name of the event is
73:44 - connection then you can find in the
73:46 - documentation so you don't have to
73:48 - memorize any of these stuff okay and the
73:51 - second argument is a callback function
73:54 - or the actual listener as you can see in
73:57 - the tooltip here this listener is a
74:00 - function with one argument that is
74:01 - socket of type socket class and it
74:05 - returns void so here we have the arrow
74:08 - function syntax in es6 so let's add an
74:11 - error function that takes a socket and
74:14 - goes to this code block now here we can
74:19 - simply log something on the console new
74:22 - connection now back in the terminal
74:28 - let's run this application we can see we
74:31 - are listening on port 3000
74:34 - now back in the browser let's head over
74:36 - to localhost port 3000 and now if you
74:40 - look in the terminal you can see we have
74:42 - a new connection here so you can see
74:45 - this server object raises different
74:47 - kinds of events that you can respond to
74:49 - now in real world applications we are
74:51 - not going to respond to the connection
74:53 - event to build an HTTP service this is
74:56 - very low level so let's delete this what
75:01 - we commonly do is we pass a callback
75:04 - function to this create server method so
75:07 - function this function takes two
75:10 - parameters request and response or we
75:16 - can use the error function syntax so we
75:18 - remove the function keyword and add this
75:21 - fat arrow here now in this function
75:25 - instead of working with a socket we can
75:27 - work with the actual request or response
75:30 - objects so we can check if request that
75:33 - URL equals slash then we can send
75:38 - something to the client for example
75:39 - response dot write hello world and then
75:46 - we end the response okay now back in the
75:51 - terminal we can exit here by pressing
75:54 - ctrl + C and then run the application
75:58 - again okay we're still listening on port
76:00 - 3000 let's refresh this page so we got
76:04 - hello world on home page now if you want
76:08 - to build a back-end service for our web
76:10 - or mobile applications we need to handle
76:13 - various routes here for example we can
76:16 - have another if block if requested URL
76:20 - equals slash API slash courses
76:24 - perhaps here we want to return the list
76:26 - of courses from the database so we would
76:30 - do something like this response dot
76:33 - right here we want to return an array of
76:36 - objects using JSON so we use JSON dot
76:41 - stringify and give it an array of
76:45 - objects now for simplicity here we don't
76:47 - have to worry
76:48 - the database or complex objects let's
76:51 - just return an array of numbers 1 2 & 3
76:56 - so we pass this to json stringify which
77:00 - will convert this array into a string
77:02 - using json syntax and then we'll write
77:05 - it to the response and finally response
77:07 - the end now back in the terminal we need
77:13 - to stop this process again and run it
77:17 - one more time now in the future I will
77:18 - show you how we can automate this so
77:21 - every time we make a simple change to
77:22 - our application we don't have to restart
77:24 - it so now back in the browser if we go
77:28 - to slash API slash courses we get an
77:32 - array with three numbers so as you see
77:36 - building a web server we know it is very
77:38 - easy now in the real world we are not
77:40 - going to use this HTTP module to build a
77:43 - back-end service for our application the
77:46 - reason for this is because as you can
77:48 - see here as we add more routes this code
77:52 - gets more complex because we add all of
77:55 - them in a linear way inside this
77:58 - callback function so instead we use a
78:00 - framework called Express which gives our
78:03 - application a clean structure to handle
78:06 - various routes internally the Express
78:09 - framework is built on top of the HTTP
78:12 - module in node

Cleaned transcript:

no js' or note is an open source and crossplatform runtime environment for executing JavaScript code outside of a browser quite often we use no to build backend services also called api's or application programming interfaces these are the services that power our client applications like a web app running inside of a web browser or mobile app running on a mobile device these client apps are simply what the user sees and interacts with they're just the surface they need to talk to some services sitting on the server or in the cloud to store data send emails or push notifications kick off workflows and so on node is ideal for building highly scalable data intensive and realtime backend services that power our client applications now you might ask but mosh there are other tools and frameworks out there for building backend services such as a speed a bed rails Django and so on so what's so special about no well note is easy to get started and can be used for prototyping and agile development but it can also be used for building super fast and highly scalable services it's used in production by large companies such as PayPal uber Netflix Walmart and so on in fact at PayPal that rebuilt one of their Java and spring based applications using node and it found that the node application was built twice as fast with fewer people in 33% fewer lines of code and 40% fewer files and more importantly they double the number of requests served per second while decreasing the average response time by 35% so node is an excellent choice for building highly scalable services another reason for using node is that in old applications we use JavaScript so if you're a frontend developer and know JavaScript you can reuse your JavaScript skills and a fullstack developer and get a better job with better pay you don't have to learn a new programming language also because you can use JavaScript both on the front end and on the back end your source code will be cleaner and more consistent so you will use the same naming conventions the same tools and the same best practices and finally another reason for using node is that it has the largest ecosystem of open source libraries available to you so for pretty much any features or building blocks you want to add your application there is some free open source library out there that you can use so you don't have to build this building blocks from scratch and instead you can focus on the core of your application next we're going to look at the architecture of node so in the last video you learned that note is a runtime environment for executing JavaScript code but what is a runtime environment really well before node we use JavaScript only to build applications that run inside of a browser so every browser out there has what we call a JavaScript engine that takes our JavaScript code and converts it to code that a computer can understand for example Microsoft eight uses chakra Firefox uses spider monkey and chrome uses v8 and it's because of these varieties of engines that sometimes JavaScript code can behave differently in one browser or another now a browser provides a runtime environment for JavaScript code for example you probably know that in browsers we have the window or the document object these objects allow us to work with the environment in which our code is running now up to 2009 the only way to execute JavaScript code was inside of a browser in 2009 Brian Dahl the creator of node came up with a brilliant idea he thought it would be great to execute JavaScript outside of a browser so he took Google's v8 engine which is the fastest JavaScript engine out there and embedded it inside a C++ program and called that program node so similar to a browser node is a runtime environment for JavaScript code it contains a JavaScript engine that can execute our JavaScript code but it also has certain objects that provide an environment for our JavaScript code but these objects are different from the environment objects we have in browsers for example we don't have the document object instead we have other objects that give us more interesting capabilities for example we can work with the file system listen for requests and a given port and so on we can't do stuff like that inside of a browser right so in essence node is a program that includes the v8 JavaScript engine plus some additional modules that give us capabilities not available inside browsers we can work with the file system or the network and so on both chrome and note share the same JavaScript engine but they provide different runtime environments for JavaScript now I've seen people comparing no to csharp or Ruby or some other programming languages but this comparisons are fundamentally wrong because node is not a programming language it's like comparing a car with an apple by the same token note should not be compared with frameworks such as a spool of meth or rails or Django and so on these are frameworks for building web applications note is not a framework it's a runtime environment for executing JavaScript code next we're going to look at how node works so earlier I mentioned that note applications are highly scalable and this is because of the nonblocking or asynchronous nature of note what do you mean by asynchronous let me give you a metaphor imagine you go to a restaurant a waiter comes to your table takes your order and gives it to the kitchen then they move on to serve another table while the chef is preparing your meal so the same person can serve many different tables they don't have to wait for the chef to cook one meal before they serve another table this is what we call nonblocking or asynchronous architecture and this is how node applications work the waiter is like a thread allocated to handle a request so a single thread is used to handle multiple requests in contrast to nonblocking or asynchronous architecture we have blocking or synchronous architecture let's see how that works so back to our restaurant example imagine you go to another restaurant and in this restaurant a waiter is allocated to you they take your order and give it to the kitchen now they are sitting in the kitchen waiting for the chef to prepare your meal at this time they're not doing anything else they're just waiting they're not going to take an order from another table until your meal is ready this is what we call blocking or synchronous architecture and that's how applications built with frameworks like a speed net or rails work out of the box so when we receive a request on the server a thread is allocated to handle that request as part of handling that requests and is likely that we're going to query a database and as you know sometimes it may take a little while until the result is ready when the database is executing the query that thread is sitting there waiting it can't be used to serve another client so we need a new thread to serve another client imagine what would happen if we have a large number of concurrent clients at some point we're going to run out of threads to serve these clients so new clients have to wait until three threads are available or if we don't want them to wait we need to add more hardware so with this kind of architecture we are not utilizing our resources efficiently this is the problem with blocking or synchronous architecture and as I explained that's how applications built with frameworks like a speed a that worked by default of course in asp.net it is possible to use asynchronous architecture what you will have to do extra work for now in contrast no the applications are asynchronous by default so you don't have to do anything extra in node we have a single thread to handle all requests when a request arrives that single thread is used to handle that request if we need to query a database or thread doesn't have to wait for the database to return the data while the database is executing our query that thread will be used to serve another client when the database prepares the result it puts a message in what we call an event queue node is continuously monitoring this queue in the background when it finds an event in this queue it will take it out and process it this kind of architecture makes node ideal for building applications that include a lot of disk or network access we can serve more clients without the need to throw in more hardware and that's why no the applications are highly scalable in contrast node should not be used for CPU intensive applications like a video encoding or an image manipulation service in this kind of applications we have a lot of calculations that should be done by CPU and few operations that touch the file system or the network since no the applications are single threaded when performing the calculations to serve one client other clients have to wait and that's why node should not be used or CPU intensive applications it should only be used for building data intensive and realtime applications okay enough theory Nix I'm gonna show you how to install node and build your first node application you in this lecture I'm going to show you how to install note if you're on Windows open up command prompt if you're on Mac or Linux open up the terminal first let's see if you already have node on your machine or not so run note space version you can see on this machine I'm running node version 6.0 point three this is an earlier version of node the latest stable version is version eight now on your machine chances are you may not have known or you might have an earlier version either way I want you to install the latest version of node so open up your browser and head over to note J s org on this home page you can see we have two versions for note one is the latest stable version which is recommended for most users at the time of recording this video test version eight point nine point one and there's always a newer version which is experimental and it might not be stable so I want you to install the latest stable version also take into account that in the future when you're watching this video chances are the latest stable version might be newer if you're worried that this course is going to get outdated don't worry because in this course we're going to focus on the fundamentals so I'm going to work with the core modules of note these core modules are stable they have been there for a long time so the code that we're going to write in this course will continue to work with the future versions of note once you master the fundamentals you can always learn about the new features that come in every version by looking at the change lock so let's not worry about the fancy new features in node and focus on the fundamentals so let's go ahead and install the latest stable version you can see here I get a package we run it it's an installer take a look very simple just continue continue continue install you need to enter our password and the installation is complete it took only a few seconds so now back in the terminal let's run node version one more time you can see I upgraded my node to version eight point nine point one next we're going to build our first node application alright now we're ready to build our first node application so I'm gonna create a new folder call it first app let's go to this folder now I'm going to open this folder inside of Visual Studio code which is my preferred code editor so code period so this is Visual Studio code or vs code it's a free powerful editor but you can use any editors that you prefer you can use sublime you can use atom or any other editors so here in this folder I'm gonna add in your file app is in this file we can write regular JavaScript just like the JavaScript that we write for the browsers so I'm gonna define a function say hello that takes a parameter name and simply logs a message on the console so hello + name and then we can call this function like this Marsh now to execute this code we're going to go back to the terminal and run node and pass the name of the file as an argument so app the jas so node as I told you before is a C++ program it includes Chrome's v8 JavaScript engine so this app the J's file that we're gonna pass to node node is going to give it to v8 for execution so you can see we got hello Marsh on the console now let me show you something so back in vs code temporarily comment out this line and do it console that log of window let's see what happens so back in the terminal let's run node app a Jas you got an exception window is not defined so as I told you before in node we don't have the window or document objects these are part of the runtime environment that we get with browsers in node we have other objects to work with files with the operating system with the network and so on and that's what you're gonna learn about in the next section I hope you enjoyed this section and thank you for watching in this section we're going to look at the module system in node you will learn what modules are why we need them and how they work throughout this section we'll explore a feel of the modules built into the core of node such as operating system file system events and HTTP you will also learn how to create your own modules now let's get started so in the last section we use this console that log function to lock something on the console now this console object is what we call a global object so it's part of the global scope which means we can access it anywhere in any files we have a bunch of other objects and functions that are also globally available in node for example we have set timeout which you have probably seen before we use this to call a function after a delay like one second two second whatever so this is just part of the standard JavaScript we can use this on the client we can use this inside of a browser or inside of node we also have clear timeout similarly we have set interval which we use to repeatedly call a function after a given delay we also have clear interval which we use to stop that function from being called repeatedly so these are the global objects in JavaScript now he node we have a couple other global objects that you're going to learn about later in this section now in browsers we have this window object that represents our global scope so all the variables and functions that are defined globally we can access them via this window object so we can call window that console that log or simply just console that lock the JavaScript engine will prefix this statement with window that console dot lock because that's where this object is defined similarly all these other functions you see here they belong to the window object so we can call window that's set timeout or call it directly by the same token when we declare a variable let's say message that variable is also available via the window object okay however in the last section I told you that in node we don't have this window object instead we have another object called global so all these functions and objects we have here we can access them find the global object so we can do global that console dot log or global that set timeout and so on of course it's easier to use the shorthand instead of prefix in them with this global but one thing you need to know about note is that these variables that we define here they are not added to the global object in other words if we do a console dot log of global that message we are going to see undefined on the console so let me show you I'm gonna delete all the code here now back in the terminal let's run note app j s so we get undefined in the console so as you can see the variables and functions that we defined here they are not added to the global object they're only scoped to this fire app dot j s so they are not available outside of this file and this is because nodes modular system that you're going to learn about in the next lecture you so in the last section you'll learn that in the clientside JavaScript that we run inside of browsers when we declare a variable or a function that is added to the global scope for example when we define a function like say hello that function is added to the global scope and it's available via the window object now there is a problem with this behavior in a real world application we often split our JavaScript code into multiple files so it is possible that we have two files and in both these files we define this function say hello with the exact same name because this function is added to the global scope when we define this function in another file that new definition is going to overwrite the previous definition so this is the problem with the global scope so in order to build reliable and maintainable applications we should avoid defining variables and functions in the global scope instead we need modularity we need to create small building blocks or modules where we define our variables and functions so two variables or two functions with the same name don't overwrite another variable or function defined somewhere else that encapsulated inside of that module now at the core of node we have this concept called module so every file in a node application is considered a module the variables and functions would define in that file or that module are scoped to that file in objectoriented programming terms we say there are private they are not available outside that container outside that module if you want to use a variable or a function defined in a module outside that module you need to explicitly export it and make it public and we're going to look at that in the next lecture so what I want you to take away from this lecture is that every node application has at least one file or one module which we call a main module so in this case is after J s is our main module now let me show you this module so I'm going to delete all this code here and do a console that log of module now this module object here may appear to be global so you may think we can access it while the global object like global console but actually this is not a global object it appears to be global but it's not global and you will find out why very soon so let's just lock this module object and see what we see in the console back in the terminal node app the jas so you can see we have an object module it's a JSON object with these key value pairs so we have ID every module has an ID or a unique identifier we have exports parent file name which is the complete pass to that file loaded which is a boolean that determines if this module is loaded or not we have children and paths now for now don't worry about these properties as we go through this section you will gradually become familiar with this properties so in node every file is a module and the variables and functions defined in that file are scoped to that module they are not available outside of that module in the next lecture you're going to learn how to create and load a module alright now let's add a new module to this application so I'm gonna add a new file logger dot J s let's imagine we're going to create a module for login messages and we're gonna reuse this module in various parts of this application or potentially in other applications so loggernet J s now in this module let's imagine that we're going to use one of those remote logging services for login our messages so there are websites out there there provide logging as a service they give us a URL and we can send an HTTP request to that URL to log messages in the cloud so here I'm gonna declare a variable like URL and set it to something like this HTTP my lager dot io / lock and of course I'm making this up it may not be a true service out there but let's imagine in this implementation we're going to send an HTTP request to this endpoint to this URL now we also need a function called log that takes a message and in this function we're going to send an HTTP request however to keep things simple here we just want to focus on the modularity we don't want to get distracted with all the details of sending HTTP requests so for now I just want to log this message on the console so console that log message okay now this variable and this log function they're both scoped to this module they're private they're not visible from the outside however in after j/s which is our main module we want to use this logger module so we should be able to access this log function we should be able to call it from the app module so we need to make this public we need to make it visible from the outside now in the last lecture you saw this module object one of the properties we have here is exports you can see this property is set to an empty object anything that we add to this object will be exported from this module and it will be available outside of this module so back in our lager module I'm gonna set module dot exports dot log so I'm adding a method called log to this exports object and simply setting it to this log function we have defined here okay in other words the object that we're exporting here has a single method called lock now similarly if you want to export this URL we could do something like this so module that exports that URL we set it to URL and of course we could change the name that is exported to the outside for example internally we may call this variable URL but when we export it we may call it endpoint okay now in this case we don't need to export this URL variable because this is purely implementation detail so in real world applications every module might have several variables and functions we only want to export a subset of these members to the outside because we want to keep this module easy to use let me give you a metaphor think of a DVD player a DVD player has a few buttons on the outside and these are the buttons or objects that we interact with so these objects represent the public interface of a DVD player okay but inside the box there are lots of other objects or complex objects we don't need to know anything about these objects their implementation data and they can change significantly from one model to another but what you see on the outside is almost stable or static across different models so in our lager module this URL is implementation detail modules don't need to know anything about this they only need to call the log function so we export these make it public but keep the URL private so I'm gonna delete this last line okay so we're done with our logger module now we need to load this module and use it inside app j/s to load the module we use the require function this is one of the functions in node we don't have this in browsers this function takes one argument and that's the name or path of the target module we want to load so here we want to load the logger module now you can see both the app module and longer module are in the same folder so we use period slash to indicate the current folder and then we add the name of our module that is logger ojs or we can make it shorter and just use logger because node assumes this is a JavaScript file and it automatically asked the GS extension now if this logger was in a subfolder we could add that soft folder here or if it was in the parent folder we could use dot dot slash so here we are using the relative path to the target module in this case that module is in the same folder now this required function returns the object that is exported from this target module so this exports object here this is what we get when we call the require function let me show you so I'm gonna declare a variable call it lager the name of the module and set it to the return value of the require function now let's log this logger and see what we get so node object s look we get an object this object has a single method called log can see that's a function so we can call this function or this method in app J s so back here we call logger dot and look here we have intelligence in BS code so we call log and pass a message now I can terminal let's run this app and we get message on the console so this is how we work with modules in node when we define a module we export one or more members and then to load the module we use the require function now in the recent versions of JavaScript we have the ability to define constants so as a best practice when loading a module using the required function it's better to store the result in a constant like this the reason for this is because we don't want to accidentally overwrite the value of logger like this here if we set this to one then when we call the log method we're going to get an exception let me show you so one more time look you got logger that log is not a function now in contrast if we define this as a constant now back in the terminal let's run this program one more time look we got a different kind of error assignment two constant variable now there are tools out there that check our JavaScript code for errors like that so by using this constructs properly we can prevent these errors from happening at runtime so one of these popular tools is J's hint if you have never used it before don't worry I'm just gonna show you a quick demo so if you're on J's hint 1/2 Jas we get this error attempting to overwrite logger which is a constant so with tools like jeaious hint we can scan all our JavaScript code for errors like that so that's the benefit of using a constant as opposed to a variable here if you accidentally reset this object then we're gonna get an error at compile time instead of at run time okay and one last thing before we finish this lecture sometimes instead of exporting an object from a module you may want to export only a single function for example here in our lager module we don't necessarily need an object because we have a single method an object would be useful if we had multiple methods or properties here but in this case instead of sporting an object we can export a single function so we can reset this exports to the log function so initially it was an empty object but we reset it to just a function with that I can op j s the logger is no longer an object it's a function that we can call directly like this so logger we call it and give it an argument now a better name for this function is LOC so I'm gonna press f2 to rename these log like this now back in terminal let's run node FJ s and we get the same result so in your modules you can export a single function or an object so now you know the variables and functions we define in a module are scoped to that module they're private and not visible from the outside but you might be wondering how node does this so let me show you on the very first line of the logger jeaious module I'm going to create a syntactical error so define a variable X and set it to nothing like this so make sure to write this code on the very first line in other words if you have a line break here and do this on a second line you're not going to see what I'm gonna show you now so put this back on the first line here we have a syntactical error now back in the terminal let's run the application again okay we got on touken semicolon right but look above this line you see this function declaration so this function has a few parameters exports require module file name and surname so let me copy this code here now basically what happens under the hood is that note does not execute this code directly it wraps it inside of a function and that's the function you saw so at runtime our code is going to be converted to something like this so we have this function declaration here is the body of that function now for now I'm gonna remove this error here so this is our code and then we have the end of this function now the actual code is slightly more complicated than this but we don't want to get distracted with that complexity if you're a more advanced JavaScript developer you probably know this is an immediately invoked function expression or if you if you don't know that don't worry that's not really the scope of note what I want you to take away here is that note does not execute our code directly it always wraps the code inside each module and something like this inside of a function now look at these arguments to this function so you have seen the required function I told you that this required function appears to be global but actually it's not global in fact it's local to each module so in every module require is one of the arguments that is passed to this function we call this function the module wrapper function okay so you have seen the require function you have also seen module that is what we're using here so we have module that exports we also have exports which is a shortcut to module dot export so if you want to add a function to module that exports object you can either write module that exports dot log equals log or you can write exports that log equals log but you cannot reset this export like what we did earlier in other words you cannot write export equals lock because this export is a reference to module and exports we can change that reference okay so these are the first three arguments we also have filename and Durning which represent the name of this file and the pass so let's have a quick look at this argument on the top I'm gonna do a console that log of underline underline file name and also underline underline Durning now we're not going to have this function this module wrapper function this was purely for demonstration so I'm gonna revert the code back to what we had before okay so now we don't have any errors in this module let's go back to the terminal and run this program so note op j s so here on the first line we have file name which is the complete path to that file that is lager a s and on the second line we have the path to the directory that contains and module so now you have a basic idea about node modules and how they work you know how to create them how to load them but knowing itself comes with a bunch of useful modules that we can use in a lot of applications and that's what we're going to look at in the next lecture hi guys thank you for watching my Noah tutorial I wanted to let you know that this tutorial is the first hour of my complete note course where you will learn how to build a real restful api using node Express and MongoDB all of that recorded with the latest version of node and modern JavaScript so you will learn new and modern ways of building applications with node unlike other courses that only show you simple the only examples like how to build a todo app we're gonna work on a realworld project a restful api for a video rental application if you have taken any of my courses you know I don't waste your time by explaining the obvious like what a code editor or command prompt is we're gonna get straight to the business and as part of this I'll be touching on various important topics that you need to understand really well including working with node package manager or NPM asynchronous JavaScript including callbacks promises async and await implementing crud operations data validations authentication and authorization using JSON web tokens including role management handling and login errors unit and integration testing testdriven development so you will see I will build a feature from A to Z using testdriven development or TDD and finally we'll deploy this application to the cloud throughout the course I will share with you lots of clean coding and refactoring techniques security best practices useful libraries to use as part of your development common mistakes that many node developers make and much much more the course is currently 14 hours long and I'm planning to add more content to it in the future you can watch this course as many times as you want and if you watch it to the end you will get a certificate of completion that we can add to your resume so if you're serious about adding no to your resume I highly encourage you to enroll in the course and don't waste your time jumping from one tutorial to another so click on the link in the video description to enrol I hope to see you in the course you so in the last lecture I told you that in node we have a few useful modules that are built into the core of node with these modules we can work with files with the operating system with a network and so on so let's have a quick look at this built in modules head over to node J s org then go to Docs on the left side go to version eight point nine point three that's the current stable release chances are by the time you're watching this video this version might be different so that doesn't really matter just pick that version now hearing the table of contents we can see the built in modules of course not everything you see here is a module for example we have console which is our console object we have buffer which we're going to learn about in the future in this course again that's a global object but you can see that this is a fairly short list and some of the items in this list are built in modules in no so just that you can see there are not many modules built into note I'm gonna highlight a few very useful modules that you should be aware of for example we have file system to work with files we have HTTP that you're going to learn about later in this section so with this we can create web servers that listen for HTTP requests we have OS to work with the operating system we have path which gives us a bunch of utility functions for working with paths we have process that gives us information about the current process we have query strings which is very useful in building HTTP services we have a stream which allows us to work with streams of data again you're going to learn about this in the future and a bunch of other modules now in this lecture we're going to look at is passed module so on the documentation you can see all the functions defined in this module in this lecture we're going to use the parse method now if you scroll down you can see how you can use this module so I've seen the required function before we call the module using the required function get the result which is an object and store it in a constant so back in vs code in app Jas let's call require and as the argument use half now the argument that we gave to this require function no it assumes that this is a built in module if there is no built in module by the name specified here then node looks for the existence of a relative path to a file in this application so if we have period / or period period / whatever then notice oome this is a file in this application now in this case we're going to load the building path module and store it in a constant called pass so this is an object with a bunch of useful methods the method we're going to use is the parse method so I'm gonna give it this underline underline file name which is one of the arguments and the module wrapper function that you saw in the last lecture so let's call this and store the result in pass object and then finally log it on the console has object now back in the terminal let's run this application so this is the path object it has a few useful properties we have root we have dur which specifies the path to the folder containing this file here's the name of the file after jas here's the extension the name of the file without the extension so if you want to work with pads it's much easier to use the past module as opposed to working with strings in the next lecture we're going to look at another builtin module that gives us information about the operating system in this lecture I'm going to show you how to get information about the current operating system so if I can no documentation in the list of modules if you scroll down you can see this OS module let's have a quick look here so these are the methods that are available in this module for example we have free mem which returns the amount of free memory on this machine you also have total mem which is the total memory we can get information about the current user we can get the uptime of this machine and so on so let's use a couple of these methods here so if you scroll down you can see this is how we load this OS module just like loading other modules we call the required function and store the result in a constant called OS or anything so my can be a scone I'm gonna delete all the code here and define a new constant OS and study to require OS now we can call total mem method or free mem or other methods so let me declare a variable and store the result here and similarly for the free memory free memory and finally let's lock these values on the console so console dot log single code we add total memory and app and this total memory here now we can simplify this expression by using a template string which is available in more recent versions of JavaScript that we refer to as es6 or ES 2015 which is short for ACMA script 6 or 2015 that's the specification that defines what features are available in JavaScript so every year Ahmed defines new features that should be added to JavaScript and as you know different browsers implement different set of these features but the v8 engine that we have inside of node that's pretty uptodate and it implements a lot of new features of JavaScript that is defined in Eggman script so in Eggman script six or eight most script 2015 we have a feature called template string which helps us build a string without concatenations let me show you how that works so console dot log now instead of a single quote we use the backtick character backtick is the character before number 1 on your keyboard so here we add some static text like total memory now we want to add something here dynamically so we use dollar sign and curly braces to add a placeholder for an argument in this case our argument is this total memory variable so we can see with a template string we don't have concatenation okay now I'm gonna duplicate this line and change total to free and here let's add free memory okay now we don't need this first console log we're done with this let's go back to the terminal and run this app occasion so note app but Jas and you can see the total and free memory on my machine now what is interesting here is that before node we could not get this kind of information using javascript javascript used to run only inside of a browser and we could only work with the window or document objects we couldn't get information about the operating system but when using node our JavaScript code is executed outside of a browser or as some people say on the server with this we can get information about the operating system we can work with files we can work with the network for example we can build a web server that listens for HTTP requests on a given port and I'm going to show you all this later in this section and it's lecture I'm gonna show you how to work with files in node so I can no documentation and the list of modules here we have a module called file system in this module we have a comprehensive set of methods for working with files and directories now in this course I'm not gonna waste your time showing you every single method here because that would be very repetitive but let me show you an example so you see how to work with files in node so back in vs code first we need to require the FS module we get the result and store it in this constant now FS dot look almost every operation defined here comes in two forms synchronous or blocking and asynchronous or non blocking for example look we have access which is an asynchronous method we also have access sync which is a synchronous method now even though we have these synchronous methods here you should avoid using them these are there purely for simplicity in a real world application you should use asynchronous methods because these are non blocking so as I told you in the last section a node process has a single thread if you're using node to build the backend for your application you might have several hundreds or thousands of clients connecting to that backend if you keep that single thread busy you won't be able to serve many clients so always use asynchronous methods now that aside let's take a look at an example we're going to look at rate dir or directory method first I'm going to show you the synchronous form because that's easier to understand so as the first argument we specify the path period slash represents the current folder and this will return all the files and folders in the current folder so files will be a string array now we can display that on the console very simple so note fjs so we can see we get an array of strings and these are the files in this folder on my machine now let's take a look at the asynchronous form of this method so FS dot read directory just like before the first argument is the path so the current folder now all these asynchronous methods take a function as their last argument no it will call this function when that asynchronous operation completes we call this function a callback so here look in the intellisense the second parameter is a callback and this is a function with two parameters an error and result which is in this case a string array so here we need to pass a function or a callback function with an error and the result which is a string array we can call that files so here we need to check if we have an error or the result only one of these arguments will have a value and the other will be not so if we have error we're going to display it on the console error error now this is not how we handle errors in a real world application but don't worry about this later in the course we have a complete section about error handling in note for now we just want to display this error on the console so if you have an error we display otherwise we display the result so console dot log result and we can display this string array so I'm gonna comment out these two lines so we can only look at the result of this asynchronous read directory now note up j/s so we got resolved and this is exactly the string array that we had before now let's simulate an error so I'm going to go back in the code and change this argument to let's say a dollar sign save back in the terminal node fjs this time we go and error no such file or directory so to recap in order to work with files and directories in node first you need to require the FS module and then use one or more of the methods defined in this module all these methods come in pairs asynchronous and synchronous always prefer to use asynchronous methods one of the core concepts in node is the concept of events in fact a lot of nodes core functionality is based on this concept of events an event is basically a signal that indicates that something has happened in our application for example in node we have a class called HTTP that we can use to build a web server so we listen on a given port and every time we receive a request on that port that HTTP class raises an event now our job is to respond to that event which basically involves reading that request and returning the right response so as you go through note documentation you can see that several classes in node raises different kinds of events and in your code you might be interested to respond to those events so in this lecture I'm gonna show you how to work with the events module now back in notes documentation once again in the list of modules you can see here we have this events module so in this module we have one class that is called event emitter it's one of the core building blocks of node and a lot of classes are based on this event emitter so let's see how we can work with this event emitter I can be ESCO first let's load the events module so require events here when we call the require function we get the event emitter class so constant event emitter note that here in terms of the naming the first letter of every word is uppercase this is the convention that indicates that this event emitter is a class it's not a function it's not a simple value it's a class a class is container for properties and functions which we call methods so in this event emitter class we have these metals that you see here in the documentation so a class is a container for a bunch of related methods and properties now here in order to use this event emitter first we need to create an instance of this class so constant emitter we set this to new event emitter so here this emitter is an object in case you don't know the difference between a class and an object let me give you a metaphor a class is like human and an object is like an actual person like John Mary and so on so a class defines the properties and behavior of a concept like a human but an object is an actual instance of that class okay so here this first event emitter is a class it's a blueprint it defines what an event emitter can do but this second emitter is an actual object this is the one that we're going to use in our application so this emitter has a bunch of methods look these are all the metals that you saw in the documentation now even though here we have more than ten metals most of the time we use only two of these methods one is emit that we use to raise an event the first time I saw this method it didn't make sense to me because English is my second language and I didn't know what emit means so if you're in the same boat ma it basically means making a noise or produce something in this case you're making a noise in your application you're signaling that an event has happened okay so that's the meaning of Emmet and here we pass an argument that is the name of the event let's say message locked in the future we're going to extend our lager module and every time we log a message we're going to raise an event called message locked okay now if you run this application nothing is going to happen let me show you back in the terminal node app J gasps look nothing happened because we have raised an event here but nowhere in our application we have registered a listener that is interested in that event a listener is a function that will be called when that event is raised okay so let's register a listener that will be called when the message log event is raised so register a listener so emitter dot look here we have this method add listener but we have an alias for this that we use more often that is on if you're worked with jQuery you have seen this before so on or add listener they're exactly the same but quit often reused on method now this method takes two arguments the first one is the name of the event in this case message locked and the second one is a callback function or the actual listener so here we pass a function and this function will be called when that event is raised okay now for now I just want to lock a message in the console so console let's say listener called like this now let's run this application so node FJ guess and we got this message listener call so this indicates that when we raise this event function or listener was called okay and of course the order is important here if you register this listener after calling the Amit method nothing would have happened because when we call the Amit method this eMeter iterates over all the registered listeners and calls them synchronously okay so this is the basic of raising events and handling them using the eve an emitter class now quite often when you want to raise an event we also want to send some data about that event for example in our lager module when we log a message perhaps our remote login service will generate an ID for that message perhaps we want to return that ID to the client or it may give us a URL to access that log message directly so here when raising an event we can add additional arguments which we refer to as event arguments so we can add an ID like one and we can add a URL but as you can see these magic values here are a little bit confusing if you want to send multiple values about an event it's a better practice to encapsulate those values inside an object so here we have an object we give it a couple of properties like ID we set it to ID of this message that is logged and another property URL like this okay so we're referring to this object as event argument now when registering a listener here this callback function this actual listener can also receive this event argument so here we add a parameter called arc we can call it anything the name doesn't matter but by convention we often use arc or some people use e to refer to the event or event arc whatever you prefer is perfectly fine so here we have arc now let's log in on the console very simple let's run this application so note okay look listen are called and here's our event arc and with this technique we can pass data about the event that just happened now one last thing to make this code a little bit simpler in es6 or equal script six we have this feature called arrow function with an arrow function we can get rid of this function keyword so here we have the arguments and after that we have the body of that function now to separate the two we use an arrow and that's why we call this arrow function you can see this syntax is a little bit simpler and a lot of people prefer to use arrow functions in es6 now here's a simple exercise for you let's imagine in our lager module just before calling our remote service to log the message we're going to raise an event called logging and while raising this event we also want to send some data that is the message that we're going to lock so what I want you to do is to use what you have learned in this lecture and raise and handle is logging event it's a very simple exercise I just want you to get used to this syntax now in the real world is quite rare that you would work with this event emitter object directly instead you want to create a class that has all the capabilities of the event emitter and then you will use that class in your code let me explain what I mean by that and why so let's open up our lager module so in this module we're exporting a simple function log right and here we log that message on the console now after this we want to raise an event and then later in app module we will listen for that event and do something so let's go back to our app module and copy some code into the lager module so on the top I'm gonna copy these two lines to bring the event emitter in this module okay now back in app module I'm also gonna move these two lines for raising an event into the lager module because this code should not be here it's the lager module that emits or signals an event saying the message is locked so cut so here after we log the message you raise an event like this okay now back in app module we don't need this comment here we need to load the lager module and call the log function so constant log we call the require function and set the path to the lager module and here we simply call the log function with a message okay now when we run this application we are only going to see this message on the console in other words this event listener will not be caught let's verify that and then I will explain why that happens so back in terminal node app J s look we only got the message on the console so our event listener was not caught the reason for this is because here we're working with two different event emitters in app j/s we have this even emitter object and in longer module we have another event emitter object so earlier I told you that a class is like a blueprint and an object is an actual instance as a metaphor I said we could have a class called human or person but the objects could be Jack John Mary Bob whatever so in this case we have two different objects in the logger module you're using this emitter object to emit an event whereas in app module we're using another event emitter object to handle that event these are completely different so when we register a listener here that listener is only registered with this event emitter which is completely different from the other event emitter so that's why I told you in your applications it's very rare that you would want to work with this event emitter directly instead you want to create a class that has all the capabilities of this event emitter but it has additional capabilities in this case we want to create a class called logger that has this additional method lock okay so the first thing you want to do here is to define a class in es6 we have this keyword class which is a syntactical sugar for creating a constructor function with this we can define a class logger note that the first letter of every word in a class should be uppercase this is the Pascal case convention that we use for naming classes so class logger we have a code block now we need to move this log function inside this logger class so cut paste it here now we have an error because when we define a function inside a class we don't need this function keyword and from now on we refer to this function as a method so when a function is inside a class we say that's a method in that class okay so here we have this logger class now at the end I'm exporting the log function we're going to export the logger class okay now we want this logger class to have all the capabilities of this event emitter the way we do that is by using the extends keyword that comes in es6 so extends and here we add the name of the parent or the base class so event emitter and with this simple change this logger class will have all the functionality that is defined in event emitter so here when raising this event instead of using this emitter object we're going to use this so in this class we can directly omit or raise events okay and now we no longer need this actual emitter object because we have not used it anywhere in this code so delete we're done with the logger module now back in the app module so here when requiring the logger module we get a class so I'm gonna rename this to lager with capital L that's a class now we create an object so new lager and then to log a message recall logger deadlock now similar to the change that we made in the logger module we no longer need this event a meter object here we want to work directly with this logger object so we're gonna register this listener on this logger object okay so I'm gonna move this code after creating the logger we say hey logger when you raise this message log event I want to execute this code okay and finally you can see we no longer need this event emitter object it's not used anywhere delete now when you run this application we're going to see this message on the console but also because we're using the same logger object for registering an event listener and also raising an event we're going to see this message on the console so note fjs look this is the message on the console and you can see our listener was successfully caught so let's quickly recap if you want to raise events in your application to signal that something has happened you need to create a class that extend event emitter with this that class will have all the functionality defined in event emitter but you can also add additional functionality in this case we have the ability to log a message and then inside that class whenever you want to raise an event you use this that emit because this references this longer class itself which extends event emitter so all the methods defined an event emitter will also be part of this class okay and finally in app module again instead of using an instance of event emitter you will use an instance of the custom class that you have defined that extends event emitter one of the powerful building blocks of node is the HTTP module that we use for creating networking applications for example we can create a web server that listens for HTTP requests on a given port and with this we can easily create a backend service for our client applications like a web application that we build with react or angular or a mobile application running on a mobile device so once again back in the note documentation in the list of modules we can find this HTTP module in this module you can see various classes like HTTP that agent HTTP that client requests and so on each of this classes has a bunch of properties methods and events so back in vs code let's load the HTTP module so constant HTTP we set it to require HTTP okay now here we can call HTTP dot create server this is one of the functions defined in this module and with this we can create a web server so let's store the result in a server object now what is interesting is that this server is an event emitter so it has all the capabilities of event emitter that you saw earlier in this section so look server dot we have the on method or add listener or omit and so on also if you look at the documentation for the HTTP module on this page you can see HTTP that's server class here the documentation says that this class inherits from net dot server so this is another class defined in the net module let's have a look now here the documentation says that net the server is an event emitter so that's why I said a bunch of notes core functionality is based on if an emitter so back to our server object now we can call server that listen and give it a port let's say port 3000 now following that I'm gonna add a console deadlock saying listening on port 3000 okay now when we run this application this server will listen on port 3000 as I told you before every time there is a new connection or new request this server raises an event so we can use the own method to handle that event so before listening we want to register a listener or a handler so server dot on the name of the event is connection then you can find in the documentation so you don't have to memorize any of these stuff okay and the second argument is a callback function or the actual listener as you can see in the tooltip here this listener is a function with one argument that is socket of type socket class and it returns void so here we have the arrow function syntax in es6 so let's add an error function that takes a socket and goes to this code block now here we can simply log something on the console new connection now back in the terminal let's run this application we can see we are listening on port 3000 now back in the browser let's head over to localhost port 3000 and now if you look in the terminal you can see we have a new connection here so you can see this server object raises different kinds of events that you can respond to now in real world applications we are not going to respond to the connection event to build an HTTP service this is very low level so let's delete this what we commonly do is we pass a callback function to this create server method so function this function takes two parameters request and response or we can use the error function syntax so we remove the function keyword and add this fat arrow here now in this function instead of working with a socket we can work with the actual request or response objects so we can check if request that URL equals slash then we can send something to the client for example response dot write hello world and then we end the response okay now back in the terminal we can exit here by pressing ctrl + C and then run the application again okay we're still listening on port 3000 let's refresh this page so we got hello world on home page now if you want to build a backend service for our web or mobile applications we need to handle various routes here for example we can have another if block if requested URL equals slash API slash courses perhaps here we want to return the list of courses from the database so we would do something like this response dot right here we want to return an array of objects using JSON so we use JSON dot stringify and give it an array of objects now for simplicity here we don't have to worry the database or complex objects let's just return an array of numbers 1 2 & 3 so we pass this to json stringify which will convert this array into a string using json syntax and then we'll write it to the response and finally response the end now back in the terminal we need to stop this process again and run it one more time now in the future I will show you how we can automate this so every time we make a simple change to our application we don't have to restart it so now back in the browser if we go to slash API slash courses we get an array with three numbers so as you see building a web server we know it is very easy now in the real world we are not going to use this HTTP module to build a backend service for our application the reason for this is because as you can see here as we add more routes this code gets more complex because we add all of them in a linear way inside this callback function so instead we use a framework called Express which gives our application a clean structure to handle various routes internally the Express framework is built on top of the HTTP module in node
