With timestamps:

00:00 - [Music]
00:01 - Welcome to My ultimate Redux course I'm
00:04 - mosh and I'm going to be your instructor
00:05 - over the next few hours in this course
00:08 - you will learn everything you need to
00:09 - know to build real complex applications
00:12 - with Redux we are not going to work on a
00:14 - dummy to-do app we're going to work on a
00:16 - real bug tracking application with a
00:18 - note backend we'll go over functional
00:21 - programming principles writing clean
00:23 - code designing complex stores middleware
00:26 - calling apis testing and integrating
00:29 - with react I'm assuming this course you
00:32 - know nothing about Redux and want to
00:34 - learn everything from scratch I will
00:36 - explain every line of code I write so
00:38 - you learn and understand all the
00:40 - underlying principles I Promise You by
00:42 - the end of this course you will know and
00:44 - understand Redux inside out now before
00:47 - we get started I want to tell you that I
00:49 - have a coding school at codewithmash.com
00:51 - where you can find plenty of courses on
00:53 - web and mobile development so if you
00:55 - want to learn more from me be sure to
00:57 - check out my coding school now let's
00:59 - jump in and get started
01:02 - oh
01:03 - so what is Redux all about well Redux is
01:06 - a state management library for
01:08 - JavaScript applications we can use it
01:10 - with react angular view or even vanilla
01:14 - JavaScript because Redux is just a state
01:16 - management Library it doesn't care what
01:18 - library we use to build user interfaces
01:20 - but why do we need a state management
01:22 - library to start with well if you have
01:25 - ever built an application with a complex
01:27 - UI you have probably come across this
01:29 - situation where you need to keep
01:31 - different parts of the UI in sync let's
01:33 - say the user changes some data in one
01:35 - part of the UI and other parts of the UI
01:37 - should be immediately updated to reflect
01:39 - the changes in more complex scenarios
01:42 - that data can also get updated as a
01:44 - result of network requests or background
01:46 - tasks in these situations data can flow
01:49 - from one part of the UI to another and
01:51 - change in unpredictable ways we have to
01:54 - write a lot of code to keep everything
01:55 - in sync and when something goes wrong
01:57 - figuring out how the data changed and
01:59 - where it came from becomes really
02:01 - complex you might even end up with an
02:03 - infinite Loop that is hard to break if
02:06 - you encountered such problems in your
02:07 - applications that is a sign you need a
02:09 - state management Library Facebook
02:11 - encountered this problem in 2014 and
02:14 - came up with an architectural pattern
02:16 - called flux Redux is inspired by flux
02:19 - but it has grown more popular due to its
02:21 - Simplicity and elegance another popular
02:24 - solution is mobx with Redux instead of
02:27 - scattering application state in various
02:29 - parts of the UI we store all the
02:31 - application State inside a central
02:33 - repository that is a single JavaScript
02:36 - object called the store that is a single
02:38 - source of Truth you can think of it as
02:40 - some kind of a database for the front
02:42 - end so with this architecture the
02:44 - different pieces of the UI will no
02:46 - longer maintain their own State instead
02:48 - they get what they need from the store
02:50 - if we need to update the data there is a
02:52 - single place we have to update so this
02:55 - immediately solves the problem of
02:56 - synchronizing the data across different
02:58 - parts of the UI but redux's architecture
03:01 - also makes it easy to understand how the
03:03 - data changes in our applications if
03:06 - something goes wrong we can see exactly
03:08 - how the data changed why when and where
03:11 - it came from so in a nutshell Redux
03:13 - centralizes our application State and
03:15 - makes data flow transparent and
03:17 - predictable
03:23 - now that you know what Redux is let's
03:26 - look at some of its benefits in action
03:28 - so this is a food delivery application I
03:30 - have built with react and Redux on the
03:32 - left we have food categories such as
03:34 - soups salads and so on
03:36 - we can select the category and add items
03:39 - to our shopping cart note that as I'm
03:41 - adding these items the number of items
03:43 - in the shopping cart gets updated
03:45 - immediately
03:46 - so let's add a bunch of items
03:49 - let's also add an entree
03:52 - now let's go to our shopping cart
03:55 - once again we can update the number of
03:57 - each item in the shopping cart as I'm
03:59 - doing this the total price for this item
04:01 - for the cart as well as the number of
04:03 - items in the shopping cart get updated
04:05 - in real time
04:08 - so all the data in my application is in
04:10 - sync because we have a single store
04:11 - where we are storing our application
04:13 - State let me show you where it is
04:15 - this is Redux Dev tools a powerful tool
04:18 - for debugging Redux applications it's an
04:21 - extension to Chrome so over here you can
04:23 - see my entire application State 3 in one
04:26 - place so we have these entities we have
04:28 - our shopping cart we have our food
04:30 - categories and food items this auth
04:33 - object over here represents the current
04:35 - user so we have all the information
04:37 - about the current user and their
04:39 - authentication token we also have this
04:41 - UI property which includes some UI State
04:44 - now let me show you something powerful
04:46 - on the left side you can see all the
04:48 - actions that I have performed in this
04:50 - application
04:51 - so you can see I've added a bunch of
04:53 - items to my shopping cart
04:54 - now if I remove the first item green
04:57 - lentil soup
05:00 - you can see we have a new action here
05:02 - item removed if you select this action
05:06 - we can see the data associated with this
05:08 - action so over here I try to remove the
05:11 - product with id5 now let me show you
05:14 - something very cool
05:15 - I'm going to put this on the left side
05:16 - so you can see clearly
05:18 - let's jump to one of the previous
05:20 - actions
05:22 - the UI got updated immediately so we can
05:25 - go back to any of these previous actions
05:27 - and restore the UI in that state
05:31 - this is called time travel debugging we
05:34 - can also save the entire application
05:35 - state in a single file and reload the
05:38 - application from it later how many times
05:40 - have you got a call from your client or
05:41 - your boss telling you that a feature in
05:44 - your application is not working in these
05:46 - situations we have to ask them how did
05:47 - this happen tell me the exact steps that
05:49 - you followed then we have to repeat all
05:52 - those steps to reproduce the bug now
05:54 - every time we change our code our
05:55 - application gets reloaded and we have to
05:57 - follow those steps over and over this is
06:00 - very time consuming with Redux we don't
06:02 - have to do this anymore there's actually
06:04 - a tool called log rocket that gives you
06:06 - an always-on Redux Dev Tools in
06:09 - production for every one of your users
06:10 - so if a user encounters a problem you
06:13 - can reload the application in the same
06:15 - state as the user and see what was going
06:17 - on it's very powerful
06:19 - another benefit of Redux is that it
06:21 - allows you to cash or preserve paid
06:24 - State let me show you what I mean so
06:25 - over here note that when I refresh the
06:28 - page you're going to see a loading
06:29 - indicator for three seconds indicating a
06:32 - slow connection so look refresh
06:36 - here's our loader now the menu appears
06:39 - okay now if we navigate away from this
06:42 - page
06:43 - and then come back to it the menu is
06:46 - already there we don't have to
06:47 - re-download it from the server because
06:49 - our entire application state is
06:51 - available on the client inside a single
06:54 - JavaScript object also I can select a
06:57 - filter here let's say soups and sort the
07:00 - menu by price
07:02 - once again if we navigate away
07:05 - and then come back our menu is in its
07:08 - previous state so let's quickly recap
07:10 - Redux makes State changes predictable
07:13 - and transparent we can easily see what
07:16 - exactly is going on and how the
07:17 - application State changes in response to
07:20 - every action the second benefit of Redux
07:23 - is that these centralizes our
07:24 - application state so all the data our
07:27 - application needs is stored in a single
07:29 - place that is accessible by all parts of
07:31 - the UI with Redux we can also easily
07:34 - debug our applications we can easily
07:36 - cache or preserve paid State and
07:38 - Implement undo or redo features so if
07:41 - your application needs these features
07:42 - you may want to consider Redux the great
07:45 - thing about Redux is that it works with
07:47 - any libraries for building uis you can
07:49 - use it with react angular Ember view
07:52 - even vanilla JavaScript plus we have a
07:55 - large and growing ecosystem of add-ons
07:57 - so these are all the great things about
07:59 - Redux but all these great things come at
08:02 - a cost redox introduces some indirection
08:05 - and complexity in your code this is
08:07 - partly because Redux is based on on
08:09 - functional programming principles and a
08:12 - lot of developers are not familiar with
08:13 - this concept but don't worry I'm going
08:15 - to teach you the basics of functional
08:17 - programming very soon another problem
08:19 - with Redux is that Redux code tends to
08:21 - be verbose you have to write some
08:23 - boilerplate code to get things done this
08:25 - is one of the main complaints about
08:27 - Redux so in this course first I'm going
08:29 - to show you the traditional way of
08:31 - writing Redux code which has a lot of
08:33 - boilerplate but later on I will show you
08:35 - the modern way of building Redux
08:37 - applications you're going to learn how
08:39 - to write clean and concise Redux code
08:41 - free of boilerplate so with all that is
08:45 - Redux for your dot we'll talk about that
08:47 - next
08:51 - if you have seen any of my courses
08:53 - before you've probably seen this guy his
08:55 - name is John Smith it's kind of arrogant
08:58 - and opinionated about everything so he
09:00 - says that he uses Redux in every project
09:03 - and so should you well I tend to
09:05 - disagree for every project or app you
09:08 - need to understand what problem you're
09:09 - trying to solve what your constraints
09:11 - are and what solution optimally solves
09:14 - the problem according to those
09:16 - constraints there is no such a thing as
09:18 - one size fits all in software
09:20 - engineering if you're on a tight budget
09:22 - if you're building a small to
09:23 - medium-sized app with fairly simple UI
09:26 - and data flow if the data doesn't change
09:28 - in your app or if you simply fetch the
09:30 - data on every page load and render it
09:33 - statically on the page redox is probably
09:35 - not the right tool for you it's just
09:37 - going to complicate things and slow you
09:38 - down without giving you much value so
09:41 - don't use Redux or any other tools
09:43 - because they're popular or someone told
09:45 - you to always think about your needs and
09:47 - the kind of app you're building now John
09:50 - argues that you should always use Redux
09:52 - right from the get-go because their
09:54 - State Management problem will get messy
09:56 - sooner or later so it's better to have
09:58 - the right foundation in the project well
10:01 - that reminds me of the old proverb if
10:03 - all you have is a hammer everything
10:05 - looks like a nail developers like John
10:07 - are often used to a certain way of
10:09 - building apps they solve every problem
10:11 - using the same solution and honestly I
10:13 - think that's just basic human nature we
10:16 - don't want to constantly think and
10:17 - figure things out we like to be an
10:19 - autopilot but if you want to be a real
10:21 - software engineer you need a different
10:23 - kind of attitude you need to be an
10:25 - active Problem Solver so the bottom line
10:27 - Redux is great it provides a number of
10:30 - benefits at the cost of extra complexity
10:32 - in your code base you will see this as
10:34 - we go through this course for every app
10:36 - you need to think about all the pros and
10:38 - cons of Redux and see if it's really the
10:41 - right tool for you or not in fact down
10:43 - every month the creator of Redux once
10:45 - said you might not need Redux this is a
10:48 - great blog post to read in your spare
10:50 - time so at the end of the day I
10:52 - encourage you to watch this course to
10:54 - the end because it helps you see what
10:55 - Redux is all about and whether it's the
10:58 - right tool for your next project or not
11:00 - also keep in mind that almost 60 percent
11:02 - of react projects are built with Redux
11:04 - so if you're a react developer chances
11:07 - are the next job or project you get is
11:09 - based on Redux so you need to know how
11:11 - Redux code works and how to maintain it
11:14 - and that's what you're going to learn in
11:16 - this course
11:17 - oh
11:21 - if you look below this video you're
11:24 - going to find the starter project for
11:25 - this course so simply open this folder
11:28 - with vs code or your favorite code
11:30 - editor
11:32 - now all you have to do is to open up a
11:35 - terminal window install the dependencies
11:37 - and start the project using npm so npm
11:41 - install
11:44 - all right all of our dependencies are
11:46 - installed so now let's start the project
11:48 - with npm start
11:52 - Now open up your browser and head over
11:54 - to localhost Port 9000 you should see
11:57 - the hello world message
11:58 - now let me give you a quick overview of
12:00 - what we have in this project so take a
12:03 - look at package.json here we have three
12:06 - development dependencies and they're all
12:08 - related to webpack in case you are not
12:10 - familiar with webpack it's actually a
12:12 - module bundler for JavaScript so we can
12:15 - split our JavaScript code into multiple
12:17 - files and have webpack combine them into
12:19 - a bundle we also have webpack
12:21 - development server which is a very
12:23 - lightweight development web server
12:26 - now over here you can see the
12:28 - configuration for webpack this is pretty
12:30 - standard nothing fancy here so we're
12:33 - telling webpack that the entry point to
12:35 - our project is this file index.js that
12:38 - is located in the source folder now
12:41 - webpack is going to start from here it's
12:43 - going to get all of our JavaScript files
12:45 - and then combine them into a file called
12:48 - app.js which is going to reside in this
12:51 - folder this which is short for
12:53 - distributable
12:54 - and here's the configuration for our
12:56 - development server so we are telling
12:58 - webpack to launch our application from
13:01 - this folder on Port 9000 pretty
13:04 - straightforward
13:09 - before we dive in let me give you a
13:11 - quick overview of how I've structured
13:12 - this course so you can get the most out
13:14 - of it Redux is based on functional
13:16 - programming principles a lot of people
13:18 - find Redux confusing because they are
13:20 - not familiar with this functional
13:22 - programming Concepts so the next section
13:24 - is all about functional programming in
13:26 - JavaScript we'll be talking about
13:28 - Concepts such as higher order functions
13:30 - composition occurring immutability and
13:32 - so on the following section is all about
13:35 - the fundamentals of Redux in this
13:37 - section you will see all the building
13:39 - blocks of Redux in action we'll be
13:41 - talking about reducers actions action
13:44 - creators and so on now Redux itself is a
13:47 - very simple Library so in the following
13:49 - section I'm going to show you how to
13:51 - implement Redux from scratch yourself
13:52 - this helps you gain a better
13:54 - understanding of this Library so it will
13:56 - no longer be a mystery to you you will
13:58 - know exactly how everything works next
14:01 - we'll talk about debug and Redux
14:03 - applications I will show you various
14:05 - tools available to you and how to use
14:07 - them to debug your Redux applications
14:09 - now some of the most common complaints
14:11 - about Redux is that it involves too much
14:14 - code too much boilerplate and that Redux
14:16 - code is ugly and unmaintainable so in
14:19 - the following section I will show you
14:20 - tons of techniques to write clean
14:22 - concise and beautiful Redux code then
14:25 - we're going to talk about designing a
14:27 - Redux store we'll talk about some
14:29 - patterns and techniques that you need to
14:30 - know for building real complex
14:32 - applications then we're going to talk
14:34 - about middleware this is one of the
14:36 - areas that a lot of people find
14:37 - confusing so I'm going to make it super
14:39 - simple for you next we're going to talk
14:41 - about calling apis I've seen a lot of
14:44 - bad code when it comes to calling apis a
14:46 - lot of repetition so in this section I'm
14:48 - going to show you a very cool technique
14:50 - for calling apis we'll also talk about
14:52 - some other concerns such as loading
14:54 - indicators and caching the following
14:56 - section is about testing again I've seen
14:58 - a lot of bad practices when it comes to
15:00 - testing a lot of people blindly write
15:03 - tests and feel proud but you need to
15:05 - learn how to rate good tests not just
15:07 - tests so in this section I will show you
15:09 - the proper way to test Redux code
15:12 - finally in the last section we'll talk
15:14 - about integrating Redux into your
15:16 - reactant applications I'm going to show
15:18 - you both the Old and the new way of
15:19 - connecting your components to a Redux
15:21 - store so there's a lot we're going to
15:23 - cover and by the end of this course
15:25 - you're going to master Redux that's my
15:27 - promise to you so I'll see you in the
15:29 - next section
15:33 - Redux is built on top of functional
15:36 - programming principles which is foreign
15:37 - to a lot of developers if you have tried
15:40 - Redux I'm very confused that's probably
15:42 - because you didn't have a good
15:43 - background in functional programming so
15:45 - in this section we're going to cover the
15:46 - essential functional programming
15:48 - Concepts I highly encourage you to watch
15:50 - this section to the end because
15:52 - understanding these Concepts is crucial
15:54 - to build Redux applications so let's
15:56 - jump in and get started
16:01 - so what is functional programming well
16:04 - functional programming is one of the
16:06 - many programming paradigms or styles of
16:08 - programming you have probably heard of
16:10 - object-oriented programming that's
16:12 - another popular programming Paradigm or
16:15 - style of programming each of these
16:16 - paradigms has certain rules about how
16:19 - you should structure your code to solve
16:21 - problems functional programming was
16:22 - invented in the 1950s but it has become
16:25 - quite trendy over the past few years in
16:28 - a nutshell functional programming is
16:29 - about decomposing a problem into a bunch
16:32 - of small and reusable functions that
16:34 - take some input and return a result they
16:36 - don't mutate or change data with this
16:39 - structure we can compose these functions
16:41 - to build more complex functions now what
16:44 - are the benefits well these small
16:46 - functions tend to be more concise easier
16:48 - to debug easier to test and more
16:51 - scalable because we can run many
16:52 - function calls in parallel and take
16:55 - advantage of multiple cores of a CPU so
16:57 - these are the reasons why functional
16:59 - programming has gained a lot of popular
17:01 - already over the past few years now
17:04 - there are languages that are
17:05 - specifically designed for functional
17:07 - programming such as closure and Haskell
17:09 - JavaScript is a multi-paradigm
17:11 - programming language it's not a pure
17:13 - functional language so it has some
17:15 - caveats that you need to be aware of but
17:16 - we can still apply functional
17:18 - programming principles in JavaScript and
17:20 - that's what I'm going to show you
17:22 - throughout the rest of this section
17:27 - alright our first lesson here is going
17:28 - to be a JavaScript refresher about
17:30 - functions chances are you know what I'm
17:32 - gonna show you in this lesson so please
17:34 - be patient with me I want to make sure
17:36 - you've got the fundamentals right before
17:38 - we move on to more complex topics so in
17:41 - JavaScript functions are first class
17:43 - citizens which means we can treat them
17:45 - just like any other variables we can
17:48 - assign them to a variable we can pass
17:50 - them as arguments and return them from
17:52 - other functions let me show you
17:55 - so in our starter project I'm going to
17:57 - write all the code in this file index.js
18:01 - so let's declare a function
18:03 - called say hello that returns and string
18:08 - hello world
18:09 - as always
18:10 - now let's declare a variable call FN
18:14 - we can set this to a number or a Boolean
18:16 - or a string but we can also set it to a
18:19 - function
18:20 - say hello
18:22 - note that I'm not calling this function
18:24 - because if we call it we get its return
18:26 - value which is a string we don't want to
18:28 - call the function we simply want to pass
18:30 - a reference to it so functions are
18:33 - first-class citizens in JavaScript we
18:35 - can treat them like any other type of
18:37 - objects nothing special about them okay
18:39 - now FN is an alias for say hello so we
18:44 - can call it just like calling the say
18:47 - hello function the result is exactly the
18:50 - same we'll get a string back okay
18:52 - now we can also pass a function as an
18:55 - argument to another function
18:56 - so let's declare another function called
18:59 - grid which takes a function for
19:02 - generating a message
19:04 - now here we can do a concept.log and
19:07 - pass the return value of this function
19:10 - so our grid function
19:12 - takes a function as a parameter and
19:14 - calls it over here okay now we can call
19:17 - grid
19:19 - and pass a reference to the say hello
19:21 - function once again I'm not calling this
19:24 - function I'm simply passing a reference
19:26 - to it okay
19:27 - so in JavaScript we can assign a
19:29 - function to a variable we can pass it as
19:31 - an argument we can also return it from
19:34 - another function so let's get rid of
19:36 - this code
19:37 - in our say hello function instead of
19:40 - returning a string we can return a
19:42 - function
19:45 - in this case an anonymous function
19:47 - because this function does not have a
19:49 - name
19:50 - now inside this function we're going to
19:52 - return hello world
19:55 - with this structure if we call say hello
19:58 - we're going to get a function back
20:01 - okay
20:02 - that is this Anonymous function over
20:04 - here now we can call this function
20:07 - and get our message now you might be
20:11 - wondering what is the purpose of this
20:12 - why do we want to return a function here
20:14 - instead of a regular string well this is
20:17 - a very powerful technique and it has a
20:19 - lot of applications in the real world
20:21 - you're going to see that soon all I want
20:23 - you to understand now is that in
20:25 - JavaScript functions are first class
20:27 - citizens we can treat them like any
20:29 - other variables
20:32 - foreign
20:36 - in the last lesson you learned that in
20:38 - JavaScript and other functional
20:40 - programming languages we can pass a
20:43 - function as an argument and return it
20:45 - now in this example these two functions
20:48 - create and say hello these functions
20:51 - have a special name in functional
20:53 - programming they're called higher order
20:55 - functions so a higher order function is
20:58 - a function that takes a function as an
21:00 - argument or returns it or both
21:03 - so instead of working on strings numbers
21:05 - or booleans it goes higher to operate on
21:08 - functions this is the reason why we call
21:11 - them higher order functions the chances
21:13 - are you have worked with these higher
21:15 - order functions before without being
21:17 - aware of it let me show you so I'm going
21:19 - to declare
21:20 - an array of numbers one two three
21:24 - now we can call numbers.map map is an
21:27 - example of a higher order function
21:29 - because it takes a function as an
21:30 - argument so here we can pass a function
21:33 - like this
21:34 - number goes to number times two so we
21:38 - take each number and multiply it by two
21:41 - another example of a higher order
21:42 - function in JavaScript is the set
21:44 - timeout function so
21:47 - we can call set timeout
21:49 - here we should pass a function as an
21:51 - argument
21:52 - let's say we want to do a console.log
21:55 - of hello after one second
21:59 - so set timeout is a higher order
22:01 - function because it takes a function as
22:03 - an argument
22:05 - foreign
22:11 - functional programming is to write a
22:14 - bunch of small and reusable functions
22:15 - and then compose them to build more
22:17 - complex functions for solving real-world
22:20 - problems here's a real example
22:22 - let's say we have a variable called
22:23 - input
22:24 - and we set it to JavaScript
22:27 - now let's add some padding around this
22:30 - let's say we want to get the input trim
22:32 - it and then wrap it inside a div element
22:34 - so
22:36 - with declare another variable
22:39 - here we add the opening element next we
22:42 - add our trimmed input
22:44 - and finally the closing element not bad
22:47 - it works this is a non-functional style
22:49 - of code now let me show you how to solve
22:52 - this problem using functional
22:53 - programming techniques so what are the
22:56 - two steps that we need to follow here
22:58 - first we need to trim the string and
23:00 - then we need to wrap it inside a div
23:03 - element so we can Implement each step
23:05 - using a small reusable function so
23:09 - I can declare a function called trim
23:12 - that takes a string and Returns the
23:16 - trimmed string okay here I'm using const
23:19 - because I don't want to reassign this
23:20 - function okay now similarly we can
23:23 - create another function
23:25 - wrap and div
23:28 - that takes a string it doesn't care if
23:30 - the string is trimmed or not it only
23:32 - wraps the string inside a div element
23:35 - so here we can add an expression like
23:38 - this div plus SDR plus slash Dev or we
23:44 - can use a template string that is
23:46 - cleaner and more concise so instead of
23:48 - using quotes
23:50 - we use the back the character and here
23:53 - we Define a template so
23:55 - we add our div element now in the middle
23:58 - we want to render the string dynamically
24:01 - so we add a dollar sign and wrap it with
24:05 - braces
24:06 - and with this we can render this
24:08 - dynamically okay
24:09 - so now we have two small and reusable
24:12 - functions these functions as you can
24:14 - tell are very easy to test all we have
24:17 - to do is to give them an input and then
24:19 - observe the result very simple now
24:22 - what do we want to do here
24:24 - we have this input right we want to trim
24:27 - it first so we call the trim function
24:30 - and pass the input the trim function is
24:32 - going to return the trim string so we
24:35 - can pass that as an argument
24:37 - to our second function
24:39 - wrap and div
24:43 - there you go
24:44 - so we get the result
24:47 - and this is what we call function
24:49 - composition in functional programming
24:52 - now we could take this to the next level
24:54 - we can also create
24:56 - another function for converting a string
24:59 - to lowercase so two lowercase once again
25:03 - this function takes a string and returns
25:06 - the string and lowercase
25:08 - now we can take the output
25:10 - of the trim function and pass it to two
25:13 - lowercase
25:15 - so this is another example of
25:17 - composition
25:18 - now we have a couple of tiny problems
25:20 - here the first problem is that we have
25:22 - to read this expression from right to
25:24 - left so we have an input then we need to
25:27 - trim it next we need to convert it to
25:29 - lowercase and then wrap it in div that's
25:32 - one problem the other problem is all
25:34 - these parenthesis here as we work with
25:37 - more complex problems we'll end up with
25:39 - so many parentheses I'm going to show
25:41 - you how to solve these problems in the
25:42 - next lesson
25:44 - foreign
25:49 - I'm going to show you how to use low
25:51 - Dash to simplify the code we wrote in
25:53 - the last video
25:54 - so in case you're not familiar with low
25:56 - Dash it's basically a very popular
25:58 - utility library for JavaScript it also
26:01 - has a package with a lot of functions
26:03 - for functional programming I'm going to
26:05 - show you how to use them in this lesson
26:07 - so back in our project open up a
26:10 - terminal window and install low Dash
26:17 - all right beautiful now on the top
26:20 - we're going to import two functions from
26:22 - low dash one of them is compose
26:25 - the other is pipe
26:27 - we're going to import them from low Dash
26:29 - slash FP as in short for functional
26:32 - programming so all these utility
26:34 - functions for functional programming are
26:36 - defined in this package
26:38 - now with these two functions
26:40 - we can get rid of all these unnecessary
26:42 - parenthesis over here let me show you so
26:44 - first I'm going to use the compose
26:46 - function
26:48 - we call compose and give it three
26:50 - arguments wrapping div
26:53 - to a lowercase
26:55 - and trim once again note that I'm not
26:58 - calling any of these functions I'm
27:00 - simply passing a reference to that so
27:02 - compose is another example of a higher
27:04 - order function because it takes a bunch
27:06 - of functions as arguments and returns a
27:09 - new function that is the composition of
27:11 - all these functions so it's a higher
27:13 - order function
27:14 - now we can get the return value which is
27:17 - a function and store it and a constant
27:19 - called transform
27:22 - then we can call transform
27:25 - and give it the input so with the
27:27 - compose function we no longer need to do
27:29 - this nest.function cause our code is
27:31 - cleaner we don't have all these
27:33 - parentheses polluting the code there is
27:35 - just one tiny problem here that is the
27:37 - order of our operations so once again we
27:40 - have to read this code from right to
27:42 - left to solve this problem we can use
27:44 - the pipe function so
27:47 - we call pipe and list our functions in
27:49 - the order we want to apply them so first
27:52 - we're going to trim the input then
27:55 - we're going to convert it to lowercase
27:57 - and finally we're going to wrap it
27:59 - in a div so we no longer need this ugly
28:02 - code with all these parenthesis delete
28:04 - good
28:11 - in this lesson I'm going to show you a
28:13 - powerful functional programming
28:15 - technique called curing I like what you
28:17 - might think this has nothing to do with
28:19 - food this is named after this guy
28:21 - Haskell Curry
28:23 - so back to the problem from the last
28:24 - video Let's extend this program and
28:27 - create a function for wrapping a string
28:29 - inside a span element so over here
28:35 - we create a new function wrap in Span
28:39 - and let me copy this code from here
28:42 - and then replace div with span
28:45 - pretty straightforward
28:47 - yeah there is a problem in this code we
28:49 - have a bit of duplication these two
28:51 - expressions look very similar the only
28:54 - difference they have is in the type of
28:56 - element it would be nice if we could
28:58 - parameterize this function so instead of
29:01 - wrapping span let's call it wrap
29:04 - and give it two parameters type and
29:07 - input string
29:09 - then instead of this man we're going to
29:12 - render the type
29:14 - okay now
29:16 - let's get rid of wrap and div
29:18 - and instead use our new function
29:21 - wrap
29:24 - finally let's log the return value of
29:26 - the transform function on the console
29:28 - save the changes
29:30 - so here's what we get JavaScript
29:33 - undefined that doesn't make sense here's
29:36 - Arisa this Pi function essentially
29:38 - builds a pipeline the output of each
29:41 - function ends up being the input of the
29:43 - next function so what is the output of
29:45 - the two lowercase function it's our
29:47 - input string in lowercase right so that
29:50 - gets passed to a wrap function
29:53 - now this function has two parameters
29:54 - type and input string so our input
29:57 - string in lowercase gets passed
30:00 - as the type argument and the second
30:02 - argument becomes undefined that is the
30:05 - reason why we get this result
30:07 - now what if you call wrap and pass div
30:12 - as the type of element let's save the
30:14 - changes back in the console we get this
30:16 - error expected a function
30:19 - because every argument to the pi
30:21 - function has to be a function in this
30:23 - case we're calling the wrap function and
30:25 - give it div as the type of element so
30:27 - this is going to return a string
30:30 - we cannot pass a string in the pi
30:32 - function because we cannot build a
30:34 - pipeline with a bunch of functions and a
30:36 - string it doesn't make sense
30:38 - so here's the problem you're facing we
30:40 - have a function with two parameters but
30:42 - what we need in this pipeline is a
30:43 - function with a single parameter and
30:45 - that's the problem that occurring solves
30:47 - let me show you so I've created a
30:49 - separate file called occurring let's
30:52 - study current and isolation and then
30:53 - we'll come back to our main file so
30:56 - let's say
30:57 - we have a function for adding two
30:59 - numbers A and B here we turn a and b
31:03 - curing is a technique that allows us to
31:05 - take a function that has an argument and
31:08 - convert it to a function that has a
31:10 - single argument so to apply querying
31:12 - here
31:14 - we get rid of B
31:15 - as the second parameter
31:17 - and instead of returning this expression
31:20 - we're going to return a function that
31:22 - takes
31:24 - a parameter called B
31:26 - and then inside this function we're
31:27 - going to return a plus b
31:30 - so when we call the add function let's
31:32 - say add one this is going to return
31:35 - a function let's call it add one
31:37 - so every time we call this function and
31:40 - give it a value it's going to add 1 to
31:42 - it okay
31:43 - now in this case we don't need to store
31:45 - this function in this constant
31:47 - we can call add one we know that this
31:50 - returns a function so we can call that
31:52 - function and pass our second argument
31:55 - so with current instead of separating
31:57 - our arguments
31:59 - with comma
32:00 - we separate them
32:02 - using parenthesis but what matters here
32:05 - is that we have a function with a single
32:08 - parameter now we can also rewrite this
32:10 - function using an error function so
32:14 - let's declare a function called add to
32:17 - now this function should take a
32:19 - parameter called a
32:20 - and return a new function so a goes to
32:25 - now here we should return
32:26 - a function that takes a parameter called
32:28 - B
32:29 - so B goes to
32:31 - and returns this expression
32:36 - so once again instead of separating our
32:38 - parameters using a comma Like A and B
32:41 - goes to a plus b we are separating them
32:43 - using arrows
32:45 - this is the result of carrying a
32:47 - function now let's apply this technique
32:49 - in our main program so
32:52 - the problem we have here is that the
32:54 - wrap function takes two parameters we
32:56 - want to apply current here so we end up
32:58 - with a function with a single parameter
33:00 - so to separate these parameters instead
33:03 - of a comma we're going to use an arrow
33:05 - so
33:07 - we don't need parenthesis because we
33:08 - have a single parameter type goes to
33:11 - string goes to
33:13 - this expression this is our current
33:15 - function now here's the interesting part
33:18 - when we call wrap and pass div
33:22 - we get a function instead of a string so
33:26 - we can pass that function as another
33:28 - step in our pipeline
33:30 - let's save the changes
33:33 - and here's the final result
33:35 - so we wrapped JavaScript in a div
33:37 - element
33:38 - with this new implementation we can
33:41 - replace div with a span or any other
33:43 - elements save the changes there you go
33:46 - so we don't have to create so many
33:48 - functions for creating HTML elements
33:52 - hey Mash here thank you for watching my
33:55 - Redux tutorial this tutorial you've been
33:57 - watching is actually the first hour of
34:00 - my complete Redux course that is 6 hours
34:02 - long so if you enjoyed this tutorial and
34:04 - want to learn more I highly encourage
34:06 - you to take the full course because it
34:08 - goes Way Beyond this tutorial if you
34:10 - enroll you will also receive a
34:11 - certificate of completion that you can
34:13 - add to your resume if you're interested
34:15 - I'll put the link down below
34:19 - another important Concept in functional
34:21 - programming is pure functions we say a
34:24 - function is pure if every time we call
34:26 - it n give it the same argument it always
34:29 - returns the same result let's look at a
34:31 - few examples
34:32 - look at this function do you think this
34:34 - function is pure or not it's not because
34:37 - every time we call it this math.random
34:39 - method generates a new value so the
34:42 - result of this function is going to
34:43 - change in contrast this function is pure
34:46 - because every time we call it and give
34:48 - it one we always get 2.
34:51 - so in pure functions we cannot use
34:53 - random values we cannot use the current
34:55 - date time because again this will change
34:57 - we cannot read or change Global State
35:00 - like Dom elements files databases and so
35:03 - on because if you rely on global state
35:05 - or change it this can affect the result
35:08 - of our Pure functions now you might say
35:10 - but Marsh how are we going to update our
35:12 - Dom elements or our database well in
35:15 - practice not everything has to be pure
35:17 - at least when practicing functional
35:19 - programming with JavaScript in Redux we
35:22 - have special functions called reducers
35:24 - we'll talk about them in the next
35:25 - section when building redox applications
35:28 - we have to make sure that our reducers
35:30 - are pure other functions in our
35:32 - application can be impure that's not the
35:34 - end of the world now in pure functions
35:36 - we cannot mutate our parameters because
35:39 - if we do so again the result of a pure
35:41 - function can change let's look at a few
35:43 - more examples
35:44 - so this function takes the H of someone
35:46 - and Compares it with minimum age as you
35:49 - can see minimum age is not defined here
35:51 - so it's a global variable now if you
35:54 - rely on This Global variable to see if
35:55 - someone is eligible or not the result of
35:58 - this function can change in the future
35:59 - so if somewhere else we change the
36:01 - minimum age from 18 to 21 this function
36:04 - is going to return something different
36:05 - to make this function pure
36:08 - we have to pass minimum age as a
36:10 - parameter so everything this function
36:12 - needs should be specified in its
36:14 - parameter list now what are the benefits
36:16 - of pure functions well the first benefit
36:19 - is that these functions are
36:21 - self-documenting because everything a
36:23 - function needs is clearly specified here
36:25 - now this makes these functions easier to
36:28 - test because we don't have to set some
36:30 - Global State prior to testing these
36:32 - functions also because we don't use
36:34 - Global state or change it we can run
36:37 - these functions in parallel and finally
36:39 - another benefit of these functions is
36:41 - that they're cachable for example if we
36:43 - call this function and give it two
36:45 - arguments like one and two and we know
36:47 - that this always returns three we can
36:49 - store the result in the cache and use it
36:51 - in the future this is useful in
36:53 - functions that have intensive
36:55 - computations so if you know for sure
36:57 - that they produce the same result or the
36:59 - same arguments we can optimize them by
37:02 - reading the result from a cache so these
37:04 - are the benefits of pure functions
37:10 - in the last video I told you that pure
37:12 - functions cannot change or mutate their
37:14 - arguments the concept that goes hand in
37:17 - hand with pure functions is immutability
37:19 - which basically means once we create an
37:21 - object we cannot change or mutate it if
37:24 - you want to change that object you have
37:26 - to take a copy first and then change
37:28 - that copy
37:29 - for example strings in JavaScript and in
37:33 - most programming languages are immutable
37:35 - so if you have a string and then try to
37:37 - convert it to uppercase we get a new
37:39 - string the original string is not
37:41 - affected in contrast if you have an
37:44 - object we can change or mutate that
37:46 - object directly so in JavaScript objects
37:49 - on arrays are not immutable and that's
37:51 - why I told you that JavaScript is not a
37:54 - pure functional programming language in
37:56 - pure functional languages we cannot
37:59 - mutate data period but in JavaScript we
38:02 - can mutate objects on arrays because
38:04 - JavaScript was not designed to be a
38:06 - functional language it's a
38:07 - multi-paradigm language but we can still
38:09 - apply functional programming principles
38:11 - when writing JavaScript code now what
38:14 - about the cost keyword well this is a
38:16 - common misconception when you use const
38:19 - you're not creating an immutable object
38:21 - so we can declare book as a constant and
38:24 - then change its title property with
38:26 - const we cannot reassign book to a
38:29 - different object so const prevents
38:31 - reassignment okay now what are the
38:35 - benefits of immutability well the first
38:37 - benefit is that it makes our
38:39 - applications more predictable if we call
38:41 - a function and pass an object to it we
38:44 - know that object is not going to get
38:45 - changed so there are no surprises down
38:48 - the road the second benefit of
38:50 - immutability which is kind of specific
38:52 - to react and Redux kind of applications
38:54 - is that it makes it faster to detect
38:57 - changes so you know that react needs to
38:59 - know when the state is changed so it can
39:01 - trigger re-rendering for example let's
39:04 - say we have a book object stored in the
39:06 - memory location 100. now if you follow
39:09 - immutability to change a property of
39:11 - this object we have to create a new
39:14 - object this object is going to be stored
39:16 - in a different location in memory let's
39:18 - say 200. now react can quickly tell if
39:22 - an object is modified because it
39:24 - Compares these objects by the references
39:26 - it's like comparing 100 with 200. this
39:29 - is a very fast operation in contrast if
39:32 - we don't use immutability react has to
39:35 - compare every property of an object to
39:37 - see if it's changed so immutability
39:39 - makes change detection faster and the
39:42 - third benefit of immutability is
39:43 - concurrency if we know that a function
39:46 - does not mutate data we know that we can
39:48 - safely run this function in parallel
39:50 - it's not going to change something in
39:52 - memory that's going to mess up the state
39:53 - of the system as a whole
39:55 - so doesn't mean object mutation is bad
39:58 - and we should always favor immutability
40:00 - well if you ask John Smith he would say
40:03 - that's exactly right but in my opinion
40:05 - every approach every technique has its
40:08 - own uses pros and cons anyone telling
40:11 - you that one technique is objectively
40:13 - good or bad in all situations is selling
40:16 - you something so we talked about the
40:18 - benefits of immutability but these
40:20 - benefits are not free of cost there is a
40:23 - potential performance cost to
40:24 - immutability because every time we
40:26 - change an object all the values should
40:28 - be copied to the new object however this
40:31 - would only be an issue if you're dealing
40:33 - with a large number of objects let's say
40:35 - several thousands or hundreds of
40:37 - thousands of objects if you're dealing
40:39 - with a few objects that's not going to
40:41 - be an issue another problem with
40:43 - immutability is that copying objects can
40:45 - also cause memory overhead but we have
40:47 - immutability libraries out there that
40:50 - reduce these overheads as much as
40:51 - possible they use a technique called
40:53 - structural sharing so if some values are
40:57 - common between two objects they are not
40:59 - copied across they're shared but talk
41:01 - about this Library soon so the bottom
41:04 - line is if you're building applications
41:06 - with Redux you should not mutate data
41:08 - because that's a fundamental principle
41:10 - in Redux outside of Redux you can do
41:13 - whatever you want
41:14 - so now that you understand what
41:16 - immutability is and why it's important
41:18 - let's see how we can practice it in
41:20 - JavaScript
41:26 - so let me show you how you can practice
41:28 - immutability when working with objects
41:31 - so here we have a personal object with a
41:33 - name property now if you want to update
41:35 - this object we are not supposed to set
41:38 - the name property directly we should
41:40 - take a copy first and then update the
41:42 - copy there are basically two ways to do
41:44 - this in JavaScript
41:46 - one way is to use the object that assign
41:48 - method with this method we can copy the
41:51 - content of an object to another object
41:53 - so as a first argument we pass an empty
41:56 - object
41:57 - then we pass our personal object so this
41:59 - is going to copy all the properties of
42:01 - this object into this empty object
42:04 - optionally as a third argument we can
42:07 - supply an object with updated properties
42:10 - for example if you want to change the
42:12 - name property
42:14 - yeah that here
42:16 - let's set this to Bob we can also add
42:19 - additional properties let's say we can
42:21 - set H to 30.
42:24 - now this method is going to return a new
42:26 - object so
42:28 - let's call that updated
42:30 - and then log it on the console
42:36 - so we have this object with name set to
42:38 - Bob and age 30.
42:40 - so object.assign is one way to solve
42:42 - this problem but there is a better way
42:44 - we can use the spread operator so
42:48 - I'm going to set up data to an empty
42:50 - object
42:51 - now here we want to copy all the
42:53 - properties of the person object so we
42:55 - type dot dot dot person this is what we
42:59 - call the spread operator
43:01 - now that we've copied all the properties
43:03 - of the person object we can supply any
43:05 - additional properties so if you want to
43:08 - update the name you can pass it here
43:11 - in this case the second name property is
43:14 - going to overwrite the name property
43:16 - that we copied from the person object
43:18 - okay
43:19 - now save the changes
43:21 - and here's our updated person
43:24 - so I personally prefer the spread
43:26 - operator syntax because it's more
43:28 - concise now one thing you need to be
43:30 - aware of when using the spread operator
43:32 - or object of assignment is that both
43:35 - these methods do a shallow copy so you
43:37 - have to be careful when working with
43:39 - nest.objects for example
43:42 - let's add an address property here
43:46 - address we set it to an object with two
43:49 - properties Country USA and City
43:53 - let's say San Francisco
43:56 - now we're copying this person and
43:59 - changing his name
44:00 - now let's see what happens
44:03 - if we type updated the address
44:06 - that City
44:07 - we set it to New York
44:10 - and then
44:11 - log the original person object see what
44:15 - happens so save the changes
44:17 - so our original personal object his name
44:19 - was John now look at his address it's
44:22 - updated to New York
44:24 - because this spread operator does a
44:27 - shallow copy in this case this address
44:29 - property is set to an object the problem
44:32 - we have here is that both the person and
44:35 - updated objects have the same address
44:38 - this is the same address object in
44:40 - memory so if you change the address
44:42 - through one reference like updated it
44:45 - will apply to the other reference to
44:48 - solve this problem we have to do a deep
44:49 - copy so let me show you
44:53 - first we copy all the properties of the
44:56 - personal object
44:58 - then we add the address property
45:01 - we set it to a new object because we
45:04 - don't want to use the same address
45:05 - object associated with our original
45:07 - person object okay so we set it to a new
45:10 - object in this object first we should
45:13 - copy all the properties of person that
45:16 - address and then if we want we can
45:20 - change one of its properties let's say
45:22 - we can change the City to New York
45:25 - okay now
45:27 - we don't hit this line over here let's
45:29 - save the changes so if you log the
45:31 - original percent
45:33 - you can see its address is not modified
45:37 - so when working with nest.objects we
45:39 - have to do a deep copy now as you can
45:41 - see this approach is a little bit
45:43 - verbose the more nesting we have the
45:45 - more variables our code is going to be
45:47 - this is why we have libraries
45:49 - specifically made for immutability we're
45:52 - going to talk about them later in this
45:53 - section
45:55 - oh
45:59 - in this lesson I'm going to show you how
46:01 - to practice immutability when working
46:03 - with arrays so here we have an array of
46:06 - three numbers let's look at three
46:07 - different scenarios adding an item to
46:09 - this array removing an item and updating
46:12 - an existing item so
46:15 - for adding once again we can use the
46:17 - object spread operator so I'm going to
46:20 - declare a new constant called added
46:23 - and set it to a new array
46:25 - now first we want to copy
46:27 - all the elements in the numbers array
46:30 - and then we want to add a new element at
46:32 - the end this is how we can achieve this
46:34 - if you want to put this element at the
46:36 - beginning
46:38 - we can do it like this very easy what if
46:41 - you want to put it at a specific
46:42 - position let's say just before two well
46:45 - first we need to find the index of two
46:47 - so index we set it to numbers that index
46:51 - of 2.
46:53 - now
46:55 - we're going to create a new array first
46:57 - we have to copy all the items before two
47:01 - to do that we use numbers the slice
47:05 - we given that you start index that is
47:07 - zero this is going to return a new array
47:09 - with all the elements starting from
47:12 - index 0 up to the element at this index
47:16 - but excluding this element
47:18 - now as I told you the slice method
47:20 - returns a new array so we have to spread
47:23 - that array otherwise we'll end up with
47:26 - an array of arrays okay so we copy all
47:30 - the items before two
47:32 - now we add our new item let's say four
47:35 - and then we need to copy all the items
47:38 - starting from 2 all the way to the end
47:40 - of the array
47:41 - so once again we're going to use numbers
47:43 - dot slice as the start index we're going
47:46 - to pass index now because this returns
47:49 - an array we have to spread that array
47:52 - okay
47:53 - let's do a console.log so cancel the log
47:56 - of added
47:59 - and here's the result 1 4 2 and 3.
48:03 - now what about removing
48:05 - well this is very easy
48:07 - let's say we want to remove two so we
48:09 - use the filter method
48:11 - here we pass a function so n goes to
48:15 - we want to return all the elements
48:17 - except two so n
48:19 - not equal to 2.
48:22 - this returns a new array let's store it
48:24 - and this constant call removed
48:27 - and do a console.log
48:31 - so 2 is gone
48:33 - now what about updating
48:36 - this is fairly easy as well so
48:39 - we call the map method on our numbers
48:41 - array
48:43 - here we pass a function n goes to let's
48:46 - say we want to replace 2 with 20. so if
48:49 - n equals 2
48:52 - then we're going to return 20 otherwise
48:54 - we'll return n
48:56 - now if we had an array of objects here
48:59 - instead of just returning some number we
49:01 - would have to copy that object so we
49:03 - would have to use the spread operator to
49:05 - take a full copy of that object okay
49:08 - so let's store the result in updata
49:12 - and then do a console.log
49:17 - take a look
49:19 - so we replaced 2 with 20.
49:21 - now if you forget any of these patterns
49:23 - don't worry I'm going to include all the
49:25 - source code that I'm writing throughout
49:26 - this course in a separate project that
49:29 - should be available in the zip file that
49:31 - you downloaded at the beginning so let
49:33 - me show you what I've done here I've
49:35 - created a folder called functional and
49:37 - all the code that I've written
49:38 - throughout this section is available in
49:40 - this folder for example we have examples
49:42 - of current we have patterns for updating
49:45 - objects so we can always come back to
49:47 - the source code if you forget something
49:50 - foreign
49:54 - does not prevent object mutations
49:56 - because it's not a pure functional
49:58 - programming language to work around this
50:00 - we have to use libraries that offer real
50:03 - immutable data structures there are tons
50:05 - of laborers out there but the most
50:07 - popular options are immutable imer and
50:10 - Mari immutable or immutable JS is
50:13 - developed by Facebook and it's a very
50:14 - popular Library it gives you a bunch of
50:17 - immutable data structures such as a map
50:19 - or a list but there are a number of
50:21 - problems with this Library I'm going to
50:22 - talk about them in the next video Emer
50:24 - is a neural library that is developed by
50:26 - the creator of mobx it's becoming very
50:28 - trendy and a lot of people including
50:30 - myself love it unlike emulable.js email
50:34 - doesn't give you any immutable data
50:35 - structures so it allows you to work with
50:37 - the plain old JavaScript objects now
50:40 - Mari honestly I've never worked with it
50:42 - but I've heard it's popular
50:44 - at the end of the day the library you
50:46 - choose is entirely up to you these are
50:48 - just tools different people love
50:50 - different tools next I'm going to show
50:52 - you how to work with immutable Js
50:59 - in this lesson I'm going to give you a
51:01 - quick tour of immutable JS so here we
51:04 - have a basic JavaScript code we have a
51:07 - book object with a title property
51:09 - we have a function called publish it
51:12 - gets a book object and set its published
51:14 - properties true
51:16 - next we call this function and then log
51:18 - this book on the console pretty
51:20 - straightforward
51:21 - now when practicing functional
51:23 - programming we don't want to muted
51:25 - objects so this is where we can use
51:27 - immutable.js immutable JS provides a
51:30 - bunch of immutable data structures so
51:33 - instead of using a plain JavaScript
51:35 - object we're going to use one of the
51:37 - data structures provided by immutable.js
51:40 - so first open up your terminal window
51:42 - and run npm install immutable
51:49 - okay so I'm using immutable version 4.0
51:53 - now
51:54 - back to this code on the top
51:57 - we need to import
51:58 - the map function
52:00 - from the immutable Library
52:03 - with this map function we can create a
52:05 - map or hash map that's like a regular
52:07 - JavaScript object it's a container for
52:10 - key value pairs but this map object that
52:12 - we get from this library is immutable so
52:15 - now
52:16 - instead of using this plain JavaScript
52:19 - object
52:20 - we're going to call the map function
52:24 - to get a map object now let me
52:26 - temporarily comment out this code so we
52:29 - create a map object and log it on the
52:31 - console take a look
52:34 - so this is what we get this is not a
52:37 - regular book object it has a bunch of
52:39 - weird properties like size root owner ID
52:43 - and so on so this is the first problem
52:45 - with this Library
52:46 - if you want to log the title of a book
52:48 - we cannot access the title property
52:51 - using the dot or bracket notation
52:54 - we have to call
52:56 - the get method get title save the
52:59 - changes
53:01 - there you go
53:02 - so the first problem of this library is
53:04 - that we have to learn a whole new API
53:07 - now this API is not that complex we can
53:09 - learn it pretty quickly but in my
53:11 - opinion the main problem is that it's
53:13 - hard to integrate this with other
53:15 - libraries that expect plain JavaScript
53:18 - objects every time we need to work with
53:20 - plain JavaScript objects we have to call
53:24 - the 2js method
53:27 - so this returns a plain JavaScript
53:30 - object
53:31 - now let's bring this code back in
53:34 - so when publishing a book you want to
53:36 - set its published property to true to do
53:39 - this using immutable we have to call the
53:41 - set method so set is published
53:45 - to true
53:46 - now this is not going to modify the
53:49 - original book object it's going to
53:51 - return a new object because all these
53:54 - map objects are immutable like strings
53:56 - in JavaScript so here we have to return
53:59 - the result
54:00 - we've published a book and then we can
54:04 - reassign the book variable
54:06 - and then we can convert it to a plain
54:08 - JavaScript object and log it on the
54:10 - console take a look
54:12 - so here's the result
54:15 - so here's immutable.js in action as you
54:18 - can see once you start using it it gets
54:20 - spread out everywhere in your code base
54:22 - everywhere you have to use these Getters
54:24 - and Setters or convert immutable data
54:27 - structures to plane JavaScript objects
54:30 - that is why I personally prefer immer
54:32 - we're going to talk about that next
54:35 - foreign
54:42 - ER as you can see on npm Trends Emer has
54:46 - gained a lot of popularity and is almost
54:48 - as popular as immutable JS so this
54:51 - Orange Line represents immutable and the
54:54 - blue line represents imma
54:56 - so in our terminal window let's install
54:58 - imer
55:02 - alright now we have the same code that
55:05 - we had in the last video so here we are
55:07 - mutating this book object we don't want
55:09 - to do that let's see how we can solve
55:11 - this problem using immer so on the top
55:14 - we import
55:17 - the prettiest function
55:19 - from imer
55:21 - make sure to import it from Emer before
55:23 - I was recording this video I made a
55:25 - mistake and imported it from immutable
55:27 - the immutable Library does not have this
55:29 - produce function okay
55:31 - so
55:33 - in our polish function we are not going
55:35 - to mutate the book object instead we're
55:38 - going to call the prettiest function
55:41 - and give it two arguments the first
55:43 - argument is our book object over here
55:45 - this is what we call the inertial state
55:49 - then we're going to pass a function that
55:51 - specifies our mutations so this function
55:54 - is going to take a book object to
55:56 - differentiate let's call that draft book
55:59 - that goes to a block of code
56:02 - now in this block we can write mutating
56:04 - code so we can write draft book
56:08 - dot is published equals true however
56:12 - when following this pattern this book
56:15 - object is not going to get modified
56:17 - because this draft book is actually a
56:19 - proxy that records all the changes we
56:22 - are making
56:23 - to this initial book object
56:25 - so this produce function is going to
56:27 - take a copy of this object and apply all
56:30 - the changes we are doing here now what
56:32 - is beautiful about Emer is that our code
56:34 - looks familiar to us so we are writing
56:37 - code as if we are mutating an object but
56:39 - our object is not going to get mutated
56:41 - this is much better than using the
56:43 - spread operator because you saw that the
56:46 - spread operator can get kind of nasty
56:48 - when we're dealing with nested objects
56:50 - we have to do a lot of cloning with Mr
56:53 - we don't have to worry about any of this
56:54 - we simply follow this pattern and write
56:57 - code in a familiar style now this
56:59 - produce function is going to return the
57:01 - updated object so we're going to return
57:04 - it from our publish function
57:06 - so this publish takes a book and returns
57:10 - a new book let's call that updated
57:14 - and then we can log both these objects
57:17 - on the console
57:19 - take a look
57:21 - so here's our original book object as
57:23 - you can see it's not modified and
57:26 - here's the updated book object
57:32 - now that you have learned the
57:33 - fundamentals of functional programming
57:35 - you're ready to learn Redux so in this
57:37 - section we'll be talking about the Core
57:39 - Concepts in Redux we'll start off by
57:41 - talking about the Redux architecture
57:43 - then I'll show you the steps that you
57:45 - need to follow to build an application
57:46 - with Redux you will see all these steps
57:49 - in action using a real project so let's
57:51 - jump in and get started
57:54 - oh
57:59 - earlier I told you that with Redux we
58:01 - store our application State inside a
58:04 - single JavaScript object called the
58:06 - store this object is the single source
58:08 - of Truth for our application State and
58:11 - is accessible by all parts of the UI for
58:14 - example in an e-commerce app our store
58:16 - can have properties like the list of
58:18 - categories products shopping cart the
58:21 - current user and so on what we have in
58:23 - the store is entirely up to us Redux has
58:26 - no opinion about it we can use arrays
58:28 - objects numbers booleans essentially
58:32 - anything that represents the data that
58:34 - our application needs to function
58:36 - now we cannot directly modify or mutate
58:39 - the store because Redux is built on top
58:42 - of functional programming principles in
58:44 - the last section I told you that in
58:46 - functional programming we do not mutate
58:48 - state so we cannot write code like this
58:51 - because our store is an immutable object
58:53 - so to update it we should create a
58:56 - function that takes the store as an
58:58 - argument and Returns the updated store
59:00 - so in this function we should either use
59:02 - the spread operator to create a copy of
59:05 - the store or use one of the immutability
59:07 - libraries that we talked about in the
59:09 - last section like immutable JS or immer
59:12 - now this function is called a reducer I
59:15 - know the name is a bit weird and a lot
59:18 - of people have complained about it but
59:19 - let's not worry about it for now all
59:22 - that matters is that a reducer is a
59:24 - function that takes the current instance
59:25 - of the store and Returns the updated
59:28 - store now here's a question
59:30 - how does the reducer know what
59:32 - properties in the store it should update
59:34 - should it update the shopping cart or
59:37 - the current user or the list of products
59:39 - so we need another building block called
59:41 - an action
59:42 - an action is just a plain JavaScript
59:45 - object that describes what just happened
59:47 - examples are the user logged in or
59:50 - logged out or added an item to a
59:52 - shopping cart and so on these are the
59:54 - events that can happen in our
59:55 - application
59:56 - so we should give this reducer an action
59:59 - as the second parameter
60:00 - now based on the type of the action the
60:03 - reducer will know what properties of the
60:05 - state to update now doesn't mean that
60:08 - all the updates are going to happen
60:10 - inside a single function or a single
60:12 - reducer no this is just a simplified
60:15 - example in a real app our store can have
60:18 - many slices for example here we have
60:20 - four slices categories products the
60:23 - shopping cart and the current user each
60:26 - reducer will be responsible for updating
60:28 - a specific slice of the store as a
60:30 - metaphor think of an organization with
60:32 - multiple departments each department
60:34 - should have a manager that is
60:36 - responsible for their own department
60:38 - they don't have to worry about the other
60:40 - departments so these are the three
60:42 - building blocks and Redux applications
60:44 - we have the store which is a single
60:46 - JavaScript object that includes our
60:48 - application State we have actions which
60:50 - are plain JavaScript objects that
60:53 - represent what just happened it would be
60:55 - nicer if they were called events because
60:57 - in programming an event represents what
61:00 - just happened we also have one or more
61:02 - reducers each responsible for updating a
61:05 - slice of the store you can think of
61:07 - these reducers as event handlers or
61:10 - processors I think the reason they are
61:12 - not called event handlers is that could
61:14 - often even handlers are associated with
61:16 - object mutation which is something we
61:18 - don't do in Redux
61:19 - users are pure functions so they don't
61:22 - touch Global State they don't mutate
61:24 - their arguments and they don't have any
61:26 - side effects they just get the current
61:28 - store instance and return the updated
61:30 - one
61:31 - now how do these building blocks work
61:33 - together well when the user performs an
61:36 - action let's say they add an item to
61:38 - their shopping cart
61:39 - we create an action object and dispatch
61:41 - it the store object has a dispatch
61:43 - method that takes an action it will then
61:46 - forward this action to the reducer so we
61:48 - do not call the reducer directly we just
61:51 - work with the store the store is in
61:53 - charge of calling the reducer okay the
61:55 - reducer computes the new state and
61:57 - returns it next the store will set the
62:00 - state internally and then notify the UI
62:03 - components about the update these UI
62:05 - components will then pull out the
62:06 - updated data and refresh themselves
62:09 - you're going to see all these
62:10 - interactions in a few minutes now you
62:13 - might be wondering why redox is designed
62:15 - this way why do we need this building
62:17 - blocks why do we need to dispatch
62:18 - actions well this dispatch is like an
62:21 - entry point to our store
62:23 - so by dispatching actions we are
62:26 - essentially sending every action through
62:28 - the same entry point so we have a
62:30 - central place where we can control what
62:32 - should happen every time the user
62:34 - performs an action this allows us to do
62:37 - some really cool things for example we
62:39 - can log every action this is how Redux
62:41 - Dev tools works it shows every action
62:44 - that has been dispatched and how this
62:46 - date has changed we can also easily
62:48 - Implement undo and redo mechanisms so
62:51 - that's the idea over the next few videos
62:53 - I'm going to show you all these building
62:55 - blocks in action
62:57 - foreign
63:00 - now we're ready to build our first Redux
63:03 - application we're going to build a bug
63:05 - Tracker app using Redux so on the UI
63:08 - we're going to have a text box for
63:09 - entering information about a bug we just
63:12 - discovered we can add this block to a
63:14 - list then we can remove a bug we can
63:17 - mark it as resolved we can change the
63:19 - status to in progress and so on now in
63:21 - this section we're not going to spend
63:22 - any time on the UI because Redux is
63:24 - about State Management so we want to
63:27 - focus on Redux we don't want to get
63:28 - distracted with all the complexities of
63:31 - building user interfaces we'll talk
63:33 - about the UI later when we talk about
63:35 - integrating Redux with react okay so now
63:39 - let's look at the four steps that you
63:40 - need to follow when you want to build a
63:42 - Redux application first you need to
63:44 - design the store you need to decide what
63:46 - you want to keep in the store
63:48 - next you need to define the actions what
63:51 - are the actions that the user can
63:52 - perform in this application
63:53 - next you create one or more reducers
63:55 - these reducers take an action and return
63:58 - the updated State and finally you need
64:00 - to set up the store based on your
64:02 - reducer over the next few lessons we're
64:05 - going to look at each of these steps in
64:06 - detail
64:07 - now before we get started we need to add
64:09 - Redux to our project so in the terminal
64:12 - window we type npm install Redux I'm
64:15 - going to use the latest version which is
64:17 - version 4.0
64:19 - the chances are in the future there is a
64:21 - newer version available what I'm going
64:23 - to show you in this course I have
64:24 - confidence that's going to work with the
64:26 - future versions of Redux but to be on
64:28 - the safe side I highly encourage you to
64:30 - use the same version I'm using here so
64:32 - version 4.0
64:36 - all right Redux is installed so next
64:39 - we'll talk about designing the store
64:46 - the first step in building a Redux
64:49 - application is designing the store we
64:51 - need to decide what we want to keep in
64:53 - the store
64:54 - so for a buck tracking application like
64:56 - this what kind of state do we need we
64:58 - need to maintain the list of books so
65:01 - this is the simplest structure we can
65:03 - come up with we can have an array of bug
65:05 - objects every bug object can have
65:07 - properties like ID description and
65:10 - result which is initially set to false
65:13 - this is the simplest structure we can
65:15 - come up with now in a more real life
65:17 - application our store would probably
65:19 - look like this so instead of an array
65:21 - we're going to have an object with
65:23 - multiple properties so this object has a
65:25 - property called Bugs this is where we
65:27 - have our list of bugs we can have
65:30 - another property called current user
65:32 - this can initially be a null when the
65:34 - user logs in we're going to set this to
65:36 - an object so in this example our store
65:38 - has two slices one slice for the list of
65:42 - bugs and another slice for the current
65:44 - user and that means we're going to have
65:46 - two different reducers now in this
65:49 - section we don't want to worry about all
65:51 - these little details we want to focus on
65:53 - the simple structure that allows us to
65:55 - study Redux and see all its building
65:57 - blocks in action so we're going to go
66:00 - with this structure later in the course
66:02 - as our application develops we can
66:04 - refactor this structure and turn it into
66:07 - something more like this
66:14 - so we have completed the first step to
66:16 - build a Redux application now the second
66:18 - step is defining the actions what are
66:21 - some of the actions that a user can
66:22 - perform in our bug tracking application
66:24 - well they can add a bug they can Market
66:27 - bug as resolved and delete a bug now in
66:30 - a real live application we could have
66:32 - many other types of actions for example
66:34 - the user can change the status of a book
66:36 - they can filter the list of books they
66:38 - can change the sort order and so on for
66:41 - now let's just focus on these actions
66:43 - earlier I told you that an action is
66:45 - just a plain JavaScript object that
66:48 - describes what just happened here's an
66:50 - example you have an object with two
66:52 - properties type and description
66:55 - type is the only property that Redux
66:57 - expects in your action objects so if you
67:00 - don't have this type property Redux is
67:02 - going to complain now here we're using a
67:04 - string as the value of the type property
67:06 - but you can use any other type that is
67:08 - serializable which means we can store it
67:11 - on the disk why because Redux is built
67:14 - on this principle that we should be able
67:16 - to store the state of our application on
67:18 - disk and reload from it later
67:20 - strengths are serializable we could also
67:23 - use a number here but the problem with
67:25 - numbers is that they are not descriptive
67:27 - we don't want to write code and compare
67:29 - the type of an action with let's say
67:32 - 124. someone else reading our code would
67:34 - wonder what is 124 they are not
67:37 - descriptive
67:39 - also when you look at the action history
67:41 - in Redux Dev tools we don't want to see
67:43 - a bunch of numbers you want to see a
67:45 - description of what has happened that is
67:48 - why we use strings
67:49 - now here I've used uppercase letters and
67:52 - I've separated these words using an
67:54 - underscore this is a common convention
67:56 - in Redux code but you don't have to
67:58 - follow it if you don't want to Redux as
68:00 - the library doesn't care you can use any
68:02 - naming convention that you prefer I
68:04 - personally prefer a different convention
68:06 - like bug added so I'm using a past tense
68:09 - because an action represents what just
68:12 - happened now here we have another
68:14 - property called description so this is
68:16 - the data associated with this action
68:18 - when the user types something in the
68:20 - text box to add a bug you store that
68:23 - value in the description property in a
68:26 - real application we could have a complex
68:27 - form with many fields the user can
68:30 - specify who reported this bug what is
68:32 - the severity and so on in that case we
68:34 - will store all those extra attributes in
68:37 - this object now earlier I told you that
68:39 - Redux was inspired by flux which is an
68:42 - architectural pattern and a library
68:44 - built by Facebook in flux actions have a
68:47 - slightly different structure
68:49 - so they have two properties type and
68:51 - payload payload is an object that
68:54 - contains all the data about an action
68:56 - you don't have to follow this structure
68:58 - in Redux because Redux doesn't care but
69:00 - I personally prefer this structure
69:02 - because it gives my actions a common and
69:05 - consistent structure let's look at
69:07 - another example here we have an action
69:09 - for removing a bug so the type is bug
69:12 - removed and in the payload we have the
69:15 - ID of the bug what is important here is
69:17 - that the payload contains the minimum
69:19 - information we need about an action so
69:22 - if you're removing a bug we don't need
69:24 - to store the Box description or the date
69:26 - that occurred and so on all we need to
69:28 - identify a bug is its ID
69:31 - so now that we have an idea about our
69:32 - actions next we're going to build our
69:34 - reducer
69:40 - now we're ready to create our first
69:42 - reducer so here in the source folder
69:45 - let's add a new file
69:47 - called reducer.js
69:49 - as I told you before a reducer is a
69:52 - function
69:53 - with two parameters the current state
69:56 - and an action
69:58 - the job of this reducer is to return the
70:00 - new state based on this action so here's
70:04 - an example if action.type equals
70:08 - bug added
70:09 - then you're going to return the new
70:11 - state the earlier we decided to use a
70:14 - simple array
70:16 - to represent our store an array of books
70:18 - so if the user adds a book we want to
70:21 - return a new array
70:24 - in this array first we want to copy
70:26 - all the bugs in the current state so
70:29 - here we are using the spread operator
70:32 - and then we add
70:33 - a new bug object here this object should
70:36 - have a few properties like ID
70:37 - description and result
70:40 - so we set description to action that
70:42 - payload the description
70:46 - and we said resolved to false
70:49 - now for the ID we need to have some kind
70:51 - of counter so
70:52 - I'm going to declare a variable here
70:54 - last ID and initialize it to zero
70:57 - every time we add a book
71:00 - we're going to increment last ID first
71:02 - and then use it as the value of the ID
71:04 - property there is something I want you
71:07 - to pay attention to here the payload of
71:09 - the action should contain the minimum
71:11 - information we need to update our system
71:13 - so in the case of adding a bug we don't
71:16 - want to pass the ID or result properties
71:19 - because the minimum information we need
71:21 - for adding a bug is the description of
71:24 - the bug so everything else should be
71:26 - computed here in the reducer because
71:28 - this is where we Implement our business
71:30 - logic okay also here I'm using the
71:33 - spread operator to copy this array we
71:36 - don't have to do this we can use one of
71:37 - the immutability libraries like
71:39 - immutable JS or immer we'll use them
71:42 - later in the course for now I just want
71:44 - to show you the plain Redux code because
71:46 - that's what you see in most projects so
71:49 - here's a case for adding a book
71:53 - so after a return statement we can have
71:56 - else if
71:57 - action the type equals
72:00 - bug removed
72:03 - now here we want to return
72:05 - a new array that contains all the bugs
72:07 - except the bug with the given ID so I
72:11 - showed you how to do this in the last
72:12 - section
72:13 - we basically get the existing array and
72:15 - filter it
72:17 - so here we pass a function
72:19 - we get a bug
72:20 - we want to return all bugs except the
72:22 - bug
72:23 - with the given ID
72:25 - we can pick that from action that
72:27 - payload.id
72:29 - simple as that
72:30 - now what if the type of our action is
72:33 - neither of this we should return
72:37 - the current state
72:38 - this is very important because if you
72:40 - make a mistake if we dispatch an action
72:42 - that doesn't exist we don't want our
72:44 - system to blow up we want to return the
72:46 - current state okay we're almost done
72:50 - the only part that is missing is the
72:52 - initial state so when we start our
72:54 - application the store is initially
72:57 - undefined Redux is going to call our
72:59 - reducer and pass undefined as the value
73:02 - of the state in that case we want to
73:05 - return the initial State we don't want
73:06 - to return undefined or null now what is
73:09 - the initial State here
73:11 - that is an empty array so
73:14 - we can set that
73:16 - using a default argument over here
73:18 - so when we start our application Redux
73:21 - is going to call our reducer and pass
73:24 - undefined as the value of the state in
73:26 - that case we're going to reset the state
73:28 - to an empty array okay
73:31 - now in this example
73:33 - I'm using an if and else to implement
73:36 - this logic we could also use a switch
73:38 - and case statement Redux doesn't care
73:40 - it's entirely up to you some people
73:42 - don't like switch on case if you prefer
73:44 - even else go for it but let me show you
73:47 - how to implement this logic using a
73:49 - switch on case
73:50 - so let's switch on action the type
73:55 - here we're going to have two cases
73:58 - one for bug added
74:00 - and another
74:02 - for bug removed
74:05 - now for each case I'm going to copy the
74:07 - code from here
74:08 - so
74:10 - here's our return statement cut
74:13 - I'm going to add it here
74:16 - and finally for bug removed we have
74:20 - another return statement
74:23 - very easy
74:24 - we also need a default case if the
74:27 - action type is none of these values in
74:29 - that case we want to return the current
74:31 - state
74:33 - so
74:35 - here's our final
74:37 - implementation
74:39 - now one thing I need to emphasize here
74:41 - is that this reducer is a pure function
74:44 - we talked about pure functions in the
74:46 - last section A pure function is a
74:48 - function that if we call it multiple
74:49 - times and give it the same argument it
74:52 - always returns the same result and is
74:54 - free of side effects so in a pure
74:56 - function we are not going to touch Dom
74:57 - elements we're not going to work with
74:59 - any Global State we're not going to make
75:01 - API calls because all these operations
75:04 - can change the state of our system as a
75:06 - whole in that case if we call this pure
75:09 - function multiple times we may not get
75:11 - the same result
75:12 - so pure function should be a small
75:14 - function in an isolated world all it
75:17 - needs should be passed as arguments
75:20 - these are the only dependencies of a
75:22 - pure function so this reducer this pure
75:24 - function takes these two arguments and
75:27 - Returns the new state that's all it does
75:29 - now this properties make it really easy
75:32 - to test this reducer we don't have to
75:34 - set some Global State before calling
75:36 - this function for testing so in Redux
75:39 - reducers have to be pure now you might
75:42 - be wondering how we're going to make API
75:44 - calls we'll talk about that later in the
75:46 - course for now don't worry about that
75:49 - foreign
75:53 - now that we have a reducer we are ready
75:56 - to create our store based on this
75:58 - reducer so in the source folder let's
76:01 - add a new file
76:03 - store.js
76:05 - now here first we should import
76:07 - the create store function
76:10 - from Redux
76:12 - next we call it
76:14 - now here we should pass our reducer so
76:17 - that means we should go to our reducer
76:19 - file
76:20 - and Export this function I would prefer
76:23 - to export it as a default object so we
76:25 - can easily import it in other modules so
76:28 - save the changes
76:30 - now we can import reducer from the
76:35 - current folder
76:36 - reduce our module
76:38 - now if we didn't do a default export we
76:40 - would have to wrap this
76:42 - in braces with the default export we
76:44 - don't have to do that so this is the
76:46 - only object that is exported from this
76:48 - module okay
76:49 - so we pass our reducer as an argument
76:52 - and note that I'm not calling it I'm
76:54 - just passing a function reference so
76:57 - create store is another example of a
76:59 - higher order function because it takes a
77:01 - function as an argument right
77:04 - now this returns a store object so
77:08 - finally we need to export it
77:11 - so we can bring it in our main
77:12 - application we'll do that next
77:20 - so we created the store now let's use it
77:23 - so
77:24 - in index.js
77:27 - first we should import the store
77:30 - from the store module in the current
77:32 - folder note that I'm not wrapping this
77:34 - in braces because I exported the store
77:36 - as a default object okay
77:39 - so here's our store now before going any
77:42 - further let's just log this on the
77:44 - console and see what it really looks
77:46 - like so save
77:48 - now there you go so a store is an object
77:51 - with these properties we have a method
77:54 - for dispatching actions we have a method
77:56 - for subscribing to the store so when you
77:58 - subscribe to the store we get notified
78:00 - every time the state of the store
78:02 - changes this is used by the UI layer
78:05 - you're going to see that very soon we
78:07 - also have a method for getting the
78:09 - current state of the store we also have
78:11 - replace reducer and symbol of observable
78:14 - these are Advanced topics we'll talk
78:15 - about them in the future now what is
78:17 - interesting here is that we do not have
78:20 - a method for setting the state of the
78:22 - store we only have get State not set
78:25 - State this is a fundamental principle in
78:27 - Redux so to change the state of the
78:30 - store we have to dispatch on action with
78:32 - this architecture we're essentially
78:34 - sending every action through the same
78:36 - entry point that is the beauty of Redux
78:39 - so back to our code let's call get State
78:43 - and look at the current state of the
78:45 - store
78:46 - so save
78:48 - so initially we have an empty array
78:50 - because we haven't added any bugs yet so
78:53 - let's dispatch an action
78:55 - so before console.log we're going to
78:58 - call store.dispatch
79:00 - and pass an action this action should
79:03 - have two properties right one is type
79:06 - which was set to bug added
79:09 - the other is payload
79:11 - which is an object with a property
79:14 - called description
79:15 - and we can set this to bug one
79:17 - so in a real application when the user
79:19 - clicks on the add button we're going to
79:21 - dispatch an action now save the changes
79:25 - there you go
79:27 - so in this array we have a bug object
79:28 - with ID set to one here's a description
79:31 - and it's not resolved now let's dispatch
79:34 - an action for removing this bug
79:36 - so right after we got a dispatch
79:40 - another action
79:45 - the type of this action is going to be
79:46 - bug removed and in the payload we just
79:51 - want to pass the ID of this action we
79:53 - don't need anything else
79:55 - so save the changes
79:57 - now our store is back to initial state
80:06 - all right now let's see how we can
80:07 - subscribe to the store so before
80:09 - dispatching an action I'm going to call
80:12 - the Subscribe method here we should pass
80:15 - a function this function gets called
80:17 - every time the state of the store gets
80:19 - changed so here we can log
80:22 - store change
80:24 - and as the second argument we can get
80:27 - the current state of the store so store
80:30 - that get state
80:31 - this is basically something we do in the
80:33 - UI layer so whenever the state of the
80:35 - store changes we want to refresh the UI
80:38 - if you're building an application with
80:40 - vanilla JavaScript or jQuery this is
80:42 - where we're going to work with our Dom
80:43 - elements we're going to refresh the view
80:45 - if you're building an application with
80:47 - react we're going to re-render now we'll
80:50 - talk about that in the future for now
80:52 - what you need to understand is that UI
80:54 - components should subscribe to the store
80:56 - so they get notified when the state of
80:58 - the store changes Okay so
81:01 - let's save the changes back in the
81:03 - browser so you can see our store changed
81:06 - twice this is the first time
81:08 - so we got a new bug and then we removed
81:11 - that bug
81:13 - now this subscribe method returns a
81:15 - function for unsubscribing from the
81:17 - store
81:18 - so let's store that over here
81:20 - unsubscribe
81:22 - this is important because it is possible
81:24 - that the user navigates away from the
81:26 - current page and in the new page we're
81:28 - not going to have that UI component so
81:31 - we don't want to have a subscription to
81:32 - the store because this subscriptions can
81:34 - create memory leaks so if the current UI
81:37 - component is not going to be visible we
81:39 - should unsubscribe from the store let me
81:41 - simulate this so let's say
81:45 - we added a bug now
81:47 - I'm going to call unsubscribe
81:50 - so the second time we are dispatching an
81:52 - action we are not going to get notified
81:55 - save the changes
81:56 - and take a look we only have one message
81:59 - that indicates that the store is changed
82:02 - the second time the store got changed we
82:04 - did not get notified because we had
82:06 - unsubscribed before
82:13 - you have seen all the building blocks of
82:15 - Redux actions reducers and the store let
82:19 - me walk you through the Redux workflow
82:21 - one more time so when we dispatch an
82:24 - action
82:24 - our store is going to call our reducer
82:27 - it's going to give it the current state
82:30 - and the action that we dispatched based
82:33 - on the type of the action we're going to
82:34 - get
82:36 - the new state so
82:38 - this dispatch method
82:40 - if you look at its source code it
82:42 - actually looks like this it calls the
82:44 - reducer
82:45 - gives it the current state and the
82:47 - action that we dispatched
82:49 - and then it will get the new state
82:51 - which is going to store here so this is
82:54 - the internal state of the store okay
82:56 - then it's going to notify the
82:59 - subscribers now in the next section I'm
83:01 - going to show you how to build Redux
83:03 - from scratch so you're going to code all
83:05 - of this but before we get there I need
83:07 - to emphasize that Redux is actually a
83:09 - very small and simple Library it has a
83:11 - small API it has a small footprint
83:13 - earlier you saw that the store object
83:16 - has only a few methods that you have to
83:18 - learn about get State dispatch and
83:21 - subscribe so there are very few moving
83:23 - Parts in Redux however when building
83:25 - real world applications with Redux we
83:28 - often introduce additional building
83:30 - blocks that make our code more
83:32 - maintainable for example one problem we
83:34 - have in this implementation is that we
83:37 - have hard-coded this string in two
83:39 - places
83:40 - one is here where we are dispatching an
83:42 - action
83:43 - the other is in a reducer
83:45 - where we're handling this action
83:47 - what if tomorrow we decide to rename
83:49 - this from bug added to bug creator then
83:52 - there are multiple places in our
83:53 - application that we have to update and
83:55 - if we don't do so we're going to create
83:56 - a bug
83:57 - so let me show you how to fix this
83:59 - problem
84:01 - we're going to add a new file
84:03 - called action types
84:06 - we're going to store that string in a
84:08 - single place and use it in multiple
84:10 - places so here we're going to export
84:13 - a constant called Bug added
84:16 - and set it to that string that magic
84:18 - string
84:20 - similarly we can create another constant
84:22 - called Bug removed
84:27 - this is the only place where we're using
84:29 - the string literal if tomorrow we want
84:31 - to change it this is the only place we
84:33 - have to update now we go to our reducer
84:37 - and replace the string with the constant
84:40 - that we just exported so on the top
84:43 - we're going to import
84:45 - we can use a named import so we can
84:48 - import bug added and Bug removed
84:53 - from
84:54 - the action types module that's one way
84:56 - the other way is if you're dealing with
84:59 - multiple action types we don't want to
85:00 - pollute this import statement so we can
85:03 - import everything as
85:06 - actions now this actions is going to be
85:09 - an object with properties like bug added
85:12 - and Bug remove let me show you so we're
85:15 - going to replace bug added with actions
85:18 - dot look we have these two properties
85:21 - Bugatti
85:22 - similarly we're going to replace
85:25 - bug removed with actions that
85:28 - bug remove well actually I should have
85:31 - used bug removed so
85:33 - let's rename this to bug removed
85:36 - okay good
85:38 - now
85:40 - finally in our index.js when dispatching
85:42 - an action we're going to use that
85:44 - constant one more time so let's import
85:46 - everything as actions
85:49 - from action types
85:52 - and then
85:55 - we're going to set the type to actions
85:57 - Dot
85:58 - Bugatti as simple as that
86:06 - the other problem we have in this
86:08 - implementation is how we dispatch an
86:11 - action
86:12 - as you can see dispatching an action is
86:14 - not easy we have to type the entire
86:17 - structure of this object now what if
86:19 - there are multiple places where we want
86:21 - to dispatch the same action then we have
86:23 - to repeat all this structure in multiple
86:25 - places to improve this we can create a
86:28 - function that would create this action
86:29 - object for us we call that an action
86:32 - Creator so
86:34 - in our project
86:36 - in the source folder let's add a new
86:38 - file we can call it actions or action
86:41 - creators I prefer actions but that's
86:44 - entirely up to you
86:46 - so here you want to create a function
86:49 - called Bug added which takes a
86:52 - description
86:54 - and then returns
86:57 - this object structure over here so let's
86:59 - cut that
87:00 - and then paste it here
87:02 - pretty simple right now we can export
87:04 - this
87:05 - and
87:07 - import it in our main module so in this
87:09 - case we don't need this import statement
87:11 - anymore because we need action types
87:13 - only when creating an action so I cut
87:16 - that line
87:17 - and paste it here okay this is where
87:19 - we're using our constant
87:21 - now
87:23 - in the index module
87:24 - I'm going to import
87:27 - bug added
87:29 - from the actions module
87:32 - so here we have a named export because
87:34 - bug added is not a default export okay
87:37 - now when dispatching an action we simply
87:39 - call this function bug added and give it
87:42 - the description
87:44 - this makes our code a lot cleaner and if
87:47 - you want to dispatch the same action
87:48 - from multiple places we simply have to
87:51 - call this function we don't have to
87:52 - worry about the structure
87:55 - of this action object if tomorrow we
87:58 - want to change the structure of this
87:59 - action there is a single place that we
88:01 - have to update okay
88:03 - so this is why we use action creators
88:05 - now I personally prefer to create my
88:07 - action creators using an arrow function
88:09 - because they have a more concise syntax
88:11 - let me show you so let me comment this
88:14 - out
88:16 - now
88:17 - you're going to export a constant called
88:20 - Bug added
88:22 - and set it to an error function this
88:24 - function should take description as a
88:26 - parameter and return an object so here
88:29 - we cannot use curly braces because these
88:31 - braces indicate a block of code but here
88:34 - you want to return an object so we
88:36 - should wrap this in parenthesis
88:39 - now this is the action object that we
88:41 - want to return so it should have these
88:44 - two properties type and payload I copy
88:47 - these paste them here
88:49 - and then remove the comet
88:52 - so
88:53 - this is another way to create an action
88:56 - Creator now what syntax you use is
88:58 - internally up to you
89:04 - here's an exercise for you I want you to
89:07 - implement resolving a bug so we should
89:10 - be able to create a bug and then Mark it
89:12 - as resolved spend five to ten minutes on
89:14 - this exercise and then come back see my
89:16 - solution
89:22 - to implement a new feature with Redux
89:24 - you should always think about your
89:26 - actions first and then your reducer so
89:29 - we want to define a new action or a new
89:31 - capability or a new event that can
89:33 - happen in our application that is
89:35 - resolving a bug
89:37 - so first we go to our action types
89:39 - module
89:40 - and Define a new constant
89:43 - called Bug resolved
89:46 - once again I'm using the past tense here
89:48 - to represent an event that just happened
89:51 - so we set it to bug
89:53 - result
89:55 - next we should create an action creator
89:58 - so
90:00 - in the actions module
90:03 - we export a new constant
90:06 - called Bug resolved and set it to a
90:09 - function
90:09 - now what pieces of information do we
90:11 - need for resolving a bug at a minimum we
90:14 - need to know the idea of the bug so it
90:17 - is going to be a parameter
90:18 - until you're going to return an object
90:20 - so we wrap that object in parenthesis
90:23 - now the type of this object is going to
90:25 - be
90:28 - actions.bug resolved note that the
90:30 - benefit of importing the actions using
90:32 - the syntax is that every time we Define
90:35 - a new action every time we Define a new
90:37 - constant we can simply use it in this
90:39 - module in contrast if we used named
90:43 - Imports let's say bug added
90:46 - from action types
90:48 - every time we Define a new action type
90:50 - we have to come back and add that new
90:52 - action type here so this is a simple tip
90:55 - we import everything as one object
90:59 - now we set the type
91:01 - and then the payload
91:04 - here we can simply add
91:05 - the idea of this action now in modern
91:08 - JavaScript if the name of a property and
91:11 - the value are the same we can use a
91:13 - shorthand syntax so
91:15 - we get rid of it and by the way I
91:17 - noticed that in the last video I made a
91:19 - mistake a hard-coded bug one here but we
91:22 - should set the description property
91:24 - to the description argument so
91:27 - we save the description or use the
91:30 - shorthand syntax
91:32 - all right we're done with our action now
91:34 - we should change our reducer so it can
91:36 - handle our new action
91:37 - so
91:39 - let's go to reducer.js
91:42 - here we want to add a new case
91:46 - actions dot bug resolved
91:51 - see that's another benefit of importing
91:54 - all the actions as a single object I
91:57 - didn't have to go on top of the file and
91:59 - import our new action Okay so
92:03 - when a bug is resolved we want to update
92:06 - an existing bug object I talked about
92:08 - this pattern in the last section
92:10 - so
92:11 - basically you want to use state.map
92:16 - here we pass a function
92:18 - it takes a bug
92:19 - now if the idea of this book
92:22 - does not equal action that payload.id
92:26 - if this condition is true we want to
92:29 - return this bug as is otherwise we want
92:33 - to take a copy of this bug and modify it
92:35 - this is updating in an immutable way so
92:39 - here we want to return a new object
92:41 - first we want to copy all the properties
92:44 - of the bug
92:45 - and then we want to set the result
92:47 - property to True okay let me put this on
92:50 - a new line so you can see clarity
92:53 - so
92:55 - using the map method we're mapping this
92:57 - array to a new array if the idea of the
92:59 - book
93:01 - is not equal to the idea of the bug that
93:03 - we have resolved we're going to return
93:04 - that bug
93:05 - otherwise
93:07 - you're going to return
93:09 - a new bug object with all the properties
93:11 - of the existing bug but with the updated
93:13 - resolved property
93:15 - as you can see writing code like this is
93:18 - a little bit confusing and complex that
93:21 - is why we should use libraries like
93:23 - immutable JS or immer this is one of the
93:25 - main reasons that a lot of people find
93:27 - Redux confusing but don't worry later in
93:30 - the course I'm going to show you the
93:31 - modern way of writing Redux code that is
93:34 - very clean and concise for now I want to
93:36 - use the traditional way because that's
93:38 - what you say in most projects so a
93:41 - reducer is now capable of handling this
93:43 - new action or this new event
93:45 - with that we can go to our index module
93:48 - and after creating a bug we want to
93:51 - resolve it so store the dispatch
93:54 - we should import
93:56 - our new action Creator bug resolved
94:00 - then we call it over here bug resolved
94:02 - give it the ID and we're done
94:05 - save the changes
94:08 - so take a look
94:10 - in this array we have one bug that is
94:12 - resolved beautiful
94:16 - hey mosh here thank you for watching my
94:18 - Redux tutorial as I told you before this
94:21 - tutorial is the first hour of my
94:23 - complete Redux course that is 6 hours
94:25 - long and covers a lot more so if you
94:27 - want to learn more I highly encourage
94:29 - you to enroll in my complete redox
94:30 - course you will also receive a
94:32 - certificate of completion that you can
94:34 - add to your resume if you're interested
94:36 - up with the link down below thank you
94:37 - for watching and we hope to see you
94:39 - again please support me by liking this
94:41 - video and sharing it with others and be
94:43 - sure to subscribe for more videos like
94:44 - this
94:45 - [Music]

Cleaned transcript:

Welcome to My ultimate Redux course I'm mosh and I'm going to be your instructor over the next few hours in this course you will learn everything you need to know to build real complex applications with Redux we are not going to work on a dummy todo app we're going to work on a real bug tracking application with a note backend we'll go over functional programming principles writing clean code designing complex stores middleware calling apis testing and integrating with react I'm assuming this course you know nothing about Redux and want to learn everything from scratch I will explain every line of code I write so you learn and understand all the underlying principles I Promise You by the end of this course you will know and understand Redux inside out now before we get started I want to tell you that I have a coding school at codewithmash.com where you can find plenty of courses on web and mobile development so if you want to learn more from me be sure to check out my coding school now let's jump in and get started oh so what is Redux all about well Redux is a state management library for JavaScript applications we can use it with react angular view or even vanilla JavaScript because Redux is just a state management Library it doesn't care what library we use to build user interfaces but why do we need a state management library to start with well if you have ever built an application with a complex UI you have probably come across this situation where you need to keep different parts of the UI in sync let's say the user changes some data in one part of the UI and other parts of the UI should be immediately updated to reflect the changes in more complex scenarios that data can also get updated as a result of network requests or background tasks in these situations data can flow from one part of the UI to another and change in unpredictable ways we have to write a lot of code to keep everything in sync and when something goes wrong figuring out how the data changed and where it came from becomes really complex you might even end up with an infinite Loop that is hard to break if you encountered such problems in your applications that is a sign you need a state management Library Facebook encountered this problem in 2014 and came up with an architectural pattern called flux Redux is inspired by flux but it has grown more popular due to its Simplicity and elegance another popular solution is mobx with Redux instead of scattering application state in various parts of the UI we store all the application State inside a central repository that is a single JavaScript object called the store that is a single source of Truth you can think of it as some kind of a database for the front end so with this architecture the different pieces of the UI will no longer maintain their own State instead they get what they need from the store if we need to update the data there is a single place we have to update so this immediately solves the problem of synchronizing the data across different parts of the UI but redux's architecture also makes it easy to understand how the data changes in our applications if something goes wrong we can see exactly how the data changed why when and where it came from so in a nutshell Redux centralizes our application State and makes data flow transparent and predictable now that you know what Redux is let's look at some of its benefits in action so this is a food delivery application I have built with react and Redux on the left we have food categories such as soups salads and so on we can select the category and add items to our shopping cart note that as I'm adding these items the number of items in the shopping cart gets updated immediately so let's add a bunch of items let's also add an entree now let's go to our shopping cart once again we can update the number of each item in the shopping cart as I'm doing this the total price for this item for the cart as well as the number of items in the shopping cart get updated in real time so all the data in my application is in sync because we have a single store where we are storing our application State let me show you where it is this is Redux Dev tools a powerful tool for debugging Redux applications it's an extension to Chrome so over here you can see my entire application State 3 in one place so we have these entities we have our shopping cart we have our food categories and food items this auth object over here represents the current user so we have all the information about the current user and their authentication token we also have this UI property which includes some UI State now let me show you something powerful on the left side you can see all the actions that I have performed in this application so you can see I've added a bunch of items to my shopping cart now if I remove the first item green lentil soup you can see we have a new action here item removed if you select this action we can see the data associated with this action so over here I try to remove the product with id5 now let me show you something very cool I'm going to put this on the left side so you can see clearly let's jump to one of the previous actions the UI got updated immediately so we can go back to any of these previous actions and restore the UI in that state this is called time travel debugging we can also save the entire application state in a single file and reload the application from it later how many times have you got a call from your client or your boss telling you that a feature in your application is not working in these situations we have to ask them how did this happen tell me the exact steps that you followed then we have to repeat all those steps to reproduce the bug now every time we change our code our application gets reloaded and we have to follow those steps over and over this is very time consuming with Redux we don't have to do this anymore there's actually a tool called log rocket that gives you an alwayson Redux Dev Tools in production for every one of your users so if a user encounters a problem you can reload the application in the same state as the user and see what was going on it's very powerful another benefit of Redux is that it allows you to cash or preserve paid State let me show you what I mean so over here note that when I refresh the page you're going to see a loading indicator for three seconds indicating a slow connection so look refresh here's our loader now the menu appears okay now if we navigate away from this page and then come back to it the menu is already there we don't have to redownload it from the server because our entire application state is available on the client inside a single JavaScript object also I can select a filter here let's say soups and sort the menu by price once again if we navigate away and then come back our menu is in its previous state so let's quickly recap Redux makes State changes predictable and transparent we can easily see what exactly is going on and how the application State changes in response to every action the second benefit of Redux is that these centralizes our application state so all the data our application needs is stored in a single place that is accessible by all parts of the UI with Redux we can also easily debug our applications we can easily cache or preserve paid State and Implement undo or redo features so if your application needs these features you may want to consider Redux the great thing about Redux is that it works with any libraries for building uis you can use it with react angular Ember view even vanilla JavaScript plus we have a large and growing ecosystem of addons so these are all the great things about Redux but all these great things come at a cost redox introduces some indirection and complexity in your code this is partly because Redux is based on on functional programming principles and a lot of developers are not familiar with this concept but don't worry I'm going to teach you the basics of functional programming very soon another problem with Redux is that Redux code tends to be verbose you have to write some boilerplate code to get things done this is one of the main complaints about Redux so in this course first I'm going to show you the traditional way of writing Redux code which has a lot of boilerplate but later on I will show you the modern way of building Redux applications you're going to learn how to write clean and concise Redux code free of boilerplate so with all that is Redux for your dot we'll talk about that next if you have seen any of my courses before you've probably seen this guy his name is John Smith it's kind of arrogant and opinionated about everything so he says that he uses Redux in every project and so should you well I tend to disagree for every project or app you need to understand what problem you're trying to solve what your constraints are and what solution optimally solves the problem according to those constraints there is no such a thing as one size fits all in software engineering if you're on a tight budget if you're building a small to mediumsized app with fairly simple UI and data flow if the data doesn't change in your app or if you simply fetch the data on every page load and render it statically on the page redox is probably not the right tool for you it's just going to complicate things and slow you down without giving you much value so don't use Redux or any other tools because they're popular or someone told you to always think about your needs and the kind of app you're building now John argues that you should always use Redux right from the getgo because their State Management problem will get messy sooner or later so it's better to have the right foundation in the project well that reminds me of the old proverb if all you have is a hammer everything looks like a nail developers like John are often used to a certain way of building apps they solve every problem using the same solution and honestly I think that's just basic human nature we don't want to constantly think and figure things out we like to be an autopilot but if you want to be a real software engineer you need a different kind of attitude you need to be an active Problem Solver so the bottom line Redux is great it provides a number of benefits at the cost of extra complexity in your code base you will see this as we go through this course for every app you need to think about all the pros and cons of Redux and see if it's really the right tool for you or not in fact down every month the creator of Redux once said you might not need Redux this is a great blog post to read in your spare time so at the end of the day I encourage you to watch this course to the end because it helps you see what Redux is all about and whether it's the right tool for your next project or not also keep in mind that almost 60 percent of react projects are built with Redux so if you're a react developer chances are the next job or project you get is based on Redux so you need to know how Redux code works and how to maintain it and that's what you're going to learn in this course oh if you look below this video you're going to find the starter project for this course so simply open this folder with vs code or your favorite code editor now all you have to do is to open up a terminal window install the dependencies and start the project using npm so npm install all right all of our dependencies are installed so now let's start the project with npm start Now open up your browser and head over to localhost Port 9000 you should see the hello world message now let me give you a quick overview of what we have in this project so take a look at package.json here we have three development dependencies and they're all related to webpack in case you are not familiar with webpack it's actually a module bundler for JavaScript so we can split our JavaScript code into multiple files and have webpack combine them into a bundle we also have webpack development server which is a very lightweight development web server now over here you can see the configuration for webpack this is pretty standard nothing fancy here so we're telling webpack that the entry point to our project is this file index.js that is located in the source folder now webpack is going to start from here it's going to get all of our JavaScript files and then combine them into a file called app.js which is going to reside in this folder this which is short for distributable and here's the configuration for our development server so we are telling webpack to launch our application from this folder on Port 9000 pretty straightforward before we dive in let me give you a quick overview of how I've structured this course so you can get the most out of it Redux is based on functional programming principles a lot of people find Redux confusing because they are not familiar with this functional programming Concepts so the next section is all about functional programming in JavaScript we'll be talking about Concepts such as higher order functions composition occurring immutability and so on the following section is all about the fundamentals of Redux in this section you will see all the building blocks of Redux in action we'll be talking about reducers actions action creators and so on now Redux itself is a very simple Library so in the following section I'm going to show you how to implement Redux from scratch yourself this helps you gain a better understanding of this Library so it will no longer be a mystery to you you will know exactly how everything works next we'll talk about debug and Redux applications I will show you various tools available to you and how to use them to debug your Redux applications now some of the most common complaints about Redux is that it involves too much code too much boilerplate and that Redux code is ugly and unmaintainable so in the following section I will show you tons of techniques to write clean concise and beautiful Redux code then we're going to talk about designing a Redux store we'll talk about some patterns and techniques that you need to know for building real complex applications then we're going to talk about middleware this is one of the areas that a lot of people find confusing so I'm going to make it super simple for you next we're going to talk about calling apis I've seen a lot of bad code when it comes to calling apis a lot of repetition so in this section I'm going to show you a very cool technique for calling apis we'll also talk about some other concerns such as loading indicators and caching the following section is about testing again I've seen a lot of bad practices when it comes to testing a lot of people blindly write tests and feel proud but you need to learn how to rate good tests not just tests so in this section I will show you the proper way to test Redux code finally in the last section we'll talk about integrating Redux into your reactant applications I'm going to show you both the Old and the new way of connecting your components to a Redux store so there's a lot we're going to cover and by the end of this course you're going to master Redux that's my promise to you so I'll see you in the next section Redux is built on top of functional programming principles which is foreign to a lot of developers if you have tried Redux I'm very confused that's probably because you didn't have a good background in functional programming so in this section we're going to cover the essential functional programming Concepts I highly encourage you to watch this section to the end because understanding these Concepts is crucial to build Redux applications so let's jump in and get started so what is functional programming well functional programming is one of the many programming paradigms or styles of programming you have probably heard of objectoriented programming that's another popular programming Paradigm or style of programming each of these paradigms has certain rules about how you should structure your code to solve problems functional programming was invented in the 1950s but it has become quite trendy over the past few years in a nutshell functional programming is about decomposing a problem into a bunch of small and reusable functions that take some input and return a result they don't mutate or change data with this structure we can compose these functions to build more complex functions now what are the benefits well these small functions tend to be more concise easier to debug easier to test and more scalable because we can run many function calls in parallel and take advantage of multiple cores of a CPU so these are the reasons why functional programming has gained a lot of popular already over the past few years now there are languages that are specifically designed for functional programming such as closure and Haskell JavaScript is a multiparadigm programming language it's not a pure functional language so it has some caveats that you need to be aware of but we can still apply functional programming principles in JavaScript and that's what I'm going to show you throughout the rest of this section alright our first lesson here is going to be a JavaScript refresher about functions chances are you know what I'm gonna show you in this lesson so please be patient with me I want to make sure you've got the fundamentals right before we move on to more complex topics so in JavaScript functions are first class citizens which means we can treat them just like any other variables we can assign them to a variable we can pass them as arguments and return them from other functions let me show you so in our starter project I'm going to write all the code in this file index.js so let's declare a function called say hello that returns and string hello world as always now let's declare a variable call FN we can set this to a number or a Boolean or a string but we can also set it to a function say hello note that I'm not calling this function because if we call it we get its return value which is a string we don't want to call the function we simply want to pass a reference to it so functions are firstclass citizens in JavaScript we can treat them like any other type of objects nothing special about them okay now FN is an alias for say hello so we can call it just like calling the say hello function the result is exactly the same we'll get a string back okay now we can also pass a function as an argument to another function so let's declare another function called grid which takes a function for generating a message now here we can do a concept.log and pass the return value of this function so our grid function takes a function as a parameter and calls it over here okay now we can call grid and pass a reference to the say hello function once again I'm not calling this function I'm simply passing a reference to it okay so in JavaScript we can assign a function to a variable we can pass it as an argument we can also return it from another function so let's get rid of this code in our say hello function instead of returning a string we can return a function in this case an anonymous function because this function does not have a name now inside this function we're going to return hello world with this structure if we call say hello we're going to get a function back okay that is this Anonymous function over here now we can call this function and get our message now you might be wondering what is the purpose of this why do we want to return a function here instead of a regular string well this is a very powerful technique and it has a lot of applications in the real world you're going to see that soon all I want you to understand now is that in JavaScript functions are first class citizens we can treat them like any other variables foreign in the last lesson you learned that in JavaScript and other functional programming languages we can pass a function as an argument and return it now in this example these two functions create and say hello these functions have a special name in functional programming they're called higher order functions so a higher order function is a function that takes a function as an argument or returns it or both so instead of working on strings numbers or booleans it goes higher to operate on functions this is the reason why we call them higher order functions the chances are you have worked with these higher order functions before without being aware of it let me show you so I'm going to declare an array of numbers one two three now we can call numbers.map map is an example of a higher order function because it takes a function as an argument so here we can pass a function like this number goes to number times two so we take each number and multiply it by two another example of a higher order function in JavaScript is the set timeout function so we can call set timeout here we should pass a function as an argument let's say we want to do a console.log of hello after one second so set timeout is a higher order function because it takes a function as an argument foreign functional programming is to write a bunch of small and reusable functions and then compose them to build more complex functions for solving realworld problems here's a real example let's say we have a variable called input and we set it to JavaScript now let's add some padding around this let's say we want to get the input trim it and then wrap it inside a div element so with declare another variable here we add the opening element next we add our trimmed input and finally the closing element not bad it works this is a nonfunctional style of code now let me show you how to solve this problem using functional programming techniques so what are the two steps that we need to follow here first we need to trim the string and then we need to wrap it inside a div element so we can Implement each step using a small reusable function so I can declare a function called trim that takes a string and Returns the trimmed string okay here I'm using const because I don't want to reassign this function okay now similarly we can create another function wrap and div that takes a string it doesn't care if the string is trimmed or not it only wraps the string inside a div element so here we can add an expression like this div plus SDR plus slash Dev or we can use a template string that is cleaner and more concise so instead of using quotes we use the back the character and here we Define a template so we add our div element now in the middle we want to render the string dynamically so we add a dollar sign and wrap it with braces and with this we can render this dynamically okay so now we have two small and reusable functions these functions as you can tell are very easy to test all we have to do is to give them an input and then observe the result very simple now what do we want to do here we have this input right we want to trim it first so we call the trim function and pass the input the trim function is going to return the trim string so we can pass that as an argument to our second function wrap and div there you go so we get the result and this is what we call function composition in functional programming now we could take this to the next level we can also create another function for converting a string to lowercase so two lowercase once again this function takes a string and returns the string and lowercase now we can take the output of the trim function and pass it to two lowercase so this is another example of composition now we have a couple of tiny problems here the first problem is that we have to read this expression from right to left so we have an input then we need to trim it next we need to convert it to lowercase and then wrap it in div that's one problem the other problem is all these parenthesis here as we work with more complex problems we'll end up with so many parentheses I'm going to show you how to solve these problems in the next lesson foreign I'm going to show you how to use low Dash to simplify the code we wrote in the last video so in case you're not familiar with low Dash it's basically a very popular utility library for JavaScript it also has a package with a lot of functions for functional programming I'm going to show you how to use them in this lesson so back in our project open up a terminal window and install low Dash all right beautiful now on the top we're going to import two functions from low dash one of them is compose the other is pipe we're going to import them from low Dash slash FP as in short for functional programming so all these utility functions for functional programming are defined in this package now with these two functions we can get rid of all these unnecessary parenthesis over here let me show you so first I'm going to use the compose function we call compose and give it three arguments wrapping div to a lowercase and trim once again note that I'm not calling any of these functions I'm simply passing a reference to that so compose is another example of a higher order function because it takes a bunch of functions as arguments and returns a new function that is the composition of all these functions so it's a higher order function now we can get the return value which is a function and store it and a constant called transform then we can call transform and give it the input so with the compose function we no longer need to do this nest.function cause our code is cleaner we don't have all these parentheses polluting the code there is just one tiny problem here that is the order of our operations so once again we have to read this code from right to left to solve this problem we can use the pipe function so we call pipe and list our functions in the order we want to apply them so first we're going to trim the input then we're going to convert it to lowercase and finally we're going to wrap it in a div so we no longer need this ugly code with all these parenthesis delete good in this lesson I'm going to show you a powerful functional programming technique called curing I like what you might think this has nothing to do with food this is named after this guy Haskell Curry so back to the problem from the last video Let's extend this program and create a function for wrapping a string inside a span element so over here we create a new function wrap in Span and let me copy this code from here and then replace div with span pretty straightforward yeah there is a problem in this code we have a bit of duplication these two expressions look very similar the only difference they have is in the type of element it would be nice if we could parameterize this function so instead of wrapping span let's call it wrap and give it two parameters type and input string then instead of this man we're going to render the type okay now let's get rid of wrap and div and instead use our new function wrap finally let's log the return value of the transform function on the console save the changes so here's what we get JavaScript undefined that doesn't make sense here's Arisa this Pi function essentially builds a pipeline the output of each function ends up being the input of the next function so what is the output of the two lowercase function it's our input string in lowercase right so that gets passed to a wrap function now this function has two parameters type and input string so our input string in lowercase gets passed as the type argument and the second argument becomes undefined that is the reason why we get this result now what if you call wrap and pass div as the type of element let's save the changes back in the console we get this error expected a function because every argument to the pi function has to be a function in this case we're calling the wrap function and give it div as the type of element so this is going to return a string we cannot pass a string in the pi function because we cannot build a pipeline with a bunch of functions and a string it doesn't make sense so here's the problem you're facing we have a function with two parameters but what we need in this pipeline is a function with a single parameter and that's the problem that occurring solves let me show you so I've created a separate file called occurring let's study current and isolation and then we'll come back to our main file so let's say we have a function for adding two numbers A and B here we turn a and b curing is a technique that allows us to take a function that has an argument and convert it to a function that has a single argument so to apply querying here we get rid of B as the second parameter and instead of returning this expression we're going to return a function that takes a parameter called B and then inside this function we're going to return a plus b so when we call the add function let's say add one this is going to return a function let's call it add one so every time we call this function and give it a value it's going to add 1 to it okay now in this case we don't need to store this function in this constant we can call add one we know that this returns a function so we can call that function and pass our second argument so with current instead of separating our arguments with comma we separate them using parenthesis but what matters here is that we have a function with a single parameter now we can also rewrite this function using an error function so let's declare a function called add to now this function should take a parameter called a and return a new function so a goes to now here we should return a function that takes a parameter called B so B goes to and returns this expression so once again instead of separating our parameters using a comma Like A and B goes to a plus b we are separating them using arrows this is the result of carrying a function now let's apply this technique in our main program so the problem we have here is that the wrap function takes two parameters we want to apply current here so we end up with a function with a single parameter so to separate these parameters instead of a comma we're going to use an arrow so we don't need parenthesis because we have a single parameter type goes to string goes to this expression this is our current function now here's the interesting part when we call wrap and pass div we get a function instead of a string so we can pass that function as another step in our pipeline let's save the changes and here's the final result so we wrapped JavaScript in a div element with this new implementation we can replace div with a span or any other elements save the changes there you go so we don't have to create so many functions for creating HTML elements hey Mash here thank you for watching my Redux tutorial this tutorial you've been watching is actually the first hour of my complete Redux course that is 6 hours long so if you enjoyed this tutorial and want to learn more I highly encourage you to take the full course because it goes Way Beyond this tutorial if you enroll you will also receive a certificate of completion that you can add to your resume if you're interested I'll put the link down below another important Concept in functional programming is pure functions we say a function is pure if every time we call it n give it the same argument it always returns the same result let's look at a few examples look at this function do you think this function is pure or not it's not because every time we call it this math.random method generates a new value so the result of this function is going to change in contrast this function is pure because every time we call it and give it one we always get 2. so in pure functions we cannot use random values we cannot use the current date time because again this will change we cannot read or change Global State like Dom elements files databases and so on because if you rely on global state or change it this can affect the result of our Pure functions now you might say but Marsh how are we going to update our Dom elements or our database well in practice not everything has to be pure at least when practicing functional programming with JavaScript in Redux we have special functions called reducers we'll talk about them in the next section when building redox applications we have to make sure that our reducers are pure other functions in our application can be impure that's not the end of the world now in pure functions we cannot mutate our parameters because if we do so again the result of a pure function can change let's look at a few more examples so this function takes the H of someone and Compares it with minimum age as you can see minimum age is not defined here so it's a global variable now if you rely on This Global variable to see if someone is eligible or not the result of this function can change in the future so if somewhere else we change the minimum age from 18 to 21 this function is going to return something different to make this function pure we have to pass minimum age as a parameter so everything this function needs should be specified in its parameter list now what are the benefits of pure functions well the first benefit is that these functions are selfdocumenting because everything a function needs is clearly specified here now this makes these functions easier to test because we don't have to set some Global State prior to testing these functions also because we don't use Global state or change it we can run these functions in parallel and finally another benefit of these functions is that they're cachable for example if we call this function and give it two arguments like one and two and we know that this always returns three we can store the result in the cache and use it in the future this is useful in functions that have intensive computations so if you know for sure that they produce the same result or the same arguments we can optimize them by reading the result from a cache so these are the benefits of pure functions in the last video I told you that pure functions cannot change or mutate their arguments the concept that goes hand in hand with pure functions is immutability which basically means once we create an object we cannot change or mutate it if you want to change that object you have to take a copy first and then change that copy for example strings in JavaScript and in most programming languages are immutable so if you have a string and then try to convert it to uppercase we get a new string the original string is not affected in contrast if you have an object we can change or mutate that object directly so in JavaScript objects on arrays are not immutable and that's why I told you that JavaScript is not a pure functional programming language in pure functional languages we cannot mutate data period but in JavaScript we can mutate objects on arrays because JavaScript was not designed to be a functional language it's a multiparadigm language but we can still apply functional programming principles when writing JavaScript code now what about the cost keyword well this is a common misconception when you use const you're not creating an immutable object so we can declare book as a constant and then change its title property with const we cannot reassign book to a different object so const prevents reassignment okay now what are the benefits of immutability well the first benefit is that it makes our applications more predictable if we call a function and pass an object to it we know that object is not going to get changed so there are no surprises down the road the second benefit of immutability which is kind of specific to react and Redux kind of applications is that it makes it faster to detect changes so you know that react needs to know when the state is changed so it can trigger rerendering for example let's say we have a book object stored in the memory location 100. now if you follow immutability to change a property of this object we have to create a new object this object is going to be stored in a different location in memory let's say 200. now react can quickly tell if an object is modified because it Compares these objects by the references it's like comparing 100 with 200. this is a very fast operation in contrast if we don't use immutability react has to compare every property of an object to see if it's changed so immutability makes change detection faster and the third benefit of immutability is concurrency if we know that a function does not mutate data we know that we can safely run this function in parallel it's not going to change something in memory that's going to mess up the state of the system as a whole so doesn't mean object mutation is bad and we should always favor immutability well if you ask John Smith he would say that's exactly right but in my opinion every approach every technique has its own uses pros and cons anyone telling you that one technique is objectively good or bad in all situations is selling you something so we talked about the benefits of immutability but these benefits are not free of cost there is a potential performance cost to immutability because every time we change an object all the values should be copied to the new object however this would only be an issue if you're dealing with a large number of objects let's say several thousands or hundreds of thousands of objects if you're dealing with a few objects that's not going to be an issue another problem with immutability is that copying objects can also cause memory overhead but we have immutability libraries out there that reduce these overheads as much as possible they use a technique called structural sharing so if some values are common between two objects they are not copied across they're shared but talk about this Library soon so the bottom line is if you're building applications with Redux you should not mutate data because that's a fundamental principle in Redux outside of Redux you can do whatever you want so now that you understand what immutability is and why it's important let's see how we can practice it in JavaScript so let me show you how you can practice immutability when working with objects so here we have a personal object with a name property now if you want to update this object we are not supposed to set the name property directly we should take a copy first and then update the copy there are basically two ways to do this in JavaScript one way is to use the object that assign method with this method we can copy the content of an object to another object so as a first argument we pass an empty object then we pass our personal object so this is going to copy all the properties of this object into this empty object optionally as a third argument we can supply an object with updated properties for example if you want to change the name property yeah that here let's set this to Bob we can also add additional properties let's say we can set H to 30. now this method is going to return a new object so let's call that updated and then log it on the console so we have this object with name set to Bob and age 30. so object.assign is one way to solve this problem but there is a better way we can use the spread operator so I'm going to set up data to an empty object now here we want to copy all the properties of the person object so we type dot dot dot person this is what we call the spread operator now that we've copied all the properties of the person object we can supply any additional properties so if you want to update the name you can pass it here in this case the second name property is going to overwrite the name property that we copied from the person object okay now save the changes and here's our updated person so I personally prefer the spread operator syntax because it's more concise now one thing you need to be aware of when using the spread operator or object of assignment is that both these methods do a shallow copy so you have to be careful when working with nest.objects for example let's add an address property here address we set it to an object with two properties Country USA and City let's say San Francisco now we're copying this person and changing his name now let's see what happens if we type updated the address that City we set it to New York and then log the original person object see what happens so save the changes so our original personal object his name was John now look at his address it's updated to New York because this spread operator does a shallow copy in this case this address property is set to an object the problem we have here is that both the person and updated objects have the same address this is the same address object in memory so if you change the address through one reference like updated it will apply to the other reference to solve this problem we have to do a deep copy so let me show you first we copy all the properties of the personal object then we add the address property we set it to a new object because we don't want to use the same address object associated with our original person object okay so we set it to a new object in this object first we should copy all the properties of person that address and then if we want we can change one of its properties let's say we can change the City to New York okay now we don't hit this line over here let's save the changes so if you log the original percent you can see its address is not modified so when working with nest.objects we have to do a deep copy now as you can see this approach is a little bit verbose the more nesting we have the more variables our code is going to be this is why we have libraries specifically made for immutability we're going to talk about them later in this section oh in this lesson I'm going to show you how to practice immutability when working with arrays so here we have an array of three numbers let's look at three different scenarios adding an item to this array removing an item and updating an existing item so for adding once again we can use the object spread operator so I'm going to declare a new constant called added and set it to a new array now first we want to copy all the elements in the numbers array and then we want to add a new element at the end this is how we can achieve this if you want to put this element at the beginning we can do it like this very easy what if you want to put it at a specific position let's say just before two well first we need to find the index of two so index we set it to numbers that index of 2. now we're going to create a new array first we have to copy all the items before two to do that we use numbers the slice we given that you start index that is zero this is going to return a new array with all the elements starting from index 0 up to the element at this index but excluding this element now as I told you the slice method returns a new array so we have to spread that array otherwise we'll end up with an array of arrays okay so we copy all the items before two now we add our new item let's say four and then we need to copy all the items starting from 2 all the way to the end of the array so once again we're going to use numbers dot slice as the start index we're going to pass index now because this returns an array we have to spread that array okay let's do a console.log so cancel the log of added and here's the result 1 4 2 and 3. now what about removing well this is very easy let's say we want to remove two so we use the filter method here we pass a function so n goes to we want to return all the elements except two so n not equal to 2. this returns a new array let's store it and this constant call removed and do a console.log so 2 is gone now what about updating this is fairly easy as well so we call the map method on our numbers array here we pass a function n goes to let's say we want to replace 2 with 20. so if n equals 2 then we're going to return 20 otherwise we'll return n now if we had an array of objects here instead of just returning some number we would have to copy that object so we would have to use the spread operator to take a full copy of that object okay so let's store the result in updata and then do a console.log take a look so we replaced 2 with 20. now if you forget any of these patterns don't worry I'm going to include all the source code that I'm writing throughout this course in a separate project that should be available in the zip file that you downloaded at the beginning so let me show you what I've done here I've created a folder called functional and all the code that I've written throughout this section is available in this folder for example we have examples of current we have patterns for updating objects so we can always come back to the source code if you forget something foreign does not prevent object mutations because it's not a pure functional programming language to work around this we have to use libraries that offer real immutable data structures there are tons of laborers out there but the most popular options are immutable imer and Mari immutable or immutable JS is developed by Facebook and it's a very popular Library it gives you a bunch of immutable data structures such as a map or a list but there are a number of problems with this Library I'm going to talk about them in the next video Emer is a neural library that is developed by the creator of mobx it's becoming very trendy and a lot of people including myself love it unlike emulable.js email doesn't give you any immutable data structures so it allows you to work with the plain old JavaScript objects now Mari honestly I've never worked with it but I've heard it's popular at the end of the day the library you choose is entirely up to you these are just tools different people love different tools next I'm going to show you how to work with immutable Js in this lesson I'm going to give you a quick tour of immutable JS so here we have a basic JavaScript code we have a book object with a title property we have a function called publish it gets a book object and set its published properties true next we call this function and then log this book on the console pretty straightforward now when practicing functional programming we don't want to muted objects so this is where we can use immutable.js immutable JS provides a bunch of immutable data structures so instead of using a plain JavaScript object we're going to use one of the data structures provided by immutable.js so first open up your terminal window and run npm install immutable okay so I'm using immutable version 4.0 now back to this code on the top we need to import the map function from the immutable Library with this map function we can create a map or hash map that's like a regular JavaScript object it's a container for key value pairs but this map object that we get from this library is immutable so now instead of using this plain JavaScript object we're going to call the map function to get a map object now let me temporarily comment out this code so we create a map object and log it on the console take a look so this is what we get this is not a regular book object it has a bunch of weird properties like size root owner ID and so on so this is the first problem with this Library if you want to log the title of a book we cannot access the title property using the dot or bracket notation we have to call the get method get title save the changes there you go so the first problem of this library is that we have to learn a whole new API now this API is not that complex we can learn it pretty quickly but in my opinion the main problem is that it's hard to integrate this with other libraries that expect plain JavaScript objects every time we need to work with plain JavaScript objects we have to call the 2js method so this returns a plain JavaScript object now let's bring this code back in so when publishing a book you want to set its published property to true to do this using immutable we have to call the set method so set is published to true now this is not going to modify the original book object it's going to return a new object because all these map objects are immutable like strings in JavaScript so here we have to return the result we've published a book and then we can reassign the book variable and then we can convert it to a plain JavaScript object and log it on the console take a look so here's the result so here's immutable.js in action as you can see once you start using it it gets spread out everywhere in your code base everywhere you have to use these Getters and Setters or convert immutable data structures to plane JavaScript objects that is why I personally prefer immer we're going to talk about that next foreign ER as you can see on npm Trends Emer has gained a lot of popularity and is almost as popular as immutable JS so this Orange Line represents immutable and the blue line represents imma so in our terminal window let's install imer alright now we have the same code that we had in the last video so here we are mutating this book object we don't want to do that let's see how we can solve this problem using immer so on the top we import the prettiest function from imer make sure to import it from Emer before I was recording this video I made a mistake and imported it from immutable the immutable Library does not have this produce function okay so in our polish function we are not going to mutate the book object instead we're going to call the prettiest function and give it two arguments the first argument is our book object over here this is what we call the inertial state then we're going to pass a function that specifies our mutations so this function is going to take a book object to differentiate let's call that draft book that goes to a block of code now in this block we can write mutating code so we can write draft book dot is published equals true however when following this pattern this book object is not going to get modified because this draft book is actually a proxy that records all the changes we are making to this initial book object so this produce function is going to take a copy of this object and apply all the changes we are doing here now what is beautiful about Emer is that our code looks familiar to us so we are writing code as if we are mutating an object but our object is not going to get mutated this is much better than using the spread operator because you saw that the spread operator can get kind of nasty when we're dealing with nested objects we have to do a lot of cloning with Mr we don't have to worry about any of this we simply follow this pattern and write code in a familiar style now this produce function is going to return the updated object so we're going to return it from our publish function so this publish takes a book and returns a new book let's call that updated and then we can log both these objects on the console take a look so here's our original book object as you can see it's not modified and here's the updated book object now that you have learned the fundamentals of functional programming you're ready to learn Redux so in this section we'll be talking about the Core Concepts in Redux we'll start off by talking about the Redux architecture then I'll show you the steps that you need to follow to build an application with Redux you will see all these steps in action using a real project so let's jump in and get started oh earlier I told you that with Redux we store our application State inside a single JavaScript object called the store this object is the single source of Truth for our application State and is accessible by all parts of the UI for example in an ecommerce app our store can have properties like the list of categories products shopping cart the current user and so on what we have in the store is entirely up to us Redux has no opinion about it we can use arrays objects numbers booleans essentially anything that represents the data that our application needs to function now we cannot directly modify or mutate the store because Redux is built on top of functional programming principles in the last section I told you that in functional programming we do not mutate state so we cannot write code like this because our store is an immutable object so to update it we should create a function that takes the store as an argument and Returns the updated store so in this function we should either use the spread operator to create a copy of the store or use one of the immutability libraries that we talked about in the last section like immutable JS or immer now this function is called a reducer I know the name is a bit weird and a lot of people have complained about it but let's not worry about it for now all that matters is that a reducer is a function that takes the current instance of the store and Returns the updated store now here's a question how does the reducer know what properties in the store it should update should it update the shopping cart or the current user or the list of products so we need another building block called an action an action is just a plain JavaScript object that describes what just happened examples are the user logged in or logged out or added an item to a shopping cart and so on these are the events that can happen in our application so we should give this reducer an action as the second parameter now based on the type of the action the reducer will know what properties of the state to update now doesn't mean that all the updates are going to happen inside a single function or a single reducer no this is just a simplified example in a real app our store can have many slices for example here we have four slices categories products the shopping cart and the current user each reducer will be responsible for updating a specific slice of the store as a metaphor think of an organization with multiple departments each department should have a manager that is responsible for their own department they don't have to worry about the other departments so these are the three building blocks and Redux applications we have the store which is a single JavaScript object that includes our application State we have actions which are plain JavaScript objects that represent what just happened it would be nicer if they were called events because in programming an event represents what just happened we also have one or more reducers each responsible for updating a slice of the store you can think of these reducers as event handlers or processors I think the reason they are not called event handlers is that could often even handlers are associated with object mutation which is something we don't do in Redux users are pure functions so they don't touch Global State they don't mutate their arguments and they don't have any side effects they just get the current store instance and return the updated one now how do these building blocks work together well when the user performs an action let's say they add an item to their shopping cart we create an action object and dispatch it the store object has a dispatch method that takes an action it will then forward this action to the reducer so we do not call the reducer directly we just work with the store the store is in charge of calling the reducer okay the reducer computes the new state and returns it next the store will set the state internally and then notify the UI components about the update these UI components will then pull out the updated data and refresh themselves you're going to see all these interactions in a few minutes now you might be wondering why redox is designed this way why do we need this building blocks why do we need to dispatch actions well this dispatch is like an entry point to our store so by dispatching actions we are essentially sending every action through the same entry point so we have a central place where we can control what should happen every time the user performs an action this allows us to do some really cool things for example we can log every action this is how Redux Dev tools works it shows every action that has been dispatched and how this date has changed we can also easily Implement undo and redo mechanisms so that's the idea over the next few videos I'm going to show you all these building blocks in action foreign now we're ready to build our first Redux application we're going to build a bug Tracker app using Redux so on the UI we're going to have a text box for entering information about a bug we just discovered we can add this block to a list then we can remove a bug we can mark it as resolved we can change the status to in progress and so on now in this section we're not going to spend any time on the UI because Redux is about State Management so we want to focus on Redux we don't want to get distracted with all the complexities of building user interfaces we'll talk about the UI later when we talk about integrating Redux with react okay so now let's look at the four steps that you need to follow when you want to build a Redux application first you need to design the store you need to decide what you want to keep in the store next you need to define the actions what are the actions that the user can perform in this application next you create one or more reducers these reducers take an action and return the updated State and finally you need to set up the store based on your reducer over the next few lessons we're going to look at each of these steps in detail now before we get started we need to add Redux to our project so in the terminal window we type npm install Redux I'm going to use the latest version which is version 4.0 the chances are in the future there is a newer version available what I'm going to show you in this course I have confidence that's going to work with the future versions of Redux but to be on the safe side I highly encourage you to use the same version I'm using here so version 4.0 all right Redux is installed so next we'll talk about designing the store the first step in building a Redux application is designing the store we need to decide what we want to keep in the store so for a buck tracking application like this what kind of state do we need we need to maintain the list of books so this is the simplest structure we can come up with we can have an array of bug objects every bug object can have properties like ID description and result which is initially set to false this is the simplest structure we can come up with now in a more real life application our store would probably look like this so instead of an array we're going to have an object with multiple properties so this object has a property called Bugs this is where we have our list of bugs we can have another property called current user this can initially be a null when the user logs in we're going to set this to an object so in this example our store has two slices one slice for the list of bugs and another slice for the current user and that means we're going to have two different reducers now in this section we don't want to worry about all these little details we want to focus on the simple structure that allows us to study Redux and see all its building blocks in action so we're going to go with this structure later in the course as our application develops we can refactor this structure and turn it into something more like this so we have completed the first step to build a Redux application now the second step is defining the actions what are some of the actions that a user can perform in our bug tracking application well they can add a bug they can Market bug as resolved and delete a bug now in a real live application we could have many other types of actions for example the user can change the status of a book they can filter the list of books they can change the sort order and so on for now let's just focus on these actions earlier I told you that an action is just a plain JavaScript object that describes what just happened here's an example you have an object with two properties type and description type is the only property that Redux expects in your action objects so if you don't have this type property Redux is going to complain now here we're using a string as the value of the type property but you can use any other type that is serializable which means we can store it on the disk why because Redux is built on this principle that we should be able to store the state of our application on disk and reload from it later strengths are serializable we could also use a number here but the problem with numbers is that they are not descriptive we don't want to write code and compare the type of an action with let's say 124. someone else reading our code would wonder what is 124 they are not descriptive also when you look at the action history in Redux Dev tools we don't want to see a bunch of numbers you want to see a description of what has happened that is why we use strings now here I've used uppercase letters and I've separated these words using an underscore this is a common convention in Redux code but you don't have to follow it if you don't want to Redux as the library doesn't care you can use any naming convention that you prefer I personally prefer a different convention like bug added so I'm using a past tense because an action represents what just happened now here we have another property called description so this is the data associated with this action when the user types something in the text box to add a bug you store that value in the description property in a real application we could have a complex form with many fields the user can specify who reported this bug what is the severity and so on in that case we will store all those extra attributes in this object now earlier I told you that Redux was inspired by flux which is an architectural pattern and a library built by Facebook in flux actions have a slightly different structure so they have two properties type and payload payload is an object that contains all the data about an action you don't have to follow this structure in Redux because Redux doesn't care but I personally prefer this structure because it gives my actions a common and consistent structure let's look at another example here we have an action for removing a bug so the type is bug removed and in the payload we have the ID of the bug what is important here is that the payload contains the minimum information we need about an action so if you're removing a bug we don't need to store the Box description or the date that occurred and so on all we need to identify a bug is its ID so now that we have an idea about our actions next we're going to build our reducer now we're ready to create our first reducer so here in the source folder let's add a new file called reducer.js as I told you before a reducer is a function with two parameters the current state and an action the job of this reducer is to return the new state based on this action so here's an example if action.type equals bug added then you're going to return the new state the earlier we decided to use a simple array to represent our store an array of books so if the user adds a book we want to return a new array in this array first we want to copy all the bugs in the current state so here we are using the spread operator and then we add a new bug object here this object should have a few properties like ID description and result so we set description to action that payload the description and we said resolved to false now for the ID we need to have some kind of counter so I'm going to declare a variable here last ID and initialize it to zero every time we add a book we're going to increment last ID first and then use it as the value of the ID property there is something I want you to pay attention to here the payload of the action should contain the minimum information we need to update our system so in the case of adding a bug we don't want to pass the ID or result properties because the minimum information we need for adding a bug is the description of the bug so everything else should be computed here in the reducer because this is where we Implement our business logic okay also here I'm using the spread operator to copy this array we don't have to do this we can use one of the immutability libraries like immutable JS or immer we'll use them later in the course for now I just want to show you the plain Redux code because that's what you see in most projects so here's a case for adding a book so after a return statement we can have else if action the type equals bug removed now here we want to return a new array that contains all the bugs except the bug with the given ID so I showed you how to do this in the last section we basically get the existing array and filter it so here we pass a function we get a bug we want to return all bugs except the bug with the given ID we can pick that from action that payload.id simple as that now what if the type of our action is neither of this we should return the current state this is very important because if you make a mistake if we dispatch an action that doesn't exist we don't want our system to blow up we want to return the current state okay we're almost done the only part that is missing is the initial state so when we start our application the store is initially undefined Redux is going to call our reducer and pass undefined as the value of the state in that case we want to return the initial State we don't want to return undefined or null now what is the initial State here that is an empty array so we can set that using a default argument over here so when we start our application Redux is going to call our reducer and pass undefined as the value of the state in that case we're going to reset the state to an empty array okay now in this example I'm using an if and else to implement this logic we could also use a switch and case statement Redux doesn't care it's entirely up to you some people don't like switch on case if you prefer even else go for it but let me show you how to implement this logic using a switch on case so let's switch on action the type here we're going to have two cases one for bug added and another for bug removed now for each case I'm going to copy the code from here so here's our return statement cut I'm going to add it here and finally for bug removed we have another return statement very easy we also need a default case if the action type is none of these values in that case we want to return the current state so here's our final implementation now one thing I need to emphasize here is that this reducer is a pure function we talked about pure functions in the last section A pure function is a function that if we call it multiple times and give it the same argument it always returns the same result and is free of side effects so in a pure function we are not going to touch Dom elements we're not going to work with any Global State we're not going to make API calls because all these operations can change the state of our system as a whole in that case if we call this pure function multiple times we may not get the same result so pure function should be a small function in an isolated world all it needs should be passed as arguments these are the only dependencies of a pure function so this reducer this pure function takes these two arguments and Returns the new state that's all it does now this properties make it really easy to test this reducer we don't have to set some Global State before calling this function for testing so in Redux reducers have to be pure now you might be wondering how we're going to make API calls we'll talk about that later in the course for now don't worry about that foreign now that we have a reducer we are ready to create our store based on this reducer so in the source folder let's add a new file store.js now here first we should import the create store function from Redux next we call it now here we should pass our reducer so that means we should go to our reducer file and Export this function I would prefer to export it as a default object so we can easily import it in other modules so save the changes now we can import reducer from the current folder reduce our module now if we didn't do a default export we would have to wrap this in braces with the default export we don't have to do that so this is the only object that is exported from this module okay so we pass our reducer as an argument and note that I'm not calling it I'm just passing a function reference so create store is another example of a higher order function because it takes a function as an argument right now this returns a store object so finally we need to export it so we can bring it in our main application we'll do that next so we created the store now let's use it so in index.js first we should import the store from the store module in the current folder note that I'm not wrapping this in braces because I exported the store as a default object okay so here's our store now before going any further let's just log this on the console and see what it really looks like so save now there you go so a store is an object with these properties we have a method for dispatching actions we have a method for subscribing to the store so when you subscribe to the store we get notified every time the state of the store changes this is used by the UI layer you're going to see that very soon we also have a method for getting the current state of the store we also have replace reducer and symbol of observable these are Advanced topics we'll talk about them in the future now what is interesting here is that we do not have a method for setting the state of the store we only have get State not set State this is a fundamental principle in Redux so to change the state of the store we have to dispatch on action with this architecture we're essentially sending every action through the same entry point that is the beauty of Redux so back to our code let's call get State and look at the current state of the store so save so initially we have an empty array because we haven't added any bugs yet so let's dispatch an action so before console.log we're going to call store.dispatch and pass an action this action should have two properties right one is type which was set to bug added the other is payload which is an object with a property called description and we can set this to bug one so in a real application when the user clicks on the add button we're going to dispatch an action now save the changes there you go so in this array we have a bug object with ID set to one here's a description and it's not resolved now let's dispatch an action for removing this bug so right after we got a dispatch another action the type of this action is going to be bug removed and in the payload we just want to pass the ID of this action we don't need anything else so save the changes now our store is back to initial state all right now let's see how we can subscribe to the store so before dispatching an action I'm going to call the Subscribe method here we should pass a function this function gets called every time the state of the store gets changed so here we can log store change and as the second argument we can get the current state of the store so store that get state this is basically something we do in the UI layer so whenever the state of the store changes we want to refresh the UI if you're building an application with vanilla JavaScript or jQuery this is where we're going to work with our Dom elements we're going to refresh the view if you're building an application with react we're going to rerender now we'll talk about that in the future for now what you need to understand is that UI components should subscribe to the store so they get notified when the state of the store changes Okay so let's save the changes back in the browser so you can see our store changed twice this is the first time so we got a new bug and then we removed that bug now this subscribe method returns a function for unsubscribing from the store so let's store that over here unsubscribe this is important because it is possible that the user navigates away from the current page and in the new page we're not going to have that UI component so we don't want to have a subscription to the store because this subscriptions can create memory leaks so if the current UI component is not going to be visible we should unsubscribe from the store let me simulate this so let's say we added a bug now I'm going to call unsubscribe so the second time we are dispatching an action we are not going to get notified save the changes and take a look we only have one message that indicates that the store is changed the second time the store got changed we did not get notified because we had unsubscribed before you have seen all the building blocks of Redux actions reducers and the store let me walk you through the Redux workflow one more time so when we dispatch an action our store is going to call our reducer it's going to give it the current state and the action that we dispatched based on the type of the action we're going to get the new state so this dispatch method if you look at its source code it actually looks like this it calls the reducer gives it the current state and the action that we dispatched and then it will get the new state which is going to store here so this is the internal state of the store okay then it's going to notify the subscribers now in the next section I'm going to show you how to build Redux from scratch so you're going to code all of this but before we get there I need to emphasize that Redux is actually a very small and simple Library it has a small API it has a small footprint earlier you saw that the store object has only a few methods that you have to learn about get State dispatch and subscribe so there are very few moving Parts in Redux however when building real world applications with Redux we often introduce additional building blocks that make our code more maintainable for example one problem we have in this implementation is that we have hardcoded this string in two places one is here where we are dispatching an action the other is in a reducer where we're handling this action what if tomorrow we decide to rename this from bug added to bug creator then there are multiple places in our application that we have to update and if we don't do so we're going to create a bug so let me show you how to fix this problem we're going to add a new file called action types we're going to store that string in a single place and use it in multiple places so here we're going to export a constant called Bug added and set it to that string that magic string similarly we can create another constant called Bug removed this is the only place where we're using the string literal if tomorrow we want to change it this is the only place we have to update now we go to our reducer and replace the string with the constant that we just exported so on the top we're going to import we can use a named import so we can import bug added and Bug removed from the action types module that's one way the other way is if you're dealing with multiple action types we don't want to pollute this import statement so we can import everything as actions now this actions is going to be an object with properties like bug added and Bug remove let me show you so we're going to replace bug added with actions dot look we have these two properties Bugatti similarly we're going to replace bug removed with actions that bug remove well actually I should have used bug removed so let's rename this to bug removed okay good now finally in our index.js when dispatching an action we're going to use that constant one more time so let's import everything as actions from action types and then we're going to set the type to actions Dot Bugatti as simple as that the other problem we have in this implementation is how we dispatch an action as you can see dispatching an action is not easy we have to type the entire structure of this object now what if there are multiple places where we want to dispatch the same action then we have to repeat all this structure in multiple places to improve this we can create a function that would create this action object for us we call that an action Creator so in our project in the source folder let's add a new file we can call it actions or action creators I prefer actions but that's entirely up to you so here you want to create a function called Bug added which takes a description and then returns this object structure over here so let's cut that and then paste it here pretty simple right now we can export this and import it in our main module so in this case we don't need this import statement anymore because we need action types only when creating an action so I cut that line and paste it here okay this is where we're using our constant now in the index module I'm going to import bug added from the actions module so here we have a named export because bug added is not a default export okay now when dispatching an action we simply call this function bug added and give it the description this makes our code a lot cleaner and if you want to dispatch the same action from multiple places we simply have to call this function we don't have to worry about the structure of this action object if tomorrow we want to change the structure of this action there is a single place that we have to update okay so this is why we use action creators now I personally prefer to create my action creators using an arrow function because they have a more concise syntax let me show you so let me comment this out now you're going to export a constant called Bug added and set it to an error function this function should take description as a parameter and return an object so here we cannot use curly braces because these braces indicate a block of code but here you want to return an object so we should wrap this in parenthesis now this is the action object that we want to return so it should have these two properties type and payload I copy these paste them here and then remove the comet so this is another way to create an action Creator now what syntax you use is internally up to you here's an exercise for you I want you to implement resolving a bug so we should be able to create a bug and then Mark it as resolved spend five to ten minutes on this exercise and then come back see my solution to implement a new feature with Redux you should always think about your actions first and then your reducer so we want to define a new action or a new capability or a new event that can happen in our application that is resolving a bug so first we go to our action types module and Define a new constant called Bug resolved once again I'm using the past tense here to represent an event that just happened so we set it to bug result next we should create an action creator so in the actions module we export a new constant called Bug resolved and set it to a function now what pieces of information do we need for resolving a bug at a minimum we need to know the idea of the bug so it is going to be a parameter until you're going to return an object so we wrap that object in parenthesis now the type of this object is going to be actions.bug resolved note that the benefit of importing the actions using the syntax is that every time we Define a new action every time we Define a new constant we can simply use it in this module in contrast if we used named Imports let's say bug added from action types every time we Define a new action type we have to come back and add that new action type here so this is a simple tip we import everything as one object now we set the type and then the payload here we can simply add the idea of this action now in modern JavaScript if the name of a property and the value are the same we can use a shorthand syntax so we get rid of it and by the way I noticed that in the last video I made a mistake a hardcoded bug one here but we should set the description property to the description argument so we save the description or use the shorthand syntax all right we're done with our action now we should change our reducer so it can handle our new action so let's go to reducer.js here we want to add a new case actions dot bug resolved see that's another benefit of importing all the actions as a single object I didn't have to go on top of the file and import our new action Okay so when a bug is resolved we want to update an existing bug object I talked about this pattern in the last section so basically you want to use state.map here we pass a function it takes a bug now if the idea of this book does not equal action that payload.id if this condition is true we want to return this bug as is otherwise we want to take a copy of this bug and modify it this is updating in an immutable way so here we want to return a new object first we want to copy all the properties of the bug and then we want to set the result property to True okay let me put this on a new line so you can see clarity so using the map method we're mapping this array to a new array if the idea of the book is not equal to the idea of the bug that we have resolved we're going to return that bug otherwise you're going to return a new bug object with all the properties of the existing bug but with the updated resolved property as you can see writing code like this is a little bit confusing and complex that is why we should use libraries like immutable JS or immer this is one of the main reasons that a lot of people find Redux confusing but don't worry later in the course I'm going to show you the modern way of writing Redux code that is very clean and concise for now I want to use the traditional way because that's what you say in most projects so a reducer is now capable of handling this new action or this new event with that we can go to our index module and after creating a bug we want to resolve it so store the dispatch we should import our new action Creator bug resolved then we call it over here bug resolved give it the ID and we're done save the changes so take a look in this array we have one bug that is resolved beautiful hey mosh here thank you for watching my Redux tutorial as I told you before this tutorial is the first hour of my complete Redux course that is 6 hours long and covers a lot more so if you want to learn more I highly encourage you to enroll in my complete redox course you will also receive a certificate of completion that you can add to your resume if you're interested up with the link down below thank you for watching and we hope to see you again please support me by liking this video and sharing it with others and be sure to subscribe for more videos like this
