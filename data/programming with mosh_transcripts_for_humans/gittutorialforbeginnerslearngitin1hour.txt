With timestamps:

00:01 - In this course, you're going to learn
everything you need to know to get
00:03 - started with Git.
If you're an absolute beginner or if you
00:06 - have been using git for a while but
never really understood how git works
00:10 - this tutorial is for you you're going to
learn all the fundamental concepts
00:13 - as well as the essential commands that
you need to know these are the commands
00:16 - that you would use
every day at work so by the end of this
00:19 - tutorial you will have a good grasp of
the basics and you'll be ready to learn
00:22 - more about the intermediate to advanced
concepts
00:25 - i'm adani and i'm super excited to be
your instructor if you're new here
00:29 - be sure to subscribe as i upload new
tutorials every week
00:32 - now let's jump in and get started
00:37 - so what is git and why is it so popular
git is the most popular version control
00:42 - system in the world
a version control system records the
00:45 - changes made to our code over time
in a special database called repository
00:50 - we can look at our project history and
see
00:52 - who has made what changes when and why
and if we screw something up we can
00:57 - easily revert our project back to an
earlier state
01:00 - without a version control system we'll
have to constantly store
01:03 - copies of the entire project in various
folders
01:06 - this is very slow and doesn't scale at
all especially if multiple people have
01:10 - to work on the same project
you would have to constantly toss around
01:14 - the latest code via email or some other
mechanisms
01:17 - and then manually merge the changes so
in a nutshell
01:20 - with a version control system we can
track our project history
01:24 - and work together now version control
systems fall into two categories
01:29 - centralized and distributed in a
centralized system
01:33 - all team members connect to a central
server to get the latest copy of the
01:37 - code
and to share their changes with others
01:40 - subversion and microsoft team foundation
server
01:42 - are examples of centralized version
control systems
01:46 - the problem with the centralized
architecture is the single point of
01:49 - failure
if the server goes offline we cannot
01:52 - collaborate or save snapshots of our
project
01:55 - so we have to wait until the server
comes back online
01:58 - in distributed systems we don't have
these problems every team member
02:02 - has a copy of the project with its
history on their machine
02:05 - so we can save snapshots of our project
locally on our machine
02:09 - if the central server is offline we can
synchronize our work directly with
02:13 - others
git and mercurial are examples of
02:16 - distributed version control systems
out of all these git is the most popular
02:21 - version control system in the world
because it's free open source super fast
02:25 - and scalable
operations like branching and merging
02:28 - are slow and painful in
other version control systems like
02:31 - subversion or tfs
but they're very fast and git we'll talk
02:35 - about this later
so git is almost everywhere more than 90
02:39 - of software projects in the world use
get
02:41 - that's why almost every job description
for software developer mentions git
02:46 - so if you're looking for a job as a
software developer git is one of the
02:50 - skills you must have on your resume
you should know it inside out you should
02:53 - know how it works and how to use it to
track your project history
02:57 - and collaborate with others effectively
and that's exactly what you're going to
03:01 - learn in this course
03:08 - let's talk about various ways to use git
we can use git on the command line
03:12 - so we open a terminal or command prompt
window to execute git commands
03:16 - this is the fastest and sometimes the
easiest way to get the job done
03:21 - that's why a lot of people use the
command line now if you don't like the
03:24 - command line
well you're in luck because most modern
03:27 - code editors on ides have built-in
support for basic git features
03:32 - for example in vs code we have this
source control panel which gives
03:35 - us the essential git features there are
also extensions available for bringing
03:39 - additional git features for vs code the
most
03:42 - popular extension is gitlands it brings
a ton of git features in vs code
03:47 - there are also graphical user interfaces
specifically made for using git
03:52 - here on the git website you can find the
complete list of these tools for
03:55 - different platforms
we have tools for windows mac linux
03:59 - android and ios out of all these the two
most popular tools are git kraken
04:04 - and sourcetree git kraken is my personal
favorite gui tool for git
04:09 - it's beautifully designed it works
across different platforms
04:12 - and it integrates with other git
cracking products such as get cracking
04:16 - boards for issue tracking
and git cracking timelines for project
04:20 - management it's free for open source
projects
04:22 - but for commercial projects you have to
pay an annual fee
04:26 - just to let you know i'm not an
affiliate of git cracking i'm just a fan
04:29 - the other option is sourcetree it's
completely free
04:32 - but it's only available for windows and
mac so if you're a linux user
04:36 - you have to use git kraken or another
gui tool in this course
04:40 - we'll be spending most of our time on
the command line for a couple of reasons
04:44 - the first reason is that pretty much all
of these gui tools have some limitations
04:48 - they support the git commands that
people use most of the time
04:51 - so even if you want to use a gui tool
there are times you would have to roll
04:55 - up your sleeves
and get back to the command line to get
04:57 - the job done the other reason
is that the command line is always
05:01 - available but there are situations where
a gui tool may not be available to you
05:05 - you might connect to a server remotely
and you may not have permission to
05:09 - install a gui tool if you don't know how
to use the command line
05:12 - then you're stuck in practice a lot of
people including myself
05:16 - use both the command line and a gui tool
and that's what i'm going to show you in
05:19 - this course
there are times that it really makes
05:21 - sense to use a gui tool and not the
command line
05:24 - but there are other times that using the
command line is faster and easier so
05:27 - we'll use the command line
at the end of the day you should use the
05:30 - right tool for the job
don't be like this guy you probably know
05:34 - him our popular
superstar developer called john smith he
05:38 - thinks he's better than everyone else
because he does
05:40 - everything in the command line he never
uses a gui tool and he looks down at
05:44 - people who do
well let him think whatever he wants if
05:47 - that's what makes him happy
who cares so we'll be spending most of
05:51 - our time on the command line
but when it makes sense to use a gui
05:54 - tool i'll be showing you examples in vs
code and git kraken
05:57 - because those are the most popular tools
now if you have never worked with a
06:01 - command line before
don't worry i'm going to hold your hand
06:04 - and teach you everything step by step
it's a lot easier than you think so next
06:08 - we're going to install git
06:12 - all right let's see if you have git on
your machine or not and if yes
06:15 - what version you have installed to do
this you have to open a terminal or a
06:20 - command prompt window
if you're on mac press command and space
06:23 - and then type terminal
if you're on windows click the search
06:26 - icon on the bottom navigation bar
and type cmd so here's my terminal or
06:32 - console window
your terminal window might look
06:34 - different it doesn't matter this is
where we're going to execute git
06:37 - commands
so let's look at the version of git on
06:40 - this machine we type git
dash dash version so in this machine i'm
06:44 - using git
version 2.19.2 but the latest version
06:49 - at the time of recording this video is
2.27.0
06:53 - so i highly encourage you to download
and install the latest version
06:56 - just head over to git scm.com download
over here you can find instructions for
07:02 - installing git on different operating
systems
07:05 - it's really easy you're not going to
have any problems now if you're on
07:08 - windows
once you install git you're going to get
07:11 - this application called
git bash which is short for born again
07:15 - shell
this is basically a command prompt
07:17 - window like this one over here
but it emulates unix or linux
07:21 - environments so throughout this course
i encourage you to use git bash instead
07:25 - of the built-in command prompt window
so what you see on the screen looks
07:29 - closer to what i'm going to show you in
this course
07:31 - so go ahead and install git in the next
lesson i'm going to show you how to
07:34 - customize our git
environment
07:40 - the first time we use git we have to
specify a few configuration settings
07:44 - we have to specify our name email
default editor
07:48 - and how it should handle line endings we
can specify this configuration settings
07:53 - at three different levels
at the very top we have the system level
07:57 - the settings that we have here
apply to all users of the current
08:00 - computer below this level we have the
global level
08:03 - the settings here apply to all
repositories of the current user
08:07 - and below this level we have the local
level the settings here apply to the
08:11 - current repository
or the repository in the current folder
08:14 - so we can have different settings for
different repositories or different
08:17 - projects
so here in the terminal window we type
08:20 - git config
then we type dash dash global to specify
08:25 - the
level at which we are defining these
08:27 - settings next we should specify the
setting we want to configure
08:31 - so user that name here we type
double quotes and type our name now the
08:38 - reason we're adding double quotes
is because we have a space in this value
08:42 - okay
so that was the first setting once again
08:45 - git config
dash global this time we're going to set
08:50 - user.email
now because we don't have a space in
08:53 - emails here we don't need double quotes
so let's add our email
08:59 - all right next fill it to specify our
default editor
09:03 - if you don't set this on mac by default
git is going to use
09:06 - vim which is a scary editor a lot of
people are freaked out by it
09:10 - in this course i'm going to use visual
studio code or vs code
09:14 - you can use any editor that you prefer
but if you want to follow along with me
09:17 - i highly encourage you to download the
latest version of visual studio code
09:21 - from
code.visualstudio.com now on this
09:25 - mission i've added visual studio code to
my path
09:27 - so i can open it from any folder on my
machine without specifying the full path
09:32 - so if i type code here's vs code
if this doesn't work on your machine you
09:37 - have to troubleshoot the issue yourself
depending on your operating system there
09:41 - are different instructions for
adding vs code to your path so back to
09:45 - the terminal
let's set the default editor git config
09:49 - global the setting we want to configure
is core
09:53 - that editor once again we need double
quotes because here we're going to have
09:56 - a space
the value for this setting is code space
10:00 - dash dash weight with the weight flag we
tell the terminal window to wait
10:05 - until we close the new vs code instance
okay
10:08 - so let's go ahead now all these
configuration settings are stored in a
10:13 - text file
we can edit that file using our default
10:15 - editor in this case vs code
so we can type git config dash dash
10:20 - global dash e this will open our default
editor
10:24 - to edit all the global settings let me
show you
10:27 - so all right here's our configuration
file
10:30 - you can see the full path to this file
on the top the name of this file is
10:34 - git config now in this file we have
different sections
10:37 - so we have the user section with two
settings name
10:40 - and email we have the core section with
these two settings and so on now back in
10:46 - the terminal window
you can see the terminal is waiting for
10:49 - us to close vs code
so as close as we know
10:54 - now we're back in the terminal and we
can execute the next command
10:57 - next we're going to configure how git
should handle end of lines
11:01 - this is a very important setting that a
lot of people miss
11:05 - so on windows end of lines are marked
with two special characters
11:09 - carriers return and line feed on mac and
linux systems
11:13 - end of lines are indicated with line
feed so that means
11:16 - if we don't handle end of lines properly
we're going to run into some weird
11:20 - issues down the road
to prevent this we have to configure a
11:23 - property called core.autocrlf which is
short for carriage return
11:28 - line fit so let me walk you through a
real scenario
11:32 - let's say we have two people here john
and julie working with the same
11:35 - repository
john uses a windows machine julie uses a
11:38 - mac
as i told you on windows end of lines
11:42 - are marked with carriage return
and line feed so when john wants to
11:45 - check in his code into the repository
get to remove the carriage return
11:49 - character from end of lines
similarly when he checks out his code
11:53 - from the repository
get should update end of lines and add
11:57 - the carriage return character
to achieve this behavior we should set
12:00 - this property to true
on the other hand when julie checks out
12:04 - the code she doesn't want the carrier's
return character
12:07 - so git shouldn't touch end of lines
however if carrie's return is
12:11 - accidentally added to end of lines
perhaps because of the editor that julie
12:14 - is using
git should remove it when storing the
12:17 - code in the repository
to achieve this behavior we should set
12:20 - this property to input
which means it should only modify end of
12:24 - lines when storing code in the
repository
12:27 - so back in the terminal we type git
config
12:31 - dash dash global core dot auto
crlf if you're on windows you should set
12:37 - this to true
if you're on mac or linux you should set
12:40 - this to input
12:47 - let me show you a few different ways to
get help about git commands
12:51 - let's say you want to learn more about
the config command you can simply google
12:55 - git config on this page you can see the
full documentation of this command
13:00 - you can see various options and how they
work
13:04 - we can also access the same page on the
terminal window
13:08 - we simply type git config dash dash
help this is exactly the same
13:13 - information you saw a second ago
here we can press space to go to the
13:18 - next page
and queue to exit now if you don't need
13:22 - a full blown help you just need a quick
refresher
13:25 - you can type git config dash h
this gives us a short summary of this
13:31 - command and its options
13:37 - so we're done with the introductory
stuff starting from the next section
13:40 - we're going to cover
a lot of git commands now below this
13:43 - video we can download
a pdf of all the commands we're going to
13:47 - cover in this course
if you're starting out don't worry too
13:50 - much about memorizing these commands
instead try to understand how they work
13:54 - as you practice getting the rail board
all these commands are going to become
13:57 - second nature to you trust me
so download the cheat sheet below this
14:00 - video and then i will see you in the
next section
14:06 - the first thing you need to know to use
git effectively is how to take snapshots
14:10 - of your project
which is what we're going to talk about
14:12 - in this section we'll be talking about
the fundamental concepts and git
14:16 - that are often misunderstood so make
sure to watch every lesson in this
14:19 - section
even if you think you know the basics a
14:22 - lot of people use the basic git commands
without having a proper understanding of
14:26 - how git works and that's why they
constantly get stuck
14:29 - so watch every lesson in this section
now let's jump in and get started
14:42 - alright the first thing we're going to
do is create a directory for our project
14:45 - you can call this directory anything and
put it anywhere on your machine it
14:49 - doesn't matter
i'm currently in the projects directory
14:52 - so let's create a directory called
moon and then go into this directory so
14:58 - let's imagine this is our project
directory
15:00 - and here we can have tens or hundreds of
files the first time we want to add this
15:04 - file to a git repository
we have to initialize a new empty
15:07 - repository
so we type get init look at this message
15:12 - initialized empty git repository in and
here's the full path
15:16 - so we have the moon directory and inside
this directory we have a sub directory
15:20 - called
dot git by default this subdirectory is
15:24 - hidden because you you're not supposed
to touch
15:26 - it so if we type ls to list all the
files and directories here
15:31 - we don't see anything but if we type
ls-a which is short for all
15:36 - we can see the git subdirectory if
you're on mac you can
15:40 - open this with finder and if you're on
windows you can open it with windows
15:44 - explorer or file explorer i'm not sure
what it's called these days
15:47 - so let's open dot get
take a look so here's our git directory
15:54 - or
git repository this is where git stores
15:57 - information about our project history
so we have directories like branches
16:02 - hooks info
objects and references now as someone
16:06 - using git
you don't really need to understand this
16:08 - structure this is purely implementation
detail
16:10 - it's how git stores information it's not
of our business
16:14 - that's why this directory is hidden so
you don't touch it if you crop or remove
16:18 - this directory you're going to lose your
project history let me show you
16:21 - so back in the terminal look at this
green marker
16:24 - it says git that means we have a git
repository in this directory
16:28 - now if you want to have a pretty
colorful terminal window like this
16:31 - on mac you need to install zh or z shell
and on windows you need to install
16:36 - poshkit but don't worry about it now
these tools are completely optional to
16:41 - use git it's just for making things
pretty
16:43 - so here we have a git repository now if
i remove the git sub directory
16:47 - we're going to lose this repository so
rm
16:50 - dash rf dot get
look the green marker is gone we don't
16:55 - have a git repository here anymore
so don't touch this directory now once
17:00 - again
let's initialize a git repository
17:03 - beautiful
so now that we have a repository next
17:06 - we're going to talk about the basic git
workflow
17:14 - now that we have a git repository let's
talk about the basic git workflow
17:18 - what we do on a daily basis when using
git so here's our project directory and
17:22 - here's our git repository which is
actually a hidden sub directory in our
17:27 - project directory
now every day as part of working on
17:30 - various tasks we modify one or more fans
when our project reaches a state we want
17:34 - to record we commit those changes into
our repository
17:38 - creating a commit is like taking a
snapshot of our project
17:41 - now in git we have a special area or a
special intermediate step
17:45 - that doesn't exist in most other version
control systems
17:49 - it's called the staging area or the
index it's essentially what we're
17:53 - proposing for the next commit
or the next snapshot so when we're done
17:57 - making changes
we add the modified files to the staging
18:00 - area or index
review our changes and if everything is
18:04 - good then we'll make a commit
the proposed snapshot will get
18:07 - permanently stored in our repository
so the staging area allows us to review
18:11 - our work before recording a snapshot
if some of the changes shouldn't be
18:15 - recorded as part of the next snapshot
we can unstage them and commit them as
18:20 - part of another snapshot
that's the basic git workflow now let me
18:24 - walk you through a real example
this example is crucial so pay close
18:28 - attention
all the way to the end even if you think
18:30 - you know the basics
our project directory is currently empty
18:34 - so we add a couple of files here
now we are ready to record this state so
18:38 - we use the add command
to add these files to the staging area
18:42 - now these files are in the staging area
this is the state we're proposing for
18:45 - the next commit
we review these files everything is good
18:49 - so we use the commit command
to permanently store this snapshot in
18:52 - the repository
as part of this we supply a meaningful
18:56 - message to indicate what the snapshot
represents
18:59 - this is essential for having a useful
history so
19:02 - as we fix bugs implement new features
and refactor our code
19:06 - we make commit and each commit clearly
explains the state of the project
19:10 - at that point in time so now we have one
commit in our repository
19:14 - now a common misconception about git is
that once we commit the changes
19:18 - the staging area becomes empty this is
not correct and i think this is why a
19:22 - lot of people find git confusing
so what we currently have in the staging
19:26 - area is the same snapshot that we stored
in the repository
19:30 - so this staging area is actually very
similar to a staging environment we use
19:34 - when releasing software to production
it's either a reflection of what we
19:38 - currently have in production
or the next version that's going to go
19:41 - in production so let's continue with our
example
19:43 - let's say as part of fixing a bug we
make some changes to file one
19:47 - note that what we currently have in the
staging area is the old version of file
19:51 - one
because we haven't staged the changes
19:53 - yet so once again we use the add command
to stage the changes
19:58 - now what we have in the staging area is
the same content we have in our working
20:02 - directory
so let's make a commit to record this
20:04 - date now we have two commits in our
repository
20:08 - also look at the commit message it's
describing the bug that we just fixed
20:12 - now let's say we realize that we no
longer need file to it contains
20:15 - unused code so we delete it from our
working directory
20:19 - but this file is still in the staging
area so once again
20:22 - we should use the add command to stage
this change in this case
20:26 - the deletion this is the interesting
part even though we're saying
20:29 - add file to it knows that file 2 is
actually deleted
20:33 - so it will delete this file from the
staging area or the next snapshot
20:37 - again we make a commit to permanently
record this date
20:40 - now we have three commits in our
repository each commit contains a unique
20:44 - identifier that gets generated by git
it's like a revision number each comment
20:49 - also contains information about what was
changed
20:52 - by who when as well as a complete
snapshot of our project at the time it
20:56 - was created
so unlike many other version control
20:59 - systems git doesn't store the deltas
or what was changed it stores the full
21:05 - content
with this it can quickly restore the
21:08 - project to an earlier snapshot without
having to compute the changes
21:11 - now you might ask but hey mosh when
storing the full content in every
21:15 - snapshot
waste a lot of space no because git is
21:18 - very efficient in data storage
it compresses file contents and doesn't
21:22 - store duplicate content
now someone using git you don't really
21:26 - need to know how it stores data
that's implementation detail and may
21:30 - even change in the future
what you need to know is that each
21:33 - commit contains a complete snapshot of
our project
21:36 - and this allows us to quickly get back
to a previous state so that's the basic
21:40 - idea
over the next few lessons you're going
21:42 - to see this workflow in action
21:50 - let's start by adding a couple of files
to our project to do that we're going to
21:53 - use the echo command
this is not a git command it's just a
21:56 - standard unix or linux command
for writing content to a file so here
22:01 - we're going to write
hello to file1.txt
22:05 - so here i'm working with a text file
because i don't want this course to be
22:08 - specific to people who know
a particular programming language like
22:12 - python or javascript
what i'm going to show you in terms of
22:14 - the workflow applies to any programming
languages
22:17 - okay so we write hello to file1.txt
good now let's execute this command one
22:23 - more time
and change file 1 to file 2. so now we
22:27 - have two files in our project
now look at this question mark here that
22:30 - means we have new files here that are
not tracked by git
22:33 - because the first time you initialize a
git repository in a directory
22:37 - git is not going to automatically track
your files so if you have
22:40 - a thousand files in your project you
have to instruct it to track them
22:44 - okay so here we're gonna run git status
to see the status of the working
22:49 - directory and the staging area
take a look so we don't have any
22:53 - commands yet we have untracked files
which are file one and file two they're
22:58 - indicated by red
because they are not in the staging area
23:01 - yet to add these files to the staging
area
23:04 - we use the git add command here we can
list a single file
23:08 - like file one the txt or multiple files
separated by a space
23:13 - we can also use patterns so
star.txt that means all the files with
23:19 - the txt extension
we also have period which adds the
23:23 - entire directory recursively
now you have to be a little bit careful
23:26 - with this because sometimes there are
files you don't want to add to your
23:29 - repository
perhaps large files like large binary
23:32 - files or log files you don't want to add
this faster repository
23:36 - because they increase the size of your
repository i will show you how to ignore
23:39 - these files later in this section
so just remember add period adds the
23:43 - entire directory recursively
in this demo i'm going to go with this
23:47 - command because we only have two files
in this directory
23:50 - okay now our green indicator changed to
yellow which means we have stuff in the
23:54 - staging area
that are ready to be committed so if we
23:57 - run git status again
look we have two new files and they're
24:02 - indicated by green which means
they're in the staging area now let me
24:06 - show you something interesting
i'm gonna modify file one so once again
24:10 - we're gonna use the echo command
to echo world but here instead of one
24:15 - greater than sign
i'm gonna use two greater than science
24:18 - which means append
so we're going to append world to file
24:21 - one the txt
now let's run git status again look what
24:26 - happened
we have two files in the staging area
24:29 - because they're indicated by green
but we also have one modified file in
24:33 - our working directory
so you might be asking but hey marsh
24:36 - didn't we already add file 1 to staging
area
24:39 - yes we did but when we ran the add
command git took a snapshot of file 1
24:44 - and added that snapshot to the staging
area so here's the current situation
24:48 - in the staging area we have the first
version of file one
24:52 - we changed this file after we added it
to the staging area
24:55 - so what we currently have in our working
directory is the second version of this
24:58 - file
it has some changes that are not staged
25:01 - yet so back to the terminal
we run git add period or git add file
25:07 - one the txt one more time
now look at the status of our working
25:11 - directory
both these files are in the staging area
25:14 - and we don't have any unstaged changes
so next i'm going to show you how to
25:18 - commit this snapshot to permanently
store it in our git repository
25:28 - now we have a snapshot in the staging
area ready to be permanently stored in
25:31 - our repository
so we type git commit dash m
25:36 - for message and here in double quotes we
type a short description that identifies
25:41 - what this snapshot represents so here
i'm going to say
25:44 - initial commit now there are times that
a short one-liner description is not
25:49 - sufficient
you want to explain some details to give
25:52 - context for example if you worked on a
bug
25:54 - and there were some constraints at the
time you committed your code
25:58 - you may want to explain those
constraints this is very valuable to
26:01 - both you and your co-workers
so in situations like this we drop the
26:05 - message
we just type get commit now when we
26:09 - press enter
this opens our default editor in this
26:13 - case vs code
because at the beginning of the course i
26:16 - configured my default editor to be vs
code
26:18 - okay so here we're trying to edit this
file commit
26:22 - underline edit message which is stored
in our git sub directory
26:26 - so on the top we can type a short
description
26:31 - ideally this should be less than 80
characters then we add a line break
26:35 - and after that we can type a long
description
26:39 - now these lines that start with the
pound sign are comments they're going to
26:42 - get ignored
so we type whatever one here in this
26:45 - case i'm going to say
initial commit and this is our
26:50 - first comment of course this is
repetitive we don't have commit messages
26:54 - like this
but for this demo i'm going to go with
26:56 - this message so
we save the changes then we close this
27:00 - window
back in the terminal our snapshot is
27:03 - committed and here we have basic
statistics about what was changed
27:07 - so two files were changed which are file
one and file two
27:11 - and we have three insertions three lines
were inserted
27:14 - in file one we inserted two lines hello
world
27:17 - and in file two we inserted one line now
look at this indicator
27:21 - it turned green because our working
directory is now clean
27:24 - it doesn't have any new changes so what
we have in our working directory
27:28 - is exactly the same content we have in
our staging area
27:32 - which is exactly the same content we
have in the last commit
27:41 - let's talk about the best practices for
committing code first of all your
27:44 - comments shouldn't be too big or too
small
27:47 - we don't want to make a commit every
time we update a file that's just
27:50 - useless because we'll end up with
comments like
27:52 - update file one update file to object
five three it's just useless
27:56 - on the other hand we don't want our
comments to be too big we don't wanna
27:58 - wait and
implement a feature end to end before
28:01 - committing it we don't want to code for
three days and then make it commit
28:04 - because the whole point of committing is
to record checkpoints as we go
28:08 - so if you screw up we can always go back
and recover our code
28:12 - so try to commit often in the real world
you might commit five to ten times a day
28:16 - or even more
depending on the kind of work you are
28:18 - doing but this is just a basic guideline
don't take it as a rule don't try to aim
28:22 - for five or ten commits a day
so as you're coding as you reach a state
28:26 - you wanna record then make a commit
also each commit should represent a
28:31 - logically separate change set
so don't mix things up for example if
28:35 - you're fixing a bug
and then you accidentally find a type on
28:37 - your app you shouldn't commit both these
changes in one commit
28:41 - you should have two separate commits one
commit for the typo
28:44 - another one for the bug fix now if you
accidentally stage both these changes
28:48 - you can easily unstage them i will show
you how to do this later in this section
28:53 - next you should give yourself the habit
of creating meaningful commit messages
28:56 - because all of these messages are going
to show up in history so if your
29:00 - messages are cryptic
they're not going to be helpful to you
29:02 - or other team members now if you
followed my previous advice
29:06 - if your commit represents a single unit
of work it would be easier to come up
29:10 - with a message for your commit
if you're doing too many things in one
29:13 - commit you're not going to come up with
a good message
29:15 - okay now in terms of the wording most
people prefer to use the present tense
29:20 - in their commit messages
so instead of fix the bug you should say
29:24 - fix the bug
if you don't like this convention that's
29:26 - totally fine but whatever convention you
use
29:29 - make sure that you and other team
members stick to it so always take these
29:32 - best practices in mind
when committing code
29:37 - hey guys mosh here i just wanted to let
you know that this video you've been
29:40 - watching
is actually the first hour of my
29:43 - complete get mastery course
and covers only the basic stuff so after
29:47 - you finish this video
if you want to learn more take a look at
29:50 - my full course the complete course is 5
hours long
29:53 - and covers intermediate to advanced
level concept it comes with a
29:56 - certificate of completion
downloadable summary notes and a 30-day
30:00 - money-back guarantee
so if you're not happy you can ask for a
30:02 - refund you will learn all about browsing
history
30:05 - branching and merging collaborating with
others using git and github
30:09 - and rewriting history so by the end of
this course you would be able to use git
30:12 - like a pro
and work effectively with others in your
30:15 - team if you're interested click on the
link below this video to enroll
30:25 - one of the common questions a lot of
beginners have is do we always have to
30:29 - stage our changes before committing them
well the answer is no and in this video
30:33 - i'm going to show you how to skip the
staging area
30:36 - but do this only if you know what you're
doing if you're 100 sure that your code
30:40 - your changes don't need to be reviewed
because that's the whole point of having
30:43 - a staging area
so let's modify file 1 and then commit
30:47 - it in one step
we're gonna say echo test to file
30:52 - one.txt
once again we're appending this line to
30:56 - file1.txt okay
all right now we have a yellow indicator
31:00 - because our working directory is dirty
so instead of running git add and then
31:05 - committing it in two steps
we're going to commit here we're going
31:08 - to supply the option
dash a which means all that means all
31:12 - modified files
and then just like before we supply a
31:16 - message or we can combine
these two options so let's supply a
31:21 - message
fix the bug that prevented the users
31:26 - from signing up let's go
our code is committed one file was
31:31 - changed and we have one insertion
so this is how we can skip the staging
31:35 - area but once again
do this only if you know what you're
31:38 - doing 99 of the time you should always
stage your code
31:42 - before committing it to the repository
31:50 - let's say that we just discovered that
we no longer need file 2 in our project
31:53 - because it contains
unused code so to remove this file we
31:57 - type rm
file2.txt again this is not a git
32:01 - command because it doesn't start with
git
32:03 - it's just a standard unix command okay
so
32:06 - let's go with this now we have a yellow
indicator which means
32:09 - our working directory is dirty so let's
run git status
32:13 - we have one change that is not staged
for commit so we remove file 2 from our
32:19 - working directory
but still exists in the staging area let
32:23 - me prove it to you
so we type get ls files
32:28 - these are the files in our staging area
so file2 is still here
32:31 - even though we removed it from our
working directory so as i told you
32:34 - before
every time we make changes we have to
32:37 - stage those changes using the add
command
32:39 - so here we type git add file to
txt to stage this change or this
32:45 - deletion more accurately
now let's run git ls files one more time
32:51 - so file two is no longer in the staging
area beautiful
32:55 - let's run git status we have one change
that is ready to be committed and as you
33:01 - can see it's indicated by green which
means
33:03 - it's in the staging area so let's commit
this change
33:08 - and here we're going to say remove
unused
33:11 - code so to remove a file we have to
remove it from both our working
33:16 - directory
as well as the staging area because this
33:19 - is a very common operation
git gives us a command that does both of
33:22 - these steps in one go
let me show you so we type get rm
33:27 - so instead of using the standard rm
command in unix
33:30 - we use git rm here we list a file name
like file2.txt
33:35 - we can also specify multiple files we
can also use patterns
33:39 - like all text files when we execute this
command
33:42 - git removes this file from both the
working directory as well as the staging
33:50 - area
now let's talk about renaming or moving
33:54 - fast so currently we have a single file
in our working directory
33:57 - and that is file1.txt let's rename this
to main.js
34:01 - so we use the move command in unix to
rename file1.txt
34:05 - domain.js so with this command we can
rename or move
34:09 - files and directories okay now our
working directory is dirty
34:13 - so let's run git status we have two
changes
34:18 - and both these changes are unstaged
because they're indicated by red
34:22 - we have a delete operation we deleted
51. txt
34:25 - and under untracked files we have a new
file
34:28 - so as you saw at the beginning of this
section git doesn't automatically track
34:32 - all your new files
every time you have a new file in your
34:35 - project you have to add it to the
staging area so git starts tracking it
34:39 - so once again we have to use the add
command to stage both these changes
34:43 - git add file1.txt this is for staging
the deletion
34:48 - and now let's add the new untracked file
main.js
34:52 - now let's run git status one more time
look
34:55 - git recognized that we renamed file1.txt
to main.js
35:00 - and this item is indicated by green
which means this is in the staging area
35:04 - so renaming or moving files is a
two-step operation
35:07 - first we have to modify our working
directory and then we have to stage
35:11 - two types of changes an addition and a
deletion
35:14 - so similar to removing files git gives
us a special command
35:18 - for renaming or moving files that is git
move so instead of using the standard
35:23 - move command in unix
we're going to use git move now let's
35:27 - rename main.js
to file1.js and then run git status one
35:33 - more time
so we have a rename operation for
35:36 - renaming file on the txt
the file on the js so when we use the
35:40 - move command
the changes are applied to both the
35:43 - working directory and the staging area
now let's commit the changes for the
35:48 - message i'm going to say
refactor code now look at the statistics
35:53 - one file was changed we have zero
insertions because we haven't added any
35:58 - new lines to any of our files and we
also have zero deletions
36:01 - because we haven't removed any lines
from any files
36:10 - in almost every project we should tell
git to ignore certain files and
36:13 - directories
for example we don't want to include log
36:16 - files or binary files that get generated
as a result of compiling our code adding
36:21 - these files is just going to increase
the size of our repository
36:24 - without providing any values every
developer can have their own log files
36:28 - right
so log files are not something we want
36:31 - to share and synchronize with other team
members
36:33 - so for this demo let's create a
directory called logs
36:37 - and then add a log file here once again
we can use the echo command
36:40 - to write hello to logs dev.log
now let's run git status so git is
36:48 - saying that
we have an untracked directory called
36:50 - logs but we don't want to add this to
the staging area
36:53 - because we don't want git to track this
so to prevent this
36:57 - we have to create a special file called
dot
37:00 - git ignore so this file has no name it
only has an extension
37:04 - and it should be in the root of your
project so let's echo
37:08 - logs forward slash to dot
git ignore now i'm going to open this
37:14 - file using vs code
so code git ignore
37:18 - so in this file we have a single entry
logs forward slash
37:22 - which indicates a directory we can list
as many files and directory as we want
37:26 - here
for example we can include main.log we
37:29 - can also use
patterns like all log files and so on
37:33 - once we are done we save the changes
back in the terminal
37:37 - now if you run git status one more time
git no longer says that we have a new
37:41 - directory called logs
because it's ignoring it instead it says
37:45 - we have a new file called
dot get ignore so let's add this file to
37:50 - the staging area
and then commit our code so add git
37:55 - ignore
so this is how we can ignore files and
37:59 - directories in git
just remember this only works if you
38:02 - haven't already included a file or a
directory in your repository
38:06 - in other words if you accidentally
include a file in your repository
38:10 - and then later added to git ignore git
is not going to ignore that
38:13 - let me show you so let's create a new
directory called
38:17 - bin let's imagine that this directory
contains our compiled source code
38:21 - so using the echo command i'm going to
write hello to
38:25 - bin app.bin
now let's run git status so we have a
38:31 - new directory
now we want to accidentally commit this
38:34 - to our repository so
we add all the changes and then commit
38:40 - our code
add bin here's the problem
38:45 - every time we compile our code git is
going to say that this file
38:49 - bin app.bin is changed so we have to
stage it and then commit it
38:53 - it doesn't make sense why do we have to
commit this file every time we compile
38:57 - our application
so back to git ignore let's add the bin
39:01 - directory here as well
now back in the terminal let's run git
39:06 - status so we have modified git ignore
beautiful list stage and commit this
39:10 - change so git add
period and then git commit
39:15 - include in slash and git ignore
now in this case git is not going to
39:22 - ignore the changes in this directory
because it's already tracking this
39:25 - directory so let's modify our bin
file by saying echo hello world
39:31 - to bin slash app.bin
git status look git is saying
39:38 - that this file is modified this is not
what we want to solve this problem
39:43 - we have to remove this file from the
staging area which is what we're
39:46 - proposing for the next commit
so earlier we talked about get ls
39:51 - files this command shows the files in
our staging area
39:54 - so as you can see this bin file or the
bin directory is already in the staging
39:59 - area
we should remove it here how well
40:02 - earlier we talked about
the git remove command i told you that
40:06 - with this command we can remove a file
or a directory from both the working
40:09 - directory as well as the staging area
but in this case we don't want to remove
40:13 - this file from our working directory
because that's how we launch our
40:16 - application so we want to remove this
file
40:18 - only from the staging area how well
let's add
40:22 - dash h for a quick help so we type
git rm then we can add zero or more
40:28 - options
now here we have this option called dash
40:31 - dash cache
with this we can remove stuff only from
40:35 - the index
index is the old term for the staging
40:38 - area so when you look at git
documentation
40:40 - most of the time you see index so using
this option
40:43 - we can remove the bin directory from the
index so
40:47 - git rm dash dash cached bin
forward slash now we get an error saying
40:54 - not removing bin recursively without
dash r
40:57 - so one more time let's look at the help
for this command we have another option
41:02 - called dash
r for recursive removal so we want to
41:06 - remove the entire bin directory from the
staging area
41:09 - to do that we type git rm dash dash
cache
41:13 - dash r bin forward slash
beautiful now this entire directory is
41:18 - removed from the staging area
let's verify it so get ls files
41:24 - our bin directory is no longer here now
let's run git status
41:29 - look we have one change that is ready to
be committed
41:32 - this directory is deleted from our
staging area
41:35 - so let's commit the change
remove the bin directory that was
41:41 - accidentally
committed okay from this point forward
41:48 - git is no longer going to track the
changes in this directory
41:51 - so if we encode test to bin
slash app.bin you can see our working
41:58 - directory is still clean we don't have
any changes
42:00 - we can verify it using git status as
well so this is how we can ignore files
42:04 - and directories in git
now if you head over to github.com
42:08 - github
get ignore you can see various git
42:11 - ignore templates for different
programming languages
42:14 - for example let's look at the template
for java
42:19 - so for java projects it's a great idea
to exclude
42:23 - all the class files because these files
get automatically generated when you
42:27 - compile your code so there is no need to
include them in your repository
42:30 - so here we have various patterns like
all the class files or all the log files
42:34 - the lines that start with a high sign
these are comments so they get ignored
42:38 - by git
so you have learned how to get the
42:46 - status of the working directory and the
staging area using the status command
42:50 - the output of this command is very
comprehensive but it's also very wordy
42:54 - so as an alternative we can supply the
short status flag or dash
42:58 - s let me walk you through a few examples
so
43:01 - for this demo we're going to modify one
of our existing files
43:04 - and then add a new file so echo sky
2 file 1.js so we're appending a sky
43:12 - to 51.js now let's create a new file
so once again echo sky to file to the js
43:20 - now let's run git status we have
modified file one
43:24 - and we have a new on-track file so as
you can see
43:27 - the output of this command is very
comprehensive but also very wordy
43:31 - now let's run git status dash s this is
much easier to dice
43:35 - so let me show you how this works here
we have two columns
43:38 - the left column represents the staging
area and the right column represents the
43:42 - working directory
so we have modified file one and that's
43:46 - why we have a red
m in the right column which is the
43:49 - working directory so we have some
changes here
43:51 - but these changes are not in the staging
area that's why
43:55 - we don't have anything in the left
column now file two is a new file
43:59 - that's why we have two question marks in
both these columns
44:02 - now let's add file one to the staging
area so
44:07 - github file 1 and then do another short
status
44:10 - look for file 1 we have a green m in the
left column or the staging area column
44:16 - so all the changes that we had in the
working area are now in the staging area
44:20 - in the right column we don't have
anything we don't have any extra changes
44:24 - now earlier in this section i told you
that when we stage a file git takes a
44:28 - snapshot of that file
and puts it in the staging area so if
44:31 - you modify that file after
we have to restage the changes let me
44:35 - show you this one more time
so i'm going to modify file one one more
44:38 - time let's echo ocean
to fileone.js and then run
44:43 - git status dash s look what we have here
so in the left column we have a green l
44:49 - which means we have some changes in the
staging area
44:52 - but we have some additional changes in
the working directory
44:55 - that are not added to the staging area
okay so
44:59 - let's add file one to the staging area
one more time
45:02 - and then run git status dash
s now all the changes that we had in the
45:07 - working directory
are now in the staging area so we're
45:11 - done with file one
let's look at file two so i'm gonna add
45:15 - file two
to the staging area as well and then run
45:19 - git status dash s for file two we have a
green a
45:23 - in the left column which represents
added so file two is added
45:27 - and file one is modified this is how the
short status output works
45:37 - so we have staged a couple of changes
now before committing what we have in
45:41 - the staging area we need to review our
code because we don't want to commit bad
45:44 - code or broken code
to our repository so as a best practice
45:48 - always review what you have in the
staging area
45:50 - before making a commit now the status
command only shows the files that have
45:55 - been affected
but how can we see the exact lines of
45:57 - code that we have staged
we use the diff command so we type get
46:02 - div dash dash staged to see what we have
in the staging area that is going in the
46:08 - next commit
so let's take a look here now quite
46:12 - frankly comparing files using the
terminal window is not really the best
46:15 - way to do this
quite often we use visual tools and i'm
46:18 - going to talk about that in the next
video
46:20 - but i think it's essential for you to
understand the output of this command
46:23 - because there are times that you may not
have access to a visual tool or at this
46:27 - you may go to an interview
and you may get asked what is the output
46:30 - of this command so you need to be able
to explain it
46:32 - so on the top you can see that the diff
utility was called
46:36 - with these arguments so we are comparing
a
46:39 - slash file1.js with b file1.js
so we're comparing two copies of the
46:45 - same file the first copy
is the old copy which is what we have in
46:49 - the last commit
and the second copy which is the newer
46:53 - copy
is what we currently have in the staging
46:55 - area okay now
below that we have index whatever this
47:00 - is just some metadata it doesn't really
matter
47:03 - after that we have a legend so changes
in the old copy
47:07 - are indicated by a minus sign and
changes in the new copy
47:11 - are indicated by a plus sign after that
we have
47:14 - this section this is a header with some
information about
47:17 - what parts of our file has changed so
currently our files are very short they
47:21 - have only a few lines of text
but in the real world your file might
47:25 - have hundreds of lines of code
if you change only a couple of lines git
47:28 - is not gonna show the
entire file it's gonna divide that file
47:32 - into chunks
and what we have here is just a single
47:35 - chunk so every chunk
has a header with some information that
47:39 - gives you context
so let's see what we have here we have
47:42 - two segments the first segment
is prefix with a minus sign so this
47:46 - gives us information about the old copy
what we have in the last snapshot the
47:51 - second segment
is prefixed with a plus sign so this
47:54 - contains information about the new copy
which is what we have in the staging
47:57 - area
so in the old copy starting from line
48:01 - one
three lines have been extracted and
48:04 - shown here
in the new copy once again starting from
48:07 - the first line
five lines have been extracted and shown
48:11 - here
so these are all these lines over here
48:15 - now you can see that these two lines
are prefixed with a plus sign so these
48:19 - are the lines that we have added in the
new copy
48:21 - so we have added these lines in the
staging area they're green which means
48:25 - they're new lines
so pretty straightforward now after that
48:28 - we have
another call to the diff utility this
48:32 - time we're comparing
two copies of file two now in this case
48:36 - look at the legend we don't have an old
copy
48:39 - because this is an entirely new file so
in the last commit we didn't have a file
48:43 - called
file2 that is why in this header we have
48:47 - 0 comma 0
which means starting from line 0 0 lines
48:50 - have been extracted
because there is no old copy of this
48:53 - file okay now what if you want to see
the changes in our working directory
48:57 - that are not staged yet to do that we
run git div without any arguments
49:03 - so this compares what we have in the
working directory with what we have in
49:06 - the staging area
take a look there is no output here
49:10 - because we have staged
all the changes in our working directory
49:13 - we can also verify this using our short
status command
49:17 - so all the changes in our working
directory are now in the staging area
49:22 - so for this demo i'm going to make a
change to file 1.
49:25 - so let's open it with vs code or our
favorite editor so i'm going to change
49:30 - the first line
to hello world save
49:35 - now let's run another short status
so for file 1 we have some changes in
49:42 - our working directory that are not in
the staging area
49:45 - let's look at these changes using the
dev command so
49:48 - git diff without any arguments take a
look
49:52 - so here we're comparing two copies of
file one the old copy is what we
49:56 - currently have in the staging area
and the new copy is what we have in the
50:01 - working directory
now take a look in the old copy which is
50:05 - indicated by a minus sign
we have this line hello which is removed
50:08 - because it's red
and in the new copy which is what we
50:12 - have in the working directory
we have this new line hello world so to
50:16 - recap
if we run git diff without any argument
50:20 - we can see
unstate changes and if we pass dash dash
50:23 - staged
we can see this state changes that are
50:26 - going to go in the next commit
in the next lesson i'm going to show you
50:28 - how to use a visual tool to easily
compare files
50:37 - as i told you in the last lesson quite
often we use visual div tools for
50:41 - comparing files
there's so many visual div tools out
50:43 - there the most popular ones are kdiff
and p4 merge
50:47 - which are cross platform and win merge
that runs only on windows
50:51 - in this lesson i'm going to show you how
to use vs code for comparing files
50:54 - if you want to use a different tool or a
different editor you have to look up the
50:57 - instructions yourself
so here in the terminal first we have to
51:01 - tell git that we want to use vs code as
our default devtool
51:04 - so we have to set two configuration
settings so once again we type
51:08 - git config dash global so the global
settings apply to all of our
51:13 - repositories
okay now the setting we're going to set
51:16 - is diff
dot tool we're going to set that to vs
51:19 - code so with this command
we're just giving a name in this case vs
51:23 - code to our default div tool
next we have to tell git how to launch
51:28 - vs code
so once again git config dash global
51:32 - here we set div tool dot vs code
dot cmd we set this to double quotes
51:40 - because we're going to have a space
now on my machine i've added code to my
51:43 - path so i can run it from any
directories
51:46 - if this doesn't work on your machine you
have to look up the instructions
51:48 - yourself
depending on your operating system so
51:51 - we're going to launch code with a few
arguments
51:53 - the first one is dash dash wait this
tells the terminal window to wait until
51:58 - we're done with vs code so until we have
compared the changes
52:01 - and close the vs code instance the
second argument is
52:05 - dash div this tells vs code that we want
to use it for diffing or
52:10 - comparing files then we have two more
arguments
52:13 - dollar sign local in capital and dollar
sign
52:17 - remote and capital these are
placeholders for the old
52:20 - and new copies of a file okay so let's
set that
52:24 - now let's make sure that you've got this
step right so
52:27 - we're gonna run git config dash dash
global
52:31 - e as i told you at the beginning of the
course with this command we can
52:35 - edit our global configuration settings
in our default editor which is vs code
52:40 - so take a look so all these things are
stored
52:44 - in this file dot git config which is
stored
52:47 - in this directory so we have the user
section which we said earlier in the
52:50 - course
now here's a diff section that we just
52:53 - set in this section we have set the tool
to vs code this is just a name then we
52:58 - have diff tool
vs code and here's the command that
53:02 - should be run for comparing files with
vs code
53:04 - so we have code with dash weight then
dash diff now those two placeholders
53:10 - that i added
for some reason they're lost so let's
53:13 - add them real quick
dollar sign local and dollar sign remote
53:19 - make sure to get this right otherwise
things are not going to work on your
53:22 - machine
now we're done so let's close this
53:26 - window
back in the terminal instead of using
53:30 - the div command we're going to use
div tool this will launch our visual div
53:34 - tool for comparing files
now if we don't still play any arguments
53:38 - we're going to see our on state changes
so this will compare what we have in the
53:41 - working directory with what we have in
the staging area
53:44 - if you want to look at our state changes
we supply
53:47 - dash dash stage exactly the same way we
use the diff command
53:51 - okay so let's look at the changes we
have in our working directory
53:56 - we have modified only a single file that
is why we have
54:00 - one out of one and that is file1.js
so git is asking if you want to launch
54:05 - vs code which is the name that we
assigned to our default div tool
54:08 - let's go ahead take a look
so here's the old copy which is what we
54:14 - have in the staging area
and here's a new copy which is what we
54:17 - have in the working directory
as you can see we can easily tell that
54:21 - this line
has been replaced with this line it's
54:24 - much easier to see the changes
now the terminal window is waiting for
54:28 - us to close the vs code instance
so let's close this window back to the
54:33 - terminal
now let's look at the state changes so
54:36 - get div tool
dash dash staged two files have been
54:40 - affected in the staging area
the first one is file1.js let's look at
54:44 - the changes
all right in this case the old copy is
54:48 - what we have in the last command
and the new copy is what we have in the
54:52 - staging area so these are the changes
that are going to go in the next commit
54:56 - you can easily tell that we have added
two lines here
54:59 - now let's close this tab back in the
terminal
55:03 - git is asking if you want to look at the
changes in file2.js
55:06 - in this case i'm going to ignore that so
no like quite honestly we don't use diff
55:11 - tools so much these days i just covered
it because i want my course to be
55:14 - comprehensive
these days most editors and ids allow us
55:18 - to view the staged and unstate changes
as part of our development environment i
55:23 - will show you how to do this later in
this section
55:30 - we have made a few commits so far but
where are these commits let me show you
55:34 - so we use the lock command to look at
our history take a look
55:38 - so here are all the commits we have
created sorted from the latest to the
55:42 - earliest
so here's our last commit on top each
55:45 - commit has a unique identifier
this is a 40 character hexadecimal
55:49 - string that git automatically generates
for us
55:52 - you can think of it like a revision
number but unlike a revision number it
55:55 - doesn't
increase it's just a unique identifier
55:58 - okay now next to that we have
head pointing to master what is this
56:03 - well we're going to talk about this a
lot in the future
56:05 - but master is the main branch or the
main line of work in git
56:09 - in some other version control systems
it's called trunk and git we can have
56:13 - multiple branches
so we can work on multiple features or
56:16 - multiple bug fixes in parallel
and then combine our code we'll talk
56:20 - about that later in the course
now head is a reference to the current
56:24 - branch
so this is how git knows what branch
56:27 - we're currently working on
again we're going to talk about this a
56:30 - lot in the future
now for each commit you can see the
56:33 - author the name of the author as well as
their email
56:36 - the date and time the commit was created
as well as the one-line description
56:42 - like here we have multiple commits that
are spread across multiple pages
56:45 - we can press space to go to the next
page
56:48 - and again now to quit we can press q
now the log command has a few
56:54 - interesting options one of them is
one line this shows us a short summary
56:59 - of the commit
so here we have the unique identifier
57:02 - that is shortened to seven characters
and we only have the one line
57:06 - description so we don't have the author
as well as the date and time of each
57:10 - commit we have another option for
reversing the sort order let me show you
57:15 - so git log one line and then we add dash
dash
57:19 - reverse now you can see the first
command
57:22 - be on top and here's the last commit now
the law command is very powerful
57:27 - so in the future we're going to talk a
lot about it in fact we have a complete
57:30 - section on browsing history
i'm going to show you various ways to
57:34 - get reports from the history
for now let's just stick to the basics
57:43 - so viewing the list of commits is great
but what if you want to see what exactly
57:46 - we have changed in a given commit
that's when we use the show command for
57:50 - example let's say we want to look at the
content of this commit over here
57:54 - we type git show now here we need to
specify the commit we want to inspect
57:59 - there are two ways to reference the
commit we can reference it using its
58:02 - unique identifier
so we type d601b
58:06 - 90. now we don't have to type all the
seven characters
58:09 - we can type fewer characters as long as
we don't have another commit
58:13 - whose id starts with these characters so
that's one way to reference a commit
58:17 - another way is to use the head pointer
so look head is currently in front of
58:21 - the
last commit so to view the last commit
58:24 - we can type head
or to look at previous commit we can
58:27 - type a tilde
and then specify how many steps we want
58:31 - to go back so if we type one
we start from head which is here we go
58:35 - one step back and
this references this command over here
58:39 - let's take a look
so on the top we can see the author and
58:43 - the date of this commit
as well as its message below that we
58:46 - have a diff of what has changed
so in this commit we have changed a
58:49 - single file that is git ignore
over here we can see that we removed
58:54 - this line
and added these two lines so this is
58:57 - very useful
now what if we don't want to see the
59:00 - differences we want to see the final
version the exact version that is stored
59:03 - in this commit
well we bring down the last command git
59:07 - show
head tilde one then we type a colon and
59:11 - here we specify
the full path to a file for example we
59:14 - can say
dot git ignore or if this file is in a
59:17 - subdirectory
we type for example bin slash app.bin
59:23 - okay now let's look at git ignore
so this is the exact version stored in
59:28 - this commit now earlier i told you that
each commit
59:31 - contains a complete snapshot of a
working directory
59:34 - not just changes but when we run the
show command
59:38 - we only see the differences but it's
changed what if you want to see
59:42 - all the files and directories in a
commit well
59:45 - for that we're going to use a different
command that's called ls
59:49 - tree now why is this called a tree well
a tree is a data structure for
59:53 - representing hierarchical information
so in a tree we can have nodes and these
59:57 - nodes can have children
now a directory on the file system can
60:01 - be represented using a tree
because each directory can have children
60:04 - these children can be files
and other subdirectories if you want to
60:08 - learn more about this concept
you should take my data structures
60:10 - course so lst means
list all the files in a tree now here we
60:15 - specify the comments we are interested
in
60:18 - head tilde one and now look these are
all the files and directories stored in
60:23 - this commit
so we have git ignore right before that
60:26 - we have a unique identifier
that is generated based on the content
60:30 - of this file
so in git's database we have an object
60:33 - with this id
below that we have bin again it has a
60:37 - unique identifier that is generated
based on the content of this directory
60:41 - now look at the type of this object it's
a tree
60:44 - so files are represented using blobs and
directories are represented using trees
60:49 - all of these are objects that are stored
in git's database
60:52 - using the show command we can easily
view an object in git's database
60:56 - for example if we type git show and then
specify
60:59 - this unique identifier or we can type
only the few characters
61:03 - as long as there is no ambiguity so
here's the content of our git ignore
61:08 - file
as another example let's look at this
61:12 - object this tree
the bin directory so git show
61:17 - 64629 here we have a tree
in this tree we have this file app.bin
61:23 - so using the show command we can view an
object in git's database these objects
61:28 - can be commits
blobs which represent files and trees
61:31 - which represent directories
as well as tags we'll talk about tags in
61:35 - the future
61:41 - so i told you that you should always
review the stuff that you have in the
61:44 - staging area
before making a commit so let's say we
61:48 - reviewed these changes
and we realized that the changes in file
61:51 - one shouldn't go in the next commit
perhaps because these changes are
61:55 - logically part of a different task
so we don't want to have a commit that
61:59 - represents changes for different tasks
right so in this case we want to undo
62:03 - the add operation
because earlier we use the add command
62:07 - to add file 1 to the staging area
now we want to undo this operation how
62:11 - do we do this well
in the past we used the reset command
62:15 - but a lot of people found this command
confusing
62:18 - especially with options such as hard or
soft
62:21 - that's why we have a new command called
restore now make sure you're using the
62:25 - latest version of git
otherwise what i'm going to show you is
62:28 - not going to work on your machine
so here i'm using git version 2.28
62:33 - and with this we can easily restore
files in different environments
62:36 - in working directory or in staging area
so
62:40 - git restore we want to restore
file 1 in the staging area so we type
62:47 - dash dash staged and then we specify
the file name we can list multiple files
62:52 - here
we can also use patterns or if you want
62:55 - to restore everything in the staging
area
62:58 - we simply use a period so here i'm going
to restore
63:01 - file1.js now
when we run git status again you're not
63:07 - going to see a green m here because all
the changes that we had in the staging
63:10 - area
are now in the working directory take a
63:13 - look so
git status dash s look we no longer have
63:17 - any changes for file one
in the staging area all the changes are
63:21 - in the working directory
now it's essential for you to understand
63:25 - how the restore command works
the restore command essentially takes
63:28 - the copy from the next
environment so in case of the staging
63:32 - environment
what is the next environment the last
63:35 - commit what we have in the repository
so when we restored file one in the
63:39 - staging area git took the last copy of
this file from the last snapshot
63:43 - and put it in the staging area that is
what happened now look at file two
63:47 - file two is a new file because here we
have a green a which is short for added
63:52 - so we have this file we have this new
file in the staging area but this file
63:55 - doesn't exist
in the last commit so what do you think
63:59 - will happen when i restore this file
well because we don't have a copy of
64:03 - this file in our repository or in our
last commit
64:06 - git is going to remove this file from
the staging area and take it back to its
64:09 - previous state
which is a new on-track file let me show
64:13 - you
so git restore dash staged
64:17 - file2.js now let's run git status again
so file2 is a new untracked file because
64:24 - we have two question marks
64:32 - there are times that we have some code
in our working directory that we want to
64:35 - throw away
let's say we made some changes but we
64:37 - didn't like those changes so we want to
scratch everything and start over
64:41 - we can discard the local changes using
the restore command
64:44 - so here we have some local changes in
file1.js
64:48 - to undo these changes we type git
restore
64:51 - file1.js when we execute this command
git is going to take the version of this
64:56 - file in the next environment which is
our staging environment
64:59 - it's going to take that version and copy
into our working directory
65:03 - we can also use a period here and this
will undo all the local changes
65:07 - now let me show you something so the
command is executed
65:11 - now let's run another short status but
file two is still here
65:15 - why is that well this is a new on
tracked file
65:18 - so git hasn't been tracking this so when
we tell git to restore this file
65:22 - git doesn't know where to get a previous
version of this file
65:26 - it doesn't exist in our staging
environment or in our repository
65:29 - so to remove all these new untracked
files we have to type
65:33 - get clean now take a look
by default we get this fatal error
65:38 - saying require force defaults to true
and neither of these switches were given
65:44 - so basically git is telling us that hey
this is a dangerous operation
65:47 - if you accidentally remove these ontrack
files there is no way you can recover
65:51 - them
so let's run git clean dash for quick
65:54 - help
here we have this option dash f which
65:58 - forces git to remove this on track files
you also have d for removing whole
66:03 - directories
so quite often we type git clean dash
66:08 - fd now let's run short status again
file two is gone so this is how we undo
66:14 - local changes
66:21 - so now you know that once git tracks a
file it stores every version of that
66:25 - file in its database
and that means if you screw things we
66:28 - can always restore a file or a directory
to a previous version so in this demo
66:32 - i'm going to delete a file and then show
you how to restore it
66:35 - it's very easy so we're going to delete
file1.js
66:39 - now i told you that if we use the rm
command in linux or unix based systems
66:43 - this will only remove the file from the
working directory so then we'll have to
66:46 - stage the change or the deletion
a better way is to use the git rm
66:51 - command
this will remove the file from both the
66:54 - working directory as well as the staging
area
66:57 - okay now let's get a short status
so in the staging area we have a deleted
67:02 - file now
let's make a commit delete file1.js
67:08 - all right now let's say shoot we
shouldn't have deleted this file so what
67:12 - can we do here
well we have a few options we can undo
67:15 - or revert the last commit we're going to
talk about that later in the course
67:18 - but in this lesson i want to talk about
restoring a file to a previous version
67:23 - not on doing a commit so let's look at
our history
67:28 - all right so here's our history we want
to restore file one
67:31 - to the commit before the last commit
that is this comment over here
67:36 - so we type git restore now let's have a
quick look
67:40 - at the documentation the restore command
takes three types of arguments
67:45 - we can supply a bunch of options we can
still play a source
67:48 - we haven't done this so far so by
default git will restore that file
67:53 - from the next environment or the next
area so if the file you want to restore
67:56 - is in the working directory
git will restore it from the staging
67:59 - area and if the file is in the staging
area git will restore it from the last
68:03 - snapshot
or the last commit now in this case we
68:06 - want to change the default behavior
we want to restore a file from the
68:09 - commit before the last one
so we type git restore dash
68:15 - source we set it to head tilde 1
and then we specify the full path to the
68:20 - file in this case
file1.js now let's get a short status
68:26 - so we have a new untracked file so this
is how we can restore a file to a
68:30 - previous version
68:34 - hey guys bosh here as i said before this
video is the first
68:37 - hour of my complete git mastery course
the complete course is 5 hours long
68:42 - and covers intermediate to advanced
level concepts it comes with a
68:45 - certificate of completion
downloadable summary notes and a 30-day
68:49 - money-back guarantee
so if you're not happy you can ask for a
68:52 - refund you will learn all about browsing
history
68:54 - branching and merging collaborating with
others using git and github
68:58 - and rewriting history so by the end of
this course you would be able to use git
69:01 - like a pro
and work effectively with others in your
69:04 - team if you're interested click on the
link below this video to enroll

Cleaned transcript:

In this course, you're going to learn everything you need to know to get started with Git. If you're an absolute beginner or if you have been using git for a while but never really understood how git works this tutorial is for you you're going to learn all the fundamental concepts as well as the essential commands that you need to know these are the commands that you would use every day at work so by the end of this tutorial you will have a good grasp of the basics and you'll be ready to learn more about the intermediate to advanced concepts i'm adani and i'm super excited to be your instructor if you're new here be sure to subscribe as i upload new tutorials every week now let's jump in and get started so what is git and why is it so popular git is the most popular version control system in the world a version control system records the changes made to our code over time in a special database called repository we can look at our project history and see who has made what changes when and why and if we screw something up we can easily revert our project back to an earlier state without a version control system we'll have to constantly store copies of the entire project in various folders this is very slow and doesn't scale at all especially if multiple people have to work on the same project you would have to constantly toss around the latest code via email or some other mechanisms and then manually merge the changes so in a nutshell with a version control system we can track our project history and work together now version control systems fall into two categories centralized and distributed in a centralized system all team members connect to a central server to get the latest copy of the code and to share their changes with others subversion and microsoft team foundation server are examples of centralized version control systems the problem with the centralized architecture is the single point of failure if the server goes offline we cannot collaborate or save snapshots of our project so we have to wait until the server comes back online in distributed systems we don't have these problems every team member has a copy of the project with its history on their machine so we can save snapshots of our project locally on our machine if the central server is offline we can synchronize our work directly with others git and mercurial are examples of distributed version control systems out of all these git is the most popular version control system in the world because it's free open source super fast and scalable operations like branching and merging are slow and painful in other version control systems like subversion or tfs but they're very fast and git we'll talk about this later so git is almost everywhere more than 90 of software projects in the world use get that's why almost every job description for software developer mentions git so if you're looking for a job as a software developer git is one of the skills you must have on your resume you should know it inside out you should know how it works and how to use it to track your project history and collaborate with others effectively and that's exactly what you're going to learn in this course let's talk about various ways to use git we can use git on the command line so we open a terminal or command prompt window to execute git commands this is the fastest and sometimes the easiest way to get the job done that's why a lot of people use the command line now if you don't like the command line well you're in luck because most modern code editors on ides have builtin support for basic git features for example in vs code we have this source control panel which gives us the essential git features there are also extensions available for bringing additional git features for vs code the most popular extension is gitlands it brings a ton of git features in vs code there are also graphical user interfaces specifically made for using git here on the git website you can find the complete list of these tools for different platforms we have tools for windows mac linux android and ios out of all these the two most popular tools are git kraken and sourcetree git kraken is my personal favorite gui tool for git it's beautifully designed it works across different platforms and it integrates with other git cracking products such as get cracking boards for issue tracking and git cracking timelines for project management it's free for open source projects but for commercial projects you have to pay an annual fee just to let you know i'm not an affiliate of git cracking i'm just a fan the other option is sourcetree it's completely free but it's only available for windows and mac so if you're a linux user you have to use git kraken or another gui tool in this course we'll be spending most of our time on the command line for a couple of reasons the first reason is that pretty much all of these gui tools have some limitations they support the git commands that people use most of the time so even if you want to use a gui tool there are times you would have to roll up your sleeves and get back to the command line to get the job done the other reason is that the command line is always available but there are situations where a gui tool may not be available to you you might connect to a server remotely and you may not have permission to install a gui tool if you don't know how to use the command line then you're stuck in practice a lot of people including myself use both the command line and a gui tool and that's what i'm going to show you in this course there are times that it really makes sense to use a gui tool and not the command line but there are other times that using the command line is faster and easier so we'll use the command line at the end of the day you should use the right tool for the job don't be like this guy you probably know him our popular superstar developer called john smith he thinks he's better than everyone else because he does everything in the command line he never uses a gui tool and he looks down at people who do well let him think whatever he wants if that's what makes him happy who cares so we'll be spending most of our time on the command line but when it makes sense to use a gui tool i'll be showing you examples in vs code and git kraken because those are the most popular tools now if you have never worked with a command line before don't worry i'm going to hold your hand and teach you everything step by step it's a lot easier than you think so next we're going to install git all right let's see if you have git on your machine or not and if yes what version you have installed to do this you have to open a terminal or a command prompt window if you're on mac press command and space and then type terminal if you're on windows click the search icon on the bottom navigation bar and type cmd so here's my terminal or console window your terminal window might look different it doesn't matter this is where we're going to execute git commands so let's look at the version of git on this machine we type git dash dash version so in this machine i'm using git version 2.19.2 but the latest version at the time of recording this video is 2.27.0 so i highly encourage you to download and install the latest version just head over to git scm.com download over here you can find instructions for installing git on different operating systems it's really easy you're not going to have any problems now if you're on windows once you install git you're going to get this application called git bash which is short for born again shell this is basically a command prompt window like this one over here but it emulates unix or linux environments so throughout this course i encourage you to use git bash instead of the builtin command prompt window so what you see on the screen looks closer to what i'm going to show you in this course so go ahead and install git in the next lesson i'm going to show you how to customize our git environment the first time we use git we have to specify a few configuration settings we have to specify our name email default editor and how it should handle line endings we can specify this configuration settings at three different levels at the very top we have the system level the settings that we have here apply to all users of the current computer below this level we have the global level the settings here apply to all repositories of the current user and below this level we have the local level the settings here apply to the current repository or the repository in the current folder so we can have different settings for different repositories or different projects so here in the terminal window we type git config then we type dash dash global to specify the level at which we are defining these settings next we should specify the setting we want to configure so user that name here we type double quotes and type our name now the reason we're adding double quotes is because we have a space in this value okay so that was the first setting once again git config dash global this time we're going to set user.email now because we don't have a space in emails here we don't need double quotes so let's add our email all right next fill it to specify our default editor if you don't set this on mac by default git is going to use vim which is a scary editor a lot of people are freaked out by it in this course i'm going to use visual studio code or vs code you can use any editor that you prefer but if you want to follow along with me i highly encourage you to download the latest version of visual studio code from code.visualstudio.com now on this mission i've added visual studio code to my path so i can open it from any folder on my machine without specifying the full path so if i type code here's vs code if this doesn't work on your machine you have to troubleshoot the issue yourself depending on your operating system there are different instructions for adding vs code to your path so back to the terminal let's set the default editor git config global the setting we want to configure is core that editor once again we need double quotes because here we're going to have a space the value for this setting is code space dash dash weight with the weight flag we tell the terminal window to wait until we close the new vs code instance okay so let's go ahead now all these configuration settings are stored in a text file we can edit that file using our default editor in this case vs code so we can type git config dash dash global dash e this will open our default editor to edit all the global settings let me show you so all right here's our configuration file you can see the full path to this file on the top the name of this file is git config now in this file we have different sections so we have the user section with two settings name and email we have the core section with these two settings and so on now back in the terminal window you can see the terminal is waiting for us to close vs code so as close as we know now we're back in the terminal and we can execute the next command next we're going to configure how git should handle end of lines this is a very important setting that a lot of people miss so on windows end of lines are marked with two special characters carriers return and line feed on mac and linux systems end of lines are indicated with line feed so that means if we don't handle end of lines properly we're going to run into some weird issues down the road to prevent this we have to configure a property called core.autocrlf which is short for carriage return line fit so let me walk you through a real scenario let's say we have two people here john and julie working with the same repository john uses a windows machine julie uses a mac as i told you on windows end of lines are marked with carriage return and line feed so when john wants to check in his code into the repository get to remove the carriage return character from end of lines similarly when he checks out his code from the repository get should update end of lines and add the carriage return character to achieve this behavior we should set this property to true on the other hand when julie checks out the code she doesn't want the carrier's return character so git shouldn't touch end of lines however if carrie's return is accidentally added to end of lines perhaps because of the editor that julie is using git should remove it when storing the code in the repository to achieve this behavior we should set this property to input which means it should only modify end of lines when storing code in the repository so back in the terminal we type git config dash dash global core dot auto crlf if you're on windows you should set this to true if you're on mac or linux you should set this to input let me show you a few different ways to get help about git commands let's say you want to learn more about the config command you can simply google git config on this page you can see the full documentation of this command you can see various options and how they work we can also access the same page on the terminal window we simply type git config dash dash help this is exactly the same information you saw a second ago here we can press space to go to the next page and queue to exit now if you don't need a full blown help you just need a quick refresher you can type git config dash h this gives us a short summary of this command and its options so we're done with the introductory stuff starting from the next section we're going to cover a lot of git commands now below this video we can download a pdf of all the commands we're going to cover in this course if you're starting out don't worry too much about memorizing these commands instead try to understand how they work as you practice getting the rail board all these commands are going to become second nature to you trust me so download the cheat sheet below this video and then i will see you in the next section the first thing you need to know to use git effectively is how to take snapshots of your project which is what we're going to talk about in this section we'll be talking about the fundamental concepts and git that are often misunderstood so make sure to watch every lesson in this section even if you think you know the basics a lot of people use the basic git commands without having a proper understanding of how git works and that's why they constantly get stuck so watch every lesson in this section now let's jump in and get started alright the first thing we're going to do is create a directory for our project you can call this directory anything and put it anywhere on your machine it doesn't matter i'm currently in the projects directory so let's create a directory called moon and then go into this directory so let's imagine this is our project directory and here we can have tens or hundreds of files the first time we want to add this file to a git repository we have to initialize a new empty repository so we type get init look at this message initialized empty git repository in and here's the full path so we have the moon directory and inside this directory we have a sub directory called dot git by default this subdirectory is hidden because you you're not supposed to touch it so if we type ls to list all the files and directories here we don't see anything but if we type lsa which is short for all we can see the git subdirectory if you're on mac you can open this with finder and if you're on windows you can open it with windows explorer or file explorer i'm not sure what it's called these days so let's open dot get take a look so here's our git directory or git repository this is where git stores information about our project history so we have directories like branches hooks info objects and references now as someone using git you don't really need to understand this structure this is purely implementation detail it's how git stores information it's not of our business that's why this directory is hidden so you don't touch it if you crop or remove this directory you're going to lose your project history let me show you so back in the terminal look at this green marker it says git that means we have a git repository in this directory now if you want to have a pretty colorful terminal window like this on mac you need to install zh or z shell and on windows you need to install poshkit but don't worry about it now these tools are completely optional to use git it's just for making things pretty so here we have a git repository now if i remove the git sub directory we're going to lose this repository so rm dash rf dot get look the green marker is gone we don't have a git repository here anymore so don't touch this directory now once again let's initialize a git repository beautiful so now that we have a repository next we're going to talk about the basic git workflow now that we have a git repository let's talk about the basic git workflow what we do on a daily basis when using git so here's our project directory and here's our git repository which is actually a hidden sub directory in our project directory now every day as part of working on various tasks we modify one or more fans when our project reaches a state we want to record we commit those changes into our repository creating a commit is like taking a snapshot of our project now in git we have a special area or a special intermediate step that doesn't exist in most other version control systems it's called the staging area or the index it's essentially what we're proposing for the next commit or the next snapshot so when we're done making changes we add the modified files to the staging area or index review our changes and if everything is good then we'll make a commit the proposed snapshot will get permanently stored in our repository so the staging area allows us to review our work before recording a snapshot if some of the changes shouldn't be recorded as part of the next snapshot we can unstage them and commit them as part of another snapshot that's the basic git workflow now let me walk you through a real example this example is crucial so pay close attention all the way to the end even if you think you know the basics our project directory is currently empty so we add a couple of files here now we are ready to record this state so we use the add command to add these files to the staging area now these files are in the staging area this is the state we're proposing for the next commit we review these files everything is good so we use the commit command to permanently store this snapshot in the repository as part of this we supply a meaningful message to indicate what the snapshot represents this is essential for having a useful history so as we fix bugs implement new features and refactor our code we make commit and each commit clearly explains the state of the project at that point in time so now we have one commit in our repository now a common misconception about git is that once we commit the changes the staging area becomes empty this is not correct and i think this is why a lot of people find git confusing so what we currently have in the staging area is the same snapshot that we stored in the repository so this staging area is actually very similar to a staging environment we use when releasing software to production it's either a reflection of what we currently have in production or the next version that's going to go in production so let's continue with our example let's say as part of fixing a bug we make some changes to file one note that what we currently have in the staging area is the old version of file one because we haven't staged the changes yet so once again we use the add command to stage the changes now what we have in the staging area is the same content we have in our working directory so let's make a commit to record this date now we have two commits in our repository also look at the commit message it's describing the bug that we just fixed now let's say we realize that we no longer need file to it contains unused code so we delete it from our working directory but this file is still in the staging area so once again we should use the add command to stage this change in this case the deletion this is the interesting part even though we're saying add file to it knows that file 2 is actually deleted so it will delete this file from the staging area or the next snapshot again we make a commit to permanently record this date now we have three commits in our repository each commit contains a unique identifier that gets generated by git it's like a revision number each comment also contains information about what was changed by who when as well as a complete snapshot of our project at the time it was created so unlike many other version control systems git doesn't store the deltas or what was changed it stores the full content with this it can quickly restore the project to an earlier snapshot without having to compute the changes now you might ask but hey mosh when storing the full content in every snapshot waste a lot of space no because git is very efficient in data storage it compresses file contents and doesn't store duplicate content now someone using git you don't really need to know how it stores data that's implementation detail and may even change in the future what you need to know is that each commit contains a complete snapshot of our project and this allows us to quickly get back to a previous state so that's the basic idea over the next few lessons you're going to see this workflow in action let's start by adding a couple of files to our project to do that we're going to use the echo command this is not a git command it's just a standard unix or linux command for writing content to a file so here we're going to write hello to file1.txt so here i'm working with a text file because i don't want this course to be specific to people who know a particular programming language like python or javascript what i'm going to show you in terms of the workflow applies to any programming languages okay so we write hello to file1.txt good now let's execute this command one more time and change file 1 to file 2. so now we have two files in our project now look at this question mark here that means we have new files here that are not tracked by git because the first time you initialize a git repository in a directory git is not going to automatically track your files so if you have a thousand files in your project you have to instruct it to track them okay so here we're gonna run git status to see the status of the working directory and the staging area take a look so we don't have any commands yet we have untracked files which are file one and file two they're indicated by red because they are not in the staging area yet to add these files to the staging area we use the git add command here we can list a single file like file one the txt or multiple files separated by a space we can also use patterns so star.txt that means all the files with the txt extension we also have period which adds the entire directory recursively now you have to be a little bit careful with this because sometimes there are files you don't want to add to your repository perhaps large files like large binary files or log files you don't want to add this faster repository because they increase the size of your repository i will show you how to ignore these files later in this section so just remember add period adds the entire directory recursively in this demo i'm going to go with this command because we only have two files in this directory okay now our green indicator changed to yellow which means we have stuff in the staging area that are ready to be committed so if we run git status again look we have two new files and they're indicated by green which means they're in the staging area now let me show you something interesting i'm gonna modify file one so once again we're gonna use the echo command to echo world but here instead of one greater than sign i'm gonna use two greater than science which means append so we're going to append world to file one the txt now let's run git status again look what happened we have two files in the staging area because they're indicated by green but we also have one modified file in our working directory so you might be asking but hey marsh didn't we already add file 1 to staging area yes we did but when we ran the add command git took a snapshot of file 1 and added that snapshot to the staging area so here's the current situation in the staging area we have the first version of file one we changed this file after we added it to the staging area so what we currently have in our working directory is the second version of this file it has some changes that are not staged yet so back to the terminal we run git add period or git add file one the txt one more time now look at the status of our working directory both these files are in the staging area and we don't have any unstaged changes so next i'm going to show you how to commit this snapshot to permanently store it in our git repository now we have a snapshot in the staging area ready to be permanently stored in our repository so we type git commit dash m for message and here in double quotes we type a short description that identifies what this snapshot represents so here i'm going to say initial commit now there are times that a short oneliner description is not sufficient you want to explain some details to give context for example if you worked on a bug and there were some constraints at the time you committed your code you may want to explain those constraints this is very valuable to both you and your coworkers so in situations like this we drop the message we just type get commit now when we press enter this opens our default editor in this case vs code because at the beginning of the course i configured my default editor to be vs code okay so here we're trying to edit this file commit underline edit message which is stored in our git sub directory so on the top we can type a short description ideally this should be less than 80 characters then we add a line break and after that we can type a long description now these lines that start with the pound sign are comments they're going to get ignored so we type whatever one here in this case i'm going to say initial commit and this is our first comment of course this is repetitive we don't have commit messages like this but for this demo i'm going to go with this message so we save the changes then we close this window back in the terminal our snapshot is committed and here we have basic statistics about what was changed so two files were changed which are file one and file two and we have three insertions three lines were inserted in file one we inserted two lines hello world and in file two we inserted one line now look at this indicator it turned green because our working directory is now clean it doesn't have any new changes so what we have in our working directory is exactly the same content we have in our staging area which is exactly the same content we have in the last commit let's talk about the best practices for committing code first of all your comments shouldn't be too big or too small we don't want to make a commit every time we update a file that's just useless because we'll end up with comments like update file one update file to object five three it's just useless on the other hand we don't want our comments to be too big we don't wanna wait and implement a feature end to end before committing it we don't want to code for three days and then make it commit because the whole point of committing is to record checkpoints as we go so if you screw up we can always go back and recover our code so try to commit often in the real world you might commit five to ten times a day or even more depending on the kind of work you are doing but this is just a basic guideline don't take it as a rule don't try to aim for five or ten commits a day so as you're coding as you reach a state you wanna record then make a commit also each commit should represent a logically separate change set so don't mix things up for example if you're fixing a bug and then you accidentally find a type on your app you shouldn't commit both these changes in one commit you should have two separate commits one commit for the typo another one for the bug fix now if you accidentally stage both these changes you can easily unstage them i will show you how to do this later in this section next you should give yourself the habit of creating meaningful commit messages because all of these messages are going to show up in history so if your messages are cryptic they're not going to be helpful to you or other team members now if you followed my previous advice if your commit represents a single unit of work it would be easier to come up with a message for your commit if you're doing too many things in one commit you're not going to come up with a good message okay now in terms of the wording most people prefer to use the present tense in their commit messages so instead of fix the bug you should say fix the bug if you don't like this convention that's totally fine but whatever convention you use make sure that you and other team members stick to it so always take these best practices in mind when committing code hey guys mosh here i just wanted to let you know that this video you've been watching is actually the first hour of my complete get mastery course and covers only the basic stuff so after you finish this video if you want to learn more take a look at my full course the complete course is 5 hours long and covers intermediate to advanced level concept it comes with a certificate of completion downloadable summary notes and a 30day moneyback guarantee so if you're not happy you can ask for a refund you will learn all about browsing history branching and merging collaborating with others using git and github and rewriting history so by the end of this course you would be able to use git like a pro and work effectively with others in your team if you're interested click on the link below this video to enroll one of the common questions a lot of beginners have is do we always have to stage our changes before committing them well the answer is no and in this video i'm going to show you how to skip the staging area but do this only if you know what you're doing if you're 100 sure that your code your changes don't need to be reviewed because that's the whole point of having a staging area so let's modify file 1 and then commit it in one step we're gonna say echo test to file one.txt once again we're appending this line to file1.txt okay all right now we have a yellow indicator because our working directory is dirty so instead of running git add and then committing it in two steps we're going to commit here we're going to supply the option dash a which means all that means all modified files and then just like before we supply a message or we can combine these two options so let's supply a message fix the bug that prevented the users from signing up let's go our code is committed one file was changed and we have one insertion so this is how we can skip the staging area but once again do this only if you know what you're doing 99 of the time you should always stage your code before committing it to the repository let's say that we just discovered that we no longer need file 2 in our project because it contains unused code so to remove this file we type rm file2.txt again this is not a git command because it doesn't start with git it's just a standard unix command okay so let's go with this now we have a yellow indicator which means our working directory is dirty so let's run git status we have one change that is not staged for commit so we remove file 2 from our working directory but still exists in the staging area let me prove it to you so we type get ls files these are the files in our staging area so file2 is still here even though we removed it from our working directory so as i told you before every time we make changes we have to stage those changes using the add command so here we type git add file to txt to stage this change or this deletion more accurately now let's run git ls files one more time so file two is no longer in the staging area beautiful let's run git status we have one change that is ready to be committed and as you can see it's indicated by green which means it's in the staging area so let's commit this change and here we're going to say remove unused code so to remove a file we have to remove it from both our working directory as well as the staging area because this is a very common operation git gives us a command that does both of these steps in one go let me show you so we type get rm so instead of using the standard rm command in unix we use git rm here we list a file name like file2.txt we can also specify multiple files we can also use patterns like all text files when we execute this command git removes this file from both the working directory as well as the staging area now let's talk about renaming or moving fast so currently we have a single file in our working directory and that is file1.txt let's rename this to main.js so we use the move command in unix to rename file1.txt domain.js so with this command we can rename or move files and directories okay now our working directory is dirty so let's run git status we have two changes and both these changes are unstaged because they're indicated by red we have a delete operation we deleted 51. txt and under untracked files we have a new file so as you saw at the beginning of this section git doesn't automatically track all your new files every time you have a new file in your project you have to add it to the staging area so git starts tracking it so once again we have to use the add command to stage both these changes git add file1.txt this is for staging the deletion and now let's add the new untracked file main.js now let's run git status one more time look git recognized that we renamed file1.txt to main.js and this item is indicated by green which means this is in the staging area so renaming or moving files is a twostep operation first we have to modify our working directory and then we have to stage two types of changes an addition and a deletion so similar to removing files git gives us a special command for renaming or moving files that is git move so instead of using the standard move command in unix we're going to use git move now let's rename main.js to file1.js and then run git status one more time so we have a rename operation for renaming file on the txt the file on the js so when we use the move command the changes are applied to both the working directory and the staging area now let's commit the changes for the message i'm going to say refactor code now look at the statistics one file was changed we have zero insertions because we haven't added any new lines to any of our files and we also have zero deletions because we haven't removed any lines from any files in almost every project we should tell git to ignore certain files and directories for example we don't want to include log files or binary files that get generated as a result of compiling our code adding these files is just going to increase the size of our repository without providing any values every developer can have their own log files right so log files are not something we want to share and synchronize with other team members so for this demo let's create a directory called logs and then add a log file here once again we can use the echo command to write hello to logs dev.log now let's run git status so git is saying that we have an untracked directory called logs but we don't want to add this to the staging area because we don't want git to track this so to prevent this we have to create a special file called dot git ignore so this file has no name it only has an extension and it should be in the root of your project so let's echo logs forward slash to dot git ignore now i'm going to open this file using vs code so code git ignore so in this file we have a single entry logs forward slash which indicates a directory we can list as many files and directory as we want here for example we can include main.log we can also use patterns like all log files and so on once we are done we save the changes back in the terminal now if you run git status one more time git no longer says that we have a new directory called logs because it's ignoring it instead it says we have a new file called dot get ignore so let's add this file to the staging area and then commit our code so add git ignore so this is how we can ignore files and directories in git just remember this only works if you haven't already included a file or a directory in your repository in other words if you accidentally include a file in your repository and then later added to git ignore git is not going to ignore that let me show you so let's create a new directory called bin let's imagine that this directory contains our compiled source code so using the echo command i'm going to write hello to bin app.bin now let's run git status so we have a new directory now we want to accidentally commit this to our repository so we add all the changes and then commit our code add bin here's the problem every time we compile our code git is going to say that this file bin app.bin is changed so we have to stage it and then commit it it doesn't make sense why do we have to commit this file every time we compile our application so back to git ignore let's add the bin directory here as well now back in the terminal let's run git status so we have modified git ignore beautiful list stage and commit this change so git add period and then git commit include in slash and git ignore now in this case git is not going to ignore the changes in this directory because it's already tracking this directory so let's modify our bin file by saying echo hello world to bin slash app.bin git status look git is saying that this file is modified this is not what we want to solve this problem we have to remove this file from the staging area which is what we're proposing for the next commit so earlier we talked about get ls files this command shows the files in our staging area so as you can see this bin file or the bin directory is already in the staging area we should remove it here how well earlier we talked about the git remove command i told you that with this command we can remove a file or a directory from both the working directory as well as the staging area but in this case we don't want to remove this file from our working directory because that's how we launch our application so we want to remove this file only from the staging area how well let's add dash h for a quick help so we type git rm then we can add zero or more options now here we have this option called dash dash cache with this we can remove stuff only from the index index is the old term for the staging area so when you look at git documentation most of the time you see index so using this option we can remove the bin directory from the index so git rm dash dash cached bin forward slash now we get an error saying not removing bin recursively without dash r so one more time let's look at the help for this command we have another option called dash r for recursive removal so we want to remove the entire bin directory from the staging area to do that we type git rm dash dash cache dash r bin forward slash beautiful now this entire directory is removed from the staging area let's verify it so get ls files our bin directory is no longer here now let's run git status look we have one change that is ready to be committed this directory is deleted from our staging area so let's commit the change remove the bin directory that was accidentally committed okay from this point forward git is no longer going to track the changes in this directory so if we encode test to bin slash app.bin you can see our working directory is still clean we don't have any changes we can verify it using git status as well so this is how we can ignore files and directories in git now if you head over to github.com github get ignore you can see various git ignore templates for different programming languages for example let's look at the template for java so for java projects it's a great idea to exclude all the class files because these files get automatically generated when you compile your code so there is no need to include them in your repository so here we have various patterns like all the class files or all the log files the lines that start with a high sign these are comments so they get ignored by git so you have learned how to get the status of the working directory and the staging area using the status command the output of this command is very comprehensive but it's also very wordy so as an alternative we can supply the short status flag or dash s let me walk you through a few examples so for this demo we're going to modify one of our existing files and then add a new file so echo sky 2 file 1.js so we're appending a sky to 51.js now let's create a new file so once again echo sky to file to the js now let's run git status we have modified file one and we have a new ontrack file so as you can see the output of this command is very comprehensive but also very wordy now let's run git status dash s this is much easier to dice so let me show you how this works here we have two columns the left column represents the staging area and the right column represents the working directory so we have modified file one and that's why we have a red m in the right column which is the working directory so we have some changes here but these changes are not in the staging area that's why we don't have anything in the left column now file two is a new file that's why we have two question marks in both these columns now let's add file one to the staging area so github file 1 and then do another short status look for file 1 we have a green m in the left column or the staging area column so all the changes that we had in the working area are now in the staging area in the right column we don't have anything we don't have any extra changes now earlier in this section i told you that when we stage a file git takes a snapshot of that file and puts it in the staging area so if you modify that file after we have to restage the changes let me show you this one more time so i'm going to modify file one one more time let's echo ocean to fileone.js and then run git status dash s look what we have here so in the left column we have a green l which means we have some changes in the staging area but we have some additional changes in the working directory that are not added to the staging area okay so let's add file one to the staging area one more time and then run git status dash s now all the changes that we had in the working directory are now in the staging area so we're done with file one let's look at file two so i'm gonna add file two to the staging area as well and then run git status dash s for file two we have a green a in the left column which represents added so file two is added and file one is modified this is how the short status output works so we have staged a couple of changes now before committing what we have in the staging area we need to review our code because we don't want to commit bad code or broken code to our repository so as a best practice always review what you have in the staging area before making a commit now the status command only shows the files that have been affected but how can we see the exact lines of code that we have staged we use the diff command so we type get div dash dash staged to see what we have in the staging area that is going in the next commit so let's take a look here now quite frankly comparing files using the terminal window is not really the best way to do this quite often we use visual tools and i'm going to talk about that in the next video but i think it's essential for you to understand the output of this command because there are times that you may not have access to a visual tool or at this you may go to an interview and you may get asked what is the output of this command so you need to be able to explain it so on the top you can see that the diff utility was called with these arguments so we are comparing a slash file1.js with b file1.js so we're comparing two copies of the same file the first copy is the old copy which is what we have in the last commit and the second copy which is the newer copy is what we currently have in the staging area okay now below that we have index whatever this is just some metadata it doesn't really matter after that we have a legend so changes in the old copy are indicated by a minus sign and changes in the new copy are indicated by a plus sign after that we have this section this is a header with some information about what parts of our file has changed so currently our files are very short they have only a few lines of text but in the real world your file might have hundreds of lines of code if you change only a couple of lines git is not gonna show the entire file it's gonna divide that file into chunks and what we have here is just a single chunk so every chunk has a header with some information that gives you context so let's see what we have here we have two segments the first segment is prefix with a minus sign so this gives us information about the old copy what we have in the last snapshot the second segment is prefixed with a plus sign so this contains information about the new copy which is what we have in the staging area so in the old copy starting from line one three lines have been extracted and shown here in the new copy once again starting from the first line five lines have been extracted and shown here so these are all these lines over here now you can see that these two lines are prefixed with a plus sign so these are the lines that we have added in the new copy so we have added these lines in the staging area they're green which means they're new lines so pretty straightforward now after that we have another call to the diff utility this time we're comparing two copies of file two now in this case look at the legend we don't have an old copy because this is an entirely new file so in the last commit we didn't have a file called file2 that is why in this header we have 0 comma 0 which means starting from line 0 0 lines have been extracted because there is no old copy of this file okay now what if you want to see the changes in our working directory that are not staged yet to do that we run git div without any arguments so this compares what we have in the working directory with what we have in the staging area take a look there is no output here because we have staged all the changes in our working directory we can also verify this using our short status command so all the changes in our working directory are now in the staging area so for this demo i'm going to make a change to file 1. so let's open it with vs code or our favorite editor so i'm going to change the first line to hello world save now let's run another short status so for file 1 we have some changes in our working directory that are not in the staging area let's look at these changes using the dev command so git diff without any arguments take a look so here we're comparing two copies of file one the old copy is what we currently have in the staging area and the new copy is what we have in the working directory now take a look in the old copy which is indicated by a minus sign we have this line hello which is removed because it's red and in the new copy which is what we have in the working directory we have this new line hello world so to recap if we run git diff without any argument we can see unstate changes and if we pass dash dash staged we can see this state changes that are going to go in the next commit in the next lesson i'm going to show you how to use a visual tool to easily compare files as i told you in the last lesson quite often we use visual div tools for comparing files there's so many visual div tools out there the most popular ones are kdiff and p4 merge which are cross platform and win merge that runs only on windows in this lesson i'm going to show you how to use vs code for comparing files if you want to use a different tool or a different editor you have to look up the instructions yourself so here in the terminal first we have to tell git that we want to use vs code as our default devtool so we have to set two configuration settings so once again we type git config dash global so the global settings apply to all of our repositories okay now the setting we're going to set is diff dot tool we're going to set that to vs code so with this command we're just giving a name in this case vs code to our default div tool next we have to tell git how to launch vs code so once again git config dash global here we set div tool dot vs code dot cmd we set this to double quotes because we're going to have a space now on my machine i've added code to my path so i can run it from any directories if this doesn't work on your machine you have to look up the instructions yourself depending on your operating system so we're going to launch code with a few arguments the first one is dash dash wait this tells the terminal window to wait until we're done with vs code so until we have compared the changes and close the vs code instance the second argument is dash div this tells vs code that we want to use it for diffing or comparing files then we have two more arguments dollar sign local in capital and dollar sign remote and capital these are placeholders for the old and new copies of a file okay so let's set that now let's make sure that you've got this step right so we're gonna run git config dash dash global e as i told you at the beginning of the course with this command we can edit our global configuration settings in our default editor which is vs code so take a look so all these things are stored in this file dot git config which is stored in this directory so we have the user section which we said earlier in the course now here's a diff section that we just set in this section we have set the tool to vs code this is just a name then we have diff tool vs code and here's the command that should be run for comparing files with vs code so we have code with dash weight then dash diff now those two placeholders that i added for some reason they're lost so let's add them real quick dollar sign local and dollar sign remote make sure to get this right otherwise things are not going to work on your machine now we're done so let's close this window back in the terminal instead of using the div command we're going to use div tool this will launch our visual div tool for comparing files now if we don't still play any arguments we're going to see our on state changes so this will compare what we have in the working directory with what we have in the staging area if you want to look at our state changes we supply dash dash stage exactly the same way we use the diff command okay so let's look at the changes we have in our working directory we have modified only a single file that is why we have one out of one and that is file1.js so git is asking if you want to launch vs code which is the name that we assigned to our default div tool let's go ahead take a look so here's the old copy which is what we have in the staging area and here's a new copy which is what we have in the working directory as you can see we can easily tell that this line has been replaced with this line it's much easier to see the changes now the terminal window is waiting for us to close the vs code instance so let's close this window back to the terminal now let's look at the state changes so get div tool dash dash staged two files have been affected in the staging area the first one is file1.js let's look at the changes all right in this case the old copy is what we have in the last command and the new copy is what we have in the staging area so these are the changes that are going to go in the next commit you can easily tell that we have added two lines here now let's close this tab back in the terminal git is asking if you want to look at the changes in file2.js in this case i'm going to ignore that so no like quite honestly we don't use diff tools so much these days i just covered it because i want my course to be comprehensive these days most editors and ids allow us to view the staged and unstate changes as part of our development environment i will show you how to do this later in this section we have made a few commits so far but where are these commits let me show you so we use the lock command to look at our history take a look so here are all the commits we have created sorted from the latest to the earliest so here's our last commit on top each commit has a unique identifier this is a 40 character hexadecimal string that git automatically generates for us you can think of it like a revision number but unlike a revision number it doesn't increase it's just a unique identifier okay now next to that we have head pointing to master what is this well we're going to talk about this a lot in the future but master is the main branch or the main line of work in git in some other version control systems it's called trunk and git we can have multiple branches so we can work on multiple features or multiple bug fixes in parallel and then combine our code we'll talk about that later in the course now head is a reference to the current branch so this is how git knows what branch we're currently working on again we're going to talk about this a lot in the future now for each commit you can see the author the name of the author as well as their email the date and time the commit was created as well as the oneline description like here we have multiple commits that are spread across multiple pages we can press space to go to the next page and again now to quit we can press q now the log command has a few interesting options one of them is one line this shows us a short summary of the commit so here we have the unique identifier that is shortened to seven characters and we only have the one line description so we don't have the author as well as the date and time of each commit we have another option for reversing the sort order let me show you so git log one line and then we add dash dash reverse now you can see the first command be on top and here's the last commit now the law command is very powerful so in the future we're going to talk a lot about it in fact we have a complete section on browsing history i'm going to show you various ways to get reports from the history for now let's just stick to the basics so viewing the list of commits is great but what if you want to see what exactly we have changed in a given commit that's when we use the show command for example let's say we want to look at the content of this commit over here we type git show now here we need to specify the commit we want to inspect there are two ways to reference the commit we can reference it using its unique identifier so we type d601b 90. now we don't have to type all the seven characters we can type fewer characters as long as we don't have another commit whose id starts with these characters so that's one way to reference a commit another way is to use the head pointer so look head is currently in front of the last commit so to view the last commit we can type head or to look at previous commit we can type a tilde and then specify how many steps we want to go back so if we type one we start from head which is here we go one step back and this references this command over here let's take a look so on the top we can see the author and the date of this commit as well as its message below that we have a diff of what has changed so in this commit we have changed a single file that is git ignore over here we can see that we removed this line and added these two lines so this is very useful now what if we don't want to see the differences we want to see the final version the exact version that is stored in this commit well we bring down the last command git show head tilde one then we type a colon and here we specify the full path to a file for example we can say dot git ignore or if this file is in a subdirectory we type for example bin slash app.bin okay now let's look at git ignore so this is the exact version stored in this commit now earlier i told you that each commit contains a complete snapshot of a working directory not just changes but when we run the show command we only see the differences but it's changed what if you want to see all the files and directories in a commit well for that we're going to use a different command that's called ls tree now why is this called a tree well a tree is a data structure for representing hierarchical information so in a tree we can have nodes and these nodes can have children now a directory on the file system can be represented using a tree because each directory can have children these children can be files and other subdirectories if you want to learn more about this concept you should take my data structures course so lst means list all the files in a tree now here we specify the comments we are interested in head tilde one and now look these are all the files and directories stored in this commit so we have git ignore right before that we have a unique identifier that is generated based on the content of this file so in git's database we have an object with this id below that we have bin again it has a unique identifier that is generated based on the content of this directory now look at the type of this object it's a tree so files are represented using blobs and directories are represented using trees all of these are objects that are stored in git's database using the show command we can easily view an object in git's database for example if we type git show and then specify this unique identifier or we can type only the few characters as long as there is no ambiguity so here's the content of our git ignore file as another example let's look at this object this tree the bin directory so git show 64629 here we have a tree in this tree we have this file app.bin so using the show command we can view an object in git's database these objects can be commits blobs which represent files and trees which represent directories as well as tags we'll talk about tags in the future so i told you that you should always review the stuff that you have in the staging area before making a commit so let's say we reviewed these changes and we realized that the changes in file one shouldn't go in the next commit perhaps because these changes are logically part of a different task so we don't want to have a commit that represents changes for different tasks right so in this case we want to undo the add operation because earlier we use the add command to add file 1 to the staging area now we want to undo this operation how do we do this well in the past we used the reset command but a lot of people found this command confusing especially with options such as hard or soft that's why we have a new command called restore now make sure you're using the latest version of git otherwise what i'm going to show you is not going to work on your machine so here i'm using git version 2.28 and with this we can easily restore files in different environments in working directory or in staging area so git restore we want to restore file 1 in the staging area so we type dash dash staged and then we specify the file name we can list multiple files here we can also use patterns or if you want to restore everything in the staging area we simply use a period so here i'm going to restore file1.js now when we run git status again you're not going to see a green m here because all the changes that we had in the staging area are now in the working directory take a look so git status dash s look we no longer have any changes for file one in the staging area all the changes are in the working directory now it's essential for you to understand how the restore command works the restore command essentially takes the copy from the next environment so in case of the staging environment what is the next environment the last commit what we have in the repository so when we restored file one in the staging area git took the last copy of this file from the last snapshot and put it in the staging area that is what happened now look at file two file two is a new file because here we have a green a which is short for added so we have this file we have this new file in the staging area but this file doesn't exist in the last commit so what do you think will happen when i restore this file well because we don't have a copy of this file in our repository or in our last commit git is going to remove this file from the staging area and take it back to its previous state which is a new ontrack file let me show you so git restore dash staged file2.js now let's run git status again so file2 is a new untracked file because we have two question marks there are times that we have some code in our working directory that we want to throw away let's say we made some changes but we didn't like those changes so we want to scratch everything and start over we can discard the local changes using the restore command so here we have some local changes in file1.js to undo these changes we type git restore file1.js when we execute this command git is going to take the version of this file in the next environment which is our staging environment it's going to take that version and copy into our working directory we can also use a period here and this will undo all the local changes now let me show you something so the command is executed now let's run another short status but file two is still here why is that well this is a new on tracked file so git hasn't been tracking this so when we tell git to restore this file git doesn't know where to get a previous version of this file it doesn't exist in our staging environment or in our repository so to remove all these new untracked files we have to type get clean now take a look by default we get this fatal error saying require force defaults to true and neither of these switches were given so basically git is telling us that hey this is a dangerous operation if you accidentally remove these ontrack files there is no way you can recover them so let's run git clean dash for quick help here we have this option dash f which forces git to remove this on track files you also have d for removing whole directories so quite often we type git clean dash fd now let's run short status again file two is gone so this is how we undo local changes so now you know that once git tracks a file it stores every version of that file in its database and that means if you screw things we can always restore a file or a directory to a previous version so in this demo i'm going to delete a file and then show you how to restore it it's very easy so we're going to delete file1.js now i told you that if we use the rm command in linux or unix based systems this will only remove the file from the working directory so then we'll have to stage the change or the deletion a better way is to use the git rm command this will remove the file from both the working directory as well as the staging area okay now let's get a short status so in the staging area we have a deleted file now let's make a commit delete file1.js all right now let's say shoot we shouldn't have deleted this file so what can we do here well we have a few options we can undo or revert the last commit we're going to talk about that later in the course but in this lesson i want to talk about restoring a file to a previous version not on doing a commit so let's look at our history all right so here's our history we want to restore file one to the commit before the last commit that is this comment over here so we type git restore now let's have a quick look at the documentation the restore command takes three types of arguments we can supply a bunch of options we can still play a source we haven't done this so far so by default git will restore that file from the next environment or the next area so if the file you want to restore is in the working directory git will restore it from the staging area and if the file is in the staging area git will restore it from the last snapshot or the last commit now in this case we want to change the default behavior we want to restore a file from the commit before the last one so we type git restore dash source we set it to head tilde 1 and then we specify the full path to the file in this case file1.js now let's get a short status so we have a new untracked file so this is how we can restore a file to a previous version hey guys bosh here as i said before this video is the first hour of my complete git mastery course the complete course is 5 hours long and covers intermediate to advanced level concepts it comes with a certificate of completion downloadable summary notes and a 30day moneyback guarantee so if you're not happy you can ask for a refund you will learn all about browsing history branching and merging collaborating with others using git and github and rewriting history so by the end of this course you would be able to use git like a pro and work effectively with others in your team if you're interested click on the link below this video to enroll
