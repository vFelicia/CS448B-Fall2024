With timestamps:

00:01 - Ok, this is my favorite lecture in this
course, because there are so many blog
00:06 - posts and videos about repositories and many of them conflict with each other
00:09 - which made me confused about the
repository pattern for a long time.
00:13 - So in this lecture, I'm gonna explain clearly
what repository is and what is not
00:19 - why and if we need it and address some
of the misconceptions about repositories.
00:24 - So, what is the repository pattern? I'm
gonna start with a definition from Martin
00:29 - Fowler's book: Patterns of Enterprise
Application Architecture. Repository
00:35 - mediates between the domain and data
mapping layers acting like an in-memory
00:40 - collection of domain objects. I've
highlighted in memory collection in this
00:44 - phrase because that's the key here. So what
are the benefits of the repository
00:49 - pattern? The first one, again, based on
Martin Fowler's book is that it
00:54 - minimizes duplicate query logic. So, imagine
in a few different places in our
00:58 - application we need to get the first
five top-selling courses in a given
01:03 - category. Without the repository pattern, 
we'll end up duplicating this query logic over and
01:09 - over in different places. In situations
like this, we can encapsulate this logic
01:14 - in a repository and simply call a
method like get top-selling courses
01:18 - which takes two parameters: the category
and the number of courses to return. So
01:24 - this is one benefit of the pattern.
Another benefit of the repository
01:29 - pattern is that it decouples your
application from persistence frameworks
01:32 - in this case Entity Framework. So, in the
future if you decide to switch to a
01:37 - different persistence framework you can
do so with minimal impact on the rest of
01:42 - your application. Now the first argument
that comes here is that some developers
01:46 - say: "But who would change the persistence
framework of an application?"
01:50 - Well, let me tell you something. The fact
that this does not happen very often is
01:55 - not because it's not desirable. It's
because most of the time
01:59 - application architectures are so tangled
and tightly coupled to Entity Framework that
02:04 - it doesn't give us the freedom to change
it. A while ago I read somewhere on a
02:09 - blog that on average every two years we
get a new persistence framework
02:13 - and I think that's very true. First we
had ADO.NET so we used SqlConnection
02:18 - and SqlCommand to access
the database. Then, LinqToSql
02:23 - came along but it didn't prove to be
successful.
02:27 - Next, Entity Framework version 1 arrived
which had so many issues. Nearly at the
02:32 - same time
02:33 - NHibernate got popular. Then, after four
versions Entity Framework reached a stage
02:38 - that it was reasonable to be used in
production; but still at this point it
02:42 - had a heavy object model that was not
testable. Then, they introduced a new
02:47 - model DbContext. Now, they're working
on version 7 which is a complete rewrite
02:52 - and there are some breaking changes. Not to
mention that along these lines we have
02:57 - had other persistence frameworks like
Dapper, ORMLite, PetaPocos and so on.
03:03 - So, our persistence frameworks are
constantly changing and evolving and if
03:07 - you want to have the freedom to explore
a different persistence framework with
03:11 - minimal impact on your application
that's when you should use the
03:15 - repository pattern. Now, there is also
another benefit with the repository
03:19 - pattern that some claim: that it makes it
easier to unit test your application but
03:25 - that's partially true and that's if you're
using an older version of Entity Framework
03:29 - with ObjectContext and ObjectSet. The new DbContext and DbSet objects
03:34 - have interfaces that you can mock to
unit test your applications so you don't
03:39 - necessarily need the repository pattern
to unit test your application.
03:43 - Now, the theory behind, what is the repository
in practice? In a nutshell, this is what
03:50 - your repositories should look like. They
should act like a collection of objects
03:54 - in memory. So we have methods to add or
remove an object, get an object by ID, get all
04:01 - objects or find them using a predicate.
Note that here we do not have a method
04:06 - called update because with collections
in memory if we want to update an
04:11 - object, we simply get it from the
collection and change it. We don't tell
04:15 - the collection to update an object and
that's one of the areas that a lot of
04:19 - developers get wrong. A repository should
not have the semantics of your database.
04:24 - It should be like a collection of
objects in memory and shouldn't have
04:29 - methods like Update and Save.
04:30 - Now, with this, the first
question that pops into a lot of
04:35 - people's head, including myself along time
ago, is: "if the repository acts as a
04:40 - collection of objects in memory, how are
we going to save these objects and
04:45 - changes to them to the database?" That's
when the unit of work pattern comes into
04:50 - the picture. A unit of work
04:52 - maintains a list of objects affected by
a business transaction and coordinates
04:57 - the writing out of changes.
05:00 - And this is where things get interesting.
Some developers argue that both the
05:05 - repository and unit of work patterns are
already implemented in entity framework
05:09 - and there's no need to recreate them as
this would lead to unnecessary
05:13 - complexity. Let's see if this argument is
valid.
05:18 - So the argument says that DbSet has a
collection like interface so it has
05:23 - methods like add, remove, find, where and
as you see it doesn't have methods like
05:29 - update and save. So perfect!
05:31 - Also the argument claims that the DbContext
acts as the unit of work. It
05:37 - keeps track of changes in the objects
and coordinates the writing out of
05:41 - changes. As you see here
05:44 - DbContext has references to one or
more DbSets and a save methods actually
05:49 - implemented here, so again it makes sense
because as I explained, the Save method
05:53 - should not be in the repository. Plus,
chances are in a business transaction we
05:59 - may work with more than one repository.
So that's the reason the Save method
06:04 - should be in the unit of work. So it'll
coordinate persisting changes across
06:08 - multiple repositories in one transaction.
06:13 - So, on the surface, yes Entity Framework
DbSets and DbContext indeed look
06:19 - like repositories and unit of work.
But there's a hidden problem here with
06:24 - the implementation of these patterns in
entity framework. Let's review the
06:28 - benefits of the repository pattern again
and see if our DbSets satisfy the
06:33 - definition of repositories. So, a
repository minimizes duplicate query logic
06:39 - and I showed you an example of this before.
Now, the problem with DbSets and LINQ
06:45 - extension methods implemented on them is
that they return IQueryable and this
06:51 - means if you want to get top-selling
courses you will end up repeating this
06:56 - few lines in a few different
places in your application. In fact, in
07:00 - one of the projects I worked on recently,
this was exactly the case. DbContext
07:05 - was everywhere and we had long fat
queries repeated over and over. What you
07:12 - see here is actually a very simple
example. I've seen worse!
07:16 - So, the implementation of DbSet does
not really help with minimizing duplicate
07:20 - query logic. Yes you can argue that we can
use extension methods to encapsulate
07:25 - these logics into a method on a DbSet and
believe me, we had exactly the scenario
07:30 - in that project. In my opinion, this
solution treats the symptoms, not the
07:35 - actual problem. Because even if you use
extension methods, all the existing LINQ
07:41 - extension methods still return
IQueryable, and next time a developer joining
07:47 - your team is going to use them to write
new queries. So in this case
07:51 - ideally we want a repository that has a
method like get top selling courses and all
07:57 - the querying logic is encapsulated their there. DbContext should be a private field
08:02 - in the repository and not exposed to the
outside. It's the implementation detail. Now, the
08:09 - second benefit of repository pattern is
that it decouples your application from
08:13 - persistence frameworks. When you're  using DbContext and DbSets directly in your
08:19 - application, your application is tightly
coupled to Entity Framework if you want
08:24 - to upgrade to a newer version of Entity
Framework with a different model or
08:28 - switch to a different ORM you need to
modify your application code directly.
08:33 - However, if all this is behind a
repository and your application code
08:39 - relies on the repository to return the
right data, it doesn't matter what is
08:44 - inside the repository. Today, you can use
entity framework in a repository, tomorrow
08:49 - you may decide for optimization reasons
to replace it with stored procedures.
08:55 - Your application code will not be
affected in any way. It simply asked the
09:00 - repository to get the data. Repository
does its job. It doesn't matter what is
09:06 - inside a repository, how it's done.
09:08 - Are we using stored procedures, are we using
entity framework, are we using ObjectContext or
09:12 - DbContext or a different ORM, it doesn't
matter. So with all these, in my opinion
09:18 - while DbSet and DbContext in entity 
framework, do look like the implementation
09:23 - of the repository and unit of work,
they don't really bring the architectural
09:27 - benefit that we can get from these
patterns. If you have not read about
09:32 - clean architecture, I highly recommend
you to look it up.
09:35 - Uncle Bob or Robert C Martin has a
beautiful post on the topic, and my
09:40 - favorite line in that post is:
architecture should be independent of
09:44 - frameworks. This allows you to use such
frameworks as tools rather than having
09:50 - to cram your system into their limited
constraints. So that's why using patterns
09:55 - like the repository pattern help you
decouple from frameworks such as entity
09:59 - framework.
10:01 - Now that theory aside, I want you to
think like an engineer. Be pragmatic. Keep
10:07 - it simple. My favorite quote is that
simplicity is the ultimate
10:11 - sophistication. Just adhearing to clean
architecture principles and using all
10:17 - sorts of patterns doesn't necessarily
make you a better coder, neither does it
10:21 - improve the quality of your software. Not
every application needs sophisticated
10:27 - architecture like this! A lot of times
you might be building simple or proof of
10:32 - concept applications for a limited audience.
Please don't do over engineering!
10:38 - A while ago, I worked for five months on an
application where its requirements were
10:42 - rapidly changing and there I didn't use
any of the stuff I talked about
10:47 - in this lecture. I had no repositories, no clean
architecture, no unit testing, not even
10:53 - dependency injection! Because we were not
sure if the application would even make
10:59 - it to the production for financial and
political reasons! And guess what?
11:03 - The application never made it to the
production! So if I spent a lot of time
11:08 - adhering to all these architectural best
practices, I had just wasted my time! It
11:14 - wouldn't bring any values. some developers
simply use patterns without really
11:19 - understanding the problem and this way
they feel good about themselves.
11:23 - My pragmatic suggestion to you is:
use patterns only when you need to.
11:29 - Don't use them as deodorants to
make smelly code smell good. In the
11:33 - next lecture, I'll show you how to implement the
repository and unit of work patterns.
11:38 - I hope you enjoyed this lecture and thank
you for watching. Ok, now let's see how
11:44 - we can implement the repository pattern
with any family Chris I'm going to show
11:49 - you a diagram of the interfaces and
classes and then we'll explore Ducote so
11:54 - to start with we need a repository and
face this interface is like the
12:00 - interface for a collection of objects in
memory so it has methods link had
12:05 - removed get and fined again here we're
not going to have a date or safe mixed
12:12 - going to implement this interface in
class called repository and say this
12:17 - repository gonna have ADB context a
generic Teva context
12:22 - so what you see here is completely
generic it's got nothing to do with our
12:27 - application you can reuse this interface
and a concrete implementation of it in
12:32 - any applications in context of our
application pluto for each kennedy we're
12:39 - gonna have a repository of course any
gonna have an interface called I chorus
12:45 - repository in this interface for going
to define any operations specific
12:51 - courses that are not in our generic
repository for example we can have a
12:57 - method like get top-selling courses or
another method get courses with authors
13:03 - which uses eager loading to load the
courses and their authors so this is one
13:09 - of the key things here
13:11 - anything to do with eager loading or
explicit learning is data access concern
13:15 - you application code your business logic
should not care how this is done this is
13:22 - the implementation dito that's what
happened inside a repository
13:27 - your business logic layer or syria says
simply tell the repository give me
13:31 - courses and their officers and the
repository works out how it should be
13:36 - done now here I cross repository just
declares the contract so we need to
13:42 - implemented in a class like course
repository in this diagram course
13:48 - repository derives from our generic
repository because a lot of our data
13:52 - access Cook is similar but it also
additionally implements I chorus
13:59 - repository interface is going to have
implementations for these two methods
14:04 - you see on the right time
14:06 - next unit so we need an interface like I
unit of work this interface is specific
14:14 - to our application so it's going to
expose various repositories based on the
14:20 - entities we have in our application for
example here we have two properties
14:24 - courses and hospice and two types are I
cross repository and I author repository
14:30 - respectively and know that here we have
a method called complete which indicate
14:36 - the end of a unit of work we could cause
this safe but I personally prefer to
14:42 - call it complete because this is
completion of a unit of work next when
14:48 - it a class to implement that so we're
going to call this unit aware
14:53 - now the sleepover to Visual Studio and
see on these interfaces and
14:57 - implementations in action I'm gonna take
you through every interface and
15:02 - implementation but you can also download
all the source code and the
15:06 - supplementary materials obvious lecter
let's start with I repository
15:15 - ok here's my I repository anaphase know
that this is a generic interface where a
15:22 - TNT is a class some developers like to
have a market in a face like i entity
15:28 - and decorate their domain classes like
course author tank cover and so on that
15:34 - interface and here you could say we're a
TNT is I entity I personally don't quite
15:41 - like market interfaces because it's like
pulling herself it doesn't bring any
15:44 - value anyway here we have three groups
of methods the first group is for
15:50 - finding objects the second group is for
hanging objects and a third group is for
15:55 - removing objects to the first method get
receives and I D and returns on anybody
16:01 - but then I D yes I have get all which
returns on objects and find which takes
16:07 - a pretty kate is predicated is an
expression expression a funk so this
16:14 - means we can use a lambda expression to
filter objects exactly the same way we
16:18 - use that we're method with link
16:22 - next we have which adds one object to
the repository and a drained which adds
16:27 - a list of objects and similarly we have
been removed and remove range so as you
16:33 - see this repository in the face is like
a collection it doesn't have metals like
16:37 - update are safe now let's look at its
implementation
16:47 - here is made
16:49 - of the repository know that it takes a
diva context it is constructor and this
16:55 - is generic it's got nothing to do with
our application so it's not pluto
16:59 - context I have declared this as
protected because indirect classes like
17:05 - course repository or author repository
I'm going to use it
17:13 - now look at get all this method returns
I innumerable it doesn't return
17:19 - IQueryable and that's the key thing here
the repositories should not return
17:24 - IQueryable because this can give the
wrong impression to the upper layers
17:29 - like services or controllers that they
can use desire to build grace which is
17:34 - completely against the idea of using a
repository in the first place the
17:38 - repositories should encapsulate your
queries so you do not repeat them
17:44 - so here in get all I seem to call you
names to return an IEnumerable the
17:50 - implementation of other metals like find
out of range is pretty similar to
17:56 - normandy be context to adding objects or
removing them
18:01 - so nothing special here again you can
download the source code study on your
18:06 - own so I know that this I repository and
its implementation are completely
18:10 - generic they got nothing to do with our
application now let's take a look at the
18:15 - custom repository I'm gonna show you I
course repository
18:23 - so this interface to rise from our
generic repository interface so it's
18:29 - going to inherit all those generic
operations like add range remove get and
18:35 - so on but it also declares two
additional operations get top-selling
18:40 - courses and get courses with authors
again know that both these methods
18:46 - returned IEnumerable to be going to a
second-degree inside the repository and
18:51 - return a list of objects to declined
18:53 - now let's take a look at the
implementation of this interface so this
19:00 - class course repository derives from our
generic repository because we don't want
19:06 - a repeat of that code for adding
removing and getting objects from the
19:10 - repository
19:12 - from repository of course and also
implement high course repository so
19:19 - here's the implementation of the method
in interface now get top-selling courses
19:25 - does not really have the actual
implementation of getting top-selling
19:29 - courses I am doing here for simplicity
is ordering courses by their full price
19:36 - and getting the first few most expensive
courses so this is not really
19:41 - top-selling I did good idea to look at
this
19:46 - method of courses with authors this
method uses eager loading to load
19:52 - courses and their officers so we started
with courses that include also earns an
19:57 - order by skip and take this is for
paging because we have supplied a paging
20:03 - they underpaid size so this is another
technique that you can use these
20:07 - repositories something about a person
they have to use IQueryable so that they
20:12 - can apply filtering in the upper layers
like services of controllers at your
20:17 - filtering four pages shouldn't happen in
those layers its data access code that
20:21 - should happen inside your repositories
so that way to do that is by passing two
20:26 - parameters here page index and paid size
could optionally give this a default
20:31 - value to make calling this method easier
but paid sizes 10 lady 50 here I have
20:38 - declared a property for simplicity this
property is of type lose a context so I
20:47 - am doing he's casting the context that
you're inheriting from the generic
20:52 - repository the base of this class
requesting that too few to context
20:56 - otherwise in every method here I had to
repeat this good chance to context first
21:02 - and then get access to the course is d
be set now
21:08 - at the unit of work so here's my I used
to work in a face note that it hurts
21:19 - from my disposable and exposes two
repositories course repository and
21:26 - author repository a note that both these
are interfaces this is for testability
21:31 - so we can look this interface and its
properties in our unit tests and here's
21:38 - my complete method let's take a look at
the implementation so this unit to work
21:46 - as I said is specific to our application
so it receives Pluta context in the
21:52 - constructor and story in a private field
here and this is the interesting part it
22:00 - uses the same context to initialize both
repositories so the client of unit of
22:07 - work will instantiate a polluter context
and then we'll use this context across
22:15 - all repositories next year is the
implementation of the properties courses
22:22 - and authors we spread declared in our
inner fence incomplete method simply
22:29 - cause the safe changes on the context
and here is the implementation of the
22:34 - disposed method so he simply dispose the
context now
22:40 - can we use all these interfaces and
classes altogether
22:44 - application let me show you an example
so any console
22:51 - with simply have this using block and
inside this block we initialize a
22:55 - journey to work with a new political
context that this is not how you do it
23:01 - in a spin on the name BC or WPF
applications there we don't really use
23:06 - the using block this is just for console
applications will show you how to use
23:11 - this later in asp.net MVC and WPF oK now
let's go through three examples I'm
23:20 - gonna get a course with I D one so I
start with you need to work exactly like
23:26 - how we start with TV context here we
have authors and courses again similar
23:32 - to Dima context the differences is that
of deeply said these properties are
23:38 - repositories and these repositories as I
explained itinerary unelected TV said
23:44 - they know nothing about any framework so
this may be decoupled our application
23:50 - from any family so you directed courses
. get theirs I D that's it
24:02 - another example I wanna get all courses
with their authors so you know that
24:13 - courses and because this is I cross
repository here we have those additional
24:19 - methods that were declared in I cross
repository so get course as with authors
24:24 - first page and debate size is let's say
four
24:32 - so everything you learned in this course
about TV context and dv7 scoring a place
24:39 - here the only difference he's working
with different interfaces that are not
24:43 - part of any family let's go through one
more example
24:51 - hurting the last
24:53 - talked about removing objects you saw
that in order to remove an author and
24:57 - his courses because we didn't have
cascade delete we had to remove the
25:01 - courses first in order to remove the
author someone to remove an author first
25:07 - I need to get it
25:08 - unit of work done on Thurs don't get
author we'd courses so this method was
25:15 - declared in Ohio author repository
25:19 - specific application author with I D one
now I need to delete all his courses so
25:31 - you know where that courses don't remove
range author that courses now I
25:39 - delete the author himself unit I worry
that authors that removed after
25:47 - and finally I need to complete my unit
of work so changes will be saved to the
25:53 - database so you need to work to complete
25:57 - that's how you should use repository and
going to work so you can download the
26:03 - source code stayed on your own and you
have any questions feel free to post
26:07 - them into discussions area in the next
show you how to structure application I
26:12 - hope you enjoy and thank you for
watching

Cleaned transcript:

Ok, this is my favorite lecture in this course, because there are so many blog posts and videos about repositories and many of them conflict with each other which made me confused about the repository pattern for a long time. So in this lecture, I'm gonna explain clearly what repository is and what is not why and if we need it and address some of the misconceptions about repositories. So, what is the repository pattern? I'm gonna start with a definition from Martin Fowler's book Patterns of Enterprise Application Architecture. Repository mediates between the domain and data mapping layers acting like an inmemory collection of domain objects. I've highlighted in memory collection in this phrase because that's the key here. So what are the benefits of the repository pattern? The first one, again, based on Martin Fowler's book is that it minimizes duplicate query logic. So, imagine in a few different places in our application we need to get the first five topselling courses in a given category. Without the repository pattern, we'll end up duplicating this query logic over and over in different places. In situations like this, we can encapsulate this logic in a repository and simply call a method like get topselling courses which takes two parameters the category and the number of courses to return. So this is one benefit of the pattern. Another benefit of the repository pattern is that it decouples your application from persistence frameworks in this case Entity Framework. So, in the future if you decide to switch to a different persistence framework you can do so with minimal impact on the rest of your application. Now the first argument that comes here is that some developers say "But who would change the persistence framework of an application?" Well, let me tell you something. The fact that this does not happen very often is not because it's not desirable. It's because most of the time application architectures are so tangled and tightly coupled to Entity Framework that it doesn't give us the freedom to change it. A while ago I read somewhere on a blog that on average every two years we get a new persistence framework and I think that's very true. First we had ADO.NET so we used SqlConnection and SqlCommand to access the database. Then, LinqToSql came along but it didn't prove to be successful. Next, Entity Framework version 1 arrived which had so many issues. Nearly at the same time NHibernate got popular. Then, after four versions Entity Framework reached a stage that it was reasonable to be used in production; but still at this point it had a heavy object model that was not testable. Then, they introduced a new model DbContext. Now, they're working on version 7 which is a complete rewrite and there are some breaking changes. Not to mention that along these lines we have had other persistence frameworks like Dapper, ORMLite, PetaPocos and so on. So, our persistence frameworks are constantly changing and evolving and if you want to have the freedom to explore a different persistence framework with minimal impact on your application that's when you should use the repository pattern. Now, there is also another benefit with the repository pattern that some claim that it makes it easier to unit test your application but that's partially true and that's if you're using an older version of Entity Framework with ObjectContext and ObjectSet. The new DbContext and DbSet objects have interfaces that you can mock to unit test your applications so you don't necessarily need the repository pattern to unit test your application. Now, the theory behind, what is the repository in practice? In a nutshell, this is what your repositories should look like. They should act like a collection of objects in memory. So we have methods to add or remove an object, get an object by ID, get all objects or find them using a predicate. Note that here we do not have a method called update because with collections in memory if we want to update an object, we simply get it from the collection and change it. We don't tell the collection to update an object and that's one of the areas that a lot of developers get wrong. A repository should not have the semantics of your database. It should be like a collection of objects in memory and shouldn't have methods like Update and Save. Now, with this, the first question that pops into a lot of people's head, including myself along time ago, is "if the repository acts as a collection of objects in memory, how are we going to save these objects and changes to them to the database?" That's when the unit of work pattern comes into the picture. A unit of work maintains a list of objects affected by a business transaction and coordinates the writing out of changes. And this is where things get interesting. Some developers argue that both the repository and unit of work patterns are already implemented in entity framework and there's no need to recreate them as this would lead to unnecessary complexity. Let's see if this argument is valid. So the argument says that DbSet has a collection like interface so it has methods like add, remove, find, where and as you see it doesn't have methods like update and save. So perfect! Also the argument claims that the DbContext acts as the unit of work. It keeps track of changes in the objects and coordinates the writing out of changes. As you see here DbContext has references to one or more DbSets and a save methods actually implemented here, so again it makes sense because as I explained, the Save method should not be in the repository. Plus, chances are in a business transaction we may work with more than one repository. So that's the reason the Save method should be in the unit of work. So it'll coordinate persisting changes across multiple repositories in one transaction. So, on the surface, yes Entity Framework DbSets and DbContext indeed look like repositories and unit of work. But there's a hidden problem here with the implementation of these patterns in entity framework. Let's review the benefits of the repository pattern again and see if our DbSets satisfy the definition of repositories. So, a repository minimizes duplicate query logic and I showed you an example of this before. Now, the problem with DbSets and LINQ extension methods implemented on them is that they return IQueryable and this means if you want to get topselling courses you will end up repeating this few lines in a few different places in your application. In fact, in one of the projects I worked on recently, this was exactly the case. DbContext was everywhere and we had long fat queries repeated over and over. What you see here is actually a very simple example. I've seen worse! So, the implementation of DbSet does not really help with minimizing duplicate query logic. Yes you can argue that we can use extension methods to encapsulate these logics into a method on a DbSet and believe me, we had exactly the scenario in that project. In my opinion, this solution treats the symptoms, not the actual problem. Because even if you use extension methods, all the existing LINQ extension methods still return IQueryable, and next time a developer joining your team is going to use them to write new queries. So in this case ideally we want a repository that has a method like get top selling courses and all the querying logic is encapsulated their there. DbContext should be a private field in the repository and not exposed to the outside. It's the implementation detail. Now, the second benefit of repository pattern is that it decouples your application from persistence frameworks. When you're using DbContext and DbSets directly in your application, your application is tightly coupled to Entity Framework if you want to upgrade to a newer version of Entity Framework with a different model or switch to a different ORM you need to modify your application code directly. However, if all this is behind a repository and your application code relies on the repository to return the right data, it doesn't matter what is inside the repository. Today, you can use entity framework in a repository, tomorrow you may decide for optimization reasons to replace it with stored procedures. Your application code will not be affected in any way. It simply asked the repository to get the data. Repository does its job. It doesn't matter what is inside a repository, how it's done. Are we using stored procedures, are we using entity framework, are we using ObjectContext or DbContext or a different ORM, it doesn't matter. So with all these, in my opinion while DbSet and DbContext in entity framework, do look like the implementation of the repository and unit of work, they don't really bring the architectural benefit that we can get from these patterns. If you have not read about clean architecture, I highly recommend you to look it up. Uncle Bob or Robert C Martin has a beautiful post on the topic, and my favorite line in that post is architecture should be independent of frameworks. This allows you to use such frameworks as tools rather than having to cram your system into their limited constraints. So that's why using patterns like the repository pattern help you decouple from frameworks such as entity framework. Now that theory aside, I want you to think like an engineer. Be pragmatic. Keep it simple. My favorite quote is that simplicity is the ultimate sophistication. Just adhearing to clean architecture principles and using all sorts of patterns doesn't necessarily make you a better coder, neither does it improve the quality of your software. Not every application needs sophisticated architecture like this! A lot of times you might be building simple or proof of concept applications for a limited audience. Please don't do over engineering! A while ago, I worked for five months on an application where its requirements were rapidly changing and there I didn't use any of the stuff I talked about in this lecture. I had no repositories, no clean architecture, no unit testing, not even dependency injection! Because we were not sure if the application would even make it to the production for financial and political reasons! And guess what? The application never made it to the production! So if I spent a lot of time adhering to all these architectural best practices, I had just wasted my time! It wouldn't bring any values. some developers simply use patterns without really understanding the problem and this way they feel good about themselves. My pragmatic suggestion to you is use patterns only when you need to. Don't use them as deodorants to make smelly code smell good. In the next lecture, I'll show you how to implement the repository and unit of work patterns. I hope you enjoyed this lecture and thank you for watching. Ok, now let's see how we can implement the repository pattern with any family Chris I'm going to show you a diagram of the interfaces and classes and then we'll explore Ducote so to start with we need a repository and face this interface is like the interface for a collection of objects in memory so it has methods link had removed get and fined again here we're not going to have a date or safe mixed going to implement this interface in class called repository and say this repository gonna have ADB context a generic Teva context so what you see here is completely generic it's got nothing to do with our application you can reuse this interface and a concrete implementation of it in any applications in context of our application pluto for each kennedy we're gonna have a repository of course any gonna have an interface called I chorus repository in this interface for going to define any operations specific courses that are not in our generic repository for example we can have a method like get topselling courses or another method get courses with authors which uses eager loading to load the courses and their authors so this is one of the key things here anything to do with eager loading or explicit learning is data access concern you application code your business logic should not care how this is done this is the implementation dito that's what happened inside a repository your business logic layer or syria says simply tell the repository give me courses and their officers and the repository works out how it should be done now here I cross repository just declares the contract so we need to implemented in a class like course repository in this diagram course repository derives from our generic repository because a lot of our data access Cook is similar but it also additionally implements I chorus repository interface is going to have implementations for these two methods you see on the right time next unit so we need an interface like I unit of work this interface is specific to our application so it's going to expose various repositories based on the entities we have in our application for example here we have two properties courses and hospice and two types are I cross repository and I author repository respectively and know that here we have a method called complete which indicate the end of a unit of work we could cause this safe but I personally prefer to call it complete because this is completion of a unit of work next when it a class to implement that so we're going to call this unit aware now the sleepover to Visual Studio and see on these interfaces and implementations in action I'm gonna take you through every interface and implementation but you can also download all the source code and the supplementary materials obvious lecter let's start with I repository ok here's my I repository anaphase know that this is a generic interface where a TNT is a class some developers like to have a market in a face like i entity and decorate their domain classes like course author tank cover and so on that interface and here you could say we're a TNT is I entity I personally don't quite like market interfaces because it's like pulling herself it doesn't bring any value anyway here we have three groups of methods the first group is for finding objects the second group is for hanging objects and a third group is for removing objects to the first method get receives and I D and returns on anybody but then I D yes I have get all which returns on objects and find which takes a pretty kate is predicated is an expression expression a funk so this means we can use a lambda expression to filter objects exactly the same way we use that we're method with link next we have which adds one object to the repository and a drained which adds a list of objects and similarly we have been removed and remove range so as you see this repository in the face is like a collection it doesn't have metals like update are safe now let's look at its implementation here is made of the repository know that it takes a diva context it is constructor and this is generic it's got nothing to do with our application so it's not pluto context I have declared this as protected because indirect classes like course repository or author repository I'm going to use it now look at get all this method returns I innumerable it doesn't return IQueryable and that's the key thing here the repositories should not return IQueryable because this can give the wrong impression to the upper layers like services or controllers that they can use desire to build grace which is completely against the idea of using a repository in the first place the repositories should encapsulate your queries so you do not repeat them so here in get all I seem to call you names to return an IEnumerable the implementation of other metals like find out of range is pretty similar to normandy be context to adding objects or removing them so nothing special here again you can download the source code study on your own so I know that this I repository and its implementation are completely generic they got nothing to do with our application now let's take a look at the custom repository I'm gonna show you I course repository so this interface to rise from our generic repository interface so it's going to inherit all those generic operations like add range remove get and so on but it also declares two additional operations get topselling courses and get courses with authors again know that both these methods returned IEnumerable to be going to a seconddegree inside the repository and return a list of objects to declined now let's take a look at the implementation of this interface so this class course repository derives from our generic repository because we don't want a repeat of that code for adding removing and getting objects from the repository from repository of course and also implement high course repository so here's the implementation of the method in interface now get topselling courses does not really have the actual implementation of getting topselling courses I am doing here for simplicity is ordering courses by their full price and getting the first few most expensive courses so this is not really topselling I did good idea to look at this method of courses with authors this method uses eager loading to load courses and their officers so we started with courses that include also earns an order by skip and take this is for paging because we have supplied a paging they underpaid size so this is another technique that you can use these repositories something about a person they have to use IQueryable so that they can apply filtering in the upper layers like services of controllers at your filtering four pages shouldn't happen in those layers its data access code that should happen inside your repositories so that way to do that is by passing two parameters here page index and paid size could optionally give this a default value to make calling this method easier but paid sizes 10 lady 50 here I have declared a property for simplicity this property is of type lose a context so I am doing he's casting the context that you're inheriting from the generic repository the base of this class requesting that too few to context otherwise in every method here I had to repeat this good chance to context first and then get access to the course is d be set now at the unit of work so here's my I used to work in a face note that it hurts from my disposable and exposes two repositories course repository and author repository a note that both these are interfaces this is for testability so we can look this interface and its properties in our unit tests and here's my complete method let's take a look at the implementation so this unit to work as I said is specific to our application so it receives Pluta context in the constructor and story in a private field here and this is the interesting part it uses the same context to initialize both repositories so the client of unit of work will instantiate a polluter context and then we'll use this context across all repositories next year is the implementation of the properties courses and authors we spread declared in our inner fence incomplete method simply cause the safe changes on the context and here is the implementation of the disposed method so he simply dispose the context now can we use all these interfaces and classes altogether application let me show you an example so any console with simply have this using block and inside this block we initialize a journey to work with a new political context that this is not how you do it in a spin on the name BC or WPF applications there we don't really use the using block this is just for console applications will show you how to use this later in asp.net MVC and WPF oK now let's go through three examples I'm gonna get a course with I D one so I start with you need to work exactly like how we start with TV context here we have authors and courses again similar to Dima context the differences is that of deeply said these properties are repositories and these repositories as I explained itinerary unelected TV said they know nothing about any framework so this may be decoupled our application from any family so you directed courses . get theirs I D that's it another example I wanna get all courses with their authors so you know that courses and because this is I cross repository here we have those additional methods that were declared in I cross repository so get course as with authors first page and debate size is let's say four so everything you learned in this course about TV context and dv7 scoring a place here the only difference he's working with different interfaces that are not part of any family let's go through one more example hurting the last talked about removing objects you saw that in order to remove an author and his courses because we didn't have cascade delete we had to remove the courses first in order to remove the author someone to remove an author first I need to get it unit of work done on Thurs don't get author we'd courses so this method was declared in Ohio author repository specific application author with I D one now I need to delete all his courses so you know where that courses don't remove range author that courses now I delete the author himself unit I worry that authors that removed after and finally I need to complete my unit of work so changes will be saved to the database so you need to work to complete that's how you should use repository and going to work so you can download the source code stayed on your own and you have any questions feel free to post them into discussions area in the next show you how to structure application I hope you enjoy and thank you for watching
