With timestamps:

00:01 - in this video you're going to learn
00:02 - everything you need to know about
00:03 - exception handling in java so by the end
00:06 - of this video you'll be able to write
00:08 - java code with confidence hi i'm adani
00:11 - and i've taught millions of people how
00:13 - to code through this channel and my
00:15 - online school codewoodmash.com this
00:17 - video is part of my ultimate java
00:19 - mastery course so once you finish this
00:21 - video if you want to learn more you may
00:23 - want to look at the complete course now
00:25 - let's jump in and get started
00:32 - let's start this section by quick
00:34 - overview of exceptions first of all i'm
00:36 - going to add a package in this project
00:38 - i'm going to write all the code for this
00:40 - section in this package so let's add a
00:43 - new package
00:44 - called
00:45 - exceptions
00:47 - as you can see i've created packages for
00:49 - the other sections of this course you
00:50 - can find all these packages and all
00:52 - these files in the zip file that i gave
00:54 - you at the beginning of the course
00:56 - now in the exceptions package i'm going
00:58 - to add a new class called exceptions
01:01 - demo this is where i'm going to
01:03 - demonstrate concepts
01:05 - here i'm going to add a public static
01:08 - void method called show i made it static
01:11 - so we can call it easily from the main
01:12 - method without having to create an
01:15 - object okay
01:16 - now let's go to the main method
01:19 - and call exceptions demo
01:21 - dot show
01:24 - now back to the demo class i'm going to
01:27 - create another static method public
01:29 - static void say hello
01:32 - we give it a parameter of type string
01:34 - called name
01:36 - and here we want to print name
01:38 - in uppercase pretty straightforward
01:41 - now in the show method i'm going to call
01:44 - the say hello method and pass null which
01:46 - represents the absence of a value
01:49 - now when i run this program our program
01:51 - is going to crash let me show you
01:55 - so our program crashed without an
01:57 - exception or an exceptional event and
02:00 - the type of this exception is null
02:02 - pointer exception this is the root cause
02:04 - of many problems in java programs
02:06 - now this null.exception is a class that
02:09 - is declared in this package java.lang
02:12 - so an exception is an object that
02:15 - contains information about an error in
02:17 - this case this object is an instance of
02:20 - the null pointerexception class now we
02:22 - have several exception classes in java
02:24 - and you'll learn about them as we go
02:26 - through the section
02:27 - now let's see where this exception
02:29 - occurs in our program
02:30 - we got this exception
02:32 - in the say hello method on line 9 of
02:35 - this file
02:36 - if we click we can go to the offending
02:38 - line so this happened when we tried to
02:41 - call the two uppercase method or no that
02:44 - is why we got a null pointer exception
02:46 - now how did we get here we got here from
02:49 - the show method
02:50 - on this line
02:52 - okay but how did we get to the show
02:53 - method we got here from the main method
02:56 - so this information that we have here is
02:59 - called the stack trace it shows the
03:01 - methods that have been called in the
03:03 - reverse order and this is very useful
03:05 - when troubleshooting problems we can see
03:07 - exactly how we got to the offending code
03:09 - now back to our say hello method when an
03:13 - exception occurs in a method we say that
03:15 - method through an exception just like
03:17 - how a person can throw a ball a method
03:20 - can throw an exception
03:21 - now when this happens the java runtime
03:24 - looks for a block of code in that method
03:26 - for handling that exception we refer to
03:28 - that as an exception handler in this
03:30 - implementation we don't have any
03:32 - exception handling code i will show you
03:34 - how to add that later so the java
03:36 - runtime looks for an exception handler
03:38 - in this method if it doesn't find it it
03:40 - goes to the previous method
03:42 - that is the show method here
03:44 - again we don't have any exception
03:46 - handling code here so the java runtime
03:48 - goes back to the main method
03:51 - hoping to find an exception handler we
03:53 - don't have one here so that is why the
03:55 - java runtime terminates our program and
03:57 - displays the exception
03:59 - now as a good java developer you should
04:01 - prevent such exceptions from happening
04:03 - or anticipate and handle them properly
04:06 - and that's what you're going to learn in
04:08 - this section in the next video we're
04:10 - going to talk about the different types
04:11 - of exceptions
04:15 - [Music]
04:19 - in java we have three types of
04:20 - exceptions
04:21 - checked exceptions unchecked exceptions
04:24 - also called runtime exceptions and
04:26 - errors a lot of people new to java find
04:28 - this confusing so let me make it super
04:31 - simple for you check the exceptions are
04:33 - exceptions that we developers should
04:34 - anticipate and handle properly for
04:37 - example let's say we want to read data
04:39 - from a file what if the file doesn't
04:41 - exist maybe it got deleted just before
04:43 - we tried to open it for reading good
04:45 - developers always anticipate and handle
04:48 - these edge cases so instead of letting
04:50 - the runtime terminate our program we
04:52 - would better display a friendly message
04:53 - to the user saying hey that file doesn't
04:56 - exist
04:57 - now the good news is that the java
04:58 - compiler enforces us to handle these
05:01 - errors that is why they're called
05:03 - checked exceptions because they get
05:05 - checked at compile time let me show you
05:08 - let's create a new file reader for
05:09 - reading data from a file so
05:12 - reader equals new file reader
05:16 - let's say file.txt
05:18 - now look at this read underline the java
05:20 - compiler knows that the constructor of
05:22 - the file reader will throw an exception
05:25 - if the file doesn't exist so it's
05:27 - telling us hey you haven't handled this
05:29 - exception file not found exception this
05:32 - is an example of a checked exception so
05:34 - checked exceptions are exceptions that
05:36 - we should anticipate and recover from
05:38 - and that is why they're called checked
05:40 - exceptions because the java compiler
05:42 - checks them at compile time now the
05:44 - second type of exception is called
05:46 - unchecked exception or runtime exception
05:49 - as the name implies these exceptions are
05:51 - not checked by the compiler at compile
05:53 - time they occur because of programming
05:55 - errors node pointer exemption is an
05:57 - example of a runtime exception
06:00 - in the last video we shouldn't have
06:01 - passed null to the say hello method this
06:03 - is a programming error so unlike checked
06:06 - exceptions we don't want to anticipate
06:08 - and recover by displaying a friendly
06:10 - message like hey we made a mistake and
06:12 - try to use an object reference with the
06:14 - null value doesn't make sense
06:17 - instead we should prevent exceptions
06:18 - like this from happening in the first
06:20 - place how can we do that by good coding
06:22 - practices and testing a lot of testing
06:25 - preferably automated testing that's a
06:27 - topic for an entirely different course
06:29 - now other examples of runtime exceptions
06:32 - are arithmetic exception this gets
06:34 - thrown if we try to divide a value by
06:36 - zero we also have illegal argument
06:39 - exception for indicating that the
06:41 - argument we passed to a method was not
06:43 - accepted
06:44 - again this is a programming mistake not
06:46 - a kind of error that we should
06:47 - anticipate and validate another runtime
06:50 - exception you may see is the index out
06:52 - of bounds exception which occurs if we
06:55 - try to access an element in an array or
06:57 - a string or a list using an invalid
06:59 - index for example we have five elements
07:02 - in an array but we try to access the
07:03 - tenth element another popular runtime
07:06 - exception is illegal set exception which
07:08 - gets thrown if we try to call a method
07:11 - but the underlying object is not in the
07:13 - right state so these are runtime
07:15 - exceptions
07:16 - the third type of exception we have in
07:18 - java is an error which indicates an
07:20 - error external to our application
07:22 - examples are stack overflow error or out
07:25 - of memory error so if the java virtual
07:28 - machine runs out of memory there's
07:29 - nothing we can do about it so just like
07:32 - runtime exceptions we should let the
07:33 - application crash rather than display a
07:36 - friendly message to the user we should
07:37 - try to identify the source of these
07:39 - errors these errors can happen because
07:41 - of programming errors like an infinite
07:43 - recursion or for reasons outside of our
07:45 - application like a problem in the java
07:48 - virtual machine itself
07:49 - next we're going to look at the
07:50 - hierarchy of exception classes in java
07:56 - [Music]
08:00 - now let's look at the classes that
08:01 - represent different types of exceptions
08:04 - at the top of the exceptions hierarchy
08:05 - we have the throwable class which
08:07 - defines the common characteristics for
08:10 - all exceptions and errors like an error
08:12 - message and the stack trace so every
08:14 - kind of exception or error has an error
08:16 - message and a stack trace
08:18 - below this class we have two classes
08:20 - exception and error the error class and
08:23 - all its subtypes represent errors that
08:25 - are external to our application like out
08:27 - of memory error the exception class is
08:30 - the parent for all checked and unchecked
08:32 - exceptions below this class we have the
08:35 - runtime exception class which represents
08:37 - runtime or unchecked exceptions so if an
08:40 - exception class derives from the runtime
08:42 - exception it's considered an unchecked
08:44 - exception otherwise it's a checked
08:46 - exception i know this is a bit weird
08:49 - because we might think that any classes
08:50 - that derive from the exception class is
08:52 - a checked exception so runtime exception
08:55 - should also be a checked exception but
08:56 - that's not how it works why honestly i
08:59 - have no clue you have to ask the
09:01 - developers of java so let's quickly
09:03 - explore this hierarchy in java
09:05 - documentation
09:06 - so we search for java null pointer
09:09 - exception
09:13 - here's a documentation
09:15 - on oracle.com
09:17 - all right look at the exception
09:19 - hierarchy so here we have the putter
09:21 - exception this class derives from the
09:23 - runtime exception which derives from the
09:26 - exception class which in turn derives
09:28 - from the throwable and as you can see
09:30 - the object class is the parent of all
09:33 - classes in java now if you're curious
09:36 - what other runtime exceptions we have
09:38 - you can go here
09:39 - and
09:40 - under direct known subclasses you can
09:43 - see all types of runtime exceptions
09:46 - now you don't really need to learn about
09:47 - each of these individually you will get
09:49 - to know them as you build java
09:51 - applications some of them may never
09:52 - occur to you so don't worry about
09:54 - learning all types of exceptions in java
09:57 - next i'm going to show you how to handle
09:59 - exceptions
10:03 - [Music]
10:07 - now let's see how we can cache
10:08 - exceptions so let's create a file reader
10:10 - object
10:12 - reader we set it to a new file reader
10:15 - and here we type
10:16 - file.txt the name doesn't matter now
10:19 - right after this line
10:21 - we print a message like file open
10:24 - now we have a compilation error because
10:26 - we haven't handled the file not found
10:28 - exception
10:29 - to do this we should wrap this code
10:31 - inside a try block so we type try
10:34 - followed by curly braces to indicate a
10:36 - block of code
10:38 - then we move these lines inside this try
10:41 - block
10:42 - now right after the try block we type
10:45 - the catch clause and here in parenthesis
10:47 - we specify the type of exception we want
10:50 - to catch in this case file not found
10:52 - exception
10:54 - then we give it a name
10:56 - by convention we call this object x as
10:59 - in short for exception so this x object
11:02 - is an instance of the file not found
11:04 - exception it's an object that contains
11:06 - information about this exception
11:09 - so
11:10 - here we add another block and in this
11:12 - block we print a friendly message to the
11:14 - user
11:15 - something like file does not exist
11:19 - now let's run the program
11:23 - our program didn't crash this is the
11:25 - proper way to handle checked exceptions
11:28 - now
11:29 - we can also get the message from this
11:31 - exception object so
11:33 - we type x dot get message this returns a
11:37 - string so we can print it on the
11:38 - terminal
11:40 - file.txt no such file or directory this
11:44 - error message is defined in the file not
11:46 - found exception class okay
11:48 - now
11:50 - what happened
11:52 - to this statement over here we tried to
11:54 - print file open but we are not seeing
11:56 - that message here's the reason
11:59 - when the line throws an exception the
12:01 - control moves to the catch block for
12:04 - that exception
12:05 - so the code that we have after the
12:07 - offending line will not be executed
12:10 - however if i take this line and put it
12:12 - after our try catch block
12:15 - it will get executed take a look
12:20 - so now we have file open
12:22 - so this is how we can catch exceptions
12:24 - in java now let me show you a trick
12:27 - i'm going to take this line out of our
12:28 - try block
12:30 - put it over here
12:32 - and then delete the rest of this code so
12:34 - let's say you're creating a file reader
12:37 - object and the compiler is complaining
12:39 - that we haven't handled this checked
12:41 - exception now we don't have to manually
12:43 - type a try catch block we can put the
12:46 - carrot over here
12:47 - press alt on enter and select surround
12:51 - with try catch
12:53 - isn't that beautiful so intellij
12:55 - automatically created this try catch
12:57 - block for us
12:59 - now here we're calling the print stack
13:01 - trace method of this exception object
13:03 - this will show us something like what
13:05 - you saw before
13:07 - so we got an exception of type file not
13:10 - found exception here is the error
13:11 - associated with this exception now look
13:13 - at the stack trace
13:15 - this exception was thrown
13:17 - from the file input stream class this is
13:19 - a part of our project this is part of
13:21 - the standard java library
13:24 - so in our show method when we try to
13:26 - create a new file reader
13:28 - the constructor of the file reader was
13:30 - called and then internally this class
13:32 - works with another class called file
13:34 - input stream here we have a few method
13:36 - calls and this is where
13:39 - the exception was thrown
13:41 - so sometimes you see a long stack trace
13:43 - because of the method calls in the java
13:45 - standard library or other libraries that
13:47 - you use
13:48 - next we're going to talk about catching
13:50 - multiple types of exceptions
13:55 - [Music]
13:59 - sometimes we need to catch multiple
14:00 - types of exceptions
14:02 - for example after reading a file
14:04 - let's call
14:06 - reader.read
14:07 - this reads one character and returns its
14:09 - numeric value so let's store it in a
14:12 - variable called value
14:14 - here we have another compilation error
14:17 - because we haven't handled the i o
14:19 - exception so this read method may throw
14:21 - an i o exception if it cannot read data
14:24 - from this file to solve this problem we
14:26 - need to type another catch clause here
14:28 - so catch like here we want to catch an
14:31 - io exception we give it a name
14:34 - and in this block we can print a message
14:37 - like could not
14:39 - read data
14:41 - the exception is gone
14:43 - now we have multiple catch blocks and
14:45 - each cache block
14:47 - targets a specific type of exception so
14:50 - only one of these will be executed
14:53 - in this case we try to open a file that
14:56 - doesn't exist so this line will throw a
14:58 - file not found exception
15:00 - and this catch block will catch that
15:03 - exception
15:04 - now the code inside this catch block
15:06 - will get executed and after that the
15:08 - control will move over here
15:11 - so the second catch block will get
15:13 - ignored okay so we have multiple catch
15:15 - blocks and each catch block targets a
15:18 - specific type of exception
15:20 - now does the order of these cache blocks
15:22 - matter
15:22 - sometimes it does
15:24 - so if i move this catch block over here
15:28 - you see a compilation error the java
15:30 - compiler is saying that we have already
15:32 - caught the find not found exception what
15:34 - does this mean
15:36 - well let's look at the documentation for
15:38 - the find not found exception class
15:40 - so we type java file not found exception
15:46 - here it is
15:49 - okay so this class extends the i o
15:52 - exception class and that means if we
15:55 - have a catch clause for an i o exception
15:58 - we don't need this find not found
16:00 - exception
16:02 - this is the polymorphism principle of
16:04 - object-oriented programming we talked
16:05 - about this in the second part of this
16:07 - course let me show you if i have a
16:09 - variable of type i o exception let's
16:11 - call it x
16:13 - i can set this variable to a new
16:15 - instance of our exception or any classes
16:18 - that extend the io exception class so we
16:21 - can set this to a new file not found
16:24 - exception
16:26 - this is polymorphism an object may take
16:29 - different forms
16:30 - so
16:32 - if you have a catch clause
16:34 - to catch an i o exception this catch
16:36 - clause can catch an i o exception or any
16:39 - of its derivatives any classes that
16:41 - extend the i o exception class okay
16:44 - now sometimes we want to treat these
16:45 - exceptions the same way for example here
16:48 - we can display a generic error message
16:50 - but other times we want to handle them
16:52 - differently
16:53 - if that is the case then we need to
16:55 - bring back this catch clause and put it
16:58 - before the first catch clause so now if
17:01 - we get a find not found exception we can
17:04 - print a message like file does not exist
17:08 - so we are giving the user a more
17:10 - specific error message okay
17:12 - now
17:13 - as another example
17:15 - let's create a new
17:17 - simple date format object
17:20 - and call the parse method
17:23 - now here we have another compilation
17:25 - error because this parse method may
17:26 - throw an exception
17:28 - of type parse exception
17:30 - now we can put the carrot over here
17:32 - press alt on enter and have intellij add
17:35 - a catch clause for us
17:37 - there you go so it's right here
17:40 - now we have three catch clauses let's
17:43 - say we want to treat all of these the
17:45 - same way so first we can get rid of the
17:47 - file not found exception
17:49 - now we have two catch clauses we can
17:52 - combine this using a vertical bar so
17:54 - right after i o exception we type a
17:56 - vertical bar then we type parse
17:59 - exception
18:00 - and with this we don't need the second
18:02 - catch clause
18:05 - so this block can catch exceptions of
18:08 - type i o exception or parse exception
18:11 - so these are different ways to catch
18:13 - multiple exceptions the approach you
18:15 - take really depends on your application
18:16 - and its requirements next we're going to
18:19 - talk about the final block
18:24 - [Music]
18:28 - let's imagine this file exists so we
18:30 - successfully open it for reading but
18:32 - something goes wrong when we try to read
18:34 - data from this file this could happen
18:36 - because of a hardware problem now we
18:38 - have a problem in this code the problem
18:41 - is that we have opened this file for
18:43 - reading but nowhere we have closed it
18:46 - file handles are operating system
18:47 - resources so whenever we get them we
18:49 - shall always release them otherwise
18:52 - other processes may not be able to
18:54 - access these resources so somewhere in
18:56 - this code
18:58 - we should write reader
19:00 - dot close
19:01 - now there is a problem with this
19:02 - implementation can you tell
19:05 - the problem is that if this line throws
19:07 - an exception the runtime will pass the
19:10 - control to this catch block so this line
19:13 - will never get executed now what if we
19:15 - put this line after our try catch block
19:19 - now the reader variable is not
19:20 - recognized because we have declared it
19:23 - inside this try block so it's only
19:25 - accessible in this block but let's not
19:27 - worry about it for a second
19:29 - the problem with this implementation is
19:30 - that sometime in the future
19:33 - another developer might come here and
19:35 - write some extra code and this code may
19:38 - throw an exception again our reader is
19:41 - not going to get closed
19:43 - the proper way to handle this kind of
19:45 - scenarios is to use the final block
19:47 - so right after the catch block we type
19:50 - finally now in this block we can release
19:53 - external resources like file handles
19:56 - database connections network connections
19:58 - and so on
19:59 - so here we should type reader
20:02 - dot close
20:04 - but once again reader is not recognized
20:06 - because
20:07 - it's only accessible in the try block to
20:09 - solve this problem we need to declare
20:11 - this before our try block so
20:14 - we type
20:15 - file reader
20:17 - reader
20:19 - and then set it over here
20:21 - and by the way we cannot use var over
20:23 - here because we can use var only when we
20:25 - set this to a new instance of a class so
20:28 - the compiler knows that this object is
20:31 - an instance of the file reader class in
20:33 - this case
20:34 - we're not initializing this variable so
20:37 - the compiler doesn't know what is the
20:39 - type of this variable okay
20:41 - so
20:42 - let's type file reader
20:44 - now we have a compilation error
20:47 - variable reader might not have been
20:49 - initialized because in java before we
20:51 - can access an object we should always
20:53 - initialize it
20:54 - so if this line
20:56 - doesn't get executed if it throws an
20:58 - exception we'll try to use an
21:00 - uninitialized object
21:02 - to solve this problem we need to
21:04 - explicitly
21:06 - set this to null
21:07 - the compilation error is gone now we
21:09 - have a different kind of error we'll
21:10 - talk about that in a second but first
21:12 - let's add an if statement
21:15 - we want to call the close method only if
21:16 - the reader is not null so if reader
21:20 - is not null
21:22 - then close it
21:23 - but what is this compilation error
21:26 - on handle exception ioexception so the
21:29 - close method may also throw an i o
21:31 - exception
21:33 - to solve this problem we need to wrap
21:35 - this inside the try catch block so we
21:37 - put the carrot over here press alt enter
21:40 - and then surround with try catch
21:44 - so here's the final result
21:46 - now
21:48 - this code looks really ugly i have to
21:50 - admit that we have a much better
21:51 - exception handling structure in c-sharp
21:54 - now that aside what i want you to take
21:56 - away here is that this finite block will
21:59 - always get executed whether we have an
22:01 - exception or not
22:03 - if we don't have an exception all the
22:05 - code inside the try block will get
22:07 - executed and then the runtime will pass
22:09 - control to the final block if one of
22:12 - these lines
22:13 - throws an exception
22:15 - one of our catch blocks will get
22:16 - executed and then the final block will
22:19 - get executed so the final block will
22:22 - always get executed no matter what
22:25 - now this implementation is really ugly
22:27 - in the next video i'm going to show you
22:29 - a better way to release external
22:31 - resources
22:34 - thank you so much for watching this
22:36 - video as i said this video is part of my
22:38 - ultimate java mastery course that
22:40 - teaches you everything you need to know
22:42 - about java from the basics to more
22:44 - advanced concepts so if you want to
22:45 - learn more i highly encourage you to
22:47 - take a full course it's much faster than
22:50 - jumping from one tutorial to another if
22:52 - you're interested the link is below this
22:54 - video thank you and have a great day
23:00 - [Music]

Cleaned transcript:

in this video you're going to learn everything you need to know about exception handling in java so by the end of this video you'll be able to write java code with confidence hi i'm adani and i've taught millions of people how to code through this channel and my online school codewoodmash.com this video is part of my ultimate java mastery course so once you finish this video if you want to learn more you may want to look at the complete course now let's jump in and get started let's start this section by quick overview of exceptions first of all i'm going to add a package in this project i'm going to write all the code for this section in this package so let's add a new package called exceptions as you can see i've created packages for the other sections of this course you can find all these packages and all these files in the zip file that i gave you at the beginning of the course now in the exceptions package i'm going to add a new class called exceptions demo this is where i'm going to demonstrate concepts here i'm going to add a public static void method called show i made it static so we can call it easily from the main method without having to create an object okay now let's go to the main method and call exceptions demo dot show now back to the demo class i'm going to create another static method public static void say hello we give it a parameter of type string called name and here we want to print name in uppercase pretty straightforward now in the show method i'm going to call the say hello method and pass null which represents the absence of a value now when i run this program our program is going to crash let me show you so our program crashed without an exception or an exceptional event and the type of this exception is null pointer exception this is the root cause of many problems in java programs now this null.exception is a class that is declared in this package java.lang so an exception is an object that contains information about an error in this case this object is an instance of the null pointerexception class now we have several exception classes in java and you'll learn about them as we go through the section now let's see where this exception occurs in our program we got this exception in the say hello method on line 9 of this file if we click we can go to the offending line so this happened when we tried to call the two uppercase method or no that is why we got a null pointer exception now how did we get here we got here from the show method on this line okay but how did we get to the show method we got here from the main method so this information that we have here is called the stack trace it shows the methods that have been called in the reverse order and this is very useful when troubleshooting problems we can see exactly how we got to the offending code now back to our say hello method when an exception occurs in a method we say that method through an exception just like how a person can throw a ball a method can throw an exception now when this happens the java runtime looks for a block of code in that method for handling that exception we refer to that as an exception handler in this implementation we don't have any exception handling code i will show you how to add that later so the java runtime looks for an exception handler in this method if it doesn't find it it goes to the previous method that is the show method here again we don't have any exception handling code here so the java runtime goes back to the main method hoping to find an exception handler we don't have one here so that is why the java runtime terminates our program and displays the exception now as a good java developer you should prevent such exceptions from happening or anticipate and handle them properly and that's what you're going to learn in this section in the next video we're going to talk about the different types of exceptions in java we have three types of exceptions checked exceptions unchecked exceptions also called runtime exceptions and errors a lot of people new to java find this confusing so let me make it super simple for you check the exceptions are exceptions that we developers should anticipate and handle properly for example let's say we want to read data from a file what if the file doesn't exist maybe it got deleted just before we tried to open it for reading good developers always anticipate and handle these edge cases so instead of letting the runtime terminate our program we would better display a friendly message to the user saying hey that file doesn't exist now the good news is that the java compiler enforces us to handle these errors that is why they're called checked exceptions because they get checked at compile time let me show you let's create a new file reader for reading data from a file so reader equals new file reader let's say file.txt now look at this read underline the java compiler knows that the constructor of the file reader will throw an exception if the file doesn't exist so it's telling us hey you haven't handled this exception file not found exception this is an example of a checked exception so checked exceptions are exceptions that we should anticipate and recover from and that is why they're called checked exceptions because the java compiler checks them at compile time now the second type of exception is called unchecked exception or runtime exception as the name implies these exceptions are not checked by the compiler at compile time they occur because of programming errors node pointer exemption is an example of a runtime exception in the last video we shouldn't have passed null to the say hello method this is a programming error so unlike checked exceptions we don't want to anticipate and recover by displaying a friendly message like hey we made a mistake and try to use an object reference with the null value doesn't make sense instead we should prevent exceptions like this from happening in the first place how can we do that by good coding practices and testing a lot of testing preferably automated testing that's a topic for an entirely different course now other examples of runtime exceptions are arithmetic exception this gets thrown if we try to divide a value by zero we also have illegal argument exception for indicating that the argument we passed to a method was not accepted again this is a programming mistake not a kind of error that we should anticipate and validate another runtime exception you may see is the index out of bounds exception which occurs if we try to access an element in an array or a string or a list using an invalid index for example we have five elements in an array but we try to access the tenth element another popular runtime exception is illegal set exception which gets thrown if we try to call a method but the underlying object is not in the right state so these are runtime exceptions the third type of exception we have in java is an error which indicates an error external to our application examples are stack overflow error or out of memory error so if the java virtual machine runs out of memory there's nothing we can do about it so just like runtime exceptions we should let the application crash rather than display a friendly message to the user we should try to identify the source of these errors these errors can happen because of programming errors like an infinite recursion or for reasons outside of our application like a problem in the java virtual machine itself next we're going to look at the hierarchy of exception classes in java now let's look at the classes that represent different types of exceptions at the top of the exceptions hierarchy we have the throwable class which defines the common characteristics for all exceptions and errors like an error message and the stack trace so every kind of exception or error has an error message and a stack trace below this class we have two classes exception and error the error class and all its subtypes represent errors that are external to our application like out of memory error the exception class is the parent for all checked and unchecked exceptions below this class we have the runtime exception class which represents runtime or unchecked exceptions so if an exception class derives from the runtime exception it's considered an unchecked exception otherwise it's a checked exception i know this is a bit weird because we might think that any classes that derive from the exception class is a checked exception so runtime exception should also be a checked exception but that's not how it works why honestly i have no clue you have to ask the developers of java so let's quickly explore this hierarchy in java documentation so we search for java null pointer exception here's a documentation on oracle.com all right look at the exception hierarchy so here we have the putter exception this class derives from the runtime exception which derives from the exception class which in turn derives from the throwable and as you can see the object class is the parent of all classes in java now if you're curious what other runtime exceptions we have you can go here and under direct known subclasses you can see all types of runtime exceptions now you don't really need to learn about each of these individually you will get to know them as you build java applications some of them may never occur to you so don't worry about learning all types of exceptions in java next i'm going to show you how to handle exceptions now let's see how we can cache exceptions so let's create a file reader object reader we set it to a new file reader and here we type file.txt the name doesn't matter now right after this line we print a message like file open now we have a compilation error because we haven't handled the file not found exception to do this we should wrap this code inside a try block so we type try followed by curly braces to indicate a block of code then we move these lines inside this try block now right after the try block we type the catch clause and here in parenthesis we specify the type of exception we want to catch in this case file not found exception then we give it a name by convention we call this object x as in short for exception so this x object is an instance of the file not found exception it's an object that contains information about this exception so here we add another block and in this block we print a friendly message to the user something like file does not exist now let's run the program our program didn't crash this is the proper way to handle checked exceptions now we can also get the message from this exception object so we type x dot get message this returns a string so we can print it on the terminal file.txt no such file or directory this error message is defined in the file not found exception class okay now what happened to this statement over here we tried to print file open but we are not seeing that message here's the reason when the line throws an exception the control moves to the catch block for that exception so the code that we have after the offending line will not be executed however if i take this line and put it after our try catch block it will get executed take a look so now we have file open so this is how we can catch exceptions in java now let me show you a trick i'm going to take this line out of our try block put it over here and then delete the rest of this code so let's say you're creating a file reader object and the compiler is complaining that we haven't handled this checked exception now we don't have to manually type a try catch block we can put the carrot over here press alt on enter and select surround with try catch isn't that beautiful so intellij automatically created this try catch block for us now here we're calling the print stack trace method of this exception object this will show us something like what you saw before so we got an exception of type file not found exception here is the error associated with this exception now look at the stack trace this exception was thrown from the file input stream class this is a part of our project this is part of the standard java library so in our show method when we try to create a new file reader the constructor of the file reader was called and then internally this class works with another class called file input stream here we have a few method calls and this is where the exception was thrown so sometimes you see a long stack trace because of the method calls in the java standard library or other libraries that you use next we're going to talk about catching multiple types of exceptions sometimes we need to catch multiple types of exceptions for example after reading a file let's call reader.read this reads one character and returns its numeric value so let's store it in a variable called value here we have another compilation error because we haven't handled the i o exception so this read method may throw an i o exception if it cannot read data from this file to solve this problem we need to type another catch clause here so catch like here we want to catch an io exception we give it a name and in this block we can print a message like could not read data the exception is gone now we have multiple catch blocks and each cache block targets a specific type of exception so only one of these will be executed in this case we try to open a file that doesn't exist so this line will throw a file not found exception and this catch block will catch that exception now the code inside this catch block will get executed and after that the control will move over here so the second catch block will get ignored okay so we have multiple catch blocks and each catch block targets a specific type of exception now does the order of these cache blocks matter sometimes it does so if i move this catch block over here you see a compilation error the java compiler is saying that we have already caught the find not found exception what does this mean well let's look at the documentation for the find not found exception class so we type java file not found exception here it is okay so this class extends the i o exception class and that means if we have a catch clause for an i o exception we don't need this find not found exception this is the polymorphism principle of objectoriented programming we talked about this in the second part of this course let me show you if i have a variable of type i o exception let's call it x i can set this variable to a new instance of our exception or any classes that extend the io exception class so we can set this to a new file not found exception this is polymorphism an object may take different forms so if you have a catch clause to catch an i o exception this catch clause can catch an i o exception or any of its derivatives any classes that extend the i o exception class okay now sometimes we want to treat these exceptions the same way for example here we can display a generic error message but other times we want to handle them differently if that is the case then we need to bring back this catch clause and put it before the first catch clause so now if we get a find not found exception we can print a message like file does not exist so we are giving the user a more specific error message okay now as another example let's create a new simple date format object and call the parse method now here we have another compilation error because this parse method may throw an exception of type parse exception now we can put the carrot over here press alt on enter and have intellij add a catch clause for us there you go so it's right here now we have three catch clauses let's say we want to treat all of these the same way so first we can get rid of the file not found exception now we have two catch clauses we can combine this using a vertical bar so right after i o exception we type a vertical bar then we type parse exception and with this we don't need the second catch clause so this block can catch exceptions of type i o exception or parse exception so these are different ways to catch multiple exceptions the approach you take really depends on your application and its requirements next we're going to talk about the final block let's imagine this file exists so we successfully open it for reading but something goes wrong when we try to read data from this file this could happen because of a hardware problem now we have a problem in this code the problem is that we have opened this file for reading but nowhere we have closed it file handles are operating system resources so whenever we get them we shall always release them otherwise other processes may not be able to access these resources so somewhere in this code we should write reader dot close now there is a problem with this implementation can you tell the problem is that if this line throws an exception the runtime will pass the control to this catch block so this line will never get executed now what if we put this line after our try catch block now the reader variable is not recognized because we have declared it inside this try block so it's only accessible in this block but let's not worry about it for a second the problem with this implementation is that sometime in the future another developer might come here and write some extra code and this code may throw an exception again our reader is not going to get closed the proper way to handle this kind of scenarios is to use the final block so right after the catch block we type finally now in this block we can release external resources like file handles database connections network connections and so on so here we should type reader dot close but once again reader is not recognized because it's only accessible in the try block to solve this problem we need to declare this before our try block so we type file reader reader and then set it over here and by the way we cannot use var over here because we can use var only when we set this to a new instance of a class so the compiler knows that this object is an instance of the file reader class in this case we're not initializing this variable so the compiler doesn't know what is the type of this variable okay so let's type file reader now we have a compilation error variable reader might not have been initialized because in java before we can access an object we should always initialize it so if this line doesn't get executed if it throws an exception we'll try to use an uninitialized object to solve this problem we need to explicitly set this to null the compilation error is gone now we have a different kind of error we'll talk about that in a second but first let's add an if statement we want to call the close method only if the reader is not null so if reader is not null then close it but what is this compilation error on handle exception ioexception so the close method may also throw an i o exception to solve this problem we need to wrap this inside the try catch block so we put the carrot over here press alt enter and then surround with try catch so here's the final result now this code looks really ugly i have to admit that we have a much better exception handling structure in csharp now that aside what i want you to take away here is that this finite block will always get executed whether we have an exception or not if we don't have an exception all the code inside the try block will get executed and then the runtime will pass control to the final block if one of these lines throws an exception one of our catch blocks will get executed and then the final block will get executed so the final block will always get executed no matter what now this implementation is really ugly in the next video i'm going to show you a better way to release external resources thank you so much for watching this video as i said this video is part of my ultimate java mastery course that teaches you everything you need to know about java from the basics to more advanced concepts so if you want to learn more i highly encourage you to take a full course it's much faster than jumping from one tutorial to another if you're interested the link is below this video thank you and have a great day
