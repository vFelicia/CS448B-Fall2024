With timestamps:

00:00 - [Music]
00:01 - in order to build applications with
00:03 - react you should have at least three
00:05 - months of experience programming in
00:07 - JavaScript so in this section I'm going
00:09 - to cover the essential JavaScript
00:11 - features that you're going to use a lot
00:13 - in react applications such as let versus
00:16 - Const P words objects that this keyword
00:19 - and how it behaves differently arrow
00:22 - functions object is structuring the
00:24 - spread operator classes and modules make
00:28 - sure you know all these topics well
00:30 - before going further otherwise you're
00:32 - going to have a lot of difficulty later
00:33 - down the road I just need to clarify
00:35 - that in this section I'm not gonna go
00:37 - really deep in these concepts because
00:40 - this is a react course not a JavaScript
00:42 - course as I told you before I've got two
00:44 - other JavaScript courses for you one is
00:46 - called JavaScript basics for beginners
00:48 - and the other is object-oriented
00:50 - programming in JavaScript the focus of
00:53 - the first course is on the art of
00:54 - problem solving it teaches you how to
00:57 - think like a programmer unfortunately
00:59 - there are a lot of developers out there
01:01 - in the industry who can build
01:02 - applications with angular react and all
01:05 - kinds of fancy frameworks but they
01:07 - cannot solve simple programming problems
01:10 - because there are self-taught
01:11 - programmers they have never attended a
01:13 - college or university they never learned
01:15 - the fundamentals of computer science and
01:18 - software engineering and that's why I've
01:20 - designed this course the focus of the
01:22 - second course is on more advanced topics
01:24 - such as constructor functions objects
01:27 - prototypes inheritance polymorphism
01:30 - classes and more all right that's enough
01:32 - introduction now let's get started
01:36 - [Music]
01:41 - you
01:49 - to demonstrate the modern JavaScript
01:52 - features I'm gonna use a brand new react
01:54 - project so in this project
01:56 - let's open up index j s and delete all
01:59 - the code here and focus on plain vanilla
02:03 - JavaScript so the first thing we're
02:05 - gonna look at are the new keywords for
02:07 - defining variables and constants so
02:10 - let's define a function call it say
02:13 - hello here I'm gonna define a loop so
02:16 - for VAR I we set this to 0 as long as
02:20 - it's less than 5 we increment I and
02:24 - login on the console pretty simple right
02:27 - let's call this function save the
02:30 - changes back in the browser so here we
02:34 - see these numbers 0 to 4 pretty
02:36 - straightforward however there is a
02:38 - problem with the VAR keyword in
02:40 - JavaScript in most programming languages
02:43 - when we declare a variable that variable
02:46 - should only be accessible in the block
02:49 - in which it's defined this is what we
02:51 - call scope right so in this case I
02:53 - should only be accessible inside of the
02:57 - for block however I can come here and
03:01 - log I on the console and you will see
03:04 - that I is still accessible here save the
03:08 - changes
03:08 - back in the browser look we've got I
03:11 - displayed here because in the last
03:13 - iteration I becomes 5 and because 5 is
03:17 - not less than 5 we exit this loop so
03:21 - this is what I want you to take away
03:22 - when you declare a variable with the war
03:25 - keyword that variable is accessible
03:28 - inside of the function in which it's
03:31 - defined and this is one of those weird
03:33 - things about JavaScript that is
03:35 - different from other programming
03:36 - languages so in ECMO script 6 or es6
03:41 - which is the version of JavaScript
03:43 - introduced in year 2015 we got a new
03:46 - keyword for declaring variables and that
03:48 - is let so let came to solve this problem
03:52 - when you declare a variable with the let
03:54 - keyword that variable is only accessible
03:57 - inside of that block let's see the
04:00 - result so same to change us back in the
04:02 - browser
04:03 - now we get this error on the console I
04:05 - is not defined so here's what I want you
04:09 - to take away variables declared with the
04:13 - VAR keyword are scoped to the function
04:16 - whereas variables declared with the let
04:19 - keyword are scoped to the block in which
04:23 - they are defined so going forward you
04:26 - should prefer to use the let keyword
04:28 - unless you have a very valid reason for
04:30 - using the VAR keyword now we also have
04:33 - another new keyword in es6 and that is
04:37 - Const we use cons to define constants
04:41 - I'm going to show you that in a second
04:42 - but similar to let variables defined
04:45 - with Const are also block scoped so they
04:48 - are only accessible inside of the block
04:50 - they are defined now let me show you the
04:52 - difference between let and Const so I'm
04:55 - gonna delete all this code here let's
04:58 - define a variable with Const set it to 1
05:01 - now if we reassign this and save the
05:05 - changes back in the browser you can see
05:07 - that X is read-only in other words when
05:11 - you declare a variable with the Const
05:14 - keyword that variable cannot be
05:16 - reassigned that's why we refer to that
05:18 - as a constant so technically it's not a
05:21 - variable because it cannot change it's a
05:23 - constant so let's quickly wrap up throw
05:27 - away the VAR keyword and prefer to use
05:30 - Const over let use let only when you
05:34 - need to reassign a variable
05:43 - alright now let's take a look at objects
05:46 - so once again I'm gonna use the Const
05:48 - keyword to define a variable well more
05:52 - accurately a constant and set it to an
05:54 - object so as you know objects in
05:57 - JavaScript are collections of key value
06:00 - pairs so I'm gonna add a couple of key
06:02 - value pairs here the first one is name
06:04 - which was set to a string and the second
06:07 - is wok which was set to a function now
06:11 - in object-oriented programming terms if
06:13 - we have a function inside of an object
06:16 - we refer to that function as a method so
06:19 - here we say Walk is a method in the
06:22 - person object now starting from es6
06:25 - there is a cleaner and simpler syntax to
06:28 - define a method in an object so let's
06:30 - add another method here I'm gonna call
06:33 - this talk now here we don't need to add
06:35 - a colon and the function keyword we can
06:38 - define it like this so basically we drop
06:41 - the colon and the function keyword and
06:44 - here's the result so here we have a
06:46 - personal object with three members one
06:49 - property and two methods there are two
06:51 - ways to access these members we can use
06:55 - the dot notation which you are probably
06:56 - familiar with so dot talk or walk we can
07:02 - also use the bracket notation so person
07:05 - we add square brackets pass a string and
07:09 - this string determines the name of the
07:11 - target member so if you want to access
07:14 - the name property we pass that here and
07:17 - now we can reassign that to a different
07:19 - value in terms of practicality we use
07:23 - the bracket notation when we don't know
07:25 - ahead of time what property or method
07:28 - we're going to access let me show you
07:30 - what I mean
07:30 - so I'm going to define a constant call
07:33 - it target member and set it to name
07:38 - imagine this target member is an input
07:42 - field on a form depending on what the
07:45 - user types in that input field we're
07:47 - going to access a different property in
07:49 - this personal object that's when we use
07:52 - the bracket notation so instead of
07:54 - hard-coding name here
07:56 - Pass Target member and once again this
07:59 - could be an input field so we could
08:01 - access the value property like this and
08:03 - then dynamically access a property or a
08:06 - method in an object if we know ahead of
08:09 - time what property or method we're going
08:11 - to access we use the dock notation so we
08:14 - write person dot name we set it to a
08:17 - different value next we're going to look
08:20 - at that this keyword in JavaScript
08:30 - so we have this person object with a
08:33 - walk method now let's modify this method
08:36 - and do a consult that log of this what
08:41 - is this this is a special keyword in
08:44 - JavaScript which confuses a lot of
08:45 - developers because it doesn't behave the
08:48 - same as this in other programming
08:51 - languages like C sharp or Java in this
08:54 - languages this always returns a
08:57 - reference to the current object let me
09:00 - show you so here I'm gonna call person
09:03 - dot walk save the changes back in the
09:07 - browser so we see our personal object on
09:11 - the console so in this case this is
09:15 - returning a reference to this person
09:18 - object right
09:19 - however this in JavaScript does not
09:22 - always work that way let me show you why
09:25 - so I'm gonna define a constant call it
09:29 - walk and set it to person dot walk note
09:34 - that I'm not calling the walk method I'm
09:36 - just getting a reference to this
09:38 - function so walk is now a function let
09:41 - me show you
09:42 - so console the log of walk now back in
09:47 - the browser so you can see our walk
09:50 - constant is set to this function right
09:54 - now let's see what happens when we call
09:57 - this function so I'm gonna call walk
10:02 - save the changes back in the browser
10:05 - what's going on here so we don't get a
10:08 - reference to the person object we get
10:10 - undefined that's why I told you that
10:13 - that this keyword in JavaScript behaves
10:16 - differently from other programming
10:18 - languages the value of this is
10:21 - determined by how a function is called
10:24 - if we call a function as a method in an
10:28 - object this will always return a
10:31 - reference to that object however if we
10:35 - call a function as a standalone object
10:37 - or outside of an object this will return
10:41 - the global object which
10:43 - the window object in browsers but in
10:46 - this particular implementation we didn't
10:49 - see the window object here we got
10:51 - undefined the reason for this is because
10:53 - in this react project the strict mode is
10:56 - enabled by default if you're not
10:59 - familiar with the strict mode it's
11:01 - basically a mode to execute JavaScript
11:03 - code in a more protective way so it
11:06 - prevents potential problems that's why
11:09 - in this case instead of getting a
11:11 - reference to the window object we get
11:13 - undefined
11:22 - so in the last lecture you learned that
11:24 - when we call a function as a standalone
11:27 - function outside of an object this by
11:31 - default returns a reference to the
11:33 - global object which is the window object
11:34 - and if the strict mode is enabled it
11:37 - returns undefined in this lecture I'm
11:40 - gonna show you how to fix this problem
11:42 - so no matter how we call the walk
11:45 - function this will always return a
11:47 - reference to this person object so one
11:52 - thing that might be new to you is that
11:54 - in JavaScript functions are objects so
11:57 - here person dot walk is actually an
12:00 - object don't believe me let me show you
12:02 - so dot look these are all the members of
12:06 - the walk object so every function in
12:09 - JavaScript is an object with these
12:11 - members we've got this method here bind
12:15 - and we can use this method to bind a
12:18 - function to an object what do you mean
12:21 - by this so when we call this note the
12:24 - first argument is called this auric what
12:28 - we pass here as an argument will
12:30 - determine the value of this in this case
12:33 - if I pass this person object here the
12:39 - point method will return a new instance
12:42 - of this walk function and set this to
12:46 - point to this person object so now when
12:50 - we call this walk function we will see
12:53 - this person object on the console let's
12:56 - have a look save the changes back in the
12:58 - browser
12:58 - look the blind method fix our problem so
13:03 - let's quickly recap functions in
13:06 - JavaScript are objects they have
13:08 - properties and methods we can use one of
13:11 - the important methods that you see in a
13:12 - lot of reactor applications is the bind
13:15 - method with the point method we can set
13:18 - the value of this permanently so when we
13:21 - call bind on the walk function we get a
13:25 - new walk function and in that walk
13:27 - function the value of this is based on
13:30 - the argument that we pass to the bind
13:33 - method
13:35 - so because here we're passing the person
13:37 - object as an argument we'll get a walk
13:39 - function that is always attached to this
13:42 - person object and that's why when we
13:45 - call it here without a reference to the
13:47 - person object we'll still see the person
13:50 - object on the console
14:00 - one of my favorite features in modern
14:03 - JavaScript is arrow functions so let's
14:06 - define a constant call it Square and set
14:09 - it to a function that takes a number and
14:13 - simply returns number times number so
14:18 - this is the old JavaScript now starting
14:20 - from xmas script 6 we have a cleaner way
14:23 - to write the same code
14:24 - so let me duplicate this so you can see
14:27 - both versions side by side to convert
14:31 - this function to an arrow function we
14:34 - get rid of the function keyword and put
14:37 - a fat arrow between the parameters and
14:39 - the body of the function now if you have
14:42 - only a single parameter we can exclude
14:45 - the parentheses if you have zero
14:48 - parameters we have to add empty
14:50 - parentheses so this is a function that
14:53 - takes no parameters
14:54 - okay now let's revert this back we have
14:58 - a single parameter number now if the
15:01 - body of our function includes only a
15:04 - single line and returns a value we can
15:07 - make this code even shorter we can get
15:10 - rid of the return keyword as well as the
15:13 - curly braces and this is the end result
15:18 - so the code we have on line 5 is exactly
15:22 - equivalent to what we have here you can
15:25 - see the syntax is cleaner and more
15:27 - compact and you can read it like number
15:30 - goes to number times number so we can
15:34 - call this square function like this and
15:37 - lock the result on the console and let's
15:42 - remove this otherwise we'll get an error
15:43 - because we have declared the square
15:46 - constant twice so save the changes back
15:50 - in the browser we get 25 on the console
15:53 - now let me show you where these arrow
15:55 - functions are really useful let's
15:58 - imagine we have an array of jobs so each
16:02 - job object has maybe an ID and a
16:05 - property called is active which was set
16:08 - to true or false now I'm gonna add a
16:11 - couple more here
16:12 - and make the first two jobs active and
16:15 - the last one inactive
16:18 - okay now let's imagine we want to get
16:21 - only the active jobs so we call jobs
16:25 - that filter method the argument that we
16:28 - pass here is a predicate function a
16:31 - function that takes a job object and
16:35 - returns a true or false so when we call
16:38 - the filter method this method iterates
16:41 - over this array for each job object it
16:45 - takes that job object and pass it to
16:48 - this predicate function the job of this
16:51 - predicate is to determine if that job
16:53 - object should be returned from the
16:56 - filter method so here we can return job
17:00 - that is active if we return true here
17:04 - that job will be returned from the
17:07 - filter method so we can get the final
17:10 - list and call it active jobs okay now
17:15 - here we have a simple function and this
17:18 - is a perfect opportunity for us to use
17:20 - an arrow function and make this code
17:23 - cleaner and more readable so I'm gonna
17:25 - duplicate this line so we can compare
17:28 - them side by side so as I told you to
17:30 - convert this to an error function we get
17:33 - rid of the function keyword delete put a
17:36 - fat arrow between the parameters and the
17:38 - body now we have a single parameter so
17:41 - we can get rid of the parenthesis and
17:43 - you have a single line here
17:46 - we're simply returning a value so we can
17:48 - get rid of the return keyword as well as
17:51 - the curly braces and we don't add the
17:54 - semicolon here so this is the end result
17:58 - you can see this code is cleaner and
18:01 - easier to read so filter jobs where job
18:05 - is active there is less noise in this
18:09 - code
18:17 - one thing you need to know about the
18:19 - arrow functions is that they don't
18:22 - rebind this let me show you what I mean
18:25 - so I'm gonna start by defining a person
18:29 - object here we gonna have a simple talk
18:33 - method let's log this on the console
18:38 - okay so we call person the talk what do
18:43 - you expect to see on the console a
18:45 - reference to the person object right
18:47 - let's make sure everything's working so
18:50 - back in the browser so we have this and
18:53 - next to that we have a reference to our
18:56 - person object right now let's see what
18:59 - happens
18:59 - if you wrap this line inside of a call
19:02 - to the set timeout function so as you
19:05 - probably know in JavaScript we have this
19:08 - global function set timeout we can give
19:11 - it a function and a timeout value let's
19:16 - say 1000 milliseconds so set timeout
19:19 - we'll execute this function after this
19:25 - delay one second right now in this
19:27 - callback function I want to log this on
19:30 - the console so previously when we logged
19:33 - this on the console we saw the person
19:36 - object now let's see what happens when
19:39 - we lock this inside of this callback
19:42 - function so save the changes back on the
19:45 - console we get the window object not the
19:49 - person object what's going on here the
19:52 - reason this happened is because here
19:54 - this callback function is not part of
19:57 - any objects so it's not like the talk
19:59 - method in the person object it's a
20:02 - stand-alone function and as I told you
20:05 - before when we call a function as a
20:07 - standalone function outside of an object
20:10 - by default this returns the window
20:14 - object now in the previous example
20:16 - instead of the window object we got
20:18 - undefined because in that particular
20:20 - case when we got a reference to a method
20:23 - in an object the strict mode kicked in
20:26 - and returned undefined instead of the
20:29 - window object
20:30 - but in this particular case in case of
20:32 - callback functions the streak mode does
20:35 - not overwrite this behavior so this
20:38 - returns a reference to the window object
20:41 - so how can we solve this problem in
20:44 - other words how can we have a reference
20:46 - to the person object inside of this
20:50 - callback function well here's one
20:52 - solution so in the old days we used to
20:55 - declare a variable call it that or self
20:59 - and set it to this so we set this
21:03 - variable outside of this callback
21:05 - function and now we can use self inside
21:09 - of this callback function to get access
21:11 - to the person object right so now let's
21:14 - log self on the console so self and self
21:20 - save the changes back in chrome you can
21:24 - see we have a reference to the person
21:26 - object so this is the pattern that we
21:29 - used in the old days now with error
21:32 - functions we no longer have to do this
21:34 - because arrow functions don't rebind
21:37 - this in other words if we change this
21:41 - callback function to an arrow function
21:43 - it will inherit that this keyword let me
21:47 - show you so I'm gonna change this to an
21:50 - error function and revert this back to
21:53 - this this write save the changes back in
21:59 - the console you can see this returns a
22:02 - reference to the person object in other
22:05 - words here in this callback function
22:08 - because we have used the arrow function
22:10 - syntax this is not reset
22:13 - instead it inherits this in the context
22:17 - in which this code is defined so this is
22:21 - what I want you to take away arrow
22:23 - functions don't rebind
22:25 - the disk keyword
22:34 - ECMO script 6 introduced a new method in
22:37 - arrays called
22:39 - map this is a very useful method and in
22:41 - react we use it to render lists as you
22:45 - will see in the next section so whenever
22:47 - you want to render a list of items
22:48 - that's when you use the map method of
22:51 - arrays so let's say we have an array
22:54 - called colors with three items red green
22:58 - and blue let's imagine we want to render
23:02 - these using list items so for each color
23:05 - we want to have a list item like this
23:08 - right so we call the map method on this
23:12 - array colors map here we need to pass a
23:15 - callback function the job of this
23:18 - function is to transform each element in
23:21 - this array so this function is called by
23:24 - the map method for each item in this
23:26 - array it takes one item at a time and
23:29 - returns a new item so a callback
23:32 - function takes an item and returns a new
23:36 - item now in this case I want to rename
23:38 - this item to color because we're dealing
23:40 - with an array of colors now we take a
23:43 - color which is a string we simply return
23:47 - a new string like this we had the
23:50 - opening li tag plus color plus another
23:54 - string that includes the closing Li tag
23:59 - now this map method returns a new array
24:02 - so it does not modify the original array
24:05 - let's call that items ok now we can
24:09 - simplify this code we can make it
24:11 - cleaner so we have a callback function
24:13 - it's a very simple function and a great
24:16 - candidate for converting to an arrow
24:19 - function so we get rid of the function
24:22 - keyword and put a fat arrow here we have
24:25 - a single parameter so we can get rid of
24:27 - the parentheses we have a single line
24:30 - where we're returning a value so we can
24:33 - get rid of the return keyword as well as
24:35 - the curly braces put everything on one
24:38 - line get rid of the semicolon and this
24:41 - is the end result so your mapping or
24:44 - transforming the array of color
24:47 - for each caller will return a string
24:50 - like this now we can take this to the
24:53 - next level and make this code cleaner
24:55 - this concatenations here are a little
24:57 - bit ugly so instead we can use template
25:01 - literals in es6 so instead of using
25:04 - single or double quotes we use the
25:07 - backtick character that's the character
25:10 - before number one on your keyboard here
25:12 - we can define a template for our string
25:14 - so we want to have the opening and
25:17 - closing Li tags and in the middle we
25:21 - want to render the color dynamically so
25:24 - we add a dollar sign and curly braces
25:26 - this is an argument placeholder what we
25:30 - put in between the braces will be
25:32 - rendered dynamically at runtime so here
25:35 - we want to render this color that we
25:39 - have here right so this is what we call
25:42 - a template literal now we get a new
25:45 - array let's lock that on a console so
25:48 - console the blog items save the changes
25:53 - as you can see we have an array with
25:55 - three items so this map method is very
26:00 - useful in react when rendering lists as
26:02 - you will see in the next section
26:12 - one of the modern JavaScript features
26:15 - that you see a lot in react applications
26:17 - is object restructuring so let's imagine
26:20 - we have an address object like this
26:23 - we have Street set some value city and
26:29 - country now let's say somewhere in the
26:32 - code we need to extract the value of
26:34 - these properties and store them in
26:36 - separate variables so this is what we
26:39 - typically do constant street we set it
26:43 - to an address but street and similarly
26:47 - city we set this to address dot city and
26:51 - finally country the problem with this
26:55 - code is oops I missed a T here the
26:58 - problem with this code is that we have
27:00 - this repetitive address dot address dot
27:04 - address dot code in multiple places
27:06 - these structuring solves this problem so
27:10 - if we want to have three variables or
27:13 - three constants street city and country
27:16 - and we want them to be set to these
27:18 - properties in the address object we can
27:21 - rewrite this code like this so constant
27:25 - we add curly braces this is the
27:28 - destructuring syntax we add the name of
27:30 - the target properties in this case
27:32 - street city and country we set this to
27:37 - the address object so what we have on
27:41 - line 11 is exactly equivalent to these
27:44 - three lines and we no longer have that
27:46 - repetition of address dot so basically
27:50 - we are extracting the street property
27:53 - from the address object and storing it
27:55 - in a constant called street now you
27:58 - don't necessarily have to list all the
28:00 - properties in the address object maybe
28:03 - you're only interested in the city
28:05 - property in that case you can drop these
28:07 - two other properties now what if we want
28:11 - to use a different name here for example
28:13 - what if you want to call this constant s
28:15 - T we can use an alias here so we add : s
28:20 - T with this syntax for defining a new
28:24 - constant called s T
28:26 - and we're setting that to the street
28:27 - property of the address object so this
28:31 - is object restructuring that you will
28:33 - see a lot in the future sections
28:43 - another modern JavaScript feature that
28:46 - we use quite a lot in react is the
28:48 - spread operator let's say we have two
28:51 - arrays first with three numbers and
28:56 - second with three more numbers let's say
28:59 - we want to combine these two arrays one
29:02 - way to combine this is like this so
29:04 - combined we get the first call the
29:08 - concat method and pass the second array
29:13 - this is the old way of doing things now
29:16 - with the spread operator we can rewrite
29:18 - this code like this so a constant
29:20 - combined we create a new array we spread
29:25 - the first array and that means we'll get
29:29 - every item in this array and put it in
29:32 - our new array and then similarly we'll
29:35 - spread the second array so the spread
29:38 - operator is represented using three dots
29:41 - right in the first class you may say
29:44 - there is really not much of a difference
29:45 - between what we have on line four or
29:48 - line five in terms of the length of the
29:50 - code so why is this an improvement
29:52 - well what if we wanted to add an element
29:55 - somewhere in the middle so we can simply
29:59 - come here and add an element right in
30:02 - the middle
30:03 - but when using the concat method if you
30:05 - want to get the same result our code
30:07 - would end up looking more complicated
30:10 - similarly we can add another element
30:12 - here at the end so B we can visually see
30:17 - what the end result will look like so we
30:20 - have a new array first we spread all the
30:23 - items in the first array then we have a
30:26 - and so on so basically when we apply the
30:29 - spread operator on an array we'll get
30:32 - each individual item in that array now
30:35 - using the spread operator we can easily
30:38 - clone an array let me show you so I'm
30:41 - gonna comment out these two lines let's
30:44 - say we want to clone the first array but
30:47 - define a constant clone we create a new
30:50 - array and simply spread the first array
30:53 - now if we log
30:56 - first and clone you will see they are
30:59 - identical save the changes back in the
31:03 - console so here is first and here is
31:06 - clone now we can also apply the spread
31:09 - operator on objects so I'm going to
31:12 - rewrite this code but use an object
31:14 - instead so let's delete everything don't
31:17 - worry you're not gonna forget this so
31:19 - let's define a constant call it first we
31:22 - set it to an object with the name
31:23 - property set to maash then a second
31:28 - object with another property job
31:31 - instructor okay now let's say we want to
31:35 - combine these two objects into one
31:37 - object but declare another constant
31:40 - called combined we create a new object
31:43 - note that previously we created a new
31:46 - array because we were combining two
31:48 - arrays now we're combining two objects
31:51 - so we create a new object now in this
31:54 - new object we want to add all the
31:55 - properties are the first object so we
31:59 - spread the first object then we'll also
32:03 - spread the second object we can
32:06 - optionally add other properties let's
32:09 - say location Australia now if you log
32:15 - this combined object on the console we
32:19 - get this object with three properties
32:23 - similarly we can use the spread operator
32:26 - to clone an object so if I want to clone
32:29 - the first object I can do like this and
32:33 - your object we simply spread the first
32:36 - object and boom we're done
32:47 - now let's talk about classes so look at
32:51 - this piece of code we have this personal
32:53 - object with two members named and walk
32:56 - what if you want to create another
32:58 - personal object that can walk
33:00 - well let me temporarily duplicate this
33:03 - code and call this other object person
33:06 - two now there is a problem here
33:08 - the problem is that we have duplicated
33:11 - the implementation of the walk method
33:14 - now this implementation is currently a
33:16 - single line of code but in a real world
33:18 - application this method can be five to
33:21 - ten lines of code or maybe more if there
33:23 - is a bug in this method then we'll have
33:25 - to come back and fix it in all person
33:28 - objects that doesn't make sense right so
33:30 - when we have an object with at least one
33:33 - method we need a blueprint to create
33:36 - objects of that type and that's when we
33:38 - use classes so let me show you how a
33:40 - class can help us solve this problem I'm
33:43 - gonna delete the second person object
33:46 - and create a class so we start with the
33:49 - class keyword give our class a name
33:52 - person and note that here I'm using post
33:55 - call naming convention so the first
33:58 - letter of every word should be uppercase
34:01 - as another example if you wanted to call
34:04 - this class cool person would have to
34:06 - name it like this so note that C and P
34:10 - here are capital okay so here's our
34:13 - class then we add a code block now we
34:16 - need to move our walk method inside our
34:19 - person class so I've selected this code
34:22 - I'm holding down alt and then press a
34:26 - down arrow
34:26 - so we can move it like this easy right
34:30 - finally we need to add another method
34:34 - here that method is a special method
34:36 - that is called constructor so just like
34:41 - the walk method constructor is a method
34:44 - but the name is reserved it's a special
34:46 - keyword that's why similar to the class
34:49 - keyword it is orange okay now this
34:52 - constructor can take parameters so we
34:55 - can pass the name from the outside and
34:57 - initialize it here how
34:59 - well we use this in this case this
35:03 - always returns a reference to the
35:05 - current object so we set the name
35:07 - property on that object to this name
35:10 - argument that we received from the
35:11 - outside now we have a blueprint for
35:14 - creating personal objects so let's
35:17 - delete this code on the top to create a
35:20 - personal object we can do something like
35:22 - this so person we set it to a new person
35:27 - object so this new keyword or the new
35:31 - operator is very important here when we
35:33 - have a class to create an object using
35:36 - that class or that blueprint we need to
35:38 - use the new operator now we had
35:42 - parentheses and you can see our name
35:44 - parameter so if you ignore the new
35:47 - keyword for a second this expression
35:49 - looks like calling a function and that's
35:52 - exactly our constructor method and the
35:56 - person class so the parameters are we
35:59 - defined there we can set them here so
36:02 - I'm gonna pass maash as an argument now
36:06 - we have a person object you can see it
36:09 - has a name property and the walk method
36:11 - with this person class we have
36:14 - implemented the walk method in a single
36:16 - place if tomorrow we find a bug in this
36:19 - method there's a single place we need to
36:21 - modify so this is the benefit of using
36:23 - classes next we're going to look at
36:25 - inheritance
36:34 - now let's take the example from the last
36:37 - lecture to the next level let's say we
36:39 - want to define a teacher class so class
36:41 - teacher here we add a teach method and
36:46 - simply do a console dot log of teach
36:49 - okay however all teachers should be able
36:54 - to walk because they're all persons we
36:57 - don't want to duplicate this walk method
36:59 - in the person and teacher classes so how
37:02 - can we solve this problem
37:03 - basically there are two solutions here
37:06 - we can use inheritance or composition
37:08 - the explanation of both these approaches
37:11 - is beyond the scope of this course
37:12 - that's something that I have talked
37:14 - about in my other course object-oriented
37:16 - programming in JavaScript but as well as
37:18 - react is concerned you need to
37:20 - understand the concept of inheritance so
37:23 - we can have this teacher class inherit
37:26 - from the person class and this means it
37:29 - will inherit all the methods defined in
37:31 - this person class how can we do it very
37:34 - easy so here we add a keyword extends
37:38 - person so teacher extends person now if
37:43 - we create a teacher object so teacher we
37:48 - set it to a new teacher look at its
37:50 - constructor you see the name parameter
37:53 - right so the teacher class is also
37:55 - inheriting the constructor of the person
37:59 - class
37:59 - okay so let's pass a name here wash now
38:04 - teacher dot look we have the name
38:06 - property which we have inherited from
38:08 - the personal class we have to teach
38:10 - method that we added specifically in the
38:13 - teacher class and walk which we also
38:15 - inherited from the person class so this
38:18 - is inheritance in action now let's take
38:20 - this to the next level let's imagine
38:22 - when creating a teacher apart from the
38:25 - name we need to pass their degree so
38:29 - here in the teacher class we need to add
38:30 - a constructor constructor this
38:34 - constructor should take two parameters
38:36 - one is name which we need to pass to the
38:39 - person class and I will show you that in
38:41 - a second the other parameter is the
38:43 - degree so degree now because we added
38:47 - a custom constructor here we need to
38:50 - call the constructor of the person class
38:53 - if you don't do that we'll get an error
38:55 - let me show you so down the bottom of
38:58 - this file let's remove this line teacher
39:00 - dot save the changes back on the console
39:04 - look at this error missing super call in
39:07 - constructor and you can see it's
39:09 - pointing to line 12 this is where we're
39:11 - defining the teacher class right after
39:13 - that we have the constructor this is
39:15 - where the problem is happening so back
39:18 - in the code whenever we had a
39:20 - constructor in a child class we need to
39:23 - call the constructor of its parent class
39:26 - so here in the constructor we have this
39:29 - special keyword super that references
39:32 - the parent class so we call it just like
39:35 - a method and you can see here we have
39:38 - the name parameter so we pass this name
39:41 - argument that we receive here so this
39:44 - will initialize the name property next
39:48 - we need to initialize the degree
39:49 - property so this that degree will set it
39:53 - to this degree argument now finally on
39:56 - line 22 we need to pass the second
39:59 - argument the degree that is let's say
40:01 - Master of Science so if we type teacher
40:03 - dot now you can see we have two
40:06 - properties degree a name as well as two
40:08 - methods teach and walk so this is
40:11 - inheritance in action as you will see in
40:14 - the next section whenever we create a
40:16 - component we should have that component
40:18 - extend the base component that is
40:21 - defined in react because that base
40:23 - component in react has a bunch of
40:25 - methods that we need in our components
40:27 - so we're done with classes next we'll
40:30 - look at modules
40:39 - so here is the code that we wrote in the
40:41 - last lecture currently this file is
40:44 - getting a little bit bloated because we
40:46 - have multiple classes defined in the
40:49 - same file it would be much nicer if we
40:52 - split this code across multiple files
40:55 - and this is what we call modularity so
40:58 - instead of writing all the code in one
40:59 - file we write our code in multiple files
41:02 - we call each file a module in the old
41:05 - days we didn't have the concept of
41:07 - modules natively in JavaScript so there
41:11 - were many third-party solutions but
41:13 - starting from Egmont script 6 we have
41:15 - the concept of modules natively in
41:18 - JavaScript so let's go ahead and
41:19 - modularize this application I'm gonna
41:22 - move each class in a separate file let's
41:25 - start with the person class so create a
41:28 - new file back in index that is select
41:32 - the person class cut it and put it here
41:35 - now let's save this as person dot J s
41:41 - similarly we need to go back to index
41:43 - that j s
41:45 - and grab the t-shirt class cut it create
41:49 - a new file paste it here and save it as
41:52 - teacher dot J s so now we can see we
41:57 - have less code in each file and our
41:59 - application is more maintainable but we
42:01 - are not done yet when working with
42:03 - modules the objects we define in a
42:06 - module are private by default so that
42:09 - means this teacher class that we have
42:11 - defined here is not visible to any other
42:14 - files or modules in this application in
42:17 - order to make this visible we have to
42:18 - make it public and we do that by
42:21 - exporting this class to the outside so
42:24 - we export it from the teacher class and
42:26 - then we import it wherever we need it so
42:29 - doing that is very easy we simply prefix
42:32 - the class with export ok save the
42:36 - changes similarly we go to the person
42:38 - module so we need to export the person
42:43 - class because we have referenced that
42:45 - and our teacher module here we're using
42:48 - the person class right but currently we
42:50 - have not imported this person class here
42:52 - so on the top we add import curly braces
42:57 - person from in codes you can see
43:02 - intellisense
43:02 - in vs code is suggesting a few libraries
43:05 - like react react Dom and so on these are
43:08 - the libraries that we have specified as
43:10 - dependencies in package.json so let me
43:14 - quickly show you back in the project
43:16 - here
43:19 - the JSON we've got three dependencies
43:21 - here and these dependencies are stored
43:23 - in node modules folder right so
43:27 - currently we don't want to import
43:29 - anything from these modules we want to
43:31 - import from our own modules so let's
43:35 - close this so here we need to pass the
43:38 - relative past or the target file or the
43:40 - target module we start with period slash
43:43 - and that indicates the current folder
43:46 - here are the files in the current folder
43:48 - so we want to import this person class
43:51 - from this person file note that here we
43:53 - don't add the extension just the file
43:55 - name so we don't add dot jas okay and
43:58 - finally we need to terminate this
44:00 - statement with a semicolon
44:02 - so we imported the person class from the
44:05 - person module finally we need to go back
44:07 - to index j s and because here we're
44:11 - using the teacher class we need to
44:13 - import it so once again import curly
44:16 - braces
44:17 - teacher from relative past that is pure
44:21 - slash teacher save the changes now to
44:26 - make sure that everything works let's
44:28 - call the teach method save the changes
44:33 - and here in the console you can see the
44:35 - teach message beautiful
44:37 - so we successfully modularized this an
44:39 - application in the next lecture we'll
44:41 - talk about default and named exports
44:52 - in the last lecture I told you that the
44:55 - objects that we define in a module are
44:57 - private by default so they are not
45:00 - accessible from the outside unless we
45:02 - export them let's explore this topic in
45:04 - a bit more detail so here in our teacher
45:07 - module or teacher that Jas I'm gonna
45:09 - define a function let's call that
45:12 - promote we don't have any code here just
45:15 - a simple function now save the changes
45:18 - back in index j s so at the top you're
45:22 - importing the teacher class from the
45:24 - teacher module temporarily I'm gonna
45:26 - delete this press control space so with
45:30 - the intellisense you can see here we
45:31 - have the teacher class that is exported
45:34 - from the teacher module but we don't see
45:36 - our promote function right so back to
45:39 - teacher that J s if we export this
45:43 - function now we can import it in index
45:46 - AJ s so save the changes back to index J
45:49 - is once again control space look we have
45:52 - the promote function and the teacher
45:54 - class so we can export one or more
45:57 - objects from a given module these are
46:00 - what we call named exports so what is
46:03 - exported has a name like the promote
46:05 - function or the teacher class now apart
46:08 - from named exports we also have the
46:11 - concept of default export and that is
46:14 - the main object that is exported from a
46:17 - module typically we use default exports
46:19 - if there is only a single object that we
46:22 - want to export let me show you what I
46:24 - mean so back to teacher at Jas let me
46:27 - temporarily comment this out so you can
46:30 - see currently we are exporting only a
46:32 - single object that is the teacher class
46:35 - right now you might say what Marsh a
46:37 - class is not an object well in
46:39 - JavaScript
46:40 - technically a class is an object because
46:43 - JavaScript classes are syntactic sugar
46:45 - over constructor functions and functions
46:49 - as I told you before our objects so a
46:51 - class is technically an object in
46:53 - JavaScript now that aside here we're
46:56 - exporting a single object now we can add
46:59 - the default keyword here and that means
47:04 - this teacher object is the main
47:06 - or the default thing that we're
47:07 - exporting from this module now with this
47:11 - back to index is we don't need the curly
47:15 - braces anymore we use these braces only
47:18 - to import the names exports in this case
47:21 - teacher is the default export so we
47:24 - import it like this save the changes you
47:29 - can see our application still working
47:31 - we've got the teach message on the
47:33 - console so let me quickly recap with
47:37 - default exports we import them like this
47:40 - import whatever from this module we
47:44 - named exports we import them like this
47:48 - we put them in curly braces okay now it
47:52 - is also possible that a module has a
47:55 - default export as well as a bunch of
47:57 - named exports react module is an example
48:00 - of that and I'm going to show you that
48:02 - in a second so back to our teacher
48:04 - module here we have a default export but
48:08 - I'm also gonna export this function so
48:11 - we have a named export as well as the
48:13 - default export right save the changes
48:16 - back in index J s so on the top we are
48:20 - importing the default export also we add
48:24 - curly braces control space look we have
48:27 - the pro mode function this is a named
48:29 - export we can import that as well
48:32 - now why does this matter this is a
48:34 - pattern that you see a lot in react
48:36 - applications so as you will see in the
48:38 - following sections on top of almost
48:41 - every file in a react application we
48:43 - have an import statement like this
48:45 - import react comma braces component from
48:52 - react you can see this import statement
48:56 - looks very similar to what we have on
48:58 - line one so let's see what's going on
49:01 - here obviously a react is the module but
49:04 - note that here we don't have period
49:06 - slash because we use them only for our
49:08 - own modules that are part of the project
49:10 - but react is not part of our project
49:13 - it's a third-party library that is
49:15 - stored inside of the node modules folder
49:18 - okay now react
49:20 - is the default export from this module
49:23 - where as component is a named export so
49:26 - if I delete this and press control space
49:30 - you can see all the named exports in the
49:33 - react module 99% of the time we're going
49:37 - to use the component class because we
49:40 - want our custom components to extend
49:42 - this component so they will inherit all
49:45 - the behavior all the methods implemented
49:48 - inside of this class ok so that brings
49:51 - us to the end of this section I hope you
49:53 - enjoyed the material and I will see you
49:55 - in the next section
49:57 - [Music]

Cleaned transcript:

in order to build applications with react you should have at least three months of experience programming in JavaScript so in this section I'm going to cover the essential JavaScript features that you're going to use a lot in react applications such as let versus Const P words objects that this keyword and how it behaves differently arrow functions object is structuring the spread operator classes and modules make sure you know all these topics well before going further otherwise you're going to have a lot of difficulty later down the road I just need to clarify that in this section I'm not gonna go really deep in these concepts because this is a react course not a JavaScript course as I told you before I've got two other JavaScript courses for you one is called JavaScript basics for beginners and the other is objectoriented programming in JavaScript the focus of the first course is on the art of problem solving it teaches you how to think like a programmer unfortunately there are a lot of developers out there in the industry who can build applications with angular react and all kinds of fancy frameworks but they cannot solve simple programming problems because there are selftaught programmers they have never attended a college or university they never learned the fundamentals of computer science and software engineering and that's why I've designed this course the focus of the second course is on more advanced topics such as constructor functions objects prototypes inheritance polymorphism classes and more all right that's enough introduction now let's get started you to demonstrate the modern JavaScript features I'm gonna use a brand new react project so in this project let's open up index j s and delete all the code here and focus on plain vanilla JavaScript so the first thing we're gonna look at are the new keywords for defining variables and constants so let's define a function call it say hello here I'm gonna define a loop so for VAR I we set this to 0 as long as it's less than 5 we increment I and login on the console pretty simple right let's call this function save the changes back in the browser so here we see these numbers 0 to 4 pretty straightforward however there is a problem with the VAR keyword in JavaScript in most programming languages when we declare a variable that variable should only be accessible in the block in which it's defined this is what we call scope right so in this case I should only be accessible inside of the for block however I can come here and log I on the console and you will see that I is still accessible here save the changes back in the browser look we've got I displayed here because in the last iteration I becomes 5 and because 5 is not less than 5 we exit this loop so this is what I want you to take away when you declare a variable with the war keyword that variable is accessible inside of the function in which it's defined and this is one of those weird things about JavaScript that is different from other programming languages so in ECMO script 6 or es6 which is the version of JavaScript introduced in year 2015 we got a new keyword for declaring variables and that is let so let came to solve this problem when you declare a variable with the let keyword that variable is only accessible inside of that block let's see the result so same to change us back in the browser now we get this error on the console I is not defined so here's what I want you to take away variables declared with the VAR keyword are scoped to the function whereas variables declared with the let keyword are scoped to the block in which they are defined so going forward you should prefer to use the let keyword unless you have a very valid reason for using the VAR keyword now we also have another new keyword in es6 and that is Const we use cons to define constants I'm going to show you that in a second but similar to let variables defined with Const are also block scoped so they are only accessible inside of the block they are defined now let me show you the difference between let and Const so I'm gonna delete all this code here let's define a variable with Const set it to 1 now if we reassign this and save the changes back in the browser you can see that X is readonly in other words when you declare a variable with the Const keyword that variable cannot be reassigned that's why we refer to that as a constant so technically it's not a variable because it cannot change it's a constant so let's quickly wrap up throw away the VAR keyword and prefer to use Const over let use let only when you need to reassign a variable alright now let's take a look at objects so once again I'm gonna use the Const keyword to define a variable well more accurately a constant and set it to an object so as you know objects in JavaScript are collections of key value pairs so I'm gonna add a couple of key value pairs here the first one is name which was set to a string and the second is wok which was set to a function now in objectoriented programming terms if we have a function inside of an object we refer to that function as a method so here we say Walk is a method in the person object now starting from es6 there is a cleaner and simpler syntax to define a method in an object so let's add another method here I'm gonna call this talk now here we don't need to add a colon and the function keyword we can define it like this so basically we drop the colon and the function keyword and here's the result so here we have a personal object with three members one property and two methods there are two ways to access these members we can use the dot notation which you are probably familiar with so dot talk or walk we can also use the bracket notation so person we add square brackets pass a string and this string determines the name of the target member so if you want to access the name property we pass that here and now we can reassign that to a different value in terms of practicality we use the bracket notation when we don't know ahead of time what property or method we're going to access let me show you what I mean so I'm going to define a constant call it target member and set it to name imagine this target member is an input field on a form depending on what the user types in that input field we're going to access a different property in this personal object that's when we use the bracket notation so instead of hardcoding name here Pass Target member and once again this could be an input field so we could access the value property like this and then dynamically access a property or a method in an object if we know ahead of time what property or method we're going to access we use the dock notation so we write person dot name we set it to a different value next we're going to look at that this keyword in JavaScript so we have this person object with a walk method now let's modify this method and do a consult that log of this what is this this is a special keyword in JavaScript which confuses a lot of developers because it doesn't behave the same as this in other programming languages like C sharp or Java in this languages this always returns a reference to the current object let me show you so here I'm gonna call person dot walk save the changes back in the browser so we see our personal object on the console so in this case this is returning a reference to this person object right however this in JavaScript does not always work that way let me show you why so I'm gonna define a constant call it walk and set it to person dot walk note that I'm not calling the walk method I'm just getting a reference to this function so walk is now a function let me show you so console the log of walk now back in the browser so you can see our walk constant is set to this function right now let's see what happens when we call this function so I'm gonna call walk save the changes back in the browser what's going on here so we don't get a reference to the person object we get undefined that's why I told you that that this keyword in JavaScript behaves differently from other programming languages the value of this is determined by how a function is called if we call a function as a method in an object this will always return a reference to that object however if we call a function as a standalone object or outside of an object this will return the global object which the window object in browsers but in this particular implementation we didn't see the window object here we got undefined the reason for this is because in this react project the strict mode is enabled by default if you're not familiar with the strict mode it's basically a mode to execute JavaScript code in a more protective way so it prevents potential problems that's why in this case instead of getting a reference to the window object we get undefined so in the last lecture you learned that when we call a function as a standalone function outside of an object this by default returns a reference to the global object which is the window object and if the strict mode is enabled it returns undefined in this lecture I'm gonna show you how to fix this problem so no matter how we call the walk function this will always return a reference to this person object so one thing that might be new to you is that in JavaScript functions are objects so here person dot walk is actually an object don't believe me let me show you so dot look these are all the members of the walk object so every function in JavaScript is an object with these members we've got this method here bind and we can use this method to bind a function to an object what do you mean by this so when we call this note the first argument is called this auric what we pass here as an argument will determine the value of this in this case if I pass this person object here the point method will return a new instance of this walk function and set this to point to this person object so now when we call this walk function we will see this person object on the console let's have a look save the changes back in the browser look the blind method fix our problem so let's quickly recap functions in JavaScript are objects they have properties and methods we can use one of the important methods that you see in a lot of reactor applications is the bind method with the point method we can set the value of this permanently so when we call bind on the walk function we get a new walk function and in that walk function the value of this is based on the argument that we pass to the bind method so because here we're passing the person object as an argument we'll get a walk function that is always attached to this person object and that's why when we call it here without a reference to the person object we'll still see the person object on the console one of my favorite features in modern JavaScript is arrow functions so let's define a constant call it Square and set it to a function that takes a number and simply returns number times number so this is the old JavaScript now starting from xmas script 6 we have a cleaner way to write the same code so let me duplicate this so you can see both versions side by side to convert this function to an arrow function we get rid of the function keyword and put a fat arrow between the parameters and the body of the function now if you have only a single parameter we can exclude the parentheses if you have zero parameters we have to add empty parentheses so this is a function that takes no parameters okay now let's revert this back we have a single parameter number now if the body of our function includes only a single line and returns a value we can make this code even shorter we can get rid of the return keyword as well as the curly braces and this is the end result so the code we have on line 5 is exactly equivalent to what we have here you can see the syntax is cleaner and more compact and you can read it like number goes to number times number so we can call this square function like this and lock the result on the console and let's remove this otherwise we'll get an error because we have declared the square constant twice so save the changes back in the browser we get 25 on the console now let me show you where these arrow functions are really useful let's imagine we have an array of jobs so each job object has maybe an ID and a property called is active which was set to true or false now I'm gonna add a couple more here and make the first two jobs active and the last one inactive okay now let's imagine we want to get only the active jobs so we call jobs that filter method the argument that we pass here is a predicate function a function that takes a job object and returns a true or false so when we call the filter method this method iterates over this array for each job object it takes that job object and pass it to this predicate function the job of this predicate is to determine if that job object should be returned from the filter method so here we can return job that is active if we return true here that job will be returned from the filter method so we can get the final list and call it active jobs okay now here we have a simple function and this is a perfect opportunity for us to use an arrow function and make this code cleaner and more readable so I'm gonna duplicate this line so we can compare them side by side so as I told you to convert this to an error function we get rid of the function keyword delete put a fat arrow between the parameters and the body now we have a single parameter so we can get rid of the parenthesis and you have a single line here we're simply returning a value so we can get rid of the return keyword as well as the curly braces and we don't add the semicolon here so this is the end result you can see this code is cleaner and easier to read so filter jobs where job is active there is less noise in this code one thing you need to know about the arrow functions is that they don't rebind this let me show you what I mean so I'm gonna start by defining a person object here we gonna have a simple talk method let's log this on the console okay so we call person the talk what do you expect to see on the console a reference to the person object right let's make sure everything's working so back in the browser so we have this and next to that we have a reference to our person object right now let's see what happens if you wrap this line inside of a call to the set timeout function so as you probably know in JavaScript we have this global function set timeout we can give it a function and a timeout value let's say 1000 milliseconds so set timeout we'll execute this function after this delay one second right now in this callback function I want to log this on the console so previously when we logged this on the console we saw the person object now let's see what happens when we lock this inside of this callback function so save the changes back on the console we get the window object not the person object what's going on here the reason this happened is because here this callback function is not part of any objects so it's not like the talk method in the person object it's a standalone function and as I told you before when we call a function as a standalone function outside of an object by default this returns the window object now in the previous example instead of the window object we got undefined because in that particular case when we got a reference to a method in an object the strict mode kicked in and returned undefined instead of the window object but in this particular case in case of callback functions the streak mode does not overwrite this behavior so this returns a reference to the window object so how can we solve this problem in other words how can we have a reference to the person object inside of this callback function well here's one solution so in the old days we used to declare a variable call it that or self and set it to this so we set this variable outside of this callback function and now we can use self inside of this callback function to get access to the person object right so now let's log self on the console so self and self save the changes back in chrome you can see we have a reference to the person object so this is the pattern that we used in the old days now with error functions we no longer have to do this because arrow functions don't rebind this in other words if we change this callback function to an arrow function it will inherit that this keyword let me show you so I'm gonna change this to an error function and revert this back to this this write save the changes back in the console you can see this returns a reference to the person object in other words here in this callback function because we have used the arrow function syntax this is not reset instead it inherits this in the context in which this code is defined so this is what I want you to take away arrow functions don't rebind the disk keyword ECMO script 6 introduced a new method in arrays called map this is a very useful method and in react we use it to render lists as you will see in the next section so whenever you want to render a list of items that's when you use the map method of arrays so let's say we have an array called colors with three items red green and blue let's imagine we want to render these using list items so for each color we want to have a list item like this right so we call the map method on this array colors map here we need to pass a callback function the job of this function is to transform each element in this array so this function is called by the map method for each item in this array it takes one item at a time and returns a new item so a callback function takes an item and returns a new item now in this case I want to rename this item to color because we're dealing with an array of colors now we take a color which is a string we simply return a new string like this we had the opening li tag plus color plus another string that includes the closing Li tag now this map method returns a new array so it does not modify the original array let's call that items ok now we can simplify this code we can make it cleaner so we have a callback function it's a very simple function and a great candidate for converting to an arrow function so we get rid of the function keyword and put a fat arrow here we have a single parameter so we can get rid of the parentheses we have a single line where we're returning a value so we can get rid of the return keyword as well as the curly braces put everything on one line get rid of the semicolon and this is the end result so your mapping or transforming the array of color for each caller will return a string like this now we can take this to the next level and make this code cleaner this concatenations here are a little bit ugly so instead we can use template literals in es6 so instead of using single or double quotes we use the backtick character that's the character before number one on your keyboard here we can define a template for our string so we want to have the opening and closing Li tags and in the middle we want to render the color dynamically so we add a dollar sign and curly braces this is an argument placeholder what we put in between the braces will be rendered dynamically at runtime so here we want to render this color that we have here right so this is what we call a template literal now we get a new array let's lock that on a console so console the blog items save the changes as you can see we have an array with three items so this map method is very useful in react when rendering lists as you will see in the next section one of the modern JavaScript features that you see a lot in react applications is object restructuring so let's imagine we have an address object like this we have Street set some value city and country now let's say somewhere in the code we need to extract the value of these properties and store them in separate variables so this is what we typically do constant street we set it to an address but street and similarly city we set this to address dot city and finally country the problem with this code is oops I missed a T here the problem with this code is that we have this repetitive address dot address dot address dot code in multiple places these structuring solves this problem so if we want to have three variables or three constants street city and country and we want them to be set to these properties in the address object we can rewrite this code like this so constant we add curly braces this is the destructuring syntax we add the name of the target properties in this case street city and country we set this to the address object so what we have on line 11 is exactly equivalent to these three lines and we no longer have that repetition of address dot so basically we are extracting the street property from the address object and storing it in a constant called street now you don't necessarily have to list all the properties in the address object maybe you're only interested in the city property in that case you can drop these two other properties now what if we want to use a different name here for example what if you want to call this constant s T we can use an alias here so we add s T with this syntax for defining a new constant called s T and we're setting that to the street property of the address object so this is object restructuring that you will see a lot in the future sections another modern JavaScript feature that we use quite a lot in react is the spread operator let's say we have two arrays first with three numbers and second with three more numbers let's say we want to combine these two arrays one way to combine this is like this so combined we get the first call the concat method and pass the second array this is the old way of doing things now with the spread operator we can rewrite this code like this so a constant combined we create a new array we spread the first array and that means we'll get every item in this array and put it in our new array and then similarly we'll spread the second array so the spread operator is represented using three dots right in the first class you may say there is really not much of a difference between what we have on line four or line five in terms of the length of the code so why is this an improvement well what if we wanted to add an element somewhere in the middle so we can simply come here and add an element right in the middle but when using the concat method if you want to get the same result our code would end up looking more complicated similarly we can add another element here at the end so B we can visually see what the end result will look like so we have a new array first we spread all the items in the first array then we have a and so on so basically when we apply the spread operator on an array we'll get each individual item in that array now using the spread operator we can easily clone an array let me show you so I'm gonna comment out these two lines let's say we want to clone the first array but define a constant clone we create a new array and simply spread the first array now if we log first and clone you will see they are identical save the changes back in the console so here is first and here is clone now we can also apply the spread operator on objects so I'm going to rewrite this code but use an object instead so let's delete everything don't worry you're not gonna forget this so let's define a constant call it first we set it to an object with the name property set to maash then a second object with another property job instructor okay now let's say we want to combine these two objects into one object but declare another constant called combined we create a new object note that previously we created a new array because we were combining two arrays now we're combining two objects so we create a new object now in this new object we want to add all the properties are the first object so we spread the first object then we'll also spread the second object we can optionally add other properties let's say location Australia now if you log this combined object on the console we get this object with three properties similarly we can use the spread operator to clone an object so if I want to clone the first object I can do like this and your object we simply spread the first object and boom we're done now let's talk about classes so look at this piece of code we have this personal object with two members named and walk what if you want to create another personal object that can walk well let me temporarily duplicate this code and call this other object person two now there is a problem here the problem is that we have duplicated the implementation of the walk method now this implementation is currently a single line of code but in a real world application this method can be five to ten lines of code or maybe more if there is a bug in this method then we'll have to come back and fix it in all person objects that doesn't make sense right so when we have an object with at least one method we need a blueprint to create objects of that type and that's when we use classes so let me show you how a class can help us solve this problem I'm gonna delete the second person object and create a class so we start with the class keyword give our class a name person and note that here I'm using post call naming convention so the first letter of every word should be uppercase as another example if you wanted to call this class cool person would have to name it like this so note that C and P here are capital okay so here's our class then we add a code block now we need to move our walk method inside our person class so I've selected this code I'm holding down alt and then press a down arrow so we can move it like this easy right finally we need to add another method here that method is a special method that is called constructor so just like the walk method constructor is a method but the name is reserved it's a special keyword that's why similar to the class keyword it is orange okay now this constructor can take parameters so we can pass the name from the outside and initialize it here how well we use this in this case this always returns a reference to the current object so we set the name property on that object to this name argument that we received from the outside now we have a blueprint for creating personal objects so let's delete this code on the top to create a personal object we can do something like this so person we set it to a new person object so this new keyword or the new operator is very important here when we have a class to create an object using that class or that blueprint we need to use the new operator now we had parentheses and you can see our name parameter so if you ignore the new keyword for a second this expression looks like calling a function and that's exactly our constructor method and the person class so the parameters are we defined there we can set them here so I'm gonna pass maash as an argument now we have a person object you can see it has a name property and the walk method with this person class we have implemented the walk method in a single place if tomorrow we find a bug in this method there's a single place we need to modify so this is the benefit of using classes next we're going to look at inheritance now let's take the example from the last lecture to the next level let's say we want to define a teacher class so class teacher here we add a teach method and simply do a console dot log of teach okay however all teachers should be able to walk because they're all persons we don't want to duplicate this walk method in the person and teacher classes so how can we solve this problem basically there are two solutions here we can use inheritance or composition the explanation of both these approaches is beyond the scope of this course that's something that I have talked about in my other course objectoriented programming in JavaScript but as well as react is concerned you need to understand the concept of inheritance so we can have this teacher class inherit from the person class and this means it will inherit all the methods defined in this person class how can we do it very easy so here we add a keyword extends person so teacher extends person now if we create a teacher object so teacher we set it to a new teacher look at its constructor you see the name parameter right so the teacher class is also inheriting the constructor of the person class okay so let's pass a name here wash now teacher dot look we have the name property which we have inherited from the personal class we have to teach method that we added specifically in the teacher class and walk which we also inherited from the person class so this is inheritance in action now let's take this to the next level let's imagine when creating a teacher apart from the name we need to pass their degree so here in the teacher class we need to add a constructor constructor this constructor should take two parameters one is name which we need to pass to the person class and I will show you that in a second the other parameter is the degree so degree now because we added a custom constructor here we need to call the constructor of the person class if you don't do that we'll get an error let me show you so down the bottom of this file let's remove this line teacher dot save the changes back on the console look at this error missing super call in constructor and you can see it's pointing to line 12 this is where we're defining the teacher class right after that we have the constructor this is where the problem is happening so back in the code whenever we had a constructor in a child class we need to call the constructor of its parent class so here in the constructor we have this special keyword super that references the parent class so we call it just like a method and you can see here we have the name parameter so we pass this name argument that we receive here so this will initialize the name property next we need to initialize the degree property so this that degree will set it to this degree argument now finally on line 22 we need to pass the second argument the degree that is let's say Master of Science so if we type teacher dot now you can see we have two properties degree a name as well as two methods teach and walk so this is inheritance in action as you will see in the next section whenever we create a component we should have that component extend the base component that is defined in react because that base component in react has a bunch of methods that we need in our components so we're done with classes next we'll look at modules so here is the code that we wrote in the last lecture currently this file is getting a little bit bloated because we have multiple classes defined in the same file it would be much nicer if we split this code across multiple files and this is what we call modularity so instead of writing all the code in one file we write our code in multiple files we call each file a module in the old days we didn't have the concept of modules natively in JavaScript so there were many thirdparty solutions but starting from Egmont script 6 we have the concept of modules natively in JavaScript so let's go ahead and modularize this application I'm gonna move each class in a separate file let's start with the person class so create a new file back in index that is select the person class cut it and put it here now let's save this as person dot J s similarly we need to go back to index that j s and grab the tshirt class cut it create a new file paste it here and save it as teacher dot J s so now we can see we have less code in each file and our application is more maintainable but we are not done yet when working with modules the objects we define in a module are private by default so that means this teacher class that we have defined here is not visible to any other files or modules in this application in order to make this visible we have to make it public and we do that by exporting this class to the outside so we export it from the teacher class and then we import it wherever we need it so doing that is very easy we simply prefix the class with export ok save the changes similarly we go to the person module so we need to export the person class because we have referenced that and our teacher module here we're using the person class right but currently we have not imported this person class here so on the top we add import curly braces person from in codes you can see intellisense in vs code is suggesting a few libraries like react react Dom and so on these are the libraries that we have specified as dependencies in package.json so let me quickly show you back in the project here the JSON we've got three dependencies here and these dependencies are stored in node modules folder right so currently we don't want to import anything from these modules we want to import from our own modules so let's close this so here we need to pass the relative past or the target file or the target module we start with period slash and that indicates the current folder here are the files in the current folder so we want to import this person class from this person file note that here we don't add the extension just the file name so we don't add dot jas okay and finally we need to terminate this statement with a semicolon so we imported the person class from the person module finally we need to go back to index j s and because here we're using the teacher class we need to import it so once again import curly braces teacher from relative past that is pure slash teacher save the changes now to make sure that everything works let's call the teach method save the changes and here in the console you can see the teach message beautiful so we successfully modularized this an application in the next lecture we'll talk about default and named exports in the last lecture I told you that the objects that we define in a module are private by default so they are not accessible from the outside unless we export them let's explore this topic in a bit more detail so here in our teacher module or teacher that Jas I'm gonna define a function let's call that promote we don't have any code here just a simple function now save the changes back in index j s so at the top you're importing the teacher class from the teacher module temporarily I'm gonna delete this press control space so with the intellisense you can see here we have the teacher class that is exported from the teacher module but we don't see our promote function right so back to teacher that J s if we export this function now we can import it in index AJ s so save the changes back to index J is once again control space look we have the promote function and the teacher class so we can export one or more objects from a given module these are what we call named exports so what is exported has a name like the promote function or the teacher class now apart from named exports we also have the concept of default export and that is the main object that is exported from a module typically we use default exports if there is only a single object that we want to export let me show you what I mean so back to teacher at Jas let me temporarily comment this out so you can see currently we are exporting only a single object that is the teacher class right now you might say what Marsh a class is not an object well in JavaScript technically a class is an object because JavaScript classes are syntactic sugar over constructor functions and functions as I told you before our objects so a class is technically an object in JavaScript now that aside here we're exporting a single object now we can add the default keyword here and that means this teacher object is the main or the default thing that we're exporting from this module now with this back to index is we don't need the curly braces anymore we use these braces only to import the names exports in this case teacher is the default export so we import it like this save the changes you can see our application still working we've got the teach message on the console so let me quickly recap with default exports we import them like this import whatever from this module we named exports we import them like this we put them in curly braces okay now it is also possible that a module has a default export as well as a bunch of named exports react module is an example of that and I'm going to show you that in a second so back to our teacher module here we have a default export but I'm also gonna export this function so we have a named export as well as the default export right save the changes back in index J s so on the top we are importing the default export also we add curly braces control space look we have the pro mode function this is a named export we can import that as well now why does this matter this is a pattern that you see a lot in react applications so as you will see in the following sections on top of almost every file in a react application we have an import statement like this import react comma braces component from react you can see this import statement looks very similar to what we have on line one so let's see what's going on here obviously a react is the module but note that here we don't have period slash because we use them only for our own modules that are part of the project but react is not part of our project it's a thirdparty library that is stored inside of the node modules folder okay now react is the default export from this module where as component is a named export so if I delete this and press control space you can see all the named exports in the react module 99% of the time we're going to use the component class because we want our custom components to extend this component so they will inherit all the behavior all the methods implemented inside of this class ok so that brings us to the end of this section I hope you enjoyed the material and I will see you in the next section
