With timestamps:

00:01 - so what is zamarin forms zamarin forms
00:04 - is a library that enables you to build
00:07 - native apps for iOS Android and Windows
00:10 - using a single C code base if you have
00:14 - any experience with Windows presentation
00:16 - Foundation or silver light zamer informs
00:18 - will be very familiar to you so we have
00:21 - this XML based language called zaml
00:24 - which stands for extensible application
00:26 - markup language and we use this to
00:29 - define the user interface of our
00:31 - applications for example we can Define
00:33 - what elements we have on a page where
00:36 - they are located and what do they look
00:38 - like behind every examl file we have
00:41 - what we call a code behind which is
00:43 - basically a class that implements the
00:46 - behavior for that page for example what
00:49 - should happen when we click a button or
00:51 - select an item from a list so these are
00:54 - the responsibilities of the code behind
00:57 - now in terms of architecture Zam informs
01:00 - is built on top of two existing
01:02 - libraries zamarin Android and
01:04 - xamarin.ios so with zamarin forms we
01:07 - work with a single unified API for
01:10 - creating user interfaces and zamine
01:13 - forms will internally map these user
01:15 - interface elements to their
01:17 - corresponding native equivalent and this
01:20 - makes our applications completely native
01:23 - so we don't have user interface elements
01:24 - that look the same across different
01:27 - platforms if you use a button that
01:29 - button looks different depending on
01:31 - where you run your
01:33 - application also because zamin forms is
01:35 - built on top of z. Android and
01:38 - xamarin.ios you can write platform
01:40 - specific code that uses the API exposed
01:43 - by any of these libraries so you're not
01:46 - limited to a common set of features that
01:48 - are available across all these
01:50 - platforms now the first question that a
01:52 - lot of beginners ask me is Mos do I need
01:55 - to know about z. Android or z. iOS in
01:58 - order to learn zamarin forms not at all
02:01 - the only exception is if you want to
02:03 - write something specific for Android or
02:05 - iOS otherwise for the most part you can
02:08 - learn zamarin forms on its
02:10 - own the second beginner's question is
02:13 - how do I know which zamarin product
02:14 - should I use should I use zamin forms or
02:17 - one of the more specific libraries the
02:19 - answer is it depends what makes zamarin
02:22 - forms powerful is the ability to share
02:25 - most if not all your code across these
02:28 - platforms so you code that application
02:30 - once and then build it for different
02:33 - platforms this building is nothing more
02:35 - than just a compile in Visual Studio
02:38 - that's all you have to do so if you
02:40 - don't need to use much of the platform
02:42 - specific functionality and code reuse is
02:44 - more important to you then go for zamin
02:47 - forms otherwise if you're going to do a
02:49 - lot of customization and have quite a
02:52 - few use cases for working with platform
02:54 - specific API then it's better to use z.
02:57 - Android or z. iOS
03:00 - in terms of tooling you have a few
03:02 - options here if you have a Windows
03:04 - machine you can build and deploy apps to
03:06 - Android and Windows but not iOS for that
03:10 - you need a Mac either a MacBook Pro or
03:13 - an iMac on the other side if you're a
03:16 - Mac User you can build apps for Android
03:18 - and iOS but not for Windows so if you
03:21 - want to Target all platforms you need
03:24 - both a Windows and a Mac machine but
03:26 - this is not a requirement to take this
03:28 - course or to learn Zarin forms in
03:30 - general it's all about where you want to
03:33 - deploy your application you can start
03:35 - with a Windows machine and use Visual
03:37 - Studio to build apps for Android and
03:39 - Windows if in the future you want to
03:41 - build your app for iOS you just add a
03:44 - Mac to your setup and you're pretty much
03:46 - done you don't need to write any new
03:48 - code you just build your project for iOS
03:51 - all right next I'm going to show you how
03:52 - to set up your development
03:56 - environment in this video I'm going to
03:58 - show you how to sell zaring on a Windows
04:01 - and a Mac machine I'm going to start off
04:03 - by setting up on Windows and then I will
04:05 - get to Mac whether you're a Windows or a
04:08 - Mac User be sure to watch this video
04:10 - thoroughly so if you're a Windows user
04:12 - you probably have visual studio so you
04:15 - can install zaring and that will install
04:17 - all the required sdks as well as project
04:20 - templates in visual
04:22 - studio so simply head over to zin.com
04:26 - download fill out this form and be sure
04:29 - to set the answer of this question I
04:31 - already have Visual Studio installed to
04:34 - yes so you don't get Visual Studio you
04:36 - only get zamine
04:38 - installer once you run it you're going
04:41 - to see a dialog box like this be sure to
04:44 - select the following items under
04:46 - crossplatform mobile development so the
04:49 - latest version of
04:51 - c.net zamarin So You see I've currently
04:54 - installed version
04:55 - 4.0.3 but there is a newer version so
04:58 - I'm going to tick that
05:02 - and then under common tools and software
05:04 - development kits select Android native
05:08 - development kit you see I've installed
05:10 - both the 32-bit and 64-bit versions you
05:14 - also need to install Android
05:16 - SDK and then you need to install at
05:18 - least one of Android SDK setups the
05:22 - difference between these items are their
05:23 - version number so you see the first item
05:26 - is API level 19 and 21 and the last one
05:29 - is API level 23 you can go for the last
05:32 - version or if you have enough space on
05:34 - your machine you can install all of them
05:37 - a patchy ant is not really necessary but
05:39 - I have installed it anyway and finally
05:42 - you need to select Java SE development
05:46 - kit now if you have a typical machine
05:49 - and are not part of a network with a
05:50 - proxy server this installation process
05:53 - goes very smoothly but it may fail if
05:56 - you're behind a proxy server or if
05:58 - you're running Windows in a virtual
06:00 - machine on a Mac this happens mainly
06:03 - because zarine installer cannot download
06:05 - some of the required resources so at
06:08 - this point you need to manually install
06:10 - some of these components I've attached a
06:12 - PDF to this lecture with more details
06:14 - about manual
06:15 - installation so hopefully you won't have
06:17 - any problems during the installation but
06:20 - if you encounter any issues you really
06:22 - need to troubleshoot them yourself
06:24 - because every machine is different in
06:26 - terms of the hardware and software and I
06:28 - really cannot help you with that so just
06:31 - Google the exact error message you get
06:33 - and you will definitely find a solution
06:35 - I just want to emphasize do not get
06:38 - discouraged if you get any errors you
06:40 - only need to spend a bit of time to
06:41 - travel through these issues and then
06:43 - everything is going to be fine also it
06:45 - would be really helpful if you post the
06:47 - errors you get and the solutions you
06:49 - find in the discussion board because I
06:51 - can get all these various errors and
06:53 - compile them into a PDF and that would
06:55 - be very valuable resource for future
06:57 - students of this course
07:00 - now what if you're a Mac User you have
07:03 - two options you can either use zamarin
07:05 - Studio on a Mac which is a lightweight
07:07 - IDE similar to visual studio or you can
07:10 - use Visual Studio but this requires a
07:12 - Windows machine in my setup I'm running
07:15 - Windows as a virtual machine using
07:18 - VMware which option is better zamarin
07:21 - studio is the fastest option you simply
07:23 - head over to zar.com download and get
07:26 - zamarin studio and you're good to go you
07:29 - can build apps for IOS and Android but
07:31 - not for Windows if you want to Target
07:33 - Windows you need a Windows machine so
07:36 - you can either get a physical machine or
07:38 - use a virtual machine like me then you
07:40 - need to follow the same steps to install
07:42 - zamarin on your Windows
07:44 - machine in this video I'm going to show
07:46 - you how to create a zamin forms app in
07:48 - Visual Studio whether you're a Windows
07:51 - or a Mac User watch this video
07:53 - thoroughly so here I'm using visual
07:55 - studio 2015 let's create a new
07:58 - project
08:02 - under visual C templates select
08:04 - crossplatform for zamarin form zaps we
08:07 - have two options here portable class
08:10 - library or shared assets the preferred
08:13 - way and the best practice recommended by
08:15 - zamarin is a portable class Library if
08:19 - you want to understand the differences
08:20 - between these two project types I've
08:22 - attached a PDF for you for further
08:24 - reading but read it after watching this
08:26 - video so let's go ahead with this
08:28 - portable class
08:30 - library and I'm going to call our
08:31 - application hello
08:33 - world
08:35 - okay now this process is going to take a
08:37 - few seconds so I'm going to pause the
08:41 - recording okay next you're going to see
08:43 - this dialogue where we select the Target
08:45 - and minimum version for Universal
08:48 - Windows apps a universal windows app can
08:50 - run under Windows 10 or Windows 10
08:53 - mobile without the need to be written
08:55 - for each I'm going to accept the default
08:58 - here
09:00 - okay our solution is ready now before
09:03 - looking at the structure of this
09:04 - solution as a best practice whenever you
09:06 - create a new zamin forms app right click
09:09 - the
09:10 - solution and go to manage new get
09:12 - packages for
09:15 - solution then go to the updates
09:18 - Tab and make sure to select all
09:21 - packages and update
09:23 - them because zamarin frequently releases
09:26 - new
09:28 - libraries okay as part of this update
09:30 - process one of the older packages is
09:32 - going to be uninstalled and for that you
09:34 - need to restart visual studio so
09:37 - we
09:41 - yes okay all the packages are updated
09:43 - properly now let's see what we got here
09:46 - so in this solution we have six projects
09:49 - the first one is our portable class
09:51 - library and this is where we're going to
09:53 - do most of the work so all the code that
09:56 - should be shared across different
09:57 - platforms should be written here
10:00 - and if you look inside we only have one
10:02 - class app which is the starting point of
10:05 - our
10:06 - application next we have five platform
10:08 - specific projects one for Android one
10:11 - for iOS one for Universal Windows apps
10:14 - which can run on Windows 10 or Windows
10:16 - 10 mobile and one for Windows 8.1 and
10:19 - the last one for Windows Phone 8.1 so
10:22 - anytime you want to write platform
10:24 - specific code we'll write it in these
10:26 - projects now as I explained before the
10:28 - whole idea about zamarin forms is about
10:31 - code reuse we want to write code that
10:33 - can run across different platforms
10:36 - that's why we do most of our work in the
10:38 - portable class Library all these
10:40 - projects you see here have a reference
10:42 - to this class
10:43 - library now if you don't have a Mac
10:46 - you're not going to see this iOS project
10:49 - Here Also let's say you only want to
10:51 - build an app for Android and don't care
10:54 - about other platforms you can simply
10:56 - delete these projects here and if in the
10:58 - future you decide to support them you
11:00 - can simply right click the
11:02 - solution add a new project let's say you
11:06 - want to Target iOS then under iOS expand
11:11 - it
11:14 - Universal and here is the blank app
11:16 - template so you just add a project to
11:18 - your solution and you're good to go okay
11:21 - now let's run this app you can see that
11:23 - currently hello world. Droid is set as
11:27 - the startup project so if I press contrl
11:30 - and F5 it's going to be loaded in an
11:32 - Android
11:34 - emulator here on the toolbar we can see
11:36 - the list of emulators installed on my
11:40 - machine these emulators come as part of
11:42 - installing zamarin so if everything goes
11:45 - well during the installation you should
11:47 - see quite a few emulators here but in my
11:50 - case because I'm running Windows in a
11:52 - virtual machine on a ma I had to
11:54 - manually install Android
11:56 - emulators if you want to deploy and
11:58 - debugger your application on a real
12:00 - device you need to set it up for
12:02 - development first and then you can see
12:04 - it listed here so you simply select it
12:07 - and then press contrl F5 to deploy and
12:09 - run the app on your device or F5 to
12:12 - debug it and these are the shortcuts
12:14 - that we always used in C Development
12:17 - I've attached a PDF to this lecture with
12:19 - additional details about setting up your
12:20 - Android or iOS device for development
12:23 - now let's run this app contrl F5 now the
12:27 - first time you launch Android emulator
12:29 - you got to wait quite a few minutes even
12:31 - up to 10 or 15 minutes depending on your
12:33 - Hardware so please be
12:37 - patient and here is my Android emulator
12:40 - and you can see our first zarins app is
12:42 - running successfully so this app is just
12:45 - a single page with a label in the middle
12:47 - of the screen now your emulator may look
12:50 - different in terms of its size and the
12:52 - controls you have here but all these are
12:55 - settings that can be changed when
12:57 - creating an emulator manually
13:00 - now let's say we want to run this app in
13:02 - an iOS simulator so we right click the
13:05 - iOS
13:06 - project and set it as start a
13:10 - project then on the toolbar I can ED a
13:13 - deploy to my device because I have an
13:15 - iPhone or use one of these simulators
13:18 - iPhone 4 5 6 iPad and so
13:22 - on now this simulator actually runs on
13:25 - my Mac not on the windows and here on
13:28 - the toolbar bar we have this icon zarine
13:31 - Mac agent if you don't see this toolbar
13:34 - go to the view menu under
13:38 - toolbars select iOS we also have a
13:42 - toolbar for Android but I have disabled
13:43 - it for
13:46 - now so with this zarine Mac
13:49 - agent we can select the Mac on our
13:52 - Network that is responsible for
13:54 - launching the simulator so visual studio
13:57 - talks to a zarine agent on Mac in order
14:00 - to launch a simulator in most cases your
14:03 - Mac should be automatically detected but
14:05 - if not you can simply click add a Mac
14:08 - add the IP address here and you're good
14:10 - to go just remember you need to install
14:13 - zarine both on your windows and on your
14:15 - Mac
14:17 - machine now I can press crl
14:19 - F5 and this will launch my iPhone
14:22 - simulator on my
14:24 - Mac okay and here's the same app running
14:27 - in an iOS simulator
14:29 - next I'm going to show you how to create
14:31 - a zamarin forms app using zamarin
14:36 - Studio all right now I'm going to show
14:38 - you how to create a zamarin forms app in
14:40 - zamarin studio on a Mac if you're a
14:42 - Windows user you can skip this video but
14:44 - I encourage you to watch it just to get
14:46 - familiar with what your development
14:48 - environment on a Mac would look like so
14:51 - here I'm using zamarin studio version 6
14:53 - and I've changed my theme to dark let me
14:55 - show you how to do it so on the top
14:59 - zarine Studio
15:01 - preferences under visual style set the
15:04 - interface theme to
15:07 - dark all right now let's create a new
15:10 - solution under multiplatform category
15:13 - select app and then forms
15:16 - app next I'm going to call this hello
15:20 - world you can see both Android and iOS
15:23 - are checked but we don't have a check
15:25 - box for Windows because in zamarin
15:27 - studio you cannot Target windows and for
15:29 - that you need visual studio now in terms
15:32 - of the shared code the default setting
15:34 - is on use portable class Library the
15:36 - other option is use shared Library which
15:39 - is not something I would recommend again
15:41 - if you want to know the differences
15:42 - between a portable class library and
15:45 - shared assets look at the PDF I have
15:47 - attached to this lecture
15:50 - next I'm going to accept the defaults
15:52 - here which are about location Version
15:54 - Control and test Cloud so nothing
15:57 - important at this point
16:01 - create okay our project is ready and
16:04 - this is much faster than visual studio
16:06 - now as I told you in the last video as a
16:08 - best practice whenever you create a new
16:10 - zamar forms app make sure to update all
16:13 - the packages so right click the solution
16:16 - and go to update new get
16:19 - packages you can see zamarin studio is
16:21 - updating the packages and this is going
16:23 - to take a little
16:26 - while okay all packages are successfully
16:29 - updated now similar to visual studio you
16:32 - can see that the iOS project is set as
16:34 - the startup project because it's
16:36 - Bal and here on the toolbar we can
16:39 - select a
16:40 - simulator so we've got various versions
16:42 - of iPhone and iPad or we can deploy to a
16:46 - real device now to run this application
16:49 - you press command alt and enter and then
16:52 - iOS simulator launches and loads our
16:55 - application if you want to try the
16:57 - Android app right click this
17:00 - project and set it as startup
17:04 - project now you see all the Android
17:06 - emulators
17:08 - here so throughout this course I'll be
17:11 - using zamarin Studio to do my
17:12 - development because it's much faster and
17:15 - more lightweight if you want to use
17:17 - Visual Studio that's perfectly fine all
17:19 - the code I'm going to write in this
17:20 - course is exactly the same and it
17:22 - doesn't matter which IDE you use it's
17:24 - entirely your personal choice all right
17:27 - next we're going to explore this appli
17:29 - in more detail and add a bit of
17:31 - functionality so you will see both zaml
17:33 - and code behind
17:37 - inaction all right this is what I'm
17:39 - going to build now I want to add a new
17:41 - page to our app with a button in the
17:43 - middle of the screen in iOS buttons
17:46 - don't have a border they look like
17:48 - labels so when we click this button we
17:52 - get an alert so let's go ahead and
17:54 - implement
17:56 - this all right as I explained in the
17:58 - last lecture I'm going to use zamarin
18:00 - studio in this course to doing my
18:01 - development if you want to use Visual
18:03 - Studio that's perfectly fine all the
18:05 - code I'm going to write is exactly the
18:07 - same so as I told you earlier in zarine
18:11 - forms we use zaml which is an XML based
18:14 - language to define the visual appearance
18:16 - of our app and we use code behind to
18:19 - implement how the user interface behaves
18:22 - so I'm going to rightclick our portable
18:25 - class
18:27 - library and add
18:29 - a new
18:31 - file on the left side select forms and
18:34 - on the right side select forms content
18:37 - page zaml and now we give this a name
18:41 - greet
18:44 - page if you're using visual studio again
18:48 - right click the portable class
18:51 - library and a new
18:55 - item in the list of templates select
18:58 - cross PL form and here select forms zaml
19:03 - page and call it greet
19:08 - page so this will add two new files to
19:11 - our project one is GD page. zaml and if
19:15 - you expand it here's the code
19:17 - behind which is just a simple C
19:21 - class and we have the same scenario in
19:23 - zammer in studio so here's our code
19:26 - behind and here's our zaml file
19:29 - as you can see zaml is based on XML the
19:32 - root element here content page
19:35 - represents the type of our page in Zam
19:38 - forms we have a few page types we have
19:40 - content page master detail page
19:43 - navigation page Carousel page and so on
19:46 - we use content page to present some
19:48 - content to the user whether that being
19:51 - text images or the combination of the
19:53 - two now let me break up this line so you
19:56 - can see more
19:57 - clearly in our content page element we
20:00 - have a couple of XML namespace
20:03 - declarations the first one is owned by
20:06 - zamarin and this namespace is for
20:08 - elements that have no prefix like this
20:11 - content page element so this element
20:14 - belongs to zamarin to zamarin forms we
20:17 - have another namespace declaration which
20:20 - identifies a prefix so this colon X
20:23 - syntax is used to declare a prefix and
20:26 - if you look at the URI assigned to this
20:28 - X ml namespace you can see that this
20:30 - namespace is owned by Microsoft which
20:33 - represents the standard zaml that
20:35 - Microsoft introduced in year 2009 now
20:38 - what is this colon X here that means any
20:41 - elements or any attributes that is
20:43 - prefixed with an X belongs to this name
20:46 - space look at this attribute the class
20:50 - attribute it's prefixed with an X and we
20:53 - call it X class so this attribute
20:55 - belongs to the Microsoft namespace now
20:58 - look at the value assigned to this
21:00 - attribute it's hello world. greet page
21:03 - which is the fully qualified name of our
21:06 - code behind class so if we switch to the
21:08 - other tab look the name of our class is
21:11 - greet page and it's placed in hello
21:13 - world
21:14 - namespace so using x-class attribute we
21:17 - establish a link between the zaml file
21:20 - and the code behind file now remove the
21:23 - content of this content page
21:26 - element and instead let's add a button
21:29 - so
21:31 - button I want to put this button in the
21:33 - middle of the screen so we set
21:35 - horizontal options to
21:38 - Center and vertical options to
21:42 - Center next we set the text
21:46 - attribute click me so this way with zaml
21:50 - we're defining the visual appearance of
21:51 - our page now what about the behavior
21:54 - when we click this button I want to
21:56 - display an alert in zammer inform ter
21:59 - buttons have an event called
22:01 - clicked so we set clicked to a string
22:06 - and this identifies the name of the
22:08 - method in the code behind that should be
22:10 - called when this event is raised you can
22:13 - see zaran Studio or Visual Studio is
22:15 - suggesting a name for this method handle
22:18 - underline clicked so we press enter that
22:22 - brings us to the code behind press enter
22:24 - again and that generates our event
22:27 - handler so this event handler as you see
22:30 - it's a private method because it doesn't
22:31 - have an access modifier like public it
22:34 - has two arguments one is an object which
22:37 - is the cender or source of the event and
22:39 - the second one is event arcs which
22:41 - brings additional details about an event
22:44 - if this method looks strange or
22:46 - unfamiliar to you I highly recommend you
22:48 - to watch my C Advanced course because
22:50 - there I have a complete lecture on
22:52 - events and handlers now I want to change
22:55 - the implementation of this
22:57 - method to display an alert we call
23:00 - display alert method we inherit this
23:03 - method from content page class which is
23:06 - the base class for our greed
23:08 - page so the arguments we Supply here is
23:12 - the title of the dialog box the message
23:15 - we want to display like hello
23:18 - world and a label for the cancel button
23:22 - let's just call this
23:23 - okay potentially we could Supply another
23:26 - argument if you want to have two buttons
23:28 - like okay and cancel or yes and no but
23:32 - for this video we don't have to worry
23:33 - about it now in terms of clean coding we
23:37 - should keep the Constructor of our
23:38 - classes on the top so I want to move
23:40 - this method
23:45 - down okay we're done with this new page
23:48 - now we want to make sure that this page
23:49 - is displayed when our app is started so
23:53 - back to our solution
23:54 - view in the portable class Library you
23:57 - see we have a file called app. zaml
24:01 - let's expand this here's our code
24:04 - behind you can see here main page
24:07 - property is set to a new instance of
24:08 - hello world page main page is a property
24:12 - that is defined in the base application
24:14 - class and we use that to set the
24:17 - starting page of our
24:19 - application so I'm going to change this
24:22 - to new greed page now let's run this in
24:26 - zamer in studio I'm going to press
24:28 - command alt and enter in Visual Studio
24:30 - you press control and F5 but before
24:33 - doing so make sure in the solution
24:36 - Explorer set one of these platform
24:38 - specific projects as the startup project
24:41 - I'm going to use iOS you can use
24:42 - whatever you want so let's run the
24:46 - application okay here's our
24:50 - button so now you have an idea of what
24:52 - it's like to build crossplatform apps
24:54 - using zamarin
24:57 - forms
24:59 - so you have seen zamarin forms in action
25:01 - and you know that with zamarin forms you
25:03 - can build native apps for different
25:05 - platforms but you might be curious how
25:08 - zarine actually achieves this so let me
25:11 - give you a bit of background all zarine
25:13 - products like zamarin Android
25:16 - xamarin.ios and zamarin forms are built
25:19 - on top of mono which is an open- Source
25:22 - version of net that runs on various non-
25:25 - Windows platforms like Linux Unix and
25:28 - and OSX mono is a project that has been
25:31 - around since pretty much as long as net
25:33 - itself but it wasn't very popular until
25:36 - recent years in the mono world we had
25:39 - two releases one was called Mono for
25:41 - Android which was later renamed to z.
25:44 - Android and the other release was
25:46 - monotouch which is now what we call
25:49 - xamarin.ios
25:51 - both these libraries give you access to
25:53 - the net Base Class Library so you have
25:57 - the same name spaces your familiar with
25:59 - you got the same classes with the same
26:01 - interfaces but they also give you access
26:04 - to the native API under platform so you
26:08 - have access to additional assemblies and
26:10 - name spaces that mimic the ones that
26:12 - come natively with Android and
26:15 - iOS these are the classes that Objective
26:18 - C or Java developers work with when they
26:21 - build native apps for Android and iOS
26:24 - when using z. Android or z. iOS we work
26:28 - with classes just like standard C
26:30 - classes in net and these libraries will
26:34 - internally call the corresponding API on
26:37 - the target platform now how that happens
26:40 - it's pretty complex and it's not
26:42 - something we need to worry about that's
26:44 - something that developers at zamarin
26:45 - have to deal with now that you have an
26:48 - understanding of zamarin Android and
26:50 - xamarin.ios let's get a little bit more
26:53 - specific here when you build an
26:55 - application with zarine Android zamarin
26:58 - C compiler compiles down your C code to
27:02 - Intermediate Language or ilil it also
27:06 - EDS the monorun time with your
27:08 - application this monor run time is
27:10 - similar to CLR that you should probably
27:12 - be familiar with so when you launch an
27:15 - Android app this runtime is loaded into
27:17 - the memory and then it gets your IL code
27:20 - and compiles it to the native code for
27:22 - Android and this process is what we call
27:25 - Just in Time compilation or jit
27:28 - this is the same mechanism that is in
27:30 - place when you build a regular net
27:33 - application with C when you build a
27:35 - console desktop or web application the
27:38 - same magic
27:39 - happens now with iOS we have a different
27:42 - story apple does not allow jitting so
27:46 - when you build your iOS application
27:48 - zarine C compiler first compiles your C
27:51 - code down to Il and then it uses Apple
27:54 - compiler to compile it to native code
27:57 - and that's why you need an apple machine
27:59 - so the output is native code that iOS
28:02 - can understand and there's no jitting
28:04 - involved here in other words when you
28:07 - ship your application there is no monor
28:10 - runtime embedded in your
28:12 - application so this is how z. Android
28:15 - and xamarin.ios work but what about
28:18 - zamin fors well zamin forms is built on
28:21 - top of these two libraries so we have
28:24 - this assembly called z. forms. core and
28:28 - here we have classes that Define a
28:30 - common unified API to work with
28:32 - different platforms for example we have
28:35 - a class called bun and this is the bun
28:38 - that we reference in zaml or in code
28:40 - behind now we have another bunch of
28:43 - platform specific assemblies that map
28:45 - these common objects in zamin forms to
28:48 - their corresponding native equivalent
28:51 - let me show you so here in this blank
28:53 - solution let's expand this portable
28:56 - class library now under
28:59 - references under from
29:02 - packages look we've got zamarin forms.
29:06 - core and this is the assembly that
29:08 - defines that common API that we work
29:10 - with so here we've got classes like
29:13 - Buton label list view page and so on now
29:18 - if you look at one of the platform
29:19 - specific
29:21 - projects like the Android one again
29:24 - under
29:25 - references from packages
29:29 - now here we have an assembly called
29:31 - zamarin forms. platform. Android and
29:35 - this is the assembly that is responsible
29:37 - for mapping those common controls we
29:39 - have in zamarin forms. core into their
29:42 - corresponding Android equivalent and in
29:46 - this assembly we have a bunch of what we
29:48 - call renderers so these are the classes
29:51 - that know how to render for example a
29:53 - label or a button now we have the same
29:56 - architecture in other projects projects
29:58 - so let's expand the iOS project
30:02 - references from packages now look we've
30:06 - got zamarin forms. platform. iOS so this
30:10 - is how zamarin forms
30:14 - works all right let me quickly give you
30:16 - an overview of how I have structured
30:18 - this course and where you will find the
30:21 - content you're looking for in the next
30:23 - section you're going to learn the basics
30:25 - of zaml and this gives you a good found
30:28 - to progress through the rest of the
30:30 - course next we're going to look at
30:32 - layouts which we use for arranging
30:34 - visual elements on screen so you will
30:37 - learn how to build user interfaces like
30:40 - these next you're going to learn about
30:42 - images you will learn about downloading
30:44 - images from the Internet or embedding
30:47 - them in your applications you will also
30:49 - learn about
30:50 - icons after that we're going to look at
30:53 - lists so you will learn how to present
30:55 - data in beautiful intera active lists
30:59 - following that we're going to look at
31:01 - navigation you will learn how to
31:03 - navigate users from one page to another
31:06 - how to implement Master detail how to
31:08 - implement tabs how to display popups and
31:11 - so on next you're going to learn how to
31:14 - accept input from the user and this will
31:17 - help you build forms and setting pages
31:20 - but we're not going to talk about saving
31:21 - or loading settings in this section
31:24 - that's the topic for the following
31:25 - section so in data access section you
31:28 - will learn various ways you can store
31:30 - application data you will learn about
31:33 - application properties you will learn
31:35 - about file system you'll learn about
31:37 - storing structured data in a SQL light
31:40 - database and finally you will learn
31:41 - about consuming restful Services now if
31:44 - you don't know what restful is all about
31:46 - don't worry I've got some PDFs for you
31:49 - so you're in good
31:50 - hands next we're going to look at mvvm
31:53 - architecture pattern I will explain what
31:56 - mvvm is
31:58 - when you should use it and why and how
32:00 - to implement it but briefly we use mvvm
32:04 - for decoupling our application from a
32:06 - presentation framework like zamine and
32:08 - we do this for
32:10 - testability so at the end of this
32:12 - section I've got a short video where I
32:14 - show you how to unit test your view
32:16 - models more on this later and finally in
32:19 - the last section we're going to look at
32:21 - some more practices and features that
32:23 - are useful in building larger complex
32:26 - applications and in this section I will
32:28 - show you some of the useful plugins that
32:30 - you can use to access common device
32:33 - functionality like using the camera GPS
32:36 - checking the status of the battery
32:38 - detecting motion accessing contact book
32:41 - and so on so there is a lot to cover
32:44 - over the next 7 hours and I hope by the
32:46 - end of watching this course you will
32:48 - have a very solid foundation to build
32:50 - crossplatform mobile apps using zamin
32:54 - [Music]
32:56 - forms
32:59 - [Music]
33:02 - well hello it's Marsh here I hope you've
33:05 - been enjoying watching my Z forms
33:06 - tutorial in case you didn't know this
33:08 - tutorial is the first hour of my
33:11 - comprehensive 7 and 1 half hour course
33:13 - on uny in this course you will learn how
33:16 - to build native mobile apps for Android
33:19 - iOS and windows with C if you're
33:22 - interested to have this course you can
33:24 - get it with a big discount using the
33:26 - link in the video description
33:28 - and if not that's perfectly fine
33:30 - continue watching as the next section is
33:32 - coming
33:38 - up so as I explained in the last section
33:41 - zaml is an XML based language that we
33:44 - use to define the visual appearance of
33:46 - our applications we're going to use zaml
33:48 - a lot throughout this course so in this
33:50 - section you're going to learn zaml in
33:52 - more detail and by the end of this
33:54 - section you will have a good foundation
33:56 - that will help you progress through the
33:58 - rest of the course so let's get
34:00 - [Music]
34:05 - started okay continuing from the project
34:07 - we created in the last section in our
34:10 - greed page first I'm going to delete
34:12 - this
34:13 - button and then in the code behind I'm
34:15 - also going to remove this event
34:18 - handler now back in the zaml file I want
34:21 - to put a label on the page so
34:24 - label I want to put it in the middle of
34:26 - the screen so horizontal options
34:30 - Center vertical options
34:33 - Center and text hello
34:37 - world now we can create the same UI
34:40 - using Code instead of zaml let me show
34:43 - you how so back in the code behind in
34:47 - the
34:47 - Constructor after the call to initialize
34:50 - component we can set the content
34:52 - property of our page this property is
34:55 - derived from content page which is the
34:58 - base class for our greed
35:00 - page now we can set this to a new
35:03 - label and set its properties here so
35:07 - horizontal
35:08 - options we set this to layout options
35:12 - which is an enumeration do
35:15 - Center similarly for vertical
35:19 - options do Center and finally
35:24 - text now don't worry about this red line
35:26 - under initial component I think there's
35:29 - something wrong with my Zam in studio
35:32 - now that aside we can see that we can
35:33 - create user interfaces using Code as
35:36 - well in this case I'm sending the
35:38 - content property to a new label and this
35:41 - is exactly equivalent to what we put
35:45 - between opening and closing tags of
35:47 - content page element now you might ask
35:50 - msh what do we want to create user
35:52 - interfaces in the code as opposed to
35:54 - zaml well in more than 90% of the cases
35:57 - you would use ZL you would use code only
36:00 - if you want to add elements on a page
36:03 - dynamically for example depending on
36:05 - different circumstances you may want to
36:07 - add a label or a button or a slider or
36:09 - whatnot and all this can happen
36:11 - dynamically but as I said this is the
36:14 - kind of behavior that most applications
36:16 - don't exhibit so all I want you to take
36:19 - away here is that if you want to put
36:21 - elements on a page dynamically you can
36:23 - do it in the code now why is zaml better
36:27 - than the code
36:28 - because it's cleaner and less noisy look
36:30 - at these properties here horizontal
36:32 - options and vertical options we're
36:34 - simply setting them to your string Value
36:38 - Center now look at the equivalent in the
36:40 - code we have to prefix this value with
36:43 - layout options the name of the
36:45 - enumeration so there is a little bit of
36:47 - noise in the code and this can get worse
36:50 - when you're dealing with complex
36:52 - hierarchical structures in those
36:55 - situations zaml is a definite ER because
36:58 - XML is naturally
37:01 - hierarchical now the reality is even
37:03 - when we use zaml at run time we have a
37:06 - zaml parser that reads this zaml file
37:09 - and it will instantiate objects just
37:11 - like the code we have written here so
37:13 - the exact same code will be executed by
37:16 - the zaml parser let me show you when it
37:18 - happens so in the
37:21 - solution I'm going to right click the
37:24 - solution and set display options to show
37:27 - off all
37:29 - files if you look at the object
37:31 - folder under
37:34 - debug we have a file here hello world.
37:37 - greet page. zaml dog which stands for
37:41 - generated.
37:44 - CS so this class is automatically
37:46 - generated for us you can see it's a
37:49 - partial class so part of that is here
37:51 - and the other part is in the code
37:55 - behind you can see here we have a call
37:57 - to initialize component method now you
38:01 - might think this method is inherited
38:02 - from content page but no it's not there
38:06 - it's defined in this generated code look
38:10 - it's
38:10 - here and inside this method we have a
38:13 - call to load from
38:15 - zaml so when we compile our application
38:18 - our zaml files are embedded in our
38:21 - assembly and at runtime when initialized
38:23 - component is called this zaml file is
38:26 - extracted from the assem
38:28 - and pass to the zaml parser then zaml
38:31 - parser will take that zaml and generate
38:34 - a user interface like
38:36 - this all right so for now I'm going to
38:40 - delete this code
38:43 - here and we're just going to stick to
38:45 - zaml for creating user
38:47 - interfaces next I'm going to talk about
38:49 - content
38:53 - property all right now let me show you
38:55 - something I want to put a slider below
38:58 - this
38:59 - label
39:01 - slider but if I run this application
39:04 - now we only see the label not the slider
39:08 - but why is that all right let's have a
39:10 - look at zaring documentation to figure
39:12 - out
39:13 - why so I'm going to search for
39:16 - zamarin Content page
39:23 - class all right look at the Declaration
39:25 - of content page class this class is
39:28 - decorated with an attribute called
39:29 - content
39:31 - property and in this attribute we have a
39:34 - string which specifies one of the
39:36 - properties of content page in this case
39:39 - the name of that property is content and
39:41 - you saw that in the last lecture we set
39:44 - the content property to a new label
39:47 - remember now let's look at the
39:48 - Declaration of the content
39:53 - property look here's the content
39:55 - property it's type is a view view is the
40:00 - base class for all our visual elements
40:03 - like buttons labels sliders and so on so
40:06 - because the type of content is view we
40:09 - can set it to an instance of a single
40:11 - view not multiple
40:13 - views that's why we cannot have multiple
40:16 - children or multiple widgets or multiple
40:19 - views inside content page element so
40:22 - what's the solution let me introduce you
40:25 - to a new element
40:28 - stag
40:30 - layout and then I'm going to move these
40:33 - two widgets inside stack layout with
40:38 - stack layout we can stack multiple
40:40 - widgets horizontally or vertically now I
40:43 - want to make sure both the label and the
40:45 - slider are in the middle of the screen
40:47 - so I'm going to grab these two
40:49 - properties horizontal and vertical
40:53 - options and apply them to slack layout
40:57 - now let me run the application
40:59 - again and here's the result so here's
41:02 - our label and here's the
41:05 - slider now let's inspect stack layout
41:07 - class so we search for zamon stack
41:11 - layout
41:15 - class look this class deres from layout
41:19 - of
41:21 - view now if you look at the Declaration
41:23 - of layout class you can see the content
41:26 - property attribute the game and look the
41:29 - name of the content property for the
41:31 - layout is children so let's look at the
41:34 - children
41:36 - property now if you scroll down you're
41:38 - not going to see that children property
41:41 - you have to navigate up the hierarchy so
41:44 - we go to the layout
41:46 - class and layout class implements I
41:49 - layout controller let's look at this
41:54 - interface now look at the children
41:56 - property it's of type I read only list
42:00 - so this children property because it's a
42:03 - kind of list it can contain multiple
42:05 - widgets and that's the reason we can use
42:08 - a stack layout to stack multiple widgets
42:11 - on the
42:12 - screen all right next we want to take
42:14 - this application to the next level so we
42:16 - want to add this Behavior such that when
42:19 - we move this slider the label is updated
42:22 - to show the current value of the
42:26 - slider
42:28 - all right now we want to take this
42:29 - application a little bit further so we
42:31 - want to add this Behavior such that when
42:33 - we move the slider the label is updated
42:36 - to show the current value of the slider
42:38 - to implement this we need to handle the
42:41 - value change event of the slider and
42:44 - then in our event handler we can get the
42:46 - current value and then set the label so
42:49 - pretty basic in the first section you
42:52 - saw an example of handling the click
42:53 - event of a button in zamin forms so the
42:57 - technique we're going to use here is
42:58 - exactly the same for the slider we
43:01 - handle the value changed event and set
43:05 - this to the name of a method in our code
43:07 - behind so enter
43:10 - enter now I'm going to move this
43:14 - down okay inside our event handler we
43:17 - can use this e argument pass to this
43:19 - method to get the new value of the
43:23 - slider but we need a reference to the
43:25 - label so we can set its text
43:27 - how do we do it well back in our examl
43:32 - I'm going to give this label a name or
43:34 - an ID
43:36 - so we use one of the attributes defined
43:40 - in Microsoft
43:42 - namespace so X colon
43:46 - name this x is a prefix which is
43:48 - declared in the XML namespace
43:50 - declaration for Microsoft namespace so
43:54 - this name attribute belongs to the
43:56 - standard Zam that Microsoft introduced
43:58 - in 2009 and it's applicable in other
44:01 - Frameworks that use ZL like silver light
44:04 - or Windows presentation Foundation or
44:07 - zammer in forms now we set this name to
44:10 - an identifier like
44:13 - label now when I save this
44:16 - file and go back to the code
44:20 - behind I can type label Dot and here we
44:23 - have access to our label so we can set
44:26 - the text property
44:28 - I'm going to use string.
44:31 - format value is provide an argument
44:35 - here and then set it to e do new
44:39 - value now the value we get here is a
44:41 - floating Point number between 0 to one
44:44 - and there are a lot of digits after
44:46 - decimal point so I would like to format
44:48 - this
44:50 - value to a fixed point with two digits
44:53 - after the decimal point so let's run the
44:56 - application
44:59 - okay now if I move this slider look the
45:01 - value is
45:03 - updated and this is a pattern that you
45:05 - see in a lot of real world applications
45:07 - but the value may be displayed as
45:09 - percentage now there is just one tiny
45:11 - problem with this application let me
45:13 - restart
45:15 - it the label is displaying hello world
45:18 - instead of the current value of the
45:20 - slider to fix this in the
45:24 - Constructor after the call to initialize
45:26 - component we can explicitly set the
45:29 - value of the slider so again we need a
45:31 - reference to this slider object so back
45:34 - in our examl
45:35 - file we use x name
45:39 - attribute and give it an identifier
45:42 - slider save now back in the code behind
45:47 - we can type
45:48 - slider. value we can say it to zero or
45:53 - 0.5
45:54 - whatever let's run the application again
45:58 - okay that's much better now let me give
46:01 - you a bit more insight about this x name
46:05 - attribute so under the object folder
46:10 - debug open up hello world. greet page.
46:14 - zl. g.
46:17 - CS look we have two private Fields here
46:21 - one is a label the other is a slider and
46:24 - in initialized component method after
46:27 - the call to load from zaml these private
46:30 - fields are initialized so we have this
46:33 - method find by name which is inherited
46:35 - from content page The Base Class of our
46:38 - greed page and we give this method an
46:40 - argument which specifies the name or the
46:43 - identifier for our
46:45 - widget with this after initialized
46:48 - component we can access this private
46:51 - field like in this case the
46:53 - slider just remember if you put this
46:56 - line before initialized component you're
46:58 - going to get a null reference exception
47:00 - because that private field is not
47:02 - initialized at that
47:04 - point so in this lecture you learn how
47:06 - to access elements in code behind using
47:09 - xname
47:10 - attribute now even though our
47:12 - application is fully functioning but
47:14 - there is a simpler and cleaner way to
47:16 - implement the exact same functionality
47:18 - and that's called Data binding which I'm
47:20 - going to show you in the next
47:24 - lecture all right now let's see how we
47:26 - can use data binding to implement the
47:28 - same behavior data binding is a concept
47:31 - that you see in a lot of UI Frameworks
47:34 - like WPF and silver light and even in
47:36 - web applications we have Frameworks like
47:39 - angular and knockout and many others
47:41 - that provide this concept of data
47:43 - binding basically what it means is that
47:45 - we bind a property of a user interface
47:47 - element to a property of another object
47:51 - in this case we want to bind the text
47:53 - property of the label to the value
47:55 - property of the slider
47:57 - so when the value of the slider changes
47:59 - the text property of the label is
48:01 - automatically updated with this we don't
48:04 - have to manually handle the value change
48:06 - event of a slider which means we don't
48:09 - need to create this event handler either
48:11 - so our code would be cleaner and more
48:14 - maintainable internally the framework
48:17 - itself will create this event handler
48:19 - based on our binding expression so let's
48:22 - see how we can do this first of all I'm
48:24 - going to remove this event
48:25 - handler
48:27 - and back in
48:28 - zaml I'm also going to remove the value
48:31 - changed attribute of
48:34 - slider now we want to bind the text
48:36 - property of the label to the value
48:38 - property of the slider so we need to use
48:41 - a special Syntax for this so far all the
48:44 - attribute values you have seen have been
48:47 - strings at run time these strings are
48:50 - converted to a primitive type or an
48:52 - object using a type converter in case of
48:55 - data binding we cannot conver convert a
48:57 - string value to a binding expression
48:59 - that's why we need a special syntax and
49:01 - in zaml this is called zaml markup
49:05 - extensions
49:07 - so we use curly braces to instruct zaml
49:11 - parser that this is not a string literal
49:14 - and it's a markup extension there are
49:16 - many different markup extensions
49:18 - available in zaml and in this video
49:20 - you're going to learn two of them the
49:22 - first one is binding
49:24 - so curly braces
49:27 - binding now to set up binding we need to
49:30 - specify what object we want to bind the
49:33 - text property to so we set source
49:37 - to now here we want a reference to the
49:40 - slider object that's when we use another
49:43 - Mark of extension so again curly
49:47 - braces now this Mark of extension is
49:50 - called X reference so X colon reference
49:55 - and we use that to ref refence another
49:57 - object in this zaml file not that is
50:01 - prefixed with X which means this belongs
50:04 - to the standard zaml that Microsoft
50:06 - introduced in year 2009 if you work with
50:09 - other zaml based Frameworks like WPF or
50:12 - silver light you would see this now
50:15 - after X reference space we need to
50:18 - specify the name of the target element
50:21 - in this case
50:23 - slider and this is based on the value of
50:25 - x name add attribute all right so here's
50:28 - the source object now what property of
50:31 - this object are we interested in the
50:33 - value property which represents the
50:35 - current value so after Source
50:40 - comma path equals
50:44 - value we call this path instead of
50:46 - property because that property itself
50:49 - may be an object and we may want to use
50:51 - the dot notation to access another
50:53 - property like a b do c that's why it's
50:56 - it's called path all right that's pretty
50:59 - much all we have to write now if we run
51:02 - this
51:03 - app this is what we get note the label
51:08 - previously we formatted this number with
51:10 - two digits after the decimal point so
51:12 - let's go ahead and do
51:14 - this back here so in our binding
51:17 - expression we have set up Source path
51:21 - and now the third
51:22 - property string
51:25 - format equal
51:27 - and we use single quotes to
51:29 - differentiate from double quotes for the
51:31 - value of the text
51:33 - attribute now here we Supply a standard
51:37 - C string format so value
51:42 - is Curly braces zero represents the
51:45 - first argument colon F2 for
51:50 - formatting now let me break this up into
51:52 - multiple
51:54 - lines okay this is clear cleaner and
51:56 - more
51:57 - maintainable now let's run the
51:59 - application
52:01 - again okay that's exactly like
52:07 - before now let's take this to the next
52:09 - level what if we also want to bind the
52:12 - opacity property of the label to the
52:15 - value of the slider so let's try another
52:18 - binding
52:21 - expression opacity we use curly braces
52:25 - for markup extens extensions the first
52:28 - Mark of extension is
52:30 - binding now here we need to specify the
52:32 - source
52:35 - object equals another markup extension
52:39 - we use x reference to reference the
52:43 - slider then we set the
52:46 - path to the value property of the
52:49 - slider now we don't need a string format
52:51 - because opacity is just a number between
52:53 - 0 to one now let me run this application
52:58 - and here's the result note that the
53:00 - label is a little bit grayed out and if
53:03 - we move the slider to the left it
53:06 - becomes transparent or if you go to the
53:08 - right it becomes
53:10 - opaque but look at our binding
53:13 - expression these bindings are a little
53:15 - bit noisy in both cases we are using the
53:19 - slider as the source object so let me
53:21 - show you how to remove this noise and
53:23 - make this code a little bit cleaner and
53:25 - more maintainable
53:28 - we can set the binding context attribute
53:31 - of the label to our
53:33 - slider so again we use markup extension
53:38 - X reference
53:41 - slider now slider will be the source
53:44 - object for any properties of the label
53:47 - which means in our binding expressions
53:49 - for the text and opacity properties we
53:52 - don't need to repeat this line
53:55 - remove
53:57 - remove also we can take this to the next
54:00 - level and remove path equals value and
54:03 - just add
54:04 - value like this so we can put this on
54:08 - the same line binding to
54:10 - value and same
54:15 - here that's definitely
54:17 - cleaner now let's take this to the next
54:19 - level I want to add a box view a box
54:23 - view is a box filled with a color so a
54:26 - of the
54:27 - label I'm going to add a box
54:32 - view set its color to let's say
54:36 - green and again I want to bind its
54:38 - opacity property to the value of the
54:41 - slider so opacity equals markup
54:46 - extension binding we set the
54:49 - source another binary expression X
54:53 - reference
54:55 - slider and pass equal
54:59 - value let's run this
55:03 - application okay here's the
55:09 - result again you see there is a little
55:11 - bit of duplication in this code both the
55:14 - Box View and the label are referencing
55:16 - the slider as their binding context so
55:20 - we can basically move this binding
55:22 - context setup from the
55:25 - label
55:26 - to our stack layout the container for
55:30 - box View and the
55:32 - label and this will be inherited by all
55:35 - the elements inside stack layout which
55:38 - means we can simplify this binding
55:40 - expression for the opacity of the Box
55:42 - view remove the
55:45 - source and the
55:50 - path so this is how we set up data
55:52 - binding now finally we don't really need
55:55 - this X name for the label because we
55:58 - have not referenced it anywhere so we
56:00 - can delete it all right next I'm going
56:03 - to show you how to deal with Device
56:08 - differences all right now let me show
56:10 - you something don't type anything just
56:13 - watch for the stack layout I'm going to
56:16 - remove vertical options
56:19 - attribute let's run this application in
56:21 - Android and see what
56:24 - happens okay this is what we get note
56:27 - that the Box view is on top of the page
56:30 - just below the blue bar now I'm going to
56:33 - run the same app in
56:37 - iOS okay and this is what we get again
56:40 - note where the Box view is
56:42 - located in Android our page started
56:46 - right below the blue bar but in iOS our
56:49 - page starts right from top of the
56:51 - screen so if you had some text here
56:54 - instead of box view that text would
56:56 - Clash with the current time so this is
56:59 - one of the key differences between
57:01 - Android and iOS in this video I'm going
57:03 - to show you how to add some padding to
57:05 - top of the page but only in
57:07 - iOS so back in zamarin
57:10 - studio in this video I'm going to show
57:12 - you how to do this in code behind and
57:14 - then in the next video I'll teach you
57:16 - how to achieve the same thing in zaml
57:18 - the reason I want to introduce you to
57:19 - code behind is so that you have better
57:22 - understanding of what happens under the
57:24 - hood so
57:27 - we have this class called
57:29 - device and this has a static property
57:32 - called OS which is an enumeration of
57:35 - type Target
57:37 - platform so we can check if Target
57:41 - platform is
57:43 - IOS then we set padding of the page
57:47 - which we inherit from content page class
57:50 - to a new thickness object thickness has
57:54 - a few different Constructors and the one
57:56 - I'm going to use now takes four
57:58 - arguments left top right and bottom it's
58:03 - good to remember this order because
58:04 - you're going to use this a lot so left
58:08 - zero top 20 zero and
58:11 - zero so with iOS we always want to add
58:14 - 20 pixels on top of our page so the
58:17 - content of the page does not clash with
58:19 - the standard bar on top of the
58:22 - screen now even though this code is
58:24 - perfectly fine let's let's just assume
58:26 - we want to have different paddings for
58:28 - Android and
58:30 - Windows so if you want to use the same
58:32 - Technique we would end writing code like
58:35 - this else if device.
58:38 - OS equals Target platform.
58:43 - Android something like this now don't
58:46 - worry about these numbers these are just
58:48 - arbitrary now I want to show you a
58:50 - cleaner way to write the exact same code
58:53 - this device class has a method called on
58:58 - platform and this method has two
59:00 - overloads one that is generic as you see
59:03 - here and the other that takes actions
59:06 - I'm going to start with the generic one
59:08 - because it's easier to
59:10 - understand so we Supply the generic
59:12 - parameter in this case I want different
59:15 - thickness objects for different
59:17 - platforms so the generic parameter is
59:20 - thickness now we can supply different
59:23 - thickness objects for different
59:24 - platforms and to make make the code
59:26 - cleaner we can use name parameters in C
59:29 - so
59:31 - iOS new
59:39 - thickness also you can see that
59:41 - thickness here is great out so we can
59:43 - refactor this
59:45 - code and remove it now compare this code
59:49 - with what we wrote earlier we don't have
59:52 - all this if else if else if the code is
59:55 - cleaner and more focused so internally
59:59 - in this method on platform we actually
60:02 - going to have code like what you see on
60:04 - the top so this method takes care of all
60:06 - these conditional statements and Returns
60:09 - the proper thickness object based on the
60:12 - current operating system so then we can
60:15 - get the result from this method and
60:17 - assign it to
60:19 - padding we can use this on platform
60:22 - method with pretty much any objects in
60:24 - this case we interested in thess in your
60:27 - applications you might be interested on
60:29 - an integer being different across
60:31 - different platforms then you would
60:33 - supply three integer
60:36 - arguments now as I explained earlier
60:38 - this on platform method also has a
60:41 - non-generic overload let me show you how
60:43 - that one
60:46 - works so device. on
60:49 - platform I'm going to use the
60:51 - non-generic overload you can see here we
60:54 - have four parameters and they all are
60:57 - optional because they are set to null so
61:00 - let's say I want to execute some code
61:02 - only on
61:04 - iOS then I can supply the name parameter
61:06 - here
61:08 - iOS and here I need to specify an action
61:12 - so I'm going to use a Lambda expression
61:13 - for
61:15 - that like this now if you're not sure
61:18 - what this all means you really need to
61:20 - watch my C Advanced course because I've
61:22 - talked a lot about Lambda expressions
61:24 - and actions there
61:26 - so here in this block we can write the
61:28 - code that we want to be executed on
61:31 - iOS for example we can set
61:34 - padding to thickness
61:38 - object this is another way to set the
61:41 - padding
61:42 - property also for discussion sake let's
61:45 - say we want to have a different piece of
61:47 - code to be executed on
61:49 - Android then we set the name parameter
61:54 - action we use a Lambda
61:57 - expression and here we write the Android
62:00 - specific code so this is how we use
62:03 - device.on platform method whether the
62:06 - generic overload or the non-generic one
62:09 - now as I explained before we aim to use
62:12 - zaml to define the visual appearance of
62:14 - our
62:15 - applications so in the next lecture I'm
62:17 - going to show you how to use on platform
62:20 - in
62:23 - zaml all right now let's see how we can
62:25 - set padding using zaml so in the last
62:29 - lecture you learned that padding is a
62:31 - property of the page and we can set it
62:33 - to a thickness object like
62:37 - this and obviously this applies to all
62:40 - platforms now if you want to apply this
62:43 - padding using
62:45 - zaml we can easily do so like
62:48 - this so for our content page element we
62:52 - set the padding attribute to a string
62:54 - literal
62:57 - now at run time zaml parser will get
63:00 - this string and give it to a type
63:02 - converter which will parse this into a
63:05 - thickness object and again this will
63:08 - apply to all platforms now what if you
63:11 - want to apply this only to iOS then we
63:14 - need to use an element called on
63:18 - platform on
63:21 - platform and this element has attributes
63:24 - like iOS Android and so on but the
63:28 - problem is we cannot use this element as
63:31 - the value of the padding attribute
63:33 - because these values as you have seen so
63:35 - far are either simple strings or zaml
63:38 - markup extensions but they cannot be an
63:40 - XML element that's when we use a special
63:44 - syntax in examl called property element
63:47 - syntax let me show you how it works so
63:50 - first I'm going to remove this
63:53 - attribute now inside content page
63:56 - element I'm going to add another element
63:59 - content page do
64:03 - padding so I'm using an XML element
64:06 - instead of an XML attribute to set the
64:08 - padding property and that's the reason
64:11 - this syntax is called property element
64:14 - syntax because we said c properties
64:17 - using XML elements not attributes now
64:21 - inside this element I can either add a
64:23 - simple
64:24 - string
64:26 - or I can add another element to
64:28 - represent a complex object in this case
64:31 - I want to use on platform element
64:34 - so I can take this here and move
64:38 - it right
64:40 - here now this on platform element maps
64:43 - to a C class let me show you so back in
64:47 - code behind I'm just going to declare a
64:50 - temporary
64:51 - variable new on
64:54 - platform so this is a generic class and
64:57 - here we need to supply the generic
64:59 - parameter so I'm going to use thickness
65:04 - here now this class has properties like
65:07 - Android
65:10 - iOS and so on now I can get this on
65:13 - platform object and assign it to padding
65:17 - there will be an implicit conversion
65:19 - between on platform object and thickness
65:22 - object okay so we want to achieve the
65:25 - same thing in
65:27 - zaml when creating this on platform
65:29 - object we need to specify the generic
65:32 - argument so we use another attribute
65:35 - here X Type
65:38 - arguments and we set this to
65:41 - thickness again to emphasize because
65:43 - this is prefixed with X it belongs to
65:46 - Microsoft namespace and is part of the
65:48 - standard zaml that was first introduced
65:50 - in year
65:51 - 2009 so this line in zaml is exactly
65:56 - like this line in
65:58 - C okay now we need to set properties of
66:01 - our on platform object so back in examle
66:05 - for iOS I'm going to use 020 0 0 and to
66:08 - refresh your memory these numbers
66:10 - represent left top right and bottom in
66:14 - the last video I referred to these
66:15 - numbers as pixels but the reality is
66:18 - it's not a pixel for now for Simplicity
66:21 - imagine these are
66:23 - pixels so now using this technique I can
66:25 - apply various paddings on different
66:28 - platforms I can apply another padding
66:30 - for
66:33 - Android and similarly for Windows if you
66:35 - ever need to so to recap this video we
66:39 - use property element syntax when we are
66:41 - dealing with complex objects that cannot
66:44 - be represented using simple
66:48 - strings all right in this video I'm
66:50 - going to show you how to catch and
66:52 - prevent zaml errors so as an example I
66:55 - want to remove this s here now let's run
66:59 - this application and see what
67:03 - happens so the application
67:05 - launches and it terminates immediately
67:08 - and currently I have no idea what's
67:10 - going on
67:12 - here in situations like this the first
67:14 - thing you should look at is application
67:16 - output tab in zamine studio I believe in
67:20 - Visual Studio this tab is called
67:23 - output now if you look at this tab you
67:25 - see we have have a zaml parts exception
67:27 - the exception says type on platform not
67:31 - found so basically What's Happening Here
67:33 - is we don't have an on platform type
67:36 - that is not
67:37 - generic so this is one way to find the
67:40 - exception another way is to run the
67:42 - application in debug mode in Visual
67:45 - Studio you press F5 instead of control
67:47 - and F5 in zamarin studio you press
67:50 - command and enter instead of command alt
67:53 - and enter another option is to press
67:56 - this play icon on the
67:58 - toolbar so let's run
68:01 - this okay we got the exception so we got
68:04 - a zaml parse exception and the exception
68:07 - message is type on platform not
68:10 - found now the problem we currently have
68:13 - is that we will not know these
68:14 - exceptions until runtime and as we're
68:17 - typing zaml it's quite possible that we
68:19 - may make a few mistakes here and there
68:22 - so is there a better way to catch these
68:23 - errors yes there is
68:26 - we can include our zaml files as part of
68:29 - compilation so they will be compiled
68:31 - into Intermediate Language or ilil and
68:34 - this has a number of benefits the first
68:36 - one is that we can catch errors at
68:38 - compile time instead of runtime the
68:41 - second benefit is that because zaml
68:43 - files are compiled into IL the size of
68:46 - final assembly will be reduced because
68:48 - these zaml files will not be embedded in
68:51 - the final assembly and finally
68:53 - compilation of zaml files will slightly
68:56 - optimize the load and instantiation time
68:59 - for zaml
69:00 - elements now compilation is disabled by
69:03 - default and we need to enable it but
69:04 - that's pretty
69:06 - easy let's go to the
69:08 - solution under
69:11 - properties you find assembly
69:14 - info and here we have attributes that
69:17 - apply to the assembly as a whole like
69:19 - the title The version copyright
69:21 - information and so on we can include
69:23 - another attribute here
69:26 - brackets assembly colon and this prefix
69:29 - means this attribute is applied to the
69:31 - whole
69:33 - assembly zaml
69:36 - compilation now we get a red underline
69:38 - here because we need to resolve the name
69:40 - space so on top of the
69:42 - file using zamarin forms
69:49 - zaml now the parameter to this attribute
69:51 - is an enumeration called zaml
69:53 - compilation options
69:58 - the default value is Skip so I want to
70:01 - set this to compile and that's all we
70:03 - have to do now if I build the
70:05 - application
70:07 - again look we got an
70:11 - error and here's the exact same error we
70:13 - got at runtime but now we're catching it
70:16 - at compile time so this is a pretty good
70:18 - attribute to always include in your
70:20 - assemblies but just in case you need to
70:22 - disable it on a particular zaml file we
70:25 - can simply go to the code behind for
70:27 - that zaml file for example let's say we
70:30 - want to disable this on Greed page so we
70:34 - go to the code
70:35 - behind import the namespace using
70:38 - zamarin forms
70:41 - zaml and then apply the attribute to the
70:44 - class zaml
70:46 - compilation compilation options
70:49 - skip all right we're done with the
70:51 - basics of zaml now it's your turn so in
70:54 - the next I'm going to give you some
71:00 - exercises all right now it's your turn I
71:03 - want you to use what you have learned in
71:05 - this section and build a simple
71:07 - application like this so this is a quote
71:10 - application we've got this button on the
71:12 - top to navigate through different
71:15 - quotes and these are the quotes by
71:18 - Einstein now when building this
71:20 - application you don't necessarily have
71:22 - to use the quotes I've used here you can
71:24 - use Simple string values like quote 1
71:26 - quote 2 quote 3 the point here is that
71:30 - you have limited number of quotes in
71:32 - your application and as you click next
71:35 - when you get to the end of the list then
71:37 - you start over we also have this slider
71:40 - for changing the size of the
71:47 - text so before you get started look at
71:50 - the PDF I've attached to this lecture
71:52 - all the best and I'll will see you in
71:53 - the next section
71:56 - [Music]
71:59 - okay you seem to be very enthusiastic
72:01 - about learning Zin forms so once again
72:04 - if you're interested to take my 7 and
72:06 - 1/2 hour course with a discount click
72:08 - the link in the video description I hope
72:10 - to see you in the
72:13 - [Music]
72:15 - course

Cleaned transcript:

so what is zamarin forms zamarin forms is a library that enables you to build native apps for iOS Android and Windows using a single C code base if you have any experience with Windows presentation Foundation or silver light zamer informs will be very familiar to you so we have this XML based language called zaml which stands for extensible application markup language and we use this to define the user interface of our applications for example we can Define what elements we have on a page where they are located and what do they look like behind every examl file we have what we call a code behind which is basically a class that implements the behavior for that page for example what should happen when we click a button or select an item from a list so these are the responsibilities of the code behind now in terms of architecture Zam informs is built on top of two existing libraries zamarin Android and xamarin.ios so with zamarin forms we work with a single unified API for creating user interfaces and zamine forms will internally map these user interface elements to their corresponding native equivalent and this makes our applications completely native so we don't have user interface elements that look the same across different platforms if you use a button that button looks different depending on where you run your application also because zamin forms is built on top of z. Android and xamarin.ios you can write platform specific code that uses the API exposed by any of these libraries so you're not limited to a common set of features that are available across all these platforms now the first question that a lot of beginners ask me is Mos do I need to know about z. Android or z. iOS in order to learn zamarin forms not at all the only exception is if you want to write something specific for Android or iOS otherwise for the most part you can learn zamarin forms on its own the second beginner's question is how do I know which zamarin product should I use should I use zamin forms or one of the more specific libraries the answer is it depends what makes zamarin forms powerful is the ability to share most if not all your code across these platforms so you code that application once and then build it for different platforms this building is nothing more than just a compile in Visual Studio that's all you have to do so if you don't need to use much of the platform specific functionality and code reuse is more important to you then go for zamin forms otherwise if you're going to do a lot of customization and have quite a few use cases for working with platform specific API then it's better to use z. Android or z. iOS in terms of tooling you have a few options here if you have a Windows machine you can build and deploy apps to Android and Windows but not iOS for that you need a Mac either a MacBook Pro or an iMac on the other side if you're a Mac User you can build apps for Android and iOS but not for Windows so if you want to Target all platforms you need both a Windows and a Mac machine but this is not a requirement to take this course or to learn Zarin forms in general it's all about where you want to deploy your application you can start with a Windows machine and use Visual Studio to build apps for Android and Windows if in the future you want to build your app for iOS you just add a Mac to your setup and you're pretty much done you don't need to write any new code you just build your project for iOS all right next I'm going to show you how to set up your development environment in this video I'm going to show you how to sell zaring on a Windows and a Mac machine I'm going to start off by setting up on Windows and then I will get to Mac whether you're a Windows or a Mac User be sure to watch this video thoroughly so if you're a Windows user you probably have visual studio so you can install zaring and that will install all the required sdks as well as project templates in visual studio so simply head over to zin.com download fill out this form and be sure to set the answer of this question I already have Visual Studio installed to yes so you don't get Visual Studio you only get zamine installer once you run it you're going to see a dialog box like this be sure to select the following items under crossplatform mobile development so the latest version of c.net zamarin So You see I've currently installed version 4.0.3 but there is a newer version so I'm going to tick that and then under common tools and software development kits select Android native development kit you see I've installed both the 32bit and 64bit versions you also need to install Android SDK and then you need to install at least one of Android SDK setups the difference between these items are their version number so you see the first item is API level 19 and 21 and the last one is API level 23 you can go for the last version or if you have enough space on your machine you can install all of them a patchy ant is not really necessary but I have installed it anyway and finally you need to select Java SE development kit now if you have a typical machine and are not part of a network with a proxy server this installation process goes very smoothly but it may fail if you're behind a proxy server or if you're running Windows in a virtual machine on a Mac this happens mainly because zarine installer cannot download some of the required resources so at this point you need to manually install some of these components I've attached a PDF to this lecture with more details about manual installation so hopefully you won't have any problems during the installation but if you encounter any issues you really need to troubleshoot them yourself because every machine is different in terms of the hardware and software and I really cannot help you with that so just Google the exact error message you get and you will definitely find a solution I just want to emphasize do not get discouraged if you get any errors you only need to spend a bit of time to travel through these issues and then everything is going to be fine also it would be really helpful if you post the errors you get and the solutions you find in the discussion board because I can get all these various errors and compile them into a PDF and that would be very valuable resource for future students of this course now what if you're a Mac User you have two options you can either use zamarin Studio on a Mac which is a lightweight IDE similar to visual studio or you can use Visual Studio but this requires a Windows machine in my setup I'm running Windows as a virtual machine using VMware which option is better zamarin studio is the fastest option you simply head over to zar.com download and get zamarin studio and you're good to go you can build apps for IOS and Android but not for Windows if you want to Target Windows you need a Windows machine so you can either get a physical machine or use a virtual machine like me then you need to follow the same steps to install zamarin on your Windows machine in this video I'm going to show you how to create a zamin forms app in Visual Studio whether you're a Windows or a Mac User watch this video thoroughly so here I'm using visual studio 2015 let's create a new project under visual C templates select crossplatform for zamarin form zaps we have two options here portable class library or shared assets the preferred way and the best practice recommended by zamarin is a portable class Library if you want to understand the differences between these two project types I've attached a PDF for you for further reading but read it after watching this video so let's go ahead with this portable class library and I'm going to call our application hello world okay now this process is going to take a few seconds so I'm going to pause the recording okay next you're going to see this dialogue where we select the Target and minimum version for Universal Windows apps a universal windows app can run under Windows 10 or Windows 10 mobile without the need to be written for each I'm going to accept the default here okay our solution is ready now before looking at the structure of this solution as a best practice whenever you create a new zamin forms app right click the solution and go to manage new get packages for solution then go to the updates Tab and make sure to select all packages and update them because zamarin frequently releases new libraries okay as part of this update process one of the older packages is going to be uninstalled and for that you need to restart visual studio so we yes okay all the packages are updated properly now let's see what we got here so in this solution we have six projects the first one is our portable class library and this is where we're going to do most of the work so all the code that should be shared across different platforms should be written here and if you look inside we only have one class app which is the starting point of our application next we have five platform specific projects one for Android one for iOS one for Universal Windows apps which can run on Windows 10 or Windows 10 mobile and one for Windows 8.1 and the last one for Windows Phone 8.1 so anytime you want to write platform specific code we'll write it in these projects now as I explained before the whole idea about zamarin forms is about code reuse we want to write code that can run across different platforms that's why we do most of our work in the portable class Library all these projects you see here have a reference to this class library now if you don't have a Mac you're not going to see this iOS project Here Also let's say you only want to build an app for Android and don't care about other platforms you can simply delete these projects here and if in the future you decide to support them you can simply right click the solution add a new project let's say you want to Target iOS then under iOS expand it Universal and here is the blank app template so you just add a project to your solution and you're good to go okay now let's run this app you can see that currently hello world. Droid is set as the startup project so if I press contrl and F5 it's going to be loaded in an Android emulator here on the toolbar we can see the list of emulators installed on my machine these emulators come as part of installing zamarin so if everything goes well during the installation you should see quite a few emulators here but in my case because I'm running Windows in a virtual machine on a ma I had to manually install Android emulators if you want to deploy and debugger your application on a real device you need to set it up for development first and then you can see it listed here so you simply select it and then press contrl F5 to deploy and run the app on your device or F5 to debug it and these are the shortcuts that we always used in C Development I've attached a PDF to this lecture with additional details about setting up your Android or iOS device for development now let's run this app contrl F5 now the first time you launch Android emulator you got to wait quite a few minutes even up to 10 or 15 minutes depending on your Hardware so please be patient and here is my Android emulator and you can see our first zarins app is running successfully so this app is just a single page with a label in the middle of the screen now your emulator may look different in terms of its size and the controls you have here but all these are settings that can be changed when creating an emulator manually now let's say we want to run this app in an iOS simulator so we right click the iOS project and set it as start a project then on the toolbar I can ED a deploy to my device because I have an iPhone or use one of these simulators iPhone 4 5 6 iPad and so on now this simulator actually runs on my Mac not on the windows and here on the toolbar bar we have this icon zarine Mac agent if you don't see this toolbar go to the view menu under toolbars select iOS we also have a toolbar for Android but I have disabled it for now so with this zarine Mac agent we can select the Mac on our Network that is responsible for launching the simulator so visual studio talks to a zarine agent on Mac in order to launch a simulator in most cases your Mac should be automatically detected but if not you can simply click add a Mac add the IP address here and you're good to go just remember you need to install zarine both on your windows and on your Mac machine now I can press crl F5 and this will launch my iPhone simulator on my Mac okay and here's the same app running in an iOS simulator next I'm going to show you how to create a zamarin forms app using zamarin Studio all right now I'm going to show you how to create a zamarin forms app in zamarin studio on a Mac if you're a Windows user you can skip this video but I encourage you to watch it just to get familiar with what your development environment on a Mac would look like so here I'm using zamarin studio version 6 and I've changed my theme to dark let me show you how to do it so on the top zarine Studio preferences under visual style set the interface theme to dark all right now let's create a new solution under multiplatform category select app and then forms app next I'm going to call this hello world you can see both Android and iOS are checked but we don't have a check box for Windows because in zamarin studio you cannot Target windows and for that you need visual studio now in terms of the shared code the default setting is on use portable class Library the other option is use shared Library which is not something I would recommend again if you want to know the differences between a portable class library and shared assets look at the PDF I have attached to this lecture next I'm going to accept the defaults here which are about location Version Control and test Cloud so nothing important at this point create okay our project is ready and this is much faster than visual studio now as I told you in the last video as a best practice whenever you create a new zamar forms app make sure to update all the packages so right click the solution and go to update new get packages you can see zamarin studio is updating the packages and this is going to take a little while okay all packages are successfully updated now similar to visual studio you can see that the iOS project is set as the startup project because it's Bal and here on the toolbar we can select a simulator so we've got various versions of iPhone and iPad or we can deploy to a real device now to run this application you press command alt and enter and then iOS simulator launches and loads our application if you want to try the Android app right click this project and set it as startup project now you see all the Android emulators here so throughout this course I'll be using zamarin Studio to do my development because it's much faster and more lightweight if you want to use Visual Studio that's perfectly fine all the code I'm going to write in this course is exactly the same and it doesn't matter which IDE you use it's entirely your personal choice all right next we're going to explore this appli in more detail and add a bit of functionality so you will see both zaml and code behind inaction all right this is what I'm going to build now I want to add a new page to our app with a button in the middle of the screen in iOS buttons don't have a border they look like labels so when we click this button we get an alert so let's go ahead and implement this all right as I explained in the last lecture I'm going to use zamarin studio in this course to doing my development if you want to use Visual Studio that's perfectly fine all the code I'm going to write is exactly the same so as I told you earlier in zarine forms we use zaml which is an XML based language to define the visual appearance of our app and we use code behind to implement how the user interface behaves so I'm going to rightclick our portable class library and add a new file on the left side select forms and on the right side select forms content page zaml and now we give this a name greet page if you're using visual studio again right click the portable class library and a new item in the list of templates select cross PL form and here select forms zaml page and call it greet page so this will add two new files to our project one is GD page. zaml and if you expand it here's the code behind which is just a simple C class and we have the same scenario in zammer in studio so here's our code behind and here's our zaml file as you can see zaml is based on XML the root element here content page represents the type of our page in Zam forms we have a few page types we have content page master detail page navigation page Carousel page and so on we use content page to present some content to the user whether that being text images or the combination of the two now let me break up this line so you can see more clearly in our content page element we have a couple of XML namespace declarations the first one is owned by zamarin and this namespace is for elements that have no prefix like this content page element so this element belongs to zamarin to zamarin forms we have another namespace declaration which identifies a prefix so this colon X syntax is used to declare a prefix and if you look at the URI assigned to this X ml namespace you can see that this namespace is owned by Microsoft which represents the standard zaml that Microsoft introduced in year 2009 now what is this colon X here that means any elements or any attributes that is prefixed with an X belongs to this name space look at this attribute the class attribute it's prefixed with an X and we call it X class so this attribute belongs to the Microsoft namespace now look at the value assigned to this attribute it's hello world. greet page which is the fully qualified name of our code behind class so if we switch to the other tab look the name of our class is greet page and it's placed in hello world namespace so using xclass attribute we establish a link between the zaml file and the code behind file now remove the content of this content page element and instead let's add a button so button I want to put this button in the middle of the screen so we set horizontal options to Center and vertical options to Center next we set the text attribute click me so this way with zaml we're defining the visual appearance of our page now what about the behavior when we click this button I want to display an alert in zammer inform ter buttons have an event called clicked so we set clicked to a string and this identifies the name of the method in the code behind that should be called when this event is raised you can see zaran Studio or Visual Studio is suggesting a name for this method handle underline clicked so we press enter that brings us to the code behind press enter again and that generates our event handler so this event handler as you see it's a private method because it doesn't have an access modifier like public it has two arguments one is an object which is the cender or source of the event and the second one is event arcs which brings additional details about an event if this method looks strange or unfamiliar to you I highly recommend you to watch my C Advanced course because there I have a complete lecture on events and handlers now I want to change the implementation of this method to display an alert we call display alert method we inherit this method from content page class which is the base class for our greed page so the arguments we Supply here is the title of the dialog box the message we want to display like hello world and a label for the cancel button let's just call this okay potentially we could Supply another argument if you want to have two buttons like okay and cancel or yes and no but for this video we don't have to worry about it now in terms of clean coding we should keep the Constructor of our classes on the top so I want to move this method down okay we're done with this new page now we want to make sure that this page is displayed when our app is started so back to our solution view in the portable class Library you see we have a file called app. zaml let's expand this here's our code behind you can see here main page property is set to a new instance of hello world page main page is a property that is defined in the base application class and we use that to set the starting page of our application so I'm going to change this to new greed page now let's run this in zamer in studio I'm going to press command alt and enter in Visual Studio you press control and F5 but before doing so make sure in the solution Explorer set one of these platform specific projects as the startup project I'm going to use iOS you can use whatever you want so let's run the application okay here's our button so now you have an idea of what it's like to build crossplatform apps using zamarin forms so you have seen zamarin forms in action and you know that with zamarin forms you can build native apps for different platforms but you might be curious how zarine actually achieves this so let me give you a bit of background all zarine products like zamarin Android xamarin.ios and zamarin forms are built on top of mono which is an open Source version of net that runs on various non Windows platforms like Linux Unix and and OSX mono is a project that has been around since pretty much as long as net itself but it wasn't very popular until recent years in the mono world we had two releases one was called Mono for Android which was later renamed to z. Android and the other release was monotouch which is now what we call xamarin.ios both these libraries give you access to the net Base Class Library so you have the same name spaces your familiar with you got the same classes with the same interfaces but they also give you access to the native API under platform so you have access to additional assemblies and name spaces that mimic the ones that come natively with Android and iOS these are the classes that Objective C or Java developers work with when they build native apps for Android and iOS when using z. Android or z. iOS we work with classes just like standard C classes in net and these libraries will internally call the corresponding API on the target platform now how that happens it's pretty complex and it's not something we need to worry about that's something that developers at zamarin have to deal with now that you have an understanding of zamarin Android and xamarin.ios let's get a little bit more specific here when you build an application with zarine Android zamarin C compiler compiles down your C code to Intermediate Language or ilil it also EDS the monorun time with your application this monor run time is similar to CLR that you should probably be familiar with so when you launch an Android app this runtime is loaded into the memory and then it gets your IL code and compiles it to the native code for Android and this process is what we call Just in Time compilation or jit this is the same mechanism that is in place when you build a regular net application with C when you build a console desktop or web application the same magic happens now with iOS we have a different story apple does not allow jitting so when you build your iOS application zarine C compiler first compiles your C code down to Il and then it uses Apple compiler to compile it to native code and that's why you need an apple machine so the output is native code that iOS can understand and there's no jitting involved here in other words when you ship your application there is no monor runtime embedded in your application so this is how z. Android and xamarin.ios work but what about zamin fors well zamin forms is built on top of these two libraries so we have this assembly called z. forms. core and here we have classes that Define a common unified API to work with different platforms for example we have a class called bun and this is the bun that we reference in zaml or in code behind now we have another bunch of platform specific assemblies that map these common objects in zamin forms to their corresponding native equivalent let me show you so here in this blank solution let's expand this portable class library now under references under from packages look we've got zamarin forms. core and this is the assembly that defines that common API that we work with so here we've got classes like Buton label list view page and so on now if you look at one of the platform specific projects like the Android one again under references from packages now here we have an assembly called zamarin forms. platform. Android and this is the assembly that is responsible for mapping those common controls we have in zamarin forms. core into their corresponding Android equivalent and in this assembly we have a bunch of what we call renderers so these are the classes that know how to render for example a label or a button now we have the same architecture in other projects projects so let's expand the iOS project references from packages now look we've got zamarin forms. platform. iOS so this is how zamarin forms works all right let me quickly give you an overview of how I have structured this course and where you will find the content you're looking for in the next section you're going to learn the basics of zaml and this gives you a good found to progress through the rest of the course next we're going to look at layouts which we use for arranging visual elements on screen so you will learn how to build user interfaces like these next you're going to learn about images you will learn about downloading images from the Internet or embedding them in your applications you will also learn about icons after that we're going to look at lists so you will learn how to present data in beautiful intera active lists following that we're going to look at navigation you will learn how to navigate users from one page to another how to implement Master detail how to implement tabs how to display popups and so on next you're going to learn how to accept input from the user and this will help you build forms and setting pages but we're not going to talk about saving or loading settings in this section that's the topic for the following section so in data access section you will learn various ways you can store application data you will learn about application properties you will learn about file system you'll learn about storing structured data in a SQL light database and finally you will learn about consuming restful Services now if you don't know what restful is all about don't worry I've got some PDFs for you so you're in good hands next we're going to look at mvvm architecture pattern I will explain what mvvm is when you should use it and why and how to implement it but briefly we use mvvm for decoupling our application from a presentation framework like zamine and we do this for testability so at the end of this section I've got a short video where I show you how to unit test your view models more on this later and finally in the last section we're going to look at some more practices and features that are useful in building larger complex applications and in this section I will show you some of the useful plugins that you can use to access common device functionality like using the camera GPS checking the status of the battery detecting motion accessing contact book and so on so there is a lot to cover over the next 7 hours and I hope by the end of watching this course you will have a very solid foundation to build crossplatform mobile apps using zamin forms well hello it's Marsh here I hope you've been enjoying watching my Z forms tutorial in case you didn't know this tutorial is the first hour of my comprehensive 7 and 1 half hour course on uny in this course you will learn how to build native mobile apps for Android iOS and windows with C if you're interested to have this course you can get it with a big discount using the link in the video description and if not that's perfectly fine continue watching as the next section is coming up so as I explained in the last section zaml is an XML based language that we use to define the visual appearance of our applications we're going to use zaml a lot throughout this course so in this section you're going to learn zaml in more detail and by the end of this section you will have a good foundation that will help you progress through the rest of the course so let's get started okay continuing from the project we created in the last section in our greed page first I'm going to delete this button and then in the code behind I'm also going to remove this event handler now back in the zaml file I want to put a label on the page so label I want to put it in the middle of the screen so horizontal options Center vertical options Center and text hello world now we can create the same UI using Code instead of zaml let me show you how so back in the code behind in the Constructor after the call to initialize component we can set the content property of our page this property is derived from content page which is the base class for our greed page now we can set this to a new label and set its properties here so horizontal options we set this to layout options which is an enumeration do Center similarly for vertical options do Center and finally text now don't worry about this red line under initial component I think there's something wrong with my Zam in studio now that aside we can see that we can create user interfaces using Code as well in this case I'm sending the content property to a new label and this is exactly equivalent to what we put between opening and closing tags of content page element now you might ask msh what do we want to create user interfaces in the code as opposed to zaml well in more than 90% of the cases you would use ZL you would use code only if you want to add elements on a page dynamically for example depending on different circumstances you may want to add a label or a button or a slider or whatnot and all this can happen dynamically but as I said this is the kind of behavior that most applications don't exhibit so all I want you to take away here is that if you want to put elements on a page dynamically you can do it in the code now why is zaml better than the code because it's cleaner and less noisy look at these properties here horizontal options and vertical options we're simply setting them to your string Value Center now look at the equivalent in the code we have to prefix this value with layout options the name of the enumeration so there is a little bit of noise in the code and this can get worse when you're dealing with complex hierarchical structures in those situations zaml is a definite ER because XML is naturally hierarchical now the reality is even when we use zaml at run time we have a zaml parser that reads this zaml file and it will instantiate objects just like the code we have written here so the exact same code will be executed by the zaml parser let me show you when it happens so in the solution I'm going to right click the solution and set display options to show off all files if you look at the object folder under debug we have a file here hello world. greet page. zaml dog which stands for generated. CS so this class is automatically generated for us you can see it's a partial class so part of that is here and the other part is in the code behind you can see here we have a call to initialize component method now you might think this method is inherited from content page but no it's not there it's defined in this generated code look it's here and inside this method we have a call to load from zaml so when we compile our application our zaml files are embedded in our assembly and at runtime when initialized component is called this zaml file is extracted from the assem and pass to the zaml parser then zaml parser will take that zaml and generate a user interface like this all right so for now I'm going to delete this code here and we're just going to stick to zaml for creating user interfaces next I'm going to talk about content property all right now let me show you something I want to put a slider below this label slider but if I run this application now we only see the label not the slider but why is that all right let's have a look at zaring documentation to figure out why so I'm going to search for zamarin Content page class all right look at the Declaration of content page class this class is decorated with an attribute called content property and in this attribute we have a string which specifies one of the properties of content page in this case the name of that property is content and you saw that in the last lecture we set the content property to a new label remember now let's look at the Declaration of the content property look here's the content property it's type is a view view is the base class for all our visual elements like buttons labels sliders and so on so because the type of content is view we can set it to an instance of a single view not multiple views that's why we cannot have multiple children or multiple widgets or multiple views inside content page element so what's the solution let me introduce you to a new element stag layout and then I'm going to move these two widgets inside stack layout with stack layout we can stack multiple widgets horizontally or vertically now I want to make sure both the label and the slider are in the middle of the screen so I'm going to grab these two properties horizontal and vertical options and apply them to slack layout now let me run the application again and here's the result so here's our label and here's the slider now let's inspect stack layout class so we search for zamon stack layout class look this class deres from layout of view now if you look at the Declaration of layout class you can see the content property attribute the game and look the name of the content property for the layout is children so let's look at the children property now if you scroll down you're not going to see that children property you have to navigate up the hierarchy so we go to the layout class and layout class implements I layout controller let's look at this interface now look at the children property it's of type I read only list so this children property because it's a kind of list it can contain multiple widgets and that's the reason we can use a stack layout to stack multiple widgets on the screen all right next we want to take this application to the next level so we want to add this Behavior such that when we move this slider the label is updated to show the current value of the slider all right now we want to take this application a little bit further so we want to add this Behavior such that when we move the slider the label is updated to show the current value of the slider to implement this we need to handle the value change event of the slider and then in our event handler we can get the current value and then set the label so pretty basic in the first section you saw an example of handling the click event of a button in zamin forms so the technique we're going to use here is exactly the same for the slider we handle the value changed event and set this to the name of a method in our code behind so enter enter now I'm going to move this down okay inside our event handler we can use this e argument pass to this method to get the new value of the slider but we need a reference to the label so we can set its text how do we do it well back in our examl I'm going to give this label a name or an ID so we use one of the attributes defined in Microsoft namespace so X colon name this x is a prefix which is declared in the XML namespace declaration for Microsoft namespace so this name attribute belongs to the standard Zam that Microsoft introduced in 2009 and it's applicable in other Frameworks that use ZL like silver light or Windows presentation Foundation or zammer in forms now we set this name to an identifier like label now when I save this file and go back to the code behind I can type label Dot and here we have access to our label so we can set the text property I'm going to use string. format value is provide an argument here and then set it to e do new value now the value we get here is a floating Point number between 0 to one and there are a lot of digits after decimal point so I would like to format this value to a fixed point with two digits after the decimal point so let's run the application okay now if I move this slider look the value is updated and this is a pattern that you see in a lot of real world applications but the value may be displayed as percentage now there is just one tiny problem with this application let me restart it the label is displaying hello world instead of the current value of the slider to fix this in the Constructor after the call to initialize component we can explicitly set the value of the slider so again we need a reference to this slider object so back in our examl file we use x name attribute and give it an identifier slider save now back in the code behind we can type slider. value we can say it to zero or 0.5 whatever let's run the application again okay that's much better now let me give you a bit more insight about this x name attribute so under the object folder debug open up hello world. greet page. zl. g. CS look we have two private Fields here one is a label the other is a slider and in initialized component method after the call to load from zaml these private fields are initialized so we have this method find by name which is inherited from content page The Base Class of our greed page and we give this method an argument which specifies the name or the identifier for our widget with this after initialized component we can access this private field like in this case the slider just remember if you put this line before initialized component you're going to get a null reference exception because that private field is not initialized at that point so in this lecture you learn how to access elements in code behind using xname attribute now even though our application is fully functioning but there is a simpler and cleaner way to implement the exact same functionality and that's called Data binding which I'm going to show you in the next lecture all right now let's see how we can use data binding to implement the same behavior data binding is a concept that you see in a lot of UI Frameworks like WPF and silver light and even in web applications we have Frameworks like angular and knockout and many others that provide this concept of data binding basically what it means is that we bind a property of a user interface element to a property of another object in this case we want to bind the text property of the label to the value property of the slider so when the value of the slider changes the text property of the label is automatically updated with this we don't have to manually handle the value change event of a slider which means we don't need to create this event handler either so our code would be cleaner and more maintainable internally the framework itself will create this event handler based on our binding expression so let's see how we can do this first of all I'm going to remove this event handler and back in zaml I'm also going to remove the value changed attribute of slider now we want to bind the text property of the label to the value property of the slider so we need to use a special Syntax for this so far all the attribute values you have seen have been strings at run time these strings are converted to a primitive type or an object using a type converter in case of data binding we cannot conver convert a string value to a binding expression that's why we need a special syntax and in zaml this is called zaml markup extensions so we use curly braces to instruct zaml parser that this is not a string literal and it's a markup extension there are many different markup extensions available in zaml and in this video you're going to learn two of them the first one is binding so curly braces binding now to set up binding we need to specify what object we want to bind the text property to so we set source to now here we want a reference to the slider object that's when we use another Mark of extension so again curly braces now this Mark of extension is called X reference so X colon reference and we use that to ref refence another object in this zaml file not that is prefixed with X which means this belongs to the standard zaml that Microsoft introduced in year 2009 if you work with other zaml based Frameworks like WPF or silver light you would see this now after X reference space we need to specify the name of the target element in this case slider and this is based on the value of x name add attribute all right so here's the source object now what property of this object are we interested in the value property which represents the current value so after Source comma path equals value we call this path instead of property because that property itself may be an object and we may want to use the dot notation to access another property like a b do c that's why it's it's called path all right that's pretty much all we have to write now if we run this app this is what we get note the label previously we formatted this number with two digits after the decimal point so let's go ahead and do this back here so in our binding expression we have set up Source path and now the third property string format equal and we use single quotes to differentiate from double quotes for the value of the text attribute now here we Supply a standard C string format so value is Curly braces zero represents the first argument colon F2 for formatting now let me break this up into multiple lines okay this is clear cleaner and more maintainable now let's run the application again okay that's exactly like before now let's take this to the next level what if we also want to bind the opacity property of the label to the value of the slider so let's try another binding expression opacity we use curly braces for markup extens extensions the first Mark of extension is binding now here we need to specify the source object equals another markup extension we use x reference to reference the slider then we set the path to the value property of the slider now we don't need a string format because opacity is just a number between 0 to one now let me run this application and here's the result note that the label is a little bit grayed out and if we move the slider to the left it becomes transparent or if you go to the right it becomes opaque but look at our binding expression these bindings are a little bit noisy in both cases we are using the slider as the source object so let me show you how to remove this noise and make this code a little bit cleaner and more maintainable we can set the binding context attribute of the label to our slider so again we use markup extension X reference slider now slider will be the source object for any properties of the label which means in our binding expressions for the text and opacity properties we don't need to repeat this line remove remove also we can take this to the next level and remove path equals value and just add value like this so we can put this on the same line binding to value and same here that's definitely cleaner now let's take this to the next level I want to add a box view a box view is a box filled with a color so a of the label I'm going to add a box view set its color to let's say green and again I want to bind its opacity property to the value of the slider so opacity equals markup extension binding we set the source another binary expression X reference slider and pass equal value let's run this application okay here's the result again you see there is a little bit of duplication in this code both the Box View and the label are referencing the slider as their binding context so we can basically move this binding context setup from the label to our stack layout the container for box View and the label and this will be inherited by all the elements inside stack layout which means we can simplify this binding expression for the opacity of the Box view remove the source and the path so this is how we set up data binding now finally we don't really need this X name for the label because we have not referenced it anywhere so we can delete it all right next I'm going to show you how to deal with Device differences all right now let me show you something don't type anything just watch for the stack layout I'm going to remove vertical options attribute let's run this application in Android and see what happens okay this is what we get note that the Box view is on top of the page just below the blue bar now I'm going to run the same app in iOS okay and this is what we get again note where the Box view is located in Android our page started right below the blue bar but in iOS our page starts right from top of the screen so if you had some text here instead of box view that text would Clash with the current time so this is one of the key differences between Android and iOS in this video I'm going to show you how to add some padding to top of the page but only in iOS so back in zamarin studio in this video I'm going to show you how to do this in code behind and then in the next video I'll teach you how to achieve the same thing in zaml the reason I want to introduce you to code behind is so that you have better understanding of what happens under the hood so we have this class called device and this has a static property called OS which is an enumeration of type Target platform so we can check if Target platform is IOS then we set padding of the page which we inherit from content page class to a new thickness object thickness has a few different Constructors and the one I'm going to use now takes four arguments left top right and bottom it's good to remember this order because you're going to use this a lot so left zero top 20 zero and zero so with iOS we always want to add 20 pixels on top of our page so the content of the page does not clash with the standard bar on top of the screen now even though this code is perfectly fine let's let's just assume we want to have different paddings for Android and Windows so if you want to use the same Technique we would end writing code like this else if device. OS equals Target platform. Android something like this now don't worry about these numbers these are just arbitrary now I want to show you a cleaner way to write the exact same code this device class has a method called on platform and this method has two overloads one that is generic as you see here and the other that takes actions I'm going to start with the generic one because it's easier to understand so we Supply the generic parameter in this case I want different thickness objects for different platforms so the generic parameter is thickness now we can supply different thickness objects for different platforms and to make make the code cleaner we can use name parameters in C so iOS new thickness also you can see that thickness here is great out so we can refactor this code and remove it now compare this code with what we wrote earlier we don't have all this if else if else if the code is cleaner and more focused so internally in this method on platform we actually going to have code like what you see on the top so this method takes care of all these conditional statements and Returns the proper thickness object based on the current operating system so then we can get the result from this method and assign it to padding we can use this on platform method with pretty much any objects in this case we interested in thess in your applications you might be interested on an integer being different across different platforms then you would supply three integer arguments now as I explained earlier this on platform method also has a nongeneric overload let me show you how that one works so device. on platform I'm going to use the nongeneric overload you can see here we have four parameters and they all are optional because they are set to null so let's say I want to execute some code only on iOS then I can supply the name parameter here iOS and here I need to specify an action so I'm going to use a Lambda expression for that like this now if you're not sure what this all means you really need to watch my C Advanced course because I've talked a lot about Lambda expressions and actions there so here in this block we can write the code that we want to be executed on iOS for example we can set padding to thickness object this is another way to set the padding property also for discussion sake let's say we want to have a different piece of code to be executed on Android then we set the name parameter action we use a Lambda expression and here we write the Android specific code so this is how we use device.on platform method whether the generic overload or the nongeneric one now as I explained before we aim to use zaml to define the visual appearance of our applications so in the next lecture I'm going to show you how to use on platform in zaml all right now let's see how we can set padding using zaml so in the last lecture you learned that padding is a property of the page and we can set it to a thickness object like this and obviously this applies to all platforms now if you want to apply this padding using zaml we can easily do so like this so for our content page element we set the padding attribute to a string literal now at run time zaml parser will get this string and give it to a type converter which will parse this into a thickness object and again this will apply to all platforms now what if you want to apply this only to iOS then we need to use an element called on platform on platform and this element has attributes like iOS Android and so on but the problem is we cannot use this element as the value of the padding attribute because these values as you have seen so far are either simple strings or zaml markup extensions but they cannot be an XML element that's when we use a special syntax in examl called property element syntax let me show you how it works so first I'm going to remove this attribute now inside content page element I'm going to add another element content page do padding so I'm using an XML element instead of an XML attribute to set the padding property and that's the reason this syntax is called property element syntax because we said c properties using XML elements not attributes now inside this element I can either add a simple string or I can add another element to represent a complex object in this case I want to use on platform element so I can take this here and move it right here now this on platform element maps to a C class let me show you so back in code behind I'm just going to declare a temporary variable new on platform so this is a generic class and here we need to supply the generic parameter so I'm going to use thickness here now this class has properties like Android iOS and so on now I can get this on platform object and assign it to padding there will be an implicit conversion between on platform object and thickness object okay so we want to achieve the same thing in zaml when creating this on platform object we need to specify the generic argument so we use another attribute here X Type arguments and we set this to thickness again to emphasize because this is prefixed with X it belongs to Microsoft namespace and is part of the standard zaml that was first introduced in year 2009 so this line in zaml is exactly like this line in C okay now we need to set properties of our on platform object so back in examle for iOS I'm going to use 020 0 0 and to refresh your memory these numbers represent left top right and bottom in the last video I referred to these numbers as pixels but the reality is it's not a pixel for now for Simplicity imagine these are pixels so now using this technique I can apply various paddings on different platforms I can apply another padding for Android and similarly for Windows if you ever need to so to recap this video we use property element syntax when we are dealing with complex objects that cannot be represented using simple strings all right in this video I'm going to show you how to catch and prevent zaml errors so as an example I want to remove this s here now let's run this application and see what happens so the application launches and it terminates immediately and currently I have no idea what's going on here in situations like this the first thing you should look at is application output tab in zamine studio I believe in Visual Studio this tab is called output now if you look at this tab you see we have have a zaml parts exception the exception says type on platform not found so basically What's Happening Here is we don't have an on platform type that is not generic so this is one way to find the exception another way is to run the application in debug mode in Visual Studio you press F5 instead of control and F5 in zamarin studio you press command and enter instead of command alt and enter another option is to press this play icon on the toolbar so let's run this okay we got the exception so we got a zaml parse exception and the exception message is type on platform not found now the problem we currently have is that we will not know these exceptions until runtime and as we're typing zaml it's quite possible that we may make a few mistakes here and there so is there a better way to catch these errors yes there is we can include our zaml files as part of compilation so they will be compiled into Intermediate Language or ilil and this has a number of benefits the first one is that we can catch errors at compile time instead of runtime the second benefit is that because zaml files are compiled into IL the size of final assembly will be reduced because these zaml files will not be embedded in the final assembly and finally compilation of zaml files will slightly optimize the load and instantiation time for zaml elements now compilation is disabled by default and we need to enable it but that's pretty easy let's go to the solution under properties you find assembly info and here we have attributes that apply to the assembly as a whole like the title The version copyright information and so on we can include another attribute here brackets assembly colon and this prefix means this attribute is applied to the whole assembly zaml compilation now we get a red underline here because we need to resolve the name space so on top of the file using zamarin forms zaml now the parameter to this attribute is an enumeration called zaml compilation options the default value is Skip so I want to set this to compile and that's all we have to do now if I build the application again look we got an error and here's the exact same error we got at runtime but now we're catching it at compile time so this is a pretty good attribute to always include in your assemblies but just in case you need to disable it on a particular zaml file we can simply go to the code behind for that zaml file for example let's say we want to disable this on Greed page so we go to the code behind import the namespace using zamarin forms zaml and then apply the attribute to the class zaml compilation compilation options skip all right we're done with the basics of zaml now it's your turn so in the next I'm going to give you some exercises all right now it's your turn I want you to use what you have learned in this section and build a simple application like this so this is a quote application we've got this button on the top to navigate through different quotes and these are the quotes by Einstein now when building this application you don't necessarily have to use the quotes I've used here you can use Simple string values like quote 1 quote 2 quote 3 the point here is that you have limited number of quotes in your application and as you click next when you get to the end of the list then you start over we also have this slider for changing the size of the text so before you get started look at the PDF I've attached to this lecture all the best and I'll will see you in the next section okay you seem to be very enthusiastic about learning Zin forms so once again if you're interested to take my 7 and 1/2 hour course with a discount click the link in the video description I hope to see you in the course
