With timestamps:

00:02 - welcome to the ultimate typescript
00:03 - course in this course i'm going to teach
00:05 - you everything you need to know about
00:06 - typescript from the basics to more
00:08 - advanced concepts so by the end of this
00:11 - course you'll be able to use typescript
00:13 - to build large-scale applications if
00:15 - you're looking for a comprehensive easy
00:17 - to follow well organized and practical
00:19 - course that takes you from zero to hero
00:22 - this is the right typescript course for
00:23 - you everything you need to know about
00:25 - typescript is in one place so you don't
00:27 - need to jump back and forth between
00:29 - random tutorials i'm mush hamidani and
00:31 - i've taught millions of people how to
00:33 - advance their software engineering
00:35 - skills through my youtube channel and
00:37 - online school codewoodmosh.com if you're
00:39 - new here be sure to subscribe as we
00:41 - upload new videos all the time now let's
00:44 - jump in and get started
00:46 - [Music]
00:57 - to take this course you need to know
00:59 - typescript now that was a joke you don't
01:01 - need any familiarity with typescript as
01:03 - i'm going to cover everything from
01:05 - scratch but because typescript is built
01:07 - on top of javascript you need basic
01:09 - familiarity with javascript concepts
01:11 - such as variables and constants arrays
01:14 - objects functions arrow functions
01:17 - destructuring and so on if you need to
01:19 - refresh the basics i have a bunch of
01:21 - tutorials and comprehensive courses you
01:23 - can take i've put the links down below
01:25 - in case you are interested
01:29 - [Music]
01:32 - so assuming that you're the right
01:34 - student for this course now let's talk
01:36 - about how you should take this course
01:38 - first and foremost i want you to watch
01:40 - this entire course all the way from the
01:42 - beginning to the end because every
01:44 - lesson teaches you something new if you
01:46 - have taken any of my other courses
01:48 - before you know that i don't waste your
01:49 - time with repetitive or useless stuff so
01:52 - make sure to watch every lesson now
01:55 - while watching each lesson i want you to
01:57 - take notes you can just write down some
01:59 - keywords on a piece of paper if you
02:01 - don't want to write a lot of notes i
02:03 - strongly believe that the act of writing
02:04 - things down will help you remember new
02:07 - things that you learn now when you get
02:08 - to the end of each section make sure to
02:10 - do all the exercises i've carefully
02:12 - designed these exercises to help you
02:14 - better understand and remember the
02:16 - materials remember the more you practice
02:19 - the better you'll be at typescript or
02:21 - coding in general
02:27 - welcome to the first section of the
02:28 - ultimate typescript course
02:30 - we're going to start this section with a
02:32 - quick introduction about typescript
02:33 - we're going to talk about what it is why
02:35 - we use it and when then we're going to
02:37 - set up our development environment and
02:40 - create our first typescript program next
02:43 - we'll talk about configuring the
02:44 - typescript compiler and we'll finish
02:46 - this section by talking about debugging
02:49 - typescript applications so let's jump in
02:51 - and get started
02:54 - [Music]
03:02 - let's start by talking about the top
03:04 - three questions people ask about
03:06 - typescript what is typescript why do we
03:08 - need it and how is it different from
03:11 - plain or vanilla javascript well
03:13 - typescript is a programming language
03:15 - created at microsoft to address some of
03:18 - the shortcomings of javascript you can
03:20 - think of it like the brother or sister
03:22 - of javascript javascript is like a kid
03:25 - without any discipline who does whatever
03:27 - he or she wants typescript on the other
03:29 - hand is like a kid with some discipline
03:32 - now technically speaking typescript is a
03:34 - programming language built on top of
03:36 - javascript so every javascript file is a
03:39 - valid typescript file but typescript
03:42 - adds some really cool features to
03:43 - javascript that help us build more
03:45 - robust and maintainable applications in
03:48 - less time the most important feature
03:50 - typescript offers is static typing what
03:53 - does that mean well we have two types of
03:55 - programming languages statically typed
03:57 - and dynamically typed languages
03:59 - in statically typed languages like c
04:01 - plus plus c sharp and java we know the
04:04 - type of variables at compile time or
04:06 - while coding for example we can declare
04:09 - a variable of type integer and this
04:11 - variable can only hold integer values
04:14 - nothing else so we cannot set it to a
04:16 - string or another type of object
04:18 - in dynamically typed languages like
04:20 - javascript python and ruby the type of
04:23 - variables is dynamic so it's determined
04:26 - at runtime and it can also change so we
04:29 - can declare a variable
04:31 - set it to a number and then later on
04:33 - change it to a string
04:34 - so this variable does not have a fixed
04:37 - or a static type the type is determined
04:39 - and may change at runtime now this is
04:42 - great and gives us a lot of flexibility
04:44 - but it can also lead to problems what if
04:47 - we pass this variable to a function that
04:49 - expects a number then our application
04:52 - might misbehave or crash now the problem
04:54 - is that we will not know about these
04:56 - issues until we run our application or
04:59 - our unit tests well assuming that we
05:01 - have them in place
05:02 - so we have to test every function with
05:04 - various edge cases to cache these bugs
05:07 - and this is the problem that typescript
05:09 - tries to solve
05:11 - typescript is essentially javascript
05:13 - with type checking with typescript we
05:16 - explicitly set the type of our variables
05:18 - upon declaration just like how we code
05:21 - in statically typed languages
05:23 - then we pass our code to the typescript
05:25 - compiler and the compiler will tell us
05:27 - if we are doing something wrong so we
05:29 - can catch a lot of our mistakes at
05:31 - compile time so if we declare a variable
05:34 - as a number we cannot set it to a string
05:36 - the typescript compiler is going to stop
05:38 - us right there and this happens at
05:40 - compile time so we don't have to run our
05:43 - application or our unit tests and test
05:45 - every piece of code to cache these
05:47 - errors we can catch a lot of them simply
05:49 - by compiling our application okay but
05:52 - typescript is more than just type
05:54 - checking most code editors these days
05:56 - have great support for typescript so
05:58 - they can detect the type of our
06:00 - variables and offer productivity
06:02 - boosting features like code completion
06:04 - and refactoring also typescript includes
06:07 - additional features that help us write
06:09 - cleaner and more concise code now over
06:12 - time these features get added to
06:14 - javascript but because we have various
06:16 - browsers and runtime environments for
06:18 - executing javascript code it takes some
06:20 - time until these features are
06:22 - implemented in various browsers so by
06:25 - coding in typescript we can use the
06:27 - features of future javascript
06:29 - so in a nutshell typescript is built on
06:32 - top of javascript and we can use it
06:34 - wherever we use javascript on the front
06:36 - end or the back end so anything we can
06:38 - do with javascript we can also do with
06:40 - typescript now all these great benefits
06:42 - aside let's talk about the drawbacks of
06:45 - typescript first with typescript there
06:47 - is always a compilation step involved
06:49 - because at this time browsers don't
06:52 - understand typescript code
06:53 - so we have to give our code to the
06:55 - typescript compiler to compile and
06:57 - translate into javascript this process
07:00 - is called transpilation
07:02 - second with typescript we have to be a
07:04 - bit more disciplined when writing code
07:06 - so if you're a lazy programmer like our
07:08 - famous old john smith and want to get
07:11 - things done quickly you may feel
07:12 - typescript is getting in the way and
07:14 - that's true but if you're working on a
07:16 - large project with multiple developers
07:18 - you would end up wasting more time
07:20 - coding in vanilla javascript and
07:22 - catching those nasty bugs so then you
07:24 - really want to use typescript for simple
07:26 - applications you can totally get back to
07:28 - old vanilla javascript if that's what
07:30 - you prefer
07:31 - alright that's all about typescript next
07:34 - we're going to set up our development
07:35 - environment
07:38 - [Music]
07:44 - all right the first thing we need is
07:45 - node because we're going to use node
07:47 - package manager or npm to install the
07:49 - typescript compiler i believe as a
07:52 - student of this course you should have
07:53 - node on your machine but if not head
07:55 - over to nodejs.org and download the
07:58 - latest version over here
08:00 - once you do that then open a terminal
08:02 - window and run npm that is short for
08:05 - note package manager which we're going
08:07 - to use for installing third-party
08:08 - packages in this case typescript then we
08:11 - type i that is short for install
08:14 - dash g for installing this globally so
08:16 - we can access the typescript compiler in
08:18 - every folder and then we type the name
08:20 - of the package typescript
08:23 - now if you're on mac or linux and you
08:25 - get a permission error while running
08:26 - this command you have to prefix it with
08:29 - sudo or sudo well more accurately this
08:32 - is sudo because it's short for super
08:34 - user do but that aside let's go ahead
08:36 - and install the typescript compiler
08:41 - okay great now to verify our
08:43 - installation we type tsc that is
08:46 - shortboard typescript compiler dash v to
08:49 - get the version
08:51 - so here i'm running typescript version
08:53 - 4.6.3
08:55 - you might install a newer version but
08:57 - don't worry because everything i'm going
08:58 - to teach you here will apply to newer
09:01 - typescript compilers now in this course
09:03 - just like my other courses i'm going to
09:05 - use visual studio code or vs code as my
09:08 - code editor you're welcome to use any
09:10 - editor you prefer but if you want to
09:12 - follow along and use some of the
09:14 - shortcuts i'm going to teach you i
09:15 - highly encourage you to use vs code in
09:17 - case you don't have it you can get it
09:19 - from
09:20 - code.visualstudio.com alright so go
09:22 - ahead and set up your development
09:23 - environment because in the next lesson
09:25 - we're going to write our first
09:26 - typescript program
09:30 - [Music]
09:35 - all right now i'm going to go to my
09:36 - desktop folder
09:38 - and create a new folder for our project
09:40 - called hello dash world you can call it
09:43 - anything you want and you can put it
09:44 - anywhere on your machine
09:46 - now let's go into this folder
09:49 - and open it with vs code so we type code
09:51 - period
09:52 - now if this doesn't work on your machine
09:55 - you can simply drag and drop this folder
09:57 - onto vs code
09:59 - okay so here's our project now let's add
10:02 - a new file here called index.ts
10:05 - so every typescript file should have the
10:07 - ts extension
10:09 - now earlier i told you that typescript
10:12 - is built on top of javascript so we say
10:15 - typescript is a supersort of javascript
10:17 - which means it has everything in
10:19 - javascript plus some additional features
10:22 - so here we can write any javascript code
10:24 - and that is valid typescript code so we
10:26 - can write console.log
10:29 - and print hello world
10:32 - now we can go back to our terminal
10:33 - window here
10:34 - or we can use the embedded terminal
10:36 - window in vs code so back in vs code
10:40 - under the view menu look we have
10:43 - terminal the shortcut on mac is control
10:46 - and backtick
10:47 - so
10:48 - we can open
10:50 - the terminal window right here
10:51 - and using typescript compiler we can
10:53 - compile index.ts
10:57 - okay
10:57 - now let's open our project folder
11:00 - look we have index.js
11:03 - which is the result of compilation so we
11:06 - have the exact same code here because in
11:08 - index.ts we haven't used any typescript
11:11 - features so let's write a bit of
11:13 - typescript code
11:14 - so
11:15 - here in index.ts i'm going to declare a
11:18 - variable using the let keyword i'm going
11:20 - to call it h
11:22 - and annotate it with number so by typing
11:25 - a colon followed by the type of variable
11:28 - we can annotate or explain a variable
11:31 - now we can initialize it to let's say
11:33 - 20. now here's the beautiful part
11:35 - because we have declared age as a number
11:38 - we cannot set it to a string
11:40 - or another type of object look
11:42 - we get this error right here
11:44 - it's saying type string is not
11:46 - assignable to type number this is the
11:48 - beauty of using typescript with
11:50 - typescript we can catch a lot of our
11:52 - mistakes at compile time we don't have
11:54 - to run our application or our unit tests
11:56 - to find that we accidentally set a
11:58 - number to a string so let's remove this
12:01 - bad line and recompile our file
12:04 - so back to the terminal tsc index.js
12:08 - good
12:09 - now take a look over here
12:12 - look at the javascript code that the
12:14 - typescript compiler generated
12:16 - so instead of the let keyword here we
12:18 - have var because by default the
12:20 - typescript compiler uses an older
12:22 - version of javascript called es5 which
12:25 - is short for ecmascript 5. so ecmoscript
12:28 - is a standard or a specification while
12:31 - javascript is an implementation of that
12:34 - specification
12:35 - so es5 is an old specification it's been
12:38 - around for a long time and all these
12:40 - features have been implemented in our
12:42 - browsers for a very very long time i
12:44 - think more than a decade now in the next
12:46 - lesson i'm going to show you how to
12:48 - configure the typescript compiler to
12:50 - target a newer javascript version so the
12:53 - code that will be generated would be
12:54 - more modern
12:56 - so here's the interesting part instead
12:58 - of let we're using var and we don't have
13:00 - our type annotation this is purely for
13:03 - the typescript compiler
13:04 - the actual javascript code doesn't
13:06 - specify the type of this variable okay
13:09 - so that's it for now starting from the
13:11 - next section we're going to explore
13:13 - typescript features in detail
13:15 - next i'm going to show you how to
13:16 - configure the typescript compiler
13:21 - [Music]
13:26 - all right let's talk about creating a
13:28 - configuration file for the typescript
13:30 - compiler
13:31 - so here in the terminal we run tsc
13:33 - double hyphen in it
13:36 - so this created a configuration file
13:38 - called
13:40 - tsconfig.json with these settings
13:42 - so let's close the terminal window and
13:45 - open ts config right here so in this
13:48 - file we have a number of settings and as
13:50 - you can see most of these are commented
13:52 - out by default we're only going to use a
13:54 - handful of them so don't be intimidated
13:56 - by all these settings you don't have to
13:58 - learn all of them in fact nobody knows
14:00 - all of them i don't know all of them
14:01 - either now in case you're curious in
14:04 - front of each setting you can see a
14:05 - description of what that setting is for
14:08 - so let's talk about a few of them in
14:09 - this lesson the first one is target
14:12 - which specifies the version of
14:14 - javascript that the typescript compiler
14:16 - is going to generate so this is set to
14:19 - es 2016 which is an old standard and
14:22 - it's been implemented in all browsers
14:23 - out there now depending on where you
14:26 - want to deploy your application you can
14:27 - use a higher target and that often
14:30 - results in shorter and less concise code
14:33 - so if we remove this value and press
14:36 - ctrl and space we can see all valid
14:38 - values so we have yes 2015 16 17 18 and
14:43 - so on now in this lesson i'm going to
14:44 - leave this at yes 2016 because this is
14:47 - the safest option for all browser
14:49 - applications out there but again
14:51 - depending on where you want to deploy
14:53 - your application and how much of older
14:55 - browsers you want to support you can use
14:57 - a higher target
14:58 - now the next setting we have here is
15:01 - module which is set to common js we'll
15:03 - talk about this setting later in the
15:05 - course where we talk about modules now
15:07 - in this section in the module section we
15:10 - have a setting called there which
15:12 - specifies the directory that contains
15:14 - our source files so let's remove the
15:16 - comment by pressing command and slash on
15:19 - mac or ctrl n slash on windows
15:22 - so this is set to period slash which
15:25 - represents the current folder now by
15:27 - convention we often put our source code
15:29 - into a separate folder
15:31 - so back to our project panel let's
15:33 - create a new folder here called src
15:36 - and then move index.ts right here okay
15:40 - now i'm going to delete index.js we
15:42 - don't need it for now okay
15:45 - so now we're going to change router to
15:48 - period slash source
15:50 - now we have a similar setting here
15:52 - under the emit section that setting is
15:56 - called outer
15:58 - and this specifies the directory that
16:00 - will contain our javascript files
16:02 - so let's enable this and change it to
16:06 - dist so when we compile our code using
16:08 - the typescript compiler our javascript
16:10 - files are going to be stored in this or
16:13 - distributable folder okay
16:15 - now here we have another useful setting
16:17 - called remove comments so
16:20 - if we enable this the typescript
16:22 - compiler is going to remove all the
16:24 - comments that we add in our typescript
16:25 - code so the generated javascript code is
16:27 - going to be shorter okay
16:29 - now another useful setting in this
16:31 - section is no emit on error so by
16:34 - default when we compile our code even if
16:36 - you have errors in our code the
16:38 - typescript compiler will still generate
16:40 - javascript files this is probably not
16:42 - what we want so the best option is to
16:44 - always enable this setting so if you
16:46 - have any mistakes in our code the
16:48 - typescript compiler is not going to
16:49 - generate any javascript files okay
16:52 - now with this configuration file in
16:54 - place
16:55 - now we can go back to the terminal and
16:57 - compile our code simply by running tsc
16:59 - without any arguments so we don't have
17:01 - to type index.ts
17:03 - we just run tse and this will compile
17:06 - all typescript files in this project
17:08 - take a look all right
17:10 - now we have a new folder called disk
17:12 - that contains our javascript file
17:15 - so this was the basics of ts config as
17:18 - we go through the course we'll explore
17:20 - more of this useful settings
17:25 - [Music]
17:30 - all right now let's see how we can debug
17:32 - our typescript applications in vs code
17:34 - this is very useful when things go wrong
17:36 - and our code doesn't work as expected so
17:39 - we can run our code line by line and see
17:42 - what exactly happens under the hood
17:44 - there are a few steps we need to follow
17:46 - first we go to tsconfig.json
17:49 - and here in the emit section we enable
17:52 - the source map feature so a source map
17:55 - is a file that specifies how each line
17:57 - of our typescript code maps to the
18:00 - generated javascript code let me show
18:02 - you
18:02 - so back to the terminal let's recompile
18:05 - our code
18:06 - good now
18:08 - look into this folder we have a new file
18:10 - called
18:11 - index.js.map this is our source map
18:14 - so if you look over here
18:16 - you see some code that specifies how our
18:19 - typescript code maps to our javascript
18:22 - code now this is not for us to
18:23 - understand this is for debuggers it's
18:25 - for machines okay
18:27 - so let's close this file
18:29 - now
18:30 - to make debugging more interesting let's
18:32 - go to index.ts and write some logic we
18:36 - can say if age
18:37 - is less than 50
18:39 - we're going to add 10 to it okay
18:42 - now we're going to click on the first
18:44 - line to insert a breakpoint so when we
18:46 - start debugging the execution stops
18:49 - right at this line at this breakpoint
18:51 - from this point forward we can execute
18:53 - our code line by line okay
18:56 - now
18:57 - we go to the debug panel
18:59 - and click on create and launch the json
19:02 - file
19:04 - now from this drop down we select
19:06 - node.js and this creates a new file
19:09 - called launch.json in our project i'll
19:11 - show you that in a second
19:13 - so this is a json file with some
19:15 - configuration that tells vs code how to
19:18 - debug this application
19:19 - so we're going to use node to launch
19:22 - this program and here we have a label
19:24 - called launch program which you will see
19:26 - in a second
19:27 - and we can see our program starts here
19:30 - so in the source folder we have index.ts
19:33 - and our output files are stored
19:36 - in our workspace on our project in files
19:38 - with the js extension
19:40 - now here we need to add one more setting
19:43 - it's called pre-launch task
19:46 - we're going to set this to a string with
19:47 - this value
19:48 - tsc
19:49 - colon space build space hyphen space
19:54 - tsconfig.json
19:56 - make sure to type this out exactly as i
19:58 - have shown you here all these spaces
20:00 - matter okay
20:01 - so with this setting we are telling vs
20:03 - code to use the typescript compiler to
20:06 - build our application using this
20:07 - configuration file okay
20:09 - now
20:10 - we go back to index.es and to start
20:13 - debugging we can go to the debug panel
20:16 - and click on launch program this is the
20:19 - label that i just showed you now look at
20:21 - the shortcut it's f5 i always prefer to
20:23 - use shortcuts so let's start debugging
20:27 - good now our program started and the
20:30 - execution stopped right on this line at
20:32 - this breakpoint now on the top we have a
20:34 - bunch of tools for executing our code we
20:37 - have step over for executing one line
20:40 - we have step into we're stepping into a
20:42 - function currently we don't have any
20:43 - functions so it's not useful
20:46 - we also have step out this is useful for
20:48 - stepping out to the function we have
20:51 - restart and stop
20:53 - so in the tooltip that you see
20:55 - in front of each tool you can see the
20:57 - shortcut so the shortcut for stepping
20:59 - over a line is f10 let's press that
21:03 - so this line was executed
21:04 - now on the left side
21:06 - under variables
21:08 - you can see all the variables that are
21:09 - detected in this debugging session so
21:12 - under local we have age that is set to
21:15 - 20. as we execute each line you'll see
21:18 - the value of this variable getting
21:19 - updated
21:20 - now if there's something that you don't
21:22 - see in the variables window you can go
21:24 - to the watch window
21:26 - and insert a watch so we're going to
21:28 - watch the age variable current is 20. so
21:32 - let's step over this line
21:34 - now we're on this line so let's step
21:36 - over this as well
21:38 - now hcode updated but because our
21:40 - program terminated we don't see its
21:42 - value anymore but if you add one extra
21:44 - line here
21:45 - let's say console.log h
21:48 - let's start the debugging session one
21:49 - more time by pressing f5
21:52 - now step over f10 f10 f10 and now h is
21:57 - 30. so this is debugging in via score
21:59 - it's very useful when things go wrong we
22:01 - can start our program and execute it
22:04 - line by line
22:05 - all right now that we're done with
22:06 - debugging we can stop the debugging
22:08 - session right here
22:10 - so that brings us to the end of this
22:12 - section starting from the next section
22:14 - we're going to explore typescript in
22:15 - detail
22:17 - hey guys mosh here i just wanted to let
22:19 - you know that this tutorial you have
22:21 - been watching is actually the first hour
22:23 - of my complete typescript course the
22:26 - complete course is about 5 hours long
22:28 - and goes way beyond this tutorial it
22:30 - also comes with exercises and solutions
22:33 - summary notes and cheat sheets a 30-day
22:35 - money-back guarantee and a certificate
22:37 - of completion you can add to your resume
22:39 - so if you're serious about learning
22:41 - typescript and are looking for a job as
22:43 - a front-end or a back-end developer i
22:45 - highly encourage you to enroll in the
22:46 - course in case you're interested i'll
22:48 - put the link in the description box and
22:50 - if not that's totally fine let's move on
22:52 - to the next lesson
22:57 - welcome back to another section of the
22:59 - ultimate typescript course in this
23:01 - section we're going to explore the
23:02 - fundamentals of typescript so you will
23:04 - learn about the built-in types like the
23:06 - any type arrays tuples enums functions
23:10 - and objects the concepts you'll learn in
23:12 - this section will be the foundation for
23:14 - future sections so don't skip any
23:16 - lessons now let's jump in and get
23:18 - started
23:21 - [Music]
23:29 - so javascript has built-in types like
23:31 - number string boolean null undefined an
23:35 - object now typescript extends this list
23:38 - and introduces new types like any
23:40 - unknown never enum and tuple as we go
23:44 - through this section you will learn
23:46 - about all these steps in detail but
23:48 - before we get started let's see how we
23:49 - can play with primitive types in
23:51 - typescript so back in index.ts i'm going
23:54 - to delete all this code and declare a
23:56 - variable called sales of type number
24:00 - and set it to a value like one two three
24:02 - four five six seven eight nine
24:04 - so once again we're annotating or
24:06 - explaining the type of the sales
24:08 - variable using this syntax okay now in
24:11 - typescript if you have a large number
24:13 - we can separate its digits using an
24:16 - underscore that makes our code more
24:17 - readable okay
24:19 - now let's also declare a variable called
24:21 - course of type string and set it to
24:24 - typescript
24:25 - and one boolean called is published
24:30 - now let me show you something really
24:31 - cool in typescript we don't always have
24:34 - to annotate our variables because the
24:36 - typescript compiler can infer or detect
24:39 - the type of our variables based on their
24:41 - value for example because we have
24:44 - initialized this variable to a number
24:46 - the typescript compiler knows that this
24:48 - variable is a number so we don't have to
24:51 - annotate it so if we remove the
24:52 - annotation
24:53 - and hover our mouse over this variable
24:56 - look we can see that sales is a number
24:58 - similarly because we have initialized
25:00 - course to a string we can remove the
25:03 - annotation and once again
25:05 - we can see that course is a string and
25:08 - one more time
25:09 - now what if we declare a variable like
25:11 - level and don't initialize it
25:14 - typescript assumes that this variable is
25:16 - of type any we'll talk about that in the
25:18 - next lesson
25:22 - [Music]
25:27 - in timescript we have a new type called
25:29 - any which can represent any kind of
25:31 - values
25:32 - so if we declare a variable and don't
25:34 - initialize it the typescript compiler
25:36 - assumes this variable is of type any so
25:39 - we can set it to a number and then later
25:42 - on we can set it to a string
25:44 - but this is against the whole idea of
25:46 - using typescript because we use
25:47 - typescript for type safety so we get
25:50 - type checking so if we use the any type
25:52 - we essentially lose that feature and the
25:54 - major benefit of using typescript so as
25:57 - a best practice you should avoid using
25:59 - the any type as much as possible let's
26:01 - look at another example let's say we
26:03 - have a function called render
26:05 - that takes a document and simply renders
26:08 - it on the console
26:10 - now look we have a compilation error
26:13 - and the error is saying parameter
26:15 - document implicitly has on any type
26:18 - implicitly means we haven't explicitly
26:20 - or clearly set the type of this
26:22 - parameter so the compiler is inferring
26:25 - or guessing the type of this parameter
26:27 - and that's why we have this error now
26:29 - let's say this is part of a javascript
26:31 - project we're trying to convert to
26:33 - typescript and at this point it's
26:35 - impossible for us to explicitly annotate
26:38 - this with a particular type so we have
26:40 - to use the any type here now here we
26:41 - have two options to turn off this error
26:44 - one option is to annotate this with any
26:47 - so we're telling the compiler hey i know
26:49 - what i'm doing the document is of any
26:51 - type but what if we have tons of errors
26:54 - of this kind we don't want to go to
26:56 - every function and explicitly annotate
26:58 - various parameters with any
27:01 - well there is a nuclear option for that
27:02 - but i don't personally recommend that
27:04 - but let me show you how that works
27:06 - so let's remove the annotation
27:08 - now if you're on mac press command and p
27:11 - if you're on windows press ctrl and p to
27:14 - bring up the search box and go to
27:16 - tsconfig.json
27:18 - now look in the type checking section
27:21 - strict is turned on and this is
27:23 - equivalent to turning on some of the
27:25 - basic type checking features you will
27:27 - learn about these settings as we go
27:28 - through the course
27:30 - now the first setting you see here is no
27:33 - implicit any so let's remove the comment
27:36 - so if this feature is turned on the
27:38 - compiler will complain about implicit
27:40 - any types
27:41 - now let's turn this off and see what
27:43 - happens so back in index.ts
27:46 - the error is gone so use this with
27:49 - caution only if you know what you're
27:50 - doing otherwise there's really no point
27:52 - using typescript because you will lose
27:54 - the major benefits of typescript okay
27:56 - so back to ts config i'm going to revert
27:58 - this code
28:00 - good so that's all about the any type
28:02 - next we're going to talk about arrays
28:07 - [Music]
28:12 - all right let's talk about arrays
28:14 - in javascript we can declare an array
28:16 - like this
28:19 - now the thing about javascript arrays is
28:21 - that each element can be of different
28:24 - type so here we can have two numbers
28:27 - followed by a string
28:29 - and this is totally valid javascript
28:31 - code because javascript arrays are
28:33 - dynamic so each element can be of
28:35 - different type
28:36 - but what if we pass this array to a
28:38 - function that expects a list of numbers
28:41 - then the third element is going to cause
28:43 - some issue right this is where we use
28:45 - typescript so we can explicitly apply a
28:48 - type annotation here
28:50 - and say numbers is a number array
28:53 - now we see the error immediately at
28:56 - compile time so let's fix it
28:59 - good
29:00 - now in this particular case we don't
29:01 - even have to apply the type annotation
29:03 - because every element in this list is a
29:05 - number so if you remove the type
29:08 - annotation
29:09 - the compiler
29:11 - can still infer or guess the type of
29:13 - this variable great
29:14 - but what if we had an empty array here
29:18 - look
29:19 - now the type of this variable is any
29:21 - array which is something we should avoid
29:23 - with any arrays again we can have a mix
29:25 - of different types so the first element
29:28 - can be a number
29:29 - the second element can be of a different
29:32 - type like a string or a boolean so if
29:34 - you want to use an empty array you have
29:36 - to explicitly apply a type annotation
29:39 - here let's say number array
29:42 - now the third line is invalid so let's
29:45 - delete it
29:46 - now let me show you another cool benefit
29:48 - of using typescript and that is code
29:49 - completion or intellisense so if we type
29:52 - numbers that for each
29:55 - and pass an arrow function here like n
29:57 - goes to
29:58 - and then type n period
30:01 - over here we can see all the properties
30:03 - and methods of number objects because
30:05 - our editor knows the type of n it offers
30:07 - code completion so we can see all the
30:10 - methods of number objects this is very
30:12 - useful it's a great productivity
30:13 - boosting feature we don't get this with
30:15 - plain javascript right
30:17 - so that's another benefit of using
30:18 - typescript that's all about the arrays
30:21 - next we're going to talk about tuples
30:25 - [Music]
30:30 - typescript has a new type called topple
30:32 - which is a fixed length array where each
30:35 - element has a particular type we often
30:37 - use them when working with a pair of
30:39 - values for example let's say for each
30:41 - user we want to represent two values an
30:43 - id
30:44 - and an a
30:46 - so we declare a variable
30:48 - and annotate it using a special syntax
30:50 - like this first we add square brackets
30:52 - and then tell the compiler that the
30:54 - first element is going to be a number
30:56 - whereas the second element is going to
30:58 - be a string
30:59 - and then we initialize our variable like
31:01 - this
31:02 - so we have a fixed length array with
31:04 - exactly two elements nothing more
31:06 - nothing less so if we add a third
31:08 - element here we get a compilation error
31:11 - saying type number string number is not
31:14 - assignable to type number string okay so
31:18 - exactly two elements and these elements
31:20 - should have these types the first one
31:22 - has to be a number so if we pass a
31:25 - string again we get a compilation error
31:28 - now just like before here we get
31:30 - intellisense or code completion
31:33 - so if we access the first element
31:35 - we see all the methods of number objects
31:38 - and if you access the second element we
31:40 - see all the properties and methods of
31:42 - string objects again one of the reasons
31:44 - i love typescript
31:46 - now one thing you need to know about
31:47 - tuples is that internally they're
31:50 - represented using plain javascript
31:52 - arrays so if we compile our code we're
31:54 - just going to see a regular javascript
31:56 - array let me show you so in the terminal
31:59 - let's run tsc
32:01 - good
32:02 - now back in our project here in this
32:05 - folder let's open index.js look we just
32:08 - have a regular javascript array so that
32:11 - means back in our typescript code
32:13 - if we type user period
32:16 - over here we can see all the methods of
32:18 - array objects
32:19 - now one of this method is a little bit
32:21 - troublesome and that is the push method
32:23 - so we can call this method and store a
32:26 - third value in this array and the
32:28 - compiler is not going to complain here i
32:30 - believe this is one of the gaps in
32:32 - typescript at the time of recording this
32:33 - hopefully this will be solved in the
32:35 - future
32:36 - so a tuple is a fixed length array where
32:38 - each element has a particular type now
32:40 - as a best practice i would say restrict
32:43 - your tuples to only two values because
32:45 - anything more than that is going to make
32:47 - your code a bit hard to understand for
32:49 - example if you add
32:51 - a boolean
32:53 - and another number here
32:56 - what do these values really represent
32:58 - it's really hard to tell
32:59 - so tuples are useful when we have only
33:01 - two values like key value pairs
33:04 - next we're going to talk about enums
33:08 - [Music]
33:13 - typescript has another built-in type
33:15 - called enum which represents a list of
33:18 - related constants if you know c sharp or
33:20 - java you have seen enums before we have
33:22 - the exact same concept here in
33:24 - typescript
33:25 - so let's say we want to represent the
33:27 - size of t-shirts as constants one way is
33:30 - to define three constants like this
33:32 - small
33:34 - medium
33:35 - and large
33:37 - that's one way and then throughout our
33:38 - code we can reference this constant
33:41 - another way is to group this constant
33:44 - inside an enum so we use the enum
33:46 - keyword
33:47 - then give our enum a name
33:50 - now note that here i'm using pascal
33:52 - naming convention so the first letter of
33:55 - every word should be uppercase okay
33:58 - then we add curly braces and inside the
34:01 - braces we add our members small
34:03 - medium and large once again i'm using
34:07 - the pascal naming convention for the
34:09 - members
34:10 - now when we define an enum we don't need
34:12 - to define these three constants anymore
34:15 - and by default
34:17 - the typescript compiler assigned the
34:19 - first member the value of 0
34:22 - and other members values like 1 2 and so
34:25 - on now if you don't want to use these
34:26 - values we can explicitly set values so
34:29 - we can set small to 1 and then medium
34:31 - becomes 2 and large becomes three we can
34:34 - also use string values
34:36 - like
34:37 - s
34:38 - if we do this then we have to explicitly
34:41 - set a value for each member so
34:44 - medium and
34:46 - large like this now i'm going to revert
34:48 - this code and just rely
34:50 - on numbers so i'm going to initialize
34:52 - small to 1 and rely on the compiler to
34:56 - set the value for other members
34:58 - so now that we have this new type we can
35:00 - declare a variable like my size of type
35:03 - size
35:04 - and set it to size dot
35:06 - medium okay
35:08 - so this is how we can use enops now
35:10 - let's see what happens
35:12 - if we log
35:13 - my size on the console so back to the
35:16 - terminal let's run the typescript
35:18 - compiler
35:19 - good and then use node to execute our
35:22 - javascript code so we go to the disk
35:24 - folder and pick index.js
35:27 - so look we see the numeric value
35:29 - associated with our enum member okay
35:32 - now let's look at the generated
35:34 - javascript code in this file
35:36 - so back to the project here's our index
35:39 - file take a look
35:41 - so the generated javascript code is
35:43 - pretty verbose it's pretty lengthy now
35:45 - you don't need to worry about
35:46 - understanding this but let me show you a
35:47 - trick
35:48 - back to our typescript file
35:51 - if we define this enum as constant the
35:54 - compiler will generate a more optimized
35:56 - code so let's recompile our code
36:00 - and then look at
36:02 - index.js
36:03 - one more time
36:06 - now we don't see all that code anymore
36:07 - we only have one line for setting my
36:09 - size to 2. again you don't have to worry
36:12 - about the generated javascript code all
36:14 - i want you to take away here is that
36:16 - using an enum we can represent a list of
36:19 - related constants and if we define our
36:21 - in-apps using the constant keyword the
36:24 - compiler will generate more optimized
36:26 - code
36:27 - next we're going to talk about functions
36:31 - [Music]
36:37 - let's talk about how typescript helps us
36:39 - prevent common problems when working
36:41 - with functions
36:42 - so let's define a function
36:44 - called calculate tags
36:46 - and give it an income parameter of type
36:48 - number
36:50 - now let's hover our mouse over the
36:52 - function name look at the type of the
36:54 - return value it's void meaning this
36:57 - function does not return a value
36:59 - if you return a value here like a number
37:01 - now
37:03 - the type of the return value is number
37:05 - so the typescript compiler has inferred
37:08 - the type of the return value for us and
37:09 - that's great but as a best practice we
37:12 - should always properly annotate our
37:14 - functions so all the parameters as well
37:17 - as the return type should be properly
37:19 - annotated especially if you're building
37:21 - an api for other people to use
37:23 - so in this case to annotate the return
37:25 - type
37:26 - we go after the list of parameters
37:28 - add a colon and specify the return type
37:31 - like number or void if we are not going
37:34 - to return a value
37:35 - so let's add number
37:36 - now this has an extra benefit
37:39 - if you forget to return a value or if
37:41 - you return a different kind of value
37:43 - like your string we get a compilation
37:45 - error immediately so as best practice
37:47 - always properly annotate your functions
37:50 - now let's temporarily return zero
37:53 - okay
37:54 - look at the income parameter this is an
37:56 - unused parameter now we have a compiler
37:58 - option for detecting these unused
38:00 - parameters
38:01 - so let's go back to our ts config file
38:05 - in the type checking section
38:07 - we have a compiler option called no
38:10 - unused parameters we have to explicitly
38:13 - turn this on because this setting is not
38:15 - part of strict setting now back to
38:18 - index.ts
38:20 - look
38:20 - we have a warning saying
38:23 - income is declared but its value is
38:25 - never read so let's change this code and
38:27 - say if
38:29 - income is less than 50 000
38:32 - then we're going to return income times
38:35 - 1.2
38:36 - now here we have another compilation
38:38 - error
38:39 - saying function lags ending return
38:41 - statement and return type does not
38:43 - include undefined it sounds a bit
38:45 - cryptic but what this error is saying is
38:47 - that if this condition is true we're
38:50 - going to return a number otherwise as
38:52 - you know javascript by default always
38:55 - returns undefined from our functions and
38:58 - undefined is not a number
39:01 - now let me temporarily
39:03 - remove the annotation for the return
39:04 - type
39:07 - look we have no compilation error but
39:09 - this function has a problem
39:11 - if the income is greater than 50 000
39:14 - we're gonna get undefined from this
39:15 - function and this may cause a bug in our
39:17 - application the good news is that we
39:19 - have another compiler option for
39:21 - detecting these kind of issues where we
39:23 - forget to return a value
39:25 - so back to our ts config file again in
39:28 - the type checking section
39:30 - we have a setting called no implicit
39:33 - returns
39:34 - again we have to explicitly turn this on
39:36 - because this is not part of the strict
39:38 - setting okay
39:39 - now
39:41 - to factor code
39:43 - we have a warning saying not all code
39:45 - paths return a value so now we can fix
39:48 - this problem
39:49 - and say otherwise if income is greater
39:51 - than 50 000 we're going to return income
39:54 - times 1.3 but again it's best to always
39:58 - annotate our functions properly to
40:00 - prevent all these issues so we should
40:02 - always return a number from this
40:05 - function
40:06 - now we have another useful compiler
40:07 - setting for detecting unused variables
40:11 - so if we declare a variable like x and
40:13 - don't use it in this function this is
40:15 - unused now using the typescript compiler
40:17 - we can find these issues in our code
40:19 - so
40:20 - back to ts config
40:22 - here is the setting no
40:24 - unused locals with this feature enabled
40:27 - now
40:28 - back to our code we have a yellow
40:30 - warning saying
40:32 - x is declared but its value is never
40:34 - read so
40:35 - now we can delete this and make our code
40:37 - cleaner
40:38 - so this is the basics of functions now
40:40 - let's add a second parameter here called
40:43 - tax here of type
40:45 - number
40:46 - now we have a warning here saying
40:48 - texture is declared but its value is
40:50 - never read so let's change
40:53 - our condition to
40:54 - if tax year
40:56 - is less than 2022 then return income
40:59 - times 1.2
41:01 - so now with these two parameters if you
41:03 - want to call this function
41:05 - we have to supply exactly two arguments
41:08 - nothing more nothing less
41:10 - so i'm going to pass 10 000 for the
41:11 - income and 2022 for the tax year if you
41:14 - add an extra argument here
41:16 - we get a compilation error saying
41:19 - expected two arguments but got three if
41:21 - you have been coding in javascript for a
41:23 - while you know that this is valid
41:25 - javascript code so javascript doesn't
41:27 - really care how many arguments we pass
41:29 - to a function we can pass more or fewer
41:32 - arguments than the number of parameters
41:34 - but typescript is very strict about this
41:37 - so here we should pass exactly two
41:38 - arguments so let's remove that
41:41 - but what if you want to make this
41:42 - optional let's say in some places we
41:44 - want to call this function without
41:47 - supplying the tax year well we can make
41:50 - this parameter optional by adding a
41:53 - question mark right here
41:55 - now we have a compilation error on this
41:57 - line saying
41:58 - object is possibly undefined
42:00 - so if we don't supply the tax year by
42:04 - default undefined will be used and we
42:06 - cannot compare undefined with 2022.
42:09 - so here we have two options one option
42:11 - is to use the old javascript trick so we
42:15 - wrap this in parenthesis
42:17 - and then using the or operator we give
42:19 - it a default value like 2022
42:22 - so if we don't supply the tax year
42:25 - this value will be used otherwise the
42:27 - argument that we pass will be used here
42:29 - okay now i don't like this approach
42:31 - there is a better way we can give this a
42:33 - default value so instead of making it
42:35 - optional
42:37 - we give it a default value
42:39 - like this
42:41 - now we can call this function with or
42:43 - without a tax year if we don't supply an
42:45 - argument for the tax year this value
42:47 - will be used otherwise what we pass here
42:50 - will overwrite
42:52 - the default value okay
42:54 - now
42:55 - with this default value we no longer
42:57 - need to use
42:58 - this ugly expression we can simply
43:00 - compare
43:01 - tax year with 2022
43:03 - so let's quickly recap what you learned
43:05 - in this lesson as a best practice always
43:08 - properly annotate your functions all the
43:10 - parameters and return types and enable
43:13 - these three compiler options
43:15 - no unused locals no unused parameters
43:18 - and no implicit returns
43:22 - [Music]
43:28 - all right the last thing we're going to
43:29 - cover in this section is objects so
43:31 - let's declare an employee object
43:33 - with an id property
43:35 - now you know that in javascript objects
43:38 - are dynamic so their shape can change
43:40 - throughout the lifetime of our programs
43:42 - so once we have an employee object then
43:44 - later we can give it a new property like
43:46 - name and this is totally valid in
43:48 - javascript but as you can see this is
43:51 - not valid in typescript the compiler is
43:53 - saying property name does not exist on
43:56 - this type so this type is an object with
43:58 - an id property which is a number
44:01 - so just like all the variables we have
44:02 - declared so far the typescript compiler
44:05 - has inferred the shape of this employee
44:07 - object
44:08 - so if you hover our mouse over employee
44:11 - we can see its shape it's an object with
44:13 - an id that is a number
44:16 - now just like all the variables we have
44:17 - declared so far we can explicitly apply
44:20 - a type annotation here
44:22 - so after employee
44:24 - we add a colon followed by braces and
44:28 - inside the braces we define the
44:30 - properties of an employee object so
44:32 - every employee should have an id that is
44:34 - a number
44:35 - and a name that is a string
44:37 - now the previous error on this line is
44:39 - gone
44:40 - but we have a new kind of error let's
44:42 - find out
44:43 - the compiler is saying property name is
44:45 - missing so the reason we're seeing this
44:46 - is because every employee should have
44:49 - these two properties but while
44:51 - initializing this object we haven't
44:53 - supplied the name property now here we
44:55 - have two options one option
44:58 - is to set the name to an empty string we
45:01 - cannot set it to null or undefined we'll
45:03 - talk about this in the next section so
45:06 - we should either set it to an empty
45:07 - string
45:08 - or we can make this property
45:11 - optional and then we don't have to
45:13 - supply the name property while
45:15 - initializing an employee now even though
45:19 - typescript allows us to do something
45:20 - like this this is something we should
45:22 - avoid because conceptually it doesn't
45:24 - make sense to have an employee without a
45:27 - name every employee should have a name
45:29 - it would make sense to make the fax
45:31 - property optional because not everyone
45:33 - has a fax machine right so always make
45:36 - sure the code you write conceptually
45:38 - makes sense don't blindly use features
45:40 - of typescript or any other programming
45:42 - languages okay so in this case we're not
45:44 - going to use an optional property and
45:47 - that means we should either set the name
45:49 - to an empty string or initialize it
45:52 - right here okay now we have an error
45:54 - because i used a period okay
45:57 - so now we don't need this last line
45:59 - anymore
46:00 - okay
46:01 - now sometimes we want to make certain
46:03 - properties read only so we don't
46:05 - accidentally change them later on so
46:07 - with our current implementation we can
46:09 - change the idea of an employee anytime
46:12 - and this is not valid this is where we
46:14 - use the read-only modifier so we applied
46:17 - before the name of the property and now
46:20 - the typescript compiler prevents us from
46:22 - accidentally modifying the value of this
46:24 - property okay
46:26 - good now how can we define a function or
46:29 - more accurately a method in this object
46:31 - let's say every employee object should
46:33 - have a retirement method so
46:35 - in our type annotation we need to define
46:38 - the signature of this method we need to
46:40 - specify how many parameters it's going
46:42 - to have what is the type of each
46:43 - parameter and what is the type of the
46:45 - return value
46:46 - so we're going to have a retire method
46:48 - with one parameter that is date now here
46:51 - we use the arrow function syntax so
46:53 - first we add parenthesis and inside
46:55 - parenthesis we specify the parameters so
46:58 - we're going to have a date parameter of
47:00 - type date
47:01 - this is just a built-in data object in
47:03 - javascript and typescript so we only
47:06 - have one parameter then we use a fat
47:08 - arrow and here we specify the type of
47:11 - the return value we don't want to return
47:12 - any value so we're going to use weight
47:15 - now we have a compilation error
47:18 - saying property retire is missing
47:20 - because when initializing this object we
47:23 - haven't supplied
47:24 - the retired method so let's do that real
47:26 - quick
47:30 - all right retirement is going to be a
47:32 - method with one parameter
47:35 - and
47:36 - over here i just want to lock the date
47:39 - on the console pretty simple
47:42 - so this is how we can work with objects
47:44 - now i know this syntax this type
47:46 - annotation is a little bit messy it's
47:48 - making our code a bit verbose or noisy
47:50 - so in the next section i'll show you a
47:52 - better way to work with objects
47:58 - welcome back to another section of the
48:00 - ultimate typescript course in this
48:02 - section we're going to explore more
48:04 - advanced types in typescript
48:06 - so you will learn how to use type
48:08 - aliases to reuse types and simplify your
48:10 - code how to use unions and intersections
48:13 - to combine types how to narrow types how
48:16 - to work with nullables as well as the
48:18 - unknown and never types so let's jump in
48:21 - and get started
48:22 - [Music]
48:32 - alright so this is the employee object
48:33 - that we created at the end of the
48:34 - previous section now there are three
48:37 - problems in this implementation the
48:39 - first problem is that if you want to
48:40 - create another employee object we have
48:42 - to repeat this structure we have to
48:44 - repeat this shape so we'll end up
48:46 - duplicating our code which is bad we
48:48 - always want to confirm to the dry
48:50 - principle don't repeat yourself
48:53 - now the second problem is that the other
48:55 - employee object might have other
48:57 - properties so these two employee objects
49:00 - might not have a consistent shape
49:02 - because we don't have a single place to
49:04 - define the shape of an employee object
49:06 - now the third problem is that overall
49:09 - this structure is making our code a
49:11 - little bit hard to read and understand
49:13 - this is where we use a type alias using
49:15 - a type alias we can define a custom type
49:17 - let me show you
49:18 - so on the top we start with the type
49:21 - keyword then give our new type and name
49:23 - and once again here we use the pascal
49:25 - case so employee
49:27 - with a capital e
49:29 - then we set it to braces and inside the
49:31 - braces we define all the properties and
49:34 - methods an employee object should have
49:36 - so i'm going to go in this annotation
49:39 - select these three lines and by pressing
49:41 - alt and up we can move these lines up
49:44 - okay
49:46 - now when defining this employee object
49:48 - we annotate it with our new type
49:51 - employee okay so now we have a single
49:54 - place where we define the shape of an
49:56 - employee object and we can reuse this in
49:59 - multiple places this is the benefit of
50:01 - using a type abs
50:05 - [Music]
50:10 - all right let's talk about union types
50:12 - with union types we can give a variable
50:14 - or a function parameter more than one
50:17 - type so let's define a function for
50:19 - converting weight from kilogram to
50:21 - pounds
50:22 - now we give it a parameter called weight
50:24 - now let's assume that this parameter can
50:26 - be either a number or a string so we
50:29 - annotate it with number or string
50:33 - so using a vertical bar we can create a
50:36 - union type
50:37 - now
50:38 - we can call this function in two ways we
50:40 - can give it a number
50:42 - or
50:43 - a string like 10 kilograms okay
50:46 - now let's finish up this example so
50:48 - we're going to annotate the return type
50:50 - and return a number
50:52 - now in this function at this point we
50:55 - don't know if the weight is a number or
50:57 - a string so if we type weight period we
51:00 - only see the properties and methods that
51:03 - are common between numbers and strings
51:06 - so both numbers and strings have these
51:08 - three methods to locale string to string
51:11 - and value of so here we are not seeing
51:13 - methods that are specific to numbers or
51:16 - strings and this is where we use a
51:18 - technique called narrowing so we're
51:20 - going to narrow down this union type
51:22 - into a more specific type so here we can
51:25 - say if type of weight
51:28 - equals
51:29 - number
51:31 - now in this block the compiler knows
51:34 - that the weight is a number so if we
51:36 - type weight period we see all the
51:39 - methods that are available in number
51:41 - objects
51:42 - and by the way we don't necessarily need
51:44 - the code blocks here in this line if you
51:46 - have a one-liner and type weight period
51:49 - we still see all the methods available
51:52 - in numbers okay
51:53 - so what are we going to do here we're
51:55 - going to return weight times 2.2
52:00 - otherwise
52:01 - if you end up here that means weight as
52:04 - a string so now we see all the
52:06 - properties and methods of string objects
52:08 - okay
52:09 - so to finish this example
52:11 - here we're going to return
52:13 - first we need to convert the weight to
52:14 - an integer so we call
52:16 - parsend pass the weight
52:19 - and then multiply it by 2.2
52:22 - okay
52:23 - now back to the terminal let's compile
52:25 - our code and see what we get
52:27 - all right we're going to go to index.js
52:31 - take a look our union type is not part
52:34 - of the generated javascript code it's
52:36 - purely for the compiler to do is type
52:38 - checking
52:41 - [Music]
52:46 - so in the previous lesson you learned
52:48 - that using a union type we can say a
52:50 - variable or a function parameter can be
52:53 - one of many types right now we have
52:55 - another technique for combining types
52:57 - called intersection
52:59 - so instead of a vertical bar
53:01 - use an ampersand
53:02 - and now this type represents an object
53:06 - that is both a number and a string at
53:08 - the same time now technically this is
53:10 - impossible we cannot have an object that
53:13 - is both a number and a string at the
53:15 - same time so let's look at a more
53:16 - realistic example
53:18 - i'm going to use our type alias to
53:20 - define a new custom type called
53:22 - draggable so this represents an object
53:26 - that can be dragged on the screen now
53:28 - what properties or methods do we need in
53:30 - a draggable object
53:31 - well at least we need a method called
53:34 - drag which takes no arguments and
53:37 - returns void
53:39 - now similarly we're going to define
53:41 - another type called resizable
53:44 - and here we need a resize method that
53:46 - should take two parameters like the new
53:49 - width and the new height but for
53:50 - simplicity let's get rid of all that
53:52 - noise and just add no parameters and say
53:55 - this method returns void okay
53:58 - so now we have two separate types and
54:01 - using an intersection type we can
54:02 - combine them into a new type so we can
54:05 - define a new type called ui widget which
54:08 - is draggable and resizable so this is an
54:12 - intersection type
54:14 - now with this type in place we can
54:15 - declare a variable
54:18 - called textbox
54:20 - which is a ui widget
54:21 - now to initialize this object we need to
54:24 - implement all members of draggable and
54:27 - resizable objects so we need to
54:29 - implement the drag and resize methods
54:32 - so
54:34 - drag as a simple method
54:36 - and so is the resize method
54:39 - so this is type intersection in action
54:44 - [Music]
54:50 - sometimes we want to limit the values we
54:52 - can assign to a variable this is where
54:54 - we use literal types so let's declare a
54:56 - variable called quantity and assume that
54:59 - the quantity can either be 50 or 100 but
55:02 - nothing else now here's the problem if
55:05 - we annotate this with number
55:08 - this can take any numbers any valid
55:10 - numbers in javascript right so to limit
55:12 - the values we can use here we use a
55:14 - literal type so instead of annotating
55:17 - this with the type like number
55:19 - will annotate it with a literal meaning
55:22 - an exact or specific value
55:25 - so
55:26 - i'm going to replace number with 50.
55:29 - now quantity can only be set to 50
55:31 - nothing else so if you set it to 51 you
55:33 - get a compilation error now you might
55:35 - think this is not useful well that's
55:37 - true but what if we apply the union
55:39 - operator here so we can say the quantity
55:42 - can be 50 or 100. now we can set it to
55:46 - 50 or 100 right but we're not done yet
55:50 - we can make this code even better so
55:52 - instead of hard coding these literal
55:54 - values here we can create a custom type
55:57 - using a type alias so we define a new
55:59 - type called quantity
56:01 - which can be 50 or 100 and then we
56:05 - annotate our variable with our new type
56:08 - so what we have over here is called a
56:10 - literal type
56:12 - now literals don't have to be numbers
56:13 - they can also be strings for example we
56:16 - can define a new type called metric
56:18 - which can be centimeter or
56:21 - inch
56:22 - okay
56:23 - so that's all about literal types next
56:25 - we're going to talk about nullable types
56:30 - [Music]
56:35 - all right let's talk about working with
56:37 - null values so by default typescript is
56:40 - very strict about using null and
56:42 - undefined values because as you probably
56:44 - know these values are common source of
56:46 - bugs in their applications
56:48 - so let's look at a real example let's
56:50 - define a function
56:51 - called greet that takes a name which is
56:54 - a string
56:55 - now in this function we just want to do
56:56 - a console.log and print name the to
57:00 - uppercase
57:01 - now in vanilla javascript we can call
57:04 - this function and accidentally give it
57:06 - null or undefined that is totally valid
57:09 - javascript code but when we run our
57:11 - program our program is going to crash
57:13 - because we cannot call this method on a
57:16 - null or an undefined object so this is
57:19 - why null and undefined values are a
57:21 - common source of problems and that's why
57:24 - by default the typescript compiler stops
57:26 - us from using null or undefined values
57:29 - so here we have an error saying argument
57:31 - of type null is not assignable to
57:34 - parameter of type string
57:36 - let me show you where this comes from
57:38 - so let's go to our ts config file
57:41 - in the type checking section
57:43 - we have a compiler option called strict
57:46 - null checks that this is enabled by
57:48 - default as part of the strict option
57:51 - so if strict is set to true strict null
57:54 - checks is also true but we can overwrite
57:56 - it and turn off this feature
58:00 - now
58:00 - back to index.ts the error is gone so
58:03 - this is why by default typescript is
58:06 - very strict about using null values
58:08 - so technically we should never use this
58:10 - option we should never turn it off so
58:12 - i'm going to rewrite this back
58:14 - but what can we do in this function what
58:16 - if we want to have the ability to use a
58:18 - null value perhaps if we don't have a
58:21 - name you want to print just a generic
58:23 - message like hola meaning high in
58:25 - spanish
58:26 - so here we can say if name is truthy
58:29 - meaning it has a value then we're going
58:31 - to print name.to uppercase otherwise
58:35 - if it's null or undefined we're gonna
58:37 - print hola okay
58:40 - but we cannot pass a null value here
58:42 - this is where we use a union type once
58:44 - again
58:45 - so we annotate this parameter with
58:48 - string or
58:49 - no
58:50 - now we can pass a null value but we
58:52 - cannot pass undefined
58:54 - because this is not a valid value for
58:56 - this parameter so if you want to have
58:58 - the ability to pass undefined as well
59:01 - again we're going to use the union
59:03 - operator
59:07 - [Music]
59:12 - now when working with nullable objects
59:14 - we often have to do null checks for
59:16 - example let's define a type alias called
59:18 - customer
59:20 - and give it a birthday property of type
59:22 - date
59:24 - now let's define a function for getting
59:26 - a customer from a database so
59:28 - we give it an id which is a number and
59:31 - we get either a customer or
59:34 - null in case there is no customer with
59:36 - the given id
59:37 - now in this function let's write some
59:39 - basic logic like return if id equals
59:42 - zero
59:43 - then we return null otherwise we return
59:46 - a customer object
59:48 - with this birthday
59:49 - pretty simple
59:51 - now let's declare a variable
59:53 - and here we call getcustomer and pass
59:56 - zero
59:57 - now let's imagine we want to print the
59:59 - customer's birthday so console.log and
60:02 - here we pass customer dot birthday
60:05 - now here we have a compilation error
60:07 - because customer might possibly be no
60:10 - so as you know one way to solve this
60:12 - problem is like this
60:13 - we check if customer is not known then
60:17 - we execute this piece of code
60:20 - now let's take this to the next level
60:21 - and assume that under certain
60:23 - circumstances this function might return
60:26 - undefined so we add undefined here
60:30 - and now we have to expand this if
60:32 - statement and check for undefined
60:36 - so if customer is not null and it's not
60:39 - undefined either
60:41 - then we print the customer's birthday
60:44 - that works but there is a simpler way to
60:46 - write this code in typescript we can
60:48 - remove
60:49 - this if statement
60:51 - and use what we call the optional
60:53 - property access
60:55 - operator
60:56 - so because customer might be null or
60:58 - undefined right after it we add a
61:00 - question mark and then we add the
61:03 - chaining or the dot operator so this
61:06 - question mark followed by the chaining
61:07 - operator is called the optional property
61:10 - access operator so now this piece of
61:12 - code gets executed only if we have a
61:15 - customer that is not null or undefined
61:17 - let's see this in action so we're
61:19 - passing 0 and we get a null object so
61:22 - if we execute this code
61:24 - we get undefined so the result of this
61:27 - expression is undefined but if we pass
61:30 - one we get an actual customer object so
61:33 - we'll see the customer's birthday
61:36 - on the console
61:37 - there you go okay so this is optional
61:40 - property access operator now we can take
61:42 - this to the next level let's make the
61:44 - birthday property optional
61:47 - now let's say we want to print the full
61:49 - year
61:50 - of the birth year so over here
61:53 - we have to call dot
61:55 - get
61:56 - full year
61:58 - now once again we have the same
62:00 - compilation error because the birthday
62:02 - property might possibly be undefined
62:05 - once again to solve this problem we can
62:07 - use the optional property access
62:09 - operator so now this piece of code gets
62:12 - executed only if you have a customer and
62:14 - that customer has a birthday otherwise
62:17 - the result of this expression is
62:18 - undefined okay
62:20 - now we also have
62:22 - what we call
62:24 - optional
62:25 - element access operator and this is
62:28 - useful when we are dealing with arrays
62:30 - so we might have an area of customers
62:32 - and we want to print the first customer
62:35 - on the console now if this array is
62:37 - going to be non or undefined of course
62:39 - we have to check
62:40 - if customers is not null and it's not
62:43 - undefined
62:45 - then we're going to access the first
62:47 - element now this is where we can use the
62:49 - optional element access operator so
62:53 - before accessing this element
62:55 - we use a question mark and a dot okay
62:59 - now we also have
63:02 - the optional call operator which has the
63:04 - exact same syntax so let's imagine
63:07 - we have a variable called log which is
63:09 - going to reference a function
63:11 - so for simplicity i'm going to annotate
63:13 - this with any
63:14 - and this might be set to a function
63:16 - like a function that takes a message
63:18 - and
63:19 - prints that message on the console
63:21 - or we might set this to
63:24 - no
63:24 - right
63:25 - now let's say we want to call this
63:27 - and pass some value if we run this
63:30 - program our program is going to crash
63:32 - because log is not so this is where we
63:34 - can use the optional call operator so
63:37 - this piece of code will get executed
63:40 - only if log is referencing an actual
63:42 - function otherwise we'll get undefined
63:47 - hey guys mosh here i just wanted to let
63:49 - you know that this tutorial you have
63:51 - been watching is actually the first hour
63:53 - of my complete typescript course the
63:56 - complete course is about five hours long
63:58 - and goes way beyond this tutorial it
64:00 - also comes with exercises and solutions
64:03 - summary notes and cheat sheets a 30-day
64:05 - money-back guarantee and a certificate
64:07 - of completion you can add your resume so
64:09 - if you're serious about learning
64:11 - typescript and are looking for a job as
64:13 - a front-end or a back-end developer i
64:15 - highly encourage you to enroll in the
64:16 - course in case you're interested i'll
64:18 - put the link in the description box
64:22 - [Music]
64:27 - you

Cleaned transcript:

welcome to the ultimate typescript course in this course i'm going to teach you everything you need to know about typescript from the basics to more advanced concepts so by the end of this course you'll be able to use typescript to build largescale applications if you're looking for a comprehensive easy to follow well organized and practical course that takes you from zero to hero this is the right typescript course for you everything you need to know about typescript is in one place so you don't need to jump back and forth between random tutorials i'm mush hamidani and i've taught millions of people how to advance their software engineering skills through my youtube channel and online school codewoodmosh.com if you're new here be sure to subscribe as we upload new videos all the time now let's jump in and get started to take this course you need to know typescript now that was a joke you don't need any familiarity with typescript as i'm going to cover everything from scratch but because typescript is built on top of javascript you need basic familiarity with javascript concepts such as variables and constants arrays objects functions arrow functions destructuring and so on if you need to refresh the basics i have a bunch of tutorials and comprehensive courses you can take i've put the links down below in case you are interested so assuming that you're the right student for this course now let's talk about how you should take this course first and foremost i want you to watch this entire course all the way from the beginning to the end because every lesson teaches you something new if you have taken any of my other courses before you know that i don't waste your time with repetitive or useless stuff so make sure to watch every lesson now while watching each lesson i want you to take notes you can just write down some keywords on a piece of paper if you don't want to write a lot of notes i strongly believe that the act of writing things down will help you remember new things that you learn now when you get to the end of each section make sure to do all the exercises i've carefully designed these exercises to help you better understand and remember the materials remember the more you practice the better you'll be at typescript or coding in general welcome to the first section of the ultimate typescript course we're going to start this section with a quick introduction about typescript we're going to talk about what it is why we use it and when then we're going to set up our development environment and create our first typescript program next we'll talk about configuring the typescript compiler and we'll finish this section by talking about debugging typescript applications so let's jump in and get started let's start by talking about the top three questions people ask about typescript what is typescript why do we need it and how is it different from plain or vanilla javascript well typescript is a programming language created at microsoft to address some of the shortcomings of javascript you can think of it like the brother or sister of javascript javascript is like a kid without any discipline who does whatever he or she wants typescript on the other hand is like a kid with some discipline now technically speaking typescript is a programming language built on top of javascript so every javascript file is a valid typescript file but typescript adds some really cool features to javascript that help us build more robust and maintainable applications in less time the most important feature typescript offers is static typing what does that mean well we have two types of programming languages statically typed and dynamically typed languages in statically typed languages like c plus plus c sharp and java we know the type of variables at compile time or while coding for example we can declare a variable of type integer and this variable can only hold integer values nothing else so we cannot set it to a string or another type of object in dynamically typed languages like javascript python and ruby the type of variables is dynamic so it's determined at runtime and it can also change so we can declare a variable set it to a number and then later on change it to a string so this variable does not have a fixed or a static type the type is determined and may change at runtime now this is great and gives us a lot of flexibility but it can also lead to problems what if we pass this variable to a function that expects a number then our application might misbehave or crash now the problem is that we will not know about these issues until we run our application or our unit tests well assuming that we have them in place so we have to test every function with various edge cases to cache these bugs and this is the problem that typescript tries to solve typescript is essentially javascript with type checking with typescript we explicitly set the type of our variables upon declaration just like how we code in statically typed languages then we pass our code to the typescript compiler and the compiler will tell us if we are doing something wrong so we can catch a lot of our mistakes at compile time so if we declare a variable as a number we cannot set it to a string the typescript compiler is going to stop us right there and this happens at compile time so we don't have to run our application or our unit tests and test every piece of code to cache these errors we can catch a lot of them simply by compiling our application okay but typescript is more than just type checking most code editors these days have great support for typescript so they can detect the type of our variables and offer productivity boosting features like code completion and refactoring also typescript includes additional features that help us write cleaner and more concise code now over time these features get added to javascript but because we have various browsers and runtime environments for executing javascript code it takes some time until these features are implemented in various browsers so by coding in typescript we can use the features of future javascript so in a nutshell typescript is built on top of javascript and we can use it wherever we use javascript on the front end or the back end so anything we can do with javascript we can also do with typescript now all these great benefits aside let's talk about the drawbacks of typescript first with typescript there is always a compilation step involved because at this time browsers don't understand typescript code so we have to give our code to the typescript compiler to compile and translate into javascript this process is called transpilation second with typescript we have to be a bit more disciplined when writing code so if you're a lazy programmer like our famous old john smith and want to get things done quickly you may feel typescript is getting in the way and that's true but if you're working on a large project with multiple developers you would end up wasting more time coding in vanilla javascript and catching those nasty bugs so then you really want to use typescript for simple applications you can totally get back to old vanilla javascript if that's what you prefer alright that's all about typescript next we're going to set up our development environment all right the first thing we need is node because we're going to use node package manager or npm to install the typescript compiler i believe as a student of this course you should have node on your machine but if not head over to nodejs.org and download the latest version over here once you do that then open a terminal window and run npm that is short for note package manager which we're going to use for installing thirdparty packages in this case typescript then we type i that is short for install dash g for installing this globally so we can access the typescript compiler in every folder and then we type the name of the package typescript now if you're on mac or linux and you get a permission error while running this command you have to prefix it with sudo or sudo well more accurately this is sudo because it's short for super user do but that aside let's go ahead and install the typescript compiler okay great now to verify our installation we type tsc that is shortboard typescript compiler dash v to get the version so here i'm running typescript version 4.6.3 you might install a newer version but don't worry because everything i'm going to teach you here will apply to newer typescript compilers now in this course just like my other courses i'm going to use visual studio code or vs code as my code editor you're welcome to use any editor you prefer but if you want to follow along and use some of the shortcuts i'm going to teach you i highly encourage you to use vs code in case you don't have it you can get it from code.visualstudio.com alright so go ahead and set up your development environment because in the next lesson we're going to write our first typescript program all right now i'm going to go to my desktop folder and create a new folder for our project called hello dash world you can call it anything you want and you can put it anywhere on your machine now let's go into this folder and open it with vs code so we type code period now if this doesn't work on your machine you can simply drag and drop this folder onto vs code okay so here's our project now let's add a new file here called index.ts so every typescript file should have the ts extension now earlier i told you that typescript is built on top of javascript so we say typescript is a supersort of javascript which means it has everything in javascript plus some additional features so here we can write any javascript code and that is valid typescript code so we can write console.log and print hello world now we can go back to our terminal window here or we can use the embedded terminal window in vs code so back in vs code under the view menu look we have terminal the shortcut on mac is control and backtick so we can open the terminal window right here and using typescript compiler we can compile index.ts okay now let's open our project folder look we have index.js which is the result of compilation so we have the exact same code here because in index.ts we haven't used any typescript features so let's write a bit of typescript code so here in index.ts i'm going to declare a variable using the let keyword i'm going to call it h and annotate it with number so by typing a colon followed by the type of variable we can annotate or explain a variable now we can initialize it to let's say 20. now here's the beautiful part because we have declared age as a number we cannot set it to a string or another type of object look we get this error right here it's saying type string is not assignable to type number this is the beauty of using typescript with typescript we can catch a lot of our mistakes at compile time we don't have to run our application or our unit tests to find that we accidentally set a number to a string so let's remove this bad line and recompile our file so back to the terminal tsc index.js good now take a look over here look at the javascript code that the typescript compiler generated so instead of the let keyword here we have var because by default the typescript compiler uses an older version of javascript called es5 which is short for ecmascript 5. so ecmoscript is a standard or a specification while javascript is an implementation of that specification so es5 is an old specification it's been around for a long time and all these features have been implemented in our browsers for a very very long time i think more than a decade now in the next lesson i'm going to show you how to configure the typescript compiler to target a newer javascript version so the code that will be generated would be more modern so here's the interesting part instead of let we're using var and we don't have our type annotation this is purely for the typescript compiler the actual javascript code doesn't specify the type of this variable okay so that's it for now starting from the next section we're going to explore typescript features in detail next i'm going to show you how to configure the typescript compiler all right let's talk about creating a configuration file for the typescript compiler so here in the terminal we run tsc double hyphen in it so this created a configuration file called tsconfig.json with these settings so let's close the terminal window and open ts config right here so in this file we have a number of settings and as you can see most of these are commented out by default we're only going to use a handful of them so don't be intimidated by all these settings you don't have to learn all of them in fact nobody knows all of them i don't know all of them either now in case you're curious in front of each setting you can see a description of what that setting is for so let's talk about a few of them in this lesson the first one is target which specifies the version of javascript that the typescript compiler is going to generate so this is set to es 2016 which is an old standard and it's been implemented in all browsers out there now depending on where you want to deploy your application you can use a higher target and that often results in shorter and less concise code so if we remove this value and press ctrl and space we can see all valid values so we have yes 2015 16 17 18 and so on now in this lesson i'm going to leave this at yes 2016 because this is the safest option for all browser applications out there but again depending on where you want to deploy your application and how much of older browsers you want to support you can use a higher target now the next setting we have here is module which is set to common js we'll talk about this setting later in the course where we talk about modules now in this section in the module section we have a setting called there which specifies the directory that contains our source files so let's remove the comment by pressing command and slash on mac or ctrl n slash on windows so this is set to period slash which represents the current folder now by convention we often put our source code into a separate folder so back to our project panel let's create a new folder here called src and then move index.ts right here okay now i'm going to delete index.js we don't need it for now okay so now we're going to change router to period slash source now we have a similar setting here under the emit section that setting is called outer and this specifies the directory that will contain our javascript files so let's enable this and change it to dist so when we compile our code using the typescript compiler our javascript files are going to be stored in this or distributable folder okay now here we have another useful setting called remove comments so if we enable this the typescript compiler is going to remove all the comments that we add in our typescript code so the generated javascript code is going to be shorter okay now another useful setting in this section is no emit on error so by default when we compile our code even if you have errors in our code the typescript compiler will still generate javascript files this is probably not what we want so the best option is to always enable this setting so if you have any mistakes in our code the typescript compiler is not going to generate any javascript files okay now with this configuration file in place now we can go back to the terminal and compile our code simply by running tsc without any arguments so we don't have to type index.ts we just run tse and this will compile all typescript files in this project take a look all right now we have a new folder called disk that contains our javascript file so this was the basics of ts config as we go through the course we'll explore more of this useful settings all right now let's see how we can debug our typescript applications in vs code this is very useful when things go wrong and our code doesn't work as expected so we can run our code line by line and see what exactly happens under the hood there are a few steps we need to follow first we go to tsconfig.json and here in the emit section we enable the source map feature so a source map is a file that specifies how each line of our typescript code maps to the generated javascript code let me show you so back to the terminal let's recompile our code good now look into this folder we have a new file called index.js.map this is our source map so if you look over here you see some code that specifies how our typescript code maps to our javascript code now this is not for us to understand this is for debuggers it's for machines okay so let's close this file now to make debugging more interesting let's go to index.ts and write some logic we can say if age is less than 50 we're going to add 10 to it okay now we're going to click on the first line to insert a breakpoint so when we start debugging the execution stops right at this line at this breakpoint from this point forward we can execute our code line by line okay now we go to the debug panel and click on create and launch the json file now from this drop down we select node.js and this creates a new file called launch.json in our project i'll show you that in a second so this is a json file with some configuration that tells vs code how to debug this application so we're going to use node to launch this program and here we have a label called launch program which you will see in a second and we can see our program starts here so in the source folder we have index.ts and our output files are stored in our workspace on our project in files with the js extension now here we need to add one more setting it's called prelaunch task we're going to set this to a string with this value tsc colon space build space hyphen space tsconfig.json make sure to type this out exactly as i have shown you here all these spaces matter okay so with this setting we are telling vs code to use the typescript compiler to build our application using this configuration file okay now we go back to index.es and to start debugging we can go to the debug panel and click on launch program this is the label that i just showed you now look at the shortcut it's f5 i always prefer to use shortcuts so let's start debugging good now our program started and the execution stopped right on this line at this breakpoint now on the top we have a bunch of tools for executing our code we have step over for executing one line we have step into we're stepping into a function currently we don't have any functions so it's not useful we also have step out this is useful for stepping out to the function we have restart and stop so in the tooltip that you see in front of each tool you can see the shortcut so the shortcut for stepping over a line is f10 let's press that so this line was executed now on the left side under variables you can see all the variables that are detected in this debugging session so under local we have age that is set to 20. as we execute each line you'll see the value of this variable getting updated now if there's something that you don't see in the variables window you can go to the watch window and insert a watch so we're going to watch the age variable current is 20. so let's step over this line now we're on this line so let's step over this as well now hcode updated but because our program terminated we don't see its value anymore but if you add one extra line here let's say console.log h let's start the debugging session one more time by pressing f5 now step over f10 f10 f10 and now h is 30. so this is debugging in via score it's very useful when things go wrong we can start our program and execute it line by line all right now that we're done with debugging we can stop the debugging session right here so that brings us to the end of this section starting from the next section we're going to explore typescript in detail hey guys mosh here i just wanted to let you know that this tutorial you have been watching is actually the first hour of my complete typescript course the complete course is about 5 hours long and goes way beyond this tutorial it also comes with exercises and solutions summary notes and cheat sheets a 30day moneyback guarantee and a certificate of completion you can add to your resume so if you're serious about learning typescript and are looking for a job as a frontend or a backend developer i highly encourage you to enroll in the course in case you're interested i'll put the link in the description box and if not that's totally fine let's move on to the next lesson welcome back to another section of the ultimate typescript course in this section we're going to explore the fundamentals of typescript so you will learn about the builtin types like the any type arrays tuples enums functions and objects the concepts you'll learn in this section will be the foundation for future sections so don't skip any lessons now let's jump in and get started so javascript has builtin types like number string boolean null undefined an object now typescript extends this list and introduces new types like any unknown never enum and tuple as we go through this section you will learn about all these steps in detail but before we get started let's see how we can play with primitive types in typescript so back in index.ts i'm going to delete all this code and declare a variable called sales of type number and set it to a value like one two three four five six seven eight nine so once again we're annotating or explaining the type of the sales variable using this syntax okay now in typescript if you have a large number we can separate its digits using an underscore that makes our code more readable okay now let's also declare a variable called course of type string and set it to typescript and one boolean called is published now let me show you something really cool in typescript we don't always have to annotate our variables because the typescript compiler can infer or detect the type of our variables based on their value for example because we have initialized this variable to a number the typescript compiler knows that this variable is a number so we don't have to annotate it so if we remove the annotation and hover our mouse over this variable look we can see that sales is a number similarly because we have initialized course to a string we can remove the annotation and once again we can see that course is a string and one more time now what if we declare a variable like level and don't initialize it typescript assumes that this variable is of type any we'll talk about that in the next lesson in timescript we have a new type called any which can represent any kind of values so if we declare a variable and don't initialize it the typescript compiler assumes this variable is of type any so we can set it to a number and then later on we can set it to a string but this is against the whole idea of using typescript because we use typescript for type safety so we get type checking so if we use the any type we essentially lose that feature and the major benefit of using typescript so as a best practice you should avoid using the any type as much as possible let's look at another example let's say we have a function called render that takes a document and simply renders it on the console now look we have a compilation error and the error is saying parameter document implicitly has on any type implicitly means we haven't explicitly or clearly set the type of this parameter so the compiler is inferring or guessing the type of this parameter and that's why we have this error now let's say this is part of a javascript project we're trying to convert to typescript and at this point it's impossible for us to explicitly annotate this with a particular type so we have to use the any type here now here we have two options to turn off this error one option is to annotate this with any so we're telling the compiler hey i know what i'm doing the document is of any type but what if we have tons of errors of this kind we don't want to go to every function and explicitly annotate various parameters with any well there is a nuclear option for that but i don't personally recommend that but let me show you how that works so let's remove the annotation now if you're on mac press command and p if you're on windows press ctrl and p to bring up the search box and go to tsconfig.json now look in the type checking section strict is turned on and this is equivalent to turning on some of the basic type checking features you will learn about these settings as we go through the course now the first setting you see here is no implicit any so let's remove the comment so if this feature is turned on the compiler will complain about implicit any types now let's turn this off and see what happens so back in index.ts the error is gone so use this with caution only if you know what you're doing otherwise there's really no point using typescript because you will lose the major benefits of typescript okay so back to ts config i'm going to revert this code good so that's all about the any type next we're going to talk about arrays all right let's talk about arrays in javascript we can declare an array like this now the thing about javascript arrays is that each element can be of different type so here we can have two numbers followed by a string and this is totally valid javascript code because javascript arrays are dynamic so each element can be of different type but what if we pass this array to a function that expects a list of numbers then the third element is going to cause some issue right this is where we use typescript so we can explicitly apply a type annotation here and say numbers is a number array now we see the error immediately at compile time so let's fix it good now in this particular case we don't even have to apply the type annotation because every element in this list is a number so if you remove the type annotation the compiler can still infer or guess the type of this variable great but what if we had an empty array here look now the type of this variable is any array which is something we should avoid with any arrays again we can have a mix of different types so the first element can be a number the second element can be of a different type like a string or a boolean so if you want to use an empty array you have to explicitly apply a type annotation here let's say number array now the third line is invalid so let's delete it now let me show you another cool benefit of using typescript and that is code completion or intellisense so if we type numbers that for each and pass an arrow function here like n goes to and then type n period over here we can see all the properties and methods of number objects because our editor knows the type of n it offers code completion so we can see all the methods of number objects this is very useful it's a great productivity boosting feature we don't get this with plain javascript right so that's another benefit of using typescript that's all about the arrays next we're going to talk about tuples typescript has a new type called topple which is a fixed length array where each element has a particular type we often use them when working with a pair of values for example let's say for each user we want to represent two values an id and an a so we declare a variable and annotate it using a special syntax like this first we add square brackets and then tell the compiler that the first element is going to be a number whereas the second element is going to be a string and then we initialize our variable like this so we have a fixed length array with exactly two elements nothing more nothing less so if we add a third element here we get a compilation error saying type number string number is not assignable to type number string okay so exactly two elements and these elements should have these types the first one has to be a number so if we pass a string again we get a compilation error now just like before here we get intellisense or code completion so if we access the first element we see all the methods of number objects and if you access the second element we see all the properties and methods of string objects again one of the reasons i love typescript now one thing you need to know about tuples is that internally they're represented using plain javascript arrays so if we compile our code we're just going to see a regular javascript array let me show you so in the terminal let's run tsc good now back in our project here in this folder let's open index.js look we just have a regular javascript array so that means back in our typescript code if we type user period over here we can see all the methods of array objects now one of this method is a little bit troublesome and that is the push method so we can call this method and store a third value in this array and the compiler is not going to complain here i believe this is one of the gaps in typescript at the time of recording this hopefully this will be solved in the future so a tuple is a fixed length array where each element has a particular type now as a best practice i would say restrict your tuples to only two values because anything more than that is going to make your code a bit hard to understand for example if you add a boolean and another number here what do these values really represent it's really hard to tell so tuples are useful when we have only two values like key value pairs next we're going to talk about enums typescript has another builtin type called enum which represents a list of related constants if you know c sharp or java you have seen enums before we have the exact same concept here in typescript so let's say we want to represent the size of tshirts as constants one way is to define three constants like this small medium and large that's one way and then throughout our code we can reference this constant another way is to group this constant inside an enum so we use the enum keyword then give our enum a name now note that here i'm using pascal naming convention so the first letter of every word should be uppercase okay then we add curly braces and inside the braces we add our members small medium and large once again i'm using the pascal naming convention for the members now when we define an enum we don't need to define these three constants anymore and by default the typescript compiler assigned the first member the value of 0 and other members values like 1 2 and so on now if you don't want to use these values we can explicitly set values so we can set small to 1 and then medium becomes 2 and large becomes three we can also use string values like s if we do this then we have to explicitly set a value for each member so medium and large like this now i'm going to revert this code and just rely on numbers so i'm going to initialize small to 1 and rely on the compiler to set the value for other members so now that we have this new type we can declare a variable like my size of type size and set it to size dot medium okay so this is how we can use enops now let's see what happens if we log my size on the console so back to the terminal let's run the typescript compiler good and then use node to execute our javascript code so we go to the disk folder and pick index.js so look we see the numeric value associated with our enum member okay now let's look at the generated javascript code in this file so back to the project here's our index file take a look so the generated javascript code is pretty verbose it's pretty lengthy now you don't need to worry about understanding this but let me show you a trick back to our typescript file if we define this enum as constant the compiler will generate a more optimized code so let's recompile our code and then look at index.js one more time now we don't see all that code anymore we only have one line for setting my size to 2. again you don't have to worry about the generated javascript code all i want you to take away here is that using an enum we can represent a list of related constants and if we define our inapps using the constant keyword the compiler will generate more optimized code next we're going to talk about functions let's talk about how typescript helps us prevent common problems when working with functions so let's define a function called calculate tags and give it an income parameter of type number now let's hover our mouse over the function name look at the type of the return value it's void meaning this function does not return a value if you return a value here like a number now the type of the return value is number so the typescript compiler has inferred the type of the return value for us and that's great but as a best practice we should always properly annotate our functions so all the parameters as well as the return type should be properly annotated especially if you're building an api for other people to use so in this case to annotate the return type we go after the list of parameters add a colon and specify the return type like number or void if we are not going to return a value so let's add number now this has an extra benefit if you forget to return a value or if you return a different kind of value like your string we get a compilation error immediately so as best practice always properly annotate your functions now let's temporarily return zero okay look at the income parameter this is an unused parameter now we have a compiler option for detecting these unused parameters so let's go back to our ts config file in the type checking section we have a compiler option called no unused parameters we have to explicitly turn this on because this setting is not part of strict setting now back to index.ts look we have a warning saying income is declared but its value is never read so let's change this code and say if income is less than 50 000 then we're going to return income times 1.2 now here we have another compilation error saying function lags ending return statement and return type does not include undefined it sounds a bit cryptic but what this error is saying is that if this condition is true we're going to return a number otherwise as you know javascript by default always returns undefined from our functions and undefined is not a number now let me temporarily remove the annotation for the return type look we have no compilation error but this function has a problem if the income is greater than 50 000 we're gonna get undefined from this function and this may cause a bug in our application the good news is that we have another compiler option for detecting these kind of issues where we forget to return a value so back to our ts config file again in the type checking section we have a setting called no implicit returns again we have to explicitly turn this on because this is not part of the strict setting okay now to factor code we have a warning saying not all code paths return a value so now we can fix this problem and say otherwise if income is greater than 50 000 we're going to return income times 1.3 but again it's best to always annotate our functions properly to prevent all these issues so we should always return a number from this function now we have another useful compiler setting for detecting unused variables so if we declare a variable like x and don't use it in this function this is unused now using the typescript compiler we can find these issues in our code so back to ts config here is the setting no unused locals with this feature enabled now back to our code we have a yellow warning saying x is declared but its value is never read so now we can delete this and make our code cleaner so this is the basics of functions now let's add a second parameter here called tax here of type number now we have a warning here saying texture is declared but its value is never read so let's change our condition to if tax year is less than 2022 then return income times 1.2 so now with these two parameters if you want to call this function we have to supply exactly two arguments nothing more nothing less so i'm going to pass 10 000 for the income and 2022 for the tax year if you add an extra argument here we get a compilation error saying expected two arguments but got three if you have been coding in javascript for a while you know that this is valid javascript code so javascript doesn't really care how many arguments we pass to a function we can pass more or fewer arguments than the number of parameters but typescript is very strict about this so here we should pass exactly two arguments so let's remove that but what if you want to make this optional let's say in some places we want to call this function without supplying the tax year well we can make this parameter optional by adding a question mark right here now we have a compilation error on this line saying object is possibly undefined so if we don't supply the tax year by default undefined will be used and we cannot compare undefined with 2022. so here we have two options one option is to use the old javascript trick so we wrap this in parenthesis and then using the or operator we give it a default value like 2022 so if we don't supply the tax year this value will be used otherwise the argument that we pass will be used here okay now i don't like this approach there is a better way we can give this a default value so instead of making it optional we give it a default value like this now we can call this function with or without a tax year if we don't supply an argument for the tax year this value will be used otherwise what we pass here will overwrite the default value okay now with this default value we no longer need to use this ugly expression we can simply compare tax year with 2022 so let's quickly recap what you learned in this lesson as a best practice always properly annotate your functions all the parameters and return types and enable these three compiler options no unused locals no unused parameters and no implicit returns all right the last thing we're going to cover in this section is objects so let's declare an employee object with an id property now you know that in javascript objects are dynamic so their shape can change throughout the lifetime of our programs so once we have an employee object then later we can give it a new property like name and this is totally valid in javascript but as you can see this is not valid in typescript the compiler is saying property name does not exist on this type so this type is an object with an id property which is a number so just like all the variables we have declared so far the typescript compiler has inferred the shape of this employee object so if you hover our mouse over employee we can see its shape it's an object with an id that is a number now just like all the variables we have declared so far we can explicitly apply a type annotation here so after employee we add a colon followed by braces and inside the braces we define the properties of an employee object so every employee should have an id that is a number and a name that is a string now the previous error on this line is gone but we have a new kind of error let's find out the compiler is saying property name is missing so the reason we're seeing this is because every employee should have these two properties but while initializing this object we haven't supplied the name property now here we have two options one option is to set the name to an empty string we cannot set it to null or undefined we'll talk about this in the next section so we should either set it to an empty string or we can make this property optional and then we don't have to supply the name property while initializing an employee now even though typescript allows us to do something like this this is something we should avoid because conceptually it doesn't make sense to have an employee without a name every employee should have a name it would make sense to make the fax property optional because not everyone has a fax machine right so always make sure the code you write conceptually makes sense don't blindly use features of typescript or any other programming languages okay so in this case we're not going to use an optional property and that means we should either set the name to an empty string or initialize it right here okay now we have an error because i used a period okay so now we don't need this last line anymore okay now sometimes we want to make certain properties read only so we don't accidentally change them later on so with our current implementation we can change the idea of an employee anytime and this is not valid this is where we use the readonly modifier so we applied before the name of the property and now the typescript compiler prevents us from accidentally modifying the value of this property okay good now how can we define a function or more accurately a method in this object let's say every employee object should have a retirement method so in our type annotation we need to define the signature of this method we need to specify how many parameters it's going to have what is the type of each parameter and what is the type of the return value so we're going to have a retire method with one parameter that is date now here we use the arrow function syntax so first we add parenthesis and inside parenthesis we specify the parameters so we're going to have a date parameter of type date this is just a builtin data object in javascript and typescript so we only have one parameter then we use a fat arrow and here we specify the type of the return value we don't want to return any value so we're going to use weight now we have a compilation error saying property retire is missing because when initializing this object we haven't supplied the retired method so let's do that real quick all right retirement is going to be a method with one parameter and over here i just want to lock the date on the console pretty simple so this is how we can work with objects now i know this syntax this type annotation is a little bit messy it's making our code a bit verbose or noisy so in the next section i'll show you a better way to work with objects welcome back to another section of the ultimate typescript course in this section we're going to explore more advanced types in typescript so you will learn how to use type aliases to reuse types and simplify your code how to use unions and intersections to combine types how to narrow types how to work with nullables as well as the unknown and never types so let's jump in and get started alright so this is the employee object that we created at the end of the previous section now there are three problems in this implementation the first problem is that if you want to create another employee object we have to repeat this structure we have to repeat this shape so we'll end up duplicating our code which is bad we always want to confirm to the dry principle don't repeat yourself now the second problem is that the other employee object might have other properties so these two employee objects might not have a consistent shape because we don't have a single place to define the shape of an employee object now the third problem is that overall this structure is making our code a little bit hard to read and understand this is where we use a type alias using a type alias we can define a custom type let me show you so on the top we start with the type keyword then give our new type and name and once again here we use the pascal case so employee with a capital e then we set it to braces and inside the braces we define all the properties and methods an employee object should have so i'm going to go in this annotation select these three lines and by pressing alt and up we can move these lines up okay now when defining this employee object we annotate it with our new type employee okay so now we have a single place where we define the shape of an employee object and we can reuse this in multiple places this is the benefit of using a type abs all right let's talk about union types with union types we can give a variable or a function parameter more than one type so let's define a function for converting weight from kilogram to pounds now we give it a parameter called weight now let's assume that this parameter can be either a number or a string so we annotate it with number or string so using a vertical bar we can create a union type now we can call this function in two ways we can give it a number or a string like 10 kilograms okay now let's finish up this example so we're going to annotate the return type and return a number now in this function at this point we don't know if the weight is a number or a string so if we type weight period we only see the properties and methods that are common between numbers and strings so both numbers and strings have these three methods to locale string to string and value of so here we are not seeing methods that are specific to numbers or strings and this is where we use a technique called narrowing so we're going to narrow down this union type into a more specific type so here we can say if type of weight equals number now in this block the compiler knows that the weight is a number so if we type weight period we see all the methods that are available in number objects and by the way we don't necessarily need the code blocks here in this line if you have a oneliner and type weight period we still see all the methods available in numbers okay so what are we going to do here we're going to return weight times 2.2 otherwise if you end up here that means weight as a string so now we see all the properties and methods of string objects okay so to finish this example here we're going to return first we need to convert the weight to an integer so we call parsend pass the weight and then multiply it by 2.2 okay now back to the terminal let's compile our code and see what we get all right we're going to go to index.js take a look our union type is not part of the generated javascript code it's purely for the compiler to do is type checking so in the previous lesson you learned that using a union type we can say a variable or a function parameter can be one of many types right now we have another technique for combining types called intersection so instead of a vertical bar use an ampersand and now this type represents an object that is both a number and a string at the same time now technically this is impossible we cannot have an object that is both a number and a string at the same time so let's look at a more realistic example i'm going to use our type alias to define a new custom type called draggable so this represents an object that can be dragged on the screen now what properties or methods do we need in a draggable object well at least we need a method called drag which takes no arguments and returns void now similarly we're going to define another type called resizable and here we need a resize method that should take two parameters like the new width and the new height but for simplicity let's get rid of all that noise and just add no parameters and say this method returns void okay so now we have two separate types and using an intersection type we can combine them into a new type so we can define a new type called ui widget which is draggable and resizable so this is an intersection type now with this type in place we can declare a variable called textbox which is a ui widget now to initialize this object we need to implement all members of draggable and resizable objects so we need to implement the drag and resize methods so drag as a simple method and so is the resize method so this is type intersection in action sometimes we want to limit the values we can assign to a variable this is where we use literal types so let's declare a variable called quantity and assume that the quantity can either be 50 or 100 but nothing else now here's the problem if we annotate this with number this can take any numbers any valid numbers in javascript right so to limit the values we can use here we use a literal type so instead of annotating this with the type like number will annotate it with a literal meaning an exact or specific value so i'm going to replace number with 50. now quantity can only be set to 50 nothing else so if you set it to 51 you get a compilation error now you might think this is not useful well that's true but what if we apply the union operator here so we can say the quantity can be 50 or 100. now we can set it to 50 or 100 right but we're not done yet we can make this code even better so instead of hard coding these literal values here we can create a custom type using a type alias so we define a new type called quantity which can be 50 or 100 and then we annotate our variable with our new type so what we have over here is called a literal type now literals don't have to be numbers they can also be strings for example we can define a new type called metric which can be centimeter or inch okay so that's all about literal types next we're going to talk about nullable types all right let's talk about working with null values so by default typescript is very strict about using null and undefined values because as you probably know these values are common source of bugs in their applications so let's look at a real example let's define a function called greet that takes a name which is a string now in this function we just want to do a console.log and print name the to uppercase now in vanilla javascript we can call this function and accidentally give it null or undefined that is totally valid javascript code but when we run our program our program is going to crash because we cannot call this method on a null or an undefined object so this is why null and undefined values are a common source of problems and that's why by default the typescript compiler stops us from using null or undefined values so here we have an error saying argument of type null is not assignable to parameter of type string let me show you where this comes from so let's go to our ts config file in the type checking section we have a compiler option called strict null checks that this is enabled by default as part of the strict option so if strict is set to true strict null checks is also true but we can overwrite it and turn off this feature now back to index.ts the error is gone so this is why by default typescript is very strict about using null values so technically we should never use this option we should never turn it off so i'm going to rewrite this back but what can we do in this function what if we want to have the ability to use a null value perhaps if we don't have a name you want to print just a generic message like hola meaning high in spanish so here we can say if name is truthy meaning it has a value then we're going to print name.to uppercase otherwise if it's null or undefined we're gonna print hola okay but we cannot pass a null value here this is where we use a union type once again so we annotate this parameter with string or no now we can pass a null value but we cannot pass undefined because this is not a valid value for this parameter so if you want to have the ability to pass undefined as well again we're going to use the union operator now when working with nullable objects we often have to do null checks for example let's define a type alias called customer and give it a birthday property of type date now let's define a function for getting a customer from a database so we give it an id which is a number and we get either a customer or null in case there is no customer with the given id now in this function let's write some basic logic like return if id equals zero then we return null otherwise we return a customer object with this birthday pretty simple now let's declare a variable and here we call getcustomer and pass zero now let's imagine we want to print the customer's birthday so console.log and here we pass customer dot birthday now here we have a compilation error because customer might possibly be no so as you know one way to solve this problem is like this we check if customer is not known then we execute this piece of code now let's take this to the next level and assume that under certain circumstances this function might return undefined so we add undefined here and now we have to expand this if statement and check for undefined so if customer is not null and it's not undefined either then we print the customer's birthday that works but there is a simpler way to write this code in typescript we can remove this if statement and use what we call the optional property access operator so because customer might be null or undefined right after it we add a question mark and then we add the chaining or the dot operator so this question mark followed by the chaining operator is called the optional property access operator so now this piece of code gets executed only if we have a customer that is not null or undefined let's see this in action so we're passing 0 and we get a null object so if we execute this code we get undefined so the result of this expression is undefined but if we pass one we get an actual customer object so we'll see the customer's birthday on the console there you go okay so this is optional property access operator now we can take this to the next level let's make the birthday property optional now let's say we want to print the full year of the birth year so over here we have to call dot get full year now once again we have the same compilation error because the birthday property might possibly be undefined once again to solve this problem we can use the optional property access operator so now this piece of code gets executed only if you have a customer and that customer has a birthday otherwise the result of this expression is undefined okay now we also have what we call optional element access operator and this is useful when we are dealing with arrays so we might have an area of customers and we want to print the first customer on the console now if this array is going to be non or undefined of course we have to check if customers is not null and it's not undefined then we're going to access the first element now this is where we can use the optional element access operator so before accessing this element we use a question mark and a dot okay now we also have the optional call operator which has the exact same syntax so let's imagine we have a variable called log which is going to reference a function so for simplicity i'm going to annotate this with any and this might be set to a function like a function that takes a message and prints that message on the console or we might set this to no right now let's say we want to call this and pass some value if we run this program our program is going to crash because log is not so this is where we can use the optional call operator so this piece of code will get executed only if log is referencing an actual function otherwise we'll get undefined hey guys mosh here i just wanted to let you know that this tutorial you have been watching is actually the first hour of my complete typescript course the complete course is about five hours long and goes way beyond this tutorial it also comes with exercises and solutions summary notes and cheat sheets a 30day moneyback guarantee and a certificate of completion you can add your resume so if you're serious about learning typescript and are looking for a job as a frontend or a backend developer i highly encourage you to enroll in the course in case you're interested i'll put the link in the description box you
