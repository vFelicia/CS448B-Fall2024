With timestamps:

00:01 - in this video you're going to learn
00:02 - everything you need to know about java
00:04 - collections so by the end of this video
00:06 - you'll be able to write java code with
00:08 - confidence hi i'm adani and i've taught
00:11 - millions of people how to code through
00:13 - this channel and my online school
00:15 - codewoodmash.com this video is part of
00:17 - my ultimate java mastery course so once
00:20 - you finish this video if you want to
00:22 - learn more you may want to look at the
00:23 - complete course now let's jump in and
00:25 - get started
00:32 - let's start this section by brief
00:33 - overview of what we have in the
00:34 - collections framework
00:36 - so the green boxes you see here are
00:38 - interfaces and the blue boxes are
00:40 - classes that implement these interfaces
00:43 - now don't worry about memorizing any of
00:44 - these we're going to get back to this
00:46 - slide several times throughout this
00:47 - section
00:48 - so at the top of this hierarchy we have
00:50 - the iterable interface
00:52 - this interface represents an object that
00:54 - can be used in a for each statement so
00:57 - if we implement this interface in our
00:58 - generic list class we'll be able to use
01:00 - it in a for each loop i'll show you how
01:02 - to do that later
01:04 - below that we have the collection
01:05 - interface
01:06 - this interface extends the iterable
01:08 - interface and adds additional
01:10 - functionality it represents an object
01:12 - that can act like a container or a
01:14 - collection of objects now here's a
01:16 - question for you what are the
01:18 - capabilities that we need in a
01:19 - collection we should be able to add an
01:22 - object to a collection we should be able
01:23 - to remove an object we should be able to
01:26 - check for the existence of an object and
01:27 - so on
01:28 - so these are the operations that the
01:30 - collection interface declares
01:33 - if you search for java collection
01:34 - interface
01:35 - on this page
01:37 - you can see all the operations that this
01:38 - interface declares for example we have
01:41 - add for adding an object we have add all
01:43 - we have clear and so on
01:45 - now below this collection interface we
01:47 - have three sub interfaces list queue and
01:50 - set
01:51 - each of these again inherits all the
01:53 - capability declared in the collection
01:55 - interface and add something extra
01:58 - for example the list interface allows us
02:00 - to work with an ordered collection and
02:02 - access objects using their index just
02:04 - like how we can access an object by its
02:06 - index in an array now we have different
02:09 - implementations of this interface in the
02:10 - collections framework the one that you
02:12 - would be using most of the time is the
02:14 - arraylist class which is an
02:16 - implementation of a dynamic array so
02:18 - internally it uses an array to store
02:20 - objects if the array gets full it will
02:23 - automatically resize the array
02:25 - we have another implementation called
02:27 - linked list which is based on the linked
02:30 - list data structure the explanation of
02:32 - linked lists goes beyond the scope of
02:34 - this course i've covered them in detail
02:35 - in my data structures and algorithms
02:37 - course
02:38 - so we have two different implementations
02:40 - of the list interface again most of the
02:42 - time you will be using the arraylist
02:44 - class
02:44 - the q interface also extends the
02:46 - collection interface and provides
02:48 - additional operations for working with a
02:51 - queue of objects we use cues in
02:53 - situations where we have a resource that
02:55 - can be shared amongst many consumers a
02:58 - good example of this is the printer at
03:00 - your office different people can print
03:02 - different papers at the same time but a
03:04 - printer is not going to be able to print
03:05 - them all simultaneously so each job
03:08 - should go in a queue the printer will
03:10 - then take these jobs one by one and
03:12 - process them now in the collections
03:14 - framework the class that implements the
03:16 - qr interface is called priority queue
03:18 - we're going to look at that later in
03:19 - this section
03:20 - and finally we have the set interface
03:22 - which represents a collection without
03:24 - duplicates the class that implements
03:26 - this interface is called hiset
03:28 - so that was a very basic overview
03:31 - throughout this section we're going to
03:32 - explore each of these building blocks in
03:34 - detail
03:37 - [Music]
03:41 - as i told you in the last video the
03:43 - iterable interface is at the top of our
03:45 - hierarchy now more accurately this
03:47 - interface is not part of the collections
03:49 - framework in fact it's part of the
03:51 - java.lang package so it's one of the
03:54 - fundamental interfaces in java and
03:56 - represents an object that we can iterate
03:59 - or loop over
04:00 - now before we look at the specifics of
04:02 - this interface let's talk about the
04:04 - problem it tries to solve
04:06 - so here in the main method i'm going to
04:07 - create a generic list
04:09 - new generic list of strings
04:13 - let's add a couple of objects here
04:15 - so add a and b
04:18 - now we want to iterate over this list
04:20 - and print each item so we write a for
04:22 - each loop for item in list look we have
04:26 - a compilation error here for each not
04:28 - applicable to type generic list
04:31 - now one way to solve this problem is to
04:34 - go back to the generic list class and
04:36 - make this private field public
04:39 - then we'll be able to access the items
04:41 - array from outside of this class
04:44 - so here in the main method we can type
04:46 - list.items
04:48 - now we can iterate over this array and
04:50 - print each item
04:52 - now the problem with this approach is
04:54 - that we have exposed the internal
04:56 - implementation of this class to the
04:57 - outside
04:58 - so if we decide to change this
05:00 - implementation in the future and replace
05:03 - this array with a different data
05:05 - structure
05:06 - all the code that is dependent on this
05:08 - field will have to be changed as a
05:10 - metaphor think of the remote control of
05:12 - your tv this remote control has a few
05:14 - simple buttons for you to work with but
05:16 - on the inside it has a complex logic
05:19 - board that's the implementation detail
05:21 - now if tomorrow the manufacturing
05:23 - company decides to change this internal
05:25 - implementation you are not going to get
05:27 - affected if they replace a transistor
05:30 - with an advanced model you can still use
05:32 - the same buttons you're familiar with
05:34 - so changing the internal implementation
05:36 - of a remote control should not impact
05:39 - its public interface
05:40 - in object-oriented programming we should
05:42 - design our classes in the same way again
05:45 - i talked about this concept a lot in the
05:47 - second part of the series
05:48 - so back to our generic list we should
05:50 - not expose the items filled to the
05:52 - outside because this is the
05:53 - implementation detail let me show you
05:55 - the problem with this code
05:57 - with this implementation we can go back
05:59 - to our main method and write code like
06:01 - this list that items of zero
06:04 - we set this to a string like a
06:06 - and then we can print less than
06:09 - items.length now what is the problem
06:11 - here well there is no problem right now
06:13 - but if tomorrow we decide to replace
06:16 - this array with an arraylist object our
06:19 - code is going to break let me show you
06:21 - so
06:22 - we type arraylist
06:24 - of t this is a class declared in the
06:26 - collections framework and it's an
06:28 - implementation of a dynamic array we're
06:30 - going to look at it soon
06:32 - so let's create an arraylist object here
06:34 - new arraylist
06:36 - now back to the main method
06:40 - see what happened
06:41 - our code broke because the arraylist
06:44 - class does not support the square
06:46 - bracket syntax for accessing an object
06:48 - by its index
06:50 - also
06:51 - it doesn't have a field called length
06:54 - so a simple change in the implementation
06:56 - detail of our generic list resulted in
06:59 - two breaking changes
07:01 - in our main method now this is a very
07:03 - simple program but in a real application
07:05 - we could have hundreds of references to
07:07 - our generic list so if we change the
07:09 - implementation detail then we'll have to
07:11 - go back and fix all those hundreds of
07:13 - places that are broken
07:15 - so here's the question
07:17 - how can we iterate over a list without
07:19 - knowing anything about its internal
07:21 - implementation that is where the
07:23 - iterable interface comes to the rescue
07:25 - in the next video i'm going to show you
07:26 - how to solve this problem using the
07:28 - iterable interface
07:33 - [Music]
07:37 - the iterable interface represents an
07:38 - object that is iterable that means we
07:41 - can iterate or loop over it without
07:43 - knowing anything about this
07:44 - implementation detail
07:46 - so we are using an area here if we
07:48 - decide to replace this with an arraylist
07:50 - or a different data structure in the
07:52 - future the clients of this class are not
07:54 - going to get affected because they are
07:56 - going to code against the iterable
07:57 - interface
07:58 - back to our remote control metaphor
08:00 - think of the buttons for changing the
08:02 - volume if the internal implementation of
08:04 - this remote control changes you're not
08:06 - going to get affected you're still going
08:08 - to use the same buttons these buttons
08:10 - are the interfaces that you work with
08:13 - so we want to implement the iterable
08:15 - interface in this class and then have
08:17 - other classes that use our generic list
08:19 - program against the iterable interface
08:21 - it's like saying that they use the
08:23 - volume control buttons on a remote
08:24 - control okay now
08:27 - here is the documentation for the
08:28 - interval interface as you can see this
08:31 - interface declares three methods the
08:33 - first and last methods have a default
08:35 - implementation so we don't have to
08:37 - implement them the only method that we
08:39 - have to implement
08:41 - is this method over here iterator it
08:43 - returns an iterator object we're going
08:45 - to talk about iterators in the next
08:47 - video but very briefly an iterator is an
08:50 - object that we use to iterate over an
08:52 - iterable now i know the name is
08:54 - confusing but don't worry i'm going to
08:56 - make it super simple for you so back to
08:58 - our generic list class
09:00 - here we type
09:02 - implements iterable
09:04 - of t so this is also a generic interface
09:09 - now we press alt and enter
09:12 - and have intellij implement the method
09:15 - so here you can see the same three
09:17 - methods that i showed you the iterator
09:19 - method is highlighted because it's a
09:21 - required method so
09:23 - let's press ok and here you can see the
09:25 - iterator method for now don't worry
09:27 - about the code we're going to write in
09:28 - this method we're going to come back and
09:30 - complete this in the next video all i
09:32 - want you to pay attention to is the
09:34 - return type of this method
09:36 - it returns an iterator object
09:39 - so
09:39 - back to our main method
09:42 - now that our list implements the
09:43 - iterable interface we know that it has
09:46 - the iterator method so we call it to get
09:49 - an iterator
09:51 - and with this we can iterate or loop
09:53 - over our list without knowing anything
09:56 - about its internal implementation
09:58 - so we can write code like this while
10:00 - iterator
10:02 - has next we're going to call iterator
10:06 - dot next this will return the current
10:08 - object so we store it over here
10:11 - and then print it on the console what's
10:14 - going on here well imagine
10:17 - our list looks like this so we have a b
10:20 - and c
10:21 - this iterator is like a pointer that is
10:23 - pointing at one object
10:25 - so initially it's pointing at the first
10:27 - object
10:28 - at the beginning of our loop we ask do
10:30 - you have more items it says yes so here
10:33 - we call the next method this will return
10:36 - the current item which is the a
10:38 - and then it will advance
10:39 - the pointer to point to b
10:42 - in the next iteration we ask the
10:43 - iterator do you have more items we still
10:46 - do so this method will return true
10:49 - then we read the current item and
10:51 - advance the pointer
10:52 - one more time we read the c
10:54 - and then the iterator ends up here so in
10:56 - the next iteration when we call the
10:58 - hasnext method we'll get false
11:01 - so this iterator
11:03 - is simply an object that we use to
11:05 - iterate over a list or more accurately
11:08 - an object that is iterable
11:10 - now let me show you something really
11:11 - interesting
11:12 - let's compile the code
11:15 - then
11:15 - from the project window
11:17 - let's select the main class and look at
11:19 - its byte code representation
11:23 - take a look
11:24 - so over here we have a reference to
11:26 - iterator that has next and iterator.next
11:32 - now i'm going to delete all the code for
11:34 - using this iterator object and instead
11:37 - use a for each loop so for each item
11:40 - and list we're going to print each item
11:44 - one more time we're going to compile the
11:45 - code
11:47 - and look at the bytecode representation
11:49 - of the main class
11:53 - take a look we still have a reference to
11:55 - the iterator object
11:57 - so the for each loop is actually a
12:00 - syntactical sugar over the iterator
12:02 - object when we use the for each loop the
12:04 - java compiler will convert our code to
12:07 - use an iterator object
12:09 - this is the reason why we can iterate
12:11 - over this list using a forage loop now
12:16 - if i remove this bit of code over here
12:18 - implements iterable and go back to the
12:20 - main class
12:22 - you can see we have a compilation error
12:23 - saying for each not applicable to type
12:26 - generic list
12:27 - so this is the benefit of implementing
12:30 - the iterable interface it allows us to
12:32 - iterate over an object without knowing
12:34 - anything about its internal
12:36 - implementation
12:37 - so
12:38 - i'm going to bring this back
12:40 - now if tomorrow we decide to replace
12:42 - this array with let's say an arraylist
12:44 - our foreign loop
12:46 - is not going to get affected
12:48 - now our implementation is not complete
12:50 - we still have to implement the iterator
12:52 - method and that's what we're going to do
12:54 - next
12:58 - [Music]
13:02 - in this video we're going to complete
13:03 - our implementation of the iterator
13:05 - method
13:06 - so as you can see this method returns
13:08 - an iterator object this iterator is
13:11 - actually an interface declared in the
13:13 - java.util package
13:15 - so here on the documentation you can see
13:18 - the four methods declared in this
13:19 - interface
13:20 - these two methods over here have a
13:21 - default implementation so we don't have
13:23 - to worry about them the only two methods
13:25 - that we have to implement are has next
13:28 - and next which you saw in the last video
13:30 - so now we should declare a new class
13:33 - that implements the iterator interface
13:36 - so back to our generic list we're going
13:38 - to implement this iterator as a private
13:40 - nested class inside this generator list
13:43 - class you will see why in a second
13:45 - so after the iterator method we declare
13:48 - a private class called list
13:51 - iterator
13:53 - this class should implement the iterator
13:55 - interface which is generic so iterator
13:58 - of t
13:59 - now this t that we have here is the same
14:01 - t
14:02 - that we used when declaring our generic
14:05 - list
14:06 - so if the client of this class let's say
14:08 - in our main method we create a new
14:10 - generic list of string this type
14:12 - parameter is going to be a string and
14:14 - we're going to use the same type
14:16 - parameter over here
14:17 - because we're going to iterate over a
14:19 - list of strings so that is why i don't
14:22 - want to hard code a type over here like
14:24 - string or integer i want to use the same
14:27 - type parameter that we have on the top
14:28 - okay so here's our
14:31 - private class now let's implement the
14:34 - iterator interface so we press alt enter
14:37 - and select implement methods
14:40 - so the two required methods are
14:42 - highlighted let's click ok
14:45 - now in this class we want to iterate
14:47 - over a generic list so we should pass
14:49 - that generic list over here via a
14:51 - constructor so let's add a constructor
14:54 - public
14:55 - list
14:56 - iterator here we need a parameter of
14:59 - type generic list of t
15:02 - the same type parameter
15:04 - we call it list
15:05 - now we should store this in a private
15:07 - field in this class so private
15:10 - generate list of t recorded list
15:13 - and here we set this that list
15:17 - to list
15:18 - now
15:19 - because we have declared this list
15:21 - iterator inside our generic list
15:24 - here we have access
15:26 - to list that items so we can see the
15:29 - items array and this is perfectly fine
15:31 - because this class is part of the
15:33 - implementation of our generic list
15:36 - so if tomorrow we decide to replace this
15:37 - array with let's say an arraylist this
15:40 - class is the only place where we have to
15:42 - make changes because this class knows
15:44 - how to iterate over a generic list
15:47 - so if we replace the items array with an
15:49 - arraylist nowhere else in the code
15:51 - nowhere inside the main method or
15:53 - anywhere else where we have used a
15:54 - generic list we have to make changes
15:56 - okay now here's a question how can we
15:59 - iterate over an array well we need an
16:02 - index variable initially we set it to
16:04 - zero as long as the index is less than
16:06 - the number of items in the array we
16:08 - increment it right so
16:10 - let's declare
16:12 - a private field of type integer called
16:14 - index
16:16 - now in our has next method instead of
16:18 - returning false we're going to return a
16:20 - boolean expression like this
16:22 - if index is less than list that count
16:27 - then
16:28 - in our next method instead of returning
16:30 - null
16:31 - we're going to return list that items
16:34 - of index
16:36 - and then we'll increment
16:38 - the index so initially index is zero
16:41 - when we call the next method this will
16:42 - return list that items of zero
16:45 - now next time we call this method index
16:47 - is going to be one so we'll return the
16:49 - second item in this array and we're
16:51 - going to do this as long as index is
16:53 - less than the number of items in our
16:55 - list okay
16:56 - so
16:57 - pretty simple we're done implementing
16:59 - our list iterator
17:01 - now
17:02 - back to our iterator method instead of
17:05 - returning null we're going to return a
17:07 - new list iterator
17:10 - now note that here we have another list
17:13 - iterator which is an interface declared
17:15 - in the java.util package we don't want
17:17 - this one we want the list iterator that
17:19 - we declared here
17:20 - so
17:22 - let's create a new object and here we
17:24 - should pass our generic list to the
17:26 - constructor of this class what is that
17:30 - that is the current object this
17:32 - so let's quickly recap
17:35 - we made our generic list iterable by
17:38 - implementing the iterable interface
17:40 - and here we return a list iterator this
17:44 - is an object that knows how to iterate
17:46 - over a generic list so it has intimate
17:49 - knowledge of the implementation detail
17:51 - of our generic list if tomorrow we
17:54 - decide to replace this array with an
17:56 - arraylist or a different data structure
17:59 - this iterator is the only place where we
18:02 - have to modify our code
18:03 - now
18:04 - back to our main class
18:06 - let's add a couple of items in this list
18:09 - let's add a
18:10 - and then b
18:11 - here we can iterate over this list using
18:13 - a 4-h loop
18:15 - take a look
18:16 - we get a and b
18:19 - next we're going to talk about the
18:20 - collection interface
18:25 - [Music]
18:29 - the next interface we're going to talk
18:30 - about is the collection interface which
18:32 - represents an object that acts as a
18:35 - collection or a container for other
18:37 - objects what are the operations that we
18:39 - need to work with the collection we
18:41 - should be able to add an object to this
18:43 - collection we should be able to remove
18:45 - an existing object we should be able to
18:47 - check for the existence of an object and
18:48 - so on these are the operations that the
18:51 - collection interface declares
18:53 - here on the documentation you can see
18:54 - that the collection interface is also a
18:57 - generic interface because here we have a
18:59 - generic type parameter but instead of t
19:01 - we have e which is short for element
19:04 - that is a common convention for
19:05 - declaring interfaces or classes that
19:08 - have a collection semantic because a
19:10 - collection can have multiple elements
19:12 - okay
19:13 - now over here you can see that this
19:15 - interface extends the iterable interface
19:18 - so every collection is also iterable and
19:20 - that means we can use a for each loop to
19:23 - iterate over all collections in java
19:26 - now over here you can see various
19:27 - classes that implement this interface as
19:29 - you can see there are over 20
19:31 - implementations of this interface most
19:33 - of the time like 90 of the time you only
19:36 - need to use the arraylist class these
19:38 - other implementations are for special
19:40 - purposes and we're not going to cover
19:42 - them in this course you can learn about
19:43 - them on your own i just want to give you
19:45 - a strong foundation
19:47 - so back to our project i'm going to add
19:49 - a new package
19:51 - a new package called collections we're
19:54 - going to write all the code in this
19:55 - section
19:56 - in this package
19:58 - i'm going to add a new class
20:00 - called collections demo
20:02 - in this class we're going to have a
20:04 - public static method called show
20:08 - this is where i'm going to show you
20:09 - various operations in the collection
20:11 - interface if you download the source
20:13 - code that i've included at the beginning
20:14 - of this course you can see all examples
20:17 - in this class but while i'm recording
20:19 - this video i'm going to delete some of
20:21 - these examples to keep the screen clean
20:23 - and easy to read
20:25 - now back in the main class we're going
20:26 - to call
20:28 - collectionsdemo
20:30 - dot show
20:33 - now here i'm going to declare a variable
20:35 - of type collection of string
20:38 - let's import this type
20:40 - so that is an interface we call this
20:42 - variable collection
20:45 - now here we should set this to a new
20:46 - instance of arraylist
20:50 - because this is one of the classes that
20:51 - implements this interface
20:54 - now let's add a few items to this
20:55 - collection so collection.add
20:58 - we can add a string like a
21:00 - then b
21:01 - and then c
21:03 - because this collection is iterable we
21:05 - can use a forage loop here so for item
21:07 - in collection we can print each item
21:13 - so we get abc we can also print the
21:16 - collection as a whole so print
21:18 - collection
21:21 - now what if you want to add multiple
21:23 - items in one go instead of calling the
21:25 - add method three times well here we have
21:28 - another class called collections that is
21:31 - a utility class declared in the
21:33 - java.util package
21:36 - this class has a method called add all
21:38 - the first parameter of this method is
21:40 - the collection that we want to modify so
21:42 - we pass our collection over here now
21:44 - look at the second argument
21:46 - here we can see the list of parameters
21:47 - by pressing command and p on mac or ctrl
21:51 - p on windows if the shortcut doesn't
21:53 - work for you you can find it under view
21:57 - parameter info okay
21:58 - so look at the second parameter a string
22:01 - dot dot dot when you see dot dot dot
22:03 - that means you can pass a variable
22:05 - number of arguments you can pass zero or
22:08 - more strings so
22:10 - here we can pass a
22:12 - and then b
22:13 - and then c
22:14 - so instead of calling the add method
22:16 - three times we're passing multiple
22:18 - arguments to this method
22:20 - now if we run our program
22:22 - we get the same result as before
22:25 - another useful method is the size method
22:27 - that returns the size of a collection
22:31 - so here we have three items
22:35 - we also have a method for removing an
22:36 - object from a collection so we can call
22:39 - collection.remove a
22:42 - and then we can print the collection
22:47 - so a is gone
22:49 - we can also remove all items by calling
22:52 - the clear method
22:55 - now the collection is empty
22:58 - we can verify that by calling the is
23:00 - empty method
23:01 - so
23:02 - it returns true
23:05 - if you want to check for the existence
23:06 - of an item you can call
23:08 - the contains method so we want to see if
23:12 - this collection contains
23:15 - an a so it contains a
23:18 - and then we can print contains
23:20 - a you get true
23:24 - there are times you want to convert a
23:25 - collection to a regular array
23:28 - so here we call collection.2
23:31 - array
23:32 - as you can see this method has three
23:34 - forms or three overloads
23:36 - if we don't pass any arguments here this
23:38 - will return an object array so
23:41 - we can store it in an object array
23:45 - so every item in this array is going to
23:47 - be an instance of the object class that
23:50 - means
23:50 - if we get the first item and use the dot
23:54 - operator we don't see any of the string
23:56 - methods if that's what you need then you
23:58 - need to convert this collection to a
23:59 - string array instead of an object array
24:02 - that's very easy
24:03 - we call collection.2 array we're going
24:06 - to use this form this overload that
24:08 - takes a t array so
24:12 - if we pass a new string array here now
24:15 - how many items do we have in this
24:17 - collection one two three so we pass a
24:20 - string array over here
24:22 - and this will return
24:24 - a string
24:25 - array
24:27 - also we don't really have to specify the
24:29 - size here we could simply pass zero and
24:31 - that is a common convention because you
24:33 - don't want to worry about counting the
24:35 - number of items in your collection
24:37 - you can simply pass an empty array and
24:39 - this method would automatically create
24:41 - an array with enough capacity to hold
24:44 - all these items okay now
24:47 - if we get the first item
24:49 - we can access all the string methods for
24:52 - example we can convert this string to
24:53 - the lowercase or uppercase and so on
24:57 - and by the way we can use var here just
24:59 - as usual
25:00 - now some people don't like var they
25:02 - argue that we cannot see the type of
25:04 - this object but that is not right so if
25:07 - you put the carrot over here and then go
25:09 - to view
25:11 - quick documentation the shortcut is f1
25:14 - you can easily see that this is an
25:16 - object array or if you put the caret
25:18 - over here and one more time press f1
25:21 - we can see that this is a string array
25:23 - so i personally prefer var because it
25:26 - makes our code cleaner so this is how we
25:28 - can use the two array methods
25:31 - now there are times you want to compare
25:32 - to collections for equality
25:35 - so i'm going to create another
25:36 - collection
25:38 - of type string
25:40 - let's call it other and set it to a new
25:43 - arraylist
25:45 - now what would happen if we use
25:47 - var over here
25:49 - then the type of this variable is going
25:51 - to be the arraylist class not the
25:53 - collection interface so it's going to
25:54 - include the additional methods that are
25:56 - declared in the arraylist class
25:59 - now as i explained in the second part of
26:00 - this series we should program against
26:02 - interfaces this will make our
26:04 - applications more flexible and loosely
26:06 - coupled so i'm going to revert this back
26:09 - to collection of string
26:11 - now i want to add every object that we
26:14 - have in this collection
26:16 - in our second collection so
26:18 - we type other that add all
26:22 - now look at the type of this parameter
26:24 - it's collection of unknown extends
26:27 - string so we have a wildcard again that
26:30 - means we can pass a collection of string
26:32 - or any type that extends the collection
26:34 - of string
26:36 - so
26:36 - i'm going to pass our first collection
26:40 - now you want to check to see if these
26:42 - two collections are equal
26:43 - so i'm going to do a print statement
26:45 - here
26:46 - what do you think is the result of this
26:48 - expression collection equals other
26:51 - are we going to get true or false
26:53 - we're going to get false because these
26:55 - are two different objects in memory look
26:58 - here we have
26:59 - two new operations
27:01 - so these are going to be different
27:02 - objects in memory and this equality
27:04 - operator compares these objects by their
27:07 - references or their addresses in memory
27:10 - now if you want to check to see if two
27:12 - collections have the exact same content
27:14 - you should use the equals method so
27:16 - print
27:17 - collection
27:18 - equals other
27:21 - take a look
27:23 - so we get false as a result of
27:25 - evaluating this expression because these
27:27 - are two different objects in memory but
27:29 - we get true because these two
27:31 - collections have the exact same content
27:36 - so this was all about the collection
27:38 - interface once again don't worry about
27:39 - memorizing any of these all you need to
27:41 - take away from this video is the kind of
27:44 - operations that are provided by the
27:46 - collection interface we can add an
27:47 - object we can remove an object we can
27:49 - check to see if an object exists and so
27:51 - on don't worry about memorizing you can
27:53 - always look at these operations on the
27:55 - documentation
27:56 - next we're going to look at the list
27:58 - interface
28:02 - [Music]
28:06 - the list interface represents an ordered
28:07 - collection also called a sequence so
28:10 - with lists we can access objects by
28:12 - their index
28:14 - in collections we don't care about the
28:15 - index of objects we just care about
28:18 - adding or removing them from a
28:19 - collection
28:20 - so in your applications if you want to
28:22 - work with an ordered collection if you
28:24 - care about the index of objects on a
28:26 - collection you should use the list
28:28 - interface so let's declare a variable of
28:31 - type list of string
28:33 - we're going to import this
28:35 - and set it to a new
28:37 - array list
28:38 - now because the list interface extends
28:40 - the collection interface here we have
28:42 - all the methods you learned about in the
28:44 - last video so we can call list.add
28:48 - to add a few items
28:49 - a b and c
28:52 - but we also have an overload of the ad
28:55 - that takes an integer
28:56 - so if you want to insert
28:58 - a value or an object at a particular
29:00 - index we use this overload let's say i
29:02 - want to add
29:04 - an exclamation mark at the beginning so
29:06 - you pass zero as the index of the first
29:09 - item now we can print the list
29:14 - and here's the result we couldn't do
29:16 - this with the collection interface
29:18 - because collections don't support
29:20 - indexing
29:22 - now we can also add multiple items in
29:23 - one go
29:24 - so
29:25 - here we call collections
29:28 - that add all
29:30 - now look at the first parameter it's a
29:32 - collection so because every list is a
29:34 - collection
29:35 - here we can pass our list object
29:38 - along with a few values like a b and c
29:43 - now here we can get an object by its
29:45 - index
29:46 - using the get method
29:47 - so we can get the first item and print
29:49 - it
29:50 - and we get a
29:52 - we also have a method for replacing an
29:53 - object at the given index
29:55 - so list.set
29:58 - let's set the first object to
30:00 - a plus
30:02 - now we print plain turn list
30:06 - and here's the result
30:08 - we can also remove an object by its
30:10 - index
30:11 - here we call
30:12 - list.remove zero
30:15 - again we didn't have this method in the
30:16 - collection interface because collections
30:18 - don't support indexing
30:20 - now take a look
30:22 - a is gone and we only have b and c
30:27 - another useful method is the index of
30:30 - method so we can call the index of
30:32 - method and pass a
30:34 - and this will return the index of the
30:36 - first occurrence of a
30:38 - in this case it's going to be 0.
30:41 - now if we search for a value or an
30:44 - object that doesn't exist here
30:46 - you're going to get negative 1.
30:48 - there you go
30:51 - another useful method is last index of
30:55 - and this will return the index of the
30:57 - last occurrence of this object so if we
30:59 - add another a here
31:02 - the index of the second a is going to be
31:04 - three
31:05 - so
31:08 - there you go
31:11 - now i'm going to remove this
31:13 - another useful method is the sublist
31:15 - method so
31:17 - we can call list.sublist
31:20 - here we pass two indexes from and two
31:23 - from is inclusive but two is exclusive
31:26 - so we can start from index zero and get
31:29 - all the items up to index two
31:31 - and this will return the objects at
31:33 - index zero and one take a look
31:38 - there you go
31:39 - just realize that the original list is
31:41 - not affected because this method returns
31:44 - a new list okay
31:46 - so this is all about the list interface
31:48 - next we're going to talk about sorting
31:50 - data
31:53 - thank you so much for watching this
31:55 - video as i said this video is part of my
31:57 - ultimate java mastery course that
31:59 - teaches you everything you need to know
32:01 - about java from the basics to more
32:03 - advanced concepts so if you want to
32:04 - learn more i highly encourage you to
32:06 - take a full course it's much faster than
32:08 - jumping from one tutorial to another if
32:11 - you're interested the link is below this
32:12 - video thank you and have a great day
32:19 - [Music]

Cleaned transcript:

in this video you're going to learn everything you need to know about java collections so by the end of this video you'll be able to write java code with confidence hi i'm adani and i've taught millions of people how to code through this channel and my online school codewoodmash.com this video is part of my ultimate java mastery course so once you finish this video if you want to learn more you may want to look at the complete course now let's jump in and get started let's start this section by brief overview of what we have in the collections framework so the green boxes you see here are interfaces and the blue boxes are classes that implement these interfaces now don't worry about memorizing any of these we're going to get back to this slide several times throughout this section so at the top of this hierarchy we have the iterable interface this interface represents an object that can be used in a for each statement so if we implement this interface in our generic list class we'll be able to use it in a for each loop i'll show you how to do that later below that we have the collection interface this interface extends the iterable interface and adds additional functionality it represents an object that can act like a container or a collection of objects now here's a question for you what are the capabilities that we need in a collection we should be able to add an object to a collection we should be able to remove an object we should be able to check for the existence of an object and so on so these are the operations that the collection interface declares if you search for java collection interface on this page you can see all the operations that this interface declares for example we have add for adding an object we have add all we have clear and so on now below this collection interface we have three sub interfaces list queue and set each of these again inherits all the capability declared in the collection interface and add something extra for example the list interface allows us to work with an ordered collection and access objects using their index just like how we can access an object by its index in an array now we have different implementations of this interface in the collections framework the one that you would be using most of the time is the arraylist class which is an implementation of a dynamic array so internally it uses an array to store objects if the array gets full it will automatically resize the array we have another implementation called linked list which is based on the linked list data structure the explanation of linked lists goes beyond the scope of this course i've covered them in detail in my data structures and algorithms course so we have two different implementations of the list interface again most of the time you will be using the arraylist class the q interface also extends the collection interface and provides additional operations for working with a queue of objects we use cues in situations where we have a resource that can be shared amongst many consumers a good example of this is the printer at your office different people can print different papers at the same time but a printer is not going to be able to print them all simultaneously so each job should go in a queue the printer will then take these jobs one by one and process them now in the collections framework the class that implements the qr interface is called priority queue we're going to look at that later in this section and finally we have the set interface which represents a collection without duplicates the class that implements this interface is called hiset so that was a very basic overview throughout this section we're going to explore each of these building blocks in detail as i told you in the last video the iterable interface is at the top of our hierarchy now more accurately this interface is not part of the collections framework in fact it's part of the java.lang package so it's one of the fundamental interfaces in java and represents an object that we can iterate or loop over now before we look at the specifics of this interface let's talk about the problem it tries to solve so here in the main method i'm going to create a generic list new generic list of strings let's add a couple of objects here so add a and b now we want to iterate over this list and print each item so we write a for each loop for item in list look we have a compilation error here for each not applicable to type generic list now one way to solve this problem is to go back to the generic list class and make this private field public then we'll be able to access the items array from outside of this class so here in the main method we can type list.items now we can iterate over this array and print each item now the problem with this approach is that we have exposed the internal implementation of this class to the outside so if we decide to change this implementation in the future and replace this array with a different data structure all the code that is dependent on this field will have to be changed as a metaphor think of the remote control of your tv this remote control has a few simple buttons for you to work with but on the inside it has a complex logic board that's the implementation detail now if tomorrow the manufacturing company decides to change this internal implementation you are not going to get affected if they replace a transistor with an advanced model you can still use the same buttons you're familiar with so changing the internal implementation of a remote control should not impact its public interface in objectoriented programming we should design our classes in the same way again i talked about this concept a lot in the second part of the series so back to our generic list we should not expose the items filled to the outside because this is the implementation detail let me show you the problem with this code with this implementation we can go back to our main method and write code like this list that items of zero we set this to a string like a and then we can print less than items.length now what is the problem here well there is no problem right now but if tomorrow we decide to replace this array with an arraylist object our code is going to break let me show you so we type arraylist of t this is a class declared in the collections framework and it's an implementation of a dynamic array we're going to look at it soon so let's create an arraylist object here new arraylist now back to the main method see what happened our code broke because the arraylist class does not support the square bracket syntax for accessing an object by its index also it doesn't have a field called length so a simple change in the implementation detail of our generic list resulted in two breaking changes in our main method now this is a very simple program but in a real application we could have hundreds of references to our generic list so if we change the implementation detail then we'll have to go back and fix all those hundreds of places that are broken so here's the question how can we iterate over a list without knowing anything about its internal implementation that is where the iterable interface comes to the rescue in the next video i'm going to show you how to solve this problem using the iterable interface the iterable interface represents an object that is iterable that means we can iterate or loop over it without knowing anything about this implementation detail so we are using an area here if we decide to replace this with an arraylist or a different data structure in the future the clients of this class are not going to get affected because they are going to code against the iterable interface back to our remote control metaphor think of the buttons for changing the volume if the internal implementation of this remote control changes you're not going to get affected you're still going to use the same buttons these buttons are the interfaces that you work with so we want to implement the iterable interface in this class and then have other classes that use our generic list program against the iterable interface it's like saying that they use the volume control buttons on a remote control okay now here is the documentation for the interval interface as you can see this interface declares three methods the first and last methods have a default implementation so we don't have to implement them the only method that we have to implement is this method over here iterator it returns an iterator object we're going to talk about iterators in the next video but very briefly an iterator is an object that we use to iterate over an iterable now i know the name is confusing but don't worry i'm going to make it super simple for you so back to our generic list class here we type implements iterable of t so this is also a generic interface now we press alt and enter and have intellij implement the method so here you can see the same three methods that i showed you the iterator method is highlighted because it's a required method so let's press ok and here you can see the iterator method for now don't worry about the code we're going to write in this method we're going to come back and complete this in the next video all i want you to pay attention to is the return type of this method it returns an iterator object so back to our main method now that our list implements the iterable interface we know that it has the iterator method so we call it to get an iterator and with this we can iterate or loop over our list without knowing anything about its internal implementation so we can write code like this while iterator has next we're going to call iterator dot next this will return the current object so we store it over here and then print it on the console what's going on here well imagine our list looks like this so we have a b and c this iterator is like a pointer that is pointing at one object so initially it's pointing at the first object at the beginning of our loop we ask do you have more items it says yes so here we call the next method this will return the current item which is the a and then it will advance the pointer to point to b in the next iteration we ask the iterator do you have more items we still do so this method will return true then we read the current item and advance the pointer one more time we read the c and then the iterator ends up here so in the next iteration when we call the hasnext method we'll get false so this iterator is simply an object that we use to iterate over a list or more accurately an object that is iterable now let me show you something really interesting let's compile the code then from the project window let's select the main class and look at its byte code representation take a look so over here we have a reference to iterator that has next and iterator.next now i'm going to delete all the code for using this iterator object and instead use a for each loop so for each item and list we're going to print each item one more time we're going to compile the code and look at the bytecode representation of the main class take a look we still have a reference to the iterator object so the for each loop is actually a syntactical sugar over the iterator object when we use the for each loop the java compiler will convert our code to use an iterator object this is the reason why we can iterate over this list using a forage loop now if i remove this bit of code over here implements iterable and go back to the main class you can see we have a compilation error saying for each not applicable to type generic list so this is the benefit of implementing the iterable interface it allows us to iterate over an object without knowing anything about its internal implementation so i'm going to bring this back now if tomorrow we decide to replace this array with let's say an arraylist our foreign loop is not going to get affected now our implementation is not complete we still have to implement the iterator method and that's what we're going to do next in this video we're going to complete our implementation of the iterator method so as you can see this method returns an iterator object this iterator is actually an interface declared in the java.util package so here on the documentation you can see the four methods declared in this interface these two methods over here have a default implementation so we don't have to worry about them the only two methods that we have to implement are has next and next which you saw in the last video so now we should declare a new class that implements the iterator interface so back to our generic list we're going to implement this iterator as a private nested class inside this generator list class you will see why in a second so after the iterator method we declare a private class called list iterator this class should implement the iterator interface which is generic so iterator of t now this t that we have here is the same t that we used when declaring our generic list so if the client of this class let's say in our main method we create a new generic list of string this type parameter is going to be a string and we're going to use the same type parameter over here because we're going to iterate over a list of strings so that is why i don't want to hard code a type over here like string or integer i want to use the same type parameter that we have on the top okay so here's our private class now let's implement the iterator interface so we press alt enter and select implement methods so the two required methods are highlighted let's click ok now in this class we want to iterate over a generic list so we should pass that generic list over here via a constructor so let's add a constructor public list iterator here we need a parameter of type generic list of t the same type parameter we call it list now we should store this in a private field in this class so private generate list of t recorded list and here we set this that list to list now because we have declared this list iterator inside our generic list here we have access to list that items so we can see the items array and this is perfectly fine because this class is part of the implementation of our generic list so if tomorrow we decide to replace this array with let's say an arraylist this class is the only place where we have to make changes because this class knows how to iterate over a generic list so if we replace the items array with an arraylist nowhere else in the code nowhere inside the main method or anywhere else where we have used a generic list we have to make changes okay now here's a question how can we iterate over an array well we need an index variable initially we set it to zero as long as the index is less than the number of items in the array we increment it right so let's declare a private field of type integer called index now in our has next method instead of returning false we're going to return a boolean expression like this if index is less than list that count then in our next method instead of returning null we're going to return list that items of index and then we'll increment the index so initially index is zero when we call the next method this will return list that items of zero now next time we call this method index is going to be one so we'll return the second item in this array and we're going to do this as long as index is less than the number of items in our list okay so pretty simple we're done implementing our list iterator now back to our iterator method instead of returning null we're going to return a new list iterator now note that here we have another list iterator which is an interface declared in the java.util package we don't want this one we want the list iterator that we declared here so let's create a new object and here we should pass our generic list to the constructor of this class what is that that is the current object this so let's quickly recap we made our generic list iterable by implementing the iterable interface and here we return a list iterator this is an object that knows how to iterate over a generic list so it has intimate knowledge of the implementation detail of our generic list if tomorrow we decide to replace this array with an arraylist or a different data structure this iterator is the only place where we have to modify our code now back to our main class let's add a couple of items in this list let's add a and then b here we can iterate over this list using a 4h loop take a look we get a and b next we're going to talk about the collection interface the next interface we're going to talk about is the collection interface which represents an object that acts as a collection or a container for other objects what are the operations that we need to work with the collection we should be able to add an object to this collection we should be able to remove an existing object we should be able to check for the existence of an object and so on these are the operations that the collection interface declares here on the documentation you can see that the collection interface is also a generic interface because here we have a generic type parameter but instead of t we have e which is short for element that is a common convention for declaring interfaces or classes that have a collection semantic because a collection can have multiple elements okay now over here you can see that this interface extends the iterable interface so every collection is also iterable and that means we can use a for each loop to iterate over all collections in java now over here you can see various classes that implement this interface as you can see there are over 20 implementations of this interface most of the time like 90 of the time you only need to use the arraylist class these other implementations are for special purposes and we're not going to cover them in this course you can learn about them on your own i just want to give you a strong foundation so back to our project i'm going to add a new package a new package called collections we're going to write all the code in this section in this package i'm going to add a new class called collections demo in this class we're going to have a public static method called show this is where i'm going to show you various operations in the collection interface if you download the source code that i've included at the beginning of this course you can see all examples in this class but while i'm recording this video i'm going to delete some of these examples to keep the screen clean and easy to read now back in the main class we're going to call collectionsdemo dot show now here i'm going to declare a variable of type collection of string let's import this type so that is an interface we call this variable collection now here we should set this to a new instance of arraylist because this is one of the classes that implements this interface now let's add a few items to this collection so collection.add we can add a string like a then b and then c because this collection is iterable we can use a forage loop here so for item in collection we can print each item so we get abc we can also print the collection as a whole so print collection now what if you want to add multiple items in one go instead of calling the add method three times well here we have another class called collections that is a utility class declared in the java.util package this class has a method called add all the first parameter of this method is the collection that we want to modify so we pass our collection over here now look at the second argument here we can see the list of parameters by pressing command and p on mac or ctrl p on windows if the shortcut doesn't work for you you can find it under view parameter info okay so look at the second parameter a string dot dot dot when you see dot dot dot that means you can pass a variable number of arguments you can pass zero or more strings so here we can pass a and then b and then c so instead of calling the add method three times we're passing multiple arguments to this method now if we run our program we get the same result as before another useful method is the size method that returns the size of a collection so here we have three items we also have a method for removing an object from a collection so we can call collection.remove a and then we can print the collection so a is gone we can also remove all items by calling the clear method now the collection is empty we can verify that by calling the is empty method so it returns true if you want to check for the existence of an item you can call the contains method so we want to see if this collection contains an a so it contains a and then we can print contains a you get true there are times you want to convert a collection to a regular array so here we call collection.2 array as you can see this method has three forms or three overloads if we don't pass any arguments here this will return an object array so we can store it in an object array so every item in this array is going to be an instance of the object class that means if we get the first item and use the dot operator we don't see any of the string methods if that's what you need then you need to convert this collection to a string array instead of an object array that's very easy we call collection.2 array we're going to use this form this overload that takes a t array so if we pass a new string array here now how many items do we have in this collection one two three so we pass a string array over here and this will return a string array also we don't really have to specify the size here we could simply pass zero and that is a common convention because you don't want to worry about counting the number of items in your collection you can simply pass an empty array and this method would automatically create an array with enough capacity to hold all these items okay now if we get the first item we can access all the string methods for example we can convert this string to the lowercase or uppercase and so on and by the way we can use var here just as usual now some people don't like var they argue that we cannot see the type of this object but that is not right so if you put the carrot over here and then go to view quick documentation the shortcut is f1 you can easily see that this is an object array or if you put the caret over here and one more time press f1 we can see that this is a string array so i personally prefer var because it makes our code cleaner so this is how we can use the two array methods now there are times you want to compare to collections for equality so i'm going to create another collection of type string let's call it other and set it to a new arraylist now what would happen if we use var over here then the type of this variable is going to be the arraylist class not the collection interface so it's going to include the additional methods that are declared in the arraylist class now as i explained in the second part of this series we should program against interfaces this will make our applications more flexible and loosely coupled so i'm going to revert this back to collection of string now i want to add every object that we have in this collection in our second collection so we type other that add all now look at the type of this parameter it's collection of unknown extends string so we have a wildcard again that means we can pass a collection of string or any type that extends the collection of string so i'm going to pass our first collection now you want to check to see if these two collections are equal so i'm going to do a print statement here what do you think is the result of this expression collection equals other are we going to get true or false we're going to get false because these are two different objects in memory look here we have two new operations so these are going to be different objects in memory and this equality operator compares these objects by their references or their addresses in memory now if you want to check to see if two collections have the exact same content you should use the equals method so print collection equals other take a look so we get false as a result of evaluating this expression because these are two different objects in memory but we get true because these two collections have the exact same content so this was all about the collection interface once again don't worry about memorizing any of these all you need to take away from this video is the kind of operations that are provided by the collection interface we can add an object we can remove an object we can check to see if an object exists and so on don't worry about memorizing you can always look at these operations on the documentation next we're going to look at the list interface the list interface represents an ordered collection also called a sequence so with lists we can access objects by their index in collections we don't care about the index of objects we just care about adding or removing them from a collection so in your applications if you want to work with an ordered collection if you care about the index of objects on a collection you should use the list interface so let's declare a variable of type list of string we're going to import this and set it to a new array list now because the list interface extends the collection interface here we have all the methods you learned about in the last video so we can call list.add to add a few items a b and c but we also have an overload of the ad that takes an integer so if you want to insert a value or an object at a particular index we use this overload let's say i want to add an exclamation mark at the beginning so you pass zero as the index of the first item now we can print the list and here's the result we couldn't do this with the collection interface because collections don't support indexing now we can also add multiple items in one go so here we call collections that add all now look at the first parameter it's a collection so because every list is a collection here we can pass our list object along with a few values like a b and c now here we can get an object by its index using the get method so we can get the first item and print it and we get a we also have a method for replacing an object at the given index so list.set let's set the first object to a plus now we print plain turn list and here's the result we can also remove an object by its index here we call list.remove zero again we didn't have this method in the collection interface because collections don't support indexing now take a look a is gone and we only have b and c another useful method is the index of method so we can call the index of method and pass a and this will return the index of the first occurrence of a in this case it's going to be 0. now if we search for a value or an object that doesn't exist here you're going to get negative 1. there you go another useful method is last index of and this will return the index of the last occurrence of this object so if we add another a here the index of the second a is going to be three so there you go now i'm going to remove this another useful method is the sublist method so we can call list.sublist here we pass two indexes from and two from is inclusive but two is exclusive so we can start from index zero and get all the items up to index two and this will return the objects at index zero and one take a look there you go just realize that the original list is not affected because this method returns a new list okay so this is all about the list interface next we're going to talk about sorting data thank you so much for watching this video as i said this video is part of my ultimate java mastery course that teaches you everything you need to know about java from the basics to more advanced concepts so if you want to learn more i highly encourage you to take a full course it's much faster than jumping from one tutorial to another if you're interested the link is below this video thank you and have a great day
