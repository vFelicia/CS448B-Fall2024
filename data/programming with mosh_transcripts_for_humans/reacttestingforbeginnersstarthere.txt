With timestamps:

00:00 - [Music]
00:02 - welcome to the complete react testing
00:04 - course in this course you're going to
00:06 - learn everything necessary to write
00:08 - effective valuable and maintainable
00:11 - tests for your react applications if you
00:13 - have been searching for a comprehensive
00:15 - easy to follow well organized and
00:17 - practical course that takes you from
00:19 - Zero to Hero this is the right react
00:21 - testing course for you this course is
00:24 - packed with a ton of coding techniques
00:26 - I've learned over 20 years in software
00:28 - engineering plus it's packed with
00:30 - numerous real word exercises designed to
00:33 - help you master react testing by the end
00:36 - of this course you'll have the skills
00:37 - and knowledge to confidently test react
00:40 - applications like your pro this
00:42 - expertise will set you apart in the
00:44 - world of software development opening
00:46 - doors to exciting opportunities and
00:48 - challenges I'm m hamadani a software
00:51 - engineer with over 20 years of
00:52 - experience and I've taught Millions how
00:55 - to code and become professional software
00:57 - Engineers through my YouTube channel and
00:59 - online school cm.com so are you ready to
01:02 - elevate your react skills let's dive in
01:04 - and get started I Promise by the end of
01:07 - this course you will look at unit
01:08 - testing in a whole new way if you're new
01:11 - here welcome aboard make sure to
01:13 - subscribe as we upload new videos all
01:15 - the
01:16 - [Music]
01:24 - time let's talk about what you need to
01:27 - know to take this course first and
01:29 - foremost you should have a good grasp of
01:31 - react because we're testing a react
01:33 - application in this course so you need
01:35 - to know all the essential Concepts like
01:37 - components hooks State Management
01:40 - routing and so on if you want to brush
01:42 - up on your react skills I have a couple
01:44 - of comprehensive courses on my website
01:46 - so feel free to check them out now if
01:48 - you're watching this video on YouTube
01:50 - I've put the links Below in the
01:52 - description box you can also go to code
01:54 - withth mos.com to see all my courses now
01:58 - the react application we're going to
01:59 - test in this course is written with
02:01 - typescript so you should know the basics
02:04 - of typescript as well don't worry you
02:06 - don't need to be an expert just knowing
02:08 - the basics is enough you should know how
02:10 - to define types and annotate your
02:12 - objects with types that's all now if you
02:15 - want to learn typescript I have a 1-hour
02:17 - tutorial on my YouTube channel as well
02:19 - as a comprehensive course on my website
02:22 - again the links are below this video now
02:25 - there is one more thing you need to know
02:27 - you should know the basics of unit
02:28 - testing plain JavaScript code without
02:31 - any UI Frameworks more specifically you
02:34 - should know how to write basic unit
02:36 - tests and make assertions so I'm
02:38 - assuming you know the basics of unit
02:40 - testing and in this course you want to
02:42 - learn how to test react applications now
02:46 - if you want to learn the basics of unit
02:47 - testing JavaScript code again I have a
02:50 - 1hour tutorial on my YouTube channel as
02:52 - well as a comprehensive course on my
02:54 - website now assuming that you are the
02:57 - right student for this course let's move
02:59 - on to the next Lon
03:05 - all right before we jump in let's take a
03:07 - quick look at what we'll cover in this
03:09 - course shortly after this video we're
03:11 - going to set up our development
03:12 - environment and get all the testing
03:14 - tools we need in the next section we'll
03:17 - explore testing react components with
03:19 - the react testing Library this is where
03:22 - the fun begins you will learn how to use
03:24 - this powerful library to write tests
03:27 - that are maintainable and closely
03:28 - resemble how your web pages are used
03:31 - then we'll talk about mocking apis you
03:34 - will learn how to write tests that are
03:36 - robust and independent of external
03:39 - factors next on our list is testing
03:41 - forms forms are crucial in user
03:43 - interaction and I will show you various
03:45 - techniques to make sure they work
03:47 - flawlessly every time moving forward
03:50 - we'll delve into testing State
03:51 - Management in this section we'll look at
03:54 - a few examples involving react context
03:57 - Redux and react query after that we'll
04:00 - talk about testing authentication and in
04:02 - the final section we'll cover testing
04:05 - routing now a lot of people struggle
04:07 - with unit testing why because they don't
04:09 - know how to write good tests they spend
04:11 - a lot of time writing and fixing
04:14 - lowquality tests these tests get in the
04:17 - way slow you down and can be really
04:19 - frustrating but don't worry because
04:21 - throughout the course I'm going to show
04:22 - you various techniques to write tests
04:25 - that are not just good but great these
04:27 - are the techniques I've learned and M
04:30 - over two decades of working as a
04:32 - software engineer so I will show you how
04:34 - to write tests that are effective
04:36 - valuable and easy to maintain so there's
04:39 - a lot to cover and by the end of this
04:41 - course you'll be really good at testing
04:43 - react applications I
04:50 - promise before we start coding let's
04:52 - talk about how you should take this
04:54 - course first off as you learned in the
04:56 - previous video I've structured this
04:58 - course so it's super clear and easy to
05:01 - follow now you might be tempted to just
05:03 - jump to the sections that seem relevant
05:05 - to you but here's my advice don't do
05:08 - that even if you have been writing tests
05:09 - for a while you might have picked up
05:11 - some bad habits along the way that's why
05:14 - I suggest starting from the beginning
05:16 - and watching every single lesson because
05:18 - throughout the course I share a bunch of
05:20 - shortcuts for navigating your code base
05:23 - and writing code quickly if you skip
05:25 - around you might miss these and feel
05:27 - like the course is moving too fast trust
05:29 - me these tips are game changers now
05:32 - let's talk about exercises this course
05:34 - is incredibly Hands-On and is packed
05:36 - with real boo exercises in fact more
05:39 - than half of the course is dedicated to
05:41 - these practical exercises if you really
05:44 - want to get good at testing you need to
05:46 - do these exercises and don't just do
05:48 - them make sure to watch my Solutions as
05:50 - well that's where I share the techniques
05:52 - I have learned and refined over two
05:55 - decades of working as a software
05:57 - engineer these aren't your everyday tips
05:59 - and tricks you probably won't find them
06:01 - in most other courses I promise every
06:03 - minute you spend on this course is going
06:05 - to be worth your time lastly this course
06:08 - comes with a couple of GitHub
06:10 - repositories there is one for the
06:11 - started project and another one for the
06:14 - finished project which includes all the
06:16 - code we write in this course for each
06:19 - lesson we have a separate commit this
06:21 - way you can see the exact code I write
06:23 - in that lesson step by step so that's
06:26 - how we can get the absolute best out of
06:28 - this course follow it step by step and
06:31 - complete all the exercises I can't wait
06:33 - to see how much you learn and grow as a
06:35 - software
06:41 - engineer all right before we get started
06:44 - let's make sure you have the necessary
06:46 - tools installed on your machine first
06:48 - head over to nodejs.org and download the
06:51 - latest version of node this is really
06:53 - important because sometimes in newer
06:55 - versions of node there are optimizations
06:57 - that make your tests run faster so make
07:00 - sure to download the latest version of
07:02 - node now in addition to node we're going
07:04 - to use git to manage our source code
07:07 - these days pretty much everyone has git
07:09 - on their machine but if you don't head
07:10 - over to g-m docomo the latest version
07:14 - for your operating system now in this
07:17 - course just like my other courses I'll
07:19 - be using visual studio code or vs code
07:21 - as my editor you're welcome to use your
07:24 - preferred editor but I highly recommend
07:26 - you to use Visual Studio code because it
07:28 - makes it easier to follow along plus I'm
07:31 - going to show you a lot of shortcuts to
07:33 - boost your productivity and have fun
07:40 - coding all right now let's set up the
07:42 - starter project for this course head
07:44 - over to github.com
07:46 - slmos dhamani then go to
07:51 - repositories here we have two
07:52 - repositories for this course react
07:55 - testing starter which is our starter
07:57 - project and react testing finish which
07:59 - is the completed solution so let's go to
08:01 - react testing
08:03 - starter now here you can find all the
08:06 - details about this project for example
08:08 - you can see that our project uses ozero
08:10 - for authentication and it's built with
08:13 - Tailwind rui react router react query
08:16 - and Redux toolkit ideally you should
08:19 - have basic familiarity with all these
08:21 - Technologies and libraries but if not
08:23 - that's still fine so the first thing we
08:25 - have to do here is setting up off zero
08:28 - for Authentication
08:30 - so head over to off zero.com if you
08:33 - don't have an account sign up it's free
08:35 - and it takes only a couple minutes then
08:38 - once you log in here on the dashboard on
08:41 - the left side go to
08:44 - Applications and create a new
08:47 - application we can call this whatever
08:49 - doesn't really matter I'm going to call
08:51 - it my react
08:54 - app now we go to the settings
08:57 - page and
08:59 - here we have to set a few settings first
09:03 - we have to set application type to
09:05 - single page
09:07 - application next we set allowed call
09:10 - back URLs we set it to http Local Host
09:14 - Port
09:16 - 5173 this is the port that our project
09:18 - uses now I'm going to copy this address
09:21 - and paste it in allowed log out URLs box
09:25 - as well as allowed web Origins
09:30 - then we save the
09:34 - changes all right good so we are done
09:36 - with setting up off zero now we need to
09:39 - go back to GitHub and clone this
09:41 - repository on our machine so let's grab
09:44 - the code then we open a terminal window
09:47 - and clone this
09:50 - repository all right now let's go to
09:54 - react testing starter first we need to
09:56 - install all the dependencies
10:01 - all right good now let's open this with
10:03 - vs code now here in the root directory
10:06 - we have ATV file we're going to take a
10:09 - copy of this for storing our local
10:12 - environment variables so let's make a
10:15 - copy and rename this copy to env. local
10:21 - now we need to replace the azero domain
10:24 - and client ID with the values from our
10:26 - ozero application so back to the
10:29 - settings page of our application on the
10:31 - top you can find the domain and client
10:33 - ID let's copy these values and paste
10:37 - them
10:38 - here and one more time with the client
10:44 - ID lovely now let's go to package.json
10:49 - so look here we have a few scripts we
10:52 - have the server script for starting the
10:55 - backend our backend is implemented with
10:57 - Json server so Json server uses this
11:00 - file db. Json to serve data to our
11:03 - application now in a real application
11:05 - you're not going to use this you're
11:06 - going to use a database but it doesn't
11:08 - really matter as far as testing is
11:10 - concerned because here we're not going
11:12 - to use the real backend we're going to
11:14 - Mark the back end and test the front end
11:16 - in isolation now here we have a script
11:18 - for starting the application using
11:20 - concurrently so using this package we
11:23 - can run both the back end and front end
11:26 - in parallel so back to the term let's
11:29 - run npm start our backend starts at
11:33 - Local Host Port 3000 so make sure you
11:36 - don't have any other applications
11:37 - running on that port and our front end
11:40 - starts at Port
11:43 - 5173 so let's take a look here's our
11:46 - application it's not a full-fledged
11:48 - application but it has a few cool
11:50 - features and patterns that you find in a
11:52 - lot of real world applications for
11:54 - example on the top we have a selector
11:56 - for selecting a language currently
11:58 - English is selected if we change it to
12:01 - Spanish now the message changes here
12:03 - let's go back to English so this is
12:06 - implemented using react context now
12:08 - let's go to the products page here we
12:11 - have a list of products that are feted
12:13 - from the back end we can add them to our
12:16 - shopping cart and the number of items in
12:19 - the shopping cart is updated on the top
12:21 - we also have an admin area that is
12:24 - protected here we get redirected to the
12:26 - universal login page on o zero so let's
12:30 - sign up with a new
12:36 - account all
12:39 - right let's authorize our application
12:42 - all right I'm logged in and now I have
12:44 - access to the admin area here we have a
12:48 - products page where we can manage our
12:51 - products we can add a new
12:53 - product we have a basic form let's add
12:56 - product one give it a price now here we
12:58 - have full validation so if we submit the
13:01 - form without supplying any values we get
13:03 - validation errors so let's give this a
13:05 - price of $10 and assign it to a category
13:08 - like
13:10 - Electronics here's our product we can
13:12 - also edit it let's change the category
13:15 - to
13:17 - appliances good now we get this toast
13:19 - notification on the top beautiful now
13:22 - finally if you log out we get redirected
13:24 - back to the homepage so we have a few
13:27 - interesting patterns and features that
13:28 - you find in a lot of real word
13:35 - applications now to test this
13:37 - application we need a testing framework
13:39 - as I told you in my JavaScript testing
13:41 - course there are many testing Frameworks
13:43 - out there like Gest mocha Jasmine vest
13:47 - and so on just is probably the most
13:50 - popular testing framework but the
13:52 - problem with justest is that its support
13:54 - for Eos script modules or native
13:56 - JavaScript modules is still experimental
13:59 - so setting things up is a little bit
14:01 - awkward so in this course we'll be using
14:03 - Vest which is a relatively new testing
14:06 - framework built for testing modern
14:08 - JavaScript applications so it has
14:10 - built-in support for ecmascript modules
14:13 - as well as typescript and jsx so back to
14:16 - our project on the top let's go to view
14:20 - and then terminal look at the shortcut
14:22 - it's control and back tick so now we
14:25 - have a terminal window pointing to our
14:27 - project directory let's install vest as
14:31 - a development
14:33 - dependency all right good now we need to
14:36 - create a test script in our package.json
14:38 - file so on the top Under The Go menu
14:42 - look at the shortcut for going to a file
14:45 - on Mac it's command and P on Windows is
14:47 - probably control and P so now let's go
14:50 - to our package.json
14:53 - file here in the scripts object we need
14:55 - to add a new script let's call a test
14:59 - and set it to v test now I would prefer
15:02 - to create another script for running
15:04 - tests using the vest UI so let's call
15:07 - this test colon UI and set it to vest
15:12 - with the UI option now let's create a
15:15 - basic test to make sure that our setup
15:17 - is done properly so back to our
15:21 - project here in the root directory we
15:23 - add a new folder let's call that test
15:27 - here we add a new file let's call it
15:31 - main.
15:33 - test.ts now here on the extensions panel
15:36 - I want you to search for vest we have
15:39 - this very useful extension called vest
15:42 - Snippets it's from this developer Dean
15:45 - software with this extension installed
15:48 - here we can import the essential
15:50 - functions from vest by typing IV that is
15:53 - short for import v test so now we have
15:56 - it expect and describe from V Test Now
16:00 - to create a test Suite we type D
16:02 - followed by enter the name doesn't
16:05 - matter let's press tab Now to create a
16:07 - test case we type I followed by enter
16:11 - now I don't know why I have two
16:12 - instances in the autoc completion box
16:15 - the one we need is the one with this
16:17 - Square icon that is a code snippet so
16:21 - let's select that now let's write a
16:23 - basic assertion and say expect one to be
16:27 - truy now let's go back to the terminal
16:29 - window and run npm test or npm to run
16:33 - tests in the terminal all right our test
16:35 - passed beautiful now let's quate and run
16:38 - test using Vest UI so npm run test
16:42 - coland
16:43 - UI now the first time it's asking if you
16:46 - want to install vest UI let's select
16:50 - yes all right good now we need to run
16:53 - this command one more
16:55 - time all right here's v test UI
16:58 - throughout the course we're going to use
17:00 - this interface to run our tests because
17:02 - it's much easier to see what's happening
17:04 - as opposed to running tests in the
17:06 - terminal window now I don't like the
17:08 - light mode so let's change it to dark
17:10 - that's easier on the eyes so we have one
17:12 - passing test beautiful we're done with
17:14 - setting up v test next we're going to
17:16 - set up react testing
17:20 - [Music]
17:23 - library to test react components we need
17:26 - a few tools the first one is react
17:28 - testing Library which allows us to
17:31 - render our components and interact with
17:33 - them just like the end user so let's go
17:36 - back to the terminal and install react
17:39 - testing Library as a development
17:41 - dependency so at testing D Library SL
17:46 - react and the version I'm going to
17:48 - install is
17:58 - all right good now the next Library we
18:01 - need is jsd what is this well by default
18:04 - our tests are executed in a node
18:07 - environment but node doesn't know
18:09 - anything about browser apis like the Dom
18:11 - so to test our react components we need
18:13 - to run our tests within an environment
18:16 - that emulates a browser environment we
18:19 - have a couple of options here we have
18:20 - jsd and Happy D which is faster but
18:24 - lacks some apis so we're going to start
18:26 - with JS Dom but later we can switch to
18:29 - happy to optimize our tests so back in
18:32 - the terminal let's install JS Dom as a
18:35 - development
18:36 - dependency and the version I'm going to
18:38 - install is
18:40 - 24.0
18:42 - point0 now we need to create a
18:44 - configuration file for vest to tell it
18:46 - to use jsdom as the testing environment
18:50 - so back to our project here in the root
18:52 - directory let's add a new file called
18:57 - vest.com config TTS make sure you create
19:01 - this file in the root okay now here on
19:03 - the top first we
19:06 - import Define
19:09 - config from vest SLC
19:13 - config next we call this function and
19:16 - give it an object here we set test to an
19:19 - object and set environment to JS D now
19:25 - this returns a configuration object so
19:27 - we export it as a default object from
19:30 - this module now whenever we change vest
19:33 - configuration we have to restart vest so
19:36 - back to our terminal window where we are
19:38 - running vest UI let's press Q to quit
19:42 - and rerun npm run test
19:47 - UI all right good now the last Library
19:50 - we need is testing Library slj Dum this
19:54 - Library gives us a bunch of matchers for
19:57 - writing assertions that against the Dom
19:59 - for example we can check to see if an
20:01 - element is in the Dom if it has the
20:03 - right content and so on so back in the
20:05 - terminal let's install one more library
20:08 - and that is at testing Library slj
20:18 - ddom welcome back to the complete react
20:21 - testing course in this section we're
20:23 - going to dive deep into the world of
20:25 - testing react components we'll kick
20:27 - things up off by understanding what to
20:29 - test and what not to test when it comes
20:32 - to testing components we'll then jump
20:34 - right in and explore testing rendering
20:36 - and user interactions we'll also look at
20:39 - a few techniques you need to know to
20:41 - test components that use component
20:43 - libraries like radex UI material UI and
20:46 - so on throughout this section I will
20:48 - also show you a few techniques to
20:50 - simplify your tests and make them more
20:52 - maintainable and finally we'll wrap up
20:55 - this section by talking about using ES
20:57 - length to catch common issues in the
20:59 - code this is a foundational section in
21:01 - the course so make sure to watch every
21:04 - lesson and complete every exercise with
21:07 - that now let's jump in and get
21:12 - [Music]
21:18 - started okay before we dive into writing
21:21 - tests let's take a moment and talk about
21:23 - what exactly we should be testing and
21:25 - perhaps more importantly what we can
21:27 - skip testing when it comes to testing
21:30 - react components there are two major
21:32 - concerns we need to test how they render
21:35 - and how they respond to user actions for
21:37 - rendering we should verify that our
21:40 - components render correctly under
21:42 - various conditions if a component has
21:44 - props we should pass different props and
21:47 - verify that it renders correctly if our
21:50 - component handles user events like
21:52 - clicks keyboard inputs or anything
21:54 - similar we should simulate those and
21:56 - check if it reacts the way we expect now
21:59 - in my JavaScript testing course we
22:01 - talked about the importance of creating
22:04 - tests that are maintainable robust and
22:07 - trustworthy I mentioned that having no
22:09 - tests is better than writing bad tests
22:12 - because poorly written tests can get in
22:14 - the way and slow us down now one of the
22:17 - best practices I touched on was testing
22:19 - the behavior and not the implementation
22:22 - in simple words that means we should
22:24 - test what our application does not how
22:27 - it's implemented
22:28 - as an analogy think of testing at TV we
22:31 - use the remote Press buttons and watch
22:34 - what happens we don't care what's inside
22:36 - the TV right similarly when testing a
22:39 - component we should test what it does
22:41 - not how it's implemented if our
22:44 - component uses hooks or react context or
22:46 - reducers these are all implementation
22:49 - details we should not write tests
22:51 - against those details because if the
22:53 - implementation details change in the
22:54 - future our tests may break even if our
22:57 - application still works fine so for the
23:00 - most part we shouldn't test building
23:02 - blocks like Hooks and reducers in
23:04 - isolation unless they're used by several
23:07 - components and have complex logic in
23:10 - those cases yes it makes sense to unit
23:13 - test those pieces in isolation but for
23:15 - the most part we should test them as
23:17 - part of testing our components which is
23:19 - what we call integration testing now you
23:22 - have probably seen this test pyramid
23:24 - before the test pyramid suggests that we
23:27 - should write more more unit tests than
23:29 - integration tests and more integration
23:31 - tests than endtoend tests this is just a
23:34 - guide not a strict rule so when testing
23:37 - react applications we often lean towards
23:39 - integration tests our tests might be
23:41 - slower than unit tests because we'll be
23:44 - testing several units together but they
23:46 - give us better confidence that our
23:48 - application works plus our tests are
23:51 - less likely to break if we refactor some
23:53 - code as long as the end result stays the
23:56 - same the other thing you should avoid is
23:58 - testing Styles why well visual tests can
24:02 - be fragile a tinier style change like
24:04 - changing the font size or color can fail
24:07 - a test and honestly passing visual tests
24:10 - don't guarantee that our application
24:12 - looks good that's a job for our own eyes
24:15 - so instead of wasting our time testing
24:18 - Styles we should test our application's
24:20 - behavior and functionality that's where
24:23 - the real value is All Right theory time
24:25 - is over let's dive into some real
24:27 - examples of component testing as we move
24:34 - forward all right let's write our first
24:36 - test here in the source folder inside
24:40 - the components folder we have a
24:42 - component called GRE a very simple
24:45 - component with a name prop of type
24:47 - string if we provide the name our
24:49 - component renders a heading otherwise it
24:51 - renders a login button so here we need
24:54 - two test cases in one test case we
24:56 - provide a name and and assert that we
24:58 - have a heading with this content in the
25:00 - Dom in the other test case we don't
25:02 - provide a name and assert that we have a
25:04 - login button in the Dom so back to our
25:08 - project we go to our tests folder and
25:11 - create a new folder here called
25:14 - components now in terms of test
25:16 - organization there are two schools of
25:18 - thought Some people prefer to have all
25:21 - their tests inside the tests folder
25:24 - other people prefer to have their tests
25:26 - next to their components there is really
25:28 - no right or wrong here but most of the
25:30 - community prefer to have their tests
25:32 - inside the tests folder this also makes
25:35 - things a little bit easier when working
25:36 - with continuous integration and
25:38 - deployment tools so in this course we're
25:41 - going to put all our tests inside the
25:43 - tests folder now here we have a folder
25:46 - for our components so all our component
25:48 - tests are in a single place now we
25:50 - create a new file called greet
25:54 - test.ts now note that here we are using
25:56 - capital G because that's how we name
25:58 - files that have react
26:00 - components now in this file first we
26:03 - have to import the essential functions
26:04 - from vest so
26:06 - IV then we create a test suite for the
26:10 - greed
26:12 - component here's our first test case it
26:15 - should render hello with the name when
26:19 - name is
26:22 - provided now here first we have to
26:24 - render our greed component to do that
26:28 - we have to import the render function
26:31 - from react testing Library so at testing
26:34 - Library SL
26:36 - react so we call
26:39 - render now here we need to pass our
26:41 - greed component now because we're going
26:43 - to write some jsx expression here we
26:46 - have to rename our file from TS to TSX
26:50 - so let's rename our file to
26:52 - TSX good now here we can render our comp
26:57 - component our greet
27:00 - component now in this case vs code Auto
27:02 - imported this for me on the top if your
27:04 - editor doesn't do it make sure to import
27:07 - greet from the right
27:08 - location so we render greet and set the
27:11 - name prop to let's say
27:14 - mosh so this render function renders our
27:18 - component into a virtual Dom that is
27:20 - implemented by JS Dom the library we
27:23 - installed in the first section okay now
27:25 - to see the state of the Dom we can use
27:27 - the screen object so on this line we
27:31 - also import the screen object now after
27:35 - we render our component we call screen.
27:38 - debug now back to v test UI in the
27:41 - browser let's look at our GRE test here
27:44 - on the console tab look this is the
27:47 - state of our virtual do we have body div
27:50 - and our heading now to complete our test
27:53 - we have to find this heading in the Dom
27:55 - and make an assertion against it to to
27:57 - do that we have to use one of the query
27:59 - methods in react testing Library if you
28:02 - search for react testing Library queries
28:05 - you will find this
28:06 - page here we have a bunch of query
28:09 - methods like by Roll by label text by
28:12 - placeholder text and so on most of the
28:14 - time we prefer to use by roll because
28:17 - this makes our tests more robust and
28:19 - less prone to Breaking changes when we
28:21 - change the UI for example if we change
28:24 - some text or class names of our elements
28:27 - a test using this query method is less
28:29 - likely to fail compared to one that
28:31 - relies on text or class selectors okay
28:34 - also this query method encourages us to
28:37 - interact with our components just like
28:39 - the end user focusing on accessibility
28:42 - features so back to our code here we
28:45 - call screen get by
28:48 - roll now here we have a bunch of
28:50 - standard roles like alert article banner
28:53 - and so on here we want to select an
28:55 - element with the role of heading this
28:57 - returns any kind of heading like H1 H2
29:00 - and so on now we store it in an
29:03 - object and finally we need to write our
29:06 - assertions so just like unit testing
29:08 - JavaScript code we start with expect we
29:11 - pass our heading object now here we need
29:14 - to use one of the matchers that comes
29:17 - with testing Library so on the top we
29:21 - import at testing Library slj Dom
29:29 - slvest now if you're using just you have
29:31 - to modify your import statement in this
29:33 - package we have a bunch of custom
29:35 - matchers you can find them all by
29:37 - searching testing Library just
29:42 - Dom on this GitHub page you can find all
29:45 - these custom matchers like to be
29:47 - disabled to be enabled to be in the
29:50 - document and so on you don't have to
29:52 - memorize any of these as we go through
29:53 - the course as we work on more exercises
29:56 - you will gradually get familiar with
29:58 - these matches okay so back to our code
30:01 - now let's finish our assertion so we
30:03 - expect heading to be in the
30:06 - document okay back to v test UI we have
30:10 - one passing test beautiful now in my
30:12 - JavaScript testing course I emphasize
30:14 - the importance of testing the correct
30:16 - Behavior so to prevent false positives
30:19 - or tests that always pass we can go to
30:22 - our production code make a tiny change
30:24 - and see if our test fails or not so
30:26 - let's go back to our greed
30:28 - component we can comment out the line of
30:31 - code that should make our test pass now
30:34 - if our test fails it means that we're
30:36 - testing the correct Behavior now look
30:39 - our test failed good we can look at the
30:42 - report tab to see what's happening down
30:44 - here you can see the state of the Dom so
30:47 - we have the login button but we were
30:48 - searching for a heading so back to our
30:51 - great component let's bring this back
30:54 - good now we can write a second assertion
30:56 - and Ensure that our heading has the
30:58 - right content so we expect heading to
31:03 - have text content this is another custom
31:06 - matcher that comes with testing
31:09 - library now here we can pass a string or
31:12 - a regular expression it's often better
31:15 - to use a regular expression to make our
31:17 - tests more robust so here we pass a
31:20 - regular expression and search for Hello
31:23 - mosh and we want to make this case
31:26 - insensitive
31:27 - now if in the future we replace hello
31:29 - with hi or good morning or whatever our
31:32 - test is going to break so we don't want
31:33 - to be over specific here we want to make
31:36 - our assertions a little bit looser or
31:38 - more General okay now again our test is
31:42 - passing great so we're done with our
31:44 - first test case now let's repeat and
31:47 - create a second test case to save time
31:49 - I'm going to duplicate this test
31:52 - case and change the test name should
31:56 - render login button when name is not
32:02 - provided now if you remove the name prop
32:06 - we get a compilation error saying
32:08 - property name is missing because our
32:10 - grid component always expects a name so
32:14 - here we have to pass an mty string but
32:17 - this looks a little bit ugly so to make
32:19 - our component more flexible we can make
32:22 - the name prop optional so right here we
32:25 - add a question mark
32:27 - and now we don't have to supply the name
32:30 - prop all right good now in this test
32:33 - case we get an element by the rule of
32:38 - button let's change the name of this
32:40 - constant to button first we expect our
32:43 - button to be in the document and then we
32:46 - assert that it should have the right
32:48 - content in this case login now look we
32:52 - have two passing tests great once again
32:55 - to verify that we are testing the
32:57 - correct Behavior we go to our production
33:00 - code and comment out the line of code
33:02 - that should make our last test
33:05 - pass now our test failed so that means
33:07 - we're testing the correct Behavior so
33:09 - let's bring it
33:16 - back all right you have learned how to
33:18 - write basic tests using react testing
33:20 - library now there is a problem with our
33:23 - setup every time we want to create a
33:25 - test file we have to add these import
33:27 - statements on the top this is repetitive
33:30 - and conversome so in this lesson I'm
33:32 - going to show you a few techniques for
33:34 - simplifying our test setup first we
33:37 - don't have to import these functions
33:39 - from vest in every single test file we
33:42 - can go to our vest configuration file
33:44 - and turn on globals so let's go to vest.
33:55 - config.sys
33:57 - the first import statement now here we
34:00 - get a bunch of compilation errors from
34:02 - the typescript compiler for example the
34:05 - typescript compiler is complaining that
34:07 - it cannot find name describe to fix this
34:10 - issue we have to go to our typescript
34:12 - configuration file which is
34:15 - tsconfig
34:16 - Json here in the compiler options object
34:19 - we add a new property called types we
34:23 - set it to an array and here we pass V
34:26 - test/
34:28 - globals now the error should go away
34:32 - there you go if this doesn't happen on
34:34 - your machine bring up the command pallet
34:36 - and search for typescript reload project
34:40 - okay so that was the first Improvement
34:43 - now the second Improvement again we
34:45 - don't want to import this module in
34:48 - every test file to get access to these
34:51 - custom matchers so let's go to our tests
34:55 - folder here we add a new file called
34:58 - setup
35:00 - TTS Now we move this line from our test
35:03 - file into our setup
35:06 - file next we go to our vest
35:08 - configuration
35:09 - file and reference our setup file so
35:13 - here we set setup files to tests SLS
35:18 - setup. TS this setup file is run before
35:22 - each test file it's useful for
35:24 - configuring our testing environment okay
35:27 - now because we have changed our vest
35:29 - configuration file we have to go back to
35:31 - the terminal stop this process and run
35:35 - our tests
35:36 - again all right all our tests are
35:39 - passing great now back to our test file
35:42 - the last Improvement I want to show you
35:43 - here is that we don't have to type
35:46 - import render and screen from testing
35:48 - Library every single time there is a
35:51 - shortcut for this here in the extensions
35:53 - panel search for testing Library snippet
35:57 - we have this extension from Dean
35:59 - software let's install
36:03 - this all right now back to our test
36:06 - file instead of manually typing this
36:08 - every single time we can type ITR and
36:12 - press enter as simple as
36:20 - that okay here's a great exercise for
36:22 - you to practice what you have learned so
36:24 - far in our components folder we have
36:26 - have a component called user account
36:29 - this component has a prop called user of
36:32 - type user let's take a look at this type
36:36 - here we have three properties ID name
36:38 - and is admin now this component renders
36:42 - the users's name and an edit button if
36:45 - the user is an admin so I want you to
36:48 - spend 10 to 15 minutes and write all the
36:51 - test cases for this component to give
36:53 - you a hint here we need three test cases
36:55 - in one test case case we assert that the
36:58 - user's name is rendered in the Dom now
37:01 - to write this assertion you cannot use
37:03 - the get by roll method because look the
37:05 - name is rendered inside a div and divs
37:08 - don't have a role by default unless we
37:11 - give them a role but this is unnecessary
37:14 - so in this test case you have to use a
37:17 - different query method that is called
37:19 - get by text okay now we need two test
37:23 - cases for the edit button in one test
37:26 - case we pass an admin user to this
37:28 - component and assert that the edit
37:30 - button is rendered in the other test
37:32 - case we pass a non-admin user and assert
37:36 - that the edit button is not in the Dom
37:39 - now in this test case again you cannot
37:41 - use the get by roll method because get
37:44 - by roll will throw an error if the
37:46 - element you're looking for doesn't exist
37:48 - in the Dom so in that test case you have
37:51 - to use a different method called query
37:54 - by row so you you look for a button
37:57 - using this method and then as part of
38:00 - writing your assertion you have to use
38:03 - the not property to make sure that that
38:06 - element is not in the
38:10 - document okay so spend 10 to 15 minutes
38:13 - on this and then come back and see my
38:19 - solution all right so we go to our test
38:21 - folder inside the components folder we
38:24 - add a new file called user account.
38:27 - test.
38:29 - TSX first we import screen and render
38:33 - from react testing Library good then we
38:36 - create a test Suite called user account
38:40 - now I'm going to go faster because I'm
38:42 - assuming you have done your exercise
38:43 - okay now here's our first test case it
38:46 - should render user
38:48 - name here first we create a user object
38:52 - we annotate it with its type now here we
38:55 - have two user types types one is defined
38:57 - in all zero the other is defined in the
39:00 - end of this module in this project we're
39:03 - going to pick this one now let's create
39:05 - a user object we set the ID and name to
39:09 - some arbitrary
39:11 - values next we render the user account
39:16 - component and give it this user
39:20 - object now our assertion so here we call
39:24 - screen. get by 10 next and pass
39:28 - user.name now this returns an element
39:31 - but we don't need to store it in a
39:32 - constant because we're going to use it
39:34 - only once so we can pass it directly to
39:37 - the expect function and assert that this
39:41 - element is in the
39:43 - document now look we have one passing
39:45 - test great now once again to verify that
39:48 - we're testing the correct Behavior we go
39:51 - to our production code and comment out
39:55 - the line that that should make that test
39:57 - pass so now our test should fail there
40:00 - you go we're testing the correct
40:02 - Behavior now going forward I'm not going
40:04 - to repeat this over and over because
40:06 - that's repetitive but I want you to
40:08 - practice this as part of writing your
40:10 - tests okay so let's bring this back we
40:14 - are done with our first test case now
40:17 - let's duplicate this and write the test
40:21 - for the edit button so here we say it
40:24 - should render edit button if user is
40:29 - admin here we set is admin to
40:33 - true now our assertion is going to be
40:35 - different so here we call screen. get by
40:39 - roll we look for a button we store it in
40:43 - a constant because we're going to write
40:45 - two assertions against this object first
40:48 - we expect our button to be in the
40:52 - document and then we assert that it has
40:56 - the right write label so to have text
40:59 - content and again here we use a regular
41:02 - expression all right good take a look
41:05 - two passing tests lovely now the final
41:08 - test case so let's duplicate this
41:14 - test first we change the test name to
41:17 - should not render edit button if user is
41:22 - not admin we can set this to false or
41:25 - remove this
41:26 - property now in this test we cannot use
41:29 - get by roll because this will throw an
41:31 - error because we're not going to have a
41:33 - button in the Dom so here we call query
41:37 - by
41:38 - roll we get the button and then expect
41:41 - this button not to be in the document
41:45 - okay let's remove this other assertion
41:47 - good now take a look we have three
41:50 - passing
41:52 - tests well hello msh here thank you for
41:55 - watching my react testing tutorial I
41:57 - wanted to let you know that this
41:58 - tutorial is the first hour of my
42:01 - complete react testing course so after
42:03 - you finish this tutorial if you want to
42:05 - learn more I highly recommend you to
42:07 - enroll in the full course because it's
42:10 - much faster and easier to learn react
42:12 - testing than jumping over a bunch of
42:14 - disconnected tutorials on YouTube
42:17 - everything you need to know is
42:18 - jam-packed in a perfectly structured
42:20 - 7-hour course will cover more advanced
42:23 - topics like marking apis testing forms
42:26 - testing State Management authentication
42:28 - and routing now just like my other
42:30 - courses this course comes with a 30-day
42:33 - moneyb guarantee and a certificate of
42:36 - completion if you're interested click
42:38 - the link below this video to enroll in
42:40 - the
42:42 - [Music]
42:45 - course all right now let's look at an
42:47 - example involving lists in our
42:49 - components folder we have a component
42:51 - called user list this component takes a
42:54 - prop called users which is an array of
42:57 - users if the array is empty it renders
43:00 - no users available otherwise it renders
43:03 - a list of hyperlinks one for each user
43:06 - okay so let's test this we go back to
43:09 - our test
43:11 - folder in the components folder we add a
43:14 - new file called user list. test.
43:19 - TSX let's do the
43:21 - ceremony we create a test Suite called
43:25 - user list
43:26 - and here's our first test casee it
43:28 - should render no users when the users
43:33 - array is empty and of course we can word
43:36 - it differently so here we call
43:39 - render and give it user
43:42 - list with an empty
43:46 - array okay now to write our
43:50 - assertion look this message is rendered
43:53 - inside a paragraph and paragraphs don't
43:55 - have a rooll by default so once again we
43:58 - have to use the get by text method so
44:02 - here we call screen that get by
44:06 - text now we don't want to look for the
44:08 - exact message like no users is available
44:11 - because this makes our test fragile if
44:14 - one of the words here changes our test
44:16 - will break so we use a regular
44:18 - expression to look for the presence of
44:21 - certain keywords I think the chances of
44:24 - no users keyword
44:26 - changing in the future is probably
44:29 - minimal we not sure but I think this
44:31 - makes our assertion a little bit more
44:33 - General and our test will be a little
44:35 - bit more robust okay so we find this
44:38 - element and expect it to be in the
44:41 - document and by the way look when you
44:44 - want to find a method you don't have to
44:45 - type the whole method name that's very
44:48 - time consuming instead we can use
44:50 - abbreviations like to be in the document
44:54 - okay so that was our first test now take
44:58 - a look user list we have one passing
45:00 - test grade now our second test this test
45:03 - is more interesting so I'm going to
45:07 - duplicate this
45:08 - test and here we change the test name to
45:12 - should
45:14 - render a list of
45:17 - users now in this test first we create
45:20 - an array of users so we annotate this
45:23 - with user array and again make sure to
45:25 - pick the type in the entities
45:28 - module okay now let's initialize this
45:32 - array with two objects we set the idea
45:36 - name msh and one
45:39 - more let's call this user
45:43 - John so we passed the users array
45:48 - here now how can we verify that we have
45:51 - the right hyperlink for each user well
45:54 - here we can iterate over our array of
45:57 - users and for each user we can look for
45:59 - a link with the user's name and then we
46:02 - can verify that that link has the right
46:04 - HF attribute here's how we're going to
46:07 - do it
46:08 - so here we call users. for each we
46:13 - iterate over this array for each
46:16 - user we find a link with the user's name
46:19 - so we call screen. get by
46:22 - roll we look for a link now all these
46:26 - query methods have a second argument
46:29 - which is optional and this is the
46:30 - options object you can find the details
46:33 - in the documentation so take a look
46:36 - here's get by roll now this is the
46:39 - options object here we have a bunch of
46:41 - properties like name for using a text
46:44 - match we have selected for applying a
46:46 - filter and picking elements that are
46:48 - selected we also have checked pressed
46:51 - and a bunch of other properties I'm not
46:53 - familiar with all of them but you will
46:54 - learn about them depending on the types
46:56 - of test you write okay so here we can
46:59 - pass the options object and apply a
47:03 - filter we only want to find a link with
47:06 - this name user.name
47:09 - now this returns a
47:12 - link first we check if
47:15 - link is in the
47:17 - document and then we check that it has
47:20 - the right href attribute so we expect
47:24 - link now here here is another matcher to
47:27 - have
47:28 - attribute we look for
47:30 - hre and we want this to be like slash
47:33 - users well let's look at our production
47:36 - code here's what we expect SL users
47:40 - user. ID now I need to clarify something
47:43 - here in this case technically I cheated
47:45 - we shouldn't write our tests based on
47:47 - our production code because our
47:49 - production code might have a bug if we
47:51 - write our assertions based on what we
47:53 - have in the production code we'll end up
47:55 - with far false positives our tests will
47:57 - pass but our application will have a
47:59 - book so ideally we should write our
48:01 - tests based on the requirements in other
48:03 - words we should treat each component
48:05 - like a black box we shouldn't care what
48:08 - is inside we shouldn't care about the
48:09 - implementation we should test what it's
48:12 - supposed to do okay now back to our test
48:15 - so here we want to look for an HF like/
48:19 - users slash now we want to add the ID
48:21 - dynamically so let's replace this string
48:24 - literal with a template literal and here
48:27 - we can insert user.
48:31 - ID take a look our test are passing
48:34 - great now I want to verify that we're
48:36 - testing the correct Behavior so for the
48:38 - last time let's comment out this line
48:42 - now our test fails
48:47 - [Music]
48:50 - great all right here's another great
48:52 - exercise for you in the components
48:54 - folder we have we have this component
48:56 - called product image gallery this
48:59 - component receives a list of image URLs
49:02 - as a string array now if the array is
49:04 - empty our component renders nothing
49:07 - otherwise it renders a list of images so
49:10 - here we need two test cases in the first
49:13 - test case we should render this
49:14 - component with an empty array and then
49:17 - assert that the Dom is empty now we
49:19 - haven't done this so far so I want you
49:21 - to do a bit of research and solve this
49:23 - problem on your own it's not complicated
49:25 - it just search for react testing Library
49:28 - assert that the Dom is empty now in the
49:31 - second test case we should render this
49:33 - component with a list of URLs and then
49:35 - assert that we have a list of images
49:38 - with the right Source attribute rendered
49:40 - in the do spend 10 minutes on this then
49:43 - come back and see my
49:48 - solution all right to save your time I
49:51 - created this test file with the basic
49:53 - setup before recording this video so
49:55 - here's our first test case our component
49:58 - should render nothing if given an empty
50:02 - array so here we call render and give it
50:07 - product image
50:09 - gallery here we set image URLs to an
50:11 - empty array now to assert that the Dom
50:14 - is empty we get the object that is
50:16 - returned from this function we can call
50:18 - it result now look result has a bunch of
50:21 - properties one of them is container this
50:24 - is the container for component so here
50:27 - we can destructure this object and grab
50:30 - the container then we pass it to the
50:33 - expect function and here we call to be
50:37 - empty Dom element as simple as that now
50:41 - take a look our test is passing great
50:44 - now let's work on the second test
50:47 - case it should render a list of
50:52 - images now in this test first we deare
50:55 - an AR array of URLs let's call it image
50:58 - URLs we set it to two
51:00 - elements URL 1 and
51:03 - two then we
51:05 - render product image
51:07 - gallery here we set image URLs to image
51:11 - URLs good now in this test unlike the
51:14 - previous lesson we cannot iterate over
51:17 - this array and for each element assert
51:19 - that we have an element with this URL
51:23 - because in the previous lesson we were
51:24 - applying a filter by name but here we
51:27 - cannot filter Elements by their Source
51:29 - attribute so here we have to take a
51:31 - different approach first we call screen.
51:35 - get all by row so all query methods that
51:39 - you have seen before they have a
51:41 - variation for selecting multiple
51:42 - elements so we have get by role we also
51:46 - have get all by ro similarly we have get
51:49 - by text we have get all by text and so
51:51 - on so let's call get all by roll
51:55 - for selecting multiple images the role
51:59 - we should pass is IMG with this we can
52:01 - get all the images in the Dom first we
52:05 - should assert that we have two images so
52:08 - we expect images to have
52:12 - length two then for each element in this
52:16 - array we assert that we have an image
52:18 - with the right Source attribute for
52:21 - example we can say expect images of zero
52:25 - to have
52:27 - attribute source and here we should pass
52:31 - image URLs of zero and of course we have
52:34 - to repeat this for the second element
52:36 - but that looks a little bit ugly so here
52:38 - we can iterate over image
52:42 - URLs using for each we pass an arrow
52:45 - function here with two
52:47 - parameters URL and
52:50 - index Now we move this assertion up here
52:54 - and we check that
52:55 - the element at this index have this
52:59 - attribute that is the URL that we get in
53:02 - this function now take a look our tests
53:05 - are
53:09 - [Music]
53:12 - passing all right now let's see how we
53:14 - can test user interactions here we have
53:16 - a component called terms and conditions
53:20 - a very typical implementation where we
53:22 - have our terms and conditions followed
53:25 - by
53:25 - a checkbox for the user to accept the
53:27 - terms and a button that is only enabled
53:31 - if the checkbox is checked now before we
53:33 - write tests for this component let's see
53:35 - it in action so let's go to this file
53:38 - called playground page it's inside the
53:41 - pages
53:42 - folder now here we're rendering the
53:44 - onboarding component we don't need it
53:46 - for now we'll come back to it in the
53:47 - future so instead let's render terms and
53:52 - conditions now back to our website
53:55 - let's go to the playground page here's
53:57 - our component now the button should be
54:00 - initially disabled but we don't see it
54:02 - visually because I forgot to apply a
54:04 - style here so to fix this let's go to
54:08 - index.css
54:10 - here's our button class let's add
54:13 - another button class with a disabled
54:17 - selector here we set the background to
54:20 - CCC now look our button is initially
54:23 - disabled but if if we check the check
54:25 - box it becomes enabled this is the
54:28 - behavior we're going to test in this
54:30 - lesson so back to our project let's go
54:34 - to the tests folder here we add a new
54:37 - file call terms and conditions. test.
54:43 - TSX we do the setup
54:46 - first then we create a test
54:49 - Suite terms and conditions now in our
54:53 - first test we want to make sure that
54:55 - that our component renders correctly so
54:57 - nothing new so far we just want to test
54:59 - the rendering of this component so here
55:02 - we can say it should render with correct
55:06 - text and initial state so we call render
55:10 - and past terms and
55:16 - conditions now here we have some basic
55:18 - text we don't want to look for the
55:19 - presence of this text because this can
55:21 - easily change in the future the only
55:23 - thing we want to look for in terms of
55:24 - text next is our heading so back to our
55:27 - test here we call screen. get by roll
55:31 - look what I'm typing gbr that is short
55:33 - for get by roll okay so we find a
55:38 - heading we store it in this object first
55:42 - we check that this heading is in the
55:44 - document so to be in the
55:48 - document and then we check that it has
55:51 - the right content to have text content
55:56 - now in this case we can pass a string we
55:58 - don't have to use a regular expression
56:00 - because the chances of this heading
56:03 - changing in the future is really minimal
56:05 - okay so that was our text now what about
56:09 - the initial State well we need to verify
56:11 - that we have an unchecked check boox in
56:14 - the dot so we call screen get by roll
56:18 - check
56:19 - box we store it in this
56:23 - object now just like before before we
56:25 - expect
56:27 - checkbox to be in the
56:31 - document and it should also be unchecked
56:34 - how do we do that well we have a matcher
56:37 - here called to be checked okay now we
56:41 - don't have a match called to be
56:43 - unchecked so to verify that our checkbox
56:46 - is unchecked here we use the not
56:49 - property okay now one question you might
56:52 - have here is isn't that better to split
56:55 - these assertions into two tests one
56:57 - testing the heading the other testing
56:59 - the checkbox we can certainly do that
57:01 - but in this case I don't find any value
57:03 - in doing so because look we have to
57:05 - repeat this test case two more times and
57:08 - in each test case we have to render the
57:10 - component it's a little bit repetitive
57:12 - so I prefer to have all these assertions
57:15 - regarding rendering in this test case
57:17 - but don't take it as a hard and fast
57:19 - rule every problem every component every
57:21 - test case is different so we check the
57:24 - check box and finally we verify that we
57:27 - have a disabled button so we call screen
57:32 - get by roll button now if you have
57:35 - multiple buttons here we can apply a
57:37 - filter and look for the button that has
57:40 - what was the label that is submit okay
57:45 - so here we can pass a regular expression
57:48 - to filter our buttons in this case we
57:51 - don't need that so let's simplify our
57:53 - test so we get our
57:55 - button first we check that the button is
58:00 - in the Dom or in the
58:03 - document then we check that our
58:06 - button has the right label to have text
58:10 - content
58:12 - submit and finally we assert that our
58:16 - button is disabled so expect
58:19 - button to be
58:21 - disabled now it is possible that in the
58:24 - future F this label gets changed to
58:26 - something else like continue so in this
58:29 - case I prefer to remove this assertion
58:32 - what we want to focus on is the behavior
58:34 - or the functionality of this component
58:36 - that the button is only enabled when the
58:38 - checkbox is checked testing this
58:40 - behavior is more important and more
58:42 - valuable than testing the content on our
58:45 - web pages okay so that was our first
58:48 - test now look our test is passing great
58:51 - so let's see how we can test user
58:53 - interactions
58:56 - so let's create a second test case and
58:58 - say should enable the button when the
59:03 - checkbox is
59:06 - checked now once again we render our
59:11 - component now to simulate user
59:14 - interactions we have to use a different
59:16 - Library called user event back to the
59:19 - documentation of testing library look
59:22 - here we have this section called user
59:25 - interactions we have this companion
59:27 - Library called user event we have to
59:30 - install this separately to simulate user
59:32 - events just note that in react testing
59:35 - Library we also have fire event a lot of
59:38 - people use this but it's not the best
59:40 - way to simulate user events because fire
59:43 - event as explained here is a lightweight
59:46 - wrapper around the browser's low-level
59:49 - dispatch event API so it doesn't
59:51 - simulate a real work scenario and that
59:53 - is why we have the the user event
59:55 - Library the way this Library dispatches
59:58 - events is similar to how users use our
60:01 - application okay now to install this we
60:04 - have to install testing Library sluser
60:07 - event as a development dependency so
60:10 - let's copy this line and paste it in the
60:14 - terminal good back to our test so first
60:17 - we render our component then we look up
60:21 - our checkbox so screen. get by roll
60:25 - checkbox just like before we store it
60:28 - here now to click this checkbox first we
60:32 - call user event this object is defined
60:35 - in testing Library SL user event so if
60:38 - your editor doesn't automatically import
60:41 - this make sure to import it like this on
60:44 - the top okay back to our test here we
60:47 - call user event. setup this returns an
60:50 - object we can call it
60:52 - user then we call user. click
60:57 - checkbox now look at the return type of
60:59 - this method it returns a promise so here
61:02 - we have to await this and make our test
61:06 - function
61:07 - async finally we make an assertion so we
61:11 - call screen get by roll we get our
61:14 - button and expect this button to be
61:20 - enabled now pay attention to how I've
61:23 - formatted this code so here we have the
61:26 - arrange part then we separate it with
61:29 - the line break from the ACT part and
61:32 - finally we have the assert part we don't
61:35 - need to add the comments just using a
61:36 - vertical line bre is enough to give
61:40 - other people how we have structured this
61:42 - test now back in vest UI both our tests
61:45 - are passing great now do we need another
61:48 - test case to assert that our button is
61:50 - disabled if the checkbox is unchecked I
61:53 - find it redundant because our first test
61:55 - case verifies that behavior there is no
61:58 - need to write a separate test case and
62:00 - click the checkbox twice to see if the
62:02 - button is
62:08 - disabled all right here's another
62:10 - fantastic exercise for you to practice
62:12 - unit testing look at this component
62:15 - expandable text our component receives a
62:18 - prop which is a text of type string that
62:21 - if the text is shorter than 250 five
62:24 - characters it gets rendered otherwise it
62:27 - gets truncated with a dot dot dot at the
62:30 - end and here we have a button for
62:32 - expanding or collapsing the text now
62:35 - before testing this let's see it in
62:37 - action so we go to our playground and
62:40 - render our expandable text component now
62:44 - let's set the text to a short
62:47 - text all right here's what we get the
62:49 - full text is rendered but if you pass a
62:52 - long string here which we can generate
62:54 - by typing lurm followed by a number a
62:57 - big number like 100 and tap that's a
63:00 - long lurm if some text now we can grab
63:03 - this and paste it here look what happens
63:08 - so our text is truncated and here we
63:10 - have the show more button ignore the
63:12 - styling I forgot to apply class we can
63:15 - fix it by applying the BTN class to our
63:19 - button so here we set class to well
63:22 - class name to BTN
63:25 - all right that's better now if we click
63:27 - this we see the full text and now we
63:29 - have show less this is a great exercise
63:32 - for you to practice what you have
63:33 - learned so far so spend 15 to 20 minutes
63:36 - on this and then come back and see my
63:42 - solution all right just like before we
63:44 - start with the rendering tests and then
63:47 - we'll move on to user interactions so
63:49 - what aspects do we want to test here for
63:51 - rendering we want to make sure that if
63:53 - the text is is short the full text is
63:55 - rendered otherwise our text is truncated
63:59 - these are the two aspects we need to
64:00 - test so here's our first test case
64:03 - should render the full text if less than
64:08 - 255 characters so here we call render
64:13 - and pass expandable
64:15 - text we set the text prop to some short
64:20 - text now to look this up in the Dom we
64:23 - use screen do get by text now let me
64:27 - show you a shortcut earlier in the
64:29 - course we installed an
64:31 - extension for react testing
64:35 - library in case you didn't do it it's
64:38 - right here testing Library Snippets from
64:41 - Dean software now with this we can
64:44 - generate this statement by typing QT
64:48 - that is query by text if we press enter
64:52 - now we have all query methods for for
64:54 - looking up an element by text so we have
64:56 - get by text get all by text query by
64:59 - text and so on now similarly we have
65:02 - query by role so
65:04 - QR but in this case we're going to go
65:06 - with QT okay so we're going to look up
65:09 - an element by this text now we don't
65:11 - want to repeat this
65:13 - here so let's put it in a
65:16 - constant short text and now we can reuse
65:20 - it in multiple
65:22 - places text and
65:25 - and
65:27 - text now we expect this element to be in
65:31 - the document another shortcut just type
65:33 - T bind that gives us to be in the
65:37 - document okay let's take a look all
65:40 - right we have one passing test great now
65:43 - let's write another test case for a long
65:46 - text so to save time I'm going to
65:49 - duplicate this
65:51 - test now let's change the test name
65:55 - should truncate text if longer than 255
66:01 - characters now to generate a long text
66:04 - we can grab a character like
66:06 - a and then repeat it let's say 256 times
66:11 - now in this test we have to look for the
66:14 - truncated text so let's declare a
66:17 - constant called truncated text we grab
66:21 - our text apply a substring and grab the
66:24 - first 255 characters and then we append
66:28 - dot dot dot at the end that is what we
66:30 - expect to have in the Dom so let's pass
66:34 - it to get by
66:37 - text take a look our test is passing
66:40 - great now in this scenario we also want
66:43 - to look for the presence of the show
66:45 - more button so to find our button we
66:47 - type
66:48 - QR get by roll and pass
66:51 - button restore it here
66:55 - first we expect the button to be in the
66:58 - document and
67:01 - then we verify that it has the right
67:04 - label so to have text
67:08 - content and here we use a regular
67:10 - expression and look for
67:12 - more now earlier I told you that get by
67:15 - roll throws an error if there is no
67:17 - element matching the criteria so
67:20 - technically speaking we don't even need
67:22 - to check if the button is in the
67:24 - document because if it doesn't exist
67:26 - this test is going to fail on this line
67:28 - anyway so in this case we can safely
67:30 - remove this line but if we didn't have
67:33 - another assertion after our test would
67:35 - look weird it would look unfinished so
67:38 - for clarity if we don't have other
67:40 - assertions I would prefer to check if
67:43 - the element is in the document okay we
67:45 - don't need it for now now let's take a
67:48 - look our test is passing great so these
67:50 - are the rendering tests now let's test
67:53 - the user interactions so again to save
67:57 - time I'm going to duplicate this test
67:59 - because we're dealing with a long text
68:02 - now there are two places where we are
68:04 - generating long text let's move these
68:07 - outside of our test cases into a single
68:09 - place so we can go to our test
68:13 - Suite first of all we can declare a
68:16 - constant called limit we set it to 255
68:19 - so if the requirements change in the
68:21 - future there is a single place in our
68:23 - tests we need to update now for
68:26 - generating a long text we can grab a and
68:30 - repeat it up to limit plus one now for
68:35 - generating the truncated text we declare
68:38 - a
68:39 - constant and here we get our long
68:42 - text and grab the first 255 characters
68:47 - in this case limit okay now we can
68:50 - simplify our tests a little bit so we we
68:53 - don't need to generate a long text
68:56 - here now we need to replace text with
69:00 - long
69:01 - text and we don't need to compute truned
69:04 - text either okay so always pay attention
69:07 - to these little details because they
69:08 - will always pay off in the long run okay
69:12 - now in our last test case well here we
69:15 - need to change the title
69:17 - to
69:19 - should expand text when show more button
69:24 - is clicked again we don't need to
69:27 - generate a long text
69:30 - here and similarly for the truncated
69:33 - text so we find our button then we need
69:36 - to click it so here we call user event
69:40 - do
69:40 - setup we get a user object and then we
69:44 - call user. click button I told you this
69:47 - returns a promise so we need to await it
69:50 - and make our test function async all
69:52 - right so this is the ACT part now we
69:54 - need to separate it from the assertion
69:56 - part so in this case we expect the full
69:59 - text to be in the document so we expect
70:03 - query by
70:04 - text and here we look for our long text
70:08 - to be in the
70:10 - document okay also the label of our
70:13 - button should be changed to show less
70:17 - now as I've said before there are some
70:19 - folks who are strict about a single
70:21 - assertion in the test but this is
70:23 - impractical call because imagine if we
70:25 - wanted to move this assertion into a
70:27 - separate test we would have to repeat
70:28 - all this logic in that test sure we can
70:31 - create another test suite and use before
70:33 - each but all that ceremony is
70:35 - unnecessary these two assertions are
70:37 - highly related they're logically part of
70:39 - a particular state of our component that
70:42 - is why I prefer to put them in the same
70:44 - test okay let's see if our test passes
70:48 - all right looks like one of our tests
70:49 - failed I made a mistake so what's
70:52 - happening here this this is the test for
70:54 - truncating
70:55 - text the aror is saying unable to find
70:58 - an element with the text whatever okay
71:02 - so let's take a look so in this test we
71:06 - are looking for the truncated text so
71:08 - the test is fine I probably made a
71:10 - mistake up here yes I forgot to add dot
71:14 - dot dot at the end sorry about that all
71:17 - right now all tests are passing great
71:19 - there's one more test we
71:21 - need so we have a test test for
71:24 - expanding the text now we need a test
71:26 - for collapsing the text so let's
71:29 - duplicate this
71:32 - test first we should change the test
71:35 - name to should collapse text when shows
71:41 - button is clicked now in this test in
71:44 - the arrange part first we have to click
71:46 - the show more button so the text is
71:48 - expanded so I'm going to remove this
71:50 - line brick this is our arrange part we
71:53 - click the button to expand the text now
71:56 - in the ACT part we click the button
72:01 - again and then assert that the long text
72:05 - is no longer in the document so we
72:06 - should look for truncated text and the
72:10 - show more button now take a look our
72:14 - tests are passing but I don't like the
72:16 - way I've written this test let me show
72:18 - you a better way first we're going to
72:20 - rename this button to show more
72:25 - button and for clarity here we can apply
72:27 - a
72:28 - filter we can set the name to
72:32 - more now it's clear that on this step
72:35 - we're clicking the show more button now
72:38 - in the ACT part we can call get by row
72:42 - to get a button and here we apply a
72:46 - filter as
72:47 - well this time we are looking for the
72:49 - shows button so we store it in a
72:52 - constant show less
72:55 - button and at this step we are clicking
72:58 - the show lless button even though it's
73:00 - technically the same button now our test
73:03 - code better aligns with the test
73:06 - description this is just a personal
73:08 - preference you don't have to do this now
73:10 - let's see if our tests are still passing
73:12 - there you go beautiful we're done with
73:13 - this exercise so let's move on to the
73:15 - next
73:21 - lesson okay let me show you a great
73:23 - technique for simplifying our tests
73:25 - let's take a look at the tests we wrote
73:28 - for the terms and conditions component
73:30 - now if you have paid close attention you
73:32 - have probably noticed that there are a
73:34 - few places where we are looking up our
73:37 - elements so here we are looking up our
73:39 - check boox and button and similarly in
73:42 - this other test we are looking up these
73:44 - elements this is duplication so let me
73:47 - show you a better way to write these
73:49 - tests back to our test Suite here we
73:52 - Define a helper function for rendering
73:55 - our component and returning the common
73:58 - elements we want to query so we can use
74:01 - the arrow function syntax or function
74:03 - declaration syntax it doesn't matter I'm
74:05 - going to go with the arrow function
74:07 - syntax so we declare a constant called
74:10 - render
74:11 - component we set it to an arrow function
74:15 - now in this function we render our
74:18 - component then we return an object and
74:22 - in this object we add
74:23 - the elements we want to query so look in
74:27 - this test we need the heading the
74:29 - checkbox and the button so here we add
74:31 - three properties heading and we set it
74:34 - to screen. get by roll heading similarly
74:40 - we add our
74:42 - checkbox let's grab the code from
74:46 - here and finally we add our
74:51 - button change it to button good now in
74:56 - this test instead of calling the render
74:58 - function from react testing Library we
75:01 - use our own render function render
75:04 - component this returns an object so we
75:07 - destructure it and grab the elements we
75:10 - need heading checkbox and button now we
75:15 - can remove these lines here's one here's
75:17 - another one and one more now earlier I
75:21 - told you that when we use
75:23 - the get by ro or any other variations of
75:26 - get by query method we don't need to
75:28 - check if the element is in the document
75:31 - because if not this line this statement
75:33 - is going to throw an arrrow so in this
75:36 - test we can safely remove this line and
75:39 - this line and this line now these three
75:43 - assertions are logically related so I
75:46 - put them next to each other because all
75:48 - of them are about checking that our
75:51 - component renders correctly okay okay
75:53 - now look our test is a lot cleaner it's
75:56 - easier to maintain and understand now
75:58 - similarly in this other test we call
76:01 - render
76:03 - component now here we only need the
76:06 - checkbox and the button so we can
76:09 - simplify our test and here we simply
76:13 - pass button to the expect function
76:16 - that's a lot
76:18 - better well hello msh here thank you for
76:21 - watching my react testing tutorial I
76:23 - wanted to let you know that this
76:24 - tutorial is the first hour of my
76:26 - complete react testing course so after
76:29 - you finish this tutorial if you want to
76:31 - learn more I highly recommend you to
76:33 - enroll in the full course because it's
76:35 - much faster and easier to learn react
76:38 - testing than jumping over a bunch of
76:40 - disconnected tutorials on YouTube
76:42 - everything you need to know is
76:43 - jam-packed in a perfectly structured
76:46 - 7-hour course would cover more advanced
76:48 - topics like marking apis testing forms
76:51 - testing State Management authentication
76:54 - and routing now just like my other
76:56 - courses this course comes with a 30-day
76:59 - moneyb guarantee and a certificate of
77:02 - completion if you're interested click
77:04 - the link below this video to enroll in
77:06 - the
77:12 - course

Cleaned transcript:

welcome to the complete react testing course in this course you're going to learn everything necessary to write effective valuable and maintainable tests for your react applications if you have been searching for a comprehensive easy to follow well organized and practical course that takes you from Zero to Hero this is the right react testing course for you this course is packed with a ton of coding techniques I've learned over 20 years in software engineering plus it's packed with numerous real word exercises designed to help you master react testing by the end of this course you'll have the skills and knowledge to confidently test react applications like your pro this expertise will set you apart in the world of software development opening doors to exciting opportunities and challenges I'm m hamadani a software engineer with over 20 years of experience and I've taught Millions how to code and become professional software Engineers through my YouTube channel and online school cm.com so are you ready to elevate your react skills let's dive in and get started I Promise by the end of this course you will look at unit testing in a whole new way if you're new here welcome aboard make sure to subscribe as we upload new videos all the time let's talk about what you need to know to take this course first and foremost you should have a good grasp of react because we're testing a react application in this course so you need to know all the essential Concepts like components hooks State Management routing and so on if you want to brush up on your react skills I have a couple of comprehensive courses on my website so feel free to check them out now if you're watching this video on YouTube I've put the links Below in the description box you can also go to code withth mos.com to see all my courses now the react application we're going to test in this course is written with typescript so you should know the basics of typescript as well don't worry you don't need to be an expert just knowing the basics is enough you should know how to define types and annotate your objects with types that's all now if you want to learn typescript I have a 1hour tutorial on my YouTube channel as well as a comprehensive course on my website again the links are below this video now there is one more thing you need to know you should know the basics of unit testing plain JavaScript code without any UI Frameworks more specifically you should know how to write basic unit tests and make assertions so I'm assuming you know the basics of unit testing and in this course you want to learn how to test react applications now if you want to learn the basics of unit testing JavaScript code again I have a 1hour tutorial on my YouTube channel as well as a comprehensive course on my website now assuming that you are the right student for this course let's move on to the next Lon all right before we jump in let's take a quick look at what we'll cover in this course shortly after this video we're going to set up our development environment and get all the testing tools we need in the next section we'll explore testing react components with the react testing Library this is where the fun begins you will learn how to use this powerful library to write tests that are maintainable and closely resemble how your web pages are used then we'll talk about mocking apis you will learn how to write tests that are robust and independent of external factors next on our list is testing forms forms are crucial in user interaction and I will show you various techniques to make sure they work flawlessly every time moving forward we'll delve into testing State Management in this section we'll look at a few examples involving react context Redux and react query after that we'll talk about testing authentication and in the final section we'll cover testing routing now a lot of people struggle with unit testing why because they don't know how to write good tests they spend a lot of time writing and fixing lowquality tests these tests get in the way slow you down and can be really frustrating but don't worry because throughout the course I'm going to show you various techniques to write tests that are not just good but great these are the techniques I've learned and M over two decades of working as a software engineer so I will show you how to write tests that are effective valuable and easy to maintain so there's a lot to cover and by the end of this course you'll be really good at testing react applications I promise before we start coding let's talk about how you should take this course first off as you learned in the previous video I've structured this course so it's super clear and easy to follow now you might be tempted to just jump to the sections that seem relevant to you but here's my advice don't do that even if you have been writing tests for a while you might have picked up some bad habits along the way that's why I suggest starting from the beginning and watching every single lesson because throughout the course I share a bunch of shortcuts for navigating your code base and writing code quickly if you skip around you might miss these and feel like the course is moving too fast trust me these tips are game changers now let's talk about exercises this course is incredibly HandsOn and is packed with real boo exercises in fact more than half of the course is dedicated to these practical exercises if you really want to get good at testing you need to do these exercises and don't just do them make sure to watch my Solutions as well that's where I share the techniques I have learned and refined over two decades of working as a software engineer these aren't your everyday tips and tricks you probably won't find them in most other courses I promise every minute you spend on this course is going to be worth your time lastly this course comes with a couple of GitHub repositories there is one for the started project and another one for the finished project which includes all the code we write in this course for each lesson we have a separate commit this way you can see the exact code I write in that lesson step by step so that's how we can get the absolute best out of this course follow it step by step and complete all the exercises I can't wait to see how much you learn and grow as a software engineer all right before we get started let's make sure you have the necessary tools installed on your machine first head over to nodejs.org and download the latest version of node this is really important because sometimes in newer versions of node there are optimizations that make your tests run faster so make sure to download the latest version of node now in addition to node we're going to use git to manage our source code these days pretty much everyone has git on their machine but if you don't head over to gm docomo the latest version for your operating system now in this course just like my other courses I'll be using visual studio code or vs code as my editor you're welcome to use your preferred editor but I highly recommend you to use Visual Studio code because it makes it easier to follow along plus I'm going to show you a lot of shortcuts to boost your productivity and have fun coding all right now let's set up the starter project for this course head over to github.com slmos dhamani then go to repositories here we have two repositories for this course react testing starter which is our starter project and react testing finish which is the completed solution so let's go to react testing starter now here you can find all the details about this project for example you can see that our project uses ozero for authentication and it's built with Tailwind rui react router react query and Redux toolkit ideally you should have basic familiarity with all these Technologies and libraries but if not that's still fine so the first thing we have to do here is setting up off zero for Authentication so head over to off zero.com if you don't have an account sign up it's free and it takes only a couple minutes then once you log in here on the dashboard on the left side go to Applications and create a new application we can call this whatever doesn't really matter I'm going to call it my react app now we go to the settings page and here we have to set a few settings first we have to set application type to single page application next we set allowed call back URLs we set it to http Local Host Port 5173 this is the port that our project uses now I'm going to copy this address and paste it in allowed log out URLs box as well as allowed web Origins then we save the changes all right good so we are done with setting up off zero now we need to go back to GitHub and clone this repository on our machine so let's grab the code then we open a terminal window and clone this repository all right now let's go to react testing starter first we need to install all the dependencies all right good now let's open this with vs code now here in the root directory we have ATV file we're going to take a copy of this for storing our local environment variables so let's make a copy and rename this copy to env. local now we need to replace the azero domain and client ID with the values from our ozero application so back to the settings page of our application on the top you can find the domain and client ID let's copy these values and paste them here and one more time with the client ID lovely now let's go to package.json so look here we have a few scripts we have the server script for starting the backend our backend is implemented with Json server so Json server uses this file db. Json to serve data to our application now in a real application you're not going to use this you're going to use a database but it doesn't really matter as far as testing is concerned because here we're not going to use the real backend we're going to Mark the back end and test the front end in isolation now here we have a script for starting the application using concurrently so using this package we can run both the back end and front end in parallel so back to the term let's run npm start our backend starts at Local Host Port 3000 so make sure you don't have any other applications running on that port and our front end starts at Port 5173 so let's take a look here's our application it's not a fullfledged application but it has a few cool features and patterns that you find in a lot of real world applications for example on the top we have a selector for selecting a language currently English is selected if we change it to Spanish now the message changes here let's go back to English so this is implemented using react context now let's go to the products page here we have a list of products that are feted from the back end we can add them to our shopping cart and the number of items in the shopping cart is updated on the top we also have an admin area that is protected here we get redirected to the universal login page on o zero so let's sign up with a new account all right let's authorize our application all right I'm logged in and now I have access to the admin area here we have a products page where we can manage our products we can add a new product we have a basic form let's add product one give it a price now here we have full validation so if we submit the form without supplying any values we get validation errors so let's give this a price of $10 and assign it to a category like Electronics here's our product we can also edit it let's change the category to appliances good now we get this toast notification on the top beautiful now finally if you log out we get redirected back to the homepage so we have a few interesting patterns and features that you find in a lot of real word applications now to test this application we need a testing framework as I told you in my JavaScript testing course there are many testing Frameworks out there like Gest mocha Jasmine vest and so on just is probably the most popular testing framework but the problem with justest is that its support for Eos script modules or native JavaScript modules is still experimental so setting things up is a little bit awkward so in this course we'll be using Vest which is a relatively new testing framework built for testing modern JavaScript applications so it has builtin support for ecmascript modules as well as typescript and jsx so back to our project on the top let's go to view and then terminal look at the shortcut it's control and back tick so now we have a terminal window pointing to our project directory let's install vest as a development dependency all right good now we need to create a test script in our package.json file so on the top Under The Go menu look at the shortcut for going to a file on Mac it's command and P on Windows is probably control and P so now let's go to our package.json file here in the scripts object we need to add a new script let's call a test and set it to v test now I would prefer to create another script for running tests using the vest UI so let's call this test colon UI and set it to vest with the UI option now let's create a basic test to make sure that our setup is done properly so back to our project here in the root directory we add a new folder let's call that test here we add a new file let's call it main. test.ts now here on the extensions panel I want you to search for vest we have this very useful extension called vest Snippets it's from this developer Dean software with this extension installed here we can import the essential functions from vest by typing IV that is short for import v test so now we have it expect and describe from V Test Now to create a test Suite we type D followed by enter the name doesn't matter let's press tab Now to create a test case we type I followed by enter now I don't know why I have two instances in the autoc completion box the one we need is the one with this Square icon that is a code snippet so let's select that now let's write a basic assertion and say expect one to be truy now let's go back to the terminal window and run npm test or npm to run tests in the terminal all right our test passed beautiful now let's quate and run test using Vest UI so npm run test coland UI now the first time it's asking if you want to install vest UI let's select yes all right good now we need to run this command one more time all right here's v test UI throughout the course we're going to use this interface to run our tests because it's much easier to see what's happening as opposed to running tests in the terminal window now I don't like the light mode so let's change it to dark that's easier on the eyes so we have one passing test beautiful we're done with setting up v test next we're going to set up react testing library to test react components we need a few tools the first one is react testing Library which allows us to render our components and interact with them just like the end user so let's go back to the terminal and install react testing Library as a development dependency so at testing D Library SL react and the version I'm going to install is all right good now the next Library we need is jsd what is this well by default our tests are executed in a node environment but node doesn't know anything about browser apis like the Dom so to test our react components we need to run our tests within an environment that emulates a browser environment we have a couple of options here we have jsd and Happy D which is faster but lacks some apis so we're going to start with JS Dom but later we can switch to happy to optimize our tests so back in the terminal let's install JS Dom as a development dependency and the version I'm going to install is 24.0 point0 now we need to create a configuration file for vest to tell it to use jsdom as the testing environment so back to our project here in the root directory let's add a new file called vest.com config TTS make sure you create this file in the root okay now here on the top first we import Define config from vest SLC config next we call this function and give it an object here we set test to an object and set environment to JS D now this returns a configuration object so we export it as a default object from this module now whenever we change vest configuration we have to restart vest so back to our terminal window where we are running vest UI let's press Q to quit and rerun npm run test UI all right good now the last Library we need is testing Library slj Dum this Library gives us a bunch of matchers for writing assertions that against the Dom for example we can check to see if an element is in the Dom if it has the right content and so on so back in the terminal let's install one more library and that is at testing Library slj ddom welcome back to the complete react testing course in this section we're going to dive deep into the world of testing react components we'll kick things up off by understanding what to test and what not to test when it comes to testing components we'll then jump right in and explore testing rendering and user interactions we'll also look at a few techniques you need to know to test components that use component libraries like radex UI material UI and so on throughout this section I will also show you a few techniques to simplify your tests and make them more maintainable and finally we'll wrap up this section by talking about using ES length to catch common issues in the code this is a foundational section in the course so make sure to watch every lesson and complete every exercise with that now let's jump in and get started okay before we dive into writing tests let's take a moment and talk about what exactly we should be testing and perhaps more importantly what we can skip testing when it comes to testing react components there are two major concerns we need to test how they render and how they respond to user actions for rendering we should verify that our components render correctly under various conditions if a component has props we should pass different props and verify that it renders correctly if our component handles user events like clicks keyboard inputs or anything similar we should simulate those and check if it reacts the way we expect now in my JavaScript testing course we talked about the importance of creating tests that are maintainable robust and trustworthy I mentioned that having no tests is better than writing bad tests because poorly written tests can get in the way and slow us down now one of the best practices I touched on was testing the behavior and not the implementation in simple words that means we should test what our application does not how it's implemented as an analogy think of testing at TV we use the remote Press buttons and watch what happens we don't care what's inside the TV right similarly when testing a component we should test what it does not how it's implemented if our component uses hooks or react context or reducers these are all implementation details we should not write tests against those details because if the implementation details change in the future our tests may break even if our application still works fine so for the most part we shouldn't test building blocks like Hooks and reducers in isolation unless they're used by several components and have complex logic in those cases yes it makes sense to unit test those pieces in isolation but for the most part we should test them as part of testing our components which is what we call integration testing now you have probably seen this test pyramid before the test pyramid suggests that we should write more more unit tests than integration tests and more integration tests than endtoend tests this is just a guide not a strict rule so when testing react applications we often lean towards integration tests our tests might be slower than unit tests because we'll be testing several units together but they give us better confidence that our application works plus our tests are less likely to break if we refactor some code as long as the end result stays the same the other thing you should avoid is testing Styles why well visual tests can be fragile a tinier style change like changing the font size or color can fail a test and honestly passing visual tests don't guarantee that our application looks good that's a job for our own eyes so instead of wasting our time testing Styles we should test our application's behavior and functionality that's where the real value is All Right theory time is over let's dive into some real examples of component testing as we move forward all right let's write our first test here in the source folder inside the components folder we have a component called GRE a very simple component with a name prop of type string if we provide the name our component renders a heading otherwise it renders a login button so here we need two test cases in one test case we provide a name and and assert that we have a heading with this content in the Dom in the other test case we don't provide a name and assert that we have a login button in the Dom so back to our project we go to our tests folder and create a new folder here called components now in terms of test organization there are two schools of thought Some people prefer to have all their tests inside the tests folder other people prefer to have their tests next to their components there is really no right or wrong here but most of the community prefer to have their tests inside the tests folder this also makes things a little bit easier when working with continuous integration and deployment tools so in this course we're going to put all our tests inside the tests folder now here we have a folder for our components so all our component tests are in a single place now we create a new file called greet test.ts now note that here we are using capital G because that's how we name files that have react components now in this file first we have to import the essential functions from vest so IV then we create a test suite for the greed component here's our first test case it should render hello with the name when name is provided now here first we have to render our greed component to do that we have to import the render function from react testing Library so at testing Library SL react so we call render now here we need to pass our greed component now because we're going to write some jsx expression here we have to rename our file from TS to TSX so let's rename our file to TSX good now here we can render our comp component our greet component now in this case vs code Auto imported this for me on the top if your editor doesn't do it make sure to import greet from the right location so we render greet and set the name prop to let's say mosh so this render function renders our component into a virtual Dom that is implemented by JS Dom the library we installed in the first section okay now to see the state of the Dom we can use the screen object so on this line we also import the screen object now after we render our component we call screen. debug now back to v test UI in the browser let's look at our GRE test here on the console tab look this is the state of our virtual do we have body div and our heading now to complete our test we have to find this heading in the Dom and make an assertion against it to to do that we have to use one of the query methods in react testing Library if you search for react testing Library queries you will find this page here we have a bunch of query methods like by Roll by label text by placeholder text and so on most of the time we prefer to use by roll because this makes our tests more robust and less prone to Breaking changes when we change the UI for example if we change some text or class names of our elements a test using this query method is less likely to fail compared to one that relies on text or class selectors okay also this query method encourages us to interact with our components just like the end user focusing on accessibility features so back to our code here we call screen get by roll now here we have a bunch of standard roles like alert article banner and so on here we want to select an element with the role of heading this returns any kind of heading like H1 H2 and so on now we store it in an object and finally we need to write our assertions so just like unit testing JavaScript code we start with expect we pass our heading object now here we need to use one of the matchers that comes with testing Library so on the top we import at testing Library slj Dom slvest now if you're using just you have to modify your import statement in this package we have a bunch of custom matchers you can find them all by searching testing Library just Dom on this GitHub page you can find all these custom matchers like to be disabled to be enabled to be in the document and so on you don't have to memorize any of these as we go through the course as we work on more exercises you will gradually get familiar with these matches okay so back to our code now let's finish our assertion so we expect heading to be in the document okay back to v test UI we have one passing test beautiful now in my JavaScript testing course I emphasize the importance of testing the correct Behavior so to prevent false positives or tests that always pass we can go to our production code make a tiny change and see if our test fails or not so let's go back to our greed component we can comment out the line of code that should make our test pass now if our test fails it means that we're testing the correct Behavior now look our test failed good we can look at the report tab to see what's happening down here you can see the state of the Dom so we have the login button but we were searching for a heading so back to our great component let's bring this back good now we can write a second assertion and Ensure that our heading has the right content so we expect heading to have text content this is another custom matcher that comes with testing library now here we can pass a string or a regular expression it's often better to use a regular expression to make our tests more robust so here we pass a regular expression and search for Hello mosh and we want to make this case insensitive now if in the future we replace hello with hi or good morning or whatever our test is going to break so we don't want to be over specific here we want to make our assertions a little bit looser or more General okay now again our test is passing great so we're done with our first test case now let's repeat and create a second test case to save time I'm going to duplicate this test case and change the test name should render login button when name is not provided now if you remove the name prop we get a compilation error saying property name is missing because our grid component always expects a name so here we have to pass an mty string but this looks a little bit ugly so to make our component more flexible we can make the name prop optional so right here we add a question mark and now we don't have to supply the name prop all right good now in this test case we get an element by the rule of button let's change the name of this constant to button first we expect our button to be in the document and then we assert that it should have the right content in this case login now look we have two passing tests great once again to verify that we are testing the correct Behavior we go to our production code and comment out the line of code that should make our last test pass now our test failed so that means we're testing the correct Behavior so let's bring it back all right you have learned how to write basic tests using react testing library now there is a problem with our setup every time we want to create a test file we have to add these import statements on the top this is repetitive and conversome so in this lesson I'm going to show you a few techniques for simplifying our test setup first we don't have to import these functions from vest in every single test file we can go to our vest configuration file and turn on globals so let's go to vest. config.sys the first import statement now here we get a bunch of compilation errors from the typescript compiler for example the typescript compiler is complaining that it cannot find name describe to fix this issue we have to go to our typescript configuration file which is tsconfig Json here in the compiler options object we add a new property called types we set it to an array and here we pass V test/ globals now the error should go away there you go if this doesn't happen on your machine bring up the command pallet and search for typescript reload project okay so that was the first Improvement now the second Improvement again we don't want to import this module in every test file to get access to these custom matchers so let's go to our tests folder here we add a new file called setup TTS Now we move this line from our test file into our setup file next we go to our vest configuration file and reference our setup file so here we set setup files to tests SLS setup. TS this setup file is run before each test file it's useful for configuring our testing environment okay now because we have changed our vest configuration file we have to go back to the terminal stop this process and run our tests again all right all our tests are passing great now back to our test file the last Improvement I want to show you here is that we don't have to type import render and screen from testing Library every single time there is a shortcut for this here in the extensions panel search for testing Library snippet we have this extension from Dean software let's install this all right now back to our test file instead of manually typing this every single time we can type ITR and press enter as simple as that okay here's a great exercise for you to practice what you have learned so far in our components folder we have have a component called user account this component has a prop called user of type user let's take a look at this type here we have three properties ID name and is admin now this component renders the users's name and an edit button if the user is an admin so I want you to spend 10 to 15 minutes and write all the test cases for this component to give you a hint here we need three test cases in one test case case we assert that the user's name is rendered in the Dom now to write this assertion you cannot use the get by roll method because look the name is rendered inside a div and divs don't have a role by default unless we give them a role but this is unnecessary so in this test case you have to use a different query method that is called get by text okay now we need two test cases for the edit button in one test case we pass an admin user to this component and assert that the edit button is rendered in the other test case we pass a nonadmin user and assert that the edit button is not in the Dom now in this test case again you cannot use the get by roll method because get by roll will throw an error if the element you're looking for doesn't exist in the Dom so in that test case you have to use a different method called query by row so you you look for a button using this method and then as part of writing your assertion you have to use the not property to make sure that that element is not in the document okay so spend 10 to 15 minutes on this and then come back and see my solution all right so we go to our test folder inside the components folder we add a new file called user account. test. TSX first we import screen and render from react testing Library good then we create a test Suite called user account now I'm going to go faster because I'm assuming you have done your exercise okay now here's our first test case it should render user name here first we create a user object we annotate it with its type now here we have two user types types one is defined in all zero the other is defined in the end of this module in this project we're going to pick this one now let's create a user object we set the ID and name to some arbitrary values next we render the user account component and give it this user object now our assertion so here we call screen. get by 10 next and pass user.name now this returns an element but we don't need to store it in a constant because we're going to use it only once so we can pass it directly to the expect function and assert that this element is in the document now look we have one passing test great now once again to verify that we're testing the correct Behavior we go to our production code and comment out the line that that should make that test pass so now our test should fail there you go we're testing the correct Behavior now going forward I'm not going to repeat this over and over because that's repetitive but I want you to practice this as part of writing your tests okay so let's bring this back we are done with our first test case now let's duplicate this and write the test for the edit button so here we say it should render edit button if user is admin here we set is admin to true now our assertion is going to be different so here we call screen. get by roll we look for a button we store it in a constant because we're going to write two assertions against this object first we expect our button to be in the document and then we assert that it has the right write label so to have text content and again here we use a regular expression all right good take a look two passing tests lovely now the final test case so let's duplicate this test first we change the test name to should not render edit button if user is not admin we can set this to false or remove this property now in this test we cannot use get by roll because this will throw an error because we're not going to have a button in the Dom so here we call query by roll we get the button and then expect this button not to be in the document okay let's remove this other assertion good now take a look we have three passing tests well hello msh here thank you for watching my react testing tutorial I wanted to let you know that this tutorial is the first hour of my complete react testing course so after you finish this tutorial if you want to learn more I highly recommend you to enroll in the full course because it's much faster and easier to learn react testing than jumping over a bunch of disconnected tutorials on YouTube everything you need to know is jampacked in a perfectly structured 7hour course will cover more advanced topics like marking apis testing forms testing State Management authentication and routing now just like my other courses this course comes with a 30day moneyb guarantee and a certificate of completion if you're interested click the link below this video to enroll in the course all right now let's look at an example involving lists in our components folder we have a component called user list this component takes a prop called users which is an array of users if the array is empty it renders no users available otherwise it renders a list of hyperlinks one for each user okay so let's test this we go back to our test folder in the components folder we add a new file called user list. test. TSX let's do the ceremony we create a test Suite called user list and here's our first test casee it should render no users when the users array is empty and of course we can word it differently so here we call render and give it user list with an empty array okay now to write our assertion look this message is rendered inside a paragraph and paragraphs don't have a rooll by default so once again we have to use the get by text method so here we call screen that get by text now we don't want to look for the exact message like no users is available because this makes our test fragile if one of the words here changes our test will break so we use a regular expression to look for the presence of certain keywords I think the chances of no users keyword changing in the future is probably minimal we not sure but I think this makes our assertion a little bit more General and our test will be a little bit more robust okay so we find this element and expect it to be in the document and by the way look when you want to find a method you don't have to type the whole method name that's very time consuming instead we can use abbreviations like to be in the document okay so that was our first test now take a look user list we have one passing test grade now our second test this test is more interesting so I'm going to duplicate this test and here we change the test name to should render a list of users now in this test first we create an array of users so we annotate this with user array and again make sure to pick the type in the entities module okay now let's initialize this array with two objects we set the idea name msh and one more let's call this user John so we passed the users array here now how can we verify that we have the right hyperlink for each user well here we can iterate over our array of users and for each user we can look for a link with the user's name and then we can verify that that link has the right HF attribute here's how we're going to do it so here we call users. for each we iterate over this array for each user we find a link with the user's name so we call screen. get by roll we look for a link now all these query methods have a second argument which is optional and this is the options object you can find the details in the documentation so take a look here's get by roll now this is the options object here we have a bunch of properties like name for using a text match we have selected for applying a filter and picking elements that are selected we also have checked pressed and a bunch of other properties I'm not familiar with all of them but you will learn about them depending on the types of test you write okay so here we can pass the options object and apply a filter we only want to find a link with this name user.name now this returns a link first we check if link is in the document and then we check that it has the right href attribute so we expect link now here here is another matcher to have attribute we look for hre and we want this to be like slash users well let's look at our production code here's what we expect SL users user. ID now I need to clarify something here in this case technically I cheated we shouldn't write our tests based on our production code because our production code might have a bug if we write our assertions based on what we have in the production code we'll end up with far false positives our tests will pass but our application will have a book so ideally we should write our tests based on the requirements in other words we should treat each component like a black box we shouldn't care what is inside we shouldn't care about the implementation we should test what it's supposed to do okay now back to our test so here we want to look for an HF like/ users slash now we want to add the ID dynamically so let's replace this string literal with a template literal and here we can insert user. ID take a look our test are passing great now I want to verify that we're testing the correct Behavior so for the last time let's comment out this line now our test fails great all right here's another great exercise for you in the components folder we have we have this component called product image gallery this component receives a list of image URLs as a string array now if the array is empty our component renders nothing otherwise it renders a list of images so here we need two test cases in the first test case we should render this component with an empty array and then assert that the Dom is empty now we haven't done this so far so I want you to do a bit of research and solve this problem on your own it's not complicated it just search for react testing Library assert that the Dom is empty now in the second test case we should render this component with a list of URLs and then assert that we have a list of images with the right Source attribute rendered in the do spend 10 minutes on this then come back and see my solution all right to save your time I created this test file with the basic setup before recording this video so here's our first test case our component should render nothing if given an empty array so here we call render and give it product image gallery here we set image URLs to an empty array now to assert that the Dom is empty we get the object that is returned from this function we can call it result now look result has a bunch of properties one of them is container this is the container for component so here we can destructure this object and grab the container then we pass it to the expect function and here we call to be empty Dom element as simple as that now take a look our test is passing great now let's work on the second test case it should render a list of images now in this test first we deare an AR array of URLs let's call it image URLs we set it to two elements URL 1 and two then we render product image gallery here we set image URLs to image URLs good now in this test unlike the previous lesson we cannot iterate over this array and for each element assert that we have an element with this URL because in the previous lesson we were applying a filter by name but here we cannot filter Elements by their Source attribute so here we have to take a different approach first we call screen. get all by row so all query methods that you have seen before they have a variation for selecting multiple elements so we have get by role we also have get all by ro similarly we have get by text we have get all by text and so on so let's call get all by roll for selecting multiple images the role we should pass is IMG with this we can get all the images in the Dom first we should assert that we have two images so we expect images to have length two then for each element in this array we assert that we have an image with the right Source attribute for example we can say expect images of zero to have attribute source and here we should pass image URLs of zero and of course we have to repeat this for the second element but that looks a little bit ugly so here we can iterate over image URLs using for each we pass an arrow function here with two parameters URL and index Now we move this assertion up here and we check that the element at this index have this attribute that is the URL that we get in this function now take a look our tests are passing all right now let's see how we can test user interactions here we have a component called terms and conditions a very typical implementation where we have our terms and conditions followed by a checkbox for the user to accept the terms and a button that is only enabled if the checkbox is checked now before we write tests for this component let's see it in action so let's go to this file called playground page it's inside the pages folder now here we're rendering the onboarding component we don't need it for now we'll come back to it in the future so instead let's render terms and conditions now back to our website let's go to the playground page here's our component now the button should be initially disabled but we don't see it visually because I forgot to apply a style here so to fix this let's go to index.css here's our button class let's add another button class with a disabled selector here we set the background to CCC now look our button is initially disabled but if if we check the check box it becomes enabled this is the behavior we're going to test in this lesson so back to our project let's go to the tests folder here we add a new file call terms and conditions. test. TSX we do the setup first then we create a test Suite terms and conditions now in our first test we want to make sure that that our component renders correctly so nothing new so far we just want to test the rendering of this component so here we can say it should render with correct text and initial state so we call render and past terms and conditions now here we have some basic text we don't want to look for the presence of this text because this can easily change in the future the only thing we want to look for in terms of text next is our heading so back to our test here we call screen. get by roll look what I'm typing gbr that is short for get by roll okay so we find a heading we store it in this object first we check that this heading is in the document so to be in the document and then we check that it has the right content to have text content now in this case we can pass a string we don't have to use a regular expression because the chances of this heading changing in the future is really minimal okay so that was our text now what about the initial State well we need to verify that we have an unchecked check boox in the dot so we call screen get by roll check box we store it in this object now just like before before we expect checkbox to be in the document and it should also be unchecked how do we do that well we have a matcher here called to be checked okay now we don't have a match called to be unchecked so to verify that our checkbox is unchecked here we use the not property okay now one question you might have here is isn't that better to split these assertions into two tests one testing the heading the other testing the checkbox we can certainly do that but in this case I don't find any value in doing so because look we have to repeat this test case two more times and in each test case we have to render the component it's a little bit repetitive so I prefer to have all these assertions regarding rendering in this test case but don't take it as a hard and fast rule every problem every component every test case is different so we check the check box and finally we verify that we have a disabled button so we call screen get by roll button now if you have multiple buttons here we can apply a filter and look for the button that has what was the label that is submit okay so here we can pass a regular expression to filter our buttons in this case we don't need that so let's simplify our test so we get our button first we check that the button is in the Dom or in the document then we check that our button has the right label to have text content submit and finally we assert that our button is disabled so expect button to be disabled now it is possible that in the future F this label gets changed to something else like continue so in this case I prefer to remove this assertion what we want to focus on is the behavior or the functionality of this component that the button is only enabled when the checkbox is checked testing this behavior is more important and more valuable than testing the content on our web pages okay so that was our first test now look our test is passing great so let's see how we can test user interactions so let's create a second test case and say should enable the button when the checkbox is checked now once again we render our component now to simulate user interactions we have to use a different Library called user event back to the documentation of testing library look here we have this section called user interactions we have this companion Library called user event we have to install this separately to simulate user events just note that in react testing Library we also have fire event a lot of people use this but it's not the best way to simulate user events because fire event as explained here is a lightweight wrapper around the browser's lowlevel dispatch event API so it doesn't simulate a real work scenario and that is why we have the the user event Library the way this Library dispatches events is similar to how users use our application okay now to install this we have to install testing Library sluser event as a development dependency so let's copy this line and paste it in the terminal good back to our test so first we render our component then we look up our checkbox so screen. get by roll checkbox just like before we store it here now to click this checkbox first we call user event this object is defined in testing Library SL user event so if your editor doesn't automatically import this make sure to import it like this on the top okay back to our test here we call user event. setup this returns an object we can call it user then we call user. click checkbox now look at the return type of this method it returns a promise so here we have to await this and make our test function async finally we make an assertion so we call screen get by roll we get our button and expect this button to be enabled now pay attention to how I've formatted this code so here we have the arrange part then we separate it with the line break from the ACT part and finally we have the assert part we don't need to add the comments just using a vertical line bre is enough to give other people how we have structured this test now back in vest UI both our tests are passing great now do we need another test case to assert that our button is disabled if the checkbox is unchecked I find it redundant because our first test case verifies that behavior there is no need to write a separate test case and click the checkbox twice to see if the button is disabled all right here's another fantastic exercise for you to practice unit testing look at this component expandable text our component receives a prop which is a text of type string that if the text is shorter than 250 five characters it gets rendered otherwise it gets truncated with a dot dot dot at the end and here we have a button for expanding or collapsing the text now before testing this let's see it in action so we go to our playground and render our expandable text component now let's set the text to a short text all right here's what we get the full text is rendered but if you pass a long string here which we can generate by typing lurm followed by a number a big number like 100 and tap that's a long lurm if some text now we can grab this and paste it here look what happens so our text is truncated and here we have the show more button ignore the styling I forgot to apply class we can fix it by applying the BTN class to our button so here we set class to well class name to BTN all right that's better now if we click this we see the full text and now we have show less this is a great exercise for you to practice what you have learned so far so spend 15 to 20 minutes on this and then come back and see my solution all right just like before we start with the rendering tests and then we'll move on to user interactions so what aspects do we want to test here for rendering we want to make sure that if the text is is short the full text is rendered otherwise our text is truncated these are the two aspects we need to test so here's our first test case should render the full text if less than 255 characters so here we call render and pass expandable text we set the text prop to some short text now to look this up in the Dom we use screen do get by text now let me show you a shortcut earlier in the course we installed an extension for react testing library in case you didn't do it it's right here testing Library Snippets from Dean software now with this we can generate this statement by typing QT that is query by text if we press enter now we have all query methods for for looking up an element by text so we have get by text get all by text query by text and so on now similarly we have query by role so QR but in this case we're going to go with QT okay so we're going to look up an element by this text now we don't want to repeat this here so let's put it in a constant short text and now we can reuse it in multiple places text and and text now we expect this element to be in the document another shortcut just type T bind that gives us to be in the document okay let's take a look all right we have one passing test great now let's write another test case for a long text so to save time I'm going to duplicate this test now let's change the test name should truncate text if longer than 255 characters now to generate a long text we can grab a character like a and then repeat it let's say 256 times now in this test we have to look for the truncated text so let's declare a constant called truncated text we grab our text apply a substring and grab the first 255 characters and then we append dot dot dot at the end that is what we expect to have in the Dom so let's pass it to get by text take a look our test is passing great now in this scenario we also want to look for the presence of the show more button so to find our button we type QR get by roll and pass button restore it here first we expect the button to be in the document and then we verify that it has the right label so to have text content and here we use a regular expression and look for more now earlier I told you that get by roll throws an error if there is no element matching the criteria so technically speaking we don't even need to check if the button is in the document because if it doesn't exist this test is going to fail on this line anyway so in this case we can safely remove this line but if we didn't have another assertion after our test would look weird it would look unfinished so for clarity if we don't have other assertions I would prefer to check if the element is in the document okay we don't need it for now now let's take a look our test is passing great so these are the rendering tests now let's test the user interactions so again to save time I'm going to duplicate this test because we're dealing with a long text now there are two places where we are generating long text let's move these outside of our test cases into a single place so we can go to our test Suite first of all we can declare a constant called limit we set it to 255 so if the requirements change in the future there is a single place in our tests we need to update now for generating a long text we can grab a and repeat it up to limit plus one now for generating the truncated text we declare a constant and here we get our long text and grab the first 255 characters in this case limit okay now we can simplify our tests a little bit so we we don't need to generate a long text here now we need to replace text with long text and we don't need to compute truned text either okay so always pay attention to these little details because they will always pay off in the long run okay now in our last test case well here we need to change the title to should expand text when show more button is clicked again we don't need to generate a long text here and similarly for the truncated text so we find our button then we need to click it so here we call user event do setup we get a user object and then we call user. click button I told you this returns a promise so we need to await it and make our test function async all right so this is the ACT part now we need to separate it from the assertion part so in this case we expect the full text to be in the document so we expect query by text and here we look for our long text to be in the document okay also the label of our button should be changed to show less now as I've said before there are some folks who are strict about a single assertion in the test but this is impractical call because imagine if we wanted to move this assertion into a separate test we would have to repeat all this logic in that test sure we can create another test suite and use before each but all that ceremony is unnecessary these two assertions are highly related they're logically part of a particular state of our component that is why I prefer to put them in the same test okay let's see if our test passes all right looks like one of our tests failed I made a mistake so what's happening here this this is the test for truncating text the aror is saying unable to find an element with the text whatever okay so let's take a look so in this test we are looking for the truncated text so the test is fine I probably made a mistake up here yes I forgot to add dot dot dot at the end sorry about that all right now all tests are passing great there's one more test we need so we have a test test for expanding the text now we need a test for collapsing the text so let's duplicate this test first we should change the test name to should collapse text when shows button is clicked now in this test in the arrange part first we have to click the show more button so the text is expanded so I'm going to remove this line brick this is our arrange part we click the button to expand the text now in the ACT part we click the button again and then assert that the long text is no longer in the document so we should look for truncated text and the show more button now take a look our tests are passing but I don't like the way I've written this test let me show you a better way first we're going to rename this button to show more button and for clarity here we can apply a filter we can set the name to more now it's clear that on this step we're clicking the show more button now in the ACT part we can call get by row to get a button and here we apply a filter as well this time we are looking for the shows button so we store it in a constant show less button and at this step we are clicking the show lless button even though it's technically the same button now our test code better aligns with the test description this is just a personal preference you don't have to do this now let's see if our tests are still passing there you go beautiful we're done with this exercise so let's move on to the next lesson okay let me show you a great technique for simplifying our tests let's take a look at the tests we wrote for the terms and conditions component now if you have paid close attention you have probably noticed that there are a few places where we are looking up our elements so here we are looking up our check boox and button and similarly in this other test we are looking up these elements this is duplication so let me show you a better way to write these tests back to our test Suite here we Define a helper function for rendering our component and returning the common elements we want to query so we can use the arrow function syntax or function declaration syntax it doesn't matter I'm going to go with the arrow function syntax so we declare a constant called render component we set it to an arrow function now in this function we render our component then we return an object and in this object we add the elements we want to query so look in this test we need the heading the checkbox and the button so here we add three properties heading and we set it to screen. get by roll heading similarly we add our checkbox let's grab the code from here and finally we add our button change it to button good now in this test instead of calling the render function from react testing Library we use our own render function render component this returns an object so we destructure it and grab the elements we need heading checkbox and button now we can remove these lines here's one here's another one and one more now earlier I told you that when we use the get by ro or any other variations of get by query method we don't need to check if the element is in the document because if not this line this statement is going to throw an arrrow so in this test we can safely remove this line and this line and this line now these three assertions are logically related so I put them next to each other because all of them are about checking that our component renders correctly okay okay now look our test is a lot cleaner it's easier to maintain and understand now similarly in this other test we call render component now here we only need the checkbox and the button so we can simplify our test and here we simply pass button to the expect function that's a lot better well hello msh here thank you for watching my react testing tutorial I wanted to let you know that this tutorial is the first hour of my complete react testing course so after you finish this tutorial if you want to learn more I highly recommend you to enroll in the full course because it's much faster and easier to learn react testing than jumping over a bunch of disconnected tutorials on YouTube everything you need to know is jampacked in a perfectly structured 7hour course would cover more advanced topics like marking apis testing forms testing State Management authentication and routing now just like my other courses this course comes with a 30day moneyb guarantee and a certificate of completion if you're interested click the link below this video to enroll in the course
