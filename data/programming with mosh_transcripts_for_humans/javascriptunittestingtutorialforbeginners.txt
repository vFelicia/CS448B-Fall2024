With timestamps:

00:00 - [Music]
00:02 - welcome to mastering JavaScript unit
00:04 - testing in this comprehensive 4-Hour
00:07 - course I will take you on an exciting
00:09 - Journey where we will explore everything
00:11 - you need to know about unit testing from
00:13 - the very Basics to more Advanced
00:14 - Techniques if you're looking for a
00:16 - comprehensive easy to follow well
00:18 - organized and practical course that
00:20 - takes you from Zero to Hero this is the
00:23 - right JavaScript unit testing course for
00:24 - you this course is packed with real
00:27 - world examples and a ton of Hands-On
00:29 - exercises giving you plenty of
00:31 - opportunities to practice what you learn
00:33 - by the end of this course you'll have a
00:35 - strong foundation in unit testing you'll
00:37 - be able to significantly reduce bugs and
00:40 - improve the overall quality of your code
00:42 - this expertise will set you apart in the
00:45 - world of software development opening
00:47 - doors to exciting opportunities and
00:49 - challenges so if you're ready to unlock
00:51 - the full potential of JavaScript unit
00:53 - testing and elevate your coding skills
00:56 - join me in this exciting Journey I'm msh
00:58 - hamadani a software engineer with over
01:00 - 20 years of experience and I've taught
01:03 - Millions how to code and become
01:05 - professional software Engineers through
01:06 - my YouTube channel and online school CWI
01:09 - mar.com if you're new here make sure to
01:12 - subscribe as I upload new videos all the
01:14 - time now let's jump in and get
01:16 - [Music]
01:24 - started now to take this course you
01:26 - don't need any familiarity with unit
01:28 - testing at all in fact fact I've
01:30 - designed this course specifically for
01:32 - people who have never done unit testing
01:34 - because they find the idea intimidating
01:36 - so I'm going to teach you everything
01:38 - from the ground up but to take this
01:40 - course you should have a basic
01:42 - understanding of modern JavaScript that
01:44 - means you should be comfortable with
01:46 - Concepts like importing and exporting
01:48 - promises acing can weight and so on if
01:51 - you need to brush up on any of these
01:53 - Concepts check out the JavaScript series
01:55 - on my website so that's all about the
01:57 - prerequisites next we're going to talk
01:59 - about the course
02:05 - structure all right now let's talk about
02:07 - how I've structured this course this
02:09 - course serves as the rock solid
02:11 - foundation for unit testing in
02:13 - JavaScript applications however I want
02:16 - to clarify something up front we won't
02:18 - be testing a front end or a backend here
02:20 - because our primary focus is on nailing
02:23 - those fundamental unit testing Concepts
02:25 - and best practices that often get
02:27 - overlooked in many other courses
02:30 - this is where a lot of folks stumble
02:32 - when it comes to unit testing they rush
02:34 - into testing react or node without
02:36 - grasping the essential foundations and
02:38 - best practices so in this course my goal
02:41 - is to equip you with a robust Foundation
02:44 - once you have completed this course
02:46 - you'll be well prepared to tackle my
02:48 - other courses on testing react or Noe
02:51 - now here's our road map for this course
02:53 - we'll kick things off by getting you
02:54 - familiar with the basics of unit testing
02:57 - so in the first section we'll cover what
02:59 - unit testing is what are its benefits
03:01 - and what are the common arguments
03:03 - against it then we'll see unit testing
03:05 - in action you will learn how to write
03:07 - basic tests and run them next up we'll
03:10 - delve deeper into core unit testing
03:13 - techniques and best practices we'll
03:15 - cover Concepts like positive and
03:17 - negative testing boundary testing
03:19 - parameterized testing and so on then
03:22 - we'll explore how to use mocks or fakes
03:24 - to isolate our code during tests this is
03:27 - a very important technique used in unit
03:29 - testing
03:30 - in the final section we'll explore some
03:33 - handy static analysis tools like eslint
03:36 - prier and typescript these tools help
03:38 - you elevate the quality of your code and
03:41 - reduce the need for extensive test cases
03:44 - once you finish this course you'll have
03:45 - a rock solid foundation for testing
03:47 - JavaScript code if your goal is to write
03:50 - JavaScript libraries you can take what
03:52 - you learn in this course and use it to
03:54 - test your libraries if you're a front
03:56 - and developer and want to learn how to
03:58 - test react applications I've got you
04:00 - covered I'm planning to create a
04:01 - dedicated course on the topic and
04:03 - Chances Are by the time you're watching
04:05 - this course my react testing course is
04:07 - already published as for backend testing
04:10 - I've covered it in my note course so at
04:12 - this point I'm not planning to create a
04:14 - separate course on the
04:20 - topic all right now let's talk about how
04:22 - to make the most of this course if
04:25 - you're brand new to unit testing the
04:26 - best approach is to follow the lessons
04:28 - in order and complete the exercises
04:31 - along the way it'll help you build a
04:33 - strong Foundation however if you already
04:35 - have some experience you might be
04:37 - tempted to jump around and focus on
04:39 - specific lessons while that's an option
04:42 - because the course is well structured I
04:44 - would like to advise you against it why
04:46 - well you might unknowingly have some bad
04:48 - habits or be using less than optimal
04:51 - practices as your instructor I strongly
04:54 - recommend going through all the lessons
04:55 - sequentially the Fantastic part is that
04:58 - the course is concise and to the point
05:00 - so you can easily complete it in a
05:01 - single day plus it's full of practical
05:04 - examples and exercises so you're not
05:06 - going to get bored with fluff content
05:09 - all right now that we're on the same
05:10 - page our next step is setting up our
05:12 - testing
05:18 - environment all right let's talk about
05:19 - setting up our testing environment first
05:22 - head over to nodejs.org and download the
05:25 - latest version of note now in this
05:27 - course just like my other courses I'll
05:30 - be using visual studio code or vs code
05:32 - as my editor you're welcome to use your
05:34 - preferred editor but in this course I'm
05:36 - going to show you a ton of shortcuts for
05:38 - increasing your productivity so while
05:41 - not necessary I recommend you to
05:43 - download and install Visual Studio
05:47 - [Music]
05:49 - code all right before we move on to the
05:51 - next section I want you to download the
05:53 - starter project I have created for this
05:55 - course so head over to github.com
05:59 - - hamadani here go to
06:02 - repositories and search for JavaScript D
06:06 - testing here we have two repositories
06:09 - the started project and the finished
06:11 - project the finished project contains
06:13 - the solution to all the exercises I have
06:15 - created for you so let's start with the
06:18 - starter
06:19 - project then go to
06:22 - code clone this URL next open a terminal
06:26 - window and run get clone followed by the
06:28 - URL
06:30 - all right good so here we have this
06:32 - folder JavaScript testing starter just
06:35 - open this with vs code and you're good
06:38 - to
06:41 - go welcome back to another section of
06:44 - unit testing JavaScript course this
06:46 - section is going to be your gateway to
06:48 - the world of unit testing we'll kick
06:50 - things off by talking about what is unit
06:52 - testing what are its benefits and what
06:55 - are common arguments against it then
06:58 - we'll talk about different types of
07:00 - tests we encounter in real world
07:02 - applications once we've got the theory
07:04 - covered we'll talk about the tooling
07:06 - we'll explore various testing Frameworks
07:08 - out there in this course we'll be using
07:10 - Vest which is a relatively new testing
07:13 - framework that has gained popularity but
07:15 - the concepts you will learn in this
07:17 - course apply to other testing Frameworks
07:19 - like just as well so next we'll set up v
07:22 - test and write our first unit tests you
07:24 - will see unit testing and its benefits
07:26 - in action then I will introduce you to
07:28 - the con concept of test driven
07:30 - development or tddd we'll talk about the
07:33 - benefits as well as a few misconceptions
07:35 - about tdd next I will show you various
07:38 - ways to run your tests efficiently this
07:40 - is a key skill you need to have
07:42 - especially when you deal with broken
07:44 - tests you should be able to quickly
07:46 - filter your tests and focus on one or a
07:48 - few at a time now every season developer
07:51 - is expected to know how to navigate
07:53 - their code base quickly and smoothly so
07:56 - I will show you various shortcuts in vs
07:58 - code to navigate your tests and
08:00 - production code last but not least we'll
08:02 - wrap up this section by talking about
08:04 - code coverage which is a metric that
08:07 - shows how much of our code is tested
08:09 - this is a great introduction to unit
08:11 - testing so let's jump in and get
08:15 - [Music]
08:23 - started so what exactly is unit testing
08:26 - well unit testing is a form of automat
08:29 - testing where we write code to check if
08:32 - our code works as expected here's an
08:34 - example imagine we have a function for
08:37 - calculating the monthly loan payment now
08:40 - if we were to test this function
08:41 - manually we would have to launch our
08:43 - application possibly login navigate to a
08:46 - particular page fill out a form submit
08:49 - it and then check if the result is
08:51 - calculated correctly as you can see this
08:54 - is pretty time consuming this is where
08:57 - automated testing comes to the rescue we
08:59 - can write some code to directly call
09:01 - this function with various inputs and
09:04 - check if it Returns the correct result
09:06 - we execute this code using a program
09:08 - called a test Runner which displays test
09:11 - results in the console or terminal
09:13 - window if a test passes we see a green
09:16 - tick otherwise we see a red cross using
09:19 - this technique we can run hundreds or
09:21 - even thousands of tests in just a few
09:23 - seconds clearly this is much faster than
09:26 - manual testing through the user
09:28 - interface with automated testing our
09:30 - code base consists of two types of code
09:34 - the application code also known as
09:36 - production code and the test code or
09:39 - tests once we have a suite of tests we
09:41 - can run them every time we make changes
09:44 - to our code and this brings us a bunch
09:46 - of benefits firstly unit tests help us
09:50 - identify and fix bugs early in the
09:52 - development process long before they
09:54 - become nasty surprises in production
09:57 - there have been many studies that show
09:59 - that that the later we find and fix a
10:01 - bug in the development process the
10:03 - costlier it is for the business for
10:05 - example fixing a bug after deploying the
10:08 - software can be up to five times more
10:10 - expensive than during the coding phase
10:13 - secondly unit testing helps us refactor
10:16 - our code with confidence refactoring
10:18 - means changing the structure of our code
10:21 - without changing its Behavior or
10:23 - functionality for instance we can
10:25 - extract a few lines of code and put them
10:28 - into a separate function we're changing
10:30 - the structure of the code but not its
10:32 - functionality with unit tests every time
10:35 - we refactor our code we can run our
10:37 - tests to quickly confirm if our code
10:40 - still behaves as expected thirdly
10:43 - writing unit tests encourages us to
10:45 - consider various edge cases and error
10:47 - conditions and this leads to more robust
10:50 - and reliable code and lastly unit tests
10:53 - serve as documentation for how our
10:56 - functions should behave and this makes
10:58 - it easier for others to understand and
11:01 - maintain a project now despite these
11:03 - benefits we have developers with very
11:06 - strong opinions like our famous
11:08 - superstar developer Mr John Smith who is
11:11 - skeptical about unit testing he proudly
11:14 - claims that in his 20 years of software
11:16 - engineering he's been writing bug free
11:18 - code without ever writing a single unit
11:21 - test on the other side of the spectrum
11:23 - we have other developers like test Smith
11:26 - who are obsessed with writing test and
11:27 - say every line of your code should be
11:30 - covered by tests so who's right well in
11:33 - my opinion both of these viewpoints are
11:35 - extreme and can be costly for a business
11:38 - having no unit test at all and relying
11:41 - solidly on manual testing can be very
11:43 - timeconsuming especially as our
11:45 - application grows in size and complexity
11:48 - on the other hand covering every line of
11:50 - code with tests can also be very
11:52 - expensive we always have time and
11:54 - resource constraints so next time you
11:57 - encounter one of these folks with strong
11:59 - opinions don't get caught up in their
12:01 - debate instead be pragmatic and find a
12:04 - good balance that works for your project
12:07 - keep in mind that every project is
12:08 - unique new projects with rapidly
12:11 - evolving requirements might not be the
12:13 - best candidate for extensive unit
12:15 - testing because as the requirements
12:17 - change some of your tests may break and
12:19 - you end up spending more time fixing
12:22 - broken tests than delivering actual
12:24 - features however if your project is more
12:27 - established and certain features have
12:29 - stable requirements it's a good idea to
12:32 - write a suite of tests to ensure that at
12:34 - least the critical modules continue to
12:37 - work as expected this way whenever you
12:40 - make changes to those modules you can
12:42 - run your tests to get immediate feedback
12:45 - if you have broken something or not in
12:47 - reality unit testing is an investment in
12:50 - software quality like any investment it
12:53 - can be fruitful or go wrong if you skip
12:55 - writing tests entirely you will rely
12:57 - solely on manual testing and this will
13:00 - get increasingly costly over time on the
13:03 - other hand writing poor tests that
13:05 - produce inaccurate results and fail to
13:08 - give you real feedback about your codes
13:10 - reliability is a waste of time so just
13:13 - like how you should wisely invest your
13:15 - money you should also use your time
13:17 - wisely when writing tests you should
13:19 - write good tests that are maintainable
13:22 - robust and trustworthy and that's what
13:24 - I'm going to teach you in this course if
13:26 - your tests are not maintainable r and
13:29 - trustworthy they offer no value they get
13:32 - in the way and slow you down it's better
13:34 - not to write them at all all right next
13:36 - we're going to talk about different
13:38 - types of
13:43 - tests in automated testing we have three
13:46 - types of tests unit tests integration
13:49 - tests and endtoend tests so what are the
13:52 - differences well unit tests verify the
13:55 - correctness of individual units or
13:58 - components of an application in
14:00 - isolation these units could be functions
14:02 - classes or even small modules these
14:05 - tests are incredibly useful for catching
14:07 - bugs early in the development process
14:10 - integration tests focus on verifying how
14:13 - different units or components of your
14:15 - application work together as a whole
14:18 - they help you identify issues that might
14:20 - arise when combining different units
14:22 - such as data flow problems communication
14:24 - between modules and compatibility issues
14:27 - between components and tests are the
14:30 - broadest type of tests focusing on
14:32 - testing the entire application as a
14:34 - whole they simulate real user
14:36 - interactions with the entire system from
14:38 - the user interface down to the backend
14:40 - Services they're excellent for ensuring
14:43 - that our entire application works
14:44 - seamlessly from the user's perspective
14:47 - now a common question that I get is what
14:49 - types of tests should we write well the
14:52 - classic recommendation is to have more
14:54 - unit tests than integration tests and
14:57 - more integration tests tests than
14:59 - endtoend tests this is referred to as
15:01 - the testing pyramid however this is just
15:04 - a suggestion it doesn't mean you should
15:06 - follow it religiously because every
15:08 - application is different in some cases
15:11 - it may make more sense to have more
15:13 - integration tests or more endtoend tests
15:16 - there is no one siiz fits all in
15:18 - software engineering anyone who tells
15:20 - you there is only one way to do
15:22 - something and that's the best way
15:24 - they're either selling you something or
15:26 - they haven't been around long enough so
15:28 - when designing a testing strategy for
15:30 - your application consider the complexity
15:33 - of your application's code as well as
15:34 - your time and resources to come up with
15:37 - a suite of tests that give you the most
15:39 - value but there is one thing crucial you
15:42 - need to understand about the testing
15:44 - pyramid as we go up this pyramid in
15:46 - other words as we test more units of our
15:49 - code together our tests will be slower
15:51 - but they will give us more confidence in
15:53 - the reliability of our application so
15:56 - end to1 tests give us the highest
15:58 - confidence but they're significantly
16:00 - slower running them every time we change
16:02 - or refactor our code isn't always
16:04 - feasible this is where unit tests come
16:07 - into play unit tests are incredibly fast
16:10 - so we can run them every time we change
16:12 - or refactor our code to get immediate
16:14 - feedback if you have broken something so
16:17 - all these types of test are valuable
16:20 - it's hard to determine which type has
16:22 - more value it's like debating what type
16:24 - of shoes is more valuable dress shoes or
16:26 - running shoes well it depends where you
16:28 - want to go so don't listen to folks with
16:30 - strong opinions on social media saying
16:32 - things like unit tasks are a waste of
16:34 - time and they only write end to and
16:36 - tests well good for them anyway in this
16:39 - course our focus is entirely on unit
16:41 - testing so you don't need to worry about
16:43 - integration and end to end tests at this
16:46 - point in the second part of this series
16:48 - where we will look at testing react
16:49 - applications we'll talk about
16:51 - integration
16:57 - tests so I mentioned earlier that we
17:00 - need a test Runner to execute our tests
17:03 - now this is where testing Frameworks
17:04 - come into the picture a testing
17:06 - framework is a set of tools for writing
17:09 - and running tests it typically includes
17:11 - a test runner for executing tests
17:14 - assertion libraries to check if the code
17:17 - behaves as expected mocking tools to
17:19 - replace certain modules with Fakes
17:22 - simulating different scenarios test
17:24 - coverage tools for measuring how much of
17:26 - the code is tested and many other tools
17:29 - now there are several testing Frameworks
17:31 - out there like just mocha Jasmine vest
17:35 - Cypress playwright and many many more
17:38 - all these Frameworks work more or less
17:40 - the same way so once you get the hang of
17:43 - one you can easily pick up other
17:45 - Frameworks among these just is the most
17:48 - widely adopted and used in many projects
17:51 - however there is a little catch with
17:53 - just it's an older framework and its
17:55 - support for Eos script modules or n
17:58 - native JavaScript modules is still
18:00 - experimental so setting up things can be
18:03 - a little bit awkward so in this course
18:05 - we're going to take a different route
18:07 - we'll be using Vest which is a new
18:09 - testing framework designed for modern
18:11 - JavaScript it has all the Fantastic
18:13 - features of Gest as well as outof thee
18:16 - boox support for econ script modules
18:18 - typescript and jsx which is used in
18:21 - react plus its API is almost identical
18:24 - to just so everything you learn about
18:26 - vest in this course will will be
18:28 - directly applicable to just as
18:35 - well all right now we're ready to set up
18:37 - vest so I have opened our starter
18:40 - project in vs code now we need to open a
18:42 - terminal window to install vest so on
18:45 - the top Under The View menu let's go to
18:48 - terminal look at the shortcut it's
18:50 - control and back
18:52 - tick so here we're going to use npm to
18:56 - install vest as a development
18:58 - dependency because we don't want to
19:00 - deploy our test tools with our
19:02 - application so we always install them as
19:04 - development dependencies so let's
19:06 - install
19:08 - vest lovely now we need to go to our
19:12 - package Json file and create a test
19:15 - script so here in the scripts object we
19:19 - add a new key value paent called test
19:23 - and set it to vest now whenever we run
19:26 - npm test v test will execute our tests
19:30 - so if you go back to the terminal and
19:31 - run npm test or npm t v test will
19:36 - execute our tests now currently we don't
19:38 - have any test files that is why we get
19:40 - this error in the next lesson we're
19:42 - going to create our first
19:45 - [Music]
19:48 - test all right we're going to write our
19:50 - first test so here in the source folder
19:53 - we have a module called intro in this
19:55 - module we have all the code we're going
19:57 - to use in this section ction so here we
19:59 - have a function for getting the max of
20:01 - two numbers pretty basic if a is greater
20:04 - than b it returns a otherwise if B is
20:07 - greater it returns B otherwise if
20:10 - they're equal it returns a I know this
20:12 - is not the best way to write this
20:13 - function this is deliberate once we
20:16 - cover this function with tests we'll
20:17 - come back and refactor it into a more
20:19 - elegant implementation so to test this
20:23 - we're going to go in the root of our
20:24 - project next to the source
20:26 - folder we create cre a new folder called
20:30 - test and here we create a test file for
20:34 - the intro module so we call it intro.
20:37 - test.js this is the pattern that vest or
20:41 - just looks for so vest by default pixel
20:44 - files that have test in their name and
20:46 - of course this can be configured okay
20:49 - now in this file we're going to import a
20:52 - few functions from vest one of them is
20:55 - describe for creating a test Suite TW or
20:58 - a group of related tests the other one
21:01 - is test for creating a test case there
21:04 - is also another function that does the
21:05 - same job it's called it we'll talk about
21:08 - it momentarily and one more function
21:10 - that is
21:11 - expect so first we call the describe
21:14 - function to create a test Suite or a
21:17 - group of related tests we give it two
21:20 - arguments the first argument is a string
21:23 - that is the name of our test Suite
21:25 - typically we use the name of the
21:27 - function or the unit under test in this
21:30 - case Max the second argument is a
21:33 - function that will be called by our test
21:35 - runner in this case v test so here we
21:38 - pass an eror function now in this block
21:42 - or in this test Suite we Define one or
21:45 - more test cases so we call test or it it
21:49 - doesn't matter it's a matter of personal
21:51 - preference now just like the describe
21:53 - function here we need two arguments the
21:56 - first argument is a string that
21:58 - represents our test name so look here we
22:01 - want to test a scenario where a is
22:04 - greater than b so to name this test here
22:08 - we can pass a string like should return
22:11 - the first argument if it is greater now
22:16 - look the reason Some people prefer to
22:18 - use the it function is because the test
22:21 - case reads like it should return the
22:23 - first argument if it's greater very
22:26 - clear so always pay great attention to
22:28 - naming your tests I've seen some people
22:30 - naming their test like test one test two
22:32 - don't do that because over time it's not
22:35 - going to be clear what is the purpose of
22:37 - these tests so always treat your tests
22:40 - as first class citizens your test code
22:42 - is as important as your production or
22:45 - application code okay so here's a test
22:48 - name now the second argument should be a
22:50 - function that will be executed by our
22:53 - test runner in this case v test once
22:55 - again we pass an arrow function
22:59 - now in this test we typically structure
23:01 - our test using the AAA pattern that is
23:05 - short for arrange act and assert this is
23:09 - a pattern that a lot of people follow
23:11 - when organizing their tests in the
23:13 - arrange phase we set up our test
23:15 - environment including any necessary data
23:18 - or configurations in the ACT phase we
23:21 - perform the action we want to test and
23:23 - in the assert phase we check the outcome
23:26 - to ensure that it matches our expect
23:27 - expectations let me give you a real
23:29 - example imagine we want to test that a
23:32 - TV can be turned off in the enrange part
23:36 - first we turn on the
23:37 - TV in the ACT part we press the power
23:42 - button and in the assert part we verify
23:45 - that the TV is
23:47 - off okay now we can take this analogy
23:50 - and apply it to our tests so in the
23:53 - arrange part first we declare two
23:56 - variables or two constants we can call
23:59 - them A and B we set a to 2 and B to 1
24:04 - now these are arbitrary values we could
24:06 - use 20 and 10 we could use 10 and 9 it
24:09 - doesn't matter what matters is that we
24:11 - want the first argument to be greater
24:14 - now in the ACT phase we perform the
24:16 - action we want to test in this case we
24:19 - call the max function that is defined in
24:22 - this module so let's press enter the max
24:25 - function is imported on the top now we
24:27 - pass our arguments A and B get the
24:31 - result and store it
24:33 - here now finally in the assert
24:36 - phase we verify that the result is
24:39 - correct to do that first we call the
24:41 - expect function of v test and by the way
24:44 - just has the same functions and they
24:46 - work exactly the same way so we call
24:49 - expect and pass result now this returns
24:52 - an expectation object in this object we
24:55 - have a bunch of methods that start with
24:57 - is two these are called matchers we use
25:00 - these to verify expectations for example
25:03 - we have to be to be called to be defined
25:06 - to be falsy to be greater than and so on
25:09 - as we go through the course you're going
25:11 - to get familiar with these matches in
25:13 - this lesson we're only going to use the
25:15 - to be matcher so we expect the result to
25:18 - be two this is how we structure our test
25:22 - now we don't necessarily have to add
25:24 - these
25:26 - comments we can use a vertical line
25:28 - Breck to separate these sections this
25:31 - way it's immediately visible that the
25:33 - first part is the range part the second
25:36 - part is the act part and so on now for
25:39 - simple cases we don't even have to have
25:41 - all these parts or all these faces we
25:43 - can combine them to make our test more
25:45 - concise for example we don't need to
25:47 - declare these two constants because
25:50 - they're only used on this line so we can
25:52 - replace a and b with their literal
25:56 - values now we don't need the arrange
25:58 - part and similarly we can combine these
26:00 - two lines into a single line so we
26:04 - replace result with a call to the max
26:08 - function now our test has a single line
26:10 - of code so back in the terminal let's
26:13 - run npm test or npm
26:16 - t all right we have one passing test
26:19 - beautiful and look the test name clearly
26:22 - identifies the scenario we're testing
26:25 - now back in our test if I change this
26:28 - value to one now back in the terminal
26:31 - look now we have a failing test and the
26:34 - failure is happening on line six of this
26:37 - module so the test expected one but it
26:41 - received two so back to our test let's
26:44 - change it back to two all right that was
26:47 - our first test case now we need two more
26:50 - test cases for scenarios where the
26:52 - second argument is greater and also the
26:55 - scenario where our arguments are equal
26:57 - so I'm going to duplicate these few
27:02 - lines so here's what we have so far in
27:05 - this test Suite we have two test cases
27:07 - now let's change the name of the second
27:09 - test and here we say it should return
27:12 - the second argument if it's greater now
27:15 - let's swap the order of these arguments
27:19 - back in the terminal now we have two
27:21 - passing tests in one test file and one
27:25 - more test case
27:29 - I'm going to say it should return the
27:32 - first argument if arguments are equal so
27:38 - here we can pass one and one and expect
27:41 - the result to be one now take a look now
27:46 - we have three passing tests and all
27:48 - these tests were executed in 8
27:51 - milliseconds imagine if you wanted to
27:53 - test this function through the UI
27:55 - perhaps we have to do a few clicks
27:57 - perhaps we had to fill out a form
27:59 - obviously we could never do this in 8
28:01 - milliseconds right it would take several
28:03 - seconds but we are not done yet now that
28:06 - we have fully covered this function with
28:08 - tests let's refactor it with confidence
28:11 - so we're going to replace these three
28:13 - lines with an expression like this
28:16 - return if a is greater than b return a
28:19 - otherwise return B back in the terminal
28:23 - look our tests are still passing this is
28:26 - the beauty of unit test they give us
28:28 - immediate feedback if we have broken
28:30 - something during our refactorings
28:32 - however if you go back here and let's
28:34 - make it deliberate mistake let's return
28:37 - a in both cases now look one of our
28:40 - tests failed and that is this particular
28:45 - test should return the second argument
28:47 - if it's greater so we expected to get
28:50 - two but we received one so let's go back
28:53 - and fix the
28:55 - arrow all right so that's that was our
28:57 - first test now as we go through the
28:59 - course we're going to look at more
29:01 - complicated and real word
29:05 - [Music]
29:08 - examples all right here's your exercise
29:11 - in the same module we have a function
29:13 - called fsus it's a very popular function
29:16 - that comes up in coding interviews so
29:18 - this function receives a number if the
29:21 - number is divisible by three and five it
29:24 - returns fizzbuzz if it's only divisible
29:27 - by three it returns Fizz if it's only
29:29 - divisible by five it returns Buzz
29:32 - otherwise if the number is not divisible
29:34 - by three or five it returns that number
29:37 - as a string now as your exercise I want
29:40 - you to cover this function with tests
29:42 - now to give you a hint when writing test
29:44 - for a function you should cover all the
29:46 - execution paths so here we have four
29:49 - execution paths here's the first one
29:52 - second third and fourth spend 5 to 10
29:55 - minutes on this and then come back see
29:57 - my my
30:01 - solution so back to our test file here
30:04 - we have a test suite for the max
30:06 - function now we need to Define another
30:10 - suite for testing the fsbos function so
30:14 - we call
30:15 - describe and pass
30:19 - fizzbuzz now here we have a scenario
30:23 - where the argument is divisible by three
30:25 - and five so
30:28 - it should return fiz buzz if argument is
30:34 - divisible by three and five I'm going a
30:37 - little bit faster because I'm assuming
30:39 - you have done your exercise then we pass
30:42 - an aror
30:44 - function now once again here we don't
30:46 - need to have separate arrange act and
30:49 - assert faces we can combine all of them
30:51 - into a single line because our test is
30:53 - very simple so we call
30:56 - fboss and and give it a number like
30:59 - 15 then we make an assertion and check
31:03 - to see if the
31:05 - result is Fizz
31:09 - bu now back in the terminal beautiful we
31:12 - have four passing tests now to make sure
31:15 - that we're testing the right thing let's
31:17 - change this to
31:19 - Fizz now we have one failing test lovely
31:23 - so let's revert it back to Fizz boss
31:26 - this is a very simple and useful
31:28 - technique to ensure that you're testing
31:30 - the right thing because sometimes your
31:32 - test might pass but it might not be
31:34 - testing the right thing or even the
31:35 - right function so always make a tiny
31:38 - change to make sure that your test and
31:40 - production code are in sync another way
31:42 - to go about this is by modifying the
31:44 - production code so instead of changing
31:47 - the test code we can go back to the
31:49 - production code and create a bug so here
31:52 - we can add an exclamation mark and now
31:55 - look we have one failing test so this
31:58 - verifies that our test code and
32:01 - production code are in sync in other
32:03 - words our test is actually testing this
32:06 - function because otherwise let me show
32:08 - you an exaggerated example let's imagine
32:11 - instead of calling 2B we had a call to
32:15 - to be
32:16 - defined so we're checking that the value
32:19 - that is returned from this function is
32:21 - defined with this test now our test
32:25 - always
32:26 - passes even though we have a bug in our
32:28 - production code if we make any changes
32:31 - here our test still passes so this shows
32:33 - that we are not testing the right thing
32:36 - this is what we call a false positive so
32:38 - our test always passes giving us an
32:40 - illusion that our code works we can also
32:43 - have false negatives tests that always
32:45 - fail even though there's no bug in our
32:48 - production code so this technique is
32:50 - very useful to prevent false positives
32:52 - and false negatives you want to make
32:54 - sure that our test code and production
32:56 - code are inan think or in other words
32:58 - we're testing the right thing so let me
33:02 - bring
33:03 - back the 2B match and compare the result
33:07 - with fiz
33:08 - Buzz okay now we have a failing test
33:11 - lovely so let's go back and fix the
33:17 - bug good so we're done with the first
33:20 - test case now let's move on to the
33:22 - second test case so I'm going to
33:24 - duplicate these few lines
33:27 - this time we say that our function
33:29 - should return fiz if argument is only
33:35 - divisible by
33:36 - three so we can pass three or 6 or 9 it
33:40 - doesn't really matter let's compare it
33:44 - with
33:45 - fizz we have one passing test now to
33:48 - make sure that we're testing the right
33:50 - thing again we can go back to our
33:52 - production code and make a tiny change
33:55 - here
33:58 - there you go now we have a failing test
34:00 - so our test and production code are in
34:02 - sync now we need two more test cases so
34:06 - let's duplicate this test and change the
34:09 - name to it should return buzz if
34:12 - argument is only divisible by five so
34:16 - here we pass Five and compare the result
34:18 - with
34:20 - Buzz one more passing test and the last
34:24 - test case it should return
34:27 - argument as a string if it's not
34:32 - divisible by three or
34:37 - five okay so let's pass let's say one
34:42 - and here we expect to get one as a
34:45 - string seven passing test but if you
34:48 - pass one as a number now we have a
34:51 - failing test okay so let's revert it
34:54 - back beautiful we're done with this
34:56 - lesson next we're going to talk about
34:58 - test driven
35:00 - [Music]
35:04 - development there are two ways to write
35:06 - tests code first or test first code
35:10 - first is what we have been doing so far
35:12 - we write the application code first and
35:15 - then we cover it with tests test first
35:17 - is the opposite we start with tests and
35:20 - then we produce the application code
35:22 - this approach is also called test driven
35:24 - development or tdd TD CD is a way of
35:27 - building software it follows a simple
35:30 - effective three-step cycle we start by
35:32 - writing a failing test and then we write
35:35 - just enough code to make the test pass
35:38 - then if necessary we refactor our code
35:40 - while ensuring that all tests still pass
35:43 - and then we repeat let's see this in
35:45 - action so let's imagine we want to
35:47 - create a function for calculating the
35:49 - average of values in an array so we
35:52 - start by writing a failing test so back
35:54 - to our test file first we create a new
35:57 - test Suite let's call this calculate
36:03 - average now here we start with a test
36:06 - case for an empty array let's say that
36:09 - if we pass an empty array to this
36:11 - function we expect to get not a number
36:14 - so it should return not a number if
36:18 - given an empty
36:23 - array now first we need to create this
36:25 - function so back to to our intro module
36:28 - we Define a function called calculate
36:32 - average that takes an area of numbers
36:36 - and then export it from this module so
36:38 - we're not going to implement this yet we
36:40 - just have the Declaration of the
36:42 - function now back to our test so we call
36:45 - calculate average and give it an empty
36:49 - array and then expect the result to be
36:53 - not a
36:55 - number okay back in the terminal look we
36:58 - have a failing test because we expected
37:02 - not a number but we received undefined
37:05 - because in JavaScript all functions by
37:08 - default return undefined unless we
37:10 - explicitly return a value so to make
37:13 - this test pass we go back to our intro
37:15 - module and write the simplest
37:17 - implementation possible so we return not
37:21 - a number now we have one passing test
37:25 - beautiful that was one cycle now we need
37:28 - to repeat this with other test cases so
37:32 - as our second test
37:35 - case we're going to call this function
37:38 - and give it an array with a single
37:40 - element so we can change the test name
37:44 - to should calculate the average of an
37:49 - array with a single element so we call
37:53 - it and give it an array with just one
37:56 - and expect the result to be one now look
38:01 - again we have a failing test so we have
38:03 - to write just SE of code to make this
38:05 - test pass so back to the intro module
38:08 - now we can say if numbers the length
38:12 - equals zero then we return another
38:16 - number otherwise we return numbers of
38:20 - zero obviously this logic is still
38:23 - immature but we're going to enhance it
38:25 - with more test cases
38:27 - so back in the terminal now we have nine
38:30 - passing test so we completed one more
38:32 - cycle now let's write another test case
38:34 - for an array with two elements so back
38:37 - to our test file let's duplicate this
38:40 - test case and say it should calculate
38:44 - the average of an array
38:47 - with two elements so if we pass one and
38:51 - two we expect the average to be 1 and
38:54 - half now look
38:57 - again one failing test so we go back to
39:00 - our intro module and write the simple
39:03 - logic here we can use a for Loop to
39:06 - iterate over this array and calculate
39:08 - the total of all values or we can use
39:10 - the reduce method so here we call
39:13 - numbers do
39:16 - reduce and give it an arrow function
39:19 - this function should have two parameters
39:22 - the first parameter is an accumulator or
39:25 - a variable that con contains the total
39:27 - value we can call it total or sum that's
39:30 - better the second parameter holds the
39:33 - current value one value at a time in
39:35 - this array so we can call it current now
39:39 - in the body of this function we simply
39:41 - add current to sum so we return sum plus
39:46 - current so this function is the first
39:48 - argument to the reduce method now as the
39:51 - second argument we need to provide the
39:53 - initial value for the sum so we we
39:56 - initialize it to zero now with this we
39:59 - get the sum of all numbers in this array
40:03 - and finally we can divide sum by
40:07 - numbers. length now back in the terminal
40:11 - all our tests are passing lovely so
40:13 - let's write one more test case this time
40:15 - we want to pass an array with three
40:20 - elements so if you pass 1 2 and
40:24 - three the average should be to now look
40:28 - all right all our tests are passing so
40:30 - this was tdd in action we started by
40:33 - writing tests and as a result we
40:36 - produced this function now the beautiful
40:38 - thing about tdd is that it produces
40:41 - production code that is 100% covered by
40:43 - tests so here we don't have any
40:45 - execution paths that we haven't tested
40:47 - the current implementation of this
40:49 - function is fully covered by tests if
40:52 - the implementation is not complete yet
40:54 - we can add other test cases to drive the
40:56 - development the other great thing about
40:58 - tdd is that it prevents us from over
41:01 - engineering because our focus is on
41:03 - rating the simplest logic to make the
41:05 - tests pass and we can always refactor
41:08 - and refine our implementation what
41:10 - matters is that we are not over
41:12 - engineering ahead of time so these are
41:15 - the benefits of tddd but in practice tdd
41:17 - can be difficult especially for new
41:19 - Learners so in this course our Focus
41:22 - will be on the code first approach but
41:24 - as you learn unit testing you can
41:26 - challenge yourself and start exploring
41:28 - tdd first it might be difficult
41:31 - especially in more complex applications
41:33 - but trust me over time with practice it
41:36 - gets easier and easier now I just want
41:38 - to clarify something here tdd as a
41:40 - philosophy is great but it doesn't mean
41:42 - that you should always write tests using
41:44 - this approach I know that there are some
41:46 - folks that are fanatic about tdd and
41:48 - they say you're not a developer if you
41:49 - don't use tdd but again this is one of
41:52 - those extremely radical viewpoints if
41:54 - you don't like tdd or if you prefer to
41:57 - write tests after the production code
41:59 - that is perfectly fine again there is no
42:02 - one-size fitall in software engineering
42:04 - every project every team is different so
42:06 - always use the approach that works for
42:08 - you and your
42:14 - projects now as your exercise I want you
42:17 - to implement the factorial function
42:19 - using tdd we have all studied factorial
42:22 - at school in math now to refresh your
42:24 - memory the factorial of an number is the
42:27 - product of all positive numbers from one
42:30 - to that number here are a few examples
42:32 - so factorial of 0 is 1 factorial of 1 is
42:36 - 1 factorial of 2 is 2 * 1 factorial of 3
42:42 - is 3 * 2 * 1 so write a test case for
42:46 - each of these scenarios and then
42:48 - implement the factorial
42:54 - function all right so we start start by
42:57 - creating a new test Suite called
43:03 - factorial first we write a test case for
43:06 - the factorial of zero so should return
43:10 - one if given
43:15 - zero now first we need to create the
43:18 - factorial function so back to our intro
43:20 - module we export a function called
43:25 - factorial
43:26 - that takes a number and we leave out the
43:30 - implementation now back to our test we
43:33 - call
43:34 - factorial and give it zero and then we
43:37 - expect the result to be
43:40 - one back in the terminal obviously we
43:43 - have a failing test so to make this test
43:46 - pass we go back to our intro module and
43:49 - return
43:51 - one all right our test is passing now
43:54 - the second test case so we duplicate
43:59 - this and change the test name to it
44:02 - should return one if given
44:07 - one our tests are still passing lovely
44:11 - so let's add another test
44:14 - case should return
44:17 - two if given
44:22 - two now back to our function here we
44:26 - need a bit of logic we can check if n
44:29 - equals
44:30 - 0
44:32 - or 1 then we return one otherwise we can
44:38 - do a trick we can just return two we
44:40 - hard Cod this value and our tests are
44:43 - still passing so what I want to
44:45 - emphasize here is that we want to write
44:47 - just a little bit of code to make our
44:49 - test pass we want to do baby steps we
44:51 - don't want to have a big step where we
44:53 - write a lot of logic because that can
44:55 - lead to over engineering ing so our
44:57 - tests are still passing so let's add
45:00 - another test
45:02 - case should return six if given
45:07 - three so factorial of three should be
45:11 - six now one of our tests is failing so
45:15 - we go back to our factorial function and
45:17 - this is where we make another step so
45:20 - instead of hard coding two or six we
45:22 - implement the actual logic here we can
45:24 - use recursion so we multiply n by
45:28 - factorial of n
45:31 - -1 all our tests are passing lovely
45:35 - let's add one more test
45:37 - case what if we pass
45:40 - four factorial of four should be
45:47 - 24 all right all our test are still
45:50 - passing beautiful now what if we pass a
45:53 - negative number well that's one of the
45:55 - areas that is is debatable but we can
45:57 - say that factorial of negative numbers
46:00 - is undefined so we write another test
46:03 - case
46:05 - here and say it should return
46:10 - undefined if given a negative number so
46:16 - we pass -1 and expect the result to be
46:20 - undefined now we also have a separate
46:22 - matcher function here that is to be un
46:25 - defined we can also use this back to the
46:29 - terminal one of our tests is failing so
46:31 - back to our factorial function let's add
46:34 - another if statement and say if n is
46:37 - less than zero then return
46:42 - undefined all our tests are passing
46:44 - lovely now I just want to clarify
46:46 - something here as part of writing tests
46:49 - whether we go with the code first or the
46:51 - test first approach we don't want to
46:52 - test against all possible numbers in the
46:54 - world because that is is Not Practical
46:56 - so we don't want to test a factorial
46:58 - function with a million different
46:59 - numbers we want to have enough numbers
47:01 - in different ranges like zero positive
47:05 - negative as long as we have a few
47:06 - different test cases for different
47:08 - scenarios that is
47:11 - sufficient all right what's next well if
47:13 - you want to learn more I have a
47:15 - comprehensive JavaScript unit testing
47:17 - course on my website what you have
47:19 - watched is the first 40 minutes the full
47:21 - course is 4 hours long and goes Way
47:24 - Beyond the basics we'll talk talk about
47:26 - various techniques for writing effective
47:28 - tests that are robust maintainable and
47:30 - trustworthy we'll talk about positive
47:33 - and negative testing boundary testing
47:35 - writing parameterized tests testing
47:38 - asynchronous code and using marks and
47:40 - spies to isolate code during tests we'll
47:43 - also have a section on improving code
47:45 - quality using static analysis tools
47:48 - we'll talk about formatting code with
47:50 - prier linting it with es lint catching
47:53 - type errors with typescript and
47:55 - automating code quality checks with
47:57 - Husky so by the end of the course you
47:59 - will have a strong foundation in unit
48:01 - testing and we'll be ready to learn
48:03 - about testing frontend applications like
48:05 - react the full course is packed with a
48:08 - ton of exercises so you can practice
48:10 - what you will learn and the best part is
48:12 - that it comes with a certificate of
48:14 - completion and a 30-day money back
48:16 - guarantee so if you're not satisfied
48:18 - just ask for a refund if you're
48:20 - interested use the link below this video
48:21 - to enroll I hope to see you in the
48:23 - course thank you and have a great day
48:27 - [Applause]
48:30 - up

Cleaned transcript:

welcome to mastering JavaScript unit testing in this comprehensive 4Hour course I will take you on an exciting Journey where we will explore everything you need to know about unit testing from the very Basics to more Advanced Techniques if you're looking for a comprehensive easy to follow well organized and practical course that takes you from Zero to Hero this is the right JavaScript unit testing course for you this course is packed with real world examples and a ton of HandsOn exercises giving you plenty of opportunities to practice what you learn by the end of this course you'll have a strong foundation in unit testing you'll be able to significantly reduce bugs and improve the overall quality of your code this expertise will set you apart in the world of software development opening doors to exciting opportunities and challenges so if you're ready to unlock the full potential of JavaScript unit testing and elevate your coding skills join me in this exciting Journey I'm msh hamadani a software engineer with over 20 years of experience and I've taught Millions how to code and become professional software Engineers through my YouTube channel and online school CWI mar.com if you're new here make sure to subscribe as I upload new videos all the time now let's jump in and get started now to take this course you don't need any familiarity with unit testing at all in fact fact I've designed this course specifically for people who have never done unit testing because they find the idea intimidating so I'm going to teach you everything from the ground up but to take this course you should have a basic understanding of modern JavaScript that means you should be comfortable with Concepts like importing and exporting promises acing can weight and so on if you need to brush up on any of these Concepts check out the JavaScript series on my website so that's all about the prerequisites next we're going to talk about the course structure all right now let's talk about how I've structured this course this course serves as the rock solid foundation for unit testing in JavaScript applications however I want to clarify something up front we won't be testing a front end or a backend here because our primary focus is on nailing those fundamental unit testing Concepts and best practices that often get overlooked in many other courses this is where a lot of folks stumble when it comes to unit testing they rush into testing react or node without grasping the essential foundations and best practices so in this course my goal is to equip you with a robust Foundation once you have completed this course you'll be well prepared to tackle my other courses on testing react or Noe now here's our road map for this course we'll kick things off by getting you familiar with the basics of unit testing so in the first section we'll cover what unit testing is what are its benefits and what are the common arguments against it then we'll see unit testing in action you will learn how to write basic tests and run them next up we'll delve deeper into core unit testing techniques and best practices we'll cover Concepts like positive and negative testing boundary testing parameterized testing and so on then we'll explore how to use mocks or fakes to isolate our code during tests this is a very important technique used in unit testing in the final section we'll explore some handy static analysis tools like eslint prier and typescript these tools help you elevate the quality of your code and reduce the need for extensive test cases once you finish this course you'll have a rock solid foundation for testing JavaScript code if your goal is to write JavaScript libraries you can take what you learn in this course and use it to test your libraries if you're a front and developer and want to learn how to test react applications I've got you covered I'm planning to create a dedicated course on the topic and Chances Are by the time you're watching this course my react testing course is already published as for backend testing I've covered it in my note course so at this point I'm not planning to create a separate course on the topic all right now let's talk about how to make the most of this course if you're brand new to unit testing the best approach is to follow the lessons in order and complete the exercises along the way it'll help you build a strong Foundation however if you already have some experience you might be tempted to jump around and focus on specific lessons while that's an option because the course is well structured I would like to advise you against it why well you might unknowingly have some bad habits or be using less than optimal practices as your instructor I strongly recommend going through all the lessons sequentially the Fantastic part is that the course is concise and to the point so you can easily complete it in a single day plus it's full of practical examples and exercises so you're not going to get bored with fluff content all right now that we're on the same page our next step is setting up our testing environment all right let's talk about setting up our testing environment first head over to nodejs.org and download the latest version of note now in this course just like my other courses I'll be using visual studio code or vs code as my editor you're welcome to use your preferred editor but in this course I'm going to show you a ton of shortcuts for increasing your productivity so while not necessary I recommend you to download and install Visual Studio code all right before we move on to the next section I want you to download the starter project I have created for this course so head over to github.com hamadani here go to repositories and search for JavaScript D testing here we have two repositories the started project and the finished project the finished project contains the solution to all the exercises I have created for you so let's start with the starter project then go to code clone this URL next open a terminal window and run get clone followed by the URL all right good so here we have this folder JavaScript testing starter just open this with vs code and you're good to go welcome back to another section of unit testing JavaScript course this section is going to be your gateway to the world of unit testing we'll kick things off by talking about what is unit testing what are its benefits and what are common arguments against it then we'll talk about different types of tests we encounter in real world applications once we've got the theory covered we'll talk about the tooling we'll explore various testing Frameworks out there in this course we'll be using Vest which is a relatively new testing framework that has gained popularity but the concepts you will learn in this course apply to other testing Frameworks like just as well so next we'll set up v test and write our first unit tests you will see unit testing and its benefits in action then I will introduce you to the con concept of test driven development or tddd we'll talk about the benefits as well as a few misconceptions about tdd next I will show you various ways to run your tests efficiently this is a key skill you need to have especially when you deal with broken tests you should be able to quickly filter your tests and focus on one or a few at a time now every season developer is expected to know how to navigate their code base quickly and smoothly so I will show you various shortcuts in vs code to navigate your tests and production code last but not least we'll wrap up this section by talking about code coverage which is a metric that shows how much of our code is tested this is a great introduction to unit testing so let's jump in and get started so what exactly is unit testing well unit testing is a form of automat testing where we write code to check if our code works as expected here's an example imagine we have a function for calculating the monthly loan payment now if we were to test this function manually we would have to launch our application possibly login navigate to a particular page fill out a form submit it and then check if the result is calculated correctly as you can see this is pretty time consuming this is where automated testing comes to the rescue we can write some code to directly call this function with various inputs and check if it Returns the correct result we execute this code using a program called a test Runner which displays test results in the console or terminal window if a test passes we see a green tick otherwise we see a red cross using this technique we can run hundreds or even thousands of tests in just a few seconds clearly this is much faster than manual testing through the user interface with automated testing our code base consists of two types of code the application code also known as production code and the test code or tests once we have a suite of tests we can run them every time we make changes to our code and this brings us a bunch of benefits firstly unit tests help us identify and fix bugs early in the development process long before they become nasty surprises in production there have been many studies that show that that the later we find and fix a bug in the development process the costlier it is for the business for example fixing a bug after deploying the software can be up to five times more expensive than during the coding phase secondly unit testing helps us refactor our code with confidence refactoring means changing the structure of our code without changing its Behavior or functionality for instance we can extract a few lines of code and put them into a separate function we're changing the structure of the code but not its functionality with unit tests every time we refactor our code we can run our tests to quickly confirm if our code still behaves as expected thirdly writing unit tests encourages us to consider various edge cases and error conditions and this leads to more robust and reliable code and lastly unit tests serve as documentation for how our functions should behave and this makes it easier for others to understand and maintain a project now despite these benefits we have developers with very strong opinions like our famous superstar developer Mr John Smith who is skeptical about unit testing he proudly claims that in his 20 years of software engineering he's been writing bug free code without ever writing a single unit test on the other side of the spectrum we have other developers like test Smith who are obsessed with writing test and say every line of your code should be covered by tests so who's right well in my opinion both of these viewpoints are extreme and can be costly for a business having no unit test at all and relying solidly on manual testing can be very timeconsuming especially as our application grows in size and complexity on the other hand covering every line of code with tests can also be very expensive we always have time and resource constraints so next time you encounter one of these folks with strong opinions don't get caught up in their debate instead be pragmatic and find a good balance that works for your project keep in mind that every project is unique new projects with rapidly evolving requirements might not be the best candidate for extensive unit testing because as the requirements change some of your tests may break and you end up spending more time fixing broken tests than delivering actual features however if your project is more established and certain features have stable requirements it's a good idea to write a suite of tests to ensure that at least the critical modules continue to work as expected this way whenever you make changes to those modules you can run your tests to get immediate feedback if you have broken something or not in reality unit testing is an investment in software quality like any investment it can be fruitful or go wrong if you skip writing tests entirely you will rely solely on manual testing and this will get increasingly costly over time on the other hand writing poor tests that produce inaccurate results and fail to give you real feedback about your codes reliability is a waste of time so just like how you should wisely invest your money you should also use your time wisely when writing tests you should write good tests that are maintainable robust and trustworthy and that's what I'm going to teach you in this course if your tests are not maintainable r and trustworthy they offer no value they get in the way and slow you down it's better not to write them at all all right next we're going to talk about different types of tests in automated testing we have three types of tests unit tests integration tests and endtoend tests so what are the differences well unit tests verify the correctness of individual units or components of an application in isolation these units could be functions classes or even small modules these tests are incredibly useful for catching bugs early in the development process integration tests focus on verifying how different units or components of your application work together as a whole they help you identify issues that might arise when combining different units such as data flow problems communication between modules and compatibility issues between components and tests are the broadest type of tests focusing on testing the entire application as a whole they simulate real user interactions with the entire system from the user interface down to the backend Services they're excellent for ensuring that our entire application works seamlessly from the user's perspective now a common question that I get is what types of tests should we write well the classic recommendation is to have more unit tests than integration tests and more integration tests tests than endtoend tests this is referred to as the testing pyramid however this is just a suggestion it doesn't mean you should follow it religiously because every application is different in some cases it may make more sense to have more integration tests or more endtoend tests there is no one siiz fits all in software engineering anyone who tells you there is only one way to do something and that's the best way they're either selling you something or they haven't been around long enough so when designing a testing strategy for your application consider the complexity of your application's code as well as your time and resources to come up with a suite of tests that give you the most value but there is one thing crucial you need to understand about the testing pyramid as we go up this pyramid in other words as we test more units of our code together our tests will be slower but they will give us more confidence in the reliability of our application so end to1 tests give us the highest confidence but they're significantly slower running them every time we change or refactor our code isn't always feasible this is where unit tests come into play unit tests are incredibly fast so we can run them every time we change or refactor our code to get immediate feedback if you have broken something so all these types of test are valuable it's hard to determine which type has more value it's like debating what type of shoes is more valuable dress shoes or running shoes well it depends where you want to go so don't listen to folks with strong opinions on social media saying things like unit tasks are a waste of time and they only write end to and tests well good for them anyway in this course our focus is entirely on unit testing so you don't need to worry about integration and end to end tests at this point in the second part of this series where we will look at testing react applications we'll talk about integration tests so I mentioned earlier that we need a test Runner to execute our tests now this is where testing Frameworks come into the picture a testing framework is a set of tools for writing and running tests it typically includes a test runner for executing tests assertion libraries to check if the code behaves as expected mocking tools to replace certain modules with Fakes simulating different scenarios test coverage tools for measuring how much of the code is tested and many other tools now there are several testing Frameworks out there like just mocha Jasmine vest Cypress playwright and many many more all these Frameworks work more or less the same way so once you get the hang of one you can easily pick up other Frameworks among these just is the most widely adopted and used in many projects however there is a little catch with just it's an older framework and its support for Eos script modules or n native JavaScript modules is still experimental so setting up things can be a little bit awkward so in this course we're going to take a different route we'll be using Vest which is a new testing framework designed for modern JavaScript it has all the Fantastic features of Gest as well as outof thee boox support for econ script modules typescript and jsx which is used in react plus its API is almost identical to just so everything you learn about vest in this course will will be directly applicable to just as well all right now we're ready to set up vest so I have opened our starter project in vs code now we need to open a terminal window to install vest so on the top Under The View menu let's go to terminal look at the shortcut it's control and back tick so here we're going to use npm to install vest as a development dependency because we don't want to deploy our test tools with our application so we always install them as development dependencies so let's install vest lovely now we need to go to our package Json file and create a test script so here in the scripts object we add a new key value paent called test and set it to vest now whenever we run npm test v test will execute our tests so if you go back to the terminal and run npm test or npm t v test will execute our tests now currently we don't have any test files that is why we get this error in the next lesson we're going to create our first test all right we're going to write our first test so here in the source folder we have a module called intro in this module we have all the code we're going to use in this section ction so here we have a function for getting the max of two numbers pretty basic if a is greater than b it returns a otherwise if B is greater it returns B otherwise if they're equal it returns a I know this is not the best way to write this function this is deliberate once we cover this function with tests we'll come back and refactor it into a more elegant implementation so to test this we're going to go in the root of our project next to the source folder we create cre a new folder called test and here we create a test file for the intro module so we call it intro. test.js this is the pattern that vest or just looks for so vest by default pixel files that have test in their name and of course this can be configured okay now in this file we're going to import a few functions from vest one of them is describe for creating a test Suite TW or a group of related tests the other one is test for creating a test case there is also another function that does the same job it's called it we'll talk about it momentarily and one more function that is expect so first we call the describe function to create a test Suite or a group of related tests we give it two arguments the first argument is a string that is the name of our test Suite typically we use the name of the function or the unit under test in this case Max the second argument is a function that will be called by our test runner in this case v test so here we pass an eror function now in this block or in this test Suite we Define one or more test cases so we call test or it it doesn't matter it's a matter of personal preference now just like the describe function here we need two arguments the first argument is a string that represents our test name so look here we want to test a scenario where a is greater than b so to name this test here we can pass a string like should return the first argument if it is greater now look the reason Some people prefer to use the it function is because the test case reads like it should return the first argument if it's greater very clear so always pay great attention to naming your tests I've seen some people naming their test like test one test two don't do that because over time it's not going to be clear what is the purpose of these tests so always treat your tests as first class citizens your test code is as important as your production or application code okay so here's a test name now the second argument should be a function that will be executed by our test runner in this case v test once again we pass an arrow function now in this test we typically structure our test using the AAA pattern that is short for arrange act and assert this is a pattern that a lot of people follow when organizing their tests in the arrange phase we set up our test environment including any necessary data or configurations in the ACT phase we perform the action we want to test and in the assert phase we check the outcome to ensure that it matches our expect expectations let me give you a real example imagine we want to test that a TV can be turned off in the enrange part first we turn on the TV in the ACT part we press the power button and in the assert part we verify that the TV is off okay now we can take this analogy and apply it to our tests so in the arrange part first we declare two variables or two constants we can call them A and B we set a to 2 and B to 1 now these are arbitrary values we could use 20 and 10 we could use 10 and 9 it doesn't matter what matters is that we want the first argument to be greater now in the ACT phase we perform the action we want to test in this case we call the max function that is defined in this module so let's press enter the max function is imported on the top now we pass our arguments A and B get the result and store it here now finally in the assert phase we verify that the result is correct to do that first we call the expect function of v test and by the way just has the same functions and they work exactly the same way so we call expect and pass result now this returns an expectation object in this object we have a bunch of methods that start with is two these are called matchers we use these to verify expectations for example we have to be to be called to be defined to be falsy to be greater than and so on as we go through the course you're going to get familiar with these matches in this lesson we're only going to use the to be matcher so we expect the result to be two this is how we structure our test now we don't necessarily have to add these comments we can use a vertical line Breck to separate these sections this way it's immediately visible that the first part is the range part the second part is the act part and so on now for simple cases we don't even have to have all these parts or all these faces we can combine them to make our test more concise for example we don't need to declare these two constants because they're only used on this line so we can replace a and b with their literal values now we don't need the arrange part and similarly we can combine these two lines into a single line so we replace result with a call to the max function now our test has a single line of code so back in the terminal let's run npm test or npm t all right we have one passing test beautiful and look the test name clearly identifies the scenario we're testing now back in our test if I change this value to one now back in the terminal look now we have a failing test and the failure is happening on line six of this module so the test expected one but it received two so back to our test let's change it back to two all right that was our first test case now we need two more test cases for scenarios where the second argument is greater and also the scenario where our arguments are equal so I'm going to duplicate these few lines so here's what we have so far in this test Suite we have two test cases now let's change the name of the second test and here we say it should return the second argument if it's greater now let's swap the order of these arguments back in the terminal now we have two passing tests in one test file and one more test case I'm going to say it should return the first argument if arguments are equal so here we can pass one and one and expect the result to be one now take a look now we have three passing tests and all these tests were executed in 8 milliseconds imagine if you wanted to test this function through the UI perhaps we have to do a few clicks perhaps we had to fill out a form obviously we could never do this in 8 milliseconds right it would take several seconds but we are not done yet now that we have fully covered this function with tests let's refactor it with confidence so we're going to replace these three lines with an expression like this return if a is greater than b return a otherwise return B back in the terminal look our tests are still passing this is the beauty of unit test they give us immediate feedback if we have broken something during our refactorings however if you go back here and let's make it deliberate mistake let's return a in both cases now look one of our tests failed and that is this particular test should return the second argument if it's greater so we expected to get two but we received one so let's go back and fix the arrow all right so that's that was our first test now as we go through the course we're going to look at more complicated and real word examples all right here's your exercise in the same module we have a function called fsus it's a very popular function that comes up in coding interviews so this function receives a number if the number is divisible by three and five it returns fizzbuzz if it's only divisible by three it returns Fizz if it's only divisible by five it returns Buzz otherwise if the number is not divisible by three or five it returns that number as a string now as your exercise I want you to cover this function with tests now to give you a hint when writing test for a function you should cover all the execution paths so here we have four execution paths here's the first one second third and fourth spend 5 to 10 minutes on this and then come back see my my solution so back to our test file here we have a test suite for the max function now we need to Define another suite for testing the fsbos function so we call describe and pass fizzbuzz now here we have a scenario where the argument is divisible by three and five so it should return fiz buzz if argument is divisible by three and five I'm going a little bit faster because I'm assuming you have done your exercise then we pass an aror function now once again here we don't need to have separate arrange act and assert faces we can combine all of them into a single line because our test is very simple so we call fboss and and give it a number like 15 then we make an assertion and check to see if the result is Fizz bu now back in the terminal beautiful we have four passing tests now to make sure that we're testing the right thing let's change this to Fizz now we have one failing test lovely so let's revert it back to Fizz boss this is a very simple and useful technique to ensure that you're testing the right thing because sometimes your test might pass but it might not be testing the right thing or even the right function so always make a tiny change to make sure that your test and production code are in sync another way to go about this is by modifying the production code so instead of changing the test code we can go back to the production code and create a bug so here we can add an exclamation mark and now look we have one failing test so this verifies that our test code and production code are in sync in other words our test is actually testing this function because otherwise let me show you an exaggerated example let's imagine instead of calling 2B we had a call to to be defined so we're checking that the value that is returned from this function is defined with this test now our test always passes even though we have a bug in our production code if we make any changes here our test still passes so this shows that we are not testing the right thing this is what we call a false positive so our test always passes giving us an illusion that our code works we can also have false negatives tests that always fail even though there's no bug in our production code so this technique is very useful to prevent false positives and false negatives you want to make sure that our test code and production code are inan think or in other words we're testing the right thing so let me bring back the 2B match and compare the result with fiz Buzz okay now we have a failing test lovely so let's go back and fix the bug good so we're done with the first test case now let's move on to the second test case so I'm going to duplicate these few lines this time we say that our function should return fiz if argument is only divisible by three so we can pass three or 6 or 9 it doesn't really matter let's compare it with fizz we have one passing test now to make sure that we're testing the right thing again we can go back to our production code and make a tiny change here there you go now we have a failing test so our test and production code are in sync now we need two more test cases so let's duplicate this test and change the name to it should return buzz if argument is only divisible by five so here we pass Five and compare the result with Buzz one more passing test and the last test case it should return argument as a string if it's not divisible by three or five okay so let's pass let's say one and here we expect to get one as a string seven passing test but if you pass one as a number now we have a failing test okay so let's revert it back beautiful we're done with this lesson next we're going to talk about test driven development there are two ways to write tests code first or test first code first is what we have been doing so far we write the application code first and then we cover it with tests test first is the opposite we start with tests and then we produce the application code this approach is also called test driven development or tdd TD CD is a way of building software it follows a simple effective threestep cycle we start by writing a failing test and then we write just enough code to make the test pass then if necessary we refactor our code while ensuring that all tests still pass and then we repeat let's see this in action so let's imagine we want to create a function for calculating the average of values in an array so we start by writing a failing test so back to our test file first we create a new test Suite let's call this calculate average now here we start with a test case for an empty array let's say that if we pass an empty array to this function we expect to get not a number so it should return not a number if given an empty array now first we need to create this function so back to to our intro module we Define a function called calculate average that takes an area of numbers and then export it from this module so we're not going to implement this yet we just have the Declaration of the function now back to our test so we call calculate average and give it an empty array and then expect the result to be not a number okay back in the terminal look we have a failing test because we expected not a number but we received undefined because in JavaScript all functions by default return undefined unless we explicitly return a value so to make this test pass we go back to our intro module and write the simplest implementation possible so we return not a number now we have one passing test beautiful that was one cycle now we need to repeat this with other test cases so as our second test case we're going to call this function and give it an array with a single element so we can change the test name to should calculate the average of an array with a single element so we call it and give it an array with just one and expect the result to be one now look again we have a failing test so we have to write just SE of code to make this test pass so back to the intro module now we can say if numbers the length equals zero then we return another number otherwise we return numbers of zero obviously this logic is still immature but we're going to enhance it with more test cases so back in the terminal now we have nine passing test so we completed one more cycle now let's write another test case for an array with two elements so back to our test file let's duplicate this test case and say it should calculate the average of an array with two elements so if we pass one and two we expect the average to be 1 and half now look again one failing test so we go back to our intro module and write the simple logic here we can use a for Loop to iterate over this array and calculate the total of all values or we can use the reduce method so here we call numbers do reduce and give it an arrow function this function should have two parameters the first parameter is an accumulator or a variable that con contains the total value we can call it total or sum that's better the second parameter holds the current value one value at a time in this array so we can call it current now in the body of this function we simply add current to sum so we return sum plus current so this function is the first argument to the reduce method now as the second argument we need to provide the initial value for the sum so we we initialize it to zero now with this we get the sum of all numbers in this array and finally we can divide sum by numbers. length now back in the terminal all our tests are passing lovely so let's write one more test case this time we want to pass an array with three elements so if you pass 1 2 and three the average should be to now look all right all our tests are passing so this was tdd in action we started by writing tests and as a result we produced this function now the beautiful thing about tdd is that it produces production code that is 100% covered by tests so here we don't have any execution paths that we haven't tested the current implementation of this function is fully covered by tests if the implementation is not complete yet we can add other test cases to drive the development the other great thing about tdd is that it prevents us from over engineering because our focus is on rating the simplest logic to make the tests pass and we can always refactor and refine our implementation what matters is that we are not over engineering ahead of time so these are the benefits of tddd but in practice tdd can be difficult especially for new Learners so in this course our Focus will be on the code first approach but as you learn unit testing you can challenge yourself and start exploring tdd first it might be difficult especially in more complex applications but trust me over time with practice it gets easier and easier now I just want to clarify something here tdd as a philosophy is great but it doesn't mean that you should always write tests using this approach I know that there are some folks that are fanatic about tdd and they say you're not a developer if you don't use tdd but again this is one of those extremely radical viewpoints if you don't like tdd or if you prefer to write tests after the production code that is perfectly fine again there is no onesize fitall in software engineering every project every team is different so always use the approach that works for you and your projects now as your exercise I want you to implement the factorial function using tdd we have all studied factorial at school in math now to refresh your memory the factorial of an number is the product of all positive numbers from one to that number here are a few examples so factorial of 0 is 1 factorial of 1 is 1 factorial of 2 is 2 * 1 factorial of 3 is 3 * 2 * 1 so write a test case for each of these scenarios and then implement the factorial function all right so we start start by creating a new test Suite called factorial first we write a test case for the factorial of zero so should return one if given zero now first we need to create the factorial function so back to our intro module we export a function called factorial that takes a number and we leave out the implementation now back to our test we call factorial and give it zero and then we expect the result to be one back in the terminal obviously we have a failing test so to make this test pass we go back to our intro module and return one all right our test is passing now the second test case so we duplicate this and change the test name to it should return one if given one our tests are still passing lovely so let's add another test case should return two if given two now back to our function here we need a bit of logic we can check if n equals 0 or 1 then we return one otherwise we can do a trick we can just return two we hard Cod this value and our tests are still passing so what I want to emphasize here is that we want to write just a little bit of code to make our test pass we want to do baby steps we don't want to have a big step where we write a lot of logic because that can lead to over engineering ing so our tests are still passing so let's add another test case should return six if given three so factorial of three should be six now one of our tests is failing so we go back to our factorial function and this is where we make another step so instead of hard coding two or six we implement the actual logic here we can use recursion so we multiply n by factorial of n 1 all our tests are passing lovely let's add one more test case what if we pass four factorial of four should be 24 all right all our test are still passing beautiful now what if we pass a negative number well that's one of the areas that is is debatable but we can say that factorial of negative numbers is undefined so we write another test case here and say it should return undefined if given a negative number so we pass 1 and expect the result to be undefined now we also have a separate matcher function here that is to be un defined we can also use this back to the terminal one of our tests is failing so back to our factorial function let's add another if statement and say if n is less than zero then return undefined all our tests are passing lovely now I just want to clarify something here as part of writing tests whether we go with the code first or the test first approach we don't want to test against all possible numbers in the world because that is is Not Practical so we don't want to test a factorial function with a million different numbers we want to have enough numbers in different ranges like zero positive negative as long as we have a few different test cases for different scenarios that is sufficient all right what's next well if you want to learn more I have a comprehensive JavaScript unit testing course on my website what you have watched is the first 40 minutes the full course is 4 hours long and goes Way Beyond the basics we'll talk talk about various techniques for writing effective tests that are robust maintainable and trustworthy we'll talk about positive and negative testing boundary testing writing parameterized tests testing asynchronous code and using marks and spies to isolate code during tests we'll also have a section on improving code quality using static analysis tools we'll talk about formatting code with prier linting it with es lint catching type errors with typescript and automating code quality checks with Husky so by the end of the course you will have a strong foundation in unit testing and we'll be ready to learn about testing frontend applications like react the full course is packed with a ton of exercises so you can practice what you will learn and the best part is that it comes with a certificate of completion and a 30day money back guarantee so if you're not satisfied just ask for a refund if you're interested use the link below this video to enroll I hope to see you in the course thank you and have a great day up
