With timestamps:

00:00 - [Music]
00:01 - so earlier in section 2 where we talked
00:04 - about nodes module system you learned
00:06 - about this HTTP module we use this to
00:09 - create a web server that listens on port
00:12 - 3000 and responds to requests for these
00:16 - endpoints so the route or such API slash
00:19 - courses now while this approach is
00:21 - perfectly fine it's not ideal for
00:24 - building a complex application because
00:27 - in a large complex application we might
00:29 - have various endpoints and we don't want
00:32 - to hard-code all these if statements in
00:35 - this function so in this section we're
00:37 - going to look at Express which is a fast
00:39 - and lightweight framework for building
00:41 - web applications so next we're gonna
00:44 - look at restful services
00:50 - let's start the section by a brief
00:53 - introduction to restful services also
00:56 - called restful api s-- if you already
00:58 - know what rest is all about feel free to
01:01 - skip this video so earlier at the
01:03 - beginning of the course I introduced you
01:05 - to the client-server architecture so
01:08 - most if not all applications we use
01:10 - these days
01:11 - follow this architecture the app itself
01:14 - is the client or the front-end part
01:17 - under the hood it needs to talk to a
01:19 - server or the back-end to get or save
01:22 - the data this communication happens
01:25 - using the HTTP protocol the same
01:28 - protocol that powers our web so on the
01:30 - server we expose a bunch of services
01:33 - that are accessible via the HTTP
01:36 - protocol the client can then directly
01:39 - call the services by sending HTTP
01:41 - requests now this is where rest comes
01:45 - into the picture
01:46 - rest is short for representational state
01:49 - transfer and I know it probably doesn't
01:51 - make any sense to you because it was
01:53 - introduced by PhD student as part of his
01:56 - thesis but the theory aside rest is
01:59 - basically a convention for building
02:01 - these HTTP services so we use simple
02:05 - HTTP protocol principles to provide
02:07 - support to create read update and delete
02:11 - data we refer to these operations all
02:14 - together as crud operations now let's
02:17 - explore this convention using a real
02:19 - world example let's say we have a
02:21 - company called bitly for renting out
02:24 - movies we have a client app where we
02:26 - manage the list of our customers on the
02:29 - server we should expose a service at an
02:32 - endpoint like this so vid lucam / api /
02:36 - customers so the client can send HTTP
02:39 - requests to this endpoint to talk to our
02:42 - service now a few things about this
02:44 - endpoint you need to know first of all
02:46 - the address can start with HTTP or HTTPS
02:50 - that depends on the application and its
02:52 - requirements if you want the data to be
02:55 - exchanged on a secure Channel you would
02:57 - use HTTPS after that we have the domain
03:00 - of the application
03:02 - next we have slash API this is not
03:05 - compulsory but you see a lot of
03:06 - companies follow this convention to
03:09 - expose their restful services they
03:12 - include the word API somewhere in the
03:14 - address it can't be after the domain or
03:17 - it can be a sub domain like API that
03:20 - vidlink aam there is no hard and fast
03:22 - rule after that we have slash customers
03:26 - which refers to the collection of
03:28 - customers in our application in the rest
03:31 - world you refer to this part as a
03:33 - resource we can expose our resources
03:36 - such as customers movies rentals on
03:39 - various endpoints so this is our
03:42 - endpoint to work with the customers all
03:44 - the operations around customers such as
03:47 - creating a customer or updating a
03:49 - customer would be done by sending an
03:51 - HTTP request to this endpoint the type
03:54 - of the HTTP request determines the kind
03:57 - of the operation so every HTTP request
04:00 - has what we call a verb or method that
04:03 - determines its type or intention here
04:06 - are the standard HTTP methods we have
04:09 - yet for getting data post or creating
04:12 - data put for updating data and delayed
04:16 - for deleting data now let's explore each
04:19 - of these using our customers example to
04:22 - get the list of all customers we should
04:24 - send an HTTP GET request to this address
04:27 - note the full name customers here it
04:30 - indicates a list of customers so when we
04:33 - send an HTTP GET request to this
04:35 - endpoint our service should send us
04:38 - something like this so we have an array
04:41 - of customer objects if you want a single
04:44 - customer we should include the idea of
04:46 - that customer in the address then our
04:49 - server would respond with a customer
04:51 - object like this now to update a
04:54 - customer we should send an HTTP put
04:57 - request to this endpoint and note that
04:59 - again here we're specifying the idea of
05:01 - the customer to be updated but also we
05:05 - should include the customer object in
05:06 - the body of the request so this is a
05:09 - complete representation of the customer
05:11 - object with updated properties
05:14 - we send this to the server and the
05:16 - server updates the customer with the
05:18 - given ID according to these values
05:20 - similarly to delete a customer we should
05:23 - send an HTTP delete request to this
05:26 - endpoint but here we don't need to
05:28 - include the customer object in the body
05:30 - of the request because all we need to
05:32 - delete a customer is an ID and finally
05:35 - to create a customer we need to send an
05:38 - HTTP POST request to this endpoint note
05:41 - that here because we're adding a new
05:42 - customer you're not dealing with a
05:44 - specific customer so we don't have the
05:46 - ID in the address you're working with
05:49 - the collection of customers so we're
05:51 - posting a new customer to this collector
05:53 - and that's why we should include the
05:56 - customer object in the body of the
05:58 - request the server gets this object and
06:00 - creates the customer for us so this is
06:03 - the restful convention we expose our
06:05 - resources such as customers using a
06:08 - simple meaningful address and support
06:11 - various operations around them such as
06:13 - creating or updating them using standard
06:16 - HTTP methods so throughout this section
06:19 - you're going to learn how to use the
06:21 - Express framework to build a restful
06:24 - service from managing the list of
06:26 - customers however in this section we
06:29 - won't be doing any database work because
06:31 - that will bring in additional complexity
06:33 - our focus will be purely on building
06:36 - HTTP services and we will use a simple
06:39 - array in memory to keep the list of our
06:41 - customers later in the course we'll look
06:44 - at using a database
06:50 - so here's the code that we wrote in the
06:52 - section about node core where I
06:55 - introduce you to the HTTP module so we
06:58 - can see with HTTP module we can create a
07:00 - web server here we have a callback
07:02 - function that takes two parameters
07:05 - request and response and with this
07:08 - request object we can check the URL of
07:11 - the incoming request so with this we can
07:14 - define various routes for our
07:16 - application so if you have a request for
07:19 - let's say slash API slash courses this
07:22 - is how we're going to respond to the
07:24 - client now while this approach certainly
07:26 - works it's not very maintainable because
07:29 - as we define more routes for our
07:31 - application we need to add more if
07:33 - blocks in this callback function so
07:37 - that's when a framework comes into the
07:39 - picture a framework gives our
07:41 - application a proper structure so we can
07:43 - easily add more routes while keeping our
07:46 - application code maintainable now there
07:49 - are various frameworks out there for
07:51 - building web applications and web
07:53 - servers on top of note the most popular
07:55 - one is Express so if you head over to
07:59 - NPM JSE org or NPM J is calm here let's
08:05 - search for Express so the current
08:10 - version is version 4.2 16.2 let's have a
08:14 - quick look here so here on the right
08:16 - side look at the statistics there have
08:20 - been over 700,000 downloads in the last
08:23 - day and over 15 million downloads in the
08:26 - last month it's a very popular framework
08:28 - it's also very fast lightweight and
08:31 - perfectly documented so now back in the
08:35 - terminal let's create a new folder for
08:37 - this section so I'm gonna call this
08:39 - Express demo now let's go inside this
08:44 - folder run NPM init with yes flag so now
08:51 - we have a package JSON file and finally
08:54 - we can install Express
09:00 - beautiful in the next lecture I'm gonna
09:02 - show you how to build your first web
09:04 - server using Express
09:11 - all right now in vs code let's add a new
09:14 - file index the jas we could also call it
09:18 - app to J's it doesn't really matter so
09:22 - in this file first we want to load the
09:25 - Express module so we use our require
09:27 - function give it the name of our module
09:30 - which is Express now this returns a
09:34 - function we call that Express okay now
09:40 - we need to call this function like this
09:43 - and as you can see this returns an
09:46 - object of type Express by convention we
09:50 - call this object app so we store the
09:53 - result in a constant called app so this
10:00 - represents our application now this app
10:02 - object has a bunch of useful methods we
10:05 - have methods like get post put and
10:12 - delete all these methods correspond to
10:16 - HTTP verbs or HTTP methods that I told
10:19 - you about earlier in this section so if
10:22 - you want to handle an HTTP POST request
10:24 - to an endpoint you would use app that
10:27 - post now in this lecture we just want to
10:30 - use app but yet we want to implement a
10:33 - couple of endpoints that respond to an
10:35 - HTTP GET request so this method takes
10:38 - two arguments the first argument is the
10:42 - pass or the URL so here I'm going to use
10:45 - slash to represent the route of the
10:48 - website
10:49 - now the second argument is a callback
10:52 - function this is the function that will
10:54 - be called when we have an HTTP GET
10:56 - request to this endpoint okay so this
11:00 - callback function shall have two
11:01 - arguments request and response so this
11:07 - goes to a code block now this request
11:11 - object has a bunch of useful properties
11:14 - that gives us information about the
11:16 - incoming request if you want to learn
11:18 - about all these properties it's best to
11:21 - look at the Express documentation
11:23 - because in this course we're going to
11:24 - use only a handful of these properties
11:26 - so head over to Express Jas comm on the
11:32 - top look at API reference version 4 now
11:37 - here you can see the request object and
11:39 - below that you can see all the
11:41 - properties that are available to you
11:43 - you have base URL we have body to read
11:46 - the body of the request cookies fresh
11:49 - host name IP method original URL
11:53 - parameters and so on so back to our code
11:56 - when we get an HTTP GET request to the
11:59 - root of our website you're gonna respond
12:02 - with a hello world message so response
12:04 - dots and hello world so this is how we
12:11 - define a route we specify the path or
12:14 - the URL and a callback function which is
12:18 - also called a route handler now finally
12:21 - we need to listen on a given point so we
12:24 - call app that listen we give it a port
12:28 - number like 3,000 and optionally we can
12:31 - pass a function that will be called when
12:33 - the application starts listening on the
12:35 - given port so once again we use the
12:39 - arrow function syntax to display
12:41 - something on the console so console dot
12:44 - log listening on port 3,000
12:52 - now back in the terminal note index j s
12:58 - okay we're listening on port 3000 now
13:02 - let's switch over to Chrome and go to
13:05 - localhost port 3000 so here's our hello
13:08 - word message now let's define another
13:11 - route so once again we're gonna call app
13:15 - that get now this one is going to be
13:19 - slash API slash courses once again we
13:24 - pass a function with two arguments then
13:26 - it's request and response and this goes
13:30 - to a code block now in a real world
13:34 - scenario here you want to get the list
13:36 - of courses from the database and return
13:38 - them but as I told you before in this
13:41 - section
13:41 - our focus is purely on building these
13:44 - endpoints you're not gonna do any
13:46 - database work so I'm gonna simply return
13:48 - an array of numbers so response that's
13:53 - and it passed an array of three numbers
13:56 - in the future we can replace these
13:59 - numbers with actual course objects so
14:02 - save now back in the terminal we have to
14:06 - stop this process and started the game
14:08 - so press ctrl + C okay one more time
14:12 - node index J is now back in Chrome let's
14:18 - head over to slash API slash courses
14:20 - look we have an array of three numbers
14:23 - beautiful so this is what I want you to
14:26 - pay attention to here in this
14:28 - implementation we don't have those eve
14:31 - blocks we define new routes by calling
14:35 - app that yet and with this structure as
14:38 - our application grows we can move some
14:40 - of these routes to different files for
14:43 - example we can move all the route
14:45 - related to courses to a separate file
14:47 - like courses that Jas
14:49 - so Express gives our application is
14:51 - skeleton is structure
14:58 - so far you have noticed that every time
15:01 - we make a change to this code you have
15:04 - to go back in the terminal and stop this
15:06 - process and started the game this is
15:08 - very tedious so I'm gonna show you a
15:10 - better way we're gonna install a note
15:12 - package called note Mon which is short
15:15 - for node monitor so in the terminal and
15:19 - p.m. install - G because we want to
15:22 - install this globally so we can run it
15:24 - anywhere and the name of the package is
15:27 - node Mon now as I told you before if
15:30 - you're on Mac and you haven't configured
15:32 - the permissions properly in it put sudo
15:35 - at the front
15:41 - all right no one is installed so with
15:44 - this instead of running our application
15:47 - using node we use node Mon okay now you
15:53 - can see node Mon is watching all the
15:55 - files in this folder
15:57 - any files with any extensions so if we
16:01 - come back here and make a simple change
16:03 - and then save the file now look in the
16:08 - terminal node Hmong restarted our
16:10 - application or our process due to
16:13 - changes so we don't have to do this
16:15 - manually anymore now back in the browser
16:18 - if you send a request to the root of the
16:21 - website we can see our new message
16:24 - displayed here
16:30 - now one thing we need to improve in this
16:32 - code is this hard-coded value for the
16:35 - port so we have used 3000 as an
16:38 - arbitrary number while this may work on
16:41 - your development machine it's unlikely
16:43 - that this is gonna work in a production
16:45 - environment because when you deploy this
16:47 - application to a hosting environment the
16:49 - port is dynamically assigned by the
16:51 - hosting environment so we can't rely on
16:54 - 3000 to be available so the way to fix
16:58 - this is by using an environment variable
17:00 - so typically in hosting environments for
17:03 - node applications we have this
17:05 - environment variable called port an
17:08 - environment variable is basically a
17:10 - variable that is part of the environment
17:13 - in which a process runs its value is set
17:17 - outside this application I'm gonna show
17:19 - you how that works in a second so in
17:21 - this application we need to read the
17:23 - value of this port environment variable
17:26 - and the way we do that is by using the
17:28 - process object so we have this global
17:32 - object called process this object has a
17:35 - property called M which is short for
17:37 - environment variables and after that we
17:40 - add the name of our environment variable
17:42 - in this case port so if this is set
17:46 - we're gonna use this otherwise we're
17:49 - gonna use 3000 now we can store the
17:52 - result in a constant called port okay
17:57 - let's delete this and finally we need to
18:00 - replace 3000 with port and also change
18:04 - our message accordingly so I'm going to
18:07 - replace a single coat with backtick so
18:11 - we can use a template string and here
18:14 - we're gonna replace 3000 with a dynamic
18:17 - value so I'm here at dollar sign curly
18:20 - braces and then add our constant in this
18:23 - case port okay now back in the terminal
18:28 - let's run this application using node
18:30 - maaan
18:32 - so on this machine you can see I don't
18:35 - have an environment variable called port
18:37 - that's why 3000 is used as the port for
18:42 - this web server now I'm going to set an
18:44 - environment variable so let's stop this
18:47 - process on Mac we can set an environment
18:51 - variable by executing the export command
18:54 - if you're on Windows you should use set
18:57 - so export or set now we add the name of
19:02 - the environment variable in this case
19:04 - port and set its value I'm going to use
19:07 - 5,000 so now we have this environment
19:11 - variable called port with the value of
19:14 - 5,000 with this when we run this
19:17 - application node man
19:21 - you can see that now we are listening on
19:23 - port 5000 so this is the proper way to
19:27 - assign a port to your node applications
19:30 - you should attempt to read the value of
19:32 - an environment variable called port if
19:35 - there is a value you should use that
19:36 - otherwise use an arbitrary number for
19:40 - your development machine
19:42 - you
19:46 - all right so currently we have a route
19:48 - for getting the list of courses now in
19:51 - this lecture I'm going to show you how
19:52 - to create a route to get a single course
19:55 - so earlier in the section where I talked
19:57 - about restful services you learn that in
20:01 - order to get a single course we should
20:03 - include the idea of the course and the
20:05 - URL so our endpoint should be like this
20:08 - slash API slash courses slash one
20:11 - assuming that one is the idea of the
20:13 - course so let's see how we can implement
20:16 - a route like this so app that get we add
20:21 - the path that is slash API slash courses
20:24 - and here we need to define a parameter
20:27 - so we add : and ID so idea is the name
20:32 - of our parameter here you could use
20:34 - anything it doesn't have to be ID it
20:36 - could be course ID but ID is shorter and
20:40 - more conventional now we had our route
20:44 - handler function so request and response
20:47 - goes to now in order to read this
20:51 - parameter we use request dot params dot
20:56 - ID so for now let's just send this to
20:59 - the client so resource
21:02 - let's send okay back in the browser now
21:07 - let's head over to slash API is that
21:10 - courses slash one so you can see we
21:13 - successfully read the value of this
21:15 - parameter also it is possible to have
21:18 - multiple parameters in a route for
21:20 - example imagine you're building a
21:22 - service for powering a block so we could
21:25 - have a route like this posts here month
21:31 - so we have two parameters and with this
21:33 - we can get all the posts for the given
21:36 - month and the given here now we can read
21:39 - these parameters just like before
21:41 - so requested params that year or a month
21:44 - for this demo let me show you this
21:46 - requested params object so let's delete
21:50 - this save back in the browser now let's
21:55 - head over to API posts 2018
21:59 - and one so this is our request params
22:02 - object we have two properties year and
22:05 - month and their name based on a route
22:07 - parameters we express we can also get
22:10 - Kariya string parameters these are
22:13 - parameters that we add in the URL after
22:16 - question mark for example we can get all
22:19 - the posts in January 2018 and sort them
22:23 - by their name so we add a question mark
22:25 - sort by set this to name this is a query
22:29 - string parameter we use query string
22:32 - parameters to provide additional data to
22:35 - our back-end services so we use route
22:37 - parameters for essential or required
22:39 - values whereas we use query string
22:42 - parameters for anything that is optional
22:44 - now let me show you how to read query
22:46 - parameters so I can view scope instead
22:50 - of requested params we use request dot
22:53 - query save back in Chrome and this is
22:58 - what we get
22:59 - so query parameters are stored in an
23:02 - object with a bunch of key value pairs
23:08 - hi guys thank you for watching my Noah
23:11 - tutorial I wanted to let you know that
23:13 - this tutorial is the first hour of my
23:15 - complete note course where you will
23:18 - learn how to build a real restful api
23:20 - using node Express and MongoDB all of
23:24 - that recorded with the latest version of
23:26 - node and modern JavaScript so you will
23:29 - learn new and modern ways of building
23:32 - applications with node
23:33 - unlike other courses that only show you
23:35 - simple the only examples like how to
23:38 - build a to-do app we're gonna work on a
23:40 - real-world project a restful api for a
23:43 - video rental application if you have
23:46 - taken any of my courses you know i don't
23:48 - waste your time by explaining the
23:49 - obvious like what a code editor or
23:52 - command prompt is we're gonna get
23:54 - straight to the business and as part of
23:56 - this i'll be touching on various
23:58 - important topics that you need to
24:00 - understand really well including working
24:03 - with node package manager or npm
24:05 - asynchronous javascript including
24:08 - callbacks promises async and await
24:10 - implementing crud operations data
24:13 - validations authentication and
24:15 - authorization using JSON web tokens
24:18 - including role management handling and
24:21 - login errors unit and integration
24:23 - testing test-driven development so you
24:26 - will see I will build a feature from A
24:28 - to Z using test-driven development or
24:30 - TDD and finally we'll deploy this
24:33 - application to the cloud throughout the
24:35 - course I will share with you lots of
24:37 - clean coding and refactoring techniques
24:40 - security best practices useful libraries
24:43 - to use as part of your development
24:44 - common mistakes that many note
24:46 - developers make and much much more
24:49 - the course is currently 14 hours long
24:51 - and I'm planning to add more content to
24:54 - it in the future you can watch this
24:56 - course as many times as you want and if
24:58 - you watch it to the end you will get a
25:00 - certificate of completion that we can
25:02 - add to your resume so if you're serious
25:05 - about adding no to your resume I highly
25:08 - encourage you to enroll in the course
25:09 - and don't waste your time jumping from
25:12 - one tutorial to another so click on the
25:15 - link in the video description to enrol I
25:17 - hope to see you in the course
25:23 - alright now let's implement a new
25:25 - endpoint to get a single course from the
25:28 - server so first of all let's change this
25:32 - back to courses and add the ID parameter
25:36 - here okay
25:38 - now on the top let's define an array
25:43 - called courses so constant courses we
25:47 - set this to an array and in this array
25:50 - we're going to have three course objects
25:54 - so each object should have a couple of
25:57 - properties ID and name and of course we
26:01 - can have more but for simplicity I'm
26:03 - just gonna stick to two properties here
26:05 - okay now let's duplicate this line and
26:08 - change the IDs as well as the name two
26:12 - and three so we have two endpoints want
26:16 - to get all the courses and the other two
26:19 - get a single course right in the first
26:22 - one we're gonna return our courses are
26:26 - a-okay
26:27 - right in the second one we should write
26:29 - some logic to look for the course with
26:32 - the given ID so let me delete this first
26:36 - we're gonna call courses that find this
26:40 - is a method that is available on every
26:42 - array in JavaScript as an argument to
26:45 - this method we need to pass a function
26:47 - this function will be used to find a
26:50 - course that matches a given criteria so
26:54 - we use the arrow function syntax C goes
26:57 - to and here we write some logic that
27:00 - returns a boolean value this boolean
27:02 - value determines if this course is the
27:05 - one we're looking for or not so see that
27:08 - ID should equal request that params dot
27:13 - ID
27:14 - however this requested prams that ID
27:17 - returns a string so in order for this
27:20 - comparison to work properly we need to
27:23 - parse this string into an integer so we
27:26 - call parse int which is one of the
27:28 - global functions available in JavaScript
27:31 - and then get the result and store it and
27:35 - a constant called course
27:37 - now you might be asking why I didn't use
27:39 - var here well that would be perfectly
27:43 - fine and that's how most JavaScript code
27:45 - out there is written but going forward
27:48 - it's best to drop var and either use let
27:52 - or Const we use let if you want to
27:57 - define a variable that we can reset
27:59 - later and we use Const if you want to
28:03 - define a constant in this case I don't
28:06 - want to reset the course later in this
28:08 - function but again that's perfectly fine
28:11 - to use let here as well it's just
28:13 - personal preference so we get the course
28:16 - object now if this course doesn't have a
28:20 - value in other words if we don't find a
28:23 - course for the given ID by convention we
28:26 - should return a response with the HTTP
28:29 - status code of 404 that means object not
28:34 - found so this is one of the conventions
28:36 - of restful api so if the client asks for
28:39 - a resource but that resource does not
28:41 - exist on the server we should return a
28:43 - response with the status code of 404 so
28:47 - here we call response dot status 404 and
28:53 - optionally we can send a message to the
28:55 - client as well so send the course with
29:00 - the given ID was not found okay now
29:07 - otherwise if we do have a course with
29:09 - that ID we're simply going to return
29:10 - that to the client so response that's
29:14 - and course now let's test this so back
29:18 - in the browser let's head over to slash
29:22 - API slash courses slash one so we have a
29:25 - course with the ID one and that's why we
29:27 - get this JSON object in the response
29:29 - however if I change this to ten we can
29:34 - this message the course with the given
29:35 - ID was not found and to ensure that the
29:38 - status code of this response is 404 we
29:41 - can open up Chrome developer tools so
29:44 - right click here go to inspect
29:47 - and then on the network tab make sure
29:50 - you don't have a filter here so select
29:52 - all and then refresh the page by
29:55 - pressing ctrl R on Windows or command R
29:57 - on Mac so here's a request that we sent
30:01 - to the server you can see the status is
30:02 - 404 which means not found
30:10 - so far we have created two routes that
30:13 - respond to HTTP GET requests and we use
30:17 - this route to get all the courses as
30:19 - well as a single course in this lecture
30:21 - I'm going to teach you how to respond to
30:23 - HTTP POST requests so we use an HTTP
30:27 - POST request to create a new course so
30:31 - app that post instead of the get method
30:35 - we use the post method now similar to
30:37 - the get method we need to specify a path
30:40 - so that should be a slash API slash
30:43 - courses because we're going to post to
30:46 - the collection of courses that's why we
30:49 - use the plural name here then we add our
30:53 - route handler so request and response
30:56 - goes to code block now I'm going to add
31:00 - some line break here so I can easily see
31:02 - this video all right so in this route
31:05 - handler we need to read the course
31:08 - object that should be in the body of the
31:10 - request use these properties to create a
31:13 - new course object and then add that
31:15 - course object to our courses array so
31:18 - let's create a new course object
31:19 - constant course again I'm using a
31:23 - constant here because we're not going to
31:24 - reset this course object later so let's
31:28 - set this to a new object now here
31:31 - because we are not working with a
31:33 - database we need to manually assign an
31:35 - ID so ID so we get the number of
31:39 - elements in our courses array so courses
31:42 - dot length and simply add one to it in
31:45 - the future when we work with the
31:48 - database the ID will be assigned by the
31:50 - database next is the name property now
31:54 - we need to read this from the body of
31:56 - the request
31:57 - so request that body that name so here
32:02 - I'm assuming that in the request body we
32:05 - have an object and that object has a
32:06 - name property now in order for this line
32:10 - to work we need to enable parsing of
32:13 - JSON objects in the body of the request
32:15 - because by default this feature is not
32:17 - enabled in express so on the top after
32:21 - we get the app object
32:24 - we need to call app that use and here we
32:28 - call Express dot JSON now this may look
32:34 - a little bit strange or unfamiliar to
32:36 - you but don't worry later in this
32:38 - section we're going to explore this in
32:39 - detail basically what we're doing here
32:42 - is adding a piece of middleware
32:44 - so when we call Express the JSON meta
32:47 - this method returns a piece of
32:49 - middleware and then we call app dot use
32:52 - to use that middleware in the request
32:55 - processing pipeline again we're going to
32:57 - explore that in detail later in the
32:59 - section so back to our new route handler
33:04 - you have a course object next we push it
33:08 - in our array so courses dot push course
33:13 - and finally by convention when we post
33:16 - an object to the server when the server
33:18 - creates a new object or a new resource
33:20 - you should return that object in the
33:23 - body of the response so response that's
33:27 - and course
33:29 - the reason for this is because we are
33:32 - assigning this ID on the server so we
33:35 - need to return this course object to the
33:36 - client because chances are the client
33:39 - needs to know the idea of this new
33:41 - object or this new resource so this is
33:43 - how we handle HTTP POST requests in the
33:47 - next lecture I'm going to show you how
33:48 - to test this endpoint
33:55 - all right to call HTTP services we use a
33:58 - Chrome extension called postman so if
34:01 - you have an installed postman before
34:02 - search for Chrome postman here is
34:08 - postman simply add it to Chrome ok done
34:16 - now you can open this from the apps menu
34:19 - here postman I hear it's asking you to
34:22 - sign up for an account but you don't
34:23 - have to do this there's a link here take
34:26 - me straight to the app alright now on
34:29 - this page we can create a new HTTP
34:31 - request
34:32 - so from this drop-down list we set the
34:35 - type to a post request you put the URL
34:39 - here in this case that's HTTP localhost
34:43 - on my machine I'm using port 3000 to
34:46 - host this application API slash courses
34:50 - now we need to set the body of this
34:54 - request from this list select raw and
34:57 - then
34:59 - JSON so with this we can put a JSON
35:03 - object in the body of the request so
35:06 - let's add an object here and give it a
35:09 - name property so name we set this to new
35:13 - course and then finally send okay if you
35:18 - scroll down you can see the status of
35:20 - the request is 200 which means the
35:22 - request was handled successfully and
35:24 - here's the body of the response so IDs
35:28 - for because now we have four courses in
35:30 - our array and this is the same name that
35:33 - we send to the server so this is how we
35:35 - test HTTP services is in postman now in
35:39 - this implementation we have assumed that
35:42 - there is an object with the name
35:44 - property in the body of the request what
35:48 - if the client forgets to send this
35:49 - property or sends an invalid name
35:52 - perhaps a name that is too short that's
35:54 - where input validation comes into the
35:56 - picture and that's the topic for the
35:58 - next lecture
36:04 - in this lecture I'm going to show you
36:06 - how to do input validation so as a
36:09 - security best practice you should never
36:11 - ever ever trust what the client sends
36:14 - you
36:15 - you should always validate the input so
36:18 - in this particular example because we're
36:20 - dealing with a simple object with only
36:22 - one property that is named we can write
36:24 - some validation logic like this
36:28 - so if requests the body that name
36:35 - doesn't exist or requests that body the
36:41 - name that length is less than 3 then
36:47 - we're gonna return an error to the
36:48 - client the restful convention is to
36:51 - return a response with the HTTP status
36:54 - code or 400 that means bad requests so
37:00 - to do this recall response that status
37:06 - 400 and then we can send an error
37:10 - message in this case we can write a
37:12 - generic error message like name is
37:15 - required and should be minimum three
37:19 - characters in your implementation you
37:22 - may want to differentiate the errors for
37:24 - example if the client didn't send the
37:26 - name property perhaps you would just
37:28 - respond with name is required or if they
37:32 - did send the name but the name was not
37:34 - long enough you could send a different
37:36 - error message and then finally we
37:39 - returned here because we don't want the
37:40 - rest of this function to be executed so
37:43 - this is the basic idea however in a real
37:46 - world application it's more likely that
37:48 - you'll be working with a complex object
37:50 - something more complex than this course
37:52 - object here you don't want to write a
37:55 - complex validation logic like this at
37:57 - the beginning of your route handler so
38:00 - let me introduce you to a new package
38:01 - that makes it really easy for you to
38:03 - validate the input so on Google if you
38:07 - search for NPM joy with I look here is
38:12 - the first link so here you can see joy
38:16 - has been downloaded over to
38:18 - 150,000 times or the past day and over
38:22 - three million times over the past month
38:24 - it's a very popular package also here on
38:27 - this page you can see some sample code
38:29 - and link to your official documentation
38:32 - now let me show you how to replace this
38:35 - validation logic with joy
38:37 - so first back in terminal let's install
38:41 - joy so you can see it at the time of
38:46 - recording this video the latest version
38:49 - is version 13 point 1.0 if you want to
38:52 - make sure that you have the exact same
38:54 - experience as what I'm going to show you
38:56 - in this video then install this exact
38:58 - version so npm install joy at thirteen
39:03 - point one point zero okay now back in
39:06 - the code on the top we need to load this
39:10 - module so require joy get the result and
39:16 - store it in a constant called joy with a
39:19 - capital J because what is returned from
39:21 - this module is a class and as I told you
39:24 - before in JavaScript we use Pascal
39:26 - naming convention to name our classes so
39:29 - the first letter of every word should be
39:31 - uppercase also as a best practice with
39:35 - all your required calls on top of the
39:37 - file this way you can easily see what
39:39 - are the dependencies of this module so
39:42 - this module index module is dependent
39:44 - upon two modules one is joy the other is
39:47 - Express okay so we have this joy class
39:51 - now packing our route handler now with
39:55 - joy first we need to define a schema
39:58 - schema defines the shape of our objects
40:01 - what properties do we have in that
40:02 - object what is the type of each property
40:04 - do we have an email do we have a string
40:07 - what are the minimum or maximum number
40:09 - of characters do we have a number what
40:11 - range should that number be so this is
40:13 - the job of a schema so here first I'm
40:16 - going to define a schema constant schema
40:22 - we set it to an object this is the shape
40:26 - of our course object so here we want to
40:28 - have a name property and we said this to
40:31 - joy
40:32 - dot string so we're telling joyed that
40:35 - this is a string and it should have
40:37 - minimum three characters and it should
40:40 - be required so it has a very fluent API
40:43 - again you can look at the documentation
40:45 - to see all the methods that are
40:47 - available to you so here's our a schema
40:50 - now we call joy that validate and we
40:55 - give it request that body as well as our
40:59 - schema now this validate method returns
41:02 - an object let's store that in a constant
41:05 - called result for this demo I'm gonna
41:10 - log this result on the console so before
41:14 - we go any further let's save this go
41:17 - back to the postman let's create another
41:20 - course now back in the terminal so this
41:24 - is a result object it has two properties
41:27 - error and value only one of these can
41:31 - have a value so in this case because we
41:33 - sent a valid course object we have that
41:36 - object here as the value of the value
41:39 - property and you can see error is not if
41:43 - we send an invalid object value will be
41:46 - null and error will be set let me show
41:48 - you so I can postman let's remove the
41:53 - name property send now back in the
41:56 - terminal okay look so here's the result
42:01 - object this is the error property it's
42:03 - set to an object that has validation
42:06 - error child name fails because name is
42:09 - required so back to a route handler
42:13 - instead of this manual validation logic
42:15 - we can check the value of result that
42:18 - error property so if result that error
42:24 - then we're gonna send a response with
42:26 - status code of 400 and in the body of
42:30 - the response for now we can simply add
42:33 - result an error okay and we don't need
42:38 - this constant along anymore
42:41 - save now back in postman one more time
42:45 - I'm gonna send this empty object now
42:49 - look at the response so this is what we
42:51 - get an object with these properties is
42:54 - joy name details which is an array of
42:58 - error messages so here's the first
43:00 - message name is required now this object
43:03 - is too complex to send to the client
43:05 - perhaps you want to simplify this so
43:09 - back in the code one simple solution is
43:13 - to go to the details array get the first
43:17 - element and then access the message
43:19 - property or instead of using the first
43:22 - element you may want to access all
43:24 - elements in this array get their message
43:27 - property and concatenate them that's
43:29 - entirely up to you so save one more time
43:32 - let's send an invalid request and now we
43:36 - get name is required if we go to our
43:40 - request and add the name property but
43:42 - set it to a string that is only 1
43:44 - character now we get a different error
43:48 - name length must be at least 3
43:51 - characters long so you can see joy makes
43:54 - it really easy to validate the input and
43:56 - return proper error messages to the
43:59 - client
44:05 - all right now let's see how we can
44:06 - update a course so let's add a new route
44:11 - handler app we use the put method for
44:16 - updating resources now the path should
44:20 - be slash API slash courses and here we
44:25 - need a route parameter because we're
44:27 - dealing with your specific course
44:28 - so ID now our route handler function
44:32 - request son response goes to a code
44:36 - block alright now here's the logic we
44:39 - need to implement first we need to look
44:41 - up this course with this given ID so
44:44 - look up the course if the course doesn't
44:46 - exist if not existing we need to return
44:49 - 404 that means resource not found
44:53 - otherwise we need to validate the course
44:56 - make sure it's in good shape
44:58 - if invalid we need to return a 400 error
45:03 - which means that request and if you get
45:07 - here that means everything is good so
45:09 - you update the course and return the
45:14 - updated course to the client this is the
45:17 - logic we need to implement so we already
45:19 - have some code that we can reuse here so
45:22 - I'm not going to type everything by hand
45:23 - I'm gonna copy some code from our other
45:26 - route handlers so first we want to look
45:28 - up the course and if it doesn't exist
45:30 - you want to return a 404 error for that
45:33 - I'm gonna go to this other rat handler
45:36 - where we get a single course this is the
45:39 - logic we're interested in so we look up
45:42 - the course and if it doesn't exist we
45:44 - return a 404 error so copy these two
45:47 - lines we're done with the first part the
45:52 - second part is all about validation for
45:55 - that I'm gonna go to our post endpoint
45:59 - so here we need to copy the schema as
46:02 - well as this line for validating the
46:05 - request body using joy and there is a
46:08 - problem with this approach the problem
46:10 - is in this case we have a very simple
46:12 - schema what if you are dealing with a
46:14 - complex object with quite a few
46:16 - properties then
46:18 - or validation logic would be duplicated
46:21 - in two different round handlers so let's
46:23 - just copy the code for now and then
46:25 - we'll come back and refactor it to make
46:27 - it better so copy these few lines and
46:34 - paste it here
46:36 - so we're validating and if it's invalid
46:39 - we need to return a 400 error so I
46:42 - forgot to copy that line here if you
46:45 - have an error in the result we're gonna
46:47 - return it's 400 error okay
46:49 - so let's copy that as well so this is
46:55 - our second part we have this schema we
46:58 - validate and if you have an error we
47:00 - return a 400 error we're done with the
47:03 - second part now the third part so at
47:08 - this point we have a course object we
47:11 - can update its properties so of course
47:15 - that name we said that to request the
47:18 - body the name and of course if we have
47:21 - other properties we'll set them here as
47:23 - well so we're done with opting in the
47:26 - course and finally we need to return the
47:28 - updated course to the client so response
47:32 - that's and course this is how we handle
47:36 - an HTTP put request now I told you that
47:41 - we have duplicated this validation logic
47:43 - so I'm going to extract these few lines
47:46 - into a separate function that we can
47:49 - reuse both in this route handler for
47:52 - handling our HTTP put requests as well
47:55 - as the other one we wrote in the last
47:57 - lecture for creating a course
48:00 - so let's define a function here and call
48:04 - it validate course we give it a course
48:08 - object now in this function we should
48:13 - have the schema as well as this line for
48:17 - validating the course so cut these few
48:20 - lines place it here now instead of
48:24 - validating requested body you're gonna
48:27 - validate the argument that is passed to
48:29 - this method so that would be the course
48:32 - object now finally we can simply return
48:36 - this result to the caller there is no
48:41 - need to define a constant so with this
48:44 - new implementation we have all the
48:46 - validation logic in one place now we can
48:49 - reuse this so here is our put method
48:54 - we define a constant call result and
48:57 - study to validate course and as an
49:01 - argument we pass request dot body now we
49:06 - can make this code a little bit cleaner
49:07 - and shorter by using object
49:10 - destructuring feature and modern
49:12 - JavaScript so look here we get this
49:14 - result object and we're accessing result
49:17 - that error property in two different
49:20 - places since all we are interested in is
49:22 - this error property we can get this
49:25 - using object destructuring so let me
49:28 - duplicate this line and show you how
49:31 - object restructuring works with object
49:34 - is structuring when declaring a variable
49:36 - or a constant we add curly braces and
49:40 - then here we add the property of the
49:44 - target object so in this case the target
49:47 - object that is returned from our
49:49 - validate course method has two
49:51 - properties error and value in this case
49:54 - we just want the error property so we
49:57 - put that between curly braces so this is
50:00 - equivalent to getting result that error
50:03 - one instead of using this notation we
50:05 - use this notation okay
50:10 - and with this we don't have to repeat
50:13 - result that error in two different
50:15 - places we can simply use error okay so
50:20 - this is object destructuring now we
50:22 - don't need this first line anymore and
50:25 - finally before we finish this lecture we
50:28 - need to make one more change in this
50:29 - code so we need to use this new way of
50:31 - validating a course in the route handler
50:34 - for handling our HTTP POST requests so
50:38 - copy this is our handler for creating a
50:42 - new course now we don't need to use this
50:44 - schema here we moved all that logic to
50:47 - our validate course function so all
50:50 - these few lines here for validating the
50:53 - request body and sending the 400 error
50:55 - I'm going to delete this and paste the
50:58 - code that we copied from the other
50:59 - method so we call validate course use
51:03 - object D structure and syntax and if you
51:06 - have an error you return the 400
51:08 - response to the client now finally let's
51:11 - test our new endpoint for updating a
51:14 - course
51:14 - so back in postman we need to change the
51:19 - type of this HTTP request to put change
51:23 - the URL and add a valid course ID like
51:28 - one here we have a pilot course object
51:31 - with name set to new course so send and
51:35 - we get a 200 response which is
51:37 - successful and here is the updated
51:39 - course so if you open any new tab and
51:43 - send an HTTP GET request to localhost /
51:48 - api / courses now you should see the
51:52 - list of our courses so our first course
51:54 - it's name is up data perfect now let's
51:58 - test the other scenarios what if you
52:00 - send an invalid ID so 10 send the course
52:06 - with the given ID was not found and you
52:07 - can see the response is 404 which means
52:10 - not found and finally what if you send a
52:13 - valid course ID but an invalid course
52:16 - object so I'm gonna remove the name
52:18 - property send now you can see we have a
52:22 - bad request for 400
52:24 - error and here's error message name is
52:26 - required next I'm gonna show you how to
52:29 - handle HTTP delete requests
52:36 - so out of all the crud operations you
52:39 - have implemented create read and update
52:42 - so in this lecture I'm gonna show you
52:44 - how to respond to HTTP delete requests
52:47 - it's very simple and similar to what we
52:49 - have done so far so here's our app
52:54 - object we call the delete method give it
52:58 - a pass that is slash API slash courses
53:01 - and of course we need a parameter
53:04 - because we're working with a specific
53:05 - course then a raft Handler request our
53:09 - response goes to the code block now here
53:13 - first we need to look up the course the
53:15 - course would be given ID if it doesn't
53:17 - exist then we need to return 404
53:22 - otherwise we're going to delete it and
53:25 - by convention return the same course the
53:29 - course that was deleted so again I'm
53:31 - gonna borrow some code from our other
53:34 - grant handlers to look up the course and
53:37 - return a 404 error I'm gonna go back for
53:40 - ramp handler for the HTTP put request so
53:44 - these first two lines is for looking up
53:47 - the course and returning a 404 error so
53:50 - copy these two lines back here that is
53:55 - our first part done now to delete a
54:00 - course first we need to find the index
54:03 - of this course in our courses array so
54:06 - courses dot index of course
54:12 - we get the index store it in a constant
54:15 - and then we can use this splice method
54:18 - to remove an object from our courses
54:21 - array so courses dot splice we go to
54:25 - this index and remove one object so this
54:29 - is the delete part and finally we need
54:32 - to return the response to the client so
54:34 - response let's send this course object
54:38 - now let's test this
54:40 - so back in postman let's change put to
54:45 - delete first I want to send an invalid
54:49 - course ID like ten send so we get a 404
54:53 - error not found with this message
54:55 - perfect now let's delete the first
54:58 - course course with the ID one send so we
55:02 - get the same course object in the
55:03 - response and if we go to our second tab
55:06 - where we have the list of our courses so
55:10 - look we have an HTTP GET request to the
55:13 - send point let's send this one more time
55:15 - okay now look we don't have our first
55:18 - course anymore we only have courses with
55:20 - ID two and three all right before we go
55:26 - any further I realize we have a bug or
55:28 - actually three bugs in this code so look
55:31 - at the handler or responding to put
55:34 - requests to this endpoint if we don't
55:37 - have a course with the given ID we
55:40 - return the 404 error to the client but
55:43 - at this point we should exit this route
55:45 - handler otherwise the rest of this code
55:47 - will be executed so the proper way to
55:50 - implement this round handler is like
55:52 - this so if you don't have this course we
55:58 - return the response and then exit the
56:01 - function or a shorter way to write the
56:04 - same code is to put the return here and
56:07 - then we don't need the code block so we
56:10 - can put everything in one line okay now
56:15 - to make this code cleaner let's use the
56:18 - same technique in case we have an
56:20 - invalid request so we simply return
56:25 - and then we don't need the code lock
56:28 - anymore that's much more elegant you
56:33 - have the same issue in the handler for
56:36 - delete requests so if you don't have a
56:38 - course here we should return immediately
56:41 - the same is true when getting a single
56:46 - course so if we don't have a course with
56:48 - the given ID we return the 404 error and
56:51 - also return from this function
56:54 - immediately now finally let's have a
56:57 - look at the handler for HTTP POST
57:00 - requests here it is again I'm gonna use
57:04 - the same technique to clean up this code
57:06 - so if you have an error we simply return
57:10 - and get rid of the extra noise in the
57:14 - code that's much better
57:21 - all right now it's time for an exercise
57:25 - so from this lecturer we're gonna start
57:27 - building the back-end services for our
57:30 - VIP little acacia as I told you before
57:32 - Whitley is an imaginary service for
57:36 - renting out movies so throughout this
57:38 - course we're going to build the backend
57:40 - of Whitley bit by bit
57:42 - your first task is to create a service
57:45 - from managing the list of genres so each
57:48 - movie as a genre like action horror
57:51 - whatever we should have an endpoint for
57:54 - getting the list of all genres because
57:56 - somewhere in our client applications
57:58 - perhaps we have a drop-down list for the
58:00 - user to select a genre so we need an
58:03 - endpoint to get all the genres we should
58:05 - also be able to create a new genre as
58:07 - well as update or delete an existing one
58:10 - so before going any further I want you
58:13 - to put what you have learned so far in
58:15 - practice so even if you're an
58:16 - experienced developer don't say no mosh
58:19 - I know how to do this this is so easy I
58:21 - know it's easy but what matters now is
58:23 - that I want you to get used to this
58:25 - theme tax so go ahead start a new
58:28 - project from scratch call it bitly and
58:30 - build this HTTP service for managing the
58:33 - list of genres you can see my solution
58:35 - attached to this lecture

Cleaned transcript:

so earlier in section 2 where we talked about nodes module system you learned about this HTTP module we use this to create a web server that listens on port 3000 and responds to requests for these endpoints so the route or such API slash courses now while this approach is perfectly fine it's not ideal for building a complex application because in a large complex application we might have various endpoints and we don't want to hardcode all these if statements in this function so in this section we're going to look at Express which is a fast and lightweight framework for building web applications so next we're gonna look at restful services let's start the section by a brief introduction to restful services also called restful api s if you already know what rest is all about feel free to skip this video so earlier at the beginning of the course I introduced you to the clientserver architecture so most if not all applications we use these days follow this architecture the app itself is the client or the frontend part under the hood it needs to talk to a server or the backend to get or save the data this communication happens using the HTTP protocol the same protocol that powers our web so on the server we expose a bunch of services that are accessible via the HTTP protocol the client can then directly call the services by sending HTTP requests now this is where rest comes into the picture rest is short for representational state transfer and I know it probably doesn't make any sense to you because it was introduced by PhD student as part of his thesis but the theory aside rest is basically a convention for building these HTTP services so we use simple HTTP protocol principles to provide support to create read update and delete data we refer to these operations all together as crud operations now let's explore this convention using a real world example let's say we have a company called bitly for renting out movies we have a client app where we manage the list of our customers on the server we should expose a service at an endpoint like this so vid lucam / api / customers so the client can send HTTP requests to this endpoint to talk to our service now a few things about this endpoint you need to know first of all the address can start with HTTP or HTTPS that depends on the application and its requirements if you want the data to be exchanged on a secure Channel you would use HTTPS after that we have the domain of the application next we have slash API this is not compulsory but you see a lot of companies follow this convention to expose their restful services they include the word API somewhere in the address it can't be after the domain or it can be a sub domain like API that vidlink aam there is no hard and fast rule after that we have slash customers which refers to the collection of customers in our application in the rest world you refer to this part as a resource we can expose our resources such as customers movies rentals on various endpoints so this is our endpoint to work with the customers all the operations around customers such as creating a customer or updating a customer would be done by sending an HTTP request to this endpoint the type of the HTTP request determines the kind of the operation so every HTTP request has what we call a verb or method that determines its type or intention here are the standard HTTP methods we have yet for getting data post or creating data put for updating data and delayed for deleting data now let's explore each of these using our customers example to get the list of all customers we should send an HTTP GET request to this address note the full name customers here it indicates a list of customers so when we send an HTTP GET request to this endpoint our service should send us something like this so we have an array of customer objects if you want a single customer we should include the idea of that customer in the address then our server would respond with a customer object like this now to update a customer we should send an HTTP put request to this endpoint and note that again here we're specifying the idea of the customer to be updated but also we should include the customer object in the body of the request so this is a complete representation of the customer object with updated properties we send this to the server and the server updates the customer with the given ID according to these values similarly to delete a customer we should send an HTTP delete request to this endpoint but here we don't need to include the customer object in the body of the request because all we need to delete a customer is an ID and finally to create a customer we need to send an HTTP POST request to this endpoint note that here because we're adding a new customer you're not dealing with a specific customer so we don't have the ID in the address you're working with the collection of customers so we're posting a new customer to this collector and that's why we should include the customer object in the body of the request the server gets this object and creates the customer for us so this is the restful convention we expose our resources such as customers using a simple meaningful address and support various operations around them such as creating or updating them using standard HTTP methods so throughout this section you're going to learn how to use the Express framework to build a restful service from managing the list of customers however in this section we won't be doing any database work because that will bring in additional complexity our focus will be purely on building HTTP services and we will use a simple array in memory to keep the list of our customers later in the course we'll look at using a database so here's the code that we wrote in the section about node core where I introduce you to the HTTP module so we can see with HTTP module we can create a web server here we have a callback function that takes two parameters request and response and with this request object we can check the URL of the incoming request so with this we can define various routes for our application so if you have a request for let's say slash API slash courses this is how we're going to respond to the client now while this approach certainly works it's not very maintainable because as we define more routes for our application we need to add more if blocks in this callback function so that's when a framework comes into the picture a framework gives our application a proper structure so we can easily add more routes while keeping our application code maintainable now there are various frameworks out there for building web applications and web servers on top of note the most popular one is Express so if you head over to NPM JSE org or NPM J is calm here let's search for Express so the current version is version 4.2 16.2 let's have a quick look here so here on the right side look at the statistics there have been over 700,000 downloads in the last day and over 15 million downloads in the last month it's a very popular framework it's also very fast lightweight and perfectly documented so now back in the terminal let's create a new folder for this section so I'm gonna call this Express demo now let's go inside this folder run NPM init with yes flag so now we have a package JSON file and finally we can install Express beautiful in the next lecture I'm gonna show you how to build your first web server using Express all right now in vs code let's add a new file index the jas we could also call it app to J's it doesn't really matter so in this file first we want to load the Express module so we use our require function give it the name of our module which is Express now this returns a function we call that Express okay now we need to call this function like this and as you can see this returns an object of type Express by convention we call this object app so we store the result in a constant called app so this represents our application now this app object has a bunch of useful methods we have methods like get post put and delete all these methods correspond to HTTP verbs or HTTP methods that I told you about earlier in this section so if you want to handle an HTTP POST request to an endpoint you would use app that post now in this lecture we just want to use app but yet we want to implement a couple of endpoints that respond to an HTTP GET request so this method takes two arguments the first argument is the pass or the URL so here I'm going to use slash to represent the route of the website now the second argument is a callback function this is the function that will be called when we have an HTTP GET request to this endpoint okay so this callback function shall have two arguments request and response so this goes to a code block now this request object has a bunch of useful properties that gives us information about the incoming request if you want to learn about all these properties it's best to look at the Express documentation because in this course we're going to use only a handful of these properties so head over to Express Jas comm on the top look at API reference version 4 now here you can see the request object and below that you can see all the properties that are available to you you have base URL we have body to read the body of the request cookies fresh host name IP method original URL parameters and so on so back to our code when we get an HTTP GET request to the root of our website you're gonna respond with a hello world message so response dots and hello world so this is how we define a route we specify the path or the URL and a callback function which is also called a route handler now finally we need to listen on a given point so we call app that listen we give it a port number like 3,000 and optionally we can pass a function that will be called when the application starts listening on the given port so once again we use the arrow function syntax to display something on the console so console dot log listening on port 3,000 now back in the terminal note index j s okay we're listening on port 3000 now let's switch over to Chrome and go to localhost port 3000 so here's our hello word message now let's define another route so once again we're gonna call app that get now this one is going to be slash API slash courses once again we pass a function with two arguments then it's request and response and this goes to a code block now in a real world scenario here you want to get the list of courses from the database and return them but as I told you before in this section our focus is purely on building these endpoints you're not gonna do any database work so I'm gonna simply return an array of numbers so response that's and it passed an array of three numbers in the future we can replace these numbers with actual course objects so save now back in the terminal we have to stop this process and started the game so press ctrl + C okay one more time node index J is now back in Chrome let's head over to slash API slash courses look we have an array of three numbers beautiful so this is what I want you to pay attention to here in this implementation we don't have those eve blocks we define new routes by calling app that yet and with this structure as our application grows we can move some of these routes to different files for example we can move all the route related to courses to a separate file like courses that Jas so Express gives our application is skeleton is structure so far you have noticed that every time we make a change to this code you have to go back in the terminal and stop this process and started the game this is very tedious so I'm gonna show you a better way we're gonna install a note package called note Mon which is short for node monitor so in the terminal and p.m. install G because we want to install this globally so we can run it anywhere and the name of the package is node Mon now as I told you before if you're on Mac and you haven't configured the permissions properly in it put sudo at the front all right no one is installed so with this instead of running our application using node we use node Mon okay now you can see node Mon is watching all the files in this folder any files with any extensions so if we come back here and make a simple change and then save the file now look in the terminal node Hmong restarted our application or our process due to changes so we don't have to do this manually anymore now back in the browser if you send a request to the root of the website we can see our new message displayed here now one thing we need to improve in this code is this hardcoded value for the port so we have used 3000 as an arbitrary number while this may work on your development machine it's unlikely that this is gonna work in a production environment because when you deploy this application to a hosting environment the port is dynamically assigned by the hosting environment so we can't rely on 3000 to be available so the way to fix this is by using an environment variable so typically in hosting environments for node applications we have this environment variable called port an environment variable is basically a variable that is part of the environment in which a process runs its value is set outside this application I'm gonna show you how that works in a second so in this application we need to read the value of this port environment variable and the way we do that is by using the process object so we have this global object called process this object has a property called M which is short for environment variables and after that we add the name of our environment variable in this case port so if this is set we're gonna use this otherwise we're gonna use 3000 now we can store the result in a constant called port okay let's delete this and finally we need to replace 3000 with port and also change our message accordingly so I'm going to replace a single coat with backtick so we can use a template string and here we're gonna replace 3000 with a dynamic value so I'm here at dollar sign curly braces and then add our constant in this case port okay now back in the terminal let's run this application using node maaan so on this machine you can see I don't have an environment variable called port that's why 3000 is used as the port for this web server now I'm going to set an environment variable so let's stop this process on Mac we can set an environment variable by executing the export command if you're on Windows you should use set so export or set now we add the name of the environment variable in this case port and set its value I'm going to use 5,000 so now we have this environment variable called port with the value of 5,000 with this when we run this application node man you can see that now we are listening on port 5000 so this is the proper way to assign a port to your node applications you should attempt to read the value of an environment variable called port if there is a value you should use that otherwise use an arbitrary number for your development machine you all right so currently we have a route for getting the list of courses now in this lecture I'm going to show you how to create a route to get a single course so earlier in the section where I talked about restful services you learn that in order to get a single course we should include the idea of the course and the URL so our endpoint should be like this slash API slash courses slash one assuming that one is the idea of the course so let's see how we can implement a route like this so app that get we add the path that is slash API slash courses and here we need to define a parameter so we add and ID so idea is the name of our parameter here you could use anything it doesn't have to be ID it could be course ID but ID is shorter and more conventional now we had our route handler function so request and response goes to now in order to read this parameter we use request dot params dot ID so for now let's just send this to the client so resource let's send okay back in the browser now let's head over to slash API is that courses slash one so you can see we successfully read the value of this parameter also it is possible to have multiple parameters in a route for example imagine you're building a service for powering a block so we could have a route like this posts here month so we have two parameters and with this we can get all the posts for the given month and the given here now we can read these parameters just like before so requested params that year or a month for this demo let me show you this requested params object so let's delete this save back in the browser now let's head over to API posts 2018 and one so this is our request params object we have two properties year and month and their name based on a route parameters we express we can also get Kariya string parameters these are parameters that we add in the URL after question mark for example we can get all the posts in January 2018 and sort them by their name so we add a question mark sort by set this to name this is a query string parameter we use query string parameters to provide additional data to our backend services so we use route parameters for essential or required values whereas we use query string parameters for anything that is optional now let me show you how to read query parameters so I can view scope instead of requested params we use request dot query save back in Chrome and this is what we get so query parameters are stored in an object with a bunch of key value pairs hi guys thank you for watching my Noah tutorial I wanted to let you know that this tutorial is the first hour of my complete note course where you will learn how to build a real restful api using node Express and MongoDB all of that recorded with the latest version of node and modern JavaScript so you will learn new and modern ways of building applications with node unlike other courses that only show you simple the only examples like how to build a todo app we're gonna work on a realworld project a restful api for a video rental application if you have taken any of my courses you know i don't waste your time by explaining the obvious like what a code editor or command prompt is we're gonna get straight to the business and as part of this i'll be touching on various important topics that you need to understand really well including working with node package manager or npm asynchronous javascript including callbacks promises async and await implementing crud operations data validations authentication and authorization using JSON web tokens including role management handling and login errors unit and integration testing testdriven development so you will see I will build a feature from A to Z using testdriven development or TDD and finally we'll deploy this application to the cloud throughout the course I will share with you lots of clean coding and refactoring techniques security best practices useful libraries to use as part of your development common mistakes that many note developers make and much much more the course is currently 14 hours long and I'm planning to add more content to it in the future you can watch this course as many times as you want and if you watch it to the end you will get a certificate of completion that we can add to your resume so if you're serious about adding no to your resume I highly encourage you to enroll in the course and don't waste your time jumping from one tutorial to another so click on the link in the video description to enrol I hope to see you in the course alright now let's implement a new endpoint to get a single course from the server so first of all let's change this back to courses and add the ID parameter here okay now on the top let's define an array called courses so constant courses we set this to an array and in this array we're going to have three course objects so each object should have a couple of properties ID and name and of course we can have more but for simplicity I'm just gonna stick to two properties here okay now let's duplicate this line and change the IDs as well as the name two and three so we have two endpoints want to get all the courses and the other two get a single course right in the first one we're gonna return our courses are aokay right in the second one we should write some logic to look for the course with the given ID so let me delete this first we're gonna call courses that find this is a method that is available on every array in JavaScript as an argument to this method we need to pass a function this function will be used to find a course that matches a given criteria so we use the arrow function syntax C goes to and here we write some logic that returns a boolean value this boolean value determines if this course is the one we're looking for or not so see that ID should equal request that params dot ID however this requested prams that ID returns a string so in order for this comparison to work properly we need to parse this string into an integer so we call parse int which is one of the global functions available in JavaScript and then get the result and store it and a constant called course now you might be asking why I didn't use var here well that would be perfectly fine and that's how most JavaScript code out there is written but going forward it's best to drop var and either use let or Const we use let if you want to define a variable that we can reset later and we use Const if you want to define a constant in this case I don't want to reset the course later in this function but again that's perfectly fine to use let here as well it's just personal preference so we get the course object now if this course doesn't have a value in other words if we don't find a course for the given ID by convention we should return a response with the HTTP status code of 404 that means object not found so this is one of the conventions of restful api so if the client asks for a resource but that resource does not exist on the server we should return a response with the status code of 404 so here we call response dot status 404 and optionally we can send a message to the client as well so send the course with the given ID was not found okay now otherwise if we do have a course with that ID we're simply going to return that to the client so response that's and course now let's test this so back in the browser let's head over to slash API slash courses slash one so we have a course with the ID one and that's why we get this JSON object in the response however if I change this to ten we can this message the course with the given ID was not found and to ensure that the status code of this response is 404 we can open up Chrome developer tools so right click here go to inspect and then on the network tab make sure you don't have a filter here so select all and then refresh the page by pressing ctrl R on Windows or command R on Mac so here's a request that we sent to the server you can see the status is 404 which means not found so far we have created two routes that respond to HTTP GET requests and we use this route to get all the courses as well as a single course in this lecture I'm going to teach you how to respond to HTTP POST requests so we use an HTTP POST request to create a new course so app that post instead of the get method we use the post method now similar to the get method we need to specify a path so that should be a slash API slash courses because we're going to post to the collection of courses that's why we use the plural name here then we add our route handler so request and response goes to code block now I'm going to add some line break here so I can easily see this video all right so in this route handler we need to read the course object that should be in the body of the request use these properties to create a new course object and then add that course object to our courses array so let's create a new course object constant course again I'm using a constant here because we're not going to reset this course object later so let's set this to a new object now here because we are not working with a database we need to manually assign an ID so ID so we get the number of elements in our courses array so courses dot length and simply add one to it in the future when we work with the database the ID will be assigned by the database next is the name property now we need to read this from the body of the request so request that body that name so here I'm assuming that in the request body we have an object and that object has a name property now in order for this line to work we need to enable parsing of JSON objects in the body of the request because by default this feature is not enabled in express so on the top after we get the app object we need to call app that use and here we call Express dot JSON now this may look a little bit strange or unfamiliar to you but don't worry later in this section we're going to explore this in detail basically what we're doing here is adding a piece of middleware so when we call Express the JSON meta this method returns a piece of middleware and then we call app dot use to use that middleware in the request processing pipeline again we're going to explore that in detail later in the section so back to our new route handler you have a course object next we push it in our array so courses dot push course and finally by convention when we post an object to the server when the server creates a new object or a new resource you should return that object in the body of the response so response that's and course the reason for this is because we are assigning this ID on the server so we need to return this course object to the client because chances are the client needs to know the idea of this new object or this new resource so this is how we handle HTTP POST requests in the next lecture I'm going to show you how to test this endpoint all right to call HTTP services we use a Chrome extension called postman so if you have an installed postman before search for Chrome postman here is postman simply add it to Chrome ok done now you can open this from the apps menu here postman I hear it's asking you to sign up for an account but you don't have to do this there's a link here take me straight to the app alright now on this page we can create a new HTTP request so from this dropdown list we set the type to a post request you put the URL here in this case that's HTTP localhost on my machine I'm using port 3000 to host this application API slash courses now we need to set the body of this request from this list select raw and then JSON so with this we can put a JSON object in the body of the request so let's add an object here and give it a name property so name we set this to new course and then finally send okay if you scroll down you can see the status of the request is 200 which means the request was handled successfully and here's the body of the response so IDs for because now we have four courses in our array and this is the same name that we send to the server so this is how we test HTTP services is in postman now in this implementation we have assumed that there is an object with the name property in the body of the request what if the client forgets to send this property or sends an invalid name perhaps a name that is too short that's where input validation comes into the picture and that's the topic for the next lecture in this lecture I'm going to show you how to do input validation so as a security best practice you should never ever ever trust what the client sends you you should always validate the input so in this particular example because we're dealing with a simple object with only one property that is named we can write some validation logic like this so if requests the body that name doesn't exist or requests that body the name that length is less than 3 then we're gonna return an error to the client the restful convention is to return a response with the HTTP status code or 400 that means bad requests so to do this recall response that status 400 and then we can send an error message in this case we can write a generic error message like name is required and should be minimum three characters in your implementation you may want to differentiate the errors for example if the client didn't send the name property perhaps you would just respond with name is required or if they did send the name but the name was not long enough you could send a different error message and then finally we returned here because we don't want the rest of this function to be executed so this is the basic idea however in a real world application it's more likely that you'll be working with a complex object something more complex than this course object here you don't want to write a complex validation logic like this at the beginning of your route handler so let me introduce you to a new package that makes it really easy for you to validate the input so on Google if you search for NPM joy with I look here is the first link so here you can see joy has been downloaded over to 150,000 times or the past day and over three million times over the past month it's a very popular package also here on this page you can see some sample code and link to your official documentation now let me show you how to replace this validation logic with joy so first back in terminal let's install joy so you can see it at the time of recording this video the latest version is version 13 point 1.0 if you want to make sure that you have the exact same experience as what I'm going to show you in this video then install this exact version so npm install joy at thirteen point one point zero okay now back in the code on the top we need to load this module so require joy get the result and store it in a constant called joy with a capital J because what is returned from this module is a class and as I told you before in JavaScript we use Pascal naming convention to name our classes so the first letter of every word should be uppercase also as a best practice with all your required calls on top of the file this way you can easily see what are the dependencies of this module so this module index module is dependent upon two modules one is joy the other is Express okay so we have this joy class now packing our route handler now with joy first we need to define a schema schema defines the shape of our objects what properties do we have in that object what is the type of each property do we have an email do we have a string what are the minimum or maximum number of characters do we have a number what range should that number be so this is the job of a schema so here first I'm going to define a schema constant schema we set it to an object this is the shape of our course object so here we want to have a name property and we said this to joy dot string so we're telling joyed that this is a string and it should have minimum three characters and it should be required so it has a very fluent API again you can look at the documentation to see all the methods that are available to you so here's our a schema now we call joy that validate and we give it request that body as well as our schema now this validate method returns an object let's store that in a constant called result for this demo I'm gonna log this result on the console so before we go any further let's save this go back to the postman let's create another course now back in the terminal so this is a result object it has two properties error and value only one of these can have a value so in this case because we sent a valid course object we have that object here as the value of the value property and you can see error is not if we send an invalid object value will be null and error will be set let me show you so I can postman let's remove the name property send now back in the terminal okay look so here's the result object this is the error property it's set to an object that has validation error child name fails because name is required so back to a route handler instead of this manual validation logic we can check the value of result that error property so if result that error then we're gonna send a response with status code of 400 and in the body of the response for now we can simply add result an error okay and we don't need this constant along anymore save now back in postman one more time I'm gonna send this empty object now look at the response so this is what we get an object with these properties is joy name details which is an array of error messages so here's the first message name is required now this object is too complex to send to the client perhaps you want to simplify this so back in the code one simple solution is to go to the details array get the first element and then access the message property or instead of using the first element you may want to access all elements in this array get their message property and concatenate them that's entirely up to you so save one more time let's send an invalid request and now we get name is required if we go to our request and add the name property but set it to a string that is only 1 character now we get a different error name length must be at least 3 characters long so you can see joy makes it really easy to validate the input and return proper error messages to the client all right now let's see how we can update a course so let's add a new route handler app we use the put method for updating resources now the path should be slash API slash courses and here we need a route parameter because we're dealing with your specific course so ID now our route handler function request son response goes to a code block alright now here's the logic we need to implement first we need to look up this course with this given ID so look up the course if the course doesn't exist if not existing we need to return 404 that means resource not found otherwise we need to validate the course make sure it's in good shape if invalid we need to return a 400 error which means that request and if you get here that means everything is good so you update the course and return the updated course to the client this is the logic we need to implement so we already have some code that we can reuse here so I'm not going to type everything by hand I'm gonna copy some code from our other route handlers so first we want to look up the course and if it doesn't exist you want to return a 404 error for that I'm gonna go to this other rat handler where we get a single course this is the logic we're interested in so we look up the course and if it doesn't exist we return a 404 error so copy these two lines we're done with the first part the second part is all about validation for that I'm gonna go to our post endpoint so here we need to copy the schema as well as this line for validating the request body using joy and there is a problem with this approach the problem is in this case we have a very simple schema what if you are dealing with a complex object with quite a few properties then or validation logic would be duplicated in two different round handlers so let's just copy the code for now and then we'll come back and refactor it to make it better so copy these few lines and paste it here so we're validating and if it's invalid we need to return a 400 error so I forgot to copy that line here if you have an error in the result we're gonna return it's 400 error okay so let's copy that as well so this is our second part we have this schema we validate and if you have an error we return a 400 error we're done with the second part now the third part so at this point we have a course object we can update its properties so of course that name we said that to request the body the name and of course if we have other properties we'll set them here as well so we're done with opting in the course and finally we need to return the updated course to the client so response that's and course this is how we handle an HTTP put request now I told you that we have duplicated this validation logic so I'm going to extract these few lines into a separate function that we can reuse both in this route handler for handling our HTTP put requests as well as the other one we wrote in the last lecture for creating a course so let's define a function here and call it validate course we give it a course object now in this function we should have the schema as well as this line for validating the course so cut these few lines place it here now instead of validating requested body you're gonna validate the argument that is passed to this method so that would be the course object now finally we can simply return this result to the caller there is no need to define a constant so with this new implementation we have all the validation logic in one place now we can reuse this so here is our put method we define a constant call result and study to validate course and as an argument we pass request dot body now we can make this code a little bit cleaner and shorter by using object destructuring feature and modern JavaScript so look here we get this result object and we're accessing result that error property in two different places since all we are interested in is this error property we can get this using object destructuring so let me duplicate this line and show you how object restructuring works with object is structuring when declaring a variable or a constant we add curly braces and then here we add the property of the target object so in this case the target object that is returned from our validate course method has two properties error and value in this case we just want the error property so we put that between curly braces so this is equivalent to getting result that error one instead of using this notation we use this notation okay and with this we don't have to repeat result that error in two different places we can simply use error okay so this is object destructuring now we don't need this first line anymore and finally before we finish this lecture we need to make one more change in this code so we need to use this new way of validating a course in the route handler for handling our HTTP POST requests so copy this is our handler for creating a new course now we don't need to use this schema here we moved all that logic to our validate course function so all these few lines here for validating the request body and sending the 400 error I'm going to delete this and paste the code that we copied from the other method so we call validate course use object D structure and syntax and if you have an error you return the 400 response to the client now finally let's test our new endpoint for updating a course so back in postman we need to change the type of this HTTP request to put change the URL and add a valid course ID like one here we have a pilot course object with name set to new course so send and we get a 200 response which is successful and here is the updated course so if you open any new tab and send an HTTP GET request to localhost / api / courses now you should see the list of our courses so our first course it's name is up data perfect now let's test the other scenarios what if you send an invalid ID so 10 send the course with the given ID was not found and you can see the response is 404 which means not found and finally what if you send a valid course ID but an invalid course object so I'm gonna remove the name property send now you can see we have a bad request for 400 error and here's error message name is required next I'm gonna show you how to handle HTTP delete requests so out of all the crud operations you have implemented create read and update so in this lecture I'm gonna show you how to respond to HTTP delete requests it's very simple and similar to what we have done so far so here's our app object we call the delete method give it a pass that is slash API slash courses and of course we need a parameter because we're working with a specific course then a raft Handler request our response goes to the code block now here first we need to look up the course the course would be given ID if it doesn't exist then we need to return 404 otherwise we're going to delete it and by convention return the same course the course that was deleted so again I'm gonna borrow some code from our other grant handlers to look up the course and return a 404 error I'm gonna go back for ramp handler for the HTTP put request so these first two lines is for looking up the course and returning a 404 error so copy these two lines back here that is our first part done now to delete a course first we need to find the index of this course in our courses array so courses dot index of course we get the index store it in a constant and then we can use this splice method to remove an object from our courses array so courses dot splice we go to this index and remove one object so this is the delete part and finally we need to return the response to the client so response let's send this course object now let's test this so back in postman let's change put to delete first I want to send an invalid course ID like ten send so we get a 404 error not found with this message perfect now let's delete the first course course with the ID one send so we get the same course object in the response and if we go to our second tab where we have the list of our courses so look we have an HTTP GET request to the send point let's send this one more time okay now look we don't have our first course anymore we only have courses with ID two and three all right before we go any further I realize we have a bug or actually three bugs in this code so look at the handler or responding to put requests to this endpoint if we don't have a course with the given ID we return the 404 error to the client but at this point we should exit this route handler otherwise the rest of this code will be executed so the proper way to implement this round handler is like this so if you don't have this course we return the response and then exit the function or a shorter way to write the same code is to put the return here and then we don't need the code block so we can put everything in one line okay now to make this code cleaner let's use the same technique in case we have an invalid request so we simply return and then we don't need the code lock anymore that's much more elegant you have the same issue in the handler for delete requests so if you don't have a course here we should return immediately the same is true when getting a single course so if we don't have a course with the given ID we return the 404 error and also return from this function immediately now finally let's have a look at the handler for HTTP POST requests here it is again I'm gonna use the same technique to clean up this code so if you have an error we simply return and get rid of the extra noise in the code that's much better all right now it's time for an exercise so from this lecturer we're gonna start building the backend services for our VIP little acacia as I told you before Whitley is an imaginary service for renting out movies so throughout this course we're going to build the backend of Whitley bit by bit your first task is to create a service from managing the list of genres so each movie as a genre like action horror whatever we should have an endpoint for getting the list of all genres because somewhere in our client applications perhaps we have a dropdown list for the user to select a genre so we need an endpoint to get all the genres we should also be able to create a new genre as well as update or delete an existing one so before going any further I want you to put what you have learned so far in practice so even if you're an experienced developer don't say no mosh I know how to do this this is so easy I know it's easy but what matters now is that I want you to get used to this theme tax so go ahead start a new project from scratch call it bitly and build this HTTP service for managing the list of genres you can see my solution attached to this lecture
