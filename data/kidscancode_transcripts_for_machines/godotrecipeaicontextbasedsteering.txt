so a question i started getting asked a lot when i started talking about how to do a 3d car was how do you make an ai car that drives around the track and this car you're looking at right now i'm not touching it it's driving on its own and it's not very smart this was actually something i made to try and make the the dumbest possible car that could make it around a track and to do that i used an algorithm called contextbased steering and that's what we're going to look at today how to do this and this works perfectly well in 2d and in 3d and it also works for all sorts of things besides just cars going around race tracks alright so let's look at how this works for this demo we're going to use a generic agent object which is a kinematic body 2d with a sprite and a coaching shape and i'm keeping it generic so you can see how this algorithm works and that it doesn't really matter what type of object you're attaching it to it can work for a car driving around a track it could work for a guard patrolling a dungeon number of different kinds of game objects could use this process and at the base of the algorithm what we have is a number of rays and the agent is going to choose a direction it wants to go in maybe towards a target maybe towards a player maybe towards a goal and then it's also going to have some of these directions represent danger maybe obstacles that needs to avoid other things that it wants to flee away from whatever and that's how it develops its context of its environment and how it's going to decide how to steer so in the agent we're going to have two arrays one called interest and one called danger that are going to represent the magnitude of those vectors in each direction and so if the interest is high in a particular direction it wants to go that way if the danger is high in a particular direction it does not want to go that way and combining these two together will be how we determine the final direction to go in now of course if the interest equally points in all directions it's kind of boring it can't figure out where to go it wants to go everywhere so we're going to want to have some sort of way of deciding which way that the object wants to go so for example we might have this situation where the agent mostly wants to go forward so the longest vector is pointing directly forward but it's also okay with going a bit to the left or a bit to the right but generally it wants to go forward so in that situation the interest array would look like this the first index is the forward direction and we go around clockwise but what if an obstacle appears so now we have this upward pointing ray is detecting an obstacle and so we don't want to go that way so in that case our interest array would stay the same but our danger array now has some information in it and our arrays now look like this so now we know what our interest is the direction we want to go and we know what the danger is the directions we shouldn't go and to combine these two we just go through the danger array and anywhere we have danger we eliminate the interest in the matching box and our resulting direction would be the sum of these two which is going to make the agent turn to the right and move to go around the obstacle so to summarize we have four steps first we find interest which is the directions the object wants to go second we find those directions that have any danger those are directions we don't want to go step three is we eliminate any interest directions where there was danger and finally in step four we sum up the remaining interest directions and that tells us what the final direction to move in should be so let's look at the code for our agent to begin with we have our variables these export variables are going to be the ones where you can configure the behavior how fast we go how fast we turn this is going to be the kind of determine the turning radius look ahead is how far ahead are those rays going to project how far away can we see an obstacle before we reach it and then i've also got a variable here for the number of rays now the example we used before was using eight rays but of course you can use any number and there are reasons you might want to use more there are reasons you might want not to use too many and we'll talk about what some of those are towards the end of this tutorial but eight is good enough for us to start with and see how it works and then for our context array we're going to have our directions that the rays point in and this is an array i've had curly brackets there for some reason for something before and then we have our interest array and our danger array like we saw in the example and then finally we have the chosen direction that's going to be our result at the end once we've added up the interest removed the danger and found the resulting direction and then velocity and acceleration are going to be our movement properties so if we scroll down to our ready we're going to take our three arrays and resize them to the given size and then we're going to populate the ray directions one with the actual vectors pointing in all those directions starting with vector2.right which points to the right which is forward for our character and just going around the circle dividing by however many rays there are okay now in physics process what we're going to do is we're going to populate the context arrays we're going to have functions that do each of those things find our interest array find our danger array and use those to choose the direction so we'll get to those in a minute and then we have our standard movement code which just takes the desired velocity the place we want to go and we interpolate it with the current velocity using our steer force so that we will gradually turn towards the direction we want to go and we're using movement collide to move now the first of the arrays we want to set is interest and there's a lot of different ways you could do this depending on what your game's setup is so for this demo we're assuming that the this agent lives in a world that has a path drawn on it it has something that the agent's going to need to follow like a racetrack right it's going to want to follow and it's going to go around the track in the proper direction right we don't want our ai agents driving backwards around the around the track so so we're going to assume that our owner if we have an owner the owner has a method called get path direction it's going to tell us what direction we want to go in and this way we can stick our agent in any kind of world and let the world tell it what the preferred direction is this will be the part that you'll do differently depending on your game's setup so we ask our owner what's the direction to go in if you're in the position i'm in all right and it's going to tell us based on the the racetrack which direction we should be going in then we take each of the ray directions each of our arrays and we do a dot product with that path direction and that dot product is going to get give us a result between 0 and 1. how big we want well actually between negative one and one but the negative values will be the ones that pointing in the opposite direction that we wanna go so we're gonna zero those out and we're just gonna take either zero or the value we get and then i also have this here just in case which is for just for some of the demos that i did to set the default interest let me put this back to zero here which was to just go forward like in the diagram okay if you don't need this obviously you would leave this part out of your code right and we'll do an example here in a minute so you can see what that looks like okay but the next function here is the set danger function and this is where we're going to take each of our rays in our ray directions array and we're going to cast a ray in that direction to see if we hit something right we use the look ahead distance for how far we project forward and then we're going to set the danger to 1 if we hit something or 0 if we don't so there's something there or there isn't something there and then finally we can choose directions and we just loop through num rays and if there's something in danger we set the interest to zero there and we get our chosen direction by just summing up all of the directions where there's interest and then normalizing it and now we have a direction that we want to move in so here's our example again and i've increased the number of rays to 16 just so we can see a little more information here and so if you imagine that to the left is the direction that our world told us that the racetrack is going that's the direction we want to go so we took our forward direction and we did the dot product with each of the rays and so you can see that they're getting shorter as we go perpendicular arrays dot product is zero so we got zero and any of the rays that were pointing backwards the dot product would have been negative so we zeroed those out so this these green arrows represent the total direction that we want to go and since there's no danger none of them are getting eliminated summing them all up results in a vector pointing forward but if we add some obstacles here and we see the danger coming in as the danger changes you can see our resulting direction is going to be changed as well if we really want to block it let's see we're going to turn hard to the right now because there is a lot of danger on the left hand side so let's see it in action we've got a path 2d that i've drawn here to be a track that we're going to follow and then i've put some static bodies around to give it some obstacles to keep it on the path right so we can't we can't turn in this way we can't turn out that way and i've put a whole bunch of agents in here and all i did to change them was i randomized their speed a little bit so that some of them will be faster and some of them will be slower if we look at the code real quick this get path direction is what all the agents are going to call to say hey what direction do i need to be going so we're going to find the closest offset along the curve to the position that was given so the closest point on the curve to where the agent is we're going to take our pathfollow 2d node which is a child of the path 2d we're going to set this offset to that position so now we have that node has moved to that position and we just take its transform.x which is its forward direction and that's what we return so if you're a path follow on the path that's what forward is at that point in the path and that's the direction we want the agents to move in as well so let's look what it looks like when we run this okay so see you can see them trying to follow the track here's a really fast one right as soon as he finds a way around he's going to skip past some of these guys there we go and so you can see with some simple code we've got some pretty good path following behavior and if i turn on debug here you can see you can see how those interest and danger vectors are changing as they move around if they get too close to one wall they're going to want to steer away from it too far and they'll want to steer back away again and for the most part they're going to want to try and go forward along the path and that's it this is a pretty flexible and easily adaptable algorithm that you can apply to a lot of different types of objects the main things you're going to want to think about when you're configuring this are the look ahead how far ahead does an obstacle get seen and a lot of that's going to have to do with how fast you're moving but also the number of rays now the more rays you have the more the finer detail you're going to to have in detecting smaller objects for example but obviously the more performance hit there's going to be because you have more and more rays you're having to cast every frame to detect movement in practice i have found that eight is maybe a little too low for some cases although it works perfectly fine in others and 16 is probably good enough for most uses you can go higher and have you know 32 or 64 and obviously it doesn't even have to be a power of two but the more that there are the more um the more you're going to have to figuring out those tradeoffs of is it going to be worth it am i getting it any better behavior and you can try it you increase it to 32 and you see that they drive around just the same then maybe 32 wasn't necessary now as always if you take a look at the written version of rongorecipes.com you can see some more detail of how the implementation works and some suggestions down here at the bottom for some other improvements or additions you could make that might give you some different behavior based on what your needs are and i'd love to hear your feedback on there as well okay hopefully you found this algorithm interesting and useful and can apply it to your own games not just racing games like this one but any other kind of ai that you need some kind of steering behavior on let me know in the comments below if you tried it out and got it working in your game i'd love to see what you got it to do as well thanks for watching and i'll see you in the next video you can find this recipe and lots more on the godot recipes website at godot recipes dot com here you can find a wide variety of recipes for creating the game system you need some help on how to get started with godot in the basics section and lots more i recommend you go over there and explore and let me know if there's something you're looking for that you'd like me to add as i'm always adding more recipes over time thanks for watching and i'll see you in a future video