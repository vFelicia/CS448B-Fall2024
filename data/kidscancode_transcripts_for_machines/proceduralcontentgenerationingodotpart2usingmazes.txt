this is part two of the procedural generation tutorial series for Godot in this part we're gonna look at some ways that we can use the randomly generated mazes we created in part one for different applications in game projects so here's our script from the previous part where we made our map using the maze generation algorithm and all I've added to it is I've added a camera 2d so that when we run I can zoom the camera out and put the camera at the center of the map which allows us to make a much bigger map so if I run it you can see you know we made a much bigger map here and that's just going to be more convenient for the different variety we might be making so the first thing I want to talk about is something a lot of people ask me about in the comments and that is seeding the random number generator and if you're not familiar with that a lot of procedurally generated games like Minecraft for example use this so that users can share the same random worlds so what happens is if I generate a new world it's gonna be it's gonna be randomly created as I explore it and but if I share with you the same seed that my random number generator is using to generate that world you will get the same world as me even though we explore some you know the a humongous world we don't have to share all that data we just have to share that one number and we'll always be sure that will generate the same world and we can do that with our randomly generated content here too so what we're gonna do is we're going to add a variable called seed or I'll call it map seed to hold that seed value and I'm setting that to 0 to indicate that we don't have a seed so here on our ready what we're gonna do is after we randomize to initialize the random number generator we're gonna check to see if a seed has been set and so if no seed has been set we want to make a new one so we'll set that equal to a random integer and then what we will do is seed you know the seed function we will see the random number generator with that value and then I'm also going to print it out because I want to see what it's coming up with so we'll print that out so if we run this we'll see a random map and if we run it again you know we'll see a random different map so every time we run it we're getting a different random map but it's printing out this value here this is the seed that it used when it made the maze so if we copy and paste that value we'll get the same pattern again so if you look really closely at how the pattern is laid out you've got a couple of just pick a couple of things that you notice what they look like and we'll copy and paste this value for the map seed your extra space there and you'll see that when we run it we get the same exact pattern so every time we run this we're gonna get the same pattern and that's how the seed works and so depending on your games application you could generate this at the beginning when the player starts a new level and then save this as part of the save file so the user can see it and recall it if they want to play the same level again that kind of thing so the next thing I wanted to talk about was the maze itself so when we talked about the recursive backtrack or algorithm we talked about how it generates what's called a perfect maze that means that from any one point on the map there is one path to any other point on the map there are no loops there's no there's no two routes in between any places and there are no sections that aren't connected at all and so that's fine and we have our nice little twisty maze but it means that if for example you were generating a random city city streets don't work like this they need their need to be more intersections so one thing we can do is once we've generated the maze and we know everything is connected we can go back and randomly remove some extra walls in between some of the additional tiles so I'm going to make a variable to control that this is the fraction of walls to remove so this is just going to be a number from 0 to 1 of how much removing do you want to go through and do and I'm going to set that to 0.2 and we're going to start off doing this very simply we're just going to randomly pick tiles out of the map and if there's a wall on that tile we're gonna remove it so I'm gonna go down here to the end and I'm going to make a new function for that okay the race fault walls function is going randomly remove a number of the map walls okay so we need to we need a loop so we're gonna do this however many times which is going to be width times height times the erase fraction all right so if we have a 10 by 10 map there's a hundred of them we're gonna do 20 randomly so now we need to pick a random tile but we need to pick one that's not on the edge so I'm going to pick an number between 1 and width minus 1 do the same thing for y we're gonna do height instead and now we have a random pile so the cell that we are focused on is that x and y so now we need to pick a random neighbor of this cell that we just got so neighbor is going to be we take the keys from cell walls and remember that's the for directional vectors and we're going to just pick a random one so we pick a random directional neighbor if there's a wall between them remove it so we picked a random cell we picked a neighbor there may or may not be a wall between them so if there is so if map get cell V so we get that cell and then we compare it with cell walls a neighbor okay so if we have a 15 for example all four walls and the neighbor was the one to the north then we're comparing it with north and we're gonna get right we're gonna compare it with north and we're gonna get a true or false here if the wall is there so if it is we're gonna remove both so so the cells walls let's do so the new wall to SMAP gets lv cell cell walls neighbor alright so since we have a north wall we need to subtract it but we also need to remove the south wall from the other one so n walls for the neighbor is mapkit so the cell plus n oops L plus neighbor cell walls negative neighbor alright we want the opposite so if we have a cell with a neighbor to the north we're gonna subtract the north wall and on the neighbor we're gonna subtract the opposite which is the south wall so now we can just update now we can just update the map map set Selvi and map sale plus neighbor okay and so that will update both of them and now just so we can see it happening I'm going to stick the yield here so that we will pause or update the screen in between each frame and then we're gonna go up to our ready and just call the erase walls and we should now see it start removing some tiles there we go so you see how we're getting some loops here now some places where there's a little roundabout some places where there will be ways to get around from one place to another and depending on what you set that erase fraction to you can get a pretty densely connected map or very sparsely connected map for example here's the result if you set the erase fraction to 0.8 it's really high you get a lot of grids and chunks of tiles that are all connected together which might make sense if you wanted a very densely populated city or something like that speaking of cities since we're using roads here it kind of makes sense that you might want to turn this into some sort of city or or other driving kind of game and in that case you want to put some items some decorations some buildings things like that in the green spaces but because of the way our maze generator works every single tile is being explored so every tile has a road in it so that only leaves us a very tiny amount of space in between the adjacent roads to place any buildings or other objects and so what we want to do is space these roads out and create more space in between adjacent roads to do that we can go in and redefine our neighbors so instead of the neighbors being the one cell to the north south east and west we're going to change this to a two and so we're gonna say assails neighbors are the ones two spaces away in any direction and so that means it's going to consider those but in our making maze here we have to change this because we're now appending all cells to unvisited and there's no way to visit those inbetween cells so we actually need to take this line out so we set the whole map to 15s into solid green and then we're also going to do a loop where we go from 0 to width by twos and Y from 0 to height by twos and we're going to append those just those to the unvisited and now if we run this what's going to happen is we're now our maze algorithm is running just fine and it's calculating every cells adjacent neighbors by skipping over and of course since it's skipping over there are gaps in all of the roads so what we need to do is whenever we skip over a tile whenever we cut a wall in between say this one and this one we need to place a connection there and if you remember from our list of tiles here that means we either want to use number 5 we want to make it we want to make that in between cell a5 if it's connecting east to west or we need to make it a 10 if it's connecting north and south so it's we either moved horizontally or we moved vertically so now down here where we remove the walls from both cells we have a direction vector here that's keeping track of it'll tell us whether we went horizontally where we went vertically so after we set these walls we can add another insert intermediate cell so we want to stick that one in between so if Durex is not equal to zero that means we did a horizontal so we need number five so we need to set cell the current plus der over two so we want to do half way right there's der is two spaces so we want to do a one space over and we want to set it to five I'm just missing an L there and then otherwise we must have gone vertically so so we want to set current plus three over two to ten and that should now insert the one in between everywhere we go and made another typo there but there we go so now our maze is generating just like it did before but we have more space in between our roads so we have room in here to put buildings and trees and whatever other kind of things we want to put in between those spaces and you could totally go and just and generalize this and make the spacing arbitrary three spaces four spaces whatever I just wanted to do two as an example to show you the concept now if you also want to remove walls which I had disabled in the previous example then you're going to need to change or erase walls because we're also going to be skipping over so you'll have to change things like for example when you pick your random cell you need to pick a you need to pick an evennumbered one so instead of picking and we still don't want the walls so we're going to start with two and the easiest way to get evennumbered one is just to go between 32 minus 2 and then multiply by two and then that way you get something in between left in the middle and then you multiply by two so you get some where all the way across and I've always been an even number because you multiply by two and then we can use that same if statement here to insert the intermediate cell except that the naming is this is neighbor and this is a cell plus neighbor right here and again this is another thing that you could generalize so that your spacing can be arbitrary so there we go so now we drew our spaced out cells and then we connected a bunch of them so now you can make little city blocks here that kind of thing and then one other thing I wanted to show you is if we take our maze scene we're using you know our square tile map but the cool thing about doing our tile map this way is that the the arrangement of cells the the actual maze that we generate and the connections is independent of what the map actually looks like what the visibility of it is and so for example if you wanted to use isometric tiles you could use isometric tiles as well and they look like this so we have the same connections that we had with our topdown cells but rendered in an isometric or in an isometric style and all we would have to do is change our tile map and tile set and we won't have to change any of the code and I'll show you how that works so we're gonna take I'm gonna take the maze and I'm gonna save this scene as and call it maize isometric and so now I still have the same script attached to it let's rename this too and so we have the same tile map the same script but now I'm going to take the tile map and I'm going to change this to isometric and then I'm going to change the now when we do that we have to change the cell size and the cell size that we want for these isometric tiles we're using is 100 by 50 and then we needed to change the tile set and so if you load you can see there's an iso rhodes tile set so we wrote load that instead now we've got isometric tiles right and we can lay those out like that and now when we run it our maze is going to work exactly the same except it renders it with isometric tiles okay so I hope you enjoyed that it went a little bit longer than I had planned I so I do have at least one more video I want to do talking about the maze specifically doing the decorations filling in those blank spaces in between the roads with other features and also doing a very simple game where you walk around on the maze and explore it so that'll be that'll have to happen in the next video so as always please comment with your questions and suggestions below and I'll see you in the next video