welcome back this is part two of the dungeon generation tutorial if you haven't watched part 1 I highly recommend you go back and watch that one first because we're gonna be starting where we left off in part 1 where we've already created the rooms and we're gonna be starting to talk about how to create the path through the dungeon alright let's get started so in the previous video we made our room generator that spawned the rooms and distributed them around using the physics engine but now we need to connect these rooms together so that we have a path between them now to do this we're going to use something called a minimum spanning tree and that might sound complicated but what it really means is that given a graph which is a collection of points it finds the minimum number of connections to visit all of them so for example if you have a few points then in a line like this then the straight line is going to be the shortest path that connects all of them so this is a minimum spanning tree of this graph of 4 nodes but as soon as I add some other connections you'll start to see that the path gets a little more convoluted right and so by minimum spanning tree what we mean is a spanning tree means it visits every single node so everyone is connected there's no nodes that aren't connected and minimum means that the path lengths are kept to the minimum possible value and so if each one of these points in the graph were to represent one of our rooms then a minimum spanning tree is going to give us a path that goes through and visits every single room the algorithm we're going to be using which you saw in that demo is called prims algorithm and you can look this up on Wikipedia I'll include the link below if you want more of the details of where this comes from it also has this nice animation of a demo of the algorithm as it runs as it goes through the nodes and finds from whatever starting point each for each node it finds the next nearest node and just it's connecting them up and you can see how it grows and finds its path through the whole graph to store our data we can use Godot is built in a star node which is designed to hold a graph with connections so it's perfect for our use case here all right so it's good going so starting with the code that we did in the previous version which generates the room we're gonna add a variable called path that's gonna hold our this is gonna hold our minimum spanning trees this is this is gonna be an a star that funding object and now in our coloring section here where we go through and we after we've spread out all the rooms and put them in their places we go through and delete some of them to make it a little more sparse what we want to do is we want to collect a list of all of the room positions that we can pass to our minimum spanning tree algorithm so we're gonna make a variable here called room positions it's just gonna be an array to hold all of the room coordinates and if we call the room we don't want to put it in the list but if we do call the room then we're gonna append the room position to that array now here's one little gotcha the astar node that we use stores the positions of the nodes as vectors and that's fine except it uses vector threes because it's designed to be used in both 2d and 3d it uses vector threes for all of its positions that means we can't just insert the rooms position because that's going to be in our case a vector two so we have to convert our vector two into a vector three and we're just going to leave all of the Z coordinates as 0 so we're going to insert a vector 3 of our room position X the next line here our room position dot Y comma 0 and so that's our 3d representation of our 2d vector now we have we want to give this I'm gonna put a little delay in here and what we're gonna do here is we're just gonna have it pause briefly to finish this room calculation changing all the rooms to static before we calculate the MST or the positions might not be quite correct but now we're ready to generate a minimum spanning tree connecting the rooms and we'll do that by and we'll store it in our path variable we'll call a function find MST using those room positions all right so now it's time for the magic so we're gonna define that find MST function and that's going to be given a list of nodes like that's gonna be the array that we're passing in is a list of nodes and this is going to implement prims algorithm and I'll add some more comments in here for the version that I upload but I'm just gonna talk through it now as we're typing it so we're gonna be returning an a star path so we need to create a new a star object and we need to add the first point to it and the way we add a point to and to an a star is each point gets a unique point ID and a vector3 and so to get the available point IDs we know 0 is available but you can also use get available point ID and it will guarantee to return you one that works because it doesn't matter what IDs they're assigned they just have to be unique and then what we want to add to it here let's do this let's do in here let's do this let's zoom in here so that we can see more of the code and we want to insert the first we're just going to insert the first node from the array so pop front we'll take off the first node so now our path has one node in it and we're going to repeat this algorithm until no more nodes remain so just want to keep going through our list of nodes until we've looked at them all so we do that with saying while nodes write and array returns false if it's empty so we're gonna need a couple of variables here to track because we're trying to find for each node we look at we're trying to find the closest one so the minimum distance is the closest one we found so far and that's going to start out at infinity this is the minimum distance so far and this one then we're going to also store the position this is the position of that node and P is going to be our current position that we are looking at so now we need to loop through all the points in the path okay so we're gonna go through a path remember our path at the beginning only has one node in it so that's the one we're gonna start with but eventually we'll be adding more and more of them and I'm gonna convert this variable so get points is going to get the ID so we want to say get point position of that and I'm just gonna reuse the variable since I don't want to create another one for this then we need to loop through the remaining nodes in there in the array so we'll call this P you go through each of those now for each for each combination of these we just have to see if it's closer than the minimum distance we've found so far so if p1 distance to p2 is less than the minimum distance we've snapped found so far then that becomes the minimum distance we've found so far and then min P is going to be that position and our current node becomes that one that we're looking at now when this loop finishes when this outer loop finishes we've gone through for the for each path and for each node in the path and found its next closest neighbor so we can insert that into we can insert that into the path so let's get the next available point ID so that we can insert it and add it to the path the path that add point takes two arguments and and min P and then we need to make that connection the path dot connect points get closest point to P and n so now we have the connection and we need to remove that node from the array because we've now added it's a nodes dot erase that min okay and that's it when this while loop ends we will have visited every single node they'll all be connected so we can return the path and that is prims algorithm alright man we have a path our last step is going to be to draw it so that we can see it on the screen so in our draw some section here we're just going to say if there's a path then we want to go through each position in the path we want to get each connection for that position we want to connect the two positions so let's dump those in some temporary variables and we get the two positions and we'll do draw line draw a line we need vector twos remember we're getting back vector three positions so it's the vector two of just the x and y cp x + CP dot y and then i'll go to the next line here color will do that yellow and then we'll set a width and we'll use antialiasing because that will look cleaner and so now we should have if we run it our path get drawn okay so we just need to erase it when we reset right so over here and to do to input when we make the rooms our sorry when we press space and we delete all of the rooms we should also set path to null there we go all right so now we have our minimum spanning tree working its connect finding a connection for all the rooms now a couple things you might notice if we get here let's get a nice twisty one yeah so the path likes say this was the starting room and this was the ending room right you have a path with some branches but it means if you were to go down this branch you know and explore you're gonna have to do a lot of backtracking to get back to the kind of main central path and we'll talk about that maybe in a in a future video for now the next step that we want to do is convert this now into a tile map so that each of these rooms will be an open area with walls and there will be these lines will turn into corridors connecting the various rooms together so that we can walk around on them and that will be what we do in the next step thanks for watching you