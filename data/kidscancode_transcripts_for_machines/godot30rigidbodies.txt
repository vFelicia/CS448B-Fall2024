hello if you're new to judo and you think you might want to use rigid bodies in your games this video is for you recently I've been seeing a lot of confusion among new users who are confused about how physics works in Godot this video will show you how rigid bodies work some of their most commonly used properties and how to properly work with them in code while the examples in this video are in 2d the same lessons apply to using rigid bodies in 3d as well Godot has three physics body types rigid static and kinematic and rigid body is the one that provides simulated physics and what this means is that you don't control a rigidbody 2d directly instead you apply forces to it things like gravity impulses things like that and Godot is built in physics engine will calculate the resulting movement and figure out collisions bouncing whether if something starts spinning that kind of thing so we jump into Godot when you add a rigidbody 2d you'll see a lot of properties show up over here in the inspector and this is where you can set things like the mass of the body the friction the bounciness if you want it to respond to gravity or not a lot of properties can be set directly right here in the inspector now the body is also affected by in the project settings there is a physics 2d section where you can have your global gravity and friction settings and all rigid bodies will be affected by those unless you set them to ignore them now one of the benefits of using a rigidbody is that a lot of behavior can be gotten for free without having to write any code for example let's look at making a rudimentary Angry Birds style game where you have falling blocks and you throw a projectile to try and knock them down you only need to create rigidbody 2d s for the blocks and the projectile and set their properties the stacking the following the bouncing all that stuff will automatically be handled by the physics engine so for the blocks we're going to use I've created a new scene here and the block is a rigid badi 2d and it has two children as sprite so we can give it a texture and a collision shape 2d and of course all collision objects have to have a collision shape or they won't be able to collide with anything and the for the textures that I'm using I'm using an art pack from Kenney that is for physics and has lots of different textures and types of blocks and I'll link to that below if you want to grab that too but you can use any other textures that you want to use for this and then I've added a rectangular collision shape on top of it to outline it and if you haven't watched one of my videos before I'm gonna reiterate never ever ever do this with your collision shape things will not act properly if you scale a collision shape you need to always whatever clusion shape you're using is going to have size handles on them and you're going to use those to change the extents or the radius or whatever property of the collision shape to make it the size you want if you wanted your block to be bigger you're not gonna scale the rigidbody if you scale a rigidbody the physics engine will automatically scale it back to one to one size when you hit run and all that will go away if you want a bigger object you scale the sprite make the sprite bigger and then scale the collision and you know size the collision shape to match that so now if you drag this block to somewhere around the middle of your screen and run the scene you will see the block fall downwards now yours might be falling a little bit slower than mine and that's because I've gone over here and set the gravity scale to three this multiplies gravity by three for the block so it falls a little bit faster than the default which you should have set to one so now I've made a new scene and I've created a bunch of static body 2ds he was gonna be my walls and Laure and these are just static body 2ds with a sprite in collision shape just like we've done before and i just grouped these in a group called walls so that I could hide them all like that and then I instanced a bunch of the blocks that we just made five of them to be precise and I've stacked them up so when you hit run you will see that stack of blocks just sort of sitting there and now we need our projectile the projectile is one more rigidbody2d with this bright and a collision shape at this time I've used a round texture so that it'll look like a ball and we're going to throw that at the blocks to knock them over for a rigid body to move it needs to have some sort of velocity and you can give a body an initial velocity right here in the inspector under linear there's velocity so we're going to set that to 500 comma zero so it's going to be moving to the right and now if you hit play you will see the ball flies to the right and when it hits the box they come tumbling down you can also play around with the balls friction and bounce properties I like a bounce of around 0.5 makes the ball not just come to a complete stop when it hits the wall but bounce off a little bit and friction will determine how slippery it is on contact with other objects now for the next part let's set the velocity back to zero zero and let's say we want to be able to toss the ball at the blocks in code you should never set a rigid bodies velocity or position manually these objects are simulating realworld physics and in the real world objects can't instantly jump from place to place or go from a standstill to a high speed in zero time and if you try and do so in code the physics engine is going to resist you and you can get unexpected results so instead we have to apply forces which can create an acceleration in a certain direction aka Newton's second law to add a force to a rigid body you've got two functions to choose from add force apply impulse add force is like adding a continuous force to the body if you think about a rocket when it's when the rocket is firing it's steadily pushing it faster and faster that's an added force and also note that this adds to any existing forces that are on it so the force will continue to be applied until it's removed apply impulse is more like an instantaneous kick sort of like hitting a baseball with a baseball bat so we're gonna use apply impulse to kick the ball when we click the mouse drag it in a certain direction and release it's gonna kick it in the direction that we dragged away from to capture the mouse click I've gone into the project settings under input map and added a new action called click and then I click the plus here and added the left mouse button so this click event will fire whenever I use the left mouse button then we're gonna add a script to the sprite or to the ball here's that script so we have two variables one dragging is going to keep track of whether we are currently in the drag state or not whether we're holding the mouse down and and dragging or we've let go and drag start is going to be used to store the mouse position when we click so we know where we started and then we have the input function here checking for the press or release action on click and if we click it we're going to set drag in to true and capture the mouse position and when we let go we're going to set dragging to false and capture the end point the location where I let go and then by subtracting and from start we get the vector pointing from end to start so we're going to push back in the direction like we pulled back and let go and then we're gonna apply an impulse and apply impulse takes two parameters the first one is an offset how far off from the center of the body do you want this impulse applied and so we're going to have that be zero and then we're going to use our direction vector as the force that we're going to with and I'm multiplying by five here just to scale it up a bit it's just an arbitrary number I decided to use for this demonstration now when we play the scene there's our ball now if I click and I drag when I let go the ball will go flying and if I click and drag a longer distance it's gonna fly faster and so on now if you try adding an offset to the impulse say we set this to 40 comma zero you're gonna give a big spin to the ball when you launch it which is gonna make it you see how it kind of kicks away the blocks when it hits them and so you can just play around with a very small amount of code we've got a lot of functionality happening what about when you want a little bit more control direct control over rigidbody2d well for this other scene that I've created we're gonna talk about making the classic asteroids style game so I have a ship here and it needs to rotate when I press the left and right arrow keys and needs to move forward when I press the up arrow so I've made my rigidbody ship and the sprite and the collision shape one thing to note if you're using my art the image comes pointing upwards and in Godot three zero degrees means pointing along the x axis to the right so if we want the rotation of the ship to match the rotation of the body you need to go into the sprite and add a 90 degree rotation to it so let's talk about control so by default the physics settings have some damping in them in the project settings which will reduce a body's velocity and it's spin in space there's no friction so you know realistic space game you wouldn't want any damping at all but for asteroids we want the ship to stop rotating pretty quickly when we let go of the side arrow keys and we so want it to slow down a little bit when we let go of the thrust so what I've done here is I've gone in and changed the linear damp to 0.5 which is a little bit bigger than the default which is 0.1 and I've set the angular damp to 5 which is much higher than the default and it's going to make the rotation stop pretty quickly when we let go of the arrow key here's the script for our ship feel free to pause this if you want to take a look at it for a minute before I scroll down we have two important setting variables here the engine thrust which is going to be the power of the engine when you press the up arrow and then the spin thrust which is how quickly it you know how fast it rotates when we press the side arrow keys thrust is going to be the actual engine thrust it's going to be 0 when it's not on and it's going to be you know this this a vector with this magnitude when it is on the rotation direction is going to be tracking whether we're rotating to the left or the right and then we're going to capture in the ready the screen size we're not going to use that yet but that's something we're going to use a little bit later so I went ahead and put it in here then I have a function here to get the input we check for the up arrow and if it is pressed we're going to set the thrust and otherwise we'll set the thrust to 0 and then we capture the right and left and add or subtract from directions so that we get a 1 a 0 or a negative 1 for direction of rotation and we call that input function input function every frame in our process function and then here I have the physics process and we're going to set the applied force to the rigidbody to that thrust rotated by whatever direction our ship is rotated in and then we're going to set the applied torque applied torque applies a rotational velocity or sorry a rotational acceleration to the body and so we take our rotation direction and multiplied by this been thrust now when you go over to the inspector you want to set those values I have engine thrust set to 500 and I have spin thrust set to 25,000 in Godot units torque winds up having some pretty large numbers but go ahead and set those and you can see how it will work if we hit run now I can rotate left and right and I can press forward and I get some good asteroids style flying around the screen now here's where people start getting into trouble if you remember the classic asteroids game the way that these ship flies is when it goes off the edge of the screen it comes in on the other side giving us a wraparound effect on the screen it also has a hyperspace function where when you press the hyperspace button the ship teleports to another location and those are basically the same thing when you go off one side you're teleporting to the other side and we talked about how about you know a little earlier how you can't change a rigid bodies position directly without breaking the physics engine and so this is where people run into a lot of trouble when they're trying to do customized things with rigid bodies a really common mistake I see people make is trying to do something like this so we've added some ifs to the physics process saying that if we you know reach if we pass one screen edge we teleport over to the opposite screen edge and update the nodes position remember the position is a node 2d property has nothing to do with physics and so what's gonna happen when we run this is everything looks fine right now until we hit the edge and then we become stuck I'm holding the I'm holding the thrust button down and we are not moving and depending on how we do this we might suddenly teleport off but what happens is the physics engine is trying to move the body continuously but our script is trying to teleport it and those two are fighting each other and it's just not coming out good at all so don't ever do this now I think part of the problem here comes from people assuming that physics process means this is where you do physics stuff but what physics process means is that this Delta and this function is called in sync with the physics engine with the physics frames but that doesn't mean that it's safe to do things like change the physics body's position inside it and if you look at the docs for rigid body the answers are all there if you scroll down to the description you will see right here this note if you need to directly affect the body state use integrate forces which allows you to directly access the physics state so integrate forces and if we go look at the description of that allows you to read and very important here safely modify the simulation state of the object use this instead of physics process if you need to directly change the body's position or other physics properties so that's what we need to do we need to use this integrate forces callback instead and the integrate forces callback has one parameter it passes U which is the physics 2d direct body state which is an object that contains a whole bunch of information about the current state of the body whether it's colliding how it's moving what its gravity is experiencing is what its applied forces are everything like that and what we're really concerned with for our purposes here is its location which is contained in its transform so we have set transform here and we have get transform here and that's where we can find out what the current position rotation of our body is and set those parameters as well so here's our updated script I'm getting rid of physics process and I'm putting these applied force and applied torque statements in to integrate forces and then I'm adding the following code to do the teleporting so we get the current transform stored in this X form variable and the position of the body is encoded in the origin of the transform and so the X is what we check to teleport to the left and right and the Y is what we check to teleport to the upper and lower edges of the screen then we take that new transform that we've modified and we set it back to the state and now we should have very smooth happy teleporting that does not confuse the physics engine and doesn't conflict with any of the forces that are being applied you see I still continue to move in us in the same direction after I'm teleporting my rotation isn't affected and we're no longer getting stuck on the edges of the screen so if you're going to be working with rigidbody 2d integrate forces is your friend learn how to use it get get familiar with it experiment with it it's gonna make your life easier and one other thing I'll comment on which is that people get confused about is the rigidbody also has a property called custom integrator custom integrator let's use override the physics engine entirely and do and figure out the forces on the body yourself now if you do enable custom integrator you set this to true then you will write that code in the integrate forces function but that's not to imply that the integrate forces function only for custom integration known as the previous project we worked on I did not ever touch the custom integrator I'm perfectly happy with the built in physic engine doing what I wanted to do I'm using the integrate forces so that I can access that physics state so these two can work together but they are not integrated forces does not require you to be using a custom integrator a lot of people get confused about that and maybe I'll maybe I'll do a PR to this documentation to sort of try and make that a little clearer all right hope this was helpful to you in your projects where you're trying to use rigidbody2d please let me know in the comments below if you have any questions and thanks for watching you