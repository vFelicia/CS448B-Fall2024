welcome to a new Godot 3d game development series in this series we'll be talking about procedural content generation or PCG sometimes also called proc gen I'll be explaining and demonstrating some of the most common PCG algorithms and showing you how you can use them in your games the first PCG topic we'll be looking at is mazes for this part we'll be using the recursive backtrack or algorithm which you can see an example of running here this is also known as depthfirst search and what it does is explore the whole area and carve out a maze as it goes and it's one of the easier maze algorithms to implement so it's good one to start with and so what it's based on is a grid so we have a grid of squares restart it again here it says we have a grid of squares and the algorithm explores the grid by cell by cell connecting them as it goes but never crossing over itself in mathematical terms this is what's called a spanning tree and this means that there's no loops and there's only one path from any one point to another but every point every two points on the graph are connected so there's always a route between point a and point B and always only one route and that's the recursive backtrack or algorithm here's an overview of how the backtrack or algorithm works so we start by picking a starting cell could be anywhere on the grid and we mark it as having been visited and then if any neighbors of that cell have not been visited then we want to pick one of them randomly and remove the wall between them add the current cell the one we started with to the stack and make the chosen two random chosen neighbor the current cell and we mark that visited and then if there aren't any unvisited neighbors then we take the top cell from the stack and make it current and we just keep doing that over and over from step two until there's no more unvisited cells in the whole grid now if that doesn't make sense to you yet don't worry we will talk about what we mean by stack and what we mean by the walls between the cells but this is the steps that it takes to make the maze and this is the code we're gonna write to generate our maze in Godot now the first step whenever you're doing any kind of procedural generation is to figure out how you're gonna represent your data now since we're using Godot and we want a square grid Godot has a tile map node built into it that's perfect for this it's designed to handle a grid of squares what we have to decide is how to represent the walls between the different nodes and so here's a picture of a cell this is one cell in the grid and the cell has four walls each of those four walls can either be solid or it can be open and we're gonna we use binary representation for that then we could say the the wall if it has a one it is solid and if it has a zero it's open so that means that with any combination of four zeros and ones we could represent what state the cell is in which walls are solid and which walls are open so if we use a single bit to represent each wall state then a 4 bit number is gonna represent the entire cells state and it would look something like this now we could represent these in whatever order we like but I'm just gonna use the order west south east north so the rightmost digit is gonna represent the north wall and that's the ones place the east wall is the twos place the south wall is the first place and the west wall is the eights place and so now any 4bit number is going to represent any possible arrangement of these walls and that will be a number between 0 and 15 and every possible tile if we lay them out is going to look like this so these are all the possible combinations of tiles and that number in the center is what binary number represents that cell if you get a tile set a set of images with 16 tiles representing these 16 combinations you can use that tile set to represent your maze and so for this project I've selected Kenny's Road textures pack and if we make these into a tile set in Godot with the tile ID matching the wall pattern that you see here on the screen we can use the tile map data to record our maze data as well so whichever tile ID is in a particular cell say for example if it's number 9 then we know that the East and South walls are open so this is really nice because it means we won't need a separate data structure to store information about our walls we can just use the tile ID in our tile map so if you download the starting project you'll get a scene containing a Tom map with the tile set attached containing all of the road tiles that we just looked at okay so let's attach a script and we're gonna start by defining some properties firstly I have the four directions the north east south and west like we looked at in the picture and they're binary values for what place they represent and just naming them in ES and W is gonna make it a little easier to refer to them in code so that down below if we put the number 8 well why is the 8 there well we're talking about the west wall we'll just use a W and then this dictionary here cell walls is a mapping between those 4 values and what direction they represent what what actual physical direction on the grid is that wall on so the vector the up Vector is the north wall the down vector is the south wall and so on next I have a few more variables that I'm going to track tile size is going to be the tile size that we have set in our tile map we at right now is 64 by 64 but if you decide you want to use different size tiles that can change and then width and height is how big we want our map to be how many tiles and how many tiles tall so that's how big a maze we're gonna make and then here I'm getting a reference to the tile map just putting in the variable map because I don't want to have to type dollar sign tom map and do that lookup all the time this is just a convenient way to cache that get node lookup and then we have our ready function where we're just going to randomize so that we can get a nice random distribution we're gonna set that tile size variable based on the cell size we've set in the tile map node and then we're going to call our make maze function which is kind of the point of this exercise and before we can generate the maze we're going to need a helper function that if we give it a cell and a list of all the cells that are unvisited will return a list of which neighbors are unvisited right because that's how we in our algorithm check or choose which cell to move into next so given our current cell and all the unvisited ones this will go through and check each of the neighbors and if the neighbor is unvisited add it to a to a list and return that list so that way we know which potential cells we can choose randomly to move into and that'll take us to our make maze function so the make maze function is going to start by declaring a couple variables that were going to need we're gonna have an array called unvisited that's going to keep track of the tiles that we haven't visited yet and then we're gonna have another array to be our stack so gd script does not have a stack datatype but we can use an array because we can use the append method which texts an object on to the end of the array and then we can use the pop back method which will remove the rightmost element of the array and so that'll make it act like a stack then we're gonna clear the map and set all of its tiles to solid by looping through the width the height we're gonna add every tile to the unvisited array because to start with they are all unvisited and they're going to set every cell to every cell location north east south west which combined together is 15 and that's the solid the solid green tile then we're gonna pick our current starting cell we're gonna start in the upper left hand corner but you could start in any cell of the map and it would the maze would work just as well we're just gonna pick the top left corner and remove that from the unvisited list and then we're ready to start the actual maze generation algorithm now that we have everything set up now some of you may be wondering what this what's going on here with this weird symbol here in between the different direction letters and in GT script and in most other languages this is what's called the bitwise or what does that mean well let's take a look at the definition here so when you use a bitwise operator between two numbers it means that it operates on those numbers as if they were in binary so digit by digit in binary so for example if I have eleven or five my result is going to be 15 and the reason for that is if we look at the numbers in binary this is the number 11 this is the number of five and then we do an or operation on each digit well 1 or 1 is 1 1 or 0 is 1 and etc and so that's why we wind up with a 15 so when we have our 4 Direction values and we do in or E or s or W and we get 15 that's because remember north is 1 South is 2 or sorry East is 2 south is 4 and west is 8 so 1 or 2 or 4 or 8 results in 15 and that's why we have that so this is a very pretty common operation when you're you different what are called bit flags different positions in a binary number to represent different values and so that's what we're doing with our 4bit number here each bit is representing one of the walls and oaring them together will give us the result of having all four walls now there's also a bitwise operator called and which we're gonna use later so I'm going to explain that in a little bit so now we're ready to run our algorithm in here it is so as long as the unvisited array is not empty they're still unvisited cells we're gonna keep doing this procedure and the procedure is just like we talked about and text earlier we're gonna check the neighbors of the current cell all right this this is our function that gives us how many unvisited neighbors we have so if we have at least one unvisited neighbor we will pick a random one put the current cell on the stack then we need to remove the walls between the two so next current is going to give us a direction vector for which direction we just moved in and so using that we can get the cell at current and we can subtract whatever direction that is so for example if the current cell has a value of 15 we're going to subtract cell walls dirt well dirt is let's say we moved up if we moved up then the direction is going to be zero negative one well zero negative one means we remove the north wall so we subtract one so our 15 will become 14 and that is a cell with the north wall open for the next cell we do the opposite we just reverse the direction because we want to remove the south wall of the wall of the cell above us right if we move the north wall from the current cell we need to remove the south wall from the one we moved into then we set the map cells to match values right these are the values we calculated these values we just we set the current cell to 14 we set the next cell then we make the next cell the current cell and take it out of the unvisited array and now we have a new current and we'll do it again and we'll keep doing it again unless we have no neighbors if we have no neighbors then if there's something in the stack we're gonna pop the next one off of the stack and use that that's the backtracking part that's gonna make us go back now if we run this we're gonna see a maze but it's going to just pop up boom there's our maze right we started here and off we went and that's nice but it's also sometimes kind of nice to see everything running so at the end of the while loop here we can add a yield and if we yield let's say get tree idle frame that means we want to basically update the screen it's going to update the drawing on the screen every frame or every iteration through this while loop and so we'll see the maze sort of get generated slowly and so you see how it is backtracking I made the size a little bigger then the screen is so it's going off the screen a little bit well up to it we can correct that but you can see we're slowly going around and uncovering tiles and then backing up when we hit a dead end so I'm just going to update the size here and so now we have a maze generator now I've kept this very generic to begin with because there's a lot of different applications where you could use this in your game and the maze generation algorithm itself doesn't really change depending on what you are using it for so in the next video we'll talk about some applications of this in some ways you can use this in your game to generate say a city map to populate it with decorations and things like that you can use this for an isometric map you can use this with a 3d grid map there's a lot of different possibilities and we'll talk about that a little bit more in the next video please leave your questions and comments in the comment section below and I'll see you in the next video you