welcome back for another indepth topic on game development in this video we're going to talk about steering behaviors which is a simple way to add realistic and complex seeming movement to the computercontrolled sprites in your game for this first video we're going to be looking at the seek behavior which is how you make a sprite chase a target there are lots of other steering behaviors which we'll cover in later videos for reference if you want to learn more about steering behaviors a really great resource is this website for the book called the nature of code by daniel Schiffman especially chapter 6 chapter 6 is all about all sorts of steering behaviors and ways you can get sprites to do intelligent looking things like following lines following the leader avoiding obstacles all that kind of thing and you know for example here's some examples of line following where the sprites will try and stay on a line and and follow that okay to start out I've just made a little program here that's going to spawn a mob sprite and this fob sprite is going to have three vectors associated with it a position vector that represents where the sprite is located on the screen and it's going to pick a random X and a random y when it spawns so it's going to spawn somewhere randomly on the screen and then it's gonna have a velocity vector and that represents how much the sprite will move every frame how many pixels it will move and in what direction and I'm going to make that equal to the max speed which I set to 5 so 5 will be its maximum speed and I'm just making a vector with that pointing to the right but then I'm rotating it I'm applying the rotation to it of a random number between 0 and 360 so it'll point in a random directions be turned differently each time we spawn it and then it's going to have an acceleration vector an acceleration vector represents how much the velocity is changing each frame and that's going to be set to a zero vector so it's not going to change so it's velocity will be steady so when we spawn this sprite will spawn randomly on the screen somewhere moving in a random direction and every frame it's just going to update by we take our velocity and we add the acceleration right because the acceleration is how much the velocity changes if and I have this little this little if here just to make sure that our velocity never gets bigger than our maximum speed so we check the length of the velocity vector and if that's greater than five then we're gonna scale the length of the vector to be five and that way we won't ever go faster than five and then we take the position and we add the velocity to it and now we have our new position and then I have some ifs here just making the sprite wrap around the screen okay so when we run it we get a random sprite on the screen going in a random direction and if I hit the V key I've turned on I've had a little thing to show us show the vectors here so this green line is the sprites velocity vector and you can see it's it's supposed to be five I'm drawing it bigger just so you can see it on the screen because five pixels would be kind of short but you can see that the velocity vector is pointing in the direction it's going and this bright has no acceleration so it's velocity is never changing always stays the same now let's say we wanted to have the mob chase the mouse around the screen so I won't always want the mob to try and move towards the mouse so I can make a little method here called follow Mouse and what I'm going to do is get find out what the position of the mouse is we get the mouse's position all right and that's going to be an XY pair which we can think of as a vector representing the mouse's position and we already have a vector representing the mobs position so how do we find the vector that points from the mob to the mouse well let's look at some vector math for a second okay so let's say I'll have two vectors V 1 and V 2 and these are the values of them well adding two vectors together means you just add their X's and you add their Y's so V 1 plus V 2 is 50 plus 10 which is 60 and 30 plus 20 which is 50 now another way to look at that is if you add two vectors it's like putting the second one on the tip of the first one and you get the vector that points all the way to the end all right so that's that this vector is 60 comma 50 this blue vector and subtraction is pretty much works pretty much the same way if you take v1 minus v2 that's the same as adding v1 plus the negative of v2 just like when you use numbers adding subtracting a number is the same as adding a negative number so the negative v2 is just V 2 pointing in the opposite direction all right it's going to be negative 10 negative 20 and that's what this little vector here is so if we add those together we get this vector which is 50 minus 10 and 30 minus 20 well another way of looking at that is if v2 and v1 both represent positions for where an object is all right this is where this is where the mouse is v1 and v2 is where the mob is then this vector is pointing from v2 to v1 so if you if you take V 1 and subtract v2 you get a vector pointing from v2 to v1 if we did it the other way around if we said v2 minus v1 we would get the same vector point but pointing in the opposite direction we would get the vector from v1 to v2 okay so when you subtract two vectors you get the vector pointing from the second to the first and that's all we're gonna do to get the vector pointing at the mouse and we want that to be our acceleration because we want to accelerate towards the mouse so we're gonna take the mouse position and we're gonna subtract the mob's position and now we have a vector now we have the vector pointing from the mob to the mouse but the mouse might be far away or it might be nearby we don't want to accelerate ridiculously fast when the mouse is on the opposite side of the screen I want to always accelerate at a at a steady speed so that means I want to take this vector that I just got and I want to normalize it and all normalised means when you're talking about vectors is you're making the length one so this takes the vector it keeps pointing in the same direction the length just becomes one instead of whatever the length was before and even this is call also called a unit vector and unit vectors are super useful because they help you figure out directions right they tell you what direction something's going in but they don't worry about the distance or the length or the speed or any of those things right they just worry about the direction and if we have the direction of something we can always scale that vector to whatever size we want so let's multiply that by 0.5 so now our acceleration is going to be 0.5 in whatever direction the mouse is so in our update we will just now use that follow mouse so we follow the mouse and now what you'll see is that the mob is going to accelerate towards the mouse and I turn the vectors back on you'll see that the velocity is changing to go towards the mouse and that's pretty good but I'll turn the vector back off here it's not quite natural all right the the the mob kind of turns on a dime and it looks kind of robotic and artificial and so we can do better we can make this look much more realistic and smooth and that's what the purpose of these videos is talk about steering behaviors and steering refers to ways to make your movement look natural and there are all sorts of steering behaviors that we'll be talking about in later videos but in this one we want to talk about the seek behavior and we're just going to give it a target so this this function will calculate what the seek vector will be towards some target so what do we mean by seek behavior well let's look at another diagram okay so here we have our mob and this blue vector represents its current velocity it's currently traveling in this direction and then here's our target over here the mouse pointer so this red vector represents our desired velocity the the mob wants to go towards the target so it wants its velocity to be this and the length of this will be the max speed right which we set to five right so this is what it wants this is what it currently is if we instantly just set its speed to the desired then it would look really artificial so what we want is we want some steering this is the steering vector so we just take the desired minus the velocity we get the vector pointing from velocity to desired right and so this is the steering force this is the direction or the the force we want to apply to move our velocity to the desired now if we used it at the full length then it would instantly change from velocity to desired so we're gonna scale this and how much we scale this depends on what type of object our mob is is it a cheetah that can turn really fast so the steering force should be large or is it a slow lumbering elephant in which case it should be really short and should take it a while to pull its velocity over to the desired so we can control that by how long we make our steering force vector okay so now we can go over here to our seek and set it up so we want to set what our desired is now we don't really need this to be a a class variable self dot desired but I'm doing that so that I can draw it and you'll see later I'm going to have it draw its vector so the desired is going to be target pause dot normalize times the max speed right so that gets us our that desired vector the vector pointing from the mob to the target and its length will be max speed that's the direction we want to go and then our steering I'm just gonna call it steer is just desired velocity right just like we saw in the diagram now we need to just scale it to the right length so I'm going to make a variable here called steer what's called the seek force and that's going to be the maximum number that it could be let's set that to zero point one so if the length of our steer vector is greater than the steer force or sorry the seek force then we take the steer and we scale it to the length of the seek force and that's and then we return steer so now our seek force will give us back our seek method will give us back whatever the steer force should be okay and so now on our update we're gonna get rid of following the mouse we're not gonna follow the mouse anymore we're gonna do our acceleration so what we want to do is we just want to say our acceleration is equal to seek self dot seek and then the target is going to be get pause for the mouse right so we're seeking towards the mouse and then I want to draw the I'm going to add to my draw function down here at my Beck where I draw my vectors I'm just going to add and I'm just gonna copy and paste this to real quick just so that we can see what the desired is as well so we're gonna see the current velocity and the desired velocity okay so let's see what that seek behavior looks like okay so there is my mouth or my sprite see it's following the mouse that's good but turn on the vectors you can see see how the desired is always pointing towards the mouse and it's always the same length that's always the max speed but it takes a little bit of time for that velocity vector to move around and be equal to the desired and so this is with our seek force set to zero point one right so you can see if you wanted to see what a slower thing would be let's make it half of that let's say it was only 0.5 then you'll be able to see that it takes a lot longer for the sprite to change its velocity and get it all the way around to there all right so this is a big a big object with you know a lot of mass or something it doesn't turn on a dime and if our seek force was a lot higher then you're gonna see it can change really fast now one other thing you've got to take into account when you're doing the seek behavior is that when you what what do you do when the sprite reaches the target right see right now what happens is we get this wobbling effect and if we turn on this you'll see why it's because desired is always set to the maximum speed so as soon as we get past the target we want to go full speed in the other direction and then as soon as we have as we want to go full speed in the other direction so there's no way to actually stop when you reach your target now if you're if this is a an enemy that's chasing you and is going to hit you when it runs into you that doesn't really matter but sometimes you want the sprite to reach the target and stop there so what you want to do to adjust this is you want to use something called an approach strategy and so what the approach strategy is is that when you get as you get closer to the target you slow down so let's just copy I'm gonna duplicate this and I'm gonna call this seek with approach okay and this is just going to let us know or this is going to check to see if we've gotten close to the target and if it is if we are then we're gonna slow down now you could do this in a couple of ways the most flexible ways to basically define a radius around the target and if you're outside of that radius you run full speed towards the target but as soon as you cross that line and get close enough to the target you start slowing down and so we'll set an approach radius capitalize this and that's how far away we're gonna look to slow down okay and I'm gonna set that to a hundred and fifty okay and so now what we want to do is we want to figure out how far away we are okay so so before we normalize this this is going to tell us the distance from the target to the position right or the the vector from the target from the position to the target and so the distance is just going to be the length of that okay and then we can normalize the desired and there's a handy version of normalize is called normalize in place and we don't necessarily want it to always be back speed so we're going to rid of that so normalize in place just says take take this vector and normalize it but keep the variable name the same right we don't have to set it equal to anything it just normalizes it as it is okay so now we know what our desired direction is going to be we need to figure out what our speed should be depending on where we are so if our distance is less than the approach radius then our within we need to take our desired and we need to multiply it by some fraction of the max speed so we take our distance and we divide by the approach rate radius then we have and we know how close we are to the center right if we're halfway from the edge of the circle to the to the mob then we're halfway there right and what so we should go at half speed so we're gonna multiply that by max speed okay otherwise we're gonna go max speed okay so we if we're outside the circle we're gonna go max speed if we're inside the circle then the closer we get the slower we go okay so now our steer is the same the stuff stays the same our steer force is still going to be the same we're still trying to pull over towards our new desired vector and so let's just change this to using seek with approach and what I'll also do is just so that we can see the circle I'm going to add to the drawing here that we're gonna draw a circle at the mouse position so that we can see it okay so there's my acting just the same way as it was before actually let me go back over here I'm gonna put this back to the point one because that was a good medium value okay so there's our mob behaving as it was before but when it gets close it slows down and stops at the target and if I turn on the vectors you can see there's my approach radius circle and as soon as I get inside it my desired vector gets smaller so the steering force pulls it towards that smaller value not towards the maximum and depending on what you set your approach radius to you can have the object stop quickly ER or or take a little time and that is another thing you can adjust to make this behavior look all sorts of different ways right you can adjust that depending on how you want your mob to behave so that's the sikh behavior in future videos we'll talk about all sorts of other steering behaviors that you can implement to get a lot of different effects into how your mobs and other computercontrolled agents on the screen behave one example I'll give you before that you can try on your own is the flee behavior is basically the opposite of seek so you would just reverse this write your desired is going to be the opposite directions always pointing away from the target and then you'll always flee experiment with that you might want to do some kind of distance so you only flee when the target gets too close to you but I'll let you experiment with that on your own see if you can get that to work and we'll talk about that in a later video ok thanks for watching and hopefully this was helpful to you I'd appreciate it if you could like the video subscribe if you're not already and I will see you in the next indepth video you