all right this is part three of our indepth exploration of steering behaviors and in this video the behavior we're going to be looking at is the flee behavior making our sprite flee from a target run away from something so here we are again with our standard random mob running across the screen and what we want to do this time is I want to make the mob flee or a void to the mouse pointer so in the mouse pointer gets close its gonna run away and so with flee we could have it see you know infinitely far like we did with the with the seek but that gets kind of crazy then everywhere on the screen it's always trying to go off the sides because it's always fleeing the mouse what we're gonna do is we're going to make a radius around the mouse pointer and inside of that radius is where the flee behavior will take over you can think of it as the distance the mob can see right and when it sees that it's getting close to whatever it's trying to avoid it's going to avoid it okay so we're gonna set a flee radius and let's just make that 200 pixels okay so that's going to be the size of the circle around the mouse pointer that we're gonna flee okay so let's define that flee behavior so what the flee is gonna do is it's gonna figure out again just like usual the steering vector right the default value of that's going to be zero right we're not gonna be turning if we're too far away from the mouse so what we need to do is we need to figure out how far away is the mouse so we're going to take this the mobs position minus the target and now we have that arrow pointing from the target to the position and if you remember from our seek video we did target minus position right because we wanted the arrow pointing from the mob to the target this time we have the arrow pointing from the target to the mob because we want to flee away alright so this is gonna be pointing the opposite direction is gonna be pointing away from the target and if that distance the length of that distance vector is less than the flee radius then now we know we need to flee so a self dot desired is going to be that distance that we just figured out normalize x max B which is the same as we did in the seek remember we're doing we're pretty much doing the same thing we did in the seek behavior except we're doing it in the opposite direction steer will just be desired minus velocity and if the length of the steer is greater than the max force then we'll just scale it okay and then to draw the you know it let's set a default desired just so that we don't get an error message with drawing our vectors okay so that's our fleeted that's our flee behavior if you're close enough to whatever the target is I forgot to pass the target then you're gonna then you're gonna run away from it okay so we can put that into our update that self dot acceleration is just going to be flee and then the target is going to be position of the mouse and I've just added to the draw vectors here line to draw the circle so we can see the flee radius ourselves so let's run this and you're gonna see the mob running away from the mouse if I turn on the vectors you can see that when it crosses that line it starts running away and I can chase it around and it's always trying to get away now something you might notice though is that if it comes in a little bit yeah actually see that now it's speed is much slower because it stopped fleeing as soon as it got outside the ring and you can be left with a mob that has a very low a very low speed if you time it just right there we go you saw that so so what we'd like to also do is have the concept of a default speed and the default speed should be the maximum speed right so if there's no behavior acting on it if there's no flea force acting on it and it's going slower than the max speed then its desire should be to accelerate up to the max speed and so we can add that into our flee behavior by just setting the instead of having our desired be zero here we're just gonna say right if it's if we're closer than the free rate flea radius this is our desired but otherwise our desired is going to be whatever our velocity is scaled up to max speed and then we can actually unand end these things right and so so now our steering vector becomes away from the mouse if we're close to it or away from the target if we're close to it and otherwise just keep accelerating up to the max speed if you're not going the max speed and then that's gonna give us our steer so now if we turn that back on you can see if I try and get him off the edge see he accelerates back up to his maximum speeds right and I've added a function here that when I press M it's gonna spawn a new mob so if I spawn a whole bunch of them you can see they're all trying to flee away from the mouse all right by now you should be starting to see some of the power of these various steering behaviors with a relatively small amount of code in a really simple code we can produce the impression that we've created some really complex AI system and that's the nature of what's called emergent behavior right simple rules interacting together producing a complex result and it should also be hopefully apparent to you that none of this would be nearly as simple if we weren't using vectors and all of the nice things like you know length and normalize and scale that come along with vectors and vector math that would be really a huge difficult process if we're doing this with individual x and ycomponents and trig in a trigonometric functions and and all that kind of stuff it would be it would be really hard to keep track of so vectors are really powerful when it comes to things like this can't that'll do it for this video fleeing is a pretty simple process in the next video we're going to continue talking about steering behaviors and we're going to talk about avoiding obstacles things like walls how do you keep from running into the wall and go around obstacles that get in your way all right and I'll see you next time please hit the like button below and subscribe for the next video thanks you