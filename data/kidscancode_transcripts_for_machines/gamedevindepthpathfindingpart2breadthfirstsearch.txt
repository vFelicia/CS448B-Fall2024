hi welcome back this is part two of our indepth pathfinding video series and in this video we're going to talk about how to implement our first search algorithm or path finding algorithm which is the breadthfirst search okay so in part one we built this simple structure where we could make our grid of walls that we will be able to walk around on and we can click and draw walls wherever we want since the last video I did add just a quick thing here where if you press the M key it's just gonna print out a list of all your walls it looks like this when I press M over here it's just gonna print a list of all those wall locations and what that allows us to do is copy that print out and paste it right here and quickly make some walls that way when I run my program I am not always starting with an empty map and have to draw the walls every time so if you spend some time drawing a map layout you like you can just quickly save it just a quick and dirty way of doing that okay so we've we've got our map we've got our our grid set up we can find neighbors how do we calculate how to get from one point to another well as I said in the first video we're gonna talk about a few different path finding algorithms but the first one that we're going to talk about is one that just visits every square in the map okay and that is called the breadthfirst search algorithm and let's look at how that algorithm works so the breadthfirst search is also called DFS and all it does is you have something called the frontier the frontier is a group of tiles an expanding ring of tiles coming out from whatever your start position is and you just loop through over until that frontier is empty and there's only three steps to this algorithm first thing you do is you take the next location now they're out of the frontier you mark it as visited so you keep track of which ones you visited so that you don't ever visit them again and then you expand by taking that location and adding each of its neighbors to the frontier and that's all there is to it so let's look at an example of how that works okay so here we have our simple five by four grid and I've chosen this tile to be the starting position marked it with a star now to begin with the only tile that's in the frontier and I'm gonna mark all the frontier tiles with red all the visited tiles with green right we haven't visited anywhere yet so there's no green tiles you start out with your starting tile in the frontier and that's it so the algorithm says the first thing you do is you take the first tile in the frontier and you mark it visited and then you add its neighbors to the frontier so now the frontier has these four tiles in it and we're done with one loop now we go back to the top is the frontier empty no so take the next one market visit it and add its neighbors and then we're gonna continue doing that around and around slowly adding more and more neighbors to the frontier until we get to a situation like this see number 11 here so when we mark that one visited there's no neighbors it has no neighbors to add to the frontier because these two are already in the frontier and there's nothing over here because we're at the edge of the map so so it just gets marked visited and we move on to number 12 which is gonna do the same thing 13 you can see we're slowly filling them all in until we have visited every single square and that's it that's the breadthfirst search so let's look at an example of that running so you can see what it looks like in practice so here's a big empty grid and this red tile this is the starting tile so it's the one in the frontier only one in the frontier and when I unpause this you'll see it's just going to expand the ring just like we did in the demonstration until it is visited every tile and what's great about this algorithm is it works just as well when you have walls so if we look at another situation where we have all these walls right when this neighbor when we look at its sorry when we look at this tiles neighbors it only has these three neighbors right because this tile is not going to count so this tile won't get out to the frontier same thing with all the walls so when you run here the ring just goes all the way around the walls until you visit everywhere and that's why this algorithm is sometimes called the floodfill algorithm if you've ever used a paint program and you use the paint bucket tool you know you click somewhere in a shape and the paint fills in all the empty areas that is exactly how that is implemented in a paint program is using the breadth first search algorithm to do the flood fill ok so let's talk about how we can implement this algorithm in code so the first thing we're going to need is let's look back at the algorithm for a second so we're going to need a frontier and we're going to need a list of visited tiles the list of visited tiles is just going to it so we keep track of which ones we have visited and this frontier is where we're adding and removing the tiles as we look at them right but we need to do them in order the first one that we add to the frontier should be the first one we take out and so we need what's called a queue a queue is a data structure where when you add things you add things at one end and you take them out the other okay so the first thing that gets added is the first thing that comes off just like when you stand in line at the store you get in the back you have to wait for the people ahead of you before you get to leave the line and so we could use a list in Python to do this queue right we could have a list of items and adding to the N is just using the append function of a of a list at the end and when what we want to remove we would need to pop item number 0 now the problem with this is remember lists are indexed right this is position zero position 1 position 2 so if you remove the item at position 0 you take it out then everything moves and this becomes position 0 this position 1 this position 2 everything gets reindex t' and that is slow lists are not really good at reindexing quickly that's not what they're for so what if we tried the other way around right what do if we did it in the opposite direction and we said that when we want to remove we just use pop with no arguments right that means take it off the end so pop will be fast it'll just chop the one off the end item would be equal to 1 and 1 is removed out of the list but then when we want to add we need to insert the new item at the front of the list in position 0 which means all of these other ones have to be re indexed again and we have the same problem so this is not going to be the optimal solution for this because you think about we're gonna have a lot of squares to visit we're gonna have a lot of tiles to be added to this frontier all the neighbors every time we look at a tile and removed from the other end and a list isn't going to be very efficient the answer is to use something from the Python collections module the collections module is part of the standard library that comes with Python and has lots of useful objects in there the one we care about is called the deck the doubleended queue and this is a data structure that is set up to very efficiently you can add items to either end and you can remove items from either end you cannot access items that are in the middle you can't look at in index and say what the third item of the list because this isn't a list is a queue and all you care about is the ends that's perfect for our situation so the way we would use that is we can use append to put things on the end and we can use top left which pops things off the left hand side you could totally go the other way around and do pop things off of this side and append left at this end doesn't matter works exactly the same and it's gonna be very fast and efficient for all the piles will be looping through right let's start writing some code so first thing we need to do is let's define our starting position I'm just gonna put it around the middle here so that's going to be the starting tile and then let's hide that let's define breadthfirst search okay breadthfirst search works you give it some sort of graph and you give it a start position all right so we're just gonna pass in those values and that's all it needs okay and so we're going to make the frontier a one of those double ended queues which we need to import okay so we have the deck we will put the start in it that's the only thing in the frontier when you start and then I'm also going to make a list of visited tiles all right which all it has in it at the beginning is the start it's the only one we visited and now we just need to start that loop all right as long as Len of frontier is greater than zero right so as long as there are things in there we are going to loop through and do the steps of the algorithm all right so the first thing is we'll pick the current current tile that we're looking at is the next one in the frontier all right so we pop the next one off of the queue and that's our current okay now we need to look at the neighbors of current let's call it the next next files so we take the graph and use our find neighbors function we wrote last step and we find all the neighbors of the current tile if the next tile is not Envisat 'add we haven't visited yet and frontier then we're going to add it to the frontier and we're going to append it to the visited tiles okay so we're sort of combining those two steps because it's just a little bit quicker I wrote in twice okay and then so at the end of this we will have visited all of the tiles but how will we how will we know well I'm not gonna write the code here to animate exploring because you know obviously you don't want to do that when you're doing pathfinding in your game so all we want to do is have it walk through and visit all the tiles and so let's just when we're at the end print out the visited list and see if we've visited all of them just to test okay so we run this by executing that so here's our start so if we just say breadthfirst search we have gee our graph and start and there we go it lists a whole giant long list of tiles right but this isn't very useful because it doesn't tell us anything about how to get from tile to tile this just visits every single tile and marks them visited and that's it that's not good enough so what we want is to be able to see all this up again here what we want is to be able to see how to get to the start starts gonna be over here so if you're here how do you get there or if you're over here how do you get there what's the path to that point so I'm any other point and we can do that pretty easily by going in here and changing we don't care if or we're not concerned about whether we visited or not we're concerned about when we visit a new tile where we moved to it from okay so I'm gonna make a dictionary call called path the key will be a tile and the value will be what tile we came from right so for example we can say the path just start is not because alright you're already on the start when you're on start so you don't need a path to there but anywhere else when we look if next is not in path then we're gonna path the path for next equals okay and that's gonna say for example that you know if you're on a tile here then this tile should point back to this tile right that's the tile you steps from so an easier way to do this instead of saying that you know 0 1 is connected to 0 0 is to actually put an arrow there it's actually have a direction and the easiest way to do directions is with a direction vector alright so if we said current minus next that's going to be an arrow pointing from the next tile back to the current say path here autocomplete right and so we'll have a direction vector pointing the direction we want to go ok and let's get rid of this print ok now watch what happens when we run this ok we get an error okay and the error no this is hard to read so I'll here the error is unhackable type our problem is we're using a dictionary here right and the key of the dictionary is we want to use the tile we're on and we're using vectors to represent the tile well vectors it turns out cannot be the keys to the Cheniere because they're not hashable kind of annoying I thought about this for a little while there's a couple different ways we could approach this but so when you're doing a dictionary the the key can be any type of object right it can be a it can be a string it could be a number it could be a twopole it can be a lot of different things but it just happens to be it can be a vector but it can be a pair of numbers like this right and so the easiest thing to do is let's just convert our vector into one of those I'm just going to write a quick little function that does that conversion and it just returns the X and the y of the vector and putting an anterior because when you we are using integers for all of our table locations right it's going to be 1 comma 1 or 5 comma 7 but when you use the PI game vector to function it will send them back as real numbers so you'll get one point zero and twelve point zero I'm just going to use the int function to strip away that decimal ok so that means now that whenever we want to whenever we want to put something into this dictionary we're just going to convert it to an integer so we need to do that with this one with this one okay and that will take care of that error okay so now we're getting value so as the frontier creeps around and explores everywhere each tile is going to have a vector pointing up down left or right back to the tile it was on previously the one it was the neighbor of right so like when this one was the current this was these were neighbors whichever ones it added they're gonna point back to it so we have little Direction vectors for each of those and just real quick you can see that if we just print out the path just so you can see what the output is each each tile has a vector and see the vectors are all unit vectors pointing up down left or right okay and so let's visualize that so what we're gonna do is we're gonna return that path so whenever you run the function that's first search you're gonna get back you're gonna get back to the path all right so path equals that so we have our path we have all our vectors we just need to draw them and to draw them I just have here this this code right here which I've just pasted in goes to the icons folder and gets an arrow an image of an arrow pointing to the right and then I just create a list of those arrows four of them rotated in each of the four directions so I have arrows pointing up down left and right just four different images you can import those you know you could load this however you want it but that's how I'm doing it just so that I have four different arrows and I can draw them here and so what we want to do is we want to go through for each node and direction in that path dictionary if there's a direction because remember where we're gonna have none if we're on the starting pile then we're gonna get the X and y of the node and then I want to find the center of the tile so I can Center the arrow image so that just means I need to take the X of the tile x tile size and add tile size / okay and I'm just going to do the exact same thing for Y and then the image that we're going to use for this tile is the one that's pointing in the direction in the direction that we need we're going to get the rectangle to match with the center at X Y and then we're gonna obliterate all right and if we run that we should see a bunch of arrows so here's our start tile we'll probably need to draw something there too but here's our start tile and you can see from any point you can follow the path of arrows and you will get to the start point now the only other thing we need to do is if I add some walls you see nothing changes because we're not updating anytime we add or remove some walls we need to rerun the search so what I'm going to do here is if there's a click whether we added or removed we're just going to recalculate geez start we're gonna recalculate the breadthfirst search that way you can go in here and you can do things like closing off walls and you can see how the arrows change when you do that and go all the way around and if you block off an area well these are not neighbors of anybody anymore so they're never gonna get searched so anytime you close off an area it just won't get searched or included in the in the directions so so there you go and that's our first version of pathfinding now okay let's just add one other thing which is I want to add that if we click the right mouse button then I just want to change the start to that position and I want to recalculate when that happens to so any kind of mouse button is gonna make it re calculate button one will let us draw button three will draw walls button three will let us move the start that way you can also right click and move the start position around and see how that changes plus adding whatever walls you want okay so that is our breadthfirst search path finding algorithm this is a really useful one for all sorts of different kinds of game applications like for example if you're making a tower defense maybe your start is over here so this is the destination you're gonna have the mobs all spawn over here and then they're gonna follow whatever path through to get around and get out of the level and then you can you know predefined the walls and the player can place their turrets and things wherever they want them to be for something like our zombie game this location will be the location of the player and then you know how no matter where on the map a zombie is it has a way of getting to the player and it can roam around the maze and get to the player and that's a lot more efficient than you know if you have a lot of zombies that's a lot more efficient than having each zombie calculate its own path because then you have to do path finding you you know 20 times this way you do it once for the whole map and anything on the on the grid can look at the this vector field and head towards the player okay so in a in a later video so we'll talk about some other different kinds of path finding plus some other things you can do with this we didn't really talk about diagonals yet diagonals are a separate issue which can cause you need to do things a little bit differently for and we'll talk about that in a later video as well I hope you enjoyed it and I hope you have fun and I will see you in the next video thanks you