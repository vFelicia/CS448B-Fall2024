welcome back to another of our indepth videos on pathfinding in this video we're gonna be talking about something called Dijkstra's algorithm which is yet another optimization and improvement on the path finding algorithms we've looked at before in our last video we talked about how doing diagonal movement on the grid resulted in some weird paths for our path finding algorithm right our algorithm is supposed to be finding the shortest path which would be a straight line between the X and the home but it came up with this weird diagonal path and it turns out that our algorithm is doing what it thinks is right and it is finding the fastest path or the shortest path the amount shortest amount of movement and that's because diagonal movement isn't the same as orthogonal movement up and down left and right and the reason for that has to do with a little bit of trigonometry so to review that real quick when you move on a grid horizontally or vertically if this is this is a distance of one in a diagonal movement by a Pythagorean theorem is a movement of distance of a square root of 2 which is around 1.4 so moving from here to here if you move if you take this step in the same amount of time as you take this step then you're moving you know around 40% faster when you go diagonal so it's quicker to get somewhere moving diagonally than it is moving horizontally and vertically and we need a way to compensate for that and make the cost of movement when you move diagonally higher than the cost of moving horizontally and vertically and so we need to introduce the concept of a movement cost to our grid so what that's going to allow us to do is not only say that moving this much takes is a cost of 1 but moving this much is a cost of 1.4 but we can also make areas of our map that cost more to move through like imagine this was a map that had a forested area or or a swamp right moving through the swamp will cost you more than moving through the open grassy field and that will allow us to calculate paths that are not the shortest geometric distance but the shortest distance based on how much it costs to move right if you're if your character can only move ten squares in a turn then you know ten squares running along grass is gonna give you a lot farther than the swamp where each each square costs you five to move so you can only move two squares in a turn all right you can see what that means as we start implementing it so the first thing we're going to need is we're going to need some more information in our grid so our grid is not just going to be the the map the squares where the walls are but we also need to introduce the concept of costs so what we're going to do is we're going to take the square grid class and we're just going to extend it to the concept of a weighted grid so we'll call this weighted grid grid and this is a this is just a square grid class and we're gonna extend it okay and so what this is gonna do is when we when we initialize it and give it a width and height just like we do right we will just call the super class which is the super class is whatever class this is a child upright square grid so we'll call the super init with the width and the height and all that's gonna do is go ahead and run this code so it'll go ahead and build the connections and the walls and the set the width and height and we don't have to repeat that code in our weighted grid okay and then we're just going to add to this that there is going to be a dictionary called waits and waits is just going to be a dictionary that's going to have you know inside it it's going to have keys that are like the grid location and then the value will be some cost right the weight the cost it costs to move into that square right so each square will have a will have one of those so we'll have a set of weights and then we need to be able to return to be able to query that and ask what's the cost to move into this square so what we'll do is alright when you ask for the cost you say what square you're standing on and what square you want to move to okay and we have two ways of calculating cost right we want to be able to look at the tile and see is it a swamp tile or a forest tile and cost more to move into right which is gonna be contained in this dictionary that data but we also want to account for the orthogonal versus diagonal right so if we're moving horizontal we're gonna get one cost for a moving diagonal gonna get another cost and that's gonna be added to whatever the terrain cost of the tile will be so first we just need to see if we're moving for moving diagonally okay so if the one we're moving to from so it's we're just so if the distance is one that's a function my parentheses if if that's a if it's a distance of one then we know we're moving horizontally or vertically right so what we're gonna give back is whatever in the self dot weight we're gonna check the two node right and return zero if that isn't in the weights list right so if we're moving into a square that isn't doesn't have a way to sign to it the default weight will just be zero and then we're gonna add the cost for moving horizontally or vertically right otherwise what we're going to return duplicate that and move it down otherwise what we're gonna return is the cost plus the cost of moving diagonally right so if we move straight we had one if we move diagonally we had one point four but then we're getting you know fractions and things and so it's very common practice when working with these kind of algorithms to just make these whole numbers and call the orthogonal cost ten and the diagnosis still the same but then we're dealing with nice integers for everything okay so now we know what the cost is to move and we are done with our we've we're done with what we needed to add to our grid to account for movement costs so now when we start running our search we'll be able to when we look at the neighbors of any of any square we'll be able to get the cost of that movement but then we want to prioritize by that cost right we want to try the lowercost movements first right we want to give them priority that means that when we're doing our search and we're adding nodes to the frontier we want them to be sorted by that priority so that we take them off in that same already order and so to do that we need to use something called a heap queue okay and we can import that it's another useful thing in the Python standard library and all a heap queue is is it's it's like a list except that each item in the list has a priority assigned to it and it automatically orders them I should say it's not like a list it's like a queue it's like the queue we worked with before where when you push items onto one end and you pop them off the other end but what the heap queue does is each item is assigned a priority and it automatically in an optimized way keeps them ordered by that priority so that whichever one you pull off the end is gonna be the one with the highest priority and whenever you push one on it gets put wherever it needs to be in that priority list so so we can use that but the the heap do can do lots of other things that we don't need to deal with so what we're going to do is we're gonna make a we're gonna make a class to make it easy to work with the part the heap queue okay so we'll call this a priority a priority queue okay and okay all this party queue is gonna have in it is a list of nodes okay and so we have two operations that we're gonna want to be able to do to this cute we're gonna want to be able to put things on it and we're gonna want to be able to get the highest priority item off of it so we'll define both of those operations we'll call it put when we want to put something on and we just give it some node and some costs right that's gonna be our priority and the command to have the key heap queue add it is heap push and you just tell it what heap we're using well that's the nodes list and what are we pushing we're pushing the cost and the node okay so each time you add something to the heap queue you give it a tuple of the cost the priority which is the priority in our case and the node that you want to add and again every time you push one of these on it's going to take this cost and order them by that in ascending order so that the highest priority is the lowest cost all right so cost of 0 is going to be preferred over a cost of 10 and then we need to be able to get whatever the next one is in the list and that's just heap q heap up and if you what keep is self dot nodes and that's just gonna give you whichever the highest priority one is next one on the queue it's gonna pull it off and it's gonna give us back this so we want to actually get I only care about what note is the next and the priority I don't care about the cost I just used that to sort them and we're gonna return that so now we are able to get it off and then I'm gonna add one more method on here called empty which just lets us check because it's a true or false whether the queue is empty or not that way we know we're when we're done with our search right we only go until the frontier is empty and the frontier is empty there's no more searching to do so we're just gonna return however long that is and compare it with 0 if it's equal to 0 then we're gonna return true if it's not then we're gonna return false and that's our priority queue we're ready to start talking about our algorithm and when you do a search through a grid using weights the goto algorithm for that is called Dijkstra's algorithm named after the computer scientist who first formulated it you know and you can look here on Wikipedia there's a great article about it with all sorts of detail and a little overview of in pseudocode of what the what the algorithm is and you know that's what we're gonna that's what we're gonna implement it's gonna look very similar to what we've done before with just the addition of using those costs to prioritize what order we look at everything okay so now we can start implementing our algorithm it's going to go right here in this Dykstra search function I've created and so what I'm gonna do to spare you watching me type it all as I'm going to paste it in here and just go over what's different from what we've done before okay so again we have a frontier this time it's going to be the priority queue object and we're gonna put the start node on it with a cost of zero because obviously it costs zero to move to the square you're already on and then we're gonna keep tracking the path just like we've done before that's gonna be that dictionary full of unit vectors pointing in the direction that you're supposed to move in so we can build our a little list of our little image of arrows to show the path on the on the screen and then the cost is going to keep track of what the cost is to move to each square as we look at them okay and so again we're gonna just loop through as long as the frontier isn't empty and just keep getting the next one on the list to look at and this is because it's a priority queue the next one we get is always going to be the one with the lowest cost that's on the frontier so we'll always be looking at the lowest cost first and if we find our goal we're gonna stop right if you want to like we did in the first video make explore the whole map and get all the paths from everywhere you could leave this part out but we're gonna do the early exit thing and and stop if we find our goal and then we just start looking through the neighbors right we get the list of neighbors and then we're going to calculate the cost the cost is whatever the cost is so far right that we've got so far plus whatever the cost is to move to the next square right using our cost function that we built into our weighted grid right that's gonna return the the ten if you're moving horizontally or vertically and the 14 if you're moving diagonally right if it's not in the cost this was not in that cost dictionary then we haven't looked at it yet but we're also going to check and see if it's if it is already in the dictionary but we found a lower cost right depending on what direction you come from it might cost less to move into the square then it did the first time we looked at it from a different neighbor alright so we want to make sure we're using the lowest one so if we find that we haven't looked at it before or we found a lower cost then we're going to update those values and put it and put that neighbor into the frontier with that with that priority and then the last thing we do is add that direction vector in there okay and that's all we need to do so very similar to the breadthfirst search just the addition of these costs so now I just made sure that my graph is a weighted grid and I'm calling that function on it and when we run this you'll see we are going to get much nicer paths we will use diagonal wind diagonal makes sense right and we'll go through bolts but we'll also get very nice smooth paths through our map right that look very nice and are going to be the shortest paths okay so our diagonal movement is working really well let's look at what happens if our weighted grid has some terrain in it right we've given some values to some tiles some weights to move into them so that they cost more to move through and so our costs are gonna vary not just be the diagonal and horizontal so what we're gonna do is I'm gonna go down here and I'm going to remove the walls for the moment that's I'm just gonna comment this out so we don't have the walls and I'm going to add in a list of tiles that I'm calling terrain and I'm going to stick those all in the weights dictionary with a value of 15 so it's gonna any of these tiles are gonna cost instead of zero to move into they're gonna cost 15 right and so zero plus the horizontal or diagonal movement cost they're going to cost 15 Plus that okay and I've also updated the draw I've also updated the draw function so that will see them drawn in a Foresti color and so what that's going to do is that's going to look like this okay so if I put my start here you can see the shortest path is now avoiding going through those forest tiles because they cost more right if you're inside it well we got to go through them so it's going to find a place where it can go through the least number of those forest tiles but if you're on the upset side of the forest it's quicker to go around than it is to go through because of the movement cost right and depending on what you make that movement cost you can make it even more painful to walk through and more something to avoid okay and that's it that is our Dijkstra search all working the way we want it and now the next question becomes how do I avoid having to search the whole Matt right because if it's a big map it's a lot of tiles to look at and I'm exploring all this stuff over here when I really don't need to right and so the next step is going to be to give a little bit of intelligence to this search by prioritizing not just the movement caused by prioritizing the direction thanks for watching I hope you enjoyed it and learned a little bit more about path finding and I'll see you in the next video when we start talking about optimizing our search you