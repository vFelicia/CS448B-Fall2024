welcome back to my series on procedural generation using Godot 3.0 in this video we're gonna look at generating random Maps as you explore them if you download the starting project from the link below you'll get the following scenes already set up and ready for us to to make this project so we're gonna start by using the isometric tile map this is the tile set that we talked about in the previous video isometric Road tile set with roads for all 16 possible combinations and what we're gonna do is we're gonna make it so that you start out so you're standing on this square this is the starting square and when you move to another tile we're going to randomly pick a tile that goes there and then when you step to the next one we're gonna pick a different one and we'll make sure we always pick one that matches so we don't really don't ever get something like that you know we don't ever get a mismatched tile so the maze will rename this two roads but we'll this is going to be the scene that we'll do our main exploring and our main right our main code in okay we also have a truck scene and this scene contains the vehicle to the player be driving so this is gonna be the player and we're gonna move from square to square driving this little truck around and it's using an animated sprite to display the different art for the the car facing in the different directions and we're basically going to only use north south east west but it does have some for the all eight directions so that is our starting setup all right so I'm gonna briefly review the code for the truck because what I want to focus on for this is writing the code for the map so this the code for the truck is going to be as follows we're just going to review it real quickly so we have some constants here like we did in the map video designating what north south east and west values are in our tileset then we have a mapping that maps those to the animations so that if the player moves north we can change the truck to show the northfacing image four moves we have a mapping from the direction we want to go into what vector that represents in the tile space so moving one back one space north is negative one in Y and then we're gonna have a variable that keeps a reference to the map itself the tile map which is going to be in the parent scene we're going to keep track of our map position that's what tile we're on right we don't actually care that we are in isometric space or orthogonal space it doesn't matter to the player they're just moving from one tile to the next if they're on tile number four comma three and they move to the right they're gonna be on tile five comma three in and if that in the display space looks orthogonal that doesn't matter to the player speed is how fast our animation is going to happen it's going to take one second to move from one Square to the next square so you can speed up or slow down your movement speed and then we're gonna have a flag here that keeps track of whether we're already moving that way when we are in the middle of a move animation and we press a key another move won't get kicked off we're only allowed to move when we've stopped moving now we have a check here a function that will check to see if a movie is allowed so when we press North we don't want to be able to move north if it's blocked so this is going to do that comparison right we're gonna get the ID of the cell like we did previously in them in the maze function and we're going to compare that with the for with the direction that we wanted to go in and if that east wall is on it's set to a one then this is gonna be this is gonna be true so we will return that can move is false otherwise the move is allowed then we have our input which is going to ignore things if we're already moving otherwise it's going to move in the direction matching the key we pressed and then here's our move function itself alright if we can't we're not allowed to move we will do nothing then we will change to the animation that matches the direction we will increment our move our map position by whatever vector we're moving in and then we're going to check if the square we're moving into is a negative one and in tile maps and negative one means an empty square so if we're moving into an empty square we're going to tell the map to generate a tile we're going to tell our parent to generate a tile and that's the code we're going to be writing in a few minutes and then after that we just need to do a little tween animation to change our position from the current position to the destination which is one tile over the center of one tile over plus a little bit for the size of the truck itself and that's it when the animation finishes moving goes back to false and we're allowed to move again so you'll see how this works in a few minutes when we start working on the map so let's instance a truck in our scene and you can drag it and put it there we're gonna place it on the starting cell via code anyway so don't worry about getting it centered and perfect but it's gonna start on our one starting square and you can pick whatever starting Square you want and then the truck has a camera attached to it so it will follow that the camera will follow the truck as it drives around so you will be able to explore essentially infinitely in whatever direction the roads take you so we need to start working on the code now for how we're going to generate this now we're gonna start with some of the same information that we have used before and that's our constants and our mappings from between vectors and directions and you notice we use the same ones over in the truck script too so this is kind of thing that if you're using it a lot you could make this an auto load put it in a in a singleton that you can access from everywhere but for right now with our for these small demos I'm okay with copying and pasting it and having it in two places we're never going to change what North is we've defined North as the one first digit East as the second digit and so on so and then we have a reference to our Tao map so that we can use that and then in our ready we're going to set the truck map the map right we want we added a we added a property to the truck that references the map so we'll give it that reference we're gonna set the trucks map position to our starting tile which we put at zero zero so we're gonna just stick with that and then the truck dot position this is the starting pixel position on the screen we're gonna find that by map to world and we use the trucks map position right and then we're gonna add that off step so that it's at the center of the tile and you'll see when we run it that's gonna stick our truck right there at the center of the tile to start now if we try to move we're gonna get an error because our truck script when we move tries to call generate tile because as soon as we move we're gonna move into an empty tile so we're going to add that now what does and we want to generate it whatever location we're moving into right when we call it we're gonna call it to generate the tile that we're moving into so I'm going to generate a tile at this location and that means we need to find all the tiles that will fit in that location so in the case of this situation right when we move to this spot right the tiles that fit there like for example 9 does not right 8 does not 7 would be fine right so we needed to go through and find out whichever ones have the same tile the same top wall value on this side as this cell that we're moving out has on its opposite side so we're going to get a we're going to make a function called find valid tiles that will return a list of the cells that fit in that spot and then we'll set our map location to that so cell and we'll pick a random value out of it and that will do it and now how do we find those valid tiles so this function returns all tiles that all valid tiles sorry valid tiles for a given so so we need to check all of them right so we need to check all tiles from 0 through 15 and see if any of them will fit so first we have to get each of their neighbors each of that cells neighbors all right so we have to check charge spacers neighbors if they exist right there may not have one so we think about it we might have a situation like let's say we had this we have a curved road here we have a straight road coming out like that and then it cursed this way and has that so now if we move on to we move on to this spot right when we move here the tile that we pick has to match this side this side and this side right which is how we're going to determine what fits so there's actually only a couple of tiles that fit there right this one will fit there the curve going out will fit there where is that one alright that will fit there right because it needs to be solid on these two sides and open on this side and then this side is it is can be any okay so now in our code what we can do is if the the cell is there right so first we're gonna have a we're gonna set a flag here right we're gonna assume it doesn't match right and then we're in and each of those keys right each of the vectors each of the directions right neighbor ID is map gets L we want to get that cell we want to get cell the cell we're currently in plus n right we're gonna check all the neighbors alright so if that neighbor ID is not equal to zero right that means if it's not a empty tile then we want to see if there is a wall match between the neighbor tile that we're checking and the tile we're trying to place right which would be I so if those two things have their walls matching and in the maze tutorial we talked about how you can take the neighbor ID and you can do a bitwise and with the cell walls value and compare that with the same thing with the other cell right ones negative one is positive because of the opposite and then if this here returns zero that means that there the wall is open so this what this returns zero and this returns zero that means they're both open so that matches and then this would return non zero and non zero and that's the only problem you're gonna have is this will miss some matches and to show you how let me do a quick demo so I'm gonna do this in the Python shell real quick just because Python does the bitwise operators the same way and I can just demonstrate this real quickly so let's say our cell we're looking at is number 15 right that's the one that has walls on all four sides so that means if we say I and one the north wall we're gonna get one if we say I and two well we know that wall is there too so what do you think it's going to return you might think it would return one cuz but this isn't a true or false test so it returns two and so on and so when you test the the west wall for example you get an eight well that means that if we're trying to match two tiles we might have a situation where we're trying to compare is two equal to eight and that's no good that would mean that the east and west wall it doesn't think the east and west wall values match up right one of these is less one of these is the east so the way to to fix that is to do it's just divide by the value you're comparing right then you're gonna get it one and then now our answers will be zero or one if we were on tile number zero for example i % eight or eight that's going to be zero so that's what we need to do here so these two comparisons they have to be divided by the same value which leads to a fairly long line but it does solve our problem okay so now we if those two things match then we have a match right if these two values are equal either both zero or both one then his match can be true otherwise is match is gonna be false and we have to set it to false because we might have checked one side remember we're doing this right if we check this side and find a match and this matches but the one we then when we check this wall it doesn't match then the whole tile has to be thrown away right because it has to match all the sides so we said as match to false if we find a mismatch between two walls and if that happened since we found a mismatch we might as well break because there's no point in testing any of the other walls if we found one that doesn't match the whole tile has to get tossed out so now what we can do is if so if we got through all of that and as matches true we want to add it to our list of tiles so if we found a match and we haven't already added it all right if we find a match and it's not in the list already actually I realize we got to make a we need a variable to store all these all right we're returning a an array of the valid tiles so so if we found a match and it's not already in the list of matches then we'll append it and at the end we can return valid tiles ok let's give it a shot so there I am if I press the right arrow key I'm gonna move east move on to that square if I press the down arrow key I'm gonna move south oh and there we go it filled in what goes there press right down see I'm now I am exploring up got a dead end there I can go down all right now I have an infinite random world I can explore I can just keep going and I know that the tiles will always match up right so what do you think's gonna happen if I go east here all right the only one that would fit in that spot was that one all right so that's our infinitely generated world and the next video will talk about some more things we can do with this now that we have the basic functionality working you