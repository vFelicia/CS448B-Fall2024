welcome to part three of our pathfinding series in this video we're gonna build on the breadth first search algorithm we explored in the last video and talked about how we can find the shortest path between any two points on the map in our previous video we used the breadth first search algorithm to explore the whole map and find the path from any point on the map to some goal location and we also made it so that we can move that goal location around and see how the paths change alright and that's useful for a number of different types of applications but sometimes you want to find the path from one just from one point to another point if you have the concept of some start location and some end location you just want to find that path you don't care about the rest of the map so what we're gonna do is we're gonna call that home location the bill and we're gonna add a start location okay and then I've actually loaded some other graphics to do this so what we want to do is be able to have a start location and a goal location I'm using the middle mouse button to change my start and the right mouse button to change my goal and I just want to draw this path not any of the other paths so let's start by changing what we're drawing down here at the bottom this loop right here is drawing all the arrows in every place on the map so instead we're going to get rid of this and what we're going to do is just draw the path from the start to the goal okay and so we want to start with we're going to move from node to node along that path and we're going to start with the start node the one right after it I don't want to draw an arrow on top of the X I just want to draw the next one so I'm going to start with the next one whichever one is pointing whichever one the start points to right so as long as we haven't reached home as long as we haven't reached home we're gonna keep doing this oops well current okay we're just gonna keep drawing one after another until we've drawn them all so we're gonna take the current dot x times the tile size let's tile size over two again so that we can get the center do the same thing for the Y and then we're going to pick the arrow we want which is whichever item in the path we are looking at it's going to give us that direction vector so we can pick the right arrow get rekt so that we can Center it and flip that on the screen now we also want to find after we've lived that we want to find the next node in the path so we just add the current we just add the next one the next vector in the path so like that okay okay yeah oh I have an Hermes elf right we're going to the called it goal not home okay so now we can just draw our single path from the start to home okay now this works fine and it's gonna draw it from anywhere on the screen but you might notice something a little bit odd if I remove some of these walls you can see that we're not really taking the shortest path right we're going all the way down and then all the way over when it would be shorter if we you know took some steps over all right if we're right way over here see it just draws straight and that's happening because we are doing because of the way we're doing our find neighbors so here on our find neighbors for each node we're adding the various connections which we listed here and we listed them in this order right we're trying to the right to the left down and then up that just happens to be the order we wrote it in but that means it's always gonna prefer going right over going left it's gonna always prefer going down over going up and that's what's getting us those really long straight stretches and there's a few different ways you can deal with this but the most simplest and the most elegant is when you get the neighbors for your node we're going to add just a little bit of variation here by just saying yes I'm going to take I'm just going to add the node x and y okay and we're just going to alternate here using % to to say if it's an even number we're gonna do one thing it's an odd number or not if it's an even number I'm just gonna take neighbors and I'm gonna reverse it okay so every other time we're gonna go the opposite direction through this and look at these neighbors first before we look at these and that's going to let it choose different directions so now if I remove some of these walls here again you can see we're taking a much more straight path right we come down and then we start jogging over so if we were actually exactly diagonal we'll take the most diagonal path and that's going to work when we are when we are really far apart as well right it's gonna find the diagonal path and that's gonna look a lot better as we travel around these things like this when we go around corners okay so that looks good and we're getting good paths now from start to end now our problem is that this is very inefficient right because wherever we are on the map we're exploring the whole map and finding all these paths even though this is the one we want so I'm only showing this one remember our floodfill algorithm our breadth first search is searching the whole map so them so we're searching all of these tiles over here even though there's no way for them that they would be part of the path all right and so that's where we can start talking about some variations to this process to improve its efficiency and we only want to find this so let's not waste our time doing other parts of the map okay so the way we could solve this is we could go to our search here and we're gonna add that there's a start time and an end time and all we need to do is here in our loop as we're going through and looking at every tile if current equals end break right because if we found the final tile I mean we found the goal tile we don't need to keep searching so we can just stop searching and return what path we have so let's change that we just need to add that we included this in the function right now if we run this this isn't gonna look any different right it's still gonna find the path we want right but let's look at what's happening by looking at that animation that we had before okay so here's my animated breadthfirst search and so when I start this off we're gonna keep filling out like normal but as soon as we reach and have found the start tile we can stop and we don't need to bother exploring any of these over here okay let's look at it one more time with some walls in there so that we can see how well it works in that case right so here we are we know what the paths is gonna be let's see how quickly it finds it all right so now we saved ourselves a whole bunch of time by not exploring around all of these areas okay so it's much much more musician so back over to our code where our breadth first search is storing the full path right it's storing all of the tiles that it visits so we can just show these on the screen by this little section I added here which just goes through that path and fills a man in a darker color so that we can see how much of our map were actually exploring whatever we run so as I move around we can see right when it's close by we're not very far away we're saving a whole lot of time and you can imagine on a much bigger map or a much more complicated map that this would save a whole lot of time especially if you're having to recalculate these paths often because you know the player is moving around the mobs moving around whatever the case may be walls might be changing and changing the path so the last thing we want to look at here is what if we allow diagonal movement on our grid right right now we can only choose neighbors for any tile that are in the four directions up down left and right but what if we want to change that well we just need to add to the list of connections here the four diagonal directions right so you can go that way that way you could go that way or you could go that way all right and now when we do find neighbors we're going to get any of the eight directions possible and our search will work just fine this is just going to go through and all those tiles get added to the frontier that's all it cares about but we do need to change right here so that we can see our path and have some diagonal images I'm going to add those as well one negative one and okay now when we run this we're going to see that we can take diagonal paths now you might notice something odd about these diagonal paths if I remove some of these walls you can see it really easily those and let's say we had a straight line right why isn't it taking this path right this path should be shorter than this path although if you count it 1 2 3 4 5 6 7 8 9 10 11 12 13 steps it's the same this way actually let's do it a little bit closer your season so you can see right 1 2 3 4 steps 1 2 3 4 steps right so our search algorithm is seeing this is the same distance as this right and that's because diagonal paths aren't the same distance as horizontal and vertical paths but it but by our search algorithm they are it costs the same amount to step one step this way as it does to step one in this direction and in reality if this distance were one then this distance would be the square root of two which is about one point four and so to fix this we're going to need to talk about having the concept of a movement cost right like you could imagine that not only our diagonal moves a little bit more expensive than horizontal or vertical moves but you could have different types of terrain too right moving through the forest area it's slower than moving through the grass so maybe this path a path around the forest is faster than moving through it and all those kind of things can be implemented in a different version of the algorithm called Dijkstra's algorithm and we're gonna do that in the next video but in the meantime if you want to have some nice straight paths under this scheme all we need to do really is go back over here and remove I was commented out our little reversal of the the list every other time right because the idea of that one is that helps it find the shortest path and that works great when you're only going horizontal again horizontally and vertically but now this isn't helping us so if we comment that out you'll see we get much more much straighter paths right even when things are in a straight line alright so this will be a good enough solution for now but as you can see of course just getting from here to here we're still exploring all of this part of the map all the way around and it's not super efficient yet so in the next video we'll talk about extras algorithm and implementing the movement costs and some other strategies for improving the it's see of the search so we don't spend so much time on unimportant parts of the map all right so that'll do it for this video I will see you in the next part Thanks you