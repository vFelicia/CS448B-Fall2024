in this tutorial we'll explore how inheritance works in the Godot game engine I'm using good of three here but these lessons will also apply if you're using 2.1 still in objectoriented is a really powerful tool you can define a class that inherits from another class which means that it will contain the methods and variables of that class in addition to its own Godot is very strongly object oriented and you can use inheritance when defining classes in scripts as well as with scenes for this tutorial we're gonna assume we're making a classic topdown RPG and we'll use good O's inheritance capabilities to create two different kinds of characters in the game here's a preview of what we're making so we have two kinds of characters here we have NPC characters that you see wandering randomly around and then the green character there is controlled by the player and it's moving when I'm pressing the arrow keys starting with the project settings I've made the width and height I'm going to set those to 640 by 480 we are using 32 by 32 tiles for that tile set so we don't need a really big screen for this and then in the input map I've also set up some input actions and those are called left right up and down and specifically and these are assigned to the arrow keys corresponding arrow keys but specifically they're named that for use in the code later it's going to make things easier if we have these names match the names of the directions that the player can move in and if you download the art from the zip file that I'll link in the comments below it has in it unzip that into your project folder and it's got a couple of tiles for the grass and the stone walls and it has a folder called RPG sprites that has spreadsheet animations for a variety of different little RPG style characters now our goal in this project is to create two different kinds of characters one controlled by the player and one that will be an NPC that we will walk around by itself but both of those characters are gonna share a number of different properties and functions they're each gonna have a sprite sheet using one of these different sprite sheets that are all arranged in the exact same way they have three frames of animation for each of the four directional movements there so they're each going to need an animation player to play those animations the game is going to be based on tile based movement which means that the characters when they move around will move from tile to tile so if they're standing on one tile they'll move exactly 32 pixels in whatever direction to go and stand on the next tile there's no fractional tile movement in this example and then of course they need to not be able to move through walls so they need some sort of collision detection so what we're gonna do is we're gonna create a scene that contains all those common features and all those common properties so we'll start by making a new scene and we're gonna add an area 2d area 2d is going to be the parent because we're going to be moving it via animation I'm not worried about kinematic collisions or things like that obviously you could do it that way too if that were the kind of thing you were going for but this is going to be a character we're going to call this character and save the scene now this is going to need a sprite child it's going to need a collision shape collision shape 2d it's going to need a tween oops it made that a child of the collision shape I'm gonna call this the move tween because this is gonna handle the movement from one tile to the next changing the character's position and then we're going to need an animation player to actually play the animations themselves and change the sprite so we're going to leave that sprite without a texture because each character will have a different texture we're going to leave a blank here but we can go ahead and make the collision shape since all of these are going to the same if you were doing something where your player character had needed a different hitbox than the NPC's then you could leave that blank and set it on the individual objects but we're gonna set it here so I'm gonna add a new rectangle shape and then I'm gonna click on rectangle here and I'm going to set the extents to 10 by 18 which is gonna make a rectangular shape that's gonna be the perfect size for our sprites and let me just lock the children and drag it out on the screen so we can sort of see it in the middle so now the animations are going to be based on these textures if you haven't done sprite animation before using the animation player we're essentially going to be changing the frame of the sprite so on the sprite we need to configure it with the number of frames that it has so there's an animation section here number of vertical frames never number of horizontal frames well we have three horizontal and four vertical so set that to three and that one to four four vertical frames three horizontal frames and then changing this property will step through each one I'll snap one in there real quick just so you can see what it looks like so as I move the frame property you'll see we're going through each of the frames until we get to the twelfth one and we'll go back to zero and so the animation player is going to change those over time to give the walking animation for the direction we want so in the animation player I have created four animations up down left and right again making sure that they match the same spelling I used in the input actions lowercase spelled exactly the same because they're going to use that name the same name in our variables in our script so this is the new animation button so I just clicked that four times and name them each now each one is going to be 0.8 in length that's how long we want the animations to be and you can zoom out a little bit so you can see we're going to have our step in our animation players set to 0.1 so it snaps each one so basically we're going to do a frame of animation every other step and for example when we're on the sprite when we're on frame number zero that's the first frame of the walking up animation so I'm on the up animation and I'm going to click the keyframe next to the frame property when I am on zero and it asked me if I want to create that yes now we move over to number two and we're going to use frame number one then we move over to zero point four and we're going to use frame number two and then we go to number six and we're going to go back to frame number one so we have 0 1 2 1 and if I go back to the start here and hit play let's see we have a little walking and then it gets to the end and we're going to stop and that's because I don't want this to loop because this is going to play one time moving one square so just do that same thing for each of the other three animations and I will jump ahead so I've made the other three animations now they're each set up and we'll go in whatever direction we want it play here you can see there's the walk into the right one and the last thing we need to add here to our character is the collision detection the nodes they're going to detect whether it can move into the next square so if it's standing on a square and we say move right but there's a wall there we want it to not move so we're going to use ray casts for that so if we add a ray cast to D and then duplicate it three more times we're going to name these ray castle left right up and down and by default ray casts are off so make sure you select all them and check it to enabled and we need these to point in the direction they're going so right cast left is going to point to negative 30 to 0 raycast right we'll count will cast a 30 to 0 up and down and so on let's set the sprites texture back to no don't strictly have to do this but you know strictly have to do this but I like to do that to just keep it clean this doesn't have any assigned texture to it so now let's add a script to the character character GD is fine and this script is going to contain all the code to make the character move so we'll start with a few variables tile size is going to be the size of our tile grid we're gonna have a flag called can move that is going to determine whether you're allowed to move or not if you're already moving that will be set to false so that we can't initiate a move in the middle of a move animation facing is going to be what direction we are facing in and then we're going to have what each of the movement what direction either each of the movement goes and also which ray casts match up with them so that's two dictionaries each using the directions as the keys and these are the four directions up down left and right and these are the four written the names of the four ray casts that we made over here now for our move function this is the function that we're going to call whenever a character needs to move and it's we're gonna pass it what direction we want to move in so we'll change our facing direction to whatever that is but if we're gonna check the raycast in that direction so ray casts facing if it's colliding if the Ray cast in the direction we're facing is colliding then we cannot oops I forgot a parenthesis there then we cannot move so we will return otherwise we can move so we'll set can move to false and we will play The Associated animation so we get the animation player and say play that matching animation that's why we kept the animation names the same so if are facing is right we're gonna play animation right so now we need to move and we're gonna use the Move tween for that and we're gonna use it's interpolate property method and that's going to allow us to change the character's position so we want it to act on our self position is the property that we're going to be interpolating let me zoom in here a bit so we could see everything so we're going to change it from its initial property or I started its initial value which is position and then we're going to change it to position plus whatever Direction vector points in that direction times the tile size we want it to last 0.8 seconds right that's the same duration as our animations have and then we're going to use the trans sign tween method and then we're going to use the ease in out tween direction now we want to start the tween and we're gonna return true and the reason we're doing that is so that whenever we call move we're gonna get back up false if we weren't able to move and we're gonna get back a true if we were and we can use that in our code elsewhere to determine whether the move was successful or not and you can see I've been programming in Python lately so I capitalized true and finally to allow movement again we're gonna connect the signal from the move tween between completed signal just connect that adds our function here and what this is gonna do is set can move back to true so that when the move is completed it's allowed to make another move and that's it that completes our character so now we have a character defined that knows how to move around on the grid and that's the stuff that's the same between the player and NPC so now we need to do the stuff that's different so we're going to make a new scene for our player and the new scene for the player is going to be based on this character scene so we're gonna click scene and instead of clicking new scene we're going to do new inherited scene when we do that it asks us to pick what scene so we're gonna inherit from the character scene okay now I have a new scene that's an inherited scene and you can tell that because it has the little clapper here that tells you it's inherited from another scene I'm gonna rename this to player and save it and now we can go and start making our changes to things we want to change for example the sprite I want to change the sprite I'm going to give this bright a texture I'm gonna use the little green archer guy for my player texture and the rest of the stuff is going to stay the same right I already have the raycast pointing in the right direction I have the collegian shape ready to go everything's good there if you had other things to add to your player like additional nodes to represent weapons or things like that you could just add them in here and they would get added on but what we need to do now is add some functionality to the script because we want to listen to the input actions so the script is currently attached to the player is the same one the same character script that we just made but I don't want that so I'm going to clear the script and add a new one and for this new one we're also going to inherit so right here what says inherits area 2d I'm gonna click the little folder and pick character so now this players script is going to inherit from character GD it create and there we go that's what it says up there at the top so now our script includes everything that the character script had in it and then we can add what additional functionality we want all we really want is to check for input actions so I'm going to do that in the process function there's two ways you could do this you could do this in the input function if you want it to only move once when you push the key and then you've got to push the key to move again by doing it in process I'm gonna allow you to hold the arrow key down and it'll continue to move one square at a time in that direction so if we can move so if the can be variable is true then we're going to check the for input actions so I'm just going to do a loop to do that so we get the keys of the moves dictionary are left right up and down so if input is action pressed and we're gonna use the whatever direction because we named the actions up down left right as well then we're going to move in that direction and you can actually go ahead and try it out play the scene and there's my character by pret hold down the right arrow key you see I'm stepping one square at a time if I just tap it I'll move one square and I can move in whatever direction I want to go so hopefully this inheritance concepts starting to make sense to you now but let's go ahead and make one more just to be clear we're gonna make another new inherited scene that inherits from character and I'm going to call this one NPC and so the NPC scene unlike the player scene is going to sort of wander around the screen randomly so we're gonna leave the texture blank we'll add in our script that we're gonna randomize that and we're gonna go ahead and add the script so we'll remove the one that was there and inherit from character for our script and so for our NPC one thing we want to do is pick a random texture so I'm gonna add a I'm just gonna make a list here you can put whatever ones you want in there but here's a list of a few of the textures that are available in the art folder and I want it to pick randomly so that I need to do that in the ready function so let's make sure we randomize and then we're going to pick a texture out of that list so out of that list we want to pick a random index so we pick a random number and we modulo with the with the textures dot length or sorry size talking Python again with length so we pick whatever texture we want and then we can load it and we'll load it from the folder it's in it's in the art RPG sprites actually I can get a bunch of this and then we'll use the string replacement percent s to stick that file name in there and then we tell the sprite to set its texture to that and we'll also set our facing to a random direction and we'll just take the keys of the move and pick a random value out of it now we can do the same thing here now that one option here is we can in process check if we can move and if we can then we'll try moving remember when we try moving it's going to return false if we were unable to so we can just say if not move so if we weren't able to move then we're gonna randomly change direction again so let's just copy and paste this in there and we'll pick another random direction if we weren't able to move and that would be fine except these NPCs are gonna wander in a totally straight line until they hit a wall and then they're gonna turn and what that's gonna do is make them eventually start clumping up on the walls and just walking along the walls so let's also add a little bit of randomness in here so we'll also randomly change direction if we randomly pick a number between 1 and 10 and it's greater than 5 so that way half the time as they're walking they might just randomly turn left or right and that should do it so now if we were to run this one we should see this little sprite wandering around there it is changing direction sometimes but just sort of wandering now the part we can't test right now is the walls so the last thing we need to do is create a little environment for these characters to walk around in so let's add a new scene and I'm going to just use a node call this the main scene and in this we're going to use a tile map so let's add a tile map and set its cell size to 32 by 32 so that it matches and for the tile set you can go and you could make one out of the grass and stone but I've gone ahead and in the art folder saved a tile set that's already made that makes the stone have a clusion shape on it and the grass not so the stone will be the obstacle so we'll just drag that into tile set and then and we zoom out a little bit you should be able to just sort of paint your world let's just actually put walls along the edges I'm holding down shift and dragging to get these straight lines we'll use the bucket fill to fill the inside with grass and then you can put some walls on the inside if you want to have some other kind of obstacles to go around alright and that's a QuickTime app that we can use and then we want to add some characters to it so let's instance a player in there and let's instance a few NPCs NPC and I'll duplicate it a few times now the problem we have is we're gonna drag these guys around and put them in different places but they're not gonna be lined up with the grid so if my character was right here for example you try to move 32 or if he's this far away he would move 32 and then be sort of offset from the wall and it's gonna look weird we want them to be on the grid so to do that go to your snap to grid settings and then configure snap said to the 32 by 32 but also set the offset to 16 by 16 because we want the character to be placed at the center of a tile and then we'll also turn on the little magnet which is enabled snapping so now you see as I move around I'm snapping directly to the center of a tile so I can now put these and know that they'll be starting on a tile and then since I know they move exactly 32 pixels they will always end up on the next tile so let's hit play and see what happens now there we go they are detecting the walls you see them turning away when they hit a wall and so will the player if I walk up here I can't go through the wall if I keep pressing up nothing happens all right now some other things you could do and if you wanted to go for more of a turnbased kind of game is that you have the player you give the player a signal ah look these two sprites have moved at the same time and they've wound up on top of each other but now they're detecting each other as a collision so they can't move so one way to get around that is to go to the NPC and set them to set their collision just take them out of layer one so they won't they just won't see each other and then they won't have that problem but as I was saying you give the player a signal like a moved signal and whenever the player moves you emit that signal and you make the NPC's listen for that signal you connect that signal to them and they only call their move when they they only call their move when they detect that signal right and so so that way they would move when the player moves if you stand here still so today and that's how you would do something more turnbased and you can extend this in lots of ways if you want to start adding if you want to add monsters they could extend from character if you wanted to add pets that follow you around they could extend from character and so on so the the concept is pretty flexible and hopefully gives you some ideas of how you can apply it to your projects especially as your projects start to get bigger and bigger and more complex this becomes really necessary because if you imagine the alternative we hadn't done this inheritance then our scripts would look both players both the character and the NPC would have to have all of this code in it and if we then decided we wanted to change any aspects of how the movement works we would have to go and change it in every single individual script and make sure that they all match up and that becomes really really tedious especially if you have lots and lots of different types of characters so in any time you're finding yourself repeating code and having different objects that share a lot of either properties or nodes if their scenes are very similar or if their scripts are very similar then you probably want to think about using inheritance to do it alright thanks for watching and I'll see you in the next video you