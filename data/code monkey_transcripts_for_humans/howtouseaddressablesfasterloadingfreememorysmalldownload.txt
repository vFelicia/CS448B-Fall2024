With timestamps:

00:00 - hello and welcome I'm your code monkey
00:01 - and here let's learn how to use Unity
00:03 - addressimals this lets you have more
00:05 - control over how your assets are loaded
00:07 - into memory this is pretty crucial if
00:09 - you want to learn how to make larger
00:10 - scale games you can load an entire world
00:12 - kind of like Skyrim all at once and also
00:15 - pretty helpful to keep your download and
00:17 - install size super small and only
00:19 - download and load the assets when you
00:21 - need them also this video is a lecture
00:23 - taken from my ultimate TNT overview
00:24 - course Unity is massive so in the course
00:27 - I explain over 50 features and tools of
00:29 - the engine that you might not know about
00:30 - there's individual lectures explaining
00:32 - tons of things like Shadow graph similar
00:34 - definitions animation Avatar video
00:36 - player and so on as well as many other
00:38 - Niche things that I couldn't possibly
00:40 - cover in normal YouTube videos also the
00:42 - course will continuously be updated with
00:44 - free updates as I add more lectures
00:46 - explaining more tools and features this
00:48 - specific lecture was added as part of
00:50 - the third free update that explains more
00:52 - tones and features so go ahead and get
00:54 - the phone cores to learn how to master
00:55 - all of the unity tools to help you make
00:57 - better games faster in this lecture
00:59 - we're going to to learn all about Unity
01:01 - adjustments this enables you to have
01:03 - more control over your assets instead of
01:05 - everything being loaded automatically it
01:07 - only loads when you ask it to so it
01:09 - helps you manage memory and also
01:10 - unloading times which can be an
01:12 - extremely important thing especially
01:13 - when making mobile games you want your
01:15 - game to load as quickly as possible and
01:17 - then load some assets over time when
01:18 - they are needed instead of forcing the
01:20 - player to set up the loading screen for
01:22 - a long time also very importantly is
01:24 - addressables is internally synchronous
01:26 - so you're never waiting for your assets
01:28 - to load by looking at a frozen screen it
01:30 - loads in the background and notifies you
01:32 - when it's ready and there's also another
01:33 - part to this system which I'm going to
01:35 - cover in the next two lectures which is
01:37 - how you can store Those ads in a server
01:39 - in the cloud and dynamically push them
01:40 - to your players so they can get updated
01:42 - assets without having to push another
01:44 - build you can download those assets from
01:46 - any server like your own server perhaps
01:48 - your own CDN or Unity solution called
01:51 - cloud content delivery but again that's
01:53 - all in the next two lectures so before
01:55 - that let's just learn how it works
01:56 - locally okay so let's start using
01:59 - addressables this is one of the most
02:00 - requested topics on the comments for
02:02 - this course so let's learn about it
02:03 - thankfully it's actually pretty simple
02:05 - and extremely powerful over here I've
02:07 - got a simple empty scene now I have is a
02:11 - simple massive object this one is pretty
02:13 - much an entire living environment so if
02:15 - I drag it it even takes quite a while
02:17 - over here in DNT editor there you go
02:19 - just a massive environment with tons of
02:21 - objects this prefab is intentionally
02:23 - meant to be really complex with lots of
02:25 - objects so we can then see the memory
02:27 - footprint let's first quickly see the
02:29 - main problem that addressables help
02:30 - solve and then we're going to use it to
02:32 - fix it now with this if I just hit on
02:34 - play
02:35 - and if there it is the game is playing
02:36 - and the object is here as you expect but
02:38 - let's say you don't want to spawn the
02:40 - object right away you want to spawn it
02:41 - on a player input so for that let's make
02:44 - a simple script so let's create a new
02:45 - c-sharp script call it spawn object
02:49 - let's make a new game object to run it
02:52 - attach the script and open
02:54 - so now here let's listen to simple input
02:57 - so let's just do product void update and
03:00 - over here let's get a key down let's say
03:03 - the T key
03:05 - so we have this then over here let's
03:07 - instantiate a prefab so let's add our
03:09 - reference here as a serialized field a
03:11 - private transform
03:13 - for our prefab
03:15 - so we have this and then when we press
03:16 - let's just call instantiate on this
03:18 - prefab
03:19 - all right that's it super simple so this
03:22 - is the basic way to instantiate an
03:23 - object let's see here in the editor just
03:26 - write the prefab and let's hit on play
03:28 - okay the game is running There's No
03:29 - Object now I press the button and if
03:31 - there you go it gets instantiated then
03:33 - spawn okay great so again this is the
03:35 - standard way for how you can instantiate
03:37 - any prefab however when you do it like
03:39 - this if you were to load the scene even
03:41 - without actually spawning the object it
03:43 - would still be included in memory
03:44 - basically anything that is referenced in
03:46 - the scene like for example over here we
03:48 - have reference on this object because it
03:50 - is referenced by this object that is
03:52 - going to be loaded when the scene loads
03:54 - whether it is placed on the scene or not
03:55 - we can make a quick build just to test
03:57 - it out
03:58 - so I just going to file and build
04:00 - settings make sure to include this scene
04:02 - and let's make a simple build alright so
04:04 - here I've got the executable now let's
04:06 - click on it to open it and then count
04:08 - how many seconds the loading is actually
04:10 - going to take
04:11 - so let's double click and wait for the
04:13 - win there we go one two three four fives
04:17 - all right there it is so we took about
04:18 - 20 seconds to open so that's the
04:20 - unloading time again it's because it had
04:22 - to load that entire object into memory
04:24 - even though again right now we're
04:26 - looking at the scene and the scene is
04:27 - completely empty and we can look in the
04:29 - test venture to see the memory footprint
04:31 - over here we can see the executable is
04:33 - indeed taking 680 megabytes now if I
04:36 - press the button to spawn it and there
04:38 - you go it does spawn it and as you can
04:39 - see the memory barely moved so this is
04:42 - the problem ideally you don't want that
04:43 - object to be loaded into memory until
04:45 - it's actually needed doing so will
04:47 - massively speed up the unloading time as
04:49 - well as memory usage while the object
04:51 - isn't being used just think of how
04:53 - impossible it would be to make massive
04:54 - games like Skyrim or GTA if you had the
04:57 - entire world loaded at all times it
04:58 - would be pretty much unplayable so now
05:01 - that we've seen the problem let's learn
05:02 - about addressables and how they fix this
05:04 - first thing that we need is the package
05:06 - so let's open up the window open up the
05:08 - package manager and then over here and
05:10 - let's make sure we are on DNT registry
05:12 - and then scroll down and find the
05:13 - address once package there you go just
05:15 - go ahead and install it
05:19 - okay it's installed now to open up the
05:22 - main window let's go up into window and
05:25 - their Asset Management then addressables
05:27 - and let's open up the groups window okay
05:29 - this is the groups and as you can see we
05:31 - need the button because we pretty much
05:32 - need to create the addressable settings
05:33 - so let's click on this button to create
05:35 - it automatically and there you go that
05:37 - creates a bunch of files at the
05:38 - addressable systems uses and over here
05:40 - we can now see the groups and by default
05:42 - it creates a default local group then
05:44 - manually you can right click to create
05:46 - any groups that you want so you can have
05:48 - as many groups as you want each of these
05:50 - separate groups is going to be built
05:52 - into a different asset bundle but we're
05:53 - going to worry about that in a bit so
05:55 - for now let's stick just with the
05:57 - default group okay then once you've got
05:59 - the groups assigned let me just drag it
06:01 - up here so with the groups assigned we
06:03 - can now add some objects onto it and
06:05 - there are multiple ways to do it and the
06:07 - simplest way is really just to drag and
06:09 - drop the object so let's go over here
06:11 - into my project window I've got my
06:13 - environment so let's click and just drag
06:15 - and just drop it inside the local group
06:17 - and there you go it automatically adds
06:19 - the group so I can see over there the
06:20 - environment prefab being added and over
06:22 - here I've got the path to the
06:23 - environment so with this this object is
06:25 - already marked as addressable
06:26 - alternatively you can select the file in
06:29 - the project files and over here in the
06:30 - inspector you also see toggle for
06:32 - addressable and then you also see the
06:34 - underlying path now over here you can
06:36 - write whatever you want you can modify
06:37 - the path if you want
06:39 - but chances are you should really stick
06:41 - with the default path we're going to see
06:43 - what the path means in a bit also don't
06:45 - worry if you're already scared by the
06:47 - fact that the path is a string we're
06:48 - going to see non-string methods for
06:50 - using addressables another option you
06:52 - have is simply to mark an entire folder
06:54 - as addressable so for example if you
06:56 - want to load tons of assets at once you
06:58 - could make the folder itself addressable
06:59 - and load that for example over here I've
07:01 - got a phone there with a bunch of
07:03 - Sprites inside so instead of going
07:04 - individually and individually marking
07:06 - each of them as dressable I can just
07:08 - drag the folder and drop it over here
07:10 - into my group and there you go I've got
07:11 - an entire folder marked as dressable
07:13 - with all of the objects inside okay so
07:15 - now that we have our environment prefab
07:17 - Marta's addressable let's load it
07:19 - through code
07:19 - so first of all before we do that let's
07:21 - actually get rid of the previous script
07:23 - the previous reference make sure we
07:25 - don't need this so this one is not
07:26 - included in the build okay now let's
07:28 - make an easy sharp script so let's
07:30 - create the new C sharp script call it
07:32 - spawn object addressables
07:35 - let's make a game object to run it and
07:38 - let's attach okay
07:40 - now here first thing we need is our
07:41 - namespace and the main response
07:43 - namespace is inside using Unity engine
07:45 - dot addressable assets
07:48 - then let's make some simple input just
07:50 - like we did a while ago so avoid update
07:53 - if input let's get a key down on the T
07:56 - key
07:57 - so that happens let's load the object
07:58 - using addressables and how we do that we
08:01 - access the actual addressables class
08:04 - and over here let's use the function
08:05 - load asset async again the entirety of
08:09 - addressables is asynchronous the
08:10 - non-async methods like for example here
08:12 - and load sync you can see this one is
08:14 - marked as deprecated so you are not
08:16 - supposed to use this you are only
08:17 - supposed to use the async methods just
08:19 - in case you don't know async means
08:21 - asynchronous which also means that it
08:22 - doesn't plug the main game thread so the
08:24 - game never freezes it keeps playing as
08:26 - an S isn't loaded in the background in a
08:28 - separate thread so let's use this
08:30 - function and this one takes a key
08:33 - this is going to be the path to our
08:34 - asset so here in the address models
08:36 - window let's copy this path so let's
08:38 - select it copy the path here and let's
08:41 - use it here this one is a string again
08:43 - don't worry if you're not a fan of
08:44 - strings we're going to see a method that
08:46 - does not require strings in a bit
08:48 - so that's it just using the string
08:50 - that's the only parameter it takes then
08:51 - also this function as you can see is a
08:53 - generic so that means that we're going
08:55 - to return some type and for this one for
08:57 - a prefab let's make it work as a game
08:59 - object
09:00 - all right so we have our function
09:01 - download an asset and we can see what
09:04 - this returns so this returns an async
09:06 - operation handle let's add the using
09:08 - statement
09:13 - so we've got async operations and this
09:16 - one is going to return that so an async
09:19 - operation handle of type game object
09:27 - okay so we have this and then on this
09:30 - operation handle over here we can
09:31 - subscribe to the completed event
09:34 - so let's listen to this event
09:36 - and when this event happens over here
09:38 - we've got the same async operation
09:40 - handle
09:43 - then on this one first of all we can
09:44 - check if the operation is successful so
09:46 - let's check if this one dot let's check
09:49 - the status so if the status is
09:52 - succeeding
09:53 - if so then we have our object and if not
09:55 - then there was some kind of error
09:58 - so fail to unload this object
10:02 - but if it did succeed which it shouldn't
10:04 - if so then over here we can call
10:06 - instantiate let's spawn our prefab so
10:08 - let's go inside the async operation
10:10 - handle and inside to grab the resulting
10:13 - object that was loaded is inside the
10:15 - result this one as you can see takes a
10:17 - game object which is the type that we're
10:18 - using okay so that's it we go into the
10:21 - address bonds we ask it to unload an
10:23 - asset asynchronously we give it the path
10:25 - for the s that we want to load this
10:27 - returns an async operation handle
10:28 - because again this one is asynchronous
10:30 - so this is not completely loading
10:32 - immediately it does not block the game
10:34 - the code continues to run then grabbing
10:36 - on this one we can listen to the
10:37 - completed event so when that eventually
10:39 - finishes loading in the background when
10:41 - that happens this function is called we
10:43 - check if it succeeded and if so then we
10:45 - finally instantiate the game object okay
10:47 - so with this let's test so here we are
10:49 - and there is no object in our scene now
10:51 - I press a button and this time it takes
10:53 - a bit longer but yep the object is
10:55 - dynamically loaded in the background and
10:57 - when it's ready the object is spawned
10:58 - okay great so just with this simple
11:01 - thing we can already compare with the
11:03 - previous demo so let's make a bill to
11:05 - see that let's do the exact same thing
11:07 - just save the scene go into file build
11:09 - settings and let's make a balance just
11:11 - like the same
11:12 - okay so now it's making a build and this
11:14 - time it actually takes a bit longer to
11:16 - make the balance since it's also going
11:17 - to be compiling and compressing the
11:19 - asset bundle
11:23 - okay so the build is done now once again
11:26 - let's pay attention to the unloading
11:27 - time so let's double click
11:29 - and wait for the window
11:31 - and okay one two and there you go in
11:35 - just two seconds instead of 20. so as
11:37 - you can see much much faster the reason
11:39 - for that is of course because it's not
11:40 - automatically unloading that object at
11:42 - runtime immediately when the build
11:43 - launches and we can verify that by
11:45 - looking in the task manager same here we
11:48 - do see we are currently only using up
11:50 - 137 megabytes so nothing close to the
11:53 - 600 or 800 from before and now if I
11:56 - press the button now the object is being
11:58 - loaded you can see over there it's
12:00 - currently reading and writing to disk so
12:02 - it's loading everything currently into
12:04 - memory and after a bit yep here is our
12:06 - object spawn and the memory did go up so
12:09 - just with this simple demo we can
12:10 - already see the massive difference that
12:12 - it makes our game loaded much much
12:14 - faster and memory usage State and low
12:16 - since the object was only loaded when we
12:18 - actually needed it okay now let's keep
12:20 - learning some more about addressables
12:22 - like I said this is just one method to
12:24 - load you can write a path string and
12:26 - load it also we can simplify this like
12:29 - with any comeback so instead of having
12:31 - to define a separate function and
12:33 - storing our async operation handle let's
12:35 - just call this and then immediately when
12:38 - we call let's subscribe to the completed
12:40 - event
12:41 - instead of using a separate function
12:42 - let's use the unlimited function so
12:44 - let's define an async operation handle
12:47 - and do Al Lambda function
12:50 - and then inside we're going to do the
12:52 - same thing that we're doing here
12:56 - all right so there it is we're still
12:58 - doing exactly the same thing but
12:59 - everything is much more compact this can
13:01 - be useful because it does not require a
13:03 - separate function definition so like I
13:05 - said this method is using a string for
13:07 - the path as a general rule you should
13:09 - always avoid using strings as much as
13:11 - possible strings are super brittle it's
13:13 - really easy to make a mistake with any
13:15 - of it for example if you just miss one
13:17 - letter or just capitalize so the I put
13:19 - it to capitalized if I do this and we
13:22 - test if there we go we have an error
13:24 - because again the string path this one
13:26 - is case sensitive so as you can see
13:28 - strings are very brittle very easy to
13:30 - make mistakes so let's avoid using
13:32 - strings and the best way to do that is
13:34 - using something called an asset
13:35 - reference let's make it a serialized
13:37 - film so we can set it in the editor of
13:39 - type asset reference
13:42 - acid reference
13:44 - let's in the editor what this looks like
13:47 - so there it is we've got our reference
13:49 - and now if we want we can drag it
13:51 - straight from the addressable groups so
13:53 - if I drag the environment drag it on top
13:55 - of there if there you go it does work I
13:57 - can also drag the prefab from the
13:59 - project window or alternatively I can
14:01 - click on the little search button and
14:03 - over here select any of the adjustments
14:04 - included also if you drag a different
14:07 - asset that is not included in the group
14:09 - so right now these are the only ones in
14:10 - group and over here I've got another
14:11 - environment small if I drag this one on
14:14 - there you can see yep it does drag it on
14:16 - there and automatically adds it to the
14:18 - group okay so we have our asset
14:20 - reference now over here we can load this
14:22 - asset reference directly so we just go
14:24 - to this one and inside this one let's
14:26 - call load asset async and again let's do
14:29 - the same thing give it the type so the
14:31 - game object type and we're going to load
14:33 - it and this one takes no parameters and
14:35 - everything else is pretty much exactly
14:36 - the same so let's actually get rid of
14:38 - this and yep everything else is exactly
14:39 - the same so this function still returns
14:42 - an async operation handle everything
14:44 - still works the same except now we don't
14:45 - have strings so it says this is the C so
14:48 - here we are with nothing press the
14:50 - button and if there go it does spawn the
14:52 - object okay so that's the asset
14:54 - reference method another way to load an
14:57 - asset is with a label over here in the
14:59 - addressable groups we can see over here
15:00 - we've got a part for the labels and if
15:03 - we click on each of these drop down
15:05 - minis we can see all of our labels and
15:07 - of course we can add some more so let's
15:09 - click on the little gear icon and over
15:11 - here we've got a list of all of our
15:12 - labels let's create one let's call it
15:14 - environment then we can close this one
15:17 - over here for the environment small
15:19 - let's put it on that one also when it
15:21 - comes to labels you can have multiple
15:22 - objects so if I want this one can also
15:24 - be on there and you can also assign
15:26 - multiple labels so if I click on this
15:27 - yep you can select multiple all right so
15:30 - this object now has in label and for
15:32 - unloading we can use the same method as
15:34 - previously using the key the key can be
15:36 - a path or it can be a label that would
15:37 - work just the same or again if we want
15:40 - to avoid strings we can use a different
15:42 - thing this one is an asset label
15:44 - reference
15:47 - we can use this here in the editor it
15:50 - has a nice drop down menu so let's
15:51 - select the environmental label then here
15:53 - in the code how we want it is by using
15:55 - the previous method so addressables load
15:57 - asset async up type game object and for
16:00 - the key let's pass in just the asset
16:02 - label reference so just this one that's
16:04 - the exact same thing going to the
16:06 - completed and so on so let's see this so
16:09 - here we are and I press the button and
16:11 - if there you go it doesn't load okay so
16:13 - everything is working correctly now with
16:15 - this asset reference you can reference
16:16 - anything so for example over here on the
16:19 - asset reference file you can see that
16:20 - I've got some Sprites that I drag in
16:22 - there so if I go I can select one of
16:23 - these however over here in the code for
16:26 - this asset reference let's go back into
16:28 - the previous method
16:32 - over here we are unloading this asset
16:34 - reference as a game object but here in
16:37 - the editor we drag the Sprite reference
16:39 - if we try running this code and I press
16:42 - a button and there you go got an error
16:44 - we can see the error is because the
16:46 - asset exists as a texture 2D which is
16:48 - not assignable to the requested game
16:50 - object type so this is the error the
16:52 - code is expecting a game object but over
16:53 - here I dragged a different reference
16:55 - because I can drag any reference onto
16:57 - this field
16:57 - there's another example over here I've
16:59 - also got some audio files so I can also
17:01 - drag it on there and there you go that
17:02 - one goes in there and again this one
17:04 - would also cause an error so asset
17:07 - reference can be quite error prone and
17:09 - to some of that there are some helpful
17:10 - reference types that for some
17:11 - limitations on the type of the objects
17:14 - for example we have asset reference game
17:17 - object
17:19 - this one like the name implies only
17:20 - receives game objects then we've got two
17:23 - more so asset reference we've got a
17:25 - textured 2D as you can see we have a
17:28 - Sprite that was right and so on so there
17:30 - are multiple of these to enforce a
17:32 - specific type we can see this in the
17:34 - editor so we have this game object let's
17:36 - put this one there let's see it
17:38 - so here we have the asset reference game
17:40 - object and if I try to drag the coin
17:42 - reference nope I can't do that try to
17:44 - drag the audio clip nope does not work
17:46 - it only works if I drag an actual game
17:48 - object so this would help prevent that
17:50 - error in the code however as you can see
17:52 - there aren't on types so for example
17:54 - there isn't any type for an audio clip
17:56 - but if you need that then you can
17:58 - actually create it yourself if we
18:00 - inspect the code for this we can see
18:02 - that this is pretty much just a class
18:03 - that extends asset reference T and then
18:05 - has a type and just has a Constructor
18:07 - with the go ID so you can pretty much
18:09 - just do this for any type we want so for
18:12 - example let's go up here let's make a
18:13 - public class let's call it asset
18:16 - reference audio clip
18:18 - let's extend acid reference T and then
18:21 - inside prototype so in this case audio
18:23 - clip
18:26 - so you have this and we just need to
18:28 - implement the Constructor
18:30 - so let's use the helpful Visual Studio
18:31 - to create it automatically so here it is
18:33 - we don't need any Behavior anything at
18:35 - all so that's it this works now
18:37 - obviously in order for this to show up
18:39 - in the editor we need to mark this as
18:40 - synonym so system Dot serializable
18:44 - okay and now here we can now use that
18:45 - one so we can use an asset reference
18:48 - audio clip
18:52 - okay let's see this in the editor
18:54 - there's the asset reference audio clip
18:56 - and clicking on the button yep the only
18:57 - thing I can select is indeed an audio
18:59 - clip then for unloading any of the
19:01 - separate types it works exactly the same
19:03 - as previously also one more thing is you
19:05 - can immediately instantiate a reference
19:07 - directly so for example when working
19:09 - with game objects I can be a bit faster
19:10 - than doing all of this
19:12 - so we can go into that asset reference
19:14 - and call instantiate async we can
19:18 - optionally give it a parent essentially
19:19 - in World space give it a position
19:20 - quaternion and so on or if not let's
19:23 - just do this and now this one also
19:25 - returns an async operation
19:28 - so if you want to know when this
19:29 - actually completes you could subscribe
19:31 - to this or just don't do that and just
19:34 - call instantiate a sink
19:35 - so let's comment out of this so we only
19:37 - run this code
19:39 - and if we test this
19:41 - so here we are and press the button and
19:44 - if there you go the object is spawned
19:45 - automatically so if you want this one
19:47 - then this is much more compact than this
19:49 - now like I mentioned you can make an
19:51 - entire folder as addressable so let's
19:53 - see how to load multiple assets at once
19:55 - here in the addressables group I already
19:57 - made my special Sprites folder which
19:59 - inside has a bunch of Sprites this one
20:00 - is now unaddressable then here in the
20:03 - code let's load the entire folder so
20:06 - let's go into addressables and then
20:08 - inside instead of going into load as
20:11 - they sync let's go into load assets
20:13 - async portal
20:15 - let's load a bunch of Sprites then it
20:18 - takes a key so this is the path pretty
20:19 - much like we already saw this one can
20:22 - also take a list of keys so we can give
20:24 - it a list of string then here we can
20:26 - type one path then another path and so
20:29 - on and it will load all of the objects
20:31 - or alternatively we can also load the
20:34 - entire folder at once however this is
20:36 - actually a bit tricky it took me a quite
20:38 - a while to figure this out
20:39 - if you just type in the string for the
20:41 - folder so here in the group if I'm
20:43 - looking there this is the path so let's
20:45 - copy this so over here if I paste that
20:47 - path if you use this method
20:50 - then amp here we can see we get an error
20:52 - alternatively on the acid reference
20:54 - field you can drag the folder and drag
20:57 - it straight in there then over here try
20:58 - to use the asset reference and there
21:00 - however if we try this and now this one
21:03 - also gives the same error so basically
21:06 - we cannot load the folder directly the
21:08 - folders that we see over here inside the
21:10 - address models group this one is really
21:12 - just meant for organization meant for
21:13 - organizing all the objects inside it but
21:16 - you cannot reference the founder
21:17 - directly so the only two options on
21:19 - loading all of these objects would be to
21:21 - either manually drag the reference for
21:22 - each individual object but that kind of
21:24 - defeats the purpose of having a folder
21:26 - with multiple objects so another better
21:28 - approach is to Simply making a label so
21:31 - let's click here and let's go manage our
21:33 - labels let's make a new one special
21:35 - Sprites okay we've got a label so now
21:37 - let's assign it over here and yep as you
21:39 - can see all of the objects inside the
21:41 - folder all of them get the exact same
21:43 - label and now in order to avoid using
21:45 - strings we can go into our object and on
21:47 - the acid level reference let's use that
21:49 - label then over here let's use the
21:51 - ascent level reference like that with
21:53 - this now it will indeed load everything
21:54 - in that folder and then the function
21:56 - over here as you can see has a second
21:58 - parameter this is an action that is
22:00 - going to run on every asset so let's
22:02 - grab the Sprite that is going to run and
22:04 - let's just do unlock on it so debug.log
22:07 - on the Sprite
22:08 - okay so let's test and see if we see
22:10 - unlock for every single object inside
22:12 - that folder so here if I press T and if
22:15 - there go all of the objects so download
22:17 - Gamepad coin which are exactly of the
22:19 - Sprites that I added to this folder also
22:22 - one more thing on folders if you make a
22:24 - Founder addressable and then you drag
22:26 - another object inside that folder so for
22:28 - example if I duplicate an object here so
22:30 - I did not specifically make this object
22:32 - addressable but since it's inside an
22:34 - addressables folder then automatically
22:36 - becomes addressable however there's
22:38 - actually a small bug over here on the
22:40 - addressable groups window as you can see
22:43 - I add that one so I've got dollar and
22:44 - dollar one I've got those two objects
22:47 - but over here I can only find dollar it
22:48 - does not show the other one however
22:50 - again this is just a visual bug
22:52 - if I close the adjustments group window
22:54 - and I open it up again so let's go into
22:56 - window Asset Management Open up the
22:58 - groups and I expand it and yep there you
23:01 - go over here I do see the two dollars so
23:04 - whenever you add objects so for example
23:05 - if I take it out then it's no longer in
23:07 - there but over here it still is so this
23:09 - is just a visual bug anything you put
23:11 - inside this folder will always be
23:13 - included so if I run the build
23:15 - and I'll press the key and over here yep
23:17 - we do see all four Sprites and of course
23:20 - since you can load objects at runtime
23:22 - you can also unload them for that you
23:24 - can use
23:25 - addressables.one lease you can use this
23:27 - one and pass in the async operation
23:29 - handle alternatively you can go into
23:31 - address bones and use release instance
23:34 - this one is useful if you previously
23:36 - used instantiator sync so for example
23:38 - let's test this so let's grab this one
23:41 - so we can't instantiate a sink now we
23:43 - need to keep track of the instantiated
23:44 - object
23:45 - so a private game object for the spawn
23:48 - game object
23:50 - then over here we can't essentially the
23:52 - sync let's listen to the complete event
23:54 - so when this happens we've got over here
23:57 - the spawn game object
23:59 - so let's simply set the spawn to this
24:01 - game object although actually this one
24:03 - does not have a game object that has an
24:05 - async operation and then inside it we
24:08 - get the result and that is what actually
24:10 - contains the game object Okay so we've
24:12 - got the spawn game object reference
24:14 - let's make another input so if input get
24:17 - key down
24:19 - and on this one now let's use the same
24:21 - reference and call release instance and
24:23 - pass in the spawn game object
24:25 - alright so that's it let's just comment
24:28 - this out
24:30 - so let's make a build and look at the
24:31 - memory and see what this does
24:37 - okay so here's the build again since I'm
24:40 - using addressables the member footprint
24:42 - is real low so only 136 now I press the
24:45 - button to download the assets
24:47 - and there you go it starts loading them
24:49 - up and you appear this so the memory
24:50 - went all the way up to 616. now I press
24:53 - the button to unload it and yep there
24:55 - you go the object is destroyed and over
24:57 - there the memory comes back down also
24:59 - another thing is the assets are
25:00 - automatically unloaded from memory when
25:02 - you do a simple scene change
25:04 - so if you were to add Unity engine dot
25:08 - scene management
25:09 - and then up here on a scene
25:12 - if you would do scene manager.load scene
25:14 - if you would load a different scene then
25:17 - yep it would automatically destroy the
25:19 - objects in release the memory although
25:21 - do keep in mind this only works
25:22 - automatically if you use sync on scene
25:24 - mode if you're using additive scene
25:26 - loading then they stay unloaded since
25:27 - Unity does not know which assets you no
25:29 - longer need now there are some more
25:31 - things related to addressables if you
25:33 - want to dive deeper for example as we
25:35 - saw you've got a bunch of profiles so
25:37 - you can click here to go into manage
25:39 - profiles or alternatively go into window
25:41 - Asset Management addressables let's load
25:43 - up the profiles now these are used for
25:45 - easily setting up for example a profile
25:47 - for testing another one for production
25:49 - and so on as you can see each profile
25:51 - defines where exactly is in local and
25:53 - the remote paths I cover how to handle
25:55 - the remote paths in the next lecture
25:57 - then another helpful window is once
26:00 - again go into Asset Management over here
26:01 - we've got these settings then here you
26:03 - have tons and tons of options another
26:06 - one you have is also the useful events
26:08 - so if you see here the Event Viewer this
26:10 - one as you can see has a warning so you
26:12 - need to enable over here on the settings
26:14 - and profiler events so this one needs to
26:15 - be enabled and now if we try running the
26:18 - game like this this one kind of acts
26:20 - like a profiler so if I go and I'll look
26:23 - in the console and I press a button and
26:24 - there you go it does start loading the
26:26 - things and after a while yep it
26:28 - instantiates the object so you can stop
26:30 - at any point and see exactly what it did
26:31 - then over here you also have the analyze
26:34 - window this one lets you pretty much see
26:36 - dependencies it analyzes all of the
26:39 - rules that you define and finds of the
26:41 - dependencies within your asset bundles
26:43 - and finally there's the hosting window
26:45 - this one is for more complex use case
26:47 - where you want to connect to an external
26:48 - host and let you upload builds and
26:50 - content okay so all of that is the
26:53 - basics of addressables a really useful
26:55 - way to have more control over your
26:56 - memory and then Implement load your
26:58 - objects this one helps cut down on
27:00 - loading times in general memory usage
27:02 - you pretty much only load the assets
27:04 - when you need them and of course this
27:06 - lecture is just the basics the next step
27:08 - is to load updated assets from the cloud
27:09 - without having to make a new bone so
27:12 - we're going to learn how to do that in
27:13 - the next lecture and then in the in
27:15 - lecture after that one we're going to
27:16 - learn how to use unity's cloudcon
27:18 - delivery as the CDN for all of our
27:20 - assets so if you're interested in
27:22 - addressables definitely keep watching
27:24 - the next young lectures alright so this
27:26 - was a lecture from my ultimate Indie
27:28 - overview course there's lots more
27:30 - explaining tons of things like Shadow
27:31 - graph similar definitions animation
27:33 - Avatar the video player and so on as
27:35 - well as many Niche things that I
27:36 - couldn't possibly cover in normal
27:38 - YouTube videos go ahead and get the full
27:40 - course and learn how to master all of
27:42 - the unity tools and features to help you
27:43 - make better games faster

Cleaned transcript:

hello and welcome I'm your code monkey and here let's learn how to use Unity addressimals this lets you have more control over how your assets are loaded into memory this is pretty crucial if you want to learn how to make larger scale games you can load an entire world kind of like Skyrim all at once and also pretty helpful to keep your download and install size super small and only download and load the assets when you need them also this video is a lecture taken from my ultimate TNT overview course Unity is massive so in the course I explain over 50 features and tools of the engine that you might not know about there's individual lectures explaining tons of things like Shadow graph similar definitions animation Avatar video player and so on as well as many other Niche things that I couldn't possibly cover in normal YouTube videos also the course will continuously be updated with free updates as I add more lectures explaining more tools and features this specific lecture was added as part of the third free update that explains more tones and features so go ahead and get the phone cores to learn how to master all of the unity tools to help you make better games faster in this lecture we're going to to learn all about Unity adjustments this enables you to have more control over your assets instead of everything being loaded automatically it only loads when you ask it to so it helps you manage memory and also unloading times which can be an extremely important thing especially when making mobile games you want your game to load as quickly as possible and then load some assets over time when they are needed instead of forcing the player to set up the loading screen for a long time also very importantly is addressables is internally synchronous so you're never waiting for your assets to load by looking at a frozen screen it loads in the background and notifies you when it's ready and there's also another part to this system which I'm going to cover in the next two lectures which is how you can store Those ads in a server in the cloud and dynamically push them to your players so they can get updated assets without having to push another build you can download those assets from any server like your own server perhaps your own CDN or Unity solution called cloud content delivery but again that's all in the next two lectures so before that let's just learn how it works locally okay so let's start using addressables this is one of the most requested topics on the comments for this course so let's learn about it thankfully it's actually pretty simple and extremely powerful over here I've got a simple empty scene now I have is a simple massive object this one is pretty much an entire living environment so if I drag it it even takes quite a while over here in DNT editor there you go just a massive environment with tons of objects this prefab is intentionally meant to be really complex with lots of objects so we can then see the memory footprint let's first quickly see the main problem that addressables help solve and then we're going to use it to fix it now with this if I just hit on play and if there it is the game is playing and the object is here as you expect but let's say you don't want to spawn the object right away you want to spawn it on a player input so for that let's make a simple script so let's create a new csharp script call it spawn object let's make a new game object to run it attach the script and open so now here let's listen to simple input so let's just do product void update and over here let's get a key down let's say the T key so we have this then over here let's instantiate a prefab so let's add our reference here as a serialized field a private transform for our prefab so we have this and then when we press let's just call instantiate on this prefab all right that's it super simple so this is the basic way to instantiate an object let's see here in the editor just write the prefab and let's hit on play okay the game is running There's No Object now I press the button and if there you go it gets instantiated then spawn okay great so again this is the standard way for how you can instantiate any prefab however when you do it like this if you were to load the scene even without actually spawning the object it would still be included in memory basically anything that is referenced in the scene like for example over here we have reference on this object because it is referenced by this object that is going to be loaded when the scene loads whether it is placed on the scene or not we can make a quick build just to test it out so I just going to file and build settings make sure to include this scene and let's make a simple build alright so here I've got the executable now let's click on it to open it and then count how many seconds the loading is actually going to take so let's double click and wait for the win there we go one two three four fives all right there it is so we took about 20 seconds to open so that's the unloading time again it's because it had to load that entire object into memory even though again right now we're looking at the scene and the scene is completely empty and we can look in the test venture to see the memory footprint over here we can see the executable is indeed taking 680 megabytes now if I press the button to spawn it and there you go it does spawn it and as you can see the memory barely moved so this is the problem ideally you don't want that object to be loaded into memory until it's actually needed doing so will massively speed up the unloading time as well as memory usage while the object isn't being used just think of how impossible it would be to make massive games like Skyrim or GTA if you had the entire world loaded at all times it would be pretty much unplayable so now that we've seen the problem let's learn about addressables and how they fix this first thing that we need is the package so let's open up the window open up the package manager and then over here and let's make sure we are on DNT registry and then scroll down and find the address once package there you go just go ahead and install it okay it's installed now to open up the main window let's go up into window and their Asset Management then addressables and let's open up the groups window okay this is the groups and as you can see we need the button because we pretty much need to create the addressable settings so let's click on this button to create it automatically and there you go that creates a bunch of files at the addressable systems uses and over here we can now see the groups and by default it creates a default local group then manually you can right click to create any groups that you want so you can have as many groups as you want each of these separate groups is going to be built into a different asset bundle but we're going to worry about that in a bit so for now let's stick just with the default group okay then once you've got the groups assigned let me just drag it up here so with the groups assigned we can now add some objects onto it and there are multiple ways to do it and the simplest way is really just to drag and drop the object so let's go over here into my project window I've got my environment so let's click and just drag and just drop it inside the local group and there you go it automatically adds the group so I can see over there the environment prefab being added and over here I've got the path to the environment so with this this object is already marked as addressable alternatively you can select the file in the project files and over here in the inspector you also see toggle for addressable and then you also see the underlying path now over here you can write whatever you want you can modify the path if you want but chances are you should really stick with the default path we're going to see what the path means in a bit also don't worry if you're already scared by the fact that the path is a string we're going to see nonstring methods for using addressables another option you have is simply to mark an entire folder as addressable so for example if you want to load tons of assets at once you could make the folder itself addressable and load that for example over here I've got a phone there with a bunch of Sprites inside so instead of going individually and individually marking each of them as dressable I can just drag the folder and drop it over here into my group and there you go I've got an entire folder marked as dressable with all of the objects inside okay so now that we have our environment prefab Marta's addressable let's load it through code so first of all before we do that let's actually get rid of the previous script the previous reference make sure we don't need this so this one is not included in the build okay now let's make an easy sharp script so let's create the new C sharp script call it spawn object addressables let's make a game object to run it and let's attach okay now here first thing we need is our namespace and the main response namespace is inside using Unity engine dot addressable assets then let's make some simple input just like we did a while ago so avoid update if input let's get a key down on the T key so that happens let's load the object using addressables and how we do that we access the actual addressables class and over here let's use the function load asset async again the entirety of addressables is asynchronous the nonasync methods like for example here and load sync you can see this one is marked as deprecated so you are not supposed to use this you are only supposed to use the async methods just in case you don't know async means asynchronous which also means that it doesn't plug the main game thread so the game never freezes it keeps playing as an S isn't loaded in the background in a separate thread so let's use this function and this one takes a key this is going to be the path to our asset so here in the address models window let's copy this path so let's select it copy the path here and let's use it here this one is a string again don't worry if you're not a fan of strings we're going to see a method that does not require strings in a bit so that's it just using the string that's the only parameter it takes then also this function as you can see is a generic so that means that we're going to return some type and for this one for a prefab let's make it work as a game object all right so we have our function download an asset and we can see what this returns so this returns an async operation handle let's add the using statement so we've got async operations and this one is going to return that so an async operation handle of type game object okay so we have this and then on this operation handle over here we can subscribe to the completed event so let's listen to this event and when this event happens over here we've got the same async operation handle then on this one first of all we can check if the operation is successful so let's check if this one dot let's check the status so if the status is succeeding if so then we have our object and if not then there was some kind of error so fail to unload this object but if it did succeed which it shouldn't if so then over here we can call instantiate let's spawn our prefab so let's go inside the async operation handle and inside to grab the resulting object that was loaded is inside the result this one as you can see takes a game object which is the type that we're using okay so that's it we go into the address bonds we ask it to unload an asset asynchronously we give it the path for the s that we want to load this returns an async operation handle because again this one is asynchronous so this is not completely loading immediately it does not block the game the code continues to run then grabbing on this one we can listen to the completed event so when that eventually finishes loading in the background when that happens this function is called we check if it succeeded and if so then we finally instantiate the game object okay so with this let's test so here we are and there is no object in our scene now I press a button and this time it takes a bit longer but yep the object is dynamically loaded in the background and when it's ready the object is spawned okay great so just with this simple thing we can already compare with the previous demo so let's make a bill to see that let's do the exact same thing just save the scene go into file build settings and let's make a balance just like the same okay so now it's making a build and this time it actually takes a bit longer to make the balance since it's also going to be compiling and compressing the asset bundle okay so the build is done now once again let's pay attention to the unloading time so let's double click and wait for the window and okay one two and there you go in just two seconds instead of 20. so as you can see much much faster the reason for that is of course because it's not automatically unloading that object at runtime immediately when the build launches and we can verify that by looking in the task manager same here we do see we are currently only using up 137 megabytes so nothing close to the 600 or 800 from before and now if I press the button now the object is being loaded you can see over there it's currently reading and writing to disk so it's loading everything currently into memory and after a bit yep here is our object spawn and the memory did go up so just with this simple demo we can already see the massive difference that it makes our game loaded much much faster and memory usage State and low since the object was only loaded when we actually needed it okay now let's keep learning some more about addressables like I said this is just one method to load you can write a path string and load it also we can simplify this like with any comeback so instead of having to define a separate function and storing our async operation handle let's just call this and then immediately when we call let's subscribe to the completed event instead of using a separate function let's use the unlimited function so let's define an async operation handle and do Al Lambda function and then inside we're going to do the same thing that we're doing here all right so there it is we're still doing exactly the same thing but everything is much more compact this can be useful because it does not require a separate function definition so like I said this method is using a string for the path as a general rule you should always avoid using strings as much as possible strings are super brittle it's really easy to make a mistake with any of it for example if you just miss one letter or just capitalize so the I put it to capitalized if I do this and we test if there we go we have an error because again the string path this one is case sensitive so as you can see strings are very brittle very easy to make mistakes so let's avoid using strings and the best way to do that is using something called an asset reference let's make it a serialized film so we can set it in the editor of type asset reference acid reference let's in the editor what this looks like so there it is we've got our reference and now if we want we can drag it straight from the addressable groups so if I drag the environment drag it on top of there if there you go it does work I can also drag the prefab from the project window or alternatively I can click on the little search button and over here select any of the adjustments included also if you drag a different asset that is not included in the group so right now these are the only ones in group and over here I've got another environment small if I drag this one on there you can see yep it does drag it on there and automatically adds it to the group okay so we have our asset reference now over here we can load this asset reference directly so we just go to this one and inside this one let's call load asset async and again let's do the same thing give it the type so the game object type and we're going to load it and this one takes no parameters and everything else is pretty much exactly the same so let's actually get rid of this and yep everything else is exactly the same so this function still returns an async operation handle everything still works the same except now we don't have strings so it says this is the C so here we are with nothing press the button and if there go it does spawn the object okay so that's the asset reference method another way to load an asset is with a label over here in the addressable groups we can see over here we've got a part for the labels and if we click on each of these drop down minis we can see all of our labels and of course we can add some more so let's click on the little gear icon and over here we've got a list of all of our labels let's create one let's call it environment then we can close this one over here for the environment small let's put it on that one also when it comes to labels you can have multiple objects so if I want this one can also be on there and you can also assign multiple labels so if I click on this yep you can select multiple all right so this object now has in label and for unloading we can use the same method as previously using the key the key can be a path or it can be a label that would work just the same or again if we want to avoid strings we can use a different thing this one is an asset label reference we can use this here in the editor it has a nice drop down menu so let's select the environmental label then here in the code how we want it is by using the previous method so addressables load asset async up type game object and for the key let's pass in just the asset label reference so just this one that's the exact same thing going to the completed and so on so let's see this so here we are and I press the button and if there you go it doesn't load okay so everything is working correctly now with this asset reference you can reference anything so for example over here on the asset reference file you can see that I've got some Sprites that I drag in there so if I go I can select one of these however over here in the code for this asset reference let's go back into the previous method over here we are unloading this asset reference as a game object but here in the editor we drag the Sprite reference if we try running this code and I press a button and there you go got an error we can see the error is because the asset exists as a texture 2D which is not assignable to the requested game object type so this is the error the code is expecting a game object but over here I dragged a different reference because I can drag any reference onto this field there's another example over here I've also got some audio files so I can also drag it on there and there you go that one goes in there and again this one would also cause an error so asset reference can be quite error prone and to some of that there are some helpful reference types that for some limitations on the type of the objects for example we have asset reference game object this one like the name implies only receives game objects then we've got two more so asset reference we've got a textured 2D as you can see we have a Sprite that was right and so on so there are multiple of these to enforce a specific type we can see this in the editor so we have this game object let's put this one there let's see it so here we have the asset reference game object and if I try to drag the coin reference nope I can't do that try to drag the audio clip nope does not work it only works if I drag an actual game object so this would help prevent that error in the code however as you can see there aren't on types so for example there isn't any type for an audio clip but if you need that then you can actually create it yourself if we inspect the code for this we can see that this is pretty much just a class that extends asset reference T and then has a type and just has a Constructor with the go ID so you can pretty much just do this for any type we want so for example let's go up here let's make a public class let's call it asset reference audio clip let's extend acid reference T and then inside prototype so in this case audio clip so you have this and we just need to implement the Constructor so let's use the helpful Visual Studio to create it automatically so here it is we don't need any Behavior anything at all so that's it this works now obviously in order for this to show up in the editor we need to mark this as synonym so system Dot serializable okay and now here we can now use that one so we can use an asset reference audio clip okay let's see this in the editor there's the asset reference audio clip and clicking on the button yep the only thing I can select is indeed an audio clip then for unloading any of the separate types it works exactly the same as previously also one more thing is you can immediately instantiate a reference directly so for example when working with game objects I can be a bit faster than doing all of this so we can go into that asset reference and call instantiate async we can optionally give it a parent essentially in World space give it a position quaternion and so on or if not let's just do this and now this one also returns an async operation so if you want to know when this actually completes you could subscribe to this or just don't do that and just call instantiate a sink so let's comment out of this so we only run this code and if we test this so here we are and press the button and if there you go the object is spawned automatically so if you want this one then this is much more compact than this now like I mentioned you can make an entire folder as addressable so let's see how to load multiple assets at once here in the addressables group I already made my special Sprites folder which inside has a bunch of Sprites this one is now unaddressable then here in the code let's load the entire folder so let's go into addressables and then inside instead of going into load as they sync let's go into load assets async portal let's load a bunch of Sprites then it takes a key so this is the path pretty much like we already saw this one can also take a list of keys so we can give it a list of string then here we can type one path then another path and so on and it will load all of the objects or alternatively we can also load the entire folder at once however this is actually a bit tricky it took me a quite a while to figure this out if you just type in the string for the folder so here in the group if I'm looking there this is the path so let's copy this so over here if I paste that path if you use this method then amp here we can see we get an error alternatively on the acid reference field you can drag the folder and drag it straight in there then over here try to use the asset reference and there however if we try this and now this one also gives the same error so basically we cannot load the folder directly the folders that we see over here inside the address models group this one is really just meant for organization meant for organizing all the objects inside it but you cannot reference the founder directly so the only two options on loading all of these objects would be to either manually drag the reference for each individual object but that kind of defeats the purpose of having a folder with multiple objects so another better approach is to Simply making a label so let's click here and let's go manage our labels let's make a new one special Sprites okay we've got a label so now let's assign it over here and yep as you can see all of the objects inside the folder all of them get the exact same label and now in order to avoid using strings we can go into our object and on the acid level reference let's use that label then over here let's use the ascent level reference like that with this now it will indeed load everything in that folder and then the function over here as you can see has a second parameter this is an action that is going to run on every asset so let's grab the Sprite that is going to run and let's just do unlock on it so debug.log on the Sprite okay so let's test and see if we see unlock for every single object inside that folder so here if I press T and if there go all of the objects so download Gamepad coin which are exactly of the Sprites that I added to this folder also one more thing on folders if you make a Founder addressable and then you drag another object inside that folder so for example if I duplicate an object here so I did not specifically make this object addressable but since it's inside an addressables folder then automatically becomes addressable however there's actually a small bug over here on the addressable groups window as you can see I add that one so I've got dollar and dollar one I've got those two objects but over here I can only find dollar it does not show the other one however again this is just a visual bug if I close the adjustments group window and I open it up again so let's go into window Asset Management Open up the groups and I expand it and yep there you go over here I do see the two dollars so whenever you add objects so for example if I take it out then it's no longer in there but over here it still is so this is just a visual bug anything you put inside this folder will always be included so if I run the build and I'll press the key and over here yep we do see all four Sprites and of course since you can load objects at runtime you can also unload them for that you can use addressables.one lease you can use this one and pass in the async operation handle alternatively you can go into address bones and use release instance this one is useful if you previously used instantiator sync so for example let's test this so let's grab this one so we can't instantiate a sink now we need to keep track of the instantiated object so a private game object for the spawn game object then over here we can't essentially the sync let's listen to the complete event so when this happens we've got over here the spawn game object so let's simply set the spawn to this game object although actually this one does not have a game object that has an async operation and then inside it we get the result and that is what actually contains the game object Okay so we've got the spawn game object reference let's make another input so if input get key down and on this one now let's use the same reference and call release instance and pass in the spawn game object alright so that's it let's just comment this out so let's make a build and look at the memory and see what this does okay so here's the build again since I'm using addressables the member footprint is real low so only 136 now I press the button to download the assets and there you go it starts loading them up and you appear this so the memory went all the way up to 616. now I press the button to unload it and yep there you go the object is destroyed and over there the memory comes back down also another thing is the assets are automatically unloaded from memory when you do a simple scene change so if you were to add Unity engine dot scene management and then up here on a scene if you would do scene manager.load scene if you would load a different scene then yep it would automatically destroy the objects in release the memory although do keep in mind this only works automatically if you use sync on scene mode if you're using additive scene loading then they stay unloaded since Unity does not know which assets you no longer need now there are some more things related to addressables if you want to dive deeper for example as we saw you've got a bunch of profiles so you can click here to go into manage profiles or alternatively go into window Asset Management addressables let's load up the profiles now these are used for easily setting up for example a profile for testing another one for production and so on as you can see each profile defines where exactly is in local and the remote paths I cover how to handle the remote paths in the next lecture then another helpful window is once again go into Asset Management over here we've got these settings then here you have tons and tons of options another one you have is also the useful events so if you see here the Event Viewer this one as you can see has a warning so you need to enable over here on the settings and profiler events so this one needs to be enabled and now if we try running the game like this this one kind of acts like a profiler so if I go and I'll look in the console and I press a button and there you go it does start loading the things and after a while yep it instantiates the object so you can stop at any point and see exactly what it did then over here you also have the analyze window this one lets you pretty much see dependencies it analyzes all of the rules that you define and finds of the dependencies within your asset bundles and finally there's the hosting window this one is for more complex use case where you want to connect to an external host and let you upload builds and content okay so all of that is the basics of addressables a really useful way to have more control over your memory and then Implement load your objects this one helps cut down on loading times in general memory usage you pretty much only load the assets when you need them and of course this lecture is just the basics the next step is to load updated assets from the cloud without having to make a new bone so we're going to learn how to do that in the next lecture and then in the in lecture after that one we're going to learn how to use unity's cloudcon delivery as the CDN for all of our assets so if you're interested in addressables definitely keep watching the next young lectures alright so this was a lecture from my ultimate Indie overview course there's lots more explaining tons of things like Shadow graph similar definitions animation Avatar the video player and so on as well as many Niche things that I couldn't possibly cover in normal YouTube videos go ahead and get the full course and learn how to master all of the unity tools and features to help you make better games faster
