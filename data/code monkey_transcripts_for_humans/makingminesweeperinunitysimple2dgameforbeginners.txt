With timestamps:

00:00 - in this video we're going to make
00:01 - minesweeper in unity this is a great
00:04 - game with some simple logic which makes
00:05 - it perfect for beginners to learn let's
00:07 - begin
00:11 - [Music]
00:15 - hello and welcome I'm your code monkey
00:17 - and this channel is all about helping
00:19 - you learn how to make your own games
00:20 - with in-depth tutorials made by a
00:22 - professional indie game developer so if
00:24 - you find the video helpful consider
00:25 - subscribing ok so this is what we want
00:27 - to make first of all if you're not
00:29 - familiar with my sweeper here's a quick
00:31 - rundown of how the game goes
00:33 - we have our play area in here and as you
00:35 - can see it's using a nice grid now
00:37 - hidden under this grid we have certain
00:39 - mines the mines are randomly generated
00:41 - so here we can use a debug visual this
00:44 - reveals the entire map and every time we
00:47 - play we get a different map so there it
00:49 - is by reloading the scene we have a new
00:50 - map and just like that a new map the
00:53 - goal of the game is to clear the entire
00:55 - map without triggering any of the minds
00:57 - and way we do that is with the help of
00:59 - mine indicators now we can click to
01:01 - explore our map so I click in here and
01:03 - there it goes in the position underneath
01:05 - it is a mine indicator it reveals just
01:08 - that position in this case the indicator
01:10 - is a number and the number means that
01:12 - there is this many mines in the area
01:14 - surrounding this great position so there
01:16 - are up to 8 positions total neighboring
01:18 - a grid position above below left-right
01:20 - and diagonals but since this one is on
01:22 - the corner it only has these ones so in
01:25 - these neighboring positions there is
01:26 - going to be one possible mind so in this
01:28 - case I can use the debug visual and see
01:30 - yep indeed there is that mine in there
01:32 - so this one has one mine neighboring and
01:34 - this one has two so that one and that
01:36 - one yep then we also have some areas
01:38 - that don't have any neighboring mines
01:40 - and when we click on those they show up
01:43 - all of the connected positions with our
01:44 - mind as you see and finally we can right
01:47 - click in order to place a flag to
01:48 - indicate where we think of mine might be
01:50 - then the game ends when either we head
01:53 - on a mine so there you go hit and there
01:55 - you go we have a game over and nice
01:56 - button to retry so hit retry and again
01:59 - we got a new nice map and the timer goes
02:01 - back to zero and then we can also win
02:03 - and when I click to win there you go it
02:06 - asks me for my player name so I put in
02:08 - the player name and my score gets added
02:10 - to a very nice high score table so just
02:12 - like this we have our very nice and
02:14 - simple complete game alright so this is
02:16 - our goal let's get to it
02:17 - now minesweeper is a game which is
02:20 - played on a grid so that makes it
02:22 - perfect for us use our previously made
02:24 - grid map
02:25 - if you haven't seen that video yet go
02:27 - check out the link in the description we
02:28 - created this grid map entirely from
02:30 - scratch then we added generics which
02:33 - lets us hold a custom object type in
02:35 - each grid sound position so using that
02:38 - as our base we can really speed up the
02:40 - development for this game so let's begin
02:42 - by setting up our map so a new script
02:45 - this won't be our map now in here let's
02:48 - make this a basic class so no mana
02:50 - behavior and on the constructor in here
02:53 - we want to make our grid map so we
02:57 - define a private grid and now in here we
03:00 - need to input our grid object so let's
03:02 - make that back in here let's make a new
03:04 - c-sharp script call this our map grid
03:07 - object so this is the grid object that
03:10 - is present on every position in our grid
03:14 - and in here we're going to make the
03:16 - default fields just like we did when we
03:18 - created our grid map okay so we have our
03:25 - simple grid object now let's go back
03:28 - into the map and in here we can now
03:30 - define our grid map as a grid of map
03:32 - grade object and here on the constructor
03:36 - we simply inset here okay all right so
03:43 - here's our grid being instantiated again
03:45 - if this seems weird to you make sure you
03:47 - watch the previous videos on making the
03:48 - grid and making the grid with generics
03:50 - and here we are instantiating our grid
03:52 - with the size of 10 by 10 decent size is
03:55 - 10 units or origin on vector 3.0 and we
03:58 - are creating our grid object very simply
04:00 - with the grid DX and dy ok so now we
04:03 - need to make the main script that won't
04:04 - create our map so here and let's make a
04:07 - new c-sharp script call this the
04:09 - minesweeper game Hamlet and let's make a
04:12 - game object to run this script and we
04:15 - drag the script onto it okay
04:16 - and in here we simply go into our start
04:19 - then we create a new map all right there
04:23 - it is very simple now let's just make
04:25 - sure that on our grid script that in
04:28 - here we have the debug visuals enabled
04:30 - so let's set this to true so we can
04:31 - visually see it alright let's test any
04:34 - of their days we have our grid map being
04:36 - accentuated and as you
04:37 - see every single grid position contains
04:39 - our map quick object alright great so
04:41 - far so good now let's set up our grid
04:44 - object correctly based on our game
04:46 - design we only have a limited number of
04:48 - possible types for each grid position we
04:50 - can have an empty a mine or an indicator
04:53 - so we're going to represent those
04:55 - different types using a new so here we
04:58 - have a Pollock innum let's call this our
05:00 - type and for the various types we have
05:04 - empty we have the mind then the
05:06 - indicators just like that and finally we
05:10 - have a type for our current type now
05:14 - here on the constructor let's set our
05:15 - tank so just for testing let's set it to
05:18 - random and let's also override our to
05:26 - string and make it return a string of
05:30 - our time okay so it says and we should
05:33 - be able to see our grid with random
05:35 - types everywhere what C and yep there it
05:37 - is our grid does have random types on
05:39 - every grid position so you can see over
05:41 - here we have a mine here another mine
05:43 - here a mine new 5 and so on and so forth
05:45 - alright great now let's make a proper
05:47 - visual instead of using this debug view
05:49 - over here I have a class that takes in a
05:52 - grid and instantiate a prefab on each
05:54 - grid position we first made a grid
05:57 - visual in the heatmap video then we also
05:59 - expand upon it in the talmud video so if
06:02 - you've seen both of those videos you'll
06:03 - be able to easily understand how all of
06:05 - this works we simply have a setup
06:07 - function and then we are subscribed to
06:09 - the on grid object changed event and
06:11 - when that happens we call this function
06:12 - which updates the various prefabs
06:15 - related to every great position so we
06:17 - can customize those prefabs in order to
06:19 - fit our game design so let's first going
06:22 - to the editor to make our visual prefab
06:24 - let's make an empty game object inside
06:29 - let's add a sprite you need to select
06:32 - the empty background sprite there it is
06:33 - then we're going to have another sprite
06:36 - this one will be above the background
06:38 - let's drag the mine sprite okay like
06:41 - that and finally we're also going to
06:43 - have a text object and we're going to
06:45 - use the text in order to display the
06:47 - number of minds
06:53 - and now just drag the game object on to
06:57 - the prefabs folder in order to make it a
06:59 - proven okay so we have the background
07:01 - sprite that on top we have an icon
07:03 - sprite so we can I'll put the mine or
07:06 - the flag and then on top we also have
07:08 - the mine indicator text and finally on
07:10 - top we can also add another sprite for
07:12 - this texture right here alright that's
07:15 - our prefab now let's make a game object
07:17 - to run our visual code let's put it on
07:20 - zero zero and let's drag the grid prefab
07:23 - visual okay and now here you can see
07:26 - that we have a field for the prefab
07:27 - visual so let's remove this one from the
07:29 - scene and in here drag our prefab
07:31 - references okay now we need to see this
07:33 - working is to call our setup function so
07:36 - here on the game handler script let's
07:37 - add a field for our visual script so
07:47 - here we just need to call our setup and
07:48 - pass in our grid and finally let's go
07:51 - into the editor and here on the game
07:53 - hanwen let's pass in the reference to
07:54 - our script okay let you do it let's test
07:57 - any of there it is we can see the grid
07:59 - and we have a prefab spawned on each
08:01 - grid position so we can pause and look
08:03 - at the hierarchy and there it is we have
08:05 - all of our grid node visuals right
08:06 - awesome now with this working let's set
08:08 - up the display to be based on the
08:10 - underlying a known value so here on our
08:12 - visual script here we have the update
08:15 - visual and in here we are cycling
08:16 - through every single node position on
08:18 - our grid we grab the visual node we set
08:21 - it to active and when we set it up so we
08:23 - can go here and do all of our setup
08:25 - let's pass individual node and as well
08:28 - as the grid object
08:34 - so now here we can do a simple switch on
08:37 - our map grid object and we get the grid
08:40 - time okay so here we are grabbing
08:58 - references for all of our elements
09:00 - inside of our visual node transform
09:02 - again here is the prefab and this is how
09:04 - we set it up so you have the background
09:05 - the icon the indicator and the hidden
09:07 - sprite so here if it's empty we're going
09:10 - to hide the indicator text and we're
09:12 - also going to hide the icon then in case
09:16 - we have a mine if we have mine then
09:20 - first we hide the text then we show the
09:22 - icon then we have all of our indicators
09:25 - so for the indicators we hide the sprite
09:29 - and we show the indicator so case we
09:38 - have an indicator we show the text and
09:40 - then we set the text to the correct
09:41 - number and for right now we're not going
09:43 - to deal with revealing so let's set the
09:45 - hidden transform to always be hidden
09:50 - okay so far so good this should be
09:53 - working with this we should be able to
09:55 - see the correct visuals on each grid
09:56 - position let's see and if there it is we
09:58 - have all of our nice visuals so over
10:01 - here we have an empty we have an eight
10:02 - seven over here we have some mines and
10:04 - all of them are working exactly as
10:06 - intended
10:06 - great so right now with visuals and the
10:09 - underlying objects working we can
10:11 - finally generate a map so in our grid
10:13 - object instead of having a random type
10:15 - let's start off at empty okay and now
10:20 - let's go into the map constructor and in
10:22 - here after we instantiate our grid let's
10:24 - randomly place some mines
10:35 - all right so we are going through this
10:37 - cycle 10 times and we're simply
10:39 - randomizing the X and the y then we get
10:42 - the grid object on that X&Y position and
10:45 - we set the grid type to be a mine so
10:47 - just like this we should have randomly
10:49 - placed ten months let's test any of
10:52 - their it is we have some random minds
10:53 - let's reload and there we go they're in
10:55 - a different position try again and you
10:58 - have another random position awesome
10:59 - so our randomness is working correctly
11:01 - however we do have a slight issue we're
11:04 - placing the mines randomly and we're
11:06 - coming up to ten however this script is
11:08 - completely random so we might be
11:09 - overriding in mind so at the end we
11:11 - might not actually end up with ten
11:13 - months in here for example you can see
11:15 - one two three four five six seven and
11:17 - only eight months so let's make sure
11:19 - that we only set the exact number of
11:21 - mines that we want so here we get the
11:24 - grid object then we do if the map grid
11:26 - objects we get the grid type if it is
11:30 - not a mind then we set it and increase
11:33 - the counter and if it is already in mind
11:37 - then we're simply going to go again so
11:39 - let's see now any of there it is we have
11:41 - our random mines in our map and we can
11:43 - place an exact number okay great now
11:46 - after we place our mind it's time to
11:48 - place the indicators so here we are
11:50 - placing our mines okay and then
11:51 - afterwards
11:52 - let's cycle through the whole map so we
11:57 - are cycling through the width and height
11:58 - and we check if this is an empty
12:00 - position if it is an empty position then
12:06 - we want to come late how many neighbors
12:07 - we have with a mod so let's make a
12:09 - function to get those neighbors
12:28 - all right so here we have a function to
12:30 - get all of the neighbors of a certain x
12:32 - and y position and we're similarly doing
12:34 - some checks to make sure that the
12:35 - numbers are valid so we make sure that
12:37 - the X minus one is above zero and
12:39 - download width and so on and so forth so
12:41 - we get the in left left down up right so
12:43 - on and so forth okay so we have this
12:46 - function to get our neighbors now we can
12:48 - go up here and get our list of neighbors
12:50 - and here we define an int for the mine
12:53 - count we start off at zero then we cycle
12:56 - through all the neighbors and if the
13:00 - neighbor grid type equals a mine then
13:04 - we're going to increase the mine count
13:05 - and after going through all the
13:07 - neighbors then we can now do a switch on
13:10 - our mind count to switch on the mine
13:15 - count and based on how many we have we
13:17 - set our correct map with object type
13:19 - right great so with this let's test and
13:22 - see our mind indicators and okay there
13:24 - it is and everything seems film let's
13:25 - see if it's correct so for example on
13:27 - this corner we have a mine and yep it is
13:29 - correct empty empty an indicator
13:31 - indicator and we got a mine here this
13:33 - one says we have two mines and yep we
13:35 - have these two this one says three one
13:37 - two three and yep all of them appear to
13:39 - be correct so here we have a three so
13:41 - one two three here we have a 2 1 2 and
13:43 - so on all right so our algorithm is
13:46 - working correctly and again this is all
13:48 - being created dynamically so if we run
13:50 - this code again their days we get a
13:52 - component different map and again the
13:53 - algorithm cell works so this one has two
13:55 - so one to another 2 1 2 and so on and
13:59 - there you go as you can see the
14:00 - algorithm is working correctly alright
14:02 - awesome now let's quickly try this out
14:05 - with more mines so here instead of
14:07 - generating 10 mines and let's try
14:08 - putting 30 let's see and yep there it is
14:11 - we have our map full of Mines and now
14:14 - let's see so this one s 2 1 2 yep that's
14:16 - correct this one s 4 1 2 3 4 this one
14:19 - has 5 1 2 3 4 5 right awesome so we have
14:22 - the indicators correctly displaying how
14:24 - many mines seroma
14:25 - so we have pretty much our imagine
14:27 - correctly working now let's deal with
14:29 - player input so let's go into the game
14:32 - Handler and then here on let's make a
14:34 - credit ROI update and on update let's
14:37 - assess for the mouse button down and if
14:40 - we have the unless mouse button down
14:41 - then we're going to tell the map to
14:43 - reveal the grid position on this world
14:45 - position so let's grab the world
14:47 - position so here I'm using a function
14:53 - from the utilities in order to get the
14:54 - mouse on position as long as you can
14:56 - download the utilities for free from
14:58 - unity code monkey comm here is the
15:00 - function in case you want to employ
15:01 - yourself only does is it takes the world
15:03 - camera the screen to run point on the
15:05 - screen position okay so with this let's
15:07 - go to the map and we're going to make a
15:09 - function let's call it reveal grid
15:12 - position and let's pass in our world
15:17 - position okay so here and let's make
15:19 - that function down here a public void
15:21 - reveal grid position and we receive a
15:23 - vector3 for the world position and we
15:26 - are going to grab the map grade object
15:30 - so we have the grid object underneath
15:32 - our world position now we want to reveal
15:35 - it so to do that let's go into our grid
15:37 - object definition and in here let's also
15:40 - add a boolean called is revealed by
15:45 - default it's not revealed so let's put
15:47 - it to false and let's make a function to
15:50 - reveal it we're simply set it to true
15:56 - and again due to the way that we created
15:59 - our print we need to go into grid and
16:01 - call trigger where the object changed
16:03 - passing this x and y so this allows us
16:07 - to fire the event so we can then update
16:09 - our visual and again back into our set
16:12 - up visual node now we can deal with our
16:14 - hidden transform so if the map grid
16:16 - object dot is revealed let's make this
16:21 - listen here a public ball is revealed
16:24 - and we simply return our boolean
16:30 - okay so if it is Ruby on then we do on
16:33 - this and if not then the node is hidden
16:40 - so on we're going to do is set the
16:42 - hidden transform to visible all right
16:45 - that's it
16:46 - very simple so let's review how our code
16:52 - is running over here we have our main
16:55 - game handler script we are testing for
16:57 - an input on the mouse button down so
16:59 - when we click with the mouse button we
17:01 - call the function to reveal the grid
17:03 - position and we pass in the world
17:04 - position then the map gets the map right
17:06 - object underneath our warm position and
17:08 - we're going to call the reveal function
17:10 - so that reveal function is on the credit
17:13 - object and over here all we're doing is
17:15 - setting this boolean to true and then we
17:17 - fire the event on our grid when we fire
17:20 - that event the visual captures that
17:22 - event and calls the function here to
17:24 - update the visual which calls the set up
17:26 - visual node and then in here we set up
17:29 - this visual node we ask if it's revealed
17:31 - if so then we show it like we were doing
17:33 - previously and if not we simply show the
17:35 - hidden transform okay so let's test and
17:37 - yep for starters everything is
17:39 - completely hidden now let's put the
17:41 - mouse here and click and there you go
17:43 - that position was revealed now click
17:45 - some more and there we go that one is
17:47 - revealed and that one down down down so
17:49 - for example like here and that's a mine
17:51 - click here ok and let's see a indicator
17:54 - there I give it two so that means
17:56 - there's two mines within these eight
17:58 - positions and let's see which one it is
17:59 - that one has a 1 so there's a mine here
18:01 - here here or here and it's probably in
18:04 - here and nope it's not this one has two
18:06 - so there's one here and so on and there
18:09 - you go just by clicking we can now
18:10 - uncover our map awesome so now the next
18:14 - step is to identify what we actually
18:16 - clicked on so for example if I click on
18:18 - a mine we should be able to get a nice
18:20 - game over so over here on the map on the
18:22 - reveal grid position let's make this
18:25 - return a map great object type and we go
18:29 - into that one we reveal it and we return
18:31 - the great object type in there okay
18:35 - so now we can go into the game hammer
18:36 - and in here we revealed ok and this one
18:39 - turn em up with object type and then
18:42 - with this type we can simply test if
18:44 - this one is a mine so if we had a mind
18:49 - we're going to spawn a pop-up saying
18:50 - game over all right so let's see if this
18:53 - happens whenever we reveal a mine okay
18:55 - here we're on let's reveal and nope
18:57 - that's empty empty empty okay there's
19:01 - someone so there's a mine at some point
19:03 - in here
19:03 - and there you go that's our mind and we
19:05 - have our nice game over puppet right
19:07 - great
19:08 - so we are now correctly identifying what
19:10 - we reveal when we reveal a position in
19:12 - our grid map now let's just make a quick
19:14 - debug visual to show the entire world so
19:17 - we can easily test clicking on different
19:18 - objects so we're here in our visual
19:20 - script let's make a boolean and a couple
19:23 - of functions so we're going to have a
19:26 - private ball let's call this reveal
19:28 - entire map and let's also make it
19:31 - function okay so we can set this boolean
19:36 - and now here in our cycle when we go
19:39 - through the setup visual node let's see
19:41 - if this one is revealed or we are
19:43 - supposed to reveal the entire map and
19:45 - now let's go into the game hammer and
19:47 - here let's add some debug keys okay so
19:54 - here on key down when I press the T key
19:57 - we're going to reveal the entire map
19:59 - when I let go it's going to go back to
20:01 - normal
20:01 - okay so let's test ok here we are with
20:03 - everything nice and hidden press key and
20:05 - there you go I can reveal the whole map
20:07 - and let go and it goes back to normal so
20:09 - this is excellent for us to easily test
20:11 - what's going on under our map so for
20:13 - example I can see there's a bomb here so
20:15 - now I'm going to click and there you go
20:16 - instant game over so in here we add a
20:17 - three and there you go all right so this
20:19 - is very useful for testing
20:21 - now let's handle the logic for revealing
20:23 - an empty position when we do that for
20:25 - example this position when I click on it
20:27 - it should reveal on that one but also
20:28 - every other empty position that is
20:30 - surrounding it so let's add that logic
20:33 - on our map over here in the map what's
20:35 - going to the reveal grid position okay
20:37 - so we are revealing a grid position now
20:40 - let's test if this one is an empty
20:42 - position
20:44 - so this one is an empty then we want to
20:46 - reveal all of the notes that are
20:47 - connected that are not lines okay so we
21:03 - reveal on the current grid object under
21:05 - the warm position so we get that one on
21:07 - the warm position we call this function
21:09 - with our grid object we count to reveal
21:11 - then we test if it's an empty then we
21:14 - sight on through all the neighbors check
21:16 - if they are not mines and if not then we
21:18 - reveal them however with this we are
21:20 - going to have infinite recursion so we
21:22 - need to keep track of which nodes we've
21:24 - already revealed okay so here's the
21:41 - algorithm for revealing of our connected
21:43 - nodes so we start off just revealing
21:45 - this object then we check if it's an
21:47 - empty word object if so then we want to
21:50 - reveal all of our connected nodes so we
21:52 - set up two lists to keep track of the
21:54 - ones already checked and the ones that
21:55 - we need to check so we first add to the
21:57 - queue this current map grid object and
22:00 - then we have our second where we're
22:01 - going to run once we have nodes check we
22:04 - grab the first one removed from the
22:06 - queue added to the already checked then
22:08 - we check the neighbors then we test the
22:10 - neighbors from that great object if it's
22:12 - not a mind then we reveal it and then we
22:15 - check if it's an empty and if so then we
22:17 - add the queue which will then run and so
22:19 - on and so forth so with this we should
22:21 - be able to reveal all of our connected
22:23 - neighbors when we click on an empty node
22:25 - let's test alright so in here we can use
22:29 - our debug view okay so we can see that
22:31 - over here we have a whole bunch of empty
22:33 - nodes so when I click in here it should
22:36 - reveal this one all of these all these
22:38 - and also the number ones connected so
22:41 - mighty and click in here and there you
22:43 - go it revealed all of the connected
22:45 - empty nodes and number nodes exactly as
22:47 - intended awesome so let's try this one
22:50 - on this side and we click and there yo
22:52 - it reveals all of them so it stops when
22:55 - it finds a mine or when it finds an
22:57 - number pass another number so it only
22:59 - keeps going for the connected ones once
23:01 - the current node is empty so just like
23:03 - this we already have a lot of our game
23:05 - working we can click to reveal positions
23:07 - and we have all of our map generation
23:10 - correctly working so we spawned a bunch
23:12 - of mines and they correctly indicate how
23:14 - many mines are surrounding it right
23:16 - awesome
23:17 - now let's add our mine flag feature
23:19 - flags are a way for the player to place
23:21 - a marker where he thinks there might be
23:23 - a mine don't actually do anything in
23:25 - terms of game design they are merely a
23:27 - visual object so it's actually very
23:29 - simple to add let's go in here to our
23:32 - grid object and let's add another
23:35 - boolean simply called is flying let's
23:41 - make some functions to set this value
23:47 - all right we have our two functions okay
23:49 - now it's going to the visual and in here
23:52 - on our visual node if the node is still
23:55 - hidden we show the hidden transform okay
23:57 - but then let's also go into the map grid
24:00 - object and test if it is flag and if so
24:03 - then we want to show our five so you
24:05 - know into the icon sprite renderer and
24:07 - we're going to set the sprite so now we
24:10 - need a reference to the flag sprite so
24:13 - if here let's add another serie lights
24:15 - field okay we have a flag sprite and a
24:20 - mine sprite so if it is flag then we set
24:24 - the sprite to the flag sprite and then
24:26 - in here in case we modify that one then
24:28 - we need to set it back into the mine
24:30 - sprite alright so just like this now we
24:33 - can go into the minesweeper game hammer
24:35 - and in here we're testing on left mouse
24:37 - button to reveal okay and now it's also
24:39 - test for the right mouse button so on
24:44 - the right mouse button we want to flag
24:46 - our current world position so let's make
24:48 - that function on the map
24:53 - and now we do is go into the map great
24:55 - object and concept fun okay so that
24:58 - should do it let's see if we can see the
24:59 - visuals okay here we are now when I
25:01 - right click and there you go this
25:03 - position has been filed again this
25:05 - really is just the visual mechanics so
25:07 - if I left click I can see on revealment
25:08 - so the goal with this mechanic is for
25:10 - example over here in the corner you can
25:12 - see a one so there's a mine connected to
25:14 - it so it's not on this one or this one
25:16 - so there has to be a mine here and if we
25:19 - use the debug we can see yep indeed
25:20 - there's a mine in there so in this case
25:22 - the player would flag it in order to
25:23 - know okay there's a mine in there so
25:25 - don't reveal it that's going for this
25:27 - mechanic okay so all of our player
25:29 - actions are already implemented all
25:31 - that's left is to hand on the game over
25:33 - and game when states now we already
25:35 - identified game over so if I click in
25:37 - this one there you go we got our pop up
25:39 - so now let's the only way the game win
25:41 - now the player wins the game when all
25:43 - the nodes have been revealed except for
25:45 - the mines so let's deal with that logic
25:47 - here on the map after we reveal a
25:50 - certain position let's make a function
25:52 - to test if the entire map is already
25:54 - reveal
26:04 - all right so here we have our code we
26:07 - sight on through the entire grid we
26:08 - check if it's not a mine and if it's not
26:10 - mine we check if it's not revealed and
26:12 - if not revealed then we return false
26:14 - otherwise if we go through this entire
26:17 - cycle then the entire map is revealed
26:18 - okay so here after we reveal let's call
26:22 - this function and if the entire map is
26:26 - revealed let's fire an event so let's go
26:28 - all the way up here to make our nice
26:30 - event okay so if the entire map is
26:36 - revealed we're going to fire off this
26:38 - event so now let's go to the game
26:40 - Handler and in here and let's subscribe
26:42 - to that event so the map dot on entire
26:45 - map revealed we subscribe to it and if
26:48 - so let's do a nice puppet alright the
26:52 - logic should be working
26:54 - let's test okay so here we are now let's
26:56 - first check out the unloose scenario so
26:58 - we can use the debug okay there's a mine
26:59 - here let's check our loose click and
27:02 - there we go there's a nice pop-up saying
27:03 - game over okay now let's refresh now
27:06 - let's use the debug okay and let's
27:08 - reveal all of it alright so using the
27:14 - debug I can see that this is the only
27:15 - one left so when I click there you go we
27:18 - have the game when event fired all right
27:20 - awesome so all of our logic is correctly
27:22 - working and we can test for a game when
27:24 - and gave loose okay now let's make a
27:26 - simple game over and game win window
27:43 - okay so here we have a nice game over
27:45 - window just says game over and they
27:47 - retry button now let's make the script
27:59 - okay so we simply have the retry button
28:01 - going into the scene manager and calling
28:03 - loads in now for this to work we need to
28:06 - go into the build options over here we
28:08 - need to make sure we add this scene okay
28:10 - and now in here in order to show and
28:12 - hide this window and let's make some
28:13 - static functions okay here we have a
28:21 - simple singleton with show and hide
28:22 - functions and now we can go into the
28:25 - game handler and in here when we have
28:27 - our game over let's simply go into the
28:29 - UI game over grab the instance and
28:32 - kancho alright let's test okay here we
28:36 - are now let's use the debug to make sure
28:37 - that we lose okay there's the mine there
28:39 - now when I click there you go we got the
28:41 - pop-up and we got the game over window
28:42 - so let's click retry and there you go we
28:45 - reload the quarantine and we can play
28:46 - again
28:47 - so mighty clean this one this one and
28:49 - boom there you go game over and retry
28:51 - and there it is and we have a nice new
28:53 - map right awesome now that we have the
28:56 - game over working let's see on with the
28:58 - wind state so when we when we want to
29:00 - input our time into a high score table
29:02 - so first let's count the time
29:15 - okay here we have a nice text field now
29:18 - let's go to the game panel and here on
29:20 - let's say move the timer while the game
29:21 - is active alright so here it is very
29:38 - simple whilst the game is active we
29:40 - simply increase the timer and we update
29:42 - the text and there it is and you can see
29:44 - these seconds counting up okay great now
29:46 - when we win we want to show a text input
29:49 - window okay here is a nice input window
29:52 - now this window was fully created in a
29:54 - previous video so go check the link in
29:56 - the description to see how this was made
29:57 - over here is the input window script and
30:00 - as you can see we have various buttons
30:03 - various actions and we can essentially
30:05 - call a function in order to show it so
30:08 - let's use this here when the player wins
30:10 - let's first get the current time so
30:13 - we're just going to for the timer to get
30:15 - the time score then we're going to go
30:17 - into the input window and call show
30:22 - going to ask the player for a player
30:25 - name
30:31 - okay so we asked for a player name with
30:34 - three characters only of uppercase if
30:36 - the player cancels let's simply retry so
30:40 - you send one load the scene just like
30:41 - previously okay
30:42 - and if the player hits okay then we want
30:45 - to submit that player name and the score
30:47 - into a high score table here is the high
30:49 - score table which again this was fully
30:51 - created in the previous video so go
30:53 - check that video out to see this whole
30:54 - thing created from scratch here is the
30:57 - high score table script and we have a
30:59 - nice function to set a new high score
31:01 - entry so let's use this so we simply go
31:03 - into the high score and we simply call
31:10 - an high score entry now we're going to
31:12 - pass in our time score and our me only
31:15 - received player name and finally let's
31:18 - s√∫plica T game over window in order to
31:20 - make a play again window okay so here we
31:34 - are and everything so far looks correct
31:36 - we have the timer increasing and we have
31:38 - our grid now let's win the game okay so
31:41 - I just have to review on this one and we
31:43 - should be able to win so it's quick and
31:45 - there it is it's asking for our player
31:47 - name let's put ABC and click and there
31:50 - you go we have our high score table with
31:52 - our score and right here at the bottom
31:54 - so we just need to polish this up and
31:56 - reverse the order let's do that okay so
31:58 - here we are and let's try to win so
32:00 - let's use a debug in order to clear all
32:02 - this up all right when I click here I
32:04 - should win so click and there you go
32:06 - i won now I got the player name my input
32:09 - and there you go the player name is
32:11 - added into the high score table and as
32:13 - you can see it is now correctly sorted
32:14 - so I'm number one with a score of twenty
32:16 - three seconds so just like this we have
32:19 - the save scores and we also have the
32:20 - play again button and there you go we
32:22 - click them again and it reloads our
32:24 - scene which reloads with a completely
32:25 - new map okay so now let's just polish
32:27 - this up a bit first let's make the bombs
32:29 - be revealed on loose
32:51 - okay so when we lose we're calling
32:53 - revealing the entire map I know it does
32:55 - is exactly that it goes through the
32:57 - entire grid map and reveals every single
32:59 - grid object let's see
33:01 - okay so let's click on this bomb and see
33:03 - what happens and there you go we have
33:05 - the entire map being revealed as our
33:06 - game over window shows up so hit retry
33:08 - and see there's a bomb here click em yep
33:11 - there you go we can see the entire map
33:12 - all right great
33:13 - so just like this we have our completed
33:16 - final game we have a grid with randomly
33:19 - generated mines we can use our debug
33:21 - vision to reveal the underlying map to
33:23 - see how the generation is working so
33:26 - here is another map there you go and
33:27 - here's another one and yep our map is
33:30 - constantly being generated randomly so
33:32 - we can play which means we can click to
33:34 - reveal a single position so quick if
33:36 - it's an indicator it just shows that
33:38 - position however we can also reveal an
33:41 - empty position and if we do there you go
33:43 - it reveals all of the connected
33:45 - positions and we can also right click to
33:47 - fly potential mines so this one has a
33:49 - mind neighboring it so the mine has to
33:52 - be here so just like that we have a nice
33:54 - visual flag then if we happen to hit a
33:56 - mind so I click there you go we have the
33:58 - game over and choose entire map and we
34:00 - can easily restart however if we
34:02 - successfully clear the whole map just
34:04 - like this area we win and we can out do
34:06 - a player name given a player and there
34:10 - you go we get added to the nice high
34:11 - score table so just like this we have a
34:13 - very nice completed simple mini game as
34:16 - always you can download the project
34:17 - files and utilities from Unity code
34:19 - marcom subscribe to the channel for more
34:21 - unity tutorials plus any questions you
34:23 - have in the comments and I'll see you
34:24 - next time
34:28 - [Music]
34:30 - you

Cleaned transcript:

in this video we're going to make minesweeper in unity this is a great game with some simple logic which makes it perfect for beginners to learn let's begin hello and welcome I'm your code monkey and this channel is all about helping you learn how to make your own games with indepth tutorials made by a professional indie game developer so if you find the video helpful consider subscribing ok so this is what we want to make first of all if you're not familiar with my sweeper here's a quick rundown of how the game goes we have our play area in here and as you can see it's using a nice grid now hidden under this grid we have certain mines the mines are randomly generated so here we can use a debug visual this reveals the entire map and every time we play we get a different map so there it is by reloading the scene we have a new map and just like that a new map the goal of the game is to clear the entire map without triggering any of the minds and way we do that is with the help of mine indicators now we can click to explore our map so I click in here and there it goes in the position underneath it is a mine indicator it reveals just that position in this case the indicator is a number and the number means that there is this many mines in the area surrounding this great position so there are up to 8 positions total neighboring a grid position above below leftright and diagonals but since this one is on the corner it only has these ones so in these neighboring positions there is going to be one possible mind so in this case I can use the debug visual and see yep indeed there is that mine in there so this one has one mine neighboring and this one has two so that one and that one yep then we also have some areas that don't have any neighboring mines and when we click on those they show up all of the connected positions with our mind as you see and finally we can right click in order to place a flag to indicate where we think of mine might be then the game ends when either we head on a mine so there you go hit and there you go we have a game over and nice button to retry so hit retry and again we got a new nice map and the timer goes back to zero and then we can also win and when I click to win there you go it asks me for my player name so I put in the player name and my score gets added to a very nice high score table so just like this we have our very nice and simple complete game alright so this is our goal let's get to it now minesweeper is a game which is played on a grid so that makes it perfect for us use our previously made grid map if you haven't seen that video yet go check out the link in the description we created this grid map entirely from scratch then we added generics which lets us hold a custom object type in each grid sound position so using that as our base we can really speed up the development for this game so let's begin by setting up our map so a new script this won't be our map now in here let's make this a basic class so no mana behavior and on the constructor in here we want to make our grid map so we define a private grid and now in here we need to input our grid object so let's make that back in here let's make a new csharp script call this our map grid object so this is the grid object that is present on every position in our grid and in here we're going to make the default fields just like we did when we created our grid map okay so we have our simple grid object now let's go back into the map and in here we can now define our grid map as a grid of map grade object and here on the constructor we simply inset here okay all right so here's our grid being instantiated again if this seems weird to you make sure you watch the previous videos on making the grid and making the grid with generics and here we are instantiating our grid with the size of 10 by 10 decent size is 10 units or origin on vector 3.0 and we are creating our grid object very simply with the grid DX and dy ok so now we need to make the main script that won't create our map so here and let's make a new csharp script call this the minesweeper game Hamlet and let's make a game object to run this script and we drag the script onto it okay and in here we simply go into our start then we create a new map all right there it is very simple now let's just make sure that on our grid script that in here we have the debug visuals enabled so let's set this to true so we can visually see it alright let's test any of their days we have our grid map being accentuated and as you see every single grid position contains our map quick object alright great so far so good now let's set up our grid object correctly based on our game design we only have a limited number of possible types for each grid position we can have an empty a mine or an indicator so we're going to represent those different types using a new so here we have a Pollock innum let's call this our type and for the various types we have empty we have the mind then the indicators just like that and finally we have a type for our current type now here on the constructor let's set our tank so just for testing let's set it to random and let's also override our to string and make it return a string of our time okay so it says and we should be able to see our grid with random types everywhere what C and yep there it is our grid does have random types on every grid position so you can see over here we have a mine here another mine here a mine new 5 and so on and so forth alright great now let's make a proper visual instead of using this debug view over here I have a class that takes in a grid and instantiate a prefab on each grid position we first made a grid visual in the heatmap video then we also expand upon it in the talmud video so if you've seen both of those videos you'll be able to easily understand how all of this works we simply have a setup function and then we are subscribed to the on grid object changed event and when that happens we call this function which updates the various prefabs related to every great position so we can customize those prefabs in order to fit our game design so let's first going to the editor to make our visual prefab let's make an empty game object inside let's add a sprite you need to select the empty background sprite there it is then we're going to have another sprite this one will be above the background let's drag the mine sprite okay like that and finally we're also going to have a text object and we're going to use the text in order to display the number of minds and now just drag the game object on to the prefabs folder in order to make it a proven okay so we have the background sprite that on top we have an icon sprite so we can I'll put the mine or the flag and then on top we also have the mine indicator text and finally on top we can also add another sprite for this texture right here alright that's our prefab now let's make a game object to run our visual code let's put it on zero zero and let's drag the grid prefab visual okay and now here you can see that we have a field for the prefab visual so let's remove this one from the scene and in here drag our prefab references okay now we need to see this working is to call our setup function so here on the game handler script let's add a field for our visual script so here we just need to call our setup and pass in our grid and finally let's go into the editor and here on the game hanwen let's pass in the reference to our script okay let you do it let's test any of there it is we can see the grid and we have a prefab spawned on each grid position so we can pause and look at the hierarchy and there it is we have all of our grid node visuals right awesome now with this working let's set up the display to be based on the underlying a known value so here on our visual script here we have the update visual and in here we are cycling through every single node position on our grid we grab the visual node we set it to active and when we set it up so we can go here and do all of our setup let's pass individual node and as well as the grid object so now here we can do a simple switch on our map grid object and we get the grid time okay so here we are grabbing references for all of our elements inside of our visual node transform again here is the prefab and this is how we set it up so you have the background the icon the indicator and the hidden sprite so here if it's empty we're going to hide the indicator text and we're also going to hide the icon then in case we have a mine if we have mine then first we hide the text then we show the icon then we have all of our indicators so for the indicators we hide the sprite and we show the indicator so case we have an indicator we show the text and then we set the text to the correct number and for right now we're not going to deal with revealing so let's set the hidden transform to always be hidden okay so far so good this should be working with this we should be able to see the correct visuals on each grid position let's see and if there it is we have all of our nice visuals so over here we have an empty we have an eight seven over here we have some mines and all of them are working exactly as intended great so right now with visuals and the underlying objects working we can finally generate a map so in our grid object instead of having a random type let's start off at empty okay and now let's go into the map constructor and in here after we instantiate our grid let's randomly place some mines all right so we are going through this cycle 10 times and we're simply randomizing the X and the y then we get the grid object on that X&Y position and we set the grid type to be a mine so just like this we should have randomly placed ten months let's test any of their it is we have some random minds let's reload and there we go they're in a different position try again and you have another random position awesome so our randomness is working correctly however we do have a slight issue we're placing the mines randomly and we're coming up to ten however this script is completely random so we might be overriding in mind so at the end we might not actually end up with ten months in here for example you can see one two three four five six seven and only eight months so let's make sure that we only set the exact number of mines that we want so here we get the grid object then we do if the map grid objects we get the grid type if it is not a mind then we set it and increase the counter and if it is already in mind then we're simply going to go again so let's see now any of there it is we have our random mines in our map and we can place an exact number okay great now after we place our mind it's time to place the indicators so here we are placing our mines okay and then afterwards let's cycle through the whole map so we are cycling through the width and height and we check if this is an empty position if it is an empty position then we want to come late how many neighbors we have with a mod so let's make a function to get those neighbors all right so here we have a function to get all of the neighbors of a certain x and y position and we're similarly doing some checks to make sure that the numbers are valid so we make sure that the X minus one is above zero and download width and so on and so forth so we get the in left left down up right so on and so forth okay so we have this function to get our neighbors now we can go up here and get our list of neighbors and here we define an int for the mine count we start off at zero then we cycle through all the neighbors and if the neighbor grid type equals a mine then we're going to increase the mine count and after going through all the neighbors then we can now do a switch on our mind count to switch on the mine count and based on how many we have we set our correct map with object type right great so with this let's test and see our mind indicators and okay there it is and everything seems film let's see if it's correct so for example on this corner we have a mine and yep it is correct empty empty an indicator indicator and we got a mine here this one says we have two mines and yep we have these two this one says three one two three and yep all of them appear to be correct so here we have a three so one two three here we have a 2 1 2 and so on all right so our algorithm is working correctly and again this is all being created dynamically so if we run this code again their days we get a component different map and again the algorithm cell works so this one has two so one to another 2 1 2 and so on and there you go as you can see the algorithm is working correctly alright awesome now let's quickly try this out with more mines so here instead of generating 10 mines and let's try putting 30 let's see and yep there it is we have our map full of Mines and now let's see so this one s 2 1 2 yep that's correct this one s 4 1 2 3 4 this one has 5 1 2 3 4 5 right awesome so we have the indicators correctly displaying how many mines seroma so we have pretty much our imagine correctly working now let's deal with player input so let's go into the game Handler and then here on let's make a credit ROI update and on update let's assess for the mouse button down and if we have the unless mouse button down then we're going to tell the map to reveal the grid position on this world position so let's grab the world position so here I'm using a function from the utilities in order to get the mouse on position as long as you can download the utilities for free from unity code monkey comm here is the function in case you want to employ yourself only does is it takes the world camera the screen to run point on the screen position okay so with this let's go to the map and we're going to make a function let's call it reveal grid position and let's pass in our world position okay so here and let's make that function down here a public void reveal grid position and we receive a vector3 for the world position and we are going to grab the map grade object so we have the grid object underneath our world position now we want to reveal it so to do that let's go into our grid object definition and in here let's also add a boolean called is revealed by default it's not revealed so let's put it to false and let's make a function to reveal it we're simply set it to true and again due to the way that we created our print we need to go into grid and call trigger where the object changed passing this x and y so this allows us to fire the event so we can then update our visual and again back into our set up visual node now we can deal with our hidden transform so if the map grid object dot is revealed let's make this listen here a public ball is revealed and we simply return our boolean okay so if it is Ruby on then we do on this and if not then the node is hidden so on we're going to do is set the hidden transform to visible all right that's it very simple so let's review how our code is running over here we have our main game handler script we are testing for an input on the mouse button down so when we click with the mouse button we call the function to reveal the grid position and we pass in the world position then the map gets the map right object underneath our warm position and we're going to call the reveal function so that reveal function is on the credit object and over here all we're doing is setting this boolean to true and then we fire the event on our grid when we fire that event the visual captures that event and calls the function here to update the visual which calls the set up visual node and then in here we set up this visual node we ask if it's revealed if so then we show it like we were doing previously and if not we simply show the hidden transform okay so let's test and yep for starters everything is completely hidden now let's put the mouse here and click and there you go that position was revealed now click some more and there we go that one is revealed and that one down down down so for example like here and that's a mine click here ok and let's see a indicator there I give it two so that means there's two mines within these eight positions and let's see which one it is that one has a 1 so there's a mine here here here or here and it's probably in here and nope it's not this one has two so there's one here and so on and there you go just by clicking we can now uncover our map awesome so now the next step is to identify what we actually clicked on so for example if I click on a mine we should be able to get a nice game over so over here on the map on the reveal grid position let's make this return a map great object type and we go into that one we reveal it and we return the great object type in there okay so now we can go into the game hammer and in here we revealed ok and this one turn em up with object type and then with this type we can simply test if this one is a mine so if we had a mind we're going to spawn a popup saying game over all right so let's see if this happens whenever we reveal a mine okay here we're on let's reveal and nope that's empty empty empty okay there's someone so there's a mine at some point in here and there you go that's our mind and we have our nice game over puppet right great so we are now correctly identifying what we reveal when we reveal a position in our grid map now let's just make a quick debug visual to show the entire world so we can easily test clicking on different objects so we're here in our visual script let's make a boolean and a couple of functions so we're going to have a private ball let's call this reveal entire map and let's also make it function okay so we can set this boolean and now here in our cycle when we go through the setup visual node let's see if this one is revealed or we are supposed to reveal the entire map and now let's go into the game hammer and here let's add some debug keys okay so here on key down when I press the T key we're going to reveal the entire map when I let go it's going to go back to normal okay so let's test ok here we are with everything nice and hidden press key and there you go I can reveal the whole map and let go and it goes back to normal so this is excellent for us to easily test what's going on under our map so for example I can see there's a bomb here so now I'm going to click and there you go instant game over so in here we add a three and there you go all right so this is very useful for testing now let's handle the logic for revealing an empty position when we do that for example this position when I click on it it should reveal on that one but also every other empty position that is surrounding it so let's add that logic on our map over here in the map what's going to the reveal grid position okay so we are revealing a grid position now let's test if this one is an empty position so this one is an empty then we want to reveal all of the notes that are connected that are not lines okay so we reveal on the current grid object under the warm position so we get that one on the warm position we call this function with our grid object we count to reveal then we test if it's an empty then we sight on through all the neighbors check if they are not mines and if not then we reveal them however with this we are going to have infinite recursion so we need to keep track of which nodes we've already revealed okay so here's the algorithm for revealing of our connected nodes so we start off just revealing this object then we check if it's an empty word object if so then we want to reveal all of our connected nodes so we set up two lists to keep track of the ones already checked and the ones that we need to check so we first add to the queue this current map grid object and then we have our second where we're going to run once we have nodes check we grab the first one removed from the queue added to the already checked then we check the neighbors then we test the neighbors from that great object if it's not a mind then we reveal it and then we check if it's an empty and if so then we add the queue which will then run and so on and so forth so with this we should be able to reveal all of our connected neighbors when we click on an empty node let's test alright so in here we can use our debug view okay so we can see that over here we have a whole bunch of empty nodes so when I click in here it should reveal this one all of these all these and also the number ones connected so mighty and click in here and there you go it revealed all of the connected empty nodes and number nodes exactly as intended awesome so let's try this one on this side and we click and there yo it reveals all of them so it stops when it finds a mine or when it finds an number pass another number so it only keeps going for the connected ones once the current node is empty so just like this we already have a lot of our game working we can click to reveal positions and we have all of our map generation correctly working so we spawned a bunch of mines and they correctly indicate how many mines are surrounding it right awesome now let's add our mine flag feature flags are a way for the player to place a marker where he thinks there might be a mine don't actually do anything in terms of game design they are merely a visual object so it's actually very simple to add let's go in here to our grid object and let's add another boolean simply called is flying let's make some functions to set this value all right we have our two functions okay now it's going to the visual and in here on our visual node if the node is still hidden we show the hidden transform okay but then let's also go into the map grid object and test if it is flag and if so then we want to show our five so you know into the icon sprite renderer and we're going to set the sprite so now we need a reference to the flag sprite so if here let's add another serie lights field okay we have a flag sprite and a mine sprite so if it is flag then we set the sprite to the flag sprite and then in here in case we modify that one then we need to set it back into the mine sprite alright so just like this now we can go into the minesweeper game hammer and in here we're testing on left mouse button to reveal okay and now it's also test for the right mouse button so on the right mouse button we want to flag our current world position so let's make that function on the map and now we do is go into the map great object and concept fun okay so that should do it let's see if we can see the visuals okay here we are now when I right click and there you go this position has been filed again this really is just the visual mechanics so if I left click I can see on revealment so the goal with this mechanic is for example over here in the corner you can see a one so there's a mine connected to it so it's not on this one or this one so there has to be a mine here and if we use the debug we can see yep indeed there's a mine in there so in this case the player would flag it in order to know okay there's a mine in there so don't reveal it that's going for this mechanic okay so all of our player actions are already implemented all that's left is to hand on the game over and game when states now we already identified game over so if I click in this one there you go we got our pop up so now let's the only way the game win now the player wins the game when all the nodes have been revealed except for the mines so let's deal with that logic here on the map after we reveal a certain position let's make a function to test if the entire map is already reveal all right so here we have our code we sight on through the entire grid we check if it's not a mine and if it's not mine we check if it's not revealed and if not revealed then we return false otherwise if we go through this entire cycle then the entire map is revealed okay so here after we reveal let's call this function and if the entire map is revealed let's fire an event so let's go all the way up here to make our nice event okay so if the entire map is revealed we're going to fire off this event so now let's go to the game Handler and in here and let's subscribe to that event so the map dot on entire map revealed we subscribe to it and if so let's do a nice puppet alright the logic should be working let's test okay so here we are now let's first check out the unloose scenario so we can use the debug okay there's a mine here let's check our loose click and there we go there's a nice popup saying game over okay now let's refresh now let's use the debug okay and let's reveal all of it alright so using the debug I can see that this is the only one left so when I click there you go we have the game when event fired all right awesome so all of our logic is correctly working and we can test for a game when and gave loose okay now let's make a simple game over and game win window okay so here we have a nice game over window just says game over and they retry button now let's make the script okay so we simply have the retry button going into the scene manager and calling loads in now for this to work we need to go into the build options over here we need to make sure we add this scene okay and now in here in order to show and hide this window and let's make some static functions okay here we have a simple singleton with show and hide functions and now we can go into the game handler and in here when we have our game over let's simply go into the UI game over grab the instance and kancho alright let's test okay here we are now let's use the debug to make sure that we lose okay there's the mine there now when I click there you go we got the popup and we got the game over window so let's click retry and there you go we reload the quarantine and we can play again so mighty clean this one this one and boom there you go game over and retry and there it is and we have a nice new map right awesome now that we have the game over working let's see on with the wind state so when we when we want to input our time into a high score table so first let's count the time okay here we have a nice text field now let's go to the game panel and here on let's say move the timer while the game is active alright so here it is very simple whilst the game is active we simply increase the timer and we update the text and there it is and you can see these seconds counting up okay great now when we win we want to show a text input window okay here is a nice input window now this window was fully created in a previous video so go check the link in the description to see how this was made over here is the input window script and as you can see we have various buttons various actions and we can essentially call a function in order to show it so let's use this here when the player wins let's first get the current time so we're just going to for the timer to get the time score then we're going to go into the input window and call show going to ask the player for a player name okay so we asked for a player name with three characters only of uppercase if the player cancels let's simply retry so you send one load the scene just like previously okay and if the player hits okay then we want to submit that player name and the score into a high score table here is the high score table which again this was fully created in the previous video so go check that video out to see this whole thing created from scratch here is the high score table script and we have a nice function to set a new high score entry so let's use this so we simply go into the high score and we simply call an high score entry now we're going to pass in our time score and our me only received player name and finally let's s√∫plica T game over window in order to make a play again window okay so here we are and everything so far looks correct we have the timer increasing and we have our grid now let's win the game okay so I just have to review on this one and we should be able to win so it's quick and there it is it's asking for our player name let's put ABC and click and there you go we have our high score table with our score and right here at the bottom so we just need to polish this up and reverse the order let's do that okay so here we are and let's try to win so let's use a debug in order to clear all this up all right when I click here I should win so click and there you go i won now I got the player name my input and there you go the player name is added into the high score table and as you can see it is now correctly sorted so I'm number one with a score of twenty three seconds so just like this we have the save scores and we also have the play again button and there you go we click them again and it reloads our scene which reloads with a completely new map okay so now let's just polish this up a bit first let's make the bombs be revealed on loose okay so when we lose we're calling revealing the entire map I know it does is exactly that it goes through the entire grid map and reveals every single grid object let's see okay so let's click on this bomb and see what happens and there you go we have the entire map being revealed as our game over window shows up so hit retry and see there's a bomb here click em yep there you go we can see the entire map all right great so just like this we have our completed final game we have a grid with randomly generated mines we can use our debug vision to reveal the underlying map to see how the generation is working so here is another map there you go and here's another one and yep our map is constantly being generated randomly so we can play which means we can click to reveal a single position so quick if it's an indicator it just shows that position however we can also reveal an empty position and if we do there you go it reveals all of the connected positions and we can also right click to fly potential mines so this one has a mind neighboring it so the mine has to be here so just like that we have a nice visual flag then if we happen to hit a mind so I click there you go we have the game over and choose entire map and we can easily restart however if we successfully clear the whole map just like this area we win and we can out do a player name given a player and there you go we get added to the nice high score table so just like this we have a very nice completed simple mini game as always you can download the project files and utilities from Unity code marcom subscribe to the channel for more unity tutorials plus any questions you have in the comments and I'll see you next time you
