With timestamps:

00:00 - there's a box around his current
00:01 - position then you make sure that the
00:03 - player is within the fov
00:05 - so very quickly right here the player
00:06 - receives a ton of information
00:08 - [Music]
00:13 - this video is sponsored by core core is
00:15 - the new free game creation platform that
00:17 - lets you build publish and play games
00:19 - it's a great platform for game jams
00:21 - especially if you want to very quickly
00:22 - set up a 3d multiplayer game
00:24 - you can get started making games right
00:26 - away using thousands of free high
00:28 - quality music sound and art assets with
00:30 - no coding required
00:32 - but if you want to take it further core
00:33 - still lets you create your own game
00:35 - logic in lua
00:36 - you can build games from scratch or
00:38 - remix and re-imagine content shared by
00:40 - other creators
00:41 - and when you're ready to publish your
00:42 - game will go live instantly on the core
00:44 - platform with a click of a button
00:46 - multiplayer games are very easy to build
00:48 - since all the complicated networking
00:50 - parts are handled automatically
00:51 - there's already lots of user created
00:53 - games on the platform explore tons of
00:55 - crazy new concepts from the minds of the
00:57 - player creator community
00:58 - it is completely free so click the link
01:00 - in the description to learn more and get
01:02 - started bringing your ideas to life
01:04 - using the link also helps support the
01:05 - channel hello and welcome i'm your code
01:08 - monkey a professional indie game
01:09 - developer and here i will react and
01:11 - analyze
01:12 - to a gameplay drone i will talk about
01:14 - how things work behind the scenes and
01:15 - how you could build them in your own
01:17 - games
01:17 - in this case we're looking at the marvel
01:19 - spider-man gameplay trailer from 2017.
01:22 - alright so let's hit play
01:26 - all units all units 10 10 s and 36 and
01:29 - park repeat all units be advised
01:31 - shots fired at fisk towers
01:45 - you got this i got this
01:49 - okay so after a short cutscene we get
01:52 - into the gameplay and
01:53 - immediately the ui shows up so it's a
01:55 - pretty standard ui
01:57 - one thing about it is it seems to be
01:58 - built with a slight 3d effect
02:01 - so over here you can see that the bar is
02:03 - not perfectly horizontal but rather it
02:04 - is pointing towards the center of the
02:06 - screen
02:06 - and all the elements so there are
02:08 - several ways you can achieve this effect
02:10 - one possible approach would be a world
02:12 - canvas on each of the four corners and
02:14 - you just slightly rotate them
02:16 - that way the actual underlying elements
02:18 - have no rotation which makes them easier
02:20 - to work with but it still gives off this
02:21 - nice
02:22 - effect then all of the elements are
02:24 - pre-standard so up here we have a health
02:26 - bar
02:26 - then in here we have a combo counter
02:29 - down here the most active action
02:31 - and also a simple mini-map
02:39 - then right here we see spider-man take
02:41 - down enemy
02:42 - so over here as he approaches we see the
02:44 - active action indicator down here
02:46 - and it's going to change as the player
02:48 - gets closer to the enemy so first it's a
02:50 - web strike takedown
02:51 - and as soon as he gets close there you
02:53 - go it swaps into a normal takedown
02:55 - so the logic for all this is probably
02:57 - just a simple boxcast
02:59 - so as the player is walking around
03:00 - there's a box around his current
03:02 - position
03:03 - it is constantly looking for possible
03:04 - interactable objects
03:06 - so in this case it finds this enemy
03:08 - right here within range
03:09 - then it just tests the distance towards
03:11 - the player and if it's close enough then
03:12 - swaps out and shows the different action
03:15 - then for the action itself yep it's just
03:17 - a really nice animation and
03:18 - yep the enemy is down
03:21 - now another element that we can see here
03:23 - is the perch target
03:25 - so we see it right here where the camera
03:26 - is looking at and as the camera moves we
03:28 - see the target update
03:30 - so as the player controls the camera it
03:32 - is constantly looking for valley perch
03:34 - targets
03:34 - now the way it works is probably once
03:36 - again doing some sort of boxcast
03:38 - so right here is the center of the
03:40 - screen and it's doing a box test from
03:41 - the camera starting position
03:42 - around this area and then all of these
03:45 - objects are tagged as being perchable so
03:47 - this area right here this one right here
03:50 - this one down here and so on
03:51 - then locates all the ones that are
03:53 - within the boxcast
03:56 - then it calculates the closest point to
03:58 - the center of the screen and simply
04:00 - picks the closest and shows that one
04:02 - then for showing it's really just a
04:03 - basic ui element then for the movement
04:05 - itself it's actually pretty simple
04:07 - so it plays the web zip animation and
04:09 - moves the player towards a target
04:10 - position
04:11 - now a long time ago as i was playing
04:13 - this game i actually recreated a couple
04:14 - of systems in some tutorial videos
04:16 - one of those was the web zip so go watch
04:18 - that if you want to see a very
04:20 - simplified version of how this works
04:22 - even in 2d that system is still a lot of
04:24 - fun alright so here we have another
04:26 - enemy in a different scenario
04:28 - so previously spider-man was behind the
04:30 - other enemy and right now he's on top
04:32 - and as you can see the enemy does not
04:33 - spot him so the enemy has
04:35 - a very standard detection cone detection
04:38 - is just based on an angle
04:40 - but it also has a limit on the y axis so
04:43 - for handling detection it's really just
04:44 - a simple case of doing some basic math
04:46 - essentially you know the enemy position
04:49 - and you also know the player position
04:52 - so for example you can simply flatten
04:54 - the y put it equal 0
04:56 - and then you just test the angle using
04:58 - the x and z then you make sure that the
05:00 - player is within the fov
05:02 - so probably something like minus 45 to
05:04 - plus 45 degrees
05:06 - then you test the distance to make sure
05:07 - that the player isn't too far
05:09 - and finally you test either the y angle
05:11 - or just the difference between the y's
05:13 - then if the player is let's say five
05:14 - units above or below the enemy then he's
05:17 - outside of the view cone
05:18 - so in this case the player is not
05:20 - spotted and if there you go
05:21 - you have another way to take them so for
05:23 - the action here is pretty much the same
05:24 - that we saw previously
05:26 - so the game does a boxcast right
05:28 - underneath the player
05:29 - and if there is an enemy within that
05:31 - area then we enable the perch take down
05:33 - option
05:33 - so once again very simple and combined
05:35 - with some excellent animation
05:40 - now here this part is really interesting
05:42 - so that enemy over there realized that
05:44 - his buddy is gone
05:45 - now there are many many ways that you
05:47 - can do this as always you need to
05:48 - remember that games are all about smoke
05:50 - and mirrors
05:51 - all you're trying to do as a game
05:52 - developer is just simulate a particular
05:55 - scenario
05:56 - what i mean by that is that the game
05:57 - knows exactly what happened the game
05:59 - knows that the player is right here and
06:00 - he took down the other enemy
06:02 - and now the game has to pretend that
06:03 - this enemy doesn't know what happened
06:05 - so the reason why i mentioned that all
06:06 - games are smoking mirrors is because you
06:08 - want to fake reality rather than make a
06:10 - pure simulation
06:11 - now one approach for this would be
06:13 - indeed to make a perfect simulation
06:15 - so this enemy would keep track of the
06:17 - last position that he saw his buddies
06:20 - and he would know their patrol would go
06:21 - back and forth and he would simply go
06:23 - into an alert set as if he looked
06:24 - towards this area and one of them had
06:26 - vanished
06:27 - but doing all of that would be
06:29 - needlessly computationally expensive
06:31 - so the better approach is simply to fake
06:33 - it so these two enemies are problem
06:35 - linked in some way
06:36 - for example in unity maybe you would
06:38 - have a component with a reference to the
06:40 - other one
06:41 - then when the player takes down one of
06:42 - them it drops an invisible marker
06:44 - and then this enemy over here has his
06:46 - usual detection cone
06:48 - and if this invisible marker is visible
06:50 - by the detection cone
06:52 - then he goes into the alert state
06:53 - looking for his friend so this approach
06:55 - is computationally very cheap and really
06:57 - ends up with the same result
06:59 - so as you were going about making your
07:00 - games always remember that your goal is
07:02 - to give the player a good experience
07:04 - and not to have a perfect simulation of
07:06 - reality then once he is in the alert
07:08 - state the first thing he does is move
07:09 - towards the suspicious position
07:11 - i know here we see one of the gadgets
07:12 - it's really simple and looks great
07:14 - so the first thing the player does is he
07:16 - engages aim mode
07:18 - so when it does you can see that the
07:20 - whole game slows down
07:22 - so right there nice and slow down you
07:24 - can easily do this by modifying
07:26 - time.timescale which affects
07:28 - anything that uses time.deltatime like
07:30 - for example all the animations and
07:32 - movement
07:32 - it also enables a very interesting
07:34 - shader effect
07:36 - so right around the edges outside of
07:38 - this circle
07:39 - everything you can see is nice and
07:40 - blurred and it is also in black and
07:43 - white i covered how to make
07:44 - post-processing effects in a previous
07:46 - video
07:46 - and this is exactly the type of thing
07:48 - that you can easily build by using that
07:50 - combined with shadowgraph
07:51 - and after aiming yep the player throws a
07:53 - gadget
07:54 - now here again you have two possible
07:57 - methods for throwing
07:58 - something so you can do a perfect
07:59 - simulation or once again you can keep
08:01 - things simple and just fake it
08:04 - so here it seems like he actually throws
08:06 - an object
08:07 - however what you can do is really just
08:08 - spawn a very basic particle effect
08:11 - so you spawn something that goes
08:12 - constantly forward and falls along the
08:14 - trajectory that the
08:16 - gadget would go to and after the
08:18 - particle effect reaches the target
08:20 - position
08:20 - then it destroys itself the particle
08:23 - effect and it spawns the
08:24 - actual object so doing it this way would
08:27 - avoid potential bugs like for example
08:29 - the gadget being activated in midair or
08:31 - some other unintended behavior
08:33 - once again another simple way of
08:35 - achieving the same result
08:36 - then for the gadget the logic itself is
08:38 - pretty simple so first of all as he gets
08:41 - displaced the rotation is actually a
08:43 - normal of whatever surface it lands on
08:46 - so it's pointing in this direction and
08:48 - then all it does is once again just a
08:50 - very simple box cast
08:52 - and when an enemy is found within its
08:53 - range then it activates the gadget and
08:55 - in this case takes him down
09:05 - now here we see an interaction with a
09:07 - special object so in this case it seems
09:09 - to be just a simple scripted animation
09:12 - so no matter where spider-man is it will
09:14 - probably always do this exact animation
09:16 - you can guess that based on the fact
09:18 - that it pulled it straight down rather
09:19 - than towards the player
09:20 - so just a basic scripted animation then
09:23 - for hitting the enemies it's just a
09:25 - simple physics collision that works as
09:26 - an instant take down
09:28 - and spider-man also plays a nice audio
09:30 - clip
09:31 - if you don't want a helmet so it's
09:33 - probably linked to this specific object
09:35 - and plays when it's used and hit
09:36 - something
09:37 - so just a simple audio clip and it helps
09:39 - the game feel more responsive by
09:41 - unliterally responding to your action
09:43 - then we also see the enemy on the side
09:44 - there reacting to the noise
09:46 - dealing with sound is actually pretty
09:47 - simple all you do is you have the noise
09:50 - origin and then you just do a very basic
09:52 - sphere cast around that position
09:54 - then perhaps you also do a basic raycast
09:57 - to make sure there are no obstructions
09:58 - between the
09:59 - sound origin and the sound listener so
10:02 - if the enemy is within the range and not
10:04 - being occluded then he reacts to the
10:06 - noise
10:06 - so one clean way of doing this is to
10:09 - make an interface for anything that can
10:10 - listen
10:11 - so for example the enemy here implements
10:14 - a i
10:14 - listen interface now i covered interface
10:17 - in a previous video if you want to learn
10:18 - more
10:19 - so this is one way that you can keep
10:20 - your code decoupled from actual things
10:23 - so using this approach you can make
10:24 - anything listen to anything
10:26 - so for example you can make objects
10:28 - react to noise from other objects
10:32 - and now here we have this really super
10:34 - cool shot
10:35 - so there it is it looks really awesome
10:37 - it's an excellent pose with some
10:38 - particles
10:40 - there's also some motion blur and some
10:42 - slow motion so it perfectly matches the
10:43 - comic book source material
10:45 - now for the camera rotation you can do
10:47 - this very easily when working with
10:48 - cinemachine
10:49 - so you can create two virtual cameras
10:52 - then the first one is the normal one
10:54 - which is always behind the player
10:55 - and then the second one activates as it
10:57 - does this move and it has just a simple
10:59 - animation going around the player
11:01 - then when the animation ends it goes
11:03 - back to the original one
11:04 - now using cinemachine this is extremely
11:06 - easy by just playing around with
11:08 - priorities
11:09 - so you have the main camera following
11:10 - the player then you have the second one
11:12 - for this particular animation
11:14 - and as soon as the animation is
11:15 - triggered you enable the priority for
11:17 - this camera
11:18 - then this camera does its position its
11:20 - animation and then it lowers its
11:22 - priority
11:23 - and once again the scene machine brain
11:25 - is smart enough to interpolate all the
11:26 - values and goes back to the original
11:27 - camera
11:28 - so here it is the whole thing and yep it
11:31 - looks
11:32 - really awesome
11:36 - you got what you came for you don't need
11:38 - to kill us too
11:41 - this territory is ours now not today
11:44 - all right so we're done with the stump
11:46 - portion and right away we start off with
11:48 - a cutscene that goes into a quicktime
11:49 - event
11:50 - now these are actually very easy to make
11:56 - we really have is just a basic flow
11:57 - timer and it's constantly counting down
12:00 - and when it's within a certain amount it
12:02 - listens to player input and if so then
12:04 - it's successful
12:05 - so visually you can build all this very
12:07 - easily all you have is running just two
12:09 - circles in the button prompt image
12:11 - you can see the outer circle scaling
12:12 - down along with the timer
12:14 - and when the player gets it right yep
12:16 - plays a really nice animation
12:17 - and it's successful and visually once
12:20 - again it enables the post-processing
12:21 - effects that we saw previously
12:23 - so there's pretty much a circle right
12:25 - here where everything is normal and then
12:26 - outside everything is slightly in black
12:28 - and white and blurred
12:29 - now the difficulty with quicktime events
12:31 - is designing what happens if the player
12:32 - fails
12:33 - so just how much should you punish the
12:35 - player for failing the event
12:36 - now in this case the game isn't meant to
12:38 - be extremely hard so the punishment is
12:40 - likely that he just misses the web
12:42 - so when you start off this battle you
12:44 - start off with two extra enemies
12:45 - again that's all up to designer to
12:47 - define how hard or easy it should be
12:49 - and now right in here we get into combat
12:52 - and right away the first thing that we
12:53 - notice is a nice shader effect on the
12:54 - enemies
12:55 - so over here on this enemy yep there you
12:57 - go a nice gradient going upwards
12:59 - so this is indicating that this enemy is
13:01 - about to attack this is a very easy
13:03 - shader to make
13:04 - you just have a gradient it gets applied
13:06 - on top of the enemy
13:07 - then also right away spider-man fires a
13:09 - web straight at his face
13:11 - so the web targeting system is
13:13 - constantly looking for valid targets
13:15 - it's just a very basic simple distance
13:18 - check
13:18 - make sure they're within range and also
13:20 - obviously make sure they are within the
13:22 - player's field of view
13:23 - then it likely does some simple math to
13:25 - figure out which one should be
13:26 - prioritized
13:28 - so in this case an enemy that has an
13:29 - imminent attack probably gets a much
13:31 - much higher priority
13:33 - even if another one is supposedly
13:34 - somewhat closer so does some basic math
13:36 - choose this one and you fires the web
13:38 - straight onto his face
13:40 - and then for the enemy as he gets the
13:41 - web he goes into the basic stun state
13:43 - which takes him out of the fight for a
13:44 - few seconds
13:46 - now here we see the fight mechanics so
13:49 - once again we see this one on the left
13:51 - here
13:51 - if there you go imminent attack and the
13:53 - player right away dodges that attack
13:56 - so it's just an example of a basic timed
13:58 - animation
13:59 - so the animation has a timer and if the
14:01 - player hits the dodge button within that
14:02 - timer
14:03 - then he successfully dodges and doesn't
14:05 - take damage and if he waits too long
14:06 - then he gets hit and takes normal damage
14:08 - so if the player dodges yep exactly
14:10 - right on time then he's rewarded with
14:12 - avoiding damage and getting a nice slow
14:14 - motion effect
14:15 - then notice how the stun for this one
14:16 - down here has been temporary
14:18 - so right now the web is gone and he's
14:20 - back into his normal ai state
14:22 - then for attacking the various enemies
14:24 - it's also something that i covered in my
14:25 - simplified spider-man 2d video
14:28 - so first it locates all the enemies
14:30 - within a valid range
14:32 - then it combines it with the player
14:33 - movement vector
14:35 - so collates a vector from where the
14:36 - player is pointing the thumb stick
14:38 - and then it uses that to decide which
14:40 - enemy should be attacked so if the
14:41 - player is pointing towards this enemy
14:43 - even if this one was supposedly closer
14:45 - it would pick this one since the player
14:46 - input is what values most
14:49 - and now here we see a nice finisher
14:51 - against this enemy
14:53 - so these enemies don't have any visible
14:55 - health bars right above their heads but
14:57 - they still have a health system
14:58 - so the attacks are still causing damage
15:01 - and when their health is under a certain
15:02 - amount
15:03 - then it enables the finishing move so
15:05 - the player can take him down
15:14 - now here we see the spidey sense in
15:16 - action so as soon as he finishes this
15:18 - animation
15:20 - yep there it is we see there's an enemy
15:22 - off screen
15:24 - so there's an enemy right here about to
15:25 - attack and when the attack is imminent
15:28 - we see right away some particle effects
15:29 - showcasing the spidey sense effect on
15:31 - his head
15:32 - so just a basic particle system and
15:34 - there's also this element here
15:36 - it is pointing towards the enemy's
15:37 - direction and it's showing the button
15:39 - prompt to dodge the attack
15:40 - so this is similar to what i covered in
15:42 - the quest pointer video
15:43 - just a basic element pointing in a
15:45 - certain direction and it does say which
15:47 - button the player should press in order
15:49 - to dodge this attack
15:50 - so very quickly right here the player
15:52 - receives a ton of information
15:54 - so the spidey sense tells the player
15:55 - that he's about to take some damage
15:57 - this element is pointing towards where
15:59 - that damage is going to come from
16:01 - and he also receives the button problem
16:02 - telling him what to do if he wants to
16:04 - dodge that attack
16:05 - so tons of information and very easily
16:07 - readable
16:19 - now over here we have another battle
16:21 - we're going to see some really
16:22 - interesting interaction with level
16:24 - elements
16:24 - yup just like that so the game is always
16:27 - looking for possible interactable
16:29 - objects
16:30 - and then just like the perch system it
16:32 - identifies which one it should be
16:34 - activated
16:35 - then for this particular environment
16:37 - object it has a simple timer to activate
16:40 - it
16:40 - so this does two things first it enables
16:42 - the game designers to add a risk reward
16:44 - element onto each different interactable
16:46 - object
16:47 - so for something that causes tons of
16:48 - damage it would require a long time
16:51 - and this also helps prevent the player
16:53 - from accidentally using it since they
16:54 - need to hold the button down for some
16:56 - time
16:56 - then like we saw previously yep it plays
16:59 - a scripted animation and damages all
17:01 - enemies within that radius
17:02 - yep like that
17:20 - and now here we are going to have a mini
17:22 - boss fight
17:23 - so right away we see an increase in
17:25 - difficulty so right away the player
17:27 - starts trying to do a zip attack and
17:29 - nope doesn't work
17:30 - then he throws a web and nope doesn't
17:31 - work either so that's one way you can
17:34 - add difficulty
17:35 - instead of just increasing the health
17:36 - amount by a ton
17:38 - you just make them invulnerable to very
17:40 - specific types of attacks
17:41 - then down here we see a different type
17:43 - of interaction with the environment
17:45 - so it does pretty much the same thing
17:46 - that we saw previously in order to
17:48 - identify the
17:48 - interactable objects however in the
17:51 - previous ones it played just a scripted
17:53 - animation
17:54 - whereas on this one it is simultaneously
17:56 - looking for the interactable object
17:58 - as well as the most valid active enemy
18:01 - so as the player uses it really just
18:02 - combines both of those pieces of data
18:05 - and once again the enemy doesn't have
18:06 - any visible health bar but the enemy
18:08 - does have a health system so all this is
18:10 - still causing damage
18:11 - then over here as he was hidden there
18:13 - yep he goes into a stun state for a few
18:15 - seconds and while he's stunned the
18:16 - player can easily hit him and cause a
18:18 - bunch of damage
18:19 - that's actually really cool
18:24 - and now here we see a different mechanic
18:26 - so the enemy has a basic health system
18:29 - but he also has some sort of stamina
18:31 - system so it's likely something that
18:33 - regens over time
18:34 - i covered something similar to that in
18:35 - the mana bar video
18:37 - so each of these attacks has a certain
18:40 - stamina cost
18:41 - and if he gets down to zero by doing too
18:43 - many attacks then he goes into his stun
18:45 - state
18:52 - and there you go the player takes him
18:54 - down check the roof
19:21 - oh come on
19:31 - let's go let's go now here we see
19:34 - another quick time event pretty much
19:35 - like we saw previously so mechanically
19:37 - it's really simple
19:38 - all of these quicktime events are all
19:40 - about the visuals animation and sound
19:42 - so mechanically very easy but you can
19:44 - make them look really nice
19:52 - and now we're on to the chase sequence
19:54 - now chase sequences are always something
19:56 - interesting to design
19:57 - so at its core it's really just a
19:59 - scripted animation so usually they have
20:01 - a rule where you cannot ever catch up to
20:03 - the target
20:04 - so no matter how fast you go the target
20:06 - will always be at a certain distance
20:08 - so the animation either speeds up or
20:10 - slows down depending on how fast the
20:11 - player is
20:12 - and once again as a designer you have
20:14 - the ability to make it easy or hard
20:15 - depending on what you're going for
20:17 - so if the player starts falling behind
20:19 - you have the option to slow down the
20:20 - animation by a certain amount
20:22 - it all depends on how many mistakes you
20:23 - want to allow the player to have
20:25 - and finally when the chase sequence is
20:27 - done then the animation speed is set to
20:28 - a fixed amount
20:29 - allowing the player to catch up
20:35 - and over here we're on to a boss fight
20:38 - so mechanically this is very simple
20:40 - in here all you have are really just
20:41 - three positions so there's one here one
20:43 - on this side and one on this side
20:44 - so as a player you are not allowed to go
20:46 - all the way up here or on the way down
20:48 - there doing this limits the player's
20:49 - actions which allow you to play the
20:51 - animation sequence exactly as you want
20:52 - it
20:53 - then it still has the usual attack dodge
20:55 - mechanics and if the player fails he
20:57 - falls on and has a second chance to get
20:59 - back up
21:02 - and now here we see a different type of
21:04 - a quicktime event
21:05 - so rather than being a timed event it's
21:07 - all about pressing a button lots of
21:09 - times
21:10 - visually we can see a ring increasing on
21:12 - the outside so you can do this very
21:14 - easily by making a mask with the ring
21:16 - shape
21:17 - and then underneath you put a circle
21:19 - sprite and you set the film type to
21:21 - radial
21:21 - and you simply increase the amount so do
21:24 - that and you have this really nice
21:27 - [Music]
21:28 - effect
21:36 - i guess this is the plan
21:44 - come on now we have yet another type of
21:46 - quicktime event
21:47 - so with this one the goal is to move the
21:49 - joystick towards the target position
21:51 - so mechanically this is very easy you
21:52 - just have the cursor position
21:54 - and then on every frame you just had
21:56 - some noise movement onto any random
21:58 - direction
21:59 - the player has to constantly adapt in
22:00 - order to get it to its target
22:02 - and once again you can see on the ring
22:04 - that it has a certain time limit
22:06 - so again it's up to the designer to
22:07 - decide what happens if the player fails
22:10 - maybe it's an instant fail or maybe it
22:11 - goes into another quick time event
22:12 - giving you a second chance
22:15 - you got this you got this you got this
22:21 - alright so that's it that's my analysis
22:23 - of the spider-man gameplay trailer
22:25 - the game is really awesome so if you
22:27 - haven't played it yet i would definitely
22:28 - highly recommend it
22:29 - it was one of the best games that i
22:31 - played on that year now i hope you found
22:33 - this video interesting and useful and
22:34 - learned something along the way
22:36 - let me know in the comments your
22:37 - suggestions for what other trailers i
22:39 - should react to
22:40 - also don't forget to check out core it's
22:42 - completely free so just click the link
22:43 - in the description and try it out
22:45 - check out the code monkey app on steam
22:47 - interactive tutorials complete games and
22:49 - more
22:50 - this video is made possible thanks to
22:51 - these awesome supporters go to
22:53 - patreon.com
22:54 - unitycodemonkey to get some perks and
22:56 - help keep the videos free for everyone
22:58 - like the video and subscribe to the
22:59 - channel if you'd like to see more post
23:01 - any questions you have in the comments
23:02 - and i'll see you next time
23:08 - [Music]
23:12 - you

Cleaned transcript:

there's a box around his current position then you make sure that the player is within the fov so very quickly right here the player receives a ton of information this video is sponsored by core core is the new free game creation platform that lets you build publish and play games it's a great platform for game jams especially if you want to very quickly set up a 3d multiplayer game you can get started making games right away using thousands of free high quality music sound and art assets with no coding required but if you want to take it further core still lets you create your own game logic in lua you can build games from scratch or remix and reimagine content shared by other creators and when you're ready to publish your game will go live instantly on the core platform with a click of a button multiplayer games are very easy to build since all the complicated networking parts are handled automatically there's already lots of user created games on the platform explore tons of crazy new concepts from the minds of the player creator community it is completely free so click the link in the description to learn more and get started bringing your ideas to life using the link also helps support the channel hello and welcome i'm your code monkey a professional indie game developer and here i will react and analyze to a gameplay drone i will talk about how things work behind the scenes and how you could build them in your own games in this case we're looking at the marvel spiderman gameplay trailer from 2017. alright so let's hit play all units all units 10 10 s and 36 and park repeat all units be advised shots fired at fisk towers you got this i got this okay so after a short cutscene we get into the gameplay and immediately the ui shows up so it's a pretty standard ui one thing about it is it seems to be built with a slight 3d effect so over here you can see that the bar is not perfectly horizontal but rather it is pointing towards the center of the screen and all the elements so there are several ways you can achieve this effect one possible approach would be a world canvas on each of the four corners and you just slightly rotate them that way the actual underlying elements have no rotation which makes them easier to work with but it still gives off this nice effect then all of the elements are prestandard so up here we have a health bar then in here we have a combo counter down here the most active action and also a simple minimap then right here we see spiderman take down enemy so over here as he approaches we see the active action indicator down here and it's going to change as the player gets closer to the enemy so first it's a web strike takedown and as soon as he gets close there you go it swaps into a normal takedown so the logic for all this is probably just a simple boxcast so as the player is walking around there's a box around his current position it is constantly looking for possible interactable objects so in this case it finds this enemy right here within range then it just tests the distance towards the player and if it's close enough then swaps out and shows the different action then for the action itself yep it's just a really nice animation and yep the enemy is down now another element that we can see here is the perch target so we see it right here where the camera is looking at and as the camera moves we see the target update so as the player controls the camera it is constantly looking for valley perch targets now the way it works is probably once again doing some sort of boxcast so right here is the center of the screen and it's doing a box test from the camera starting position around this area and then all of these objects are tagged as being perchable so this area right here this one right here this one down here and so on then locates all the ones that are within the boxcast then it calculates the closest point to the center of the screen and simply picks the closest and shows that one then for showing it's really just a basic ui element then for the movement itself it's actually pretty simple so it plays the web zip animation and moves the player towards a target position now a long time ago as i was playing this game i actually recreated a couple of systems in some tutorial videos one of those was the web zip so go watch that if you want to see a very simplified version of how this works even in 2d that system is still a lot of fun alright so here we have another enemy in a different scenario so previously spiderman was behind the other enemy and right now he's on top and as you can see the enemy does not spot him so the enemy has a very standard detection cone detection is just based on an angle but it also has a limit on the y axis so for handling detection it's really just a simple case of doing some basic math essentially you know the enemy position and you also know the player position so for example you can simply flatten the y put it equal 0 and then you just test the angle using the x and z then you make sure that the player is within the fov so probably something like minus 45 to plus 45 degrees then you test the distance to make sure that the player isn't too far and finally you test either the y angle or just the difference between the y's then if the player is let's say five units above or below the enemy then he's outside of the view cone so in this case the player is not spotted and if there you go you have another way to take them so for the action here is pretty much the same that we saw previously so the game does a boxcast right underneath the player and if there is an enemy within that area then we enable the perch take down option so once again very simple and combined with some excellent animation now here this part is really interesting so that enemy over there realized that his buddy is gone now there are many many ways that you can do this as always you need to remember that games are all about smoke and mirrors all you're trying to do as a game developer is just simulate a particular scenario what i mean by that is that the game knows exactly what happened the game knows that the player is right here and he took down the other enemy and now the game has to pretend that this enemy doesn't know what happened so the reason why i mentioned that all games are smoking mirrors is because you want to fake reality rather than make a pure simulation now one approach for this would be indeed to make a perfect simulation so this enemy would keep track of the last position that he saw his buddies and he would know their patrol would go back and forth and he would simply go into an alert set as if he looked towards this area and one of them had vanished but doing all of that would be needlessly computationally expensive so the better approach is simply to fake it so these two enemies are problem linked in some way for example in unity maybe you would have a component with a reference to the other one then when the player takes down one of them it drops an invisible marker and then this enemy over here has his usual detection cone and if this invisible marker is visible by the detection cone then he goes into the alert state looking for his friend so this approach is computationally very cheap and really ends up with the same result so as you were going about making your games always remember that your goal is to give the player a good experience and not to have a perfect simulation of reality then once he is in the alert state the first thing he does is move towards the suspicious position i know here we see one of the gadgets it's really simple and looks great so the first thing the player does is he engages aim mode so when it does you can see that the whole game slows down so right there nice and slow down you can easily do this by modifying time.timescale which affects anything that uses time.deltatime like for example all the animations and movement it also enables a very interesting shader effect so right around the edges outside of this circle everything you can see is nice and blurred and it is also in black and white i covered how to make postprocessing effects in a previous video and this is exactly the type of thing that you can easily build by using that combined with shadowgraph and after aiming yep the player throws a gadget now here again you have two possible methods for throwing something so you can do a perfect simulation or once again you can keep things simple and just fake it so here it seems like he actually throws an object however what you can do is really just spawn a very basic particle effect so you spawn something that goes constantly forward and falls along the trajectory that the gadget would go to and after the particle effect reaches the target position then it destroys itself the particle effect and it spawns the actual object so doing it this way would avoid potential bugs like for example the gadget being activated in midair or some other unintended behavior once again another simple way of achieving the same result then for the gadget the logic itself is pretty simple so first of all as he gets displaced the rotation is actually a normal of whatever surface it lands on so it's pointing in this direction and then all it does is once again just a very simple box cast and when an enemy is found within its range then it activates the gadget and in this case takes him down now here we see an interaction with a special object so in this case it seems to be just a simple scripted animation so no matter where spiderman is it will probably always do this exact animation you can guess that based on the fact that it pulled it straight down rather than towards the player so just a basic scripted animation then for hitting the enemies it's just a simple physics collision that works as an instant take down and spiderman also plays a nice audio clip if you don't want a helmet so it's probably linked to this specific object and plays when it's used and hit something so just a simple audio clip and it helps the game feel more responsive by unliterally responding to your action then we also see the enemy on the side there reacting to the noise dealing with sound is actually pretty simple all you do is you have the noise origin and then you just do a very basic sphere cast around that position then perhaps you also do a basic raycast to make sure there are no obstructions between the sound origin and the sound listener so if the enemy is within the range and not being occluded then he reacts to the noise so one clean way of doing this is to make an interface for anything that can listen so for example the enemy here implements a i listen interface now i covered interface in a previous video if you want to learn more so this is one way that you can keep your code decoupled from actual things so using this approach you can make anything listen to anything so for example you can make objects react to noise from other objects and now here we have this really super cool shot so there it is it looks really awesome it's an excellent pose with some particles there's also some motion blur and some slow motion so it perfectly matches the comic book source material now for the camera rotation you can do this very easily when working with cinemachine so you can create two virtual cameras then the first one is the normal one which is always behind the player and then the second one activates as it does this move and it has just a simple animation going around the player then when the animation ends it goes back to the original one now using cinemachine this is extremely easy by just playing around with priorities so you have the main camera following the player then you have the second one for this particular animation and as soon as the animation is triggered you enable the priority for this camera then this camera does its position its animation and then it lowers its priority and once again the scene machine brain is smart enough to interpolate all the values and goes back to the original camera so here it is the whole thing and yep it looks really awesome you got what you came for you don't need to kill us too this territory is ours now not today all right so we're done with the stump portion and right away we start off with a cutscene that goes into a quicktime event now these are actually very easy to make we really have is just a basic flow timer and it's constantly counting down and when it's within a certain amount it listens to player input and if so then it's successful so visually you can build all this very easily all you have is running just two circles in the button prompt image you can see the outer circle scaling down along with the timer and when the player gets it right yep plays a really nice animation and it's successful and visually once again it enables the postprocessing effects that we saw previously so there's pretty much a circle right here where everything is normal and then outside everything is slightly in black and white and blurred now the difficulty with quicktime events is designing what happens if the player fails so just how much should you punish the player for failing the event now in this case the game isn't meant to be extremely hard so the punishment is likely that he just misses the web so when you start off this battle you start off with two extra enemies again that's all up to designer to define how hard or easy it should be and now right in here we get into combat and right away the first thing that we notice is a nice shader effect on the enemies so over here on this enemy yep there you go a nice gradient going upwards so this is indicating that this enemy is about to attack this is a very easy shader to make you just have a gradient it gets applied on top of the enemy then also right away spiderman fires a web straight at his face so the web targeting system is constantly looking for valid targets it's just a very basic simple distance check make sure they're within range and also obviously make sure they are within the player's field of view then it likely does some simple math to figure out which one should be prioritized so in this case an enemy that has an imminent attack probably gets a much much higher priority even if another one is supposedly somewhat closer so does some basic math choose this one and you fires the web straight onto his face and then for the enemy as he gets the web he goes into the basic stun state which takes him out of the fight for a few seconds now here we see the fight mechanics so once again we see this one on the left here if there you go imminent attack and the player right away dodges that attack so it's just an example of a basic timed animation so the animation has a timer and if the player hits the dodge button within that timer then he successfully dodges and doesn't take damage and if he waits too long then he gets hit and takes normal damage so if the player dodges yep exactly right on time then he's rewarded with avoiding damage and getting a nice slow motion effect then notice how the stun for this one down here has been temporary so right now the web is gone and he's back into his normal ai state then for attacking the various enemies it's also something that i covered in my simplified spiderman 2d video so first it locates all the enemies within a valid range then it combines it with the player movement vector so collates a vector from where the player is pointing the thumb stick and then it uses that to decide which enemy should be attacked so if the player is pointing towards this enemy even if this one was supposedly closer it would pick this one since the player input is what values most and now here we see a nice finisher against this enemy so these enemies don't have any visible health bars right above their heads but they still have a health system so the attacks are still causing damage and when their health is under a certain amount then it enables the finishing move so the player can take him down now here we see the spidey sense in action so as soon as he finishes this animation yep there it is we see there's an enemy off screen so there's an enemy right here about to attack and when the attack is imminent we see right away some particle effects showcasing the spidey sense effect on his head so just a basic particle system and there's also this element here it is pointing towards the enemy's direction and it's showing the button prompt to dodge the attack so this is similar to what i covered in the quest pointer video just a basic element pointing in a certain direction and it does say which button the player should press in order to dodge this attack so very quickly right here the player receives a ton of information so the spidey sense tells the player that he's about to take some damage this element is pointing towards where that damage is going to come from and he also receives the button problem telling him what to do if he wants to dodge that attack so tons of information and very easily readable now over here we have another battle we're going to see some really interesting interaction with level elements yup just like that so the game is always looking for possible interactable objects and then just like the perch system it identifies which one it should be activated then for this particular environment object it has a simple timer to activate it so this does two things first it enables the game designers to add a risk reward element onto each different interactable object so for something that causes tons of damage it would require a long time and this also helps prevent the player from accidentally using it since they need to hold the button down for some time then like we saw previously yep it plays a scripted animation and damages all enemies within that radius yep like that and now here we are going to have a mini boss fight so right away we see an increase in difficulty so right away the player starts trying to do a zip attack and nope doesn't work then he throws a web and nope doesn't work either so that's one way you can add difficulty instead of just increasing the health amount by a ton you just make them invulnerable to very specific types of attacks then down here we see a different type of interaction with the environment so it does pretty much the same thing that we saw previously in order to identify the interactable objects however in the previous ones it played just a scripted animation whereas on this one it is simultaneously looking for the interactable object as well as the most valid active enemy so as the player uses it really just combines both of those pieces of data and once again the enemy doesn't have any visible health bar but the enemy does have a health system so all this is still causing damage then over here as he was hidden there yep he goes into a stun state for a few seconds and while he's stunned the player can easily hit him and cause a bunch of damage that's actually really cool and now here we see a different mechanic so the enemy has a basic health system but he also has some sort of stamina system so it's likely something that regens over time i covered something similar to that in the mana bar video so each of these attacks has a certain stamina cost and if he gets down to zero by doing too many attacks then he goes into his stun state and there you go the player takes him down check the roof oh come on let's go let's go now here we see another quick time event pretty much like we saw previously so mechanically it's really simple all of these quicktime events are all about the visuals animation and sound so mechanically very easy but you can make them look really nice and now we're on to the chase sequence now chase sequences are always something interesting to design so at its core it's really just a scripted animation so usually they have a rule where you cannot ever catch up to the target so no matter how fast you go the target will always be at a certain distance so the animation either speeds up or slows down depending on how fast the player is and once again as a designer you have the ability to make it easy or hard depending on what you're going for so if the player starts falling behind you have the option to slow down the animation by a certain amount it all depends on how many mistakes you want to allow the player to have and finally when the chase sequence is done then the animation speed is set to a fixed amount allowing the player to catch up and over here we're on to a boss fight so mechanically this is very simple in here all you have are really just three positions so there's one here one on this side and one on this side so as a player you are not allowed to go all the way up here or on the way down there doing this limits the player's actions which allow you to play the animation sequence exactly as you want it then it still has the usual attack dodge mechanics and if the player fails he falls on and has a second chance to get back up and now here we see a different type of a quicktime event so rather than being a timed event it's all about pressing a button lots of times visually we can see a ring increasing on the outside so you can do this very easily by making a mask with the ring shape and then underneath you put a circle sprite and you set the film type to radial and you simply increase the amount so do that and you have this really nice effect i guess this is the plan come on now we have yet another type of quicktime event so with this one the goal is to move the joystick towards the target position so mechanically this is very easy you just have the cursor position and then on every frame you just had some noise movement onto any random direction the player has to constantly adapt in order to get it to its target and once again you can see on the ring that it has a certain time limit so again it's up to the designer to decide what happens if the player fails maybe it's an instant fail or maybe it goes into another quick time event giving you a second chance you got this you got this you got this alright so that's it that's my analysis of the spiderman gameplay trailer the game is really awesome so if you haven't played it yet i would definitely highly recommend it it was one of the best games that i played on that year now i hope you found this video interesting and useful and learned something along the way let me know in the comments your suggestions for what other trailers i should react to also don't forget to check out core it's completely free so just click the link in the description and try it out check out the code monkey app on steam interactive tutorials complete games and more this video is made possible thanks to these awesome supporters go to patreon.com unitycodemonkey to get some perks and help keep the videos free for everyone like the video and subscribe to the channel if you'd like to see more post any questions you have in the comments and i'll see you next time you
