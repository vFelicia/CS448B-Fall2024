With timestamps:

00:00 - in this video we're going to learn how C
00:02 - sharp delegates work and how they're
00:03 - used we're going to see how they help us
00:05 - write more modular code and use compacts
00:08 - to simplify our logic let's begin
00:10 - [Music]
00:14 - so the liggett's are a very interesting
00:17 - C sharp feature essentially they allow
00:19 - you to store a function inside of a
00:21 - field this is extremely powerful in many
00:23 - scenarios you've seen me use delegates
00:25 - whenever I use one of the function
00:27 - classes from my utilities for example on
00:29 - the function periodic which triggers an
00:31 - action every certain amount of time it
00:32 - is a delegate to receive the function
00:34 - that won't be triggered so when I create
00:36 - the object I pass the behavior that I
00:38 - want to trigger in a previous video I
00:40 - covered events which also use a type of
00:42 - delegate not only they use the standard
00:44 - event handler as the event type and even
00:46 - handler is a type of delegate with a
00:49 - return type of void and a parameter
00:51 - signature of object and event arcs so
00:55 - let's take a look at how delegates are
00:56 - defined how they are created and
00:58 - assigned and various building types that
01:00 - make our job easier then we're going to
01:02 - look at two examples that show how
01:04 - delegates help keep our code clean and
01:05 - how they help us write more modular code
01:07 - this video is made possible thanks to
01:09 - these awesome supporters go to
01:11 - patreon.com/scishow to code monkey to
01:14 - get some perks and help keep the videos
01:15 - free for everyone delegates are defined
01:18 - as a function signature and return type
01:20 - but without any implementation so for
01:22 - example here I am in a simple empty
01:24 - script and first we define a donut and
01:27 - the way we do that is very simple first
01:29 - we write the accessor so for example
01:31 - public then we write the keyword
01:33 - delegate and now we define the delegate
01:36 - return type and signature so for the
01:38 - return type let's keep it simple and
01:39 - just return void then we need a name so
01:42 - let's call it our test delegate and now
01:45 - we define the parameters that make up
01:47 - the double yet signature but again to
01:49 - keep it simple let's make it no
01:50 - parameters at all so there we go here we
01:52 - define a donut that returns void and
01:55 - takes no parameters in here on we're
01:57 - doing is defining the actual delegate
01:59 - type so now we can make a field of this
02:01 - type so just like any other field let's
02:03 - say we make it private of type test
02:06 - delegate and call it our tests they'll
02:08 - get function now this film can be
02:12 - assigned with a function that matches
02:13 - this delegate signature so here on start
02:16 - let's say we set our test don't get
02:18 - function to equal something so now we
02:20 - define our function and again make sure
02:22 - that it has the same signature as
02:24 - identity
02:25 - so let's make it first of all will
02:27 - return void then we give it a name and
02:32 - again no parameters so this function
02:36 - declaration matches the delegate so now
02:38 - here we can simply assign this function
02:40 - onto this stomach and once we have
02:43 - assigned the delegate we can call it as
02:44 - if it were a normal function so we do
02:46 - test don't get function this case no
02:48 - parameter so just friends just like that
02:51 - we are calling the function that is
02:52 - stored within this field which in this
02:54 - case is going to be this function so
02:55 - let's just add a debug mode here just T
02:58 - to us
03:00 - alright so let's test and see any of
03:03 - there's our work so our function was
03:05 - correctly triggered through our delegate
03:07 - now let's make another function examine
03:09 - like this one but with different
03:11 - behavior so in here on let's define
03:13 - another private going and inside we have
03:17 - different behavior so we're going to say
03:21 - a different message and now up here
03:23 - let's say we assign this function on to
03:25 - this delegate then we call it okay and
03:26 - then we reassign our W with this
03:29 - function and we call the exact same dumb
03:31 - yet now let's test any of there you go
03:34 - we are calling the same delegate but
03:35 - getting two different behaviors
03:37 - delegates can also be multicast meaning
03:39 - they can trigger multiple functions so
03:41 - this is mainly what is used in the
03:43 - events so here we set the delegate to
03:45 - the first function and then we do plus
03:47 - equals our second function and then we
03:49 - call the delegate let's see and yep
03:51 - there you go we just call the function
03:52 - once but we get our two inner function
03:55 - calls so this is how the event
03:56 - publishers can have multiple subscribers
03:58 - and all of them get notified whenever
04:00 - the event changes so we can add
04:02 - functions but then we can also remove
04:03 - them so let's add both of them we call
04:06 - them then let's remove the second one
04:08 - and call again
04:08 - and if there it is the first time we get
04:10 - triggered both functions and second one
04:12 - only triggered the first one all right
04:13 - so this is how you define a delegate and
04:15 - assign it to a specific function now
04:17 - like I said delegates can have any
04:19 - return type and parameters so here for
04:22 - example we can make a public delegate
04:24 - let's make it return a boolean and let's
04:28 - say that we take an int parameter now we
04:32 - define our field of this type
04:36 - and down here we make a function that
04:39 - matches the signature so we're going to
04:41 - return a boolean call it something and
04:46 - we're going to have an integer as our
04:48 - parameter and then we can assign it the
04:54 - same way as previously so my tests don't
04:56 - delegate function and then we can simply
04:59 - count all right so we sign our w2 with
05:06 - this function and then we commit and
05:08 - pass in our parameters so let's see and
05:11 - if there is we have our function call
05:13 - written correctly awesome just one note
05:15 - here when you define a double yet you
05:17 - need to give it a name for the parameter
05:18 - so if you just do int you'll get an
05:20 - error so you need to define a name for
05:22 - the parameter however when you define a
05:25 - delegate function you don't actually
05:26 - have to use the exact same name so here
05:28 - it could be something completely
05:29 - different and the code still compiled
05:33 - some runs and everything is don't great
05:35 - now when it comes to creating a delegate
05:38 - function and assigning it we have
05:40 - several ways to do it one of the ways is
05:42 - how we did it just like here so we just
05:44 - assign it to a function that we defined
05:46 - that matches the signature now what this
05:48 - is actually doing in the background is
05:51 - we are doing a new test delegate and in
05:56 - this case we pass in our function so by
06:01 - doing this you're explicitly creating
06:02 - the delegate but again you can just keep
06:05 - it simple and just set it to assigned a
06:07 - function directly which one we cast our
06:08 - medical now another way we can create a
06:11 - delegate function and assign it is using
06:13 - anonymous methods so here we can take
06:16 - our delegate we can do equals and then
06:18 - we use the keyword delegate and we
06:20 - create our parameters that match the
06:22 - delegate parameters so in this case we
06:24 - have nothing and then we have our
06:25 - function body so just like this we
06:31 - defined an anonymous method that so much
06:33 - is the double gate signature and we can
06:35 - call it the same as any other method
06:37 - there you go there's our while working
06:39 - so this is how we create a function
06:41 - inside of a code block this is easier
06:43 - than having to create a separate
06:44 - function in most cases now another way
06:47 - of creating an
06:48 - as method is with a young lambda
06:50 - expression when the expressions are
06:52 - great because they are extremely tiny
06:54 - and compact so to do it all you need to
06:57 - do is really just open the parentheses
06:59 - with the defined arguments so in this
07:01 - case we have none then we do a little
07:04 - equals arrow and then we add our
07:06 - function block and yep that's it it's
07:11 - that simple so by doing this we are
07:13 - defining our lambda expression which
07:15 - works as a function that matches our
07:17 - delegate signature and we can then count
07:18 - if we're in the code there it is
07:20 - everything is working so this is the
07:23 - easiest and most compact way of defining
07:25 - a function if you've seen some of my
07:27 - videos you've certainly seen me use lime
07:28 - dissolve they are extremely useful in
07:30 - order to keep your code simple and easy
07:32 - to follow and again both anonymous
07:34 - methods and lambda expressions you can
07:36 - still return values so let's use the
07:39 - align the expression to define this
07:41 - function in here so the signature for
07:44 - this delegate is it returns a boolean
07:46 - and contains an integer so here for my
07:49 - lambda expression we open the
07:50 - parentheses we define our integer then
07:53 - we do one little arrow we add the code
07:55 - block and here we do simply return so in
07:58 - this case return what say I under five
08:00 - there you go here we have a valid lambda
08:03 - expression that is going to return
08:05 - boolean and take an int as a parameter
08:06 - if you have just a single statement then
08:09 - you can actually compact this even more
08:10 - and just get rid of all the curly
08:13 - brackets and put it just like this there
08:15 - you go this is a valid claim that
08:16 - expression that is going to return I
08:18 - under five if we were in the code yep
08:21 - everything is working now one issue with
08:23 - anonymous methods and lambdas is if you
08:25 - don't quite have their references
08:27 - they're created you won't be able to
08:28 - remove them from the delegate manual so
08:34 - for example here I'm signing two
08:36 - separate lambda expressions onto this
08:38 - delegate function then let's say we call
08:40 - it and then we want to remove only the
08:42 - first one the way we're doing here we
08:44 - can't really do that since we have no
08:45 - unique reference for this first function
08:47 - so if you need to add and then later
08:50 - remove a function from delegate that's
08:52 - better to make it an actual proper
08:53 - function instead of using an anonymous
08:55 - method now for the built-in delegates
08:57 - there are two extremely useful ones they
09:00 - are both inside system so
09:01 - make sure you go up and add using the
09:03 - system now the first one that you have
09:06 - is action so you define it using the
09:09 - action type here is our action and as
09:13 - you can see it is say don't get that
09:15 - returns void and thinks no parameters so
09:17 - the action is pretty much a built in
09:19 - type exactly of this one that we did up
09:20 - here and then you also have generic
09:23 - versions of action that take parameters
09:24 - of any type so you can find an action
09:27 - then you make it a generic and here you
09:30 - can see we have tons of options so for
09:32 - example it's an action that takes an
09:34 - integer and a fault so then we can
09:38 - assign this and this one won't take an
09:41 - integer and a float and returns void
09:48 - there you go here we have an action with
09:51 - an int and a float so for most cases you
09:53 - can probably use just normal actions
09:54 - instead of having to directly define
09:56 - your donuts okay so that's the built-in
09:58 - action type it takes any number of
10:00 - defined parameters and returns void now
10:03 - if you want to have a return value you
10:05 - have the other very useful built-in type
10:07 - which is the func this one by the font
10:10 - has a generic and the generic won't be
10:13 - our result so essentially our return
10:15 - type so in this case and let's say we
10:17 - want to return just a boolean and we
10:19 - give it a name so we go here we have a
10:23 - donut that won't take no parameters and
10:25 - return a bone so in this case we do no
10:28 - parameters and we return false so here's
10:33 - our font double gate and again here we
10:35 - do have tons of options for any
10:37 - parameter types and amounts that you
10:39 - want so you can define a funk the last
10:42 - one is always the results so let's say
10:44 - we want to return bullion but then let's
10:47 - say we want to receive an integer so
10:51 - just in here we have pretty much the
10:53 - exact same definition that we did up
10:54 - here so it returns a boolean and it
10:57 - takes an integer as a parameter so here
11:01 - we take an int and we return a bully
11:07 - so just like that all right so here we
11:10 - look the ton at how delegates can work
11:13 - how we define them how they're signed
11:14 - and the various built-in methods that
11:16 - make our job easier now that we've seen
11:18 - the underlying structure for how
11:20 - delegates work let's look at two
11:22 - examples first let's look at an example
11:24 - that shows how delegates really help
11:26 - keep your code clean and easier to use
11:27 - and then we're going to see how
11:29 - delegates help us write more modular
11:31 - code okay so for example over here I
11:33 - have a simple timer class it is meant to
11:36 - count down the number of seconds so I
11:38 - can trigger some action after some time
11:40 - you can see it has a function in order
11:42 - to set the timer then on update it
11:44 - counts down the seconds then we have a
11:46 - function to test if the timer is
11:48 - complete then the scene the script is
11:50 - simply attached to an empty game object
11:52 - then we have the game object that has
11:54 - the testing script we've been using and
11:56 - now let's say that we want something to
11:57 - happen after one second so let's use our
12:00 - timer script first here in our testing
12:06 - let's add a film for our action on
12:08 - timeline and now back in the editor and
12:15 - we can just drag the reference okay and
12:17 - now here as soon as we start let's say
12:19 - we want something to happen after one
12:21 - second so first we access the action on
12:23 - timer in order to set our timer let's
12:26 - set it to one second so that won't set
12:29 - the timer and start counting down and
12:31 - then let's do our private voice update
12:34 - and on update we need to check if the
12:36 - timer is in laps so we use that function
12:38 - call case timer complete so if it is
12:45 - complete then when you do a simple lock
12:47 - okay so just like this it should be
12:48 - working however you can probably already
12:50 - see an issue if we do it just like this
12:53 - then once the timer is elapsed it's
12:55 - going to trigger this function on every
12:56 - single frame so it said boolean to test
12:59 - if our timer has elapsed so we only run
13:01 - this once
13:07 - so if the timer has not elapsed and
13:09 - thumber is complete then we set it to
13:10 - complete and we set a time lapse so this
13:12 - will only run once okay let's test here
13:15 - we are and after one second yep there
13:17 - you go we have our timer complete all
13:19 - right so our timer work correctly so
13:21 - here we have a fully functioning Tamra
13:22 - code but as you can see this is
13:24 - extremely dirty we're checking for the
13:27 - timer if it's elapsed on every single
13:29 - frame on this class and we have to keep
13:31 - a bouillon inert to know if it's been
13:33 - triggered or not so instead of the timer
13:35 - being handled solely by the actual timer
13:37 - class the implementation of the timer is
13:39 - split into various places then if we
13:42 - want to use this same time or somewhere
13:44 - else then we need to implement the same
13:45 - thing over again
13:46 - so both classes are tightly coupled in a
13:48 - very nasty way now we can easily solve
13:50 - this problem with a simple delegate so
13:53 - on the timer class we can go up here and
13:55 - a using system and then we can make use
13:59 - of our built in action delegate and call
14:02 - our film let's say timer combat and now
14:05 - here when we set the timer let's receive
14:07 - an action for our timer combat then we
14:10 - set the film to what we receive and then
14:13 - on update we do our timer complete logic
14:21 - all right so here our timer class is now
14:23 - much more compact and now actually is
14:25 - responsible for everything related to
14:27 - the time so on update if the timer is
14:29 - better than 0 so if the timer is active
14:31 - then we count it down and after counting
14:33 - it down if it is complete then we call
14:35 - our comeback and now we can go back into
14:37 - our testing to see how we're going to
14:39 - use this function and in here instead of
14:41 - all of this nasty code all we need is a
14:43 - reference to our timer
14:44 - we don't need an update or anything like
14:46 - this we just need to call set timer and
14:49 - then we pass in the timer come back so
14:52 - again we can use a simple lambda
14:53 - expression then we just do our log so
14:58 - now everything is much more compact and
15:00 - all the camera code is actually handled
15:02 - by the timer class itself let's see so
15:05 - here we are and after one second if
15:07 - there you go we have our timer complete
15:08 - so you can see how just by using a very
15:11 - simple donut we made our class very
15:13 - clean and very easy to use so on the
15:15 - testing all we do is we tell our time
15:16 - and the action that we want to execute
15:18 - after that
15:19 - amount of time so here is a very simple
15:21 - timer class this is similar to the
15:23 - function timer from the code mock
15:24 - utilities I cover that specific class in
15:27 - another dedicated video so check that
15:29 - out if you want to learn more okay now
15:31 - let's look at an example of how
15:32 - delegates help our code be more modular
15:34 - so over here I have a simple character
15:37 - just moving around normally and I can
15:39 - press the mouse button in order to
15:40 - attack so let's look at the code here is
15:43 - the code on our update we're handling
15:45 - our movement and our attack and on the
15:48 - attack on we're doing is a simple input
15:49 - testing for the mouse button down and if
15:52 - so we're calling the punch attack
15:53 - function now let's say we have an
15:55 - upgrade system and we want the player to
15:57 - graduate from punching to using a sword
15:59 - so we could do that with a simple
16:01 - boolean so let's say we story prep ball
16:04 - count is using sword and starts off as
16:08 - false by default then we could have a
16:11 - function concept
16:12 - use sword we set that our boolean to
16:16 - true and then here we test if we are
16:20 - using sword then we use a sword attack
16:22 - and if not then we use the punch pack so
16:25 - this would be one valid approach but we
16:28 - could also solve this problem using a
16:30 - delegate so instead of storing a boolean
16:33 - and all this let's say our infection and
16:35 - this will be our attack function and by
16:40 - default on our start let's set the
16:42 - attack function to be our punch attack
16:46 - so that's our default and then we have
16:49 - set a sword instead of working with a
16:51 - boolean we set our delegate to be our
16:54 - sword attack and then when we're
16:57 - handling our inputs we don't need to do
16:59 - any condition on logic in here all we do
17:01 - is just access and use our delegate so
17:04 - that's it you can see how this is
17:05 - another potential approach so here just
17:07 - for testing let's do a simple input so
17:13 - when I press the M key I'm going to call
17:15 - set use forward which is going to modify
17:17 - the attack function delegate which is
17:19 - then used by the attack so let's see so
17:22 - over here is my player character move
17:24 - them around and I'm attacking using
17:26 - punches and kicks all right sounds good
17:27 - now I press ducky and now I use the
17:30 - exact same attack and there you go now
17:32 - I'm using
17:32 - sword instead so when it comes to
17:35 - handling the input in the attack both
17:36 - behaviors are doing the exact same thing
17:38 - what we're doing is using our technology
17:40 - which can be pointing to whatever
17:41 - function we want so for example I've
17:43 - used this type of implementation in the
17:45 - hotkey bar video in that video I store a
17:48 - dominant for each key input and we can
17:50 - easily swap out what pressing the one
17:52 - key does what the two key does and so on
17:54 - all of our function behavior is stored
17:56 - in a field which is linked to an input
17:58 - all right so here we learn all about
18:00 - delegates how they're defined how
18:02 - they're signed and how they can be used
18:03 - as you can see having the ability to
18:05 - store a function in a field is extremely
18:08 - useful in a multitude of scenarios now
18:10 - you have one extra tool you can use to
18:12 - solve your problems and keep your code
18:13 - clean when making your games this video
18:16 - is made possible thanks to these awesome
18:18 - supporters go to patreon.com/scishow t
18:20 - code monkey to get some perks and help
18:22 - keep the videos free for everyone as
18:24 - always you can download the project
18:25 - files and utilities from in Tacoma com
18:27 - subscribe the channel for more unity
18:29 - tutorials
18:30 - post any question have any comments and
18:31 - I'll see you next time
18:34 - [Music]

Cleaned transcript:

in this video we're going to learn how C sharp delegates work and how they're used we're going to see how they help us write more modular code and use compacts to simplify our logic let's begin so the liggett's are a very interesting C sharp feature essentially they allow you to store a function inside of a field this is extremely powerful in many scenarios you've seen me use delegates whenever I use one of the function classes from my utilities for example on the function periodic which triggers an action every certain amount of time it is a delegate to receive the function that won't be triggered so when I create the object I pass the behavior that I want to trigger in a previous video I covered events which also use a type of delegate not only they use the standard event handler as the event type and even handler is a type of delegate with a return type of void and a parameter signature of object and event arcs so let's take a look at how delegates are defined how they are created and assigned and various building types that make our job easier then we're going to look at two examples that show how delegates help keep our code clean and how they help us write more modular code this video is made possible thanks to these awesome supporters go to patreon.com/scishow to code monkey to get some perks and help keep the videos free for everyone delegates are defined as a function signature and return type but without any implementation so for example here I am in a simple empty script and first we define a donut and the way we do that is very simple first we write the accessor so for example public then we write the keyword delegate and now we define the delegate return type and signature so for the return type let's keep it simple and just return void then we need a name so let's call it our test delegate and now we define the parameters that make up the double yet signature but again to keep it simple let's make it no parameters at all so there we go here we define a donut that returns void and takes no parameters in here on we're doing is defining the actual delegate type so now we can make a field of this type so just like any other field let's say we make it private of type test delegate and call it our tests they'll get function now this film can be assigned with a function that matches this delegate signature so here on start let's say we set our test don't get function to equal something so now we define our function and again make sure that it has the same signature as identity so let's make it first of all will return void then we give it a name and again no parameters so this function declaration matches the delegate so now here we can simply assign this function onto this stomach and once we have assigned the delegate we can call it as if it were a normal function so we do test don't get function this case no parameter so just friends just like that we are calling the function that is stored within this field which in this case is going to be this function so let's just add a debug mode here just T to us alright so let's test and see any of there's our work so our function was correctly triggered through our delegate now let's make another function examine like this one but with different behavior so in here on let's define another private going and inside we have different behavior so we're going to say a different message and now up here let's say we assign this function on to this delegate then we call it okay and then we reassign our W with this function and we call the exact same dumb yet now let's test any of there you go we are calling the same delegate but getting two different behaviors delegates can also be multicast meaning they can trigger multiple functions so this is mainly what is used in the events so here we set the delegate to the first function and then we do plus equals our second function and then we call the delegate let's see and yep there you go we just call the function once but we get our two inner function calls so this is how the event publishers can have multiple subscribers and all of them get notified whenever the event changes so we can add functions but then we can also remove them so let's add both of them we call them then let's remove the second one and call again and if there it is the first time we get triggered both functions and second one only triggered the first one all right so this is how you define a delegate and assign it to a specific function now like I said delegates can have any return type and parameters so here for example we can make a public delegate let's make it return a boolean and let's say that we take an int parameter now we define our field of this type and down here we make a function that matches the signature so we're going to return a boolean call it something and we're going to have an integer as our parameter and then we can assign it the same way as previously so my tests don't delegate function and then we can simply count all right so we sign our w2 with this function and then we commit and pass in our parameters so let's see and if there is we have our function call written correctly awesome just one note here when you define a double yet you need to give it a name for the parameter so if you just do int you'll get an error so you need to define a name for the parameter however when you define a delegate function you don't actually have to use the exact same name so here it could be something completely different and the code still compiled some runs and everything is don't great now when it comes to creating a delegate function and assigning it we have several ways to do it one of the ways is how we did it just like here so we just assign it to a function that we defined that matches the signature now what this is actually doing in the background is we are doing a new test delegate and in this case we pass in our function so by doing this you're explicitly creating the delegate but again you can just keep it simple and just set it to assigned a function directly which one we cast our medical now another way we can create a delegate function and assign it is using anonymous methods so here we can take our delegate we can do equals and then we use the keyword delegate and we create our parameters that match the delegate parameters so in this case we have nothing and then we have our function body so just like this we defined an anonymous method that so much is the double gate signature and we can call it the same as any other method there you go there's our while working so this is how we create a function inside of a code block this is easier than having to create a separate function in most cases now another way of creating an as method is with a young lambda expression when the expressions are great because they are extremely tiny and compact so to do it all you need to do is really just open the parentheses with the defined arguments so in this case we have none then we do a little equals arrow and then we add our function block and yep that's it it's that simple so by doing this we are defining our lambda expression which works as a function that matches our delegate signature and we can then count if we're in the code there it is everything is working so this is the easiest and most compact way of defining a function if you've seen some of my videos you've certainly seen me use lime dissolve they are extremely useful in order to keep your code simple and easy to follow and again both anonymous methods and lambda expressions you can still return values so let's use the align the expression to define this function in here so the signature for this delegate is it returns a boolean and contains an integer so here for my lambda expression we open the parentheses we define our integer then we do one little arrow we add the code block and here we do simply return so in this case return what say I under five there you go here we have a valid lambda expression that is going to return boolean and take an int as a parameter if you have just a single statement then you can actually compact this even more and just get rid of all the curly brackets and put it just like this there you go this is a valid claim that expression that is going to return I under five if we were in the code yep everything is working now one issue with anonymous methods and lambdas is if you don't quite have their references they're created you won't be able to remove them from the delegate manual so for example here I'm signing two separate lambda expressions onto this delegate function then let's say we call it and then we want to remove only the first one the way we're doing here we can't really do that since we have no unique reference for this first function so if you need to add and then later remove a function from delegate that's better to make it an actual proper function instead of using an anonymous method now for the builtin delegates there are two extremely useful ones they are both inside system so make sure you go up and add using the system now the first one that you have is action so you define it using the action type here is our action and as you can see it is say don't get that returns void and thinks no parameters so the action is pretty much a built in type exactly of this one that we did up here and then you also have generic versions of action that take parameters of any type so you can find an action then you make it a generic and here you can see we have tons of options so for example it's an action that takes an integer and a fault so then we can assign this and this one won't take an integer and a float and returns void there you go here we have an action with an int and a float so for most cases you can probably use just normal actions instead of having to directly define your donuts okay so that's the builtin action type it takes any number of defined parameters and returns void now if you want to have a return value you have the other very useful builtin type which is the func this one by the font has a generic and the generic won't be our result so essentially our return type so in this case and let's say we want to return just a boolean and we give it a name so we go here we have a donut that won't take no parameters and return a bone so in this case we do no parameters and we return false so here's our font double gate and again here we do have tons of options for any parameter types and amounts that you want so you can define a funk the last one is always the results so let's say we want to return bullion but then let's say we want to receive an integer so just in here we have pretty much the exact same definition that we did up here so it returns a boolean and it takes an integer as a parameter so here we take an int and we return a bully so just like that all right so here we look the ton at how delegates can work how we define them how they're signed and the various builtin methods that make our job easier now that we've seen the underlying structure for how delegates work let's look at two examples first let's look at an example that shows how delegates really help keep your code clean and easier to use and then we're going to see how delegates help us write more modular code okay so for example over here I have a simple timer class it is meant to count down the number of seconds so I can trigger some action after some time you can see it has a function in order to set the timer then on update it counts down the seconds then we have a function to test if the timer is complete then the scene the script is simply attached to an empty game object then we have the game object that has the testing script we've been using and now let's say that we want something to happen after one second so let's use our timer script first here in our testing let's add a film for our action on timeline and now back in the editor and we can just drag the reference okay and now here as soon as we start let's say we want something to happen after one second so first we access the action on timer in order to set our timer let's set it to one second so that won't set the timer and start counting down and then let's do our private voice update and on update we need to check if the timer is in laps so we use that function call case timer complete so if it is complete then when you do a simple lock okay so just like this it should be working however you can probably already see an issue if we do it just like this then once the timer is elapsed it's going to trigger this function on every single frame so it said boolean to test if our timer has elapsed so we only run this once so if the timer has not elapsed and thumber is complete then we set it to complete and we set a time lapse so this will only run once okay let's test here we are and after one second yep there you go we have our timer complete all right so our timer work correctly so here we have a fully functioning Tamra code but as you can see this is extremely dirty we're checking for the timer if it's elapsed on every single frame on this class and we have to keep a bouillon inert to know if it's been triggered or not so instead of the timer being handled solely by the actual timer class the implementation of the timer is split into various places then if we want to use this same time or somewhere else then we need to implement the same thing over again so both classes are tightly coupled in a very nasty way now we can easily solve this problem with a simple delegate so on the timer class we can go up here and a using system and then we can make use of our built in action delegate and call our film let's say timer combat and now here when we set the timer let's receive an action for our timer combat then we set the film to what we receive and then on update we do our timer complete logic all right so here our timer class is now much more compact and now actually is responsible for everything related to the time so on update if the timer is better than 0 so if the timer is active then we count it down and after counting it down if it is complete then we call our comeback and now we can go back into our testing to see how we're going to use this function and in here instead of all of this nasty code all we need is a reference to our timer we don't need an update or anything like this we just need to call set timer and then we pass in the timer come back so again we can use a simple lambda expression then we just do our log so now everything is much more compact and all the camera code is actually handled by the timer class itself let's see so here we are and after one second if there you go we have our timer complete so you can see how just by using a very simple donut we made our class very clean and very easy to use so on the testing all we do is we tell our time and the action that we want to execute after that amount of time so here is a very simple timer class this is similar to the function timer from the code mock utilities I cover that specific class in another dedicated video so check that out if you want to learn more okay now let's look at an example of how delegates help our code be more modular so over here I have a simple character just moving around normally and I can press the mouse button in order to attack so let's look at the code here is the code on our update we're handling our movement and our attack and on the attack on we're doing is a simple input testing for the mouse button down and if so we're calling the punch attack function now let's say we have an upgrade system and we want the player to graduate from punching to using a sword so we could do that with a simple boolean so let's say we story prep ball count is using sword and starts off as false by default then we could have a function concept use sword we set that our boolean to true and then here we test if we are using sword then we use a sword attack and if not then we use the punch pack so this would be one valid approach but we could also solve this problem using a delegate so instead of storing a boolean and all this let's say our infection and this will be our attack function and by default on our start let's set the attack function to be our punch attack so that's our default and then we have set a sword instead of working with a boolean we set our delegate to be our sword attack and then when we're handling our inputs we don't need to do any condition on logic in here all we do is just access and use our delegate so that's it you can see how this is another potential approach so here just for testing let's do a simple input so when I press the M key I'm going to call set use forward which is going to modify the attack function delegate which is then used by the attack so let's see so over here is my player character move them around and I'm attacking using punches and kicks all right sounds good now I press ducky and now I use the exact same attack and there you go now I'm using sword instead so when it comes to handling the input in the attack both behaviors are doing the exact same thing what we're doing is using our technology which can be pointing to whatever function we want so for example I've used this type of implementation in the hotkey bar video in that video I store a dominant for each key input and we can easily swap out what pressing the one key does what the two key does and so on all of our function behavior is stored in a field which is linked to an input all right so here we learn all about delegates how they're defined how they're signed and how they can be used as you can see having the ability to store a function in a field is extremely useful in a multitude of scenarios now you have one extra tool you can use to solve your problems and keep your code clean when making your games this video is made possible thanks to these awesome supporters go to patreon.com/scishow t code monkey to get some perks and help keep the videos free for everyone as always you can download the project files and utilities from in Tacoma com subscribe the channel for more unity tutorials post any question have any comments and I'll see you next time
