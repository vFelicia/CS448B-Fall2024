With timestamps:

00:00 - in this video we're going to learn how
00:01 - to implement a star path finding in
00:03 - unity we're going to set up our world in
00:05 - a grid with some areas blocked and
00:07 - implement the algorithm to calculate
00:08 - valid paths then in the future video
00:11 - we're going to apply this same algorithm
00:13 - using unity dots let's begin
00:18 - [Music]
00:22 - hello and welcome I'm your code monkey
00:25 - and this channel is all about helping
00:26 - you learn how to make your own games
00:28 - with nf2 torrents made by a professional
00:30 - indie game developer so if you find the
00:32 - video helpful consider subscribing okay
00:34 - so this one we want to create over here
00:36 - is our map with the grid visible and you
00:38 - can see some black squares which
00:39 - represent the areas that are not
00:41 - walkable now in here I have my character
00:43 - and I can click to tell him where to go
00:45 - when I click the path is calculated and
00:48 - he then follows that path we can enable
00:50 - the debug view in order to see what's
00:52 - going on inside the algorithm so over
00:54 - here you can see the various values that
00:56 - the algorithm uses and you can see it
00:58 - and looking around for all the neighbors
01:02 - after going through the entire process
01:04 - you can see that it located the correct
01:06 - path
01:13 - all right so this is our goal let's get
01:15 - to it so before we get to the code let's
01:18 - first check out the theory the goal of
01:20 - the a-star path finding algorithm is to
01:22 - search to find a path from A to B so the
01:24 - algorithm already detects one couple and
01:27 - unwalkable areas and correctly
01:28 - identifies the surance path from A to B
01:31 - our map won't be grid based from each
01:34 - grid position we can move in all eight
01:36 - directions on each node essentially we
01:38 - have three values first we have the G
01:41 - cost that is the walking cost from the
01:43 - start node so for example to go from
01:45 - this node into this node it has a cost
01:47 - of 1 and we can also move diagonally so
01:50 - from this node into this node has a cost
01:52 - of 1.4 now in order for our code to work
01:54 - with ends instead of floats we're simply
01:56 - going to multiply our values by 10 so
01:59 - horizontally we have a cost of 10 and
02:01 - diagonally cost of 14 then we have the H
02:03 - cost this is the heuristic cost to reach
02:06 - our final goal
02:07 - so it's essentially an estimate to try
02:09 - to reach the goal our calculation is
02:11 - simply assuming there are no wall so
02:12 - moving straight towards our goal so in
02:14 - here our hitch cost more commonly going
02:16 - from here to here to here again this is
02:18 - just a basic guess to figure out which
02:20 - notes you prioritize and finally we have
02:22 - the F which is simply G + H so this
02:25 - combines our actual cost from the start
02:27 - combined with an estimate to reach the
02:28 - goal and we have our found number using
02:31 - this we can prioritize nodes with lower
02:33 - F since those are more likely to be
02:35 - closer to the goal the algorithm finally
02:37 - stops when our current node is our goal
02:39 - node so if we start here first we check
02:42 - on the neighbors these are unwelcome
02:43 - also they are ignored so it checks this
02:44 - one then checks these two neighbors then
02:47 - this one has a lower F value so it
02:48 - checks this one checks the neighbors for
02:50 - down then it starts locating that one
02:52 - and it says that this one is a go so we
02:54 - have our path so here as you can see the
02:56 - G cost is constantly increasing and the
02:58 - F cost is constantly decreasing then our
03:00 - path is traced back from the final node
03:02 - into our original so each node also
03:04 - knows what the previous path node was
03:06 - then for the algorithm to work we also
03:08 - have two lists for our notes the open
03:11 - list and the close list the open list is
03:13 - where we have all the nodes that are
03:14 - queued up for searching and the cause
03:16 - lists are all the nodes that have
03:17 - already been searched so we keep going
03:19 - until we find the current node on the
03:21 - open list or our open list is empty so
03:24 - we no longer have an
03:25 - or to search so there's no path okay so
03:27 - this is the theory now let's implement
03:29 - it so over here is my starting scene
03:31 - let's start off by making a knee you see
03:33 - sharp script call this our path line now
03:37 - in here let's get rid of all this and
03:39 - get rid of the motor behavior and let's
03:42 - make a constructor that receives a width
03:44 - and a height okay now we want to set up
03:48 - our path finding in a grid so for that
03:50 - let's use the grid commands that we
03:51 - created in the previous video here is a
03:53 - class it manages a grid with a certain
03:55 - width and height now we created this
03:58 - completely from scratch in a previous
03:59 - video so go check the link in the
04:00 - description if you haven't seen it
04:02 - already so using this class let's go
04:04 - into our path finding and in here and
04:06 - let's create our grid so appear with the
04:09 - final film for our grid and now in here
04:11 - we require a grid object so let's make
04:14 - one in here let's make a new C sharp
04:16 - script and let's call this the path node
04:18 - so this won't represent a single node in
04:20 - our path finding grid so let's make a
04:23 - constructor here on let's receive the
04:26 - normal stuff that we create in our grid
04:34 - okay we have our basics now we're also
04:38 - going to have a int for the G cost then
04:41 - for the H pass and the F cost okay so
04:45 - these are the three families that we
04:46 - need to calculate and finally we're also
04:48 - going to have a path node reference for
04:52 - the node that we came from previously so
04:54 - let's call it came from node so this is
04:57 - a node that we came from in order to
04:58 - reach this one this is what we're going
05:00 - to use in the end in order to trace back
05:02 - our steps to find the final path so now
05:04 - we can go back into our path finding and
05:06 - in here we make a grid of task node and
05:09 - call it our grid all right so just like
05:16 - this we are in Senshi ating our grid
05:17 - again check the link in the description
05:19 - to see how we made this grid class
05:21 - completely from scratch so now in here
05:23 - let's make sure that everything is
05:24 - working back in the editor and let's
05:26 - make a nice testing script let's make a
05:32 - testing game object and attach the
05:33 - script okay now here in our testing
05:36 - let's
05:36 - create our pathfinding just like that
05:41 - okay final let's go into our grid and
05:44 - here just make sure that we have show
05:46 - debug set to true so just like this we
05:49 - should be able to see our grid
05:50 - let's test and if there it is we have
05:52 - our grid correctly being instantiated
05:54 - all right
05:54 - great now let's get to work and
05:56 - implement the actual algorithm so we're
05:58 - here on the pathfinding let's make our
06:00 - function this will return a list of path
06:03 - note for our entire path let's call this
06:06 - fine path in here will receive an input
06:09 - the start X for the start y for the MX
06:13 - and for the end one so retaliating a
06:17 - path from these coordinates into these
06:19 - coordinates so in here first let's set
06:21 - up our open and closed lists and here we
06:27 - also add the start node to our open list
06:29 - and Nicolson list remains empty so to
06:31 - get the start node we go into the grid
06:33 - we get the grid object on start X and
06:35 - start line and we start with the start
06:39 - node on the open list again the open
06:41 - list are the ones that were queuing up
06:43 - for searching and the cantos only
06:44 - started ones we've already searched so
06:46 - we start off with the start node Kutub
06:48 - and nothing on the cons list
06:50 - now let's initialize our grid so we need
06:52 - to cycle through all of our nodes and
06:54 - set their G cards to infinite and
06:56 - calculate their F cost
07:04 - so to initialize we set the G cost to
07:08 - infinite so in that max family and then
07:13 - we calculate the F cost so let's make a
07:14 - function to do that so back here on the
07:20 - path node we simply make this and again
07:24 - the F cost is simply equals to the G cos
07:28 - plus the 8th class okay here it is now
07:33 - in order to initialize our own list we
07:34 - also need to set the came from node back
07:37 - into no so it doesn't contain an in data
07:39 - from the previous path ok so now let's
07:42 - begin by calculating the costs for our
07:44 - start node so the start node G cost this
07:48 - is the start node so the G score is 0
07:50 - since we start right in here then we
07:52 - need to set the start node H cost so in
07:55 - here we're going to have a function and
07:57 - let's call this calculate distance since
08:02 - that's pretty much what the H cost is
08:03 - it's a distance while ignoring all the
08:05 - apocryphal areas so here we have a
08:07 - commonly distance cost we take an A and
08:09 - a B and here we just want to calculate
08:11 - the quickest direct path so your
08:13 - horizontally as much as possible and
08:15 - then diagonally so let's go up here to
08:17 - define our basic costs so here we have
08:22 - the straight cost at 10 and diagonal
08:23 - cost at 14 the reason why it's 14 is
08:26 - essentially that is the mathematical
08:28 - value for a diagonal so we have a square
08:30 - root of 200 which is 14 ok so now we can
08:33 - go all the way down here
08:34 - and our final distance cost won't be the
08:37 - amount that we can move diagonally plus
08:39 - the amount that we have to move straight
08:41 - so the distance class is essentially our
08:42 - H cot so we can go up here in order to
08:45 - set the H fast for the distance cost
08:47 - between the start node and the end node
08:51 - ok so just like this and finally we can
08:54 - go into the start node and count like
08:56 - the F cost all right so this is our
08:59 - starting data for our algorithm and now
09:01 - in here we're going to have our cycle so
09:03 - we're going to do our cycle while the
09:05 - open list count is bigger than 0 so
09:08 - while we still have nodes on the open
09:09 - list in here we get the current node and
09:14 - now the current node will be the node on
09:15 - the open list with the lowest F cos
09:17 - so we're going to make a function to do
09:19 - that to return a pat node and let's call
09:24 - it get the lowest F cost node
09:28 - okay so here this we simply cycle
09:30 - through our entire node list and we get
09:33 - the only was staff cost note so now we
09:35 - can use this in here in order to get the
09:37 - current node we pass in the open list
09:38 - okay and now the first thing we do is
09:41 - check if this is our final note if it is
09:45 - our final node then we have reached our
09:46 - goal so here we return our calculated
09:49 - path to reach this node okay I'm let's
09:53 - just define this function in here it's
09:55 - going to return a list of path node and
09:58 - for now let's leave it empty we're going
10:00 - to make this function later okay for now
10:03 - let's keep going in here so if it is the
10:05 - end node then we complete the path that
10:07 - we took to reach that end node if it is
10:10 - not the end node then first of all we're
10:12 - going to remove the current from the
10:13 - open list so we're indicating that the
10:19 - current node has already been searched
10:20 - and we're going to add it into the code
10:22 - list okay so far so good
10:25 - now in here we're going to cycle through
10:27 - the neighbors of this current node so
10:30 - let's make a function to get our
10:31 - neighbors
10:41 - okay so here we have our neighbor code
10:44 - we simply take our current node then we
10:47 - check the one right to the left of it if
10:49 - it's valid so that's why we're checking
10:50 - above zero so if it is valid then we add
10:52 - on left one then we see if we have a
10:54 - node underneath and if so then we add
10:57 - the unless and down and then left up and
10:59 - then right right down right up down and
11:01 - up so just like this we have our eight
11:04 - neighbor positions if they are valid so
11:06 - we have our neighbor list and in here we
11:08 - cycle through it so we cycle through all
11:12 - the neighbors of the current node now in
11:15 - here first we check if the neighbor node
11:16 - is already on the closed list if the
11:19 - neighbor node is already on the constant
11:21 - list then that means we've already
11:22 - searched so we simply continue now if it
11:25 - isn't on the close list then we need to
11:27 - search in so in here on let's calculate
11:29 - a tentative G cos this is based on the
11:33 - current node G cost plus the movement
11:36 - cost to go from the current node into
11:37 - this neighbor node and now with this
11:41 - tentative G cost we're going to see if
11:43 - this one is lower than the actual G cost
11:45 - currently stored on the neighbor node so
11:47 - essentially we're trying to see if we
11:48 - have a faster path from the current node
11:49 - onto the neighbor node than we had
11:51 - previously
11:52 - if we do have a better path then let's
11:55 - obtain it we go into the neighbor we
11:57 - said he came from node to be our current
11:59 - node then we set the neighbor G cost to
12:03 - be our new tentative G cost
12:05 - finally we count only the new H cost to
12:10 - be distance between the neighbor and the
12:11 - end node and finally we calculate the F
12:14 - value okay so here we have updated all
12:17 - of the values for this neighbour node
12:19 - and then we simply check if it is not
12:21 - already on the open list so the open
12:23 - list does not contain our neighbour node
12:26 - then we add the neighborhood to the open
12:30 - list okay and that's it this is our
12:33 - complete algorithm cycle and now if we
12:36 - reach down here outside of the wild then
12:40 - that means we are out of nodes on the
12:43 - open list essentially this means that we
12:47 - search through the whole map and we
12:48 - could not find a path so in here let's
12:51 - simply return no
12:53 - so now finally the last thing we need is
12:54 - simile to implement this function here
12:56 - the account link path so in here again
12:58 - each path node contains a reference to
13:00 - the node that it came from so we can
13:02 - simply use this to retrace our steps
13:04 - so in here let's make a list of path
13:07 - node we start our path off on the end
13:11 - node then we calculate a current node
13:16 - which is going to start off with our end
13:19 - node and now we're going to do while the
13:21 - current node that came from node is not
13:24 - known so essentially while the current
13:26 - node has a parent we're going to add to
13:28 - the path the current node came from node
13:31 - and then we're going to update the
13:33 - current node to be the current node came
13:35 - from node so essentially we're
13:37 - constantly cycle through the parent
13:38 - until we reach one which no longer has a
13:40 - parent which won't be our start node so
13:42 - again here we're coming from the end
13:44 - going back into the beginning so in the
13:46 - end we simply need to reverse our path
13:48 - so path out reversed like that and we
13:51 - can finally return right great so we
13:54 - wrote quite a lot of code here now let's
13:56 - see if our algorithm has been correctly
13:58 - implemented for testing let's go into
14:00 - our testing script and in here let's
14:02 - test it on Mouse down
14:09 - so in here when we press the mouse down
14:11 - we get a vector3 for the mouse world
14:15 - position here I'm just using a function
14:18 - from the utility as long as you can
14:19 - download you Tony's for free from unity
14:21 - code Montcalm if you want to make it
14:23 - yourself here it is all we're doing is a
14:25 - warm camera screen to a point okay so we
14:28 - get the model on position then let's
14:30 - convert this into grid positions so
14:33 - we're going to the pathfinding we get
14:35 - the grid and then we get the XY
14:37 - positions and we pass in our mouse wrong
14:39 - position okay so now we have an x and a
14:42 - y that we can use so in here and let's
14:44 - calculate a path okay so here we have
15:04 - our function we get the mouse wrong
15:05 - position convert into an x and y we
15:08 - calculate a fine path starting from 0 0
15:10 - onto our mouse position if we don't have
15:13 - a path then simply use draw a line north
15:14 - to draw our path okay did she do it
15:17 - let's see okay here we are with our grid
15:19 - now I can click and we're going to see a
15:21 - path starting from 0 0 going into the
15:23 - mouse so let's click right in here and
15:25 - click and there you go there's our very
15:27 - nice path as you can see you'll from
15:29 - there there there there there now I can
15:31 - click wherever I want and the path is
15:33 - already automatically calculated so just
15:35 - like this we have correctly implemented
15:37 - a star path finding awesome now over
15:40 - here I have prepared a nice script that
15:41 - we can use to visualize the inner
15:43 - workings of the path finding so for
15:45 - example let's try to move to this square
15:47 - right here so I click there's the path
15:50 - correctly calculated now let's see how
15:51 - this path was calculated I can press
15:54 - space to go step by step
15:56 - there we go on the very first step it
15:58 - calculates the F cost in the middle G
15:59 - cost up there and H cos down there so G
16:02 - cost is 0 since this is the start node
16:04 - the H cos is 24 which is the assumption
16:06 - to get there so we got 10 here and 14 in
16:09 - here so we have 24 and the F cos is
16:11 - right there so now I can press space to
16:13 - go for the next step and here we go we
16:15 - start searching for the neighbors so
16:17 - again this neighbor has a G cost of 10
16:19 - since we moved from here to here so
16:20 - that's 10 and 14 to reach the goal
16:22 - she's here so 14 right there so the f
16:25 - course is still 24 now let's check the
16:27 - other neighbors
16:28 - sorry go with that neighbor account like
16:30 - the cost and that neighbor account with
16:32 - the cost so you can see the blue squares
16:33 - are the notes on our open list and now
16:36 - in the next cycle we're going to start
16:37 - searching from node with the lowest F so
16:40 - that means we're going to start
16:41 - searching either this one or this one
16:42 - but not this one so I hit space and
16:45 - there you go now this one is red which
16:47 - means it's on the close list so we have
16:48 - fully searched this node now we're
16:50 - searching this node so now we search the
16:52 - neighbors for this one search down one
16:55 - search down and then we also try to
16:57 - update any other neighbors now we go to
16:59 - the next one with the lowest cost which
17:01 - is this one I can remember this as our
17:03 - goal so now we check the neighbors on
17:05 - this one okay there it is you can see it
17:07 - completed all of the new neighbors and
17:09 - now we keep going and now we are
17:12 - searching our final node so the current
17:14 - node is our end node so we have finished
17:16 - our goal so we click and there you go
17:17 - there's our final path go from here to
17:19 - here to here so in this script we can
17:21 - easily visualize how the algorithm works
17:23 - so here I can click anywhere to view an
17:26 - animation of the algorithm at work and
17:28 - there you go as you can see constantly
17:29 - searching for the neighbors until it
17:30 - finds a path so click in here and there
17:32 - you go searching for those and
17:34 - constantly searching for neighbors
17:35 - constantly going from the lowest F cost
17:37 - and eventually it searches and it finds
17:40 - the goal
17:41 - alright so now with this working let's
17:43 - add some unwalkable
17:44 - areas let's go here into our path node
17:46 - and in here and let's add another field
17:49 - we're going to make this a boolean and
17:51 - college is walkable now by default
17:55 - adhere in the constructor let's set it
17:57 - to true and now all we need to do is go
18:00 - into our path finding and in here when
18:02 - we're inside our cycle when we're going
18:04 - through here cycling through all the
18:06 - neighbors in here all we need to do is
18:08 - check if the neighbor node if it is not
18:12 - walkable then we're simply going to add
18:15 - this to the close list and continue so
18:20 - here it is very simple we need to do is
18:21 - set this to false and now that node
18:23 - won't be ignore from our algorithm now
18:26 - over here I have a simple visual script
18:28 - all it's doing is drawing a quad on
18:30 - certain positions so where it's not
18:32 - walkable it's going to draw a black one
18:34 - if you'd like to see an end
18:36 - look into how this script works then
18:38 - check out the heatmap video linked in
18:39 - the description oh it's really doing is
18:41 - just drawing that black quad so in order
18:43 - for this crew to work on we need to do
18:45 - is concentrate in here so I to into our
18:47 - testing and here had a feel for the
18:50 - visual and we simply call set grid then
18:55 - we go to the path finding and get the
18:57 - grid
18:58 - alright now finally let's make it grid
19:00 - unwalkable by right clicking okay so
19:13 - when we right click we're simply
19:14 - swapping out the is walkable on this
19:16 - node so let's see okay so here we have
19:19 - our grid map
19:20 - now let's left-click and there you go
19:22 - there is the path like normal now let's
19:24 - right-click and there you go that one
19:25 - turns to black so that node is no longer
19:27 - walkable it's now found left click in
19:29 - here in theory it's going to go around
19:31 - this so click any of their yo our new
19:33 - path is calculated and it's avoiding the
19:35 - unwalkable area so I can walk a bunch of
19:37 - these ones then click out here and there
19:40 - you go there's the correct path going
19:41 - around everything so I can make this as
19:44 - complex as I want and as long as the
19:46 - path is possible it won't find it there
19:48 - you go just like that so you can view
19:50 - the inner workings of the algorithm
19:52 - there you go it's constantly checking
19:53 - all those checking all the neighbors now
19:55 - it's trying to go through there but it
19:57 - finds out that it can't go through but
19:59 - it's not trying to go until it reaches
20:00 - 146 on the lowest and keeps going keeps
20:03 - trying to search all that and nope and
20:05 - it finds through here so there you go
20:06 - there's our final path so regardless of
20:09 - whatever obstacles we place our
20:11 - algorithm will always find a path if
20:12 - there is one awesome so just like this
20:14 - our path finding algorithm is now
20:16 - working with blackberries now let's just
20:18 - make the map bigger and apply the path
20:20 - finding into a unit over here I have a
20:23 - simple script to move a unit it's
20:25 - already set up in order to follow a list
20:27 - of vector threes down here I have a
20:29 - function to set the target position and
20:31 - it's in here that we're going to
20:32 - complete our path so let's go into the
20:34 - path finding and now in here if we just
20:37 - have one path funny in our game then we
20:38 - can make it a nice singleton so we can
20:40 - easily access it so here we have a
20:45 - public instance
20:46 - we're setting it on the constructor so
20:48 - now using this we can go back into our
20:50 - character and in here let's set the path
20:53 - vector list and we go into the path
20:55 - finding X is the instance and now in
20:58 - here we want the find path so we want a
21:00 - version that returns a list of vector
21:02 - threes so in here let's make that let's
21:04 - make a function returns a list of vector
21:06 - trees wrong with find path and now in
21:09 - here let's also receive world positions
21:16 - so you're going to the grid to convert
21:19 - our world positions into grid positions
21:23 - then we use our normal function in order
21:25 - to find our path there in here first we
21:27 - need to check if the path returning was
21:29 - normal meaning if we did not find a path
21:33 - but if not then let's convert our own
21:36 - list of Pat nodes into a list of vector
21:38 - three so we cycle through all the path
21:42 - nodes in the path and we convert them
21:44 - into vector threes using the X and y I
21:46 - multiply it by the grid cell size all
21:48 - right so just like this we have this
21:49 - nice function it takes in a start world
21:51 - position a end world position and
21:53 - returns a list of vector trees that the
21:55 - unit can easily follow so if I can here
21:57 - we can use fine paths we pass in the
21:59 - start position which is this one so get
22:01 - position and then the end run position
22:03 - which will be our target position and
22:06 - just like this this returns a path
22:08 - vector on list and in here you can see
22:10 - the handle movement function if we do
22:12 - have a path vector list it grabs the
22:14 - next target position it's easy if it's
22:17 - far enough if so then we want to move
22:19 - towards it so you move our position
22:21 - towards our next Waypoint index and when
22:24 - we are close and we simply increase the
22:26 - index and if we are past account we stop
22:28 - moving
22:28 - sorry go very simple path finding
22:30 - movement and now we can go back into our
22:32 - testing and in here let's add a field
22:35 - for our character and when we on
22:40 - left-click let's our character to go to
22:42 - there so we set the target position into
22:47 - our mouths wrong position all right that
22:50 - should do it
22:50 - let's test so here we have our nice unit
22:53 - standing on 0 0 and now I can click
22:55 - somewhere let's see it move quick and
22:57 - there you it starts to move example like
22:59 - that
22:59 - and I click somewhere else and there you
23:01 - go the path is always correctly
23:02 - calculated now in here let's add some
23:05 - walls so at these walls now go down here
23:07 - now what's going here and there you go
23:09 - he goes around the walls so I can make
23:12 - the map really complex and now if I
23:14 - click all the way in here if there you
23:16 - go there he's going through down here
23:18 - down here down here and so on so as you
23:20 - can see the unit is automatically
23:22 - calculating the path and moving
23:23 - alongside it right awesome so just like
23:26 - this we have our a star path finding
23:28 - fully working we can calculate the path
23:30 - from any position into any other
23:32 - position now the class that we wrote
23:34 - here does work however in terms of
23:36 - performance it is far from optimal there
23:38 - are a lot of things down here that we
23:40 - can do to greatly increase our
23:41 - performance for example here on get
23:44 - Lewis F cast node in here on we're doing
23:46 - is a very linear search so the more
23:48 - nodes we have the worse this is going to
23:50 - be for performance something like a
23:52 - binary tree would be much faster and
23:54 - here on the neighbor code we're also
23:56 - dynamically identifying the neighbors
23:58 - for every single node we could improve
24:00 - this significantly by simply pre
24:01 - calculating all the neighbors as soon as
24:03 - we make the grid so as you can see over
24:05 - here we have plenty of ways that we can
24:07 - take this and continue improving upon it
24:09 - in order to make it a proper pathfinding
24:11 - script let me know in the comments if
24:13 - you don't like to see a video just focus
24:14 - on performance improvements now that
24:16 - this video is done I'm working on
24:18 - another video where I won't take this
24:19 - exact same class and convert it into
24:21 - using unity Docs so stay tuned for that
24:23 - as always you can download the project
24:25 - files in Ataris from unity code monkey
24:27 - comm subscribe to the channel for more
24:29 - unity tutorials post any questions I
24:31 - have in the comments and I'll see you
24:32 - next time
24:34 - [Music]

Cleaned transcript:

in this video we're going to learn how to implement a star path finding in unity we're going to set up our world in a grid with some areas blocked and implement the algorithm to calculate valid paths then in the future video we're going to apply this same algorithm using unity dots let's begin hello and welcome I'm your code monkey and this channel is all about helping you learn how to make your own games with nf2 torrents made by a professional indie game developer so if you find the video helpful consider subscribing okay so this one we want to create over here is our map with the grid visible and you can see some black squares which represent the areas that are not walkable now in here I have my character and I can click to tell him where to go when I click the path is calculated and he then follows that path we can enable the debug view in order to see what's going on inside the algorithm so over here you can see the various values that the algorithm uses and you can see it and looking around for all the neighbors after going through the entire process you can see that it located the correct path all right so this is our goal let's get to it so before we get to the code let's first check out the theory the goal of the astar path finding algorithm is to search to find a path from A to B so the algorithm already detects one couple and unwalkable areas and correctly identifies the surance path from A to B our map won't be grid based from each grid position we can move in all eight directions on each node essentially we have three values first we have the G cost that is the walking cost from the start node so for example to go from this node into this node it has a cost of 1 and we can also move diagonally so from this node into this node has a cost of 1.4 now in order for our code to work with ends instead of floats we're simply going to multiply our values by 10 so horizontally we have a cost of 10 and diagonally cost of 14 then we have the H cost this is the heuristic cost to reach our final goal so it's essentially an estimate to try to reach the goal our calculation is simply assuming there are no wall so moving straight towards our goal so in here our hitch cost more commonly going from here to here to here again this is just a basic guess to figure out which notes you prioritize and finally we have the F which is simply G + H so this combines our actual cost from the start combined with an estimate to reach the goal and we have our found number using this we can prioritize nodes with lower F since those are more likely to be closer to the goal the algorithm finally stops when our current node is our goal node so if we start here first we check on the neighbors these are unwelcome also they are ignored so it checks this one then checks these two neighbors then this one has a lower F value so it checks this one checks the neighbors for down then it starts locating that one and it says that this one is a go so we have our path so here as you can see the G cost is constantly increasing and the F cost is constantly decreasing then our path is traced back from the final node into our original so each node also knows what the previous path node was then for the algorithm to work we also have two lists for our notes the open list and the close list the open list is where we have all the nodes that are queued up for searching and the cause lists are all the nodes that have already been searched so we keep going until we find the current node on the open list or our open list is empty so we no longer have an or to search so there's no path okay so this is the theory now let's implement it so over here is my starting scene let's start off by making a knee you see sharp script call this our path line now in here let's get rid of all this and get rid of the motor behavior and let's make a constructor that receives a width and a height okay now we want to set up our path finding in a grid so for that let's use the grid commands that we created in the previous video here is a class it manages a grid with a certain width and height now we created this completely from scratch in a previous video so go check the link in the description if you haven't seen it already so using this class let's go into our path finding and in here and let's create our grid so appear with the final film for our grid and now in here we require a grid object so let's make one in here let's make a new C sharp script and let's call this the path node so this won't represent a single node in our path finding grid so let's make a constructor here on let's receive the normal stuff that we create in our grid okay we have our basics now we're also going to have a int for the G cost then for the H pass and the F cost okay so these are the three families that we need to calculate and finally we're also going to have a path node reference for the node that we came from previously so let's call it came from node so this is a node that we came from in order to reach this one this is what we're going to use in the end in order to trace back our steps to find the final path so now we can go back into our path finding and in here we make a grid of task node and call it our grid all right so just like this we are in Senshi ating our grid again check the link in the description to see how we made this grid class completely from scratch so now in here let's make sure that everything is working back in the editor and let's make a nice testing script let's make a testing game object and attach the script okay now here in our testing let's create our pathfinding just like that okay final let's go into our grid and here just make sure that we have show debug set to true so just like this we should be able to see our grid let's test and if there it is we have our grid correctly being instantiated all right great now let's get to work and implement the actual algorithm so we're here on the pathfinding let's make our function this will return a list of path note for our entire path let's call this fine path in here will receive an input the start X for the start y for the MX and for the end one so retaliating a path from these coordinates into these coordinates so in here first let's set up our open and closed lists and here we also add the start node to our open list and Nicolson list remains empty so to get the start node we go into the grid we get the grid object on start X and start line and we start with the start node on the open list again the open list are the ones that were queuing up for searching and the cantos only started ones we've already searched so we start off with the start node Kutub and nothing on the cons list now let's initialize our grid so we need to cycle through all of our nodes and set their G cards to infinite and calculate their F cost so to initialize we set the G cost to infinite so in that max family and then we calculate the F cost so let's make a function to do that so back here on the path node we simply make this and again the F cost is simply equals to the G cos plus the 8th class okay here it is now in order to initialize our own list we also need to set the came from node back into no so it doesn't contain an in data from the previous path ok so now let's begin by calculating the costs for our start node so the start node G cost this is the start node so the G score is 0 since we start right in here then we need to set the start node H cost so in here we're going to have a function and let's call this calculate distance since that's pretty much what the H cost is it's a distance while ignoring all the apocryphal areas so here we have a commonly distance cost we take an A and a B and here we just want to calculate the quickest direct path so your horizontally as much as possible and then diagonally so let's go up here to define our basic costs so here we have the straight cost at 10 and diagonal cost at 14 the reason why it's 14 is essentially that is the mathematical value for a diagonal so we have a square root of 200 which is 14 ok so now we can go all the way down here and our final distance cost won't be the amount that we can move diagonally plus the amount that we have to move straight so the distance class is essentially our H cot so we can go up here in order to set the H fast for the distance cost between the start node and the end node ok so just like this and finally we can go into the start node and count like the F cost all right so this is our starting data for our algorithm and now in here we're going to have our cycle so we're going to do our cycle while the open list count is bigger than 0 so while we still have nodes on the open list in here we get the current node and now the current node will be the node on the open list with the lowest F cos so we're going to make a function to do that to return a pat node and let's call it get the lowest F cost node okay so here this we simply cycle through our entire node list and we get the only was staff cost note so now we can use this in here in order to get the current node we pass in the open list okay and now the first thing we do is check if this is our final note if it is our final node then we have reached our goal so here we return our calculated path to reach this node okay I'm let's just define this function in here it's going to return a list of path node and for now let's leave it empty we're going to make this function later okay for now let's keep going in here so if it is the end node then we complete the path that we took to reach that end node if it is not the end node then first of all we're going to remove the current from the open list so we're indicating that the current node has already been searched and we're going to add it into the code list okay so far so good now in here we're going to cycle through the neighbors of this current node so let's make a function to get our neighbors okay so here we have our neighbor code we simply take our current node then we check the one right to the left of it if it's valid so that's why we're checking above zero so if it is valid then we add on left one then we see if we have a node underneath and if so then we add the unless and down and then left up and then right right down right up down and up so just like this we have our eight neighbor positions if they are valid so we have our neighbor list and in here we cycle through it so we cycle through all the neighbors of the current node now in here first we check if the neighbor node is already on the closed list if the neighbor node is already on the constant list then that means we've already searched so we simply continue now if it isn't on the close list then we need to search in so in here on let's calculate a tentative G cos this is based on the current node G cost plus the movement cost to go from the current node into this neighbor node and now with this tentative G cost we're going to see if this one is lower than the actual G cost currently stored on the neighbor node so essentially we're trying to see if we have a faster path from the current node onto the neighbor node than we had previously if we do have a better path then let's obtain it we go into the neighbor we said he came from node to be our current node then we set the neighbor G cost to be our new tentative G cost finally we count only the new H cost to be distance between the neighbor and the end node and finally we calculate the F value okay so here we have updated all of the values for this neighbour node and then we simply check if it is not already on the open list so the open list does not contain our neighbour node then we add the neighborhood to the open list okay and that's it this is our complete algorithm cycle and now if we reach down here outside of the wild then that means we are out of nodes on the open list essentially this means that we search through the whole map and we could not find a path so in here let's simply return no so now finally the last thing we need is simile to implement this function here the account link path so in here again each path node contains a reference to the node that it came from so we can simply use this to retrace our steps so in here let's make a list of path node we start our path off on the end node then we calculate a current node which is going to start off with our end node and now we're going to do while the current node that came from node is not known so essentially while the current node has a parent we're going to add to the path the current node came from node and then we're going to update the current node to be the current node came from node so essentially we're constantly cycle through the parent until we reach one which no longer has a parent which won't be our start node so again here we're coming from the end going back into the beginning so in the end we simply need to reverse our path so path out reversed like that and we can finally return right great so we wrote quite a lot of code here now let's see if our algorithm has been correctly implemented for testing let's go into our testing script and in here let's test it on Mouse down so in here when we press the mouse down we get a vector3 for the mouse world position here I'm just using a function from the utility as long as you can download you Tony's for free from unity code Montcalm if you want to make it yourself here it is all we're doing is a warm camera screen to a point okay so we get the model on position then let's convert this into grid positions so we're going to the pathfinding we get the grid and then we get the XY positions and we pass in our mouse wrong position okay so now we have an x and a y that we can use so in here and let's calculate a path okay so here we have our function we get the mouse wrong position convert into an x and y we calculate a fine path starting from 0 0 onto our mouse position if we don't have a path then simply use draw a line north to draw our path okay did she do it let's see okay here we are with our grid now I can click and we're going to see a path starting from 0 0 going into the mouse so let's click right in here and click and there you go there's our very nice path as you can see you'll from there there there there there now I can click wherever I want and the path is already automatically calculated so just like this we have correctly implemented a star path finding awesome now over here I have prepared a nice script that we can use to visualize the inner workings of the path finding so for example let's try to move to this square right here so I click there's the path correctly calculated now let's see how this path was calculated I can press space to go step by step there we go on the very first step it calculates the F cost in the middle G cost up there and H cos down there so G cost is 0 since this is the start node the H cos is 24 which is the assumption to get there so we got 10 here and 14 in here so we have 24 and the F cos is right there so now I can press space to go for the next step and here we go we start searching for the neighbors so again this neighbor has a G cost of 10 since we moved from here to here so that's 10 and 14 to reach the goal she's here so 14 right there so the f course is still 24 now let's check the other neighbors sorry go with that neighbor account like the cost and that neighbor account with the cost so you can see the blue squares are the notes on our open list and now in the next cycle we're going to start searching from node with the lowest F so that means we're going to start searching either this one or this one but not this one so I hit space and there you go now this one is red which means it's on the close list so we have fully searched this node now we're searching this node so now we search the neighbors for this one search down one search down and then we also try to update any other neighbors now we go to the next one with the lowest cost which is this one I can remember this as our goal so now we check the neighbors on this one okay there it is you can see it completed all of the new neighbors and now we keep going and now we are searching our final node so the current node is our end node so we have finished our goal so we click and there you go there's our final path go from here to here to here so in this script we can easily visualize how the algorithm works so here I can click anywhere to view an animation of the algorithm at work and there you go as you can see constantly searching for the neighbors until it finds a path so click in here and there you go searching for those and constantly searching for neighbors constantly going from the lowest F cost and eventually it searches and it finds the goal alright so now with this working let's add some unwalkable areas let's go here into our path node and in here and let's add another field we're going to make this a boolean and college is walkable now by default adhere in the constructor let's set it to true and now all we need to do is go into our path finding and in here when we're inside our cycle when we're going through here cycling through all the neighbors in here all we need to do is check if the neighbor node if it is not walkable then we're simply going to add this to the close list and continue so here it is very simple we need to do is set this to false and now that node won't be ignore from our algorithm now over here I have a simple visual script all it's doing is drawing a quad on certain positions so where it's not walkable it's going to draw a black one if you'd like to see an end look into how this script works then check out the heatmap video linked in the description oh it's really doing is just drawing that black quad so in order for this crew to work on we need to do is concentrate in here so I to into our testing and here had a feel for the visual and we simply call set grid then we go to the path finding and get the grid alright now finally let's make it grid unwalkable by right clicking okay so when we right click we're simply swapping out the is walkable on this node so let's see okay so here we have our grid map now let's leftclick and there you go there is the path like normal now let's rightclick and there you go that one turns to black so that node is no longer walkable it's now found left click in here in theory it's going to go around this so click any of their yo our new path is calculated and it's avoiding the unwalkable area so I can walk a bunch of these ones then click out here and there you go there's the correct path going around everything so I can make this as complex as I want and as long as the path is possible it won't find it there you go just like that so you can view the inner workings of the algorithm there you go it's constantly checking all those checking all the neighbors now it's trying to go through there but it finds out that it can't go through but it's not trying to go until it reaches 146 on the lowest and keeps going keeps trying to search all that and nope and it finds through here so there you go there's our final path so regardless of whatever obstacles we place our algorithm will always find a path if there is one awesome so just like this our path finding algorithm is now working with blackberries now let's just make the map bigger and apply the path finding into a unit over here I have a simple script to move a unit it's already set up in order to follow a list of vector threes down here I have a function to set the target position and it's in here that we're going to complete our path so let's go into the path finding and now in here if we just have one path funny in our game then we can make it a nice singleton so we can easily access it so here we have a public instance we're setting it on the constructor so now using this we can go back into our character and in here let's set the path vector list and we go into the path finding X is the instance and now in here we want the find path so we want a version that returns a list of vector threes so in here let's make that let's make a function returns a list of vector trees wrong with find path and now in here let's also receive world positions so you're going to the grid to convert our world positions into grid positions then we use our normal function in order to find our path there in here first we need to check if the path returning was normal meaning if we did not find a path but if not then let's convert our own list of Pat nodes into a list of vector three so we cycle through all the path nodes in the path and we convert them into vector threes using the X and y I multiply it by the grid cell size all right so just like this we have this nice function it takes in a start world position a end world position and returns a list of vector trees that the unit can easily follow so if I can here we can use fine paths we pass in the start position which is this one so get position and then the end run position which will be our target position and just like this this returns a path vector on list and in here you can see the handle movement function if we do have a path vector list it grabs the next target position it's easy if it's far enough if so then we want to move towards it so you move our position towards our next Waypoint index and when we are close and we simply increase the index and if we are past account we stop moving sorry go very simple path finding movement and now we can go back into our testing and in here let's add a field for our character and when we on leftclick let's our character to go to there so we set the target position into our mouths wrong position all right that should do it let's test so here we have our nice unit standing on 0 0 and now I can click somewhere let's see it move quick and there you it starts to move example like that and I click somewhere else and there you go the path is always correctly calculated now in here let's add some walls so at these walls now go down here now what's going here and there you go he goes around the walls so I can make the map really complex and now if I click all the way in here if there you go there he's going through down here down here down here and so on so as you can see the unit is automatically calculating the path and moving alongside it right awesome so just like this we have our a star path finding fully working we can calculate the path from any position into any other position now the class that we wrote here does work however in terms of performance it is far from optimal there are a lot of things down here that we can do to greatly increase our performance for example here on get Lewis F cast node in here on we're doing is a very linear search so the more nodes we have the worse this is going to be for performance something like a binary tree would be much faster and here on the neighbor code we're also dynamically identifying the neighbors for every single node we could improve this significantly by simply pre calculating all the neighbors as soon as we make the grid so as you can see over here we have plenty of ways that we can take this and continue improving upon it in order to make it a proper pathfinding script let me know in the comments if you don't like to see a video just focus on performance improvements now that this video is done I'm working on another video where I won't take this exact same class and convert it into using unity Docs so stay tuned for that as always you can download the project files in Ataris from unity code monkey comm subscribe to the channel for more unity tutorials post any questions I have in the comments and I'll see you next time
