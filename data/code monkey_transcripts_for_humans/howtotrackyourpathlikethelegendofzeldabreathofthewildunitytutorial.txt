With timestamps:

00:00 - hello and welcome I'm your code monkey
00:02 - and here let's build an interesting
00:03 - system to track the player as they play
00:05 - the game this is just like the mechanic
00:07 - in The Legend of Zelda breath of the
00:08 - wild where it showed in the map where
00:10 - you've been I'm guessing tears of the
00:12 - Kingdom will have the same mechanic it's
00:13 - pretty easy to do and it adds a fun New
00:15 - mechanic to your game so it's a great
00:17 - addition if your game is open world or
00:19 - has some large levels we're going to
00:20 - keep track of the path and show it on a
00:22 - minimap and on a full map and even add
00:25 - the ability to keep track of both a
00:26 - long-term path and a short-term path as
00:28 - well as some nice simple saving and
00:30 - loading do you want to learn how to make
00:32 - games I just recently published my two
00:34 - free complete courses the first one is
00:37 - for beginners and covers how to make a
00:38 - game starting from scratch and the
00:40 - second course on taking that game and
00:42 - making it multiplayer throughout the 17
00:44 - lectures I will be teaching you how to
00:45 - make a game and importantly I won't be
00:47 - teaching you how to write good high
00:48 - quality clean code meaning I will not be
00:50 - teaching you bad practices like you see
00:52 - in so many tutorials the game in this
00:54 - course is not a throwaway demo what I'm
00:56 - teaching you is on the same level of
00:57 - quality as what I use in my own
00:58 - Professional Steam games you can
01:00 - download the center assets and the
01:01 - project files for any lecturing the
01:03 - courses you can also browse the course
01:05 - website and see related videos and
01:06 - frequently asked questions for each
01:07 - lecture both these courses are commonly
01:09 - freeing there's nothing hidden behind
01:11 - the paywall but I did make an optional
01:13 - ad free paid version so if you find the
01:15 - course helpful and if you can afford it
01:17 - then you can pick up the optional
01:18 - ad-free version to support what I do and
01:21 - if you enjoy these free courses you can
01:22 - look at my other ones learn how to make
01:24 - a really awesome turn-based strategy
01:26 - game again with a heavy focus on writing
01:28 - good clean code or get my ultimate TNT
01:30 - overview course to learn about over 60
01:32 - Unity tones and features that you might
01:33 - not know about okay so let's add a
01:35 - simple system for keeping track of where
01:37 - the player has been here is my demo
01:39 - scene I've got a simple player character
01:41 - that I can move around this is using the
01:43 - third person Controller made by unity as
01:45 - part of the freestyle assets I just
01:47 - refactored it to match my konic sound
01:49 - and for the character in the world over
01:51 - here I'm using the Cindy fantasy Kings
01:52 - track there's a link in the description
01:54 - if you want to get it so over here I can
01:56 - move around and on the lower right
01:57 - corner I have a minimap which also
01:59 - covers in detail in a previous video
02:01 - it's showing me where I'm at right now
02:03 - so I'm on the lower left corner of this
02:05 - map now the goal is as the player moves
02:07 - I want to be able to see the actual path
02:09 - the player took okay so let's begin by
02:11 - making the path tracker so let's go
02:13 - ahead and create a brand new c-sharp
02:15 - script call this the path tracker let's
02:17 - make a new MTM object give it the same
02:19 - name attach the script and reset the
02:21 - transform okay now here we really just
02:23 - need the object that we're going to
02:24 - track in this case it's going to be the
02:26 - player but we can really track anything
02:27 - and all we need to track is really just
02:29 - a position so over here let's make a
02:32 - serialized feel and let's make it of
02:34 - type transform and call it the tracker
02:36 - transform okay like this and here in the
02:39 - editor and let's just write the play
02:40 - reference okay so now let's think of how
02:42 - can we do this basically we really just
02:44 - need this transform position and we just
02:46 - need to keep track of it over time so
02:48 - for that let's make a simple factor
02:49 - three list so a private in list of
02:52 - vector three let's make it the path
02:54 - position list then let's make a private
02:57 - by the week and on the Wake let's
02:58 - initialize the list so in your list okay
03:00 - then for adding position to the list
03:02 - let's make a private void update and now
03:04 - here we grab the tractor transform we
03:06 - grab the position and we just added onto
03:08 - the list so the path position list let's
03:10 - just add this brand new position okay so
03:12 - just like this it is indeed tracking
03:14 - however obviously like this we're going
03:15 - to end up with way too many points if
03:17 - the game is running at 60fps we're going
03:19 - to end up with 60 points per second and
03:21 - all of them are likely going to be very
03:23 - close to another so that's very wasteful
03:25 - let's add a simple timer to make sure
03:27 - that we grab the positions much less
03:29 - often so up here let's make a private
03:31 - float let's call it the track timer
03:34 - then down here on the update let's count
03:37 - it down so down by time.com time then we
03:39 - check if this one is under zero
03:42 - if so then let's reset the timer by a
03:44 - certain amount so let's define a track
03:46 - timer Max and let's say 0.2 F so we
03:49 - increase the track timer by the track
03:51 - timer Max so 0.2f really means 200
03:53 - milliseconds so with this we're going to
03:55 - track five times per second which should
03:57 - be more than good enough unless your
03:58 - player moves at some kind of insane
04:00 - speed at a regular speed this is
04:02 - probably going to be more than good
04:03 - enough so with this we are now only
04:05 - tracking the position five times per
04:07 - second but again like this if the player
04:08 - is standing still if so then we're still
04:11 - going to add positions that are all
04:12 - pretty much exactly the same so as
04:14 - another check let's just do a simple
04:16 - distance check let's first grab effector
04:19 - 3 for the last path position and for
04:22 - this one we go into the path position
04:23 - list we want the last one so that is
04:25 - going to be the final position on the
04:27 - list so let's do the count minus one
04:29 - okay so this is the last pass position
04:31 - then the effect of three for the New
04:33 - Path position and this one is going to
04:35 - be the tracker transform so tracker
04:37 - transform that position okay then we
04:40 - just do a vector 3 dot distance B
04:42 - between the last path position and the
04:44 - New Path position and you check if it's
04:46 - under some amount so let's define it
04:48 - let's call this the main path distance
04:50 - and let's say 0.5 units so we're only
04:53 - going to want to track if it is further
04:54 - than 5 units so over here if it is
04:56 - bigger than the Min path distance if
04:59 - this is correct if so then yep over here
05:02 - we are indeed going to add this position
05:03 - okay great pre-semble so with this
05:05 - instead of adding the position on every
05:08 - single update which would be 60
05:09 - positions per second instead of that now
05:11 - we are only testing five times per
05:12 - second and we're only going to add if
05:14 - it's far enough from the last one now
05:15 - one thing of course since over here we
05:17 - are accessing the last path position on
05:19 - the list because this if the enlist has
05:21 - no positions in this section I'm going
05:22 - to throw an error so a super simple fix
05:24 - is just to initialize the list with one
05:26 - position so let's make a private void
05:28 - start and on start let's go into the
05:30 - path position list and let's add the
05:32 - tracker transform dot position and the
05:34 - reason why I'm doing it on certain set
05:35 - of wake is because over here we are
05:36 - essentially accessing a external
05:38 - reference if you want to know more about
05:40 - why I'm doing it like this then make
05:42 - sure you watch my free complete course
05:43 - in there I constantly talk about how you
05:46 - should use a way to initialize the
05:47 - current object and access any external
05:49 - references only on start satisfy over
05:51 - here I'm initializing the path position
05:52 - list on awake and then just adding it on
05:54 - start okay so just like this we're
05:56 - already Gathering all the data that we
05:58 - need next thing is just a proper Visual
06:00 - and for that we actually have several
06:01 - options now one approach is to build the
06:03 - mesh yourself just like I showcased in
06:05 - the drum mesh video that's one option
06:07 - with that you have tons of control for
06:09 - how exactly you want the mesh to be I
06:11 - did exactly that in this script which is
06:13 - also included in the project files it
06:15 - uses a dynamic mesh to draw the player
06:16 - position so you can inspect this script
06:18 - to see how I implemented that method but
06:20 - since I already covered that in another
06:22 - video let's use a different method over
06:23 - here let's use unity's built-in lighten
06:26 - render so we're here let's go and create
06:27 - a new object let's go into effects and
06:30 - let's create the online there you go
06:32 - this creates an object using a line
06:33 - Runner component let's just reset the
06:35 - transform like name implies this helps
06:37 - us draw a line which is exactly what we
06:38 - want over here we have all kinds of
06:40 - options to play around the visual we're
06:42 - going to do that in a little bit for now
06:43 - let's just leave everything on default
06:45 - and for the points list let's leave it
06:47 - all as empty then over here on our path
06:49 - tracker script let's add a reference
06:50 - into the online render so let's set
06:52 - another serialized field of type line
06:54 - render for the inline render just like
06:56 - this then the other turn let's drag the
06:58 - reference on the path tracker and let's
06:59 - drag a reference to the online render
07:01 - and now back in our script let's make a
07:02 - simple function to refresh the visual so
07:05 - private Droid call it refresh Visual and
07:07 - over here first thing we do is we grab
07:09 - the online render and before we can
07:11 - actually update the position list first
07:13 - we need to set the position count that
07:15 - is how we can resize the underlying data
07:17 - structure that the Align render uses so
07:19 - over here the light rendered that
07:20 - position count and let's put it on the
07:22 - path positionlist.count and afterwards
07:25 - we can use the function so let's go into
07:27 - online render and use the function
07:28 - called set positions this one takes
07:31 - multiple positions and as you can see
07:33 - this one takes an array whereas we're
07:34 - using a list so we can just take our
07:37 - fast position list and convert it into
07:38 - an array by the way obviously one quick
07:40 - note here it would obviously be a lot
07:43 - more performant to just use the array on
07:45 - time instead of over here using a list
07:46 - but just like in a normally build my own
07:48 - Games first I get the logic working and
07:50 - only then do I worry about optimization
07:52 - so for now using a list up here and then
07:54 - converting to array this is going to be
07:56 - more than good enough for initial
07:57 - version of this system okay so that's
07:59 - really it now we need to do is just call
08:00 - this function whenever the pointless
08:02 - changes so up here when we add it on to
08:04 - the start once again the refresh is
08:06 - going to access an external reference so
08:08 - we should be doing it over here on start
08:09 - and then over here on the update when we
08:11 - add new position to list let's also
08:12 - refresh the visual okay so with this
08:14 - let's test all right so here we are and
08:16 - if I start moving this is simultaneously
08:19 - working and not really working now it is
08:21 - working because the path is actually
08:22 - being built now we can't really see it
08:24 - but if I pause the scene and over here
08:26 - we select the Align object we can see
08:28 - yep the Align mesh is indeed being
08:29 - created so there you go but it's now
08:31 - really working simply because the visual
08:33 - is directly on the floor which the
08:34 - Minima camera does have trouble seeing
08:36 - so again here we have several options
08:38 - now one option is to leave it just like
08:41 - this maybe lift it up a little bit so
08:43 - this is actually a bit more visible but
08:44 - this is one option if you wanted to show
08:46 - the path in the main camera and not just
08:48 - on the minimap camera however if you
08:50 - want a clean over overhead view then we
08:51 - should probably fix this and the fix is
08:53 - actually super simple all we need to do
08:55 - is really just apply an offset on the Y
08:57 - that way the enlightened render will no
08:58 - longer be positioned directly underneath
09:00 - the mesh so over here when we refresh
09:02 - the visual let's just do some basic
09:04 - logic so let's Define effective 3 array
09:06 - for the path position array and let's go
09:09 - into the path positional list and
09:11 - convert this into an array then let's
09:13 - just do a simple cycle through it so we
09:16 - cycle through the array and on the array
09:17 - on this index we just set the Y onto a
09:21 - certain y offset so let's define a
09:23 - constant so let's go up to the top of
09:25 - the file and Define a simple private
09:27 - cons float for the Y offset let's put it
09:31 - above all the meshes so something like
09:32 - 30f okay
09:33 - so we take the path position and we
09:35 - simply just raise them all onto this y
09:37 - offset this way the visual should now be
09:39 - high enough so that it is visible by the
09:41 - minimap camera so let's try so here we
09:43 - are and if I start moving and this is
09:46 - actually working but we have some issues
09:48 - with actually seeing it just because
09:49 - it's way too thin here we cannot see
09:51 - that the mesh is indeed being generated
09:53 - correctly above the entire map so that's
09:55 - good but we can't really see it just
09:56 - because the visual so let's set that up
09:58 - exactly as we want it now the first
10:00 - thing is over here on the width so this
10:02 - is essentially the thickness of the line
10:03 - let's increase this by quite a bit so
10:06 - some only five units this is pretty good
10:07 - then my project files I have a simple
10:09 - texture just with a simple Circle
10:11 - basically I want some dots to Showcase
10:13 - where the player has been the only
10:14 - important thing over here on this
10:15 - texture is really just the rep mode is
10:17 - set to repeat if this was set the clamp
10:19 - which was the default it wouldn't really
10:20 - work so it needs to be on repeat beyond
10:22 - that just the normal setup it's not the
10:24 - Align render let's just assign the
10:25 - material so here I've got a material for
10:27 - that texture and if there you go right
10:29 - away we see it so all of these settings
10:31 - are exactly the default so just the urp
10:33 - material just just over here using this
10:35 - base map except just like this it
10:36 - doesn't exactly work exactly as we
10:38 - wanted just yet so let's play around
10:40 - with some of these options now by
10:41 - default over here the important one is
10:43 - the texture mode by default it's set to
10:45 - stretch so throughout the entire path it
10:47 - is only showing the texture just once
10:49 - and stretching it that is not what we
10:51 - want inside what we want is for the
10:52 - texture to repeat itself so over here
10:54 - let's swap it out for tile and there you
10:55 - go right away we do see some nice dashes
10:57 - and all we need to do is play around
10:58 - over here with the texture scale so you
11:00 - can lower this about a little bit until
11:02 - we get just enough dashes alright yep
11:04 - picks I don't like this right now if we
11:06 - play through the game and I run around
11:08 - and I go and do a little bit of path
11:10 - over there on the minimap we can see the
11:13 - correct position is correctly being
11:14 - recorded so let me just move a little
11:16 - bit all right there's a nice big path
11:18 - and I can bring up the map and if there
11:20 - you go there's a nice path with the nice
11:22 - dashes telling me where I've been now
11:23 - alternatively instead of some dots you
11:25 - might actually want some dashes and if
11:27 - so it's actually really simple it really
11:28 - just requires changing the texture here
11:30 - I have a line Dash texture it is super
11:32 - simple literally just half of the
11:34 - texture has a white pixel and half of it
11:36 - is fully transparent so if I use this
11:38 - one instead and if there go instead of
11:40 - dots now I got some nice dashes and I
11:42 - can play around this in order to get
11:43 - more and less dashes so as you can see
11:45 - it's super easy to play around the
11:46 - visual for the Line Runner now one
11:48 - extraordinary important thing is over
11:49 - here we are editing this while the game
11:50 - is playing if we stop playing right now
11:52 - we're going to lose these changes so
11:54 - before we do that let's right click on
11:56 - the Align render and let's copy the
11:57 - component now we can stop playing and
11:59 - Now Yep this one reset but now we can
12:01 - right click and paste component values
12:03 - and now if we play again here I am and
12:05 - if I start walking around and there you
12:07 - go the inline positions on the dashes
12:09 - they are being visible very nice okay
12:12 - great so for the next thing let's make a
12:14 - nice optional mechanic let's make it so
12:16 - that the path arrays over time and let's
12:18 - actually keep track of both so let's
12:19 - keep track of a short-term path that
12:21 - shows where the player has been recently
12:23 - any long-term path where it shows
12:24 - everywhere the player has been in the
12:26 - entire playthrough of the game that's
12:27 - super simple just over here and let's
12:29 - make another list so we've got a path
12:30 - position list and let's make a complete
12:33 - fat position list
12:34 - then let's do pretty much the same thing
12:36 - so when initializing let's initialize
12:38 - both them when setting up the first one
12:40 - let's also add this one the tracker
12:42 - transform dot position then when we are
12:45 - adding to the path position list let's
12:46 - also add to this one and then for the
12:48 - normal path position after we add it
12:51 - let's just use some basic logic so let's
12:53 - check if the path position lists account
12:55 - if it is above a certain maximum so
12:57 - let's define here a maximum for the max
12:59 - path position list let's say a maximum
13:02 - of just 20 positions
13:04 - so if it is above so if it has more than
13:07 - 20 positions if so then let's really
13:09 - just remove the first one which is going
13:10 - to be the oldest one so the path
13:12 - position list and let's remove at and
13:15 - remove on position zero okay so that's
13:17 - really it super simple
13:18 - so here I am walking around and the path
13:21 - is indeed being created and let's see
13:23 - after I walk around enough and if there
13:25 - you go the path is no longer being
13:26 - created so as I move it is actually
13:28 - raising the previous position okay great
13:30 - now let's make a nice toggle to show
13:32 - both of them and actually increase the
13:33 - size by a little bit so first let's
13:35 - duplicate the visual and actually before
13:37 - that let's just rename this so the path
13:39 - tracker online renderer let's say this
13:41 - one is for the short path and duplicate
13:43 - this one and make it for the long path
13:45 - okay so we have two online renders and
13:48 - let's say that on the short path let's
13:49 - use the line Dash and let's also make it
13:52 - in a different color just to be a bit
13:53 - more visible maybe on a blue kind of
13:55 - like this okay then back in the script
13:57 - let's just add another reference so for
13:59 - the first one let's rename this so let's
14:01 - actually get rid of this line go into
14:02 - this one so over here rename or control
14:04 - RR let's rename this to the path line
14:07 - renderer and let's see if we hit this
14:08 - one and make the complete path line
14:10 - render okay these here in the editor and
14:13 - let's drag the reference so the short
14:14 - path and the long path okay then for the
14:17 - refreshing visual let's just refresh
14:19 - onto this one so we really just do the
14:21 - exact same logic so let's copy all this
14:23 - and we're going to make the same logic
14:24 - on the complete path render except for
14:27 - this one instead of the path this one is
14:28 - the complete path positional list so
14:31 - just swap out these ones and rename this
14:33 - one to the complete path position array
14:35 - we sag on through this one we update the
14:38 - Y offset and we set the positions okay
14:40 - great so both them are now being updated
14:42 - visually now let's just do some simple
14:44 - input in order to show one or the other
14:46 - so just for testing over here on the
14:48 - update let's assume if input.getkey down
14:51 - let's test for the testing key
14:54 - so here let's go into the path line
14:56 - renderer and let's set the enable equals
14:58 - not path Line run dot enabled so this is
15:00 - going to swap it and same thing for the
15:02 - other one so for the complete path Point
15:04 - render for this one also let's swap it
15:06 - and just over here in the editor let's
15:08 - make the short path enabled by default
15:10 - and long path let's disable this one
15:12 - okay so let's see so here we are and as
15:15 - I'm walking around yep I'm seeing the
15:17 - short path so I keep moving by a little
15:19 - bit all right there you go there's the
15:20 - short path and if I press the toggle and
15:22 - if there go no I see the long path okay
15:24 - great finally let's just add one super
15:26 - simple thing just some basic saving and
15:28 - loading now I cover that in detail in
15:29 - another video that video is a bit old
15:31 - but that process is still exactly how I
15:33 - handle saving and loading nowadays
15:34 - adding saving and loading for this
15:36 - mechanic is super simple over here back
15:38 - in our script let's just make a save
15:40 - object so a private class save object
15:44 - and inside we really just need to say
15:46 - both the player position and the
15:47 - positional list so a publicly factor
15:50 - three for the tracker position then
15:52 - let's also store and list the vector 3
15:54 - for the path position list and finally
15:57 - the complete path position list okay so
16:00 - this is our save object with all the
16:02 - data that we need to save now let's make
16:04 - some save and load functions so private
16:06 - void save and another one private void
16:08 - load then on Save it's super simple and
16:10 - lets you set the position so let's
16:12 - create a new save object save object
16:14 - equals a new save object and inside
16:16 - we're going to set first of all the
16:18 - tracker position it's the tracker
16:19 - transform dot position then the path
16:21 - position list equals the path position
16:23 - list any complete equals the complete
16:26 - okay so we have created our save object
16:28 - and assigned all of the data now let's
16:30 - just convert this object into Json so
16:33 - Json utility and convert into Json this
16:36 - object this is going to be a string for
16:37 - our Json again if you don't know what
16:39 - I'm doing here then go watch the
16:41 - dedicated saving unloading video over
16:43 - here I'm just quickly doing it because
16:44 - I've already explained that in detail in
16:46 - the other one so we got the Json then
16:48 - for some simple saving let's just go
16:50 - into the player prefs set a string let's
16:52 - call it track your path and save this
16:55 - Json alright so that's it that's how
16:57 - simple it is to save now for loading
16:59 - it's also simple it's really just doing
17:00 - the opposite so let's first of all go
17:02 - into player prefs in order to get the
17:04 - string get the string with the same name
17:06 - track your path and let's actually make
17:08 - sure to write some good coin code and
17:09 - not use some strings so let's go up here
17:11 - and make a nice constant so private
17:14 - constraint
17:15 - for the player prefs
17:18 - path tracker okay so we have this nice
17:21 - content let's just use it down here just
17:23 - make things a bit more clean okay so we
17:25 - get the string this this ring for Json
17:26 - then just go in Json utility and load it
17:29 - from Json for the save object with this
17:31 - Json so this returns a save object save
17:34 - object
17:35 - then over here on let's just update so
17:37 - update the path position list the save
17:39 - object grab the path position list same
17:42 - thing for the complete path positional
17:43 - list let's grab this one and set this
17:45 - one and the only tricky thing is
17:46 - actually the tracker transform position
17:48 - for this demo of the player that I'm
17:50 - using it's using a character controller
17:51 - so I can't really teleport just by
17:53 - moving the transform position so I'm
17:55 - just going to grab the tracker transform
17:57 - in order to get the component of the
17:59 - player type and inside I have a Teleport
18:02 - position now again obviously this part
18:03 - would be different depending on what
18:05 - character control you're using so just
18:07 - going to save object and grab the
18:08 - tracker position alright so that's it
18:10 - super simple as you can see saving and
18:11 - loading is really easy to add so let's
18:13 - just add some nice testing keys so up
18:16 - here let's add two more nice testing
18:18 - ones so let's say when we press y let's
18:20 - do a save and another one press U let's
18:24 - do a load and finally let's just make
18:26 - the short path a bit bigger so 20 was
18:29 - way too tiny so let's put it on 60 just
18:31 - like this and finally after we load
18:33 - let's just make sure to refresh the
18:35 - visual okay so it says alright so here I
18:38 - am walking around and I can see that the
18:40 - short path is being recorded so that's
18:42 - great let me just walk around by a
18:44 - little bit
18:50 - all right so I've walked around for
18:51 - quite a bit so I can look at the map yep
18:53 - there's my short-term path and yep
18:55 - there's my long-term path okay great now
18:57 - I press y for saving there you go it's
18:59 - saved so now let's quit the game and now
19:01 - let's play again here I am and I press
19:03 - unloading and there you go to teleports
19:05 - the player and if I open up the map if
19:07 - there go there's a short-term path and a
19:08 - long-term path so our path is perfectly
19:10 - safe all right awesome okay so here the
19:13 - system is fully working as you can see
19:15 - it's on pretty easy this is a great
19:17 - mechanic to add to any game that is
19:19 - semi-open world or has some large levels
19:21 - players always like seeing where they've
19:23 - been and now you can easily add that to
19:24 - your game alright hope that's useful
19:26 - check out these videos to learn some
19:28 - more thanks to these awesome patreon
19:30 - supporters for making these videos
19:31 - possible thank you for watching and I'll
19:33 - see you next time
19:39 - [Music]
19:41 - thank you

Cleaned transcript:

hello and welcome I'm your code monkey and here let's build an interesting system to track the player as they play the game this is just like the mechanic in The Legend of Zelda breath of the wild where it showed in the map where you've been I'm guessing tears of the Kingdom will have the same mechanic it's pretty easy to do and it adds a fun New mechanic to your game so it's a great addition if your game is open world or has some large levels we're going to keep track of the path and show it on a minimap and on a full map and even add the ability to keep track of both a longterm path and a shortterm path as well as some nice simple saving and loading do you want to learn how to make games I just recently published my two free complete courses the first one is for beginners and covers how to make a game starting from scratch and the second course on taking that game and making it multiplayer throughout the 17 lectures I will be teaching you how to make a game and importantly I won't be teaching you how to write good high quality clean code meaning I will not be teaching you bad practices like you see in so many tutorials the game in this course is not a throwaway demo what I'm teaching you is on the same level of quality as what I use in my own Professional Steam games you can download the center assets and the project files for any lecturing the courses you can also browse the course website and see related videos and frequently asked questions for each lecture both these courses are commonly freeing there's nothing hidden behind the paywall but I did make an optional ad free paid version so if you find the course helpful and if you can afford it then you can pick up the optional adfree version to support what I do and if you enjoy these free courses you can look at my other ones learn how to make a really awesome turnbased strategy game again with a heavy focus on writing good clean code or get my ultimate TNT overview course to learn about over 60 Unity tones and features that you might not know about okay so let's add a simple system for keeping track of where the player has been here is my demo scene I've got a simple player character that I can move around this is using the third person Controller made by unity as part of the freestyle assets I just refactored it to match my konic sound and for the character in the world over here I'm using the Cindy fantasy Kings track there's a link in the description if you want to get it so over here I can move around and on the lower right corner I have a minimap which also covers in detail in a previous video it's showing me where I'm at right now so I'm on the lower left corner of this map now the goal is as the player moves I want to be able to see the actual path the player took okay so let's begin by making the path tracker so let's go ahead and create a brand new csharp script call this the path tracker let's make a new MTM object give it the same name attach the script and reset the transform okay now here we really just need the object that we're going to track in this case it's going to be the player but we can really track anything and all we need to track is really just a position so over here let's make a serialized feel and let's make it of type transform and call it the tracker transform okay like this and here in the editor and let's just write the play reference okay so now let's think of how can we do this basically we really just need this transform position and we just need to keep track of it over time so for that let's make a simple factor three list so a private in list of vector three let's make it the path position list then let's make a private by the week and on the Wake let's initialize the list so in your list okay then for adding position to the list let's make a private void update and now here we grab the tractor transform we grab the position and we just added onto the list so the path position list let's just add this brand new position okay so just like this it is indeed tracking however obviously like this we're going to end up with way too many points if the game is running at 60fps we're going to end up with 60 points per second and all of them are likely going to be very close to another so that's very wasteful let's add a simple timer to make sure that we grab the positions much less often so up here let's make a private float let's call it the track timer then down here on the update let's count it down so down by time.com time then we check if this one is under zero if so then let's reset the timer by a certain amount so let's define a track timer Max and let's say 0.2 F so we increase the track timer by the track timer Max so 0.2f really means 200 milliseconds so with this we're going to track five times per second which should be more than good enough unless your player moves at some kind of insane speed at a regular speed this is probably going to be more than good enough so with this we are now only tracking the position five times per second but again like this if the player is standing still if so then we're still going to add positions that are all pretty much exactly the same so as another check let's just do a simple distance check let's first grab effector 3 for the last path position and for this one we go into the path position list we want the last one so that is going to be the final position on the list so let's do the count minus one okay so this is the last pass position then the effect of three for the New Path position and this one is going to be the tracker transform so tracker transform that position okay then we just do a vector 3 dot distance B between the last path position and the New Path position and you check if it's under some amount so let's define it let's call this the main path distance and let's say 0.5 units so we're only going to want to track if it is further than 5 units so over here if it is bigger than the Min path distance if this is correct if so then yep over here we are indeed going to add this position okay great presemble so with this instead of adding the position on every single update which would be 60 positions per second instead of that now we are only testing five times per second and we're only going to add if it's far enough from the last one now one thing of course since over here we are accessing the last path position on the list because this if the enlist has no positions in this section I'm going to throw an error so a super simple fix is just to initialize the list with one position so let's make a private void start and on start let's go into the path position list and let's add the tracker transform dot position and the reason why I'm doing it on certain set of wake is because over here we are essentially accessing a external reference if you want to know more about why I'm doing it like this then make sure you watch my free complete course in there I constantly talk about how you should use a way to initialize the current object and access any external references only on start satisfy over here I'm initializing the path position list on awake and then just adding it on start okay so just like this we're already Gathering all the data that we need next thing is just a proper Visual and for that we actually have several options now one approach is to build the mesh yourself just like I showcased in the drum mesh video that's one option with that you have tons of control for how exactly you want the mesh to be I did exactly that in this script which is also included in the project files it uses a dynamic mesh to draw the player position so you can inspect this script to see how I implemented that method but since I already covered that in another video let's use a different method over here let's use unity's builtin lighten render so we're here let's go and create a new object let's go into effects and let's create the online there you go this creates an object using a line Runner component let's just reset the transform like name implies this helps us draw a line which is exactly what we want over here we have all kinds of options to play around the visual we're going to do that in a little bit for now let's just leave everything on default and for the points list let's leave it all as empty then over here on our path tracker script let's add a reference into the online render so let's set another serialized field of type line render for the inline render just like this then the other turn let's drag the reference on the path tracker and let's drag a reference to the online render and now back in our script let's make a simple function to refresh the visual so private Droid call it refresh Visual and over here first thing we do is we grab the online render and before we can actually update the position list first we need to set the position count that is how we can resize the underlying data structure that the Align render uses so over here the light rendered that position count and let's put it on the path positionlist.count and afterwards we can use the function so let's go into online render and use the function called set positions this one takes multiple positions and as you can see this one takes an array whereas we're using a list so we can just take our fast position list and convert it into an array by the way obviously one quick note here it would obviously be a lot more performant to just use the array on time instead of over here using a list but just like in a normally build my own Games first I get the logic working and only then do I worry about optimization so for now using a list up here and then converting to array this is going to be more than good enough for initial version of this system okay so that's really it now we need to do is just call this function whenever the pointless changes so up here when we add it on to the start once again the refresh is going to access an external reference so we should be doing it over here on start and then over here on the update when we add new position to list let's also refresh the visual okay so with this let's test all right so here we are and if I start moving this is simultaneously working and not really working now it is working because the path is actually being built now we can't really see it but if I pause the scene and over here we select the Align object we can see yep the Align mesh is indeed being created so there you go but it's now really working simply because the visual is directly on the floor which the Minima camera does have trouble seeing so again here we have several options now one option is to leave it just like this maybe lift it up a little bit so this is actually a bit more visible but this is one option if you wanted to show the path in the main camera and not just on the minimap camera however if you want a clean over overhead view then we should probably fix this and the fix is actually super simple all we need to do is really just apply an offset on the Y that way the enlightened render will no longer be positioned directly underneath the mesh so over here when we refresh the visual let's just do some basic logic so let's Define effective 3 array for the path position array and let's go into the path positional list and convert this into an array then let's just do a simple cycle through it so we cycle through the array and on the array on this index we just set the Y onto a certain y offset so let's define a constant so let's go up to the top of the file and Define a simple private cons float for the Y offset let's put it above all the meshes so something like 30f okay so we take the path position and we simply just raise them all onto this y offset this way the visual should now be high enough so that it is visible by the minimap camera so let's try so here we are and if I start moving and this is actually working but we have some issues with actually seeing it just because it's way too thin here we cannot see that the mesh is indeed being generated correctly above the entire map so that's good but we can't really see it just because the visual so let's set that up exactly as we want it now the first thing is over here on the width so this is essentially the thickness of the line let's increase this by quite a bit so some only five units this is pretty good then my project files I have a simple texture just with a simple Circle basically I want some dots to Showcase where the player has been the only important thing over here on this texture is really just the rep mode is set to repeat if this was set the clamp which was the default it wouldn't really work so it needs to be on repeat beyond that just the normal setup it's not the Align render let's just assign the material so here I've got a material for that texture and if there you go right away we see it so all of these settings are exactly the default so just the urp material just just over here using this base map except just like this it doesn't exactly work exactly as we wanted just yet so let's play around with some of these options now by default over here the important one is the texture mode by default it's set to stretch so throughout the entire path it is only showing the texture just once and stretching it that is not what we want inside what we want is for the texture to repeat itself so over here let's swap it out for tile and there you go right away we do see some nice dashes and all we need to do is play around over here with the texture scale so you can lower this about a little bit until we get just enough dashes alright yep picks I don't like this right now if we play through the game and I run around and I go and do a little bit of path over there on the minimap we can see the correct position is correctly being recorded so let me just move a little bit all right there's a nice big path and I can bring up the map and if there you go there's a nice path with the nice dashes telling me where I've been now alternatively instead of some dots you might actually want some dashes and if so it's actually really simple it really just requires changing the texture here I have a line Dash texture it is super simple literally just half of the texture has a white pixel and half of it is fully transparent so if I use this one instead and if there go instead of dots now I got some nice dashes and I can play around this in order to get more and less dashes so as you can see it's super easy to play around the visual for the Line Runner now one extraordinary important thing is over here we are editing this while the game is playing if we stop playing right now we're going to lose these changes so before we do that let's right click on the Align render and let's copy the component now we can stop playing and Now Yep this one reset but now we can right click and paste component values and now if we play again here I am and if I start walking around and there you go the inline positions on the dashes they are being visible very nice okay great so for the next thing let's make a nice optional mechanic let's make it so that the path arrays over time and let's actually keep track of both so let's keep track of a shortterm path that shows where the player has been recently any longterm path where it shows everywhere the player has been in the entire playthrough of the game that's super simple just over here and let's make another list so we've got a path position list and let's make a complete fat position list then let's do pretty much the same thing so when initializing let's initialize both them when setting up the first one let's also add this one the tracker transform dot position then when we are adding to the path position list let's also add to this one and then for the normal path position after we add it let's just use some basic logic so let's check if the path position lists account if it is above a certain maximum so let's define here a maximum for the max path position list let's say a maximum of just 20 positions so if it is above so if it has more than 20 positions if so then let's really just remove the first one which is going to be the oldest one so the path position list and let's remove at and remove on position zero okay so that's really it super simple so here I am walking around and the path is indeed being created and let's see after I walk around enough and if there you go the path is no longer being created so as I move it is actually raising the previous position okay great now let's make a nice toggle to show both of them and actually increase the size by a little bit so first let's duplicate the visual and actually before that let's just rename this so the path tracker online renderer let's say this one is for the short path and duplicate this one and make it for the long path okay so we have two online renders and let's say that on the short path let's use the line Dash and let's also make it in a different color just to be a bit more visible maybe on a blue kind of like this okay then back in the script let's just add another reference so for the first one let's rename this so let's actually get rid of this line go into this one so over here rename or control RR let's rename this to the path line renderer and let's see if we hit this one and make the complete path line render okay these here in the editor and let's drag the reference so the short path and the long path okay then for the refreshing visual let's just refresh onto this one so we really just do the exact same logic so let's copy all this and we're going to make the same logic on the complete path render except for this one instead of the path this one is the complete path positional list so just swap out these ones and rename this one to the complete path position array we sag on through this one we update the Y offset and we set the positions okay great so both them are now being updated visually now let's just do some simple input in order to show one or the other so just for testing over here on the update let's assume if input.getkey down let's test for the testing key so here let's go into the path line renderer and let's set the enable equals not path Line run dot enabled so this is going to swap it and same thing for the other one so for the complete path Point render for this one also let's swap it and just over here in the editor let's make the short path enabled by default and long path let's disable this one okay so let's see so here we are and as I'm walking around yep I'm seeing the short path so I keep moving by a little bit all right there you go there's the short path and if I press the toggle and if there go no I see the long path okay great finally let's just add one super simple thing just some basic saving and loading now I cover that in detail in another video that video is a bit old but that process is still exactly how I handle saving and loading nowadays adding saving and loading for this mechanic is super simple over here back in our script let's just make a save object so a private class save object and inside we really just need to say both the player position and the positional list so a publicly factor three for the tracker position then let's also store and list the vector 3 for the path position list and finally the complete path position list okay so this is our save object with all the data that we need to save now let's make some save and load functions so private void save and another one private void load then on Save it's super simple and lets you set the position so let's create a new save object save object equals a new save object and inside we're going to set first of all the tracker position it's the tracker transform dot position then the path position list equals the path position list any complete equals the complete okay so we have created our save object and assigned all of the data now let's just convert this object into Json so Json utility and convert into Json this object this is going to be a string for our Json again if you don't know what I'm doing here then go watch the dedicated saving unloading video over here I'm just quickly doing it because I've already explained that in detail in the other one so we got the Json then for some simple saving let's just go into the player prefs set a string let's call it track your path and save this Json alright so that's it that's how simple it is to save now for loading it's also simple it's really just doing the opposite so let's first of all go into player prefs in order to get the string get the string with the same name track your path and let's actually make sure to write some good coin code and not use some strings so let's go up here and make a nice constant so private constraint for the player prefs path tracker okay so we have this nice content let's just use it down here just make things a bit more clean okay so we get the string this this ring for Json then just go in Json utility and load it from Json for the save object with this Json so this returns a save object save object then over here on let's just update so update the path position list the save object grab the path position list same thing for the complete path positional list let's grab this one and set this one and the only tricky thing is actually the tracker transform position for this demo of the player that I'm using it's using a character controller so I can't really teleport just by moving the transform position so I'm just going to grab the tracker transform in order to get the component of the player type and inside I have a Teleport position now again obviously this part would be different depending on what character control you're using so just going to save object and grab the tracker position alright so that's it super simple as you can see saving and loading is really easy to add so let's just add some nice testing keys so up here let's add two more nice testing ones so let's say when we press y let's do a save and another one press U let's do a load and finally let's just make the short path a bit bigger so 20 was way too tiny so let's put it on 60 just like this and finally after we load let's just make sure to refresh the visual okay so it says alright so here I am walking around and I can see that the short path is being recorded so that's great let me just walk around by a little bit all right so I've walked around for quite a bit so I can look at the map yep there's my shortterm path and yep there's my longterm path okay great now I press y for saving there you go it's saved so now let's quit the game and now let's play again here I am and I press unloading and there you go to teleports the player and if I open up the map if there go there's a shortterm path and a longterm path so our path is perfectly safe all right awesome okay so here the system is fully working as you can see it's on pretty easy this is a great mechanic to add to any game that is semiopen world or has some large levels players always like seeing where they've been and now you can easily add that to your game alright hope that's useful check out these videos to learn some more thanks to these awesome patreon supporters for making these videos possible thank you for watching and I'll see you next time thank you
