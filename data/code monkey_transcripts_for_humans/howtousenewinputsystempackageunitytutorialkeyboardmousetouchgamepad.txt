With timestamps:

00:00 - hello and welcome i'm your code monkey
00:02 - and here let's learn how to use the new
00:03 - input system
00:04 - this video is pretty big but it's the
00:06 - only video you need in order to learn
00:08 - how to use the new input system
00:09 - this is an excellent package that makes
00:11 - managing multiple inputs of different
00:13 - types
00:13 - very easy it looks a bit daunting at
00:15 - first but once you understand how it
00:17 - works it becomes actually quite easy to
00:19 - work with
00:19 - and of course the benefits of this
00:21 - system are immense once you have
00:23 - everything set up in your game working
00:24 - with the actions that you defined
00:26 - after that's done then your game is
00:28 - instantly playable with the mousing
00:29 - keyboard
00:30 - or touch input or maybe an xbox or
00:32 - playstation controller
00:33 - all of that works seamlessly also this
00:36 - video is in lecture taken from my
00:37 - ultimate unity overview course
00:39 - unity is massive so in the course i
00:41 - explain over 40 features and tools of
00:43 - the engine that you might
00:44 - not know about there's individual
00:45 - lectures explaining tons of things
00:47 - like shadowgraph assembly definitions
00:49 - pro builder the video player and so on
00:51 - also the course will be continuously
00:53 - updated with free updates as i add more
00:55 - lectures explaining more tools and
00:56 - features
00:57 - this specific lecture was added as a
00:59 - part of the first free update along with
01:01 - 10 other new lectures
01:03 - so go ahead get the phone course and
01:04 - learn how to master all the unity tools
01:06 - to help you make better games faster
01:08 - in this lecture we're going to learn all
01:10 - about the new input system package
01:12 - this is a lot more capable than the
01:14 - legacy input manager and it easily
01:16 - allows you to handle input from multiple
01:17 - sources without any issues
01:19 - so you can make your games work with a
01:21 - mouse and keyboard or an xbox gamepad or
01:23 - a playstation controller and all of it
01:25 - works seamlessly
01:26 - but naturally all of those awesome
01:28 - features come at the cost of slightly
01:30 - more complexity
01:31 - however once you understand how it's all
01:32 - set up what is an action what is an
01:34 - input and so on
01:36 - once you understand the basics of the
01:37 - system it's actually quite simple to use
01:39 - okay so let's learn how it works first
01:42 - up we need to install it by going into
01:43 - the package manager
01:45 - make sure you're on the unity registry
01:47 - then scroll down
01:48 - and find the input system package then
01:50 - just go ahead and
01:51 - install it and also over here you've got
01:53 - a whole bunch of samples that you can
01:55 - download to inspect if you want to see
01:56 - how they all work
01:57 - so these are some very specific
01:59 - scenarios so maybe they can be helpful
02:01 - now when you install you might see a
02:02 - message talking about enabling the new
02:04 - input system or the old input manager
02:07 - you've got two options you can click on
02:09 - yes which won't disable the old input
02:11 - manager and enable the new input system
02:13 - or you can click on no so nothing
02:15 - changes instead of using that window you
02:17 - can instead go into edit
02:18 - and go down here into project settings
02:21 - then go on to the player tab
02:23 - and then down here scroll expand the
02:24 - other settings scroll down here until
02:26 - you see the active input handling
02:28 - and over here you can select the old one
02:30 - the new one or you can select both of
02:32 - them
02:32 - now i cover the differences between both
02:34 - of them in another lecture so go watch
02:36 - that if you haven't seen it yet
02:37 - but essentially i find that they both
02:39 - have their use cases so here i just pick
02:41 - both
02:42 - and when you change this it restarts the
02:43 - ent editor
02:45 - okay now to start actually using the new
02:47 - input system the first thing you need is
02:49 - to create an input actions asset
02:51 - this is an actual asset in your project
02:53 - files so you just right click on some
02:55 - folder go into create
02:57 - and then scroll down here until you find
02:58 - the input actions
03:00 - so create it give it a name like player
03:02 - input actions
03:04 - and then double click on it so when you
03:06 - do out pops out the input actions window
03:09 - now this is where you're going to define
03:10 - all the actions and inputs that you can
03:12 - then use in your game
03:13 - so you see this separated in three
03:15 - groups you've got action maps actions
03:17 - and properties
03:18 - now let's add an action map by clicking
03:20 - over here on the plus icon
03:22 - so an action map is how you organize
03:24 - various actions
03:25 - for example if you had a game where you
03:27 - have a player that can walk around the
03:28 - world but also enter vehicles
03:30 - you would make one action map for the
03:32 - player walking another one for the
03:34 - vehicle inputs
03:35 - maybe yet another one for the ui for
03:36 - while the game is paused and so on
03:39 - so using multiple action maps really
03:40 - helps keep things nice and organized by
03:42 - having distinct action maps instead of
03:44 - just a huge list of actions
03:46 - so let's call this one just the normal
03:48 - player next up are the individual
03:50 - actions
03:51 - so this is what actions your game can
03:53 - take like for example move or shoot
03:55 - so for example let's name this simple
03:57 - action just jump
03:59 - then over here on the properties you can
04:00 - see the action type so it's a drop down
04:02 - menu you can select from value button
04:04 - and pass through
04:05 - now value is for continuous inputs so
04:08 - something like movement being controlled
04:09 - by a joystick would be a value type
04:12 - button is like the name implies for
04:13 - things that work like buttons so
04:15 - something where you press and release
04:17 - then passthrough is similar to value but
04:19 - it bypasses something called
04:21 - disambiguation which is the process
04:23 - through which the input system decides
04:24 - which input is active
04:26 - but for now don't worry about that let's
04:28 - just focus on value and button
04:30 - now this is a jump action so let's make
04:32 - it a button then we have interactions
04:34 - this is the various ways that we can
04:36 - interact with an action of this type
04:38 - so for a button you've got the whole
04:40 - multi-tab press and so on
04:42 - if you just want a basic button pressed
04:44 - and you don't need to add anything
04:45 - that's the default
04:47 - and finally processors so this is how
04:49 - you can apply some processing to this
04:51 - specific action itself
04:52 - this is more useful for when dealing
04:54 - with joystick inputs for adding a dead
04:56 - zone and so on but we'll see that in a
04:57 - bit
04:58 - okay so when you create a new action it
05:00 - also created a new binding
05:02 - if it didn't you can just right click
05:03 - and add a binding so the binding this is
05:06 - the actual physical input that we want
05:08 - to tie into this action
05:10 - then for selecting the physical input
05:12 - you can click on this drop down menu and
05:14 - manually select it so go into the
05:15 - gamepad and over here you see all the
05:17 - various buttons that you can map
05:19 - alternatively for more advanced use case
05:21 - you can turn this into a text box and
05:22 - over here type in the
05:24 - actual button this is a special syntax
05:26 - used by the input system so again for
05:28 - now don't worry about that let's keep
05:30 - things simple
05:31 - and the simplest of all is just to click
05:32 - on this button that's named listen
05:34 - so when you click now you can press any
05:36 - key you want
05:37 - so in my case for jump let's press the
05:39 - space bar and there you go that one
05:41 - listens to the spacebar on the keyboard
05:43 - and just select it all right so with
05:45 - that we have the most basic input asset
05:47 - done
05:48 - we made the player action map inside we
05:50 - defined a jump action
05:52 - we made it so that it works like a
05:54 - button and we bound that action to the
05:56 - physical spacebar
05:57 - input now let's see how to actually use
05:59 - this to jump an object
06:00 - and also one very important thing that
06:02 - you cannot forget is to actually save
06:03 - this asset so up here you've got a
06:05 - button for save
06:06 - asset and up here on the title for this
06:08 - window you can see a little asterisk
06:10 - this means that there are unsaved
06:11 - changes so when you see that make sure
06:13 - you save it
06:14 - and also up here on the right side you
06:15 - have a toggle where you can enable to
06:17 - auto save
06:18 - so the reason why this is a toggle not
06:20 - simply enabled all the time is because
06:22 - of the c
06:22 - sharp question generation which we're
06:24 - going to see in a bit but until we do
06:25 - and turn this on and make things simpler
06:28 - okay so now that we have over here our
06:30 - actions working
06:31 - in order to use them the simplest way is
06:33 - with a pre-built component
06:35 - so i've got my testing scene here i
06:38 - essentially just got a floor
06:40 - and then i've got a basic sphere object
06:42 - so i want to jump the sphere
06:43 - and now over here let's add a component
06:45 - and let's search for player input
06:48 - so this is a built-in component that is
06:50 - really useful for working with the new
06:51 - input system
06:52 - over here you can see it takes an input
06:54 - action asset so just drag the one that
06:56 - we created
06:57 - there it is then we've got default map
06:59 - right now we just have one so let's
07:00 - default to that one then we've got some
07:02 - more advanced use cases for dealing with
07:03 - the ui camera and so on so just leave
07:05 - these at none
07:06 - and then you've got the behavior so this
07:08 - is how the actual notifications of each
07:10 - action are sent
07:11 - and over here you've got various methods
07:13 - you can use so first of all you've got
07:15 - send messages which uses the unity send
07:17 - message system
07:19 - so it triggers functions with these
07:20 - names on any script attached to this
07:22 - game object
07:23 - then the next one is broadcast messages
07:25 - this one is similar to
07:27 - send message except that it also
07:28 - triggers functions on
07:30 - any child objects but most of the time
07:32 - you should use one of the other two
07:34 - so either yinty events which you may
07:36 - already be familiar with
07:37 - or basic c sharp events so let's see the
07:40 - unity events
07:41 - now here we get an events tab that we
07:42 - can expand to see all the various events
07:44 - that this
07:45 - object will fire so by default we've got
07:48 - these three
07:48 - so when it's triggered when the device
07:50 - is lost for example a gamepad gets
07:52 - disconnected
07:53 - regained so the gamepad gets connected
07:55 - again or controls change so for example
07:57 - you swap from the keyboard to the
07:58 - gamepad
07:59 - so these are normally in the event so
08:01 - you can click on the plus icon select an
08:02 - object in a function to trigger them
08:04 - and then up here you've got the player
08:06 - so that's the specific action map that
08:08 - we created
08:08 - and up here we've got the jump so this
08:10 - is the event that we made the actual
08:12 - action
08:12 - so this is where we can trigger
08:14 - something so let's make a script that we
08:16 - can then feed into here in order to have
08:18 - our event
08:18 - so up here i'm just going to make a
08:20 - basic c sharp script
08:22 - call it testing input system and here
08:25 - let's attach it to this game object
08:27 - okay now in here let's just make a very
08:29 - simple function
08:30 - so let's make a public void jump
08:33 - and on gem let's just do a debug.log
08:36 - jump
08:38 - okay just very basic and for the object
08:40 - let's drag this game object as the
08:42 - object and for the function
08:43 - let's go down to the testing input
08:45 - system and the jump function
08:47 - okay so like this let's test so here i
08:49 - am as i press the spacebar if there you
08:51 - go i've got unlock
08:52 - all right it does work now let's just
08:54 - make the rigid body jump upwards
08:56 - so just for fun
09:13 - okay so just like this just add four
09:15 - support just to make this weird jump
09:17 - so here and as i press the spacebar if
09:18 - there you go the sphere jumps all right
09:20 - so far so good now however there's one
09:23 - interesting thing that you might notice
09:25 - which is even though i press the
09:26 - spacebar just once over here we actually
09:28 - see three unlocks
09:30 - now the reason for that has to do with
09:31 - the various phases that the input system
09:33 - goes through
09:34 - so it's essentially one log for when the
09:36 - button was pressed
09:37 - another one for the button is currently
09:39 - pressed and finally for the button
09:40 - release
09:41 - if we expand the event we can see this
09:43 - event can be called with a parameter of
09:45 - type callback context
09:46 - this is the type that contains more data
09:48 - on specifically how the button was
09:50 - pressed
09:51 - so let's modify our function to also
09:52 - include this parameter
09:54 - so back in our script let's add using
09:56 - unity engine.input system
09:59 - and then we can modify this one and
10:02 - we're going to receive of type input
10:03 - action
10:04 - dot callback context
10:09 - then of course if you want you can just
10:10 - directly go to definition and inspect
10:12 - all the source codes all the various
10:14 - things that this one does
10:15 - but over here let's just see the actual
10:17 - phase so let's set him to the log
10:19 - the context dot phase and back in the
10:22 - editor since we modified the function
10:23 - let's assign it again
10:24 - so once again the jump function there we
10:27 - go so let's test
10:29 - okay so here and as i press the space
10:31 - bar and if there you go you can see the
10:33 - various stages it goes through so the
10:34 - starting so that's as soon as i press
10:36 - perform so that's i'm currently pressing
10:38 - it and cancelling which is when i
10:40 - release
10:40 - so these are the three separate stages
10:42 - that the input system goes through
10:44 - so for example for a button chances are
10:46 - you really only want it to be triggered
10:47 - once when the button is pressed
10:49 - so you can use the performed event you
10:51 - can either test if the phase equals
10:53 - phase not performed
10:54 - or you can just go if context not
10:57 - performed
10:58 - so this is a simple boolean that simply
11:00 - returns true if it is in the performed
11:01 - phase
11:02 - so if on the performed then you do this
11:05 - okay so like this so here i am and i
11:08 - jump
11:08 - and there you go it jumps much less
11:10 - because only being implies the force
11:12 - once and you can see that we just have
11:14 - one log
11:15 - all right awesome so that's one way to
11:17 - make it work
11:18 - by using our input unity events but then
11:21 - like we saw the other method is using c
11:23 - sharp events so let's see how this one
11:25 - works
11:26 - so when you click these are c sharp
11:28 - events so they are not visible in here
11:29 - in the editor
11:30 - so the way you subscribe is like any
11:33 - other c sharp event so it's through code
11:35 - so first of all let's get our component
11:37 - so private it's of type player input
11:43 - okay so we have that one and then
11:45 - through there we can see
11:47 - all the various events that it has so
11:49 - it's got the default ones that we saw a
11:50 - while ago so on device lost regained and
11:53 - on controls changed
11:54 - and then for the various actions you've
11:56 - got this one on action triggered
11:58 - so regardless of how many action maps
12:00 - you've got you've just got this event
12:01 - so as you might imagine the one big
12:03 - difference is that this one is triggered
12:04 - for all actions on all action maps
12:07 - now right now we just defined one action
12:09 - but if we had more then
12:10 - any action input would fire this one
12:13 - event so
12:14 - let's simply subscribe to this one and
12:16 - as you can see this one takes a
12:17 - parameter of type combat context
12:20 - so when we get the context let's just do
12:21 - a debug download on the contacts just to
12:23 - see what this is doing
12:25 - okay so let's test okay so here i am as
12:28 - i press the spacebar
12:29 - and if there you go now i can see the
12:31 - various contacts so i can see the action
12:33 - is in the action map player it's the
12:35 - jump action
12:36 - it was triggered by the keyboard space
12:38 - then for the phase this one is
12:39 - disturbing
12:40 - it happened on the time of 5.9 seconds
12:42 - and once again the key keyboard space
12:45 - with the value of one and no interaction
12:47 - so you've got the starting phase the
12:48 - performance phase and the canceled phase
12:50 - so in order to use this method then you
12:52 - do some identification over here on the
12:54 - action field
12:55 - and depending on what action it fire
12:57 - then you do different things
12:58 - but if we're going with this method of
13:00 - using this built-in player input class
13:03 - then i think it makes more sense to use
13:05 - unity events for this one
13:06 - so again you can use both but here i'm
13:08 - going to switch back
13:09 - so just like this and make sure that on
13:11 - jump event it triggers the jump action
13:13 - okay so now it's a good time to look
13:15 - into action interactions
13:17 - so back in our input manager we've got
13:19 - the jump action
13:20 - over there it's an action type button
13:21 - okay and we've got the interaction so
13:23 - let's add one
13:24 - let's for example look at the whole
13:26 - interaction then if you want you can set
13:28 - how long so how much time do you have to
13:30 - hold the button before it's actually
13:32 - triggered as a hold event so you can use
13:34 - the default so just take this box or
13:36 - untick and set anything that you want
13:38 - and like this message says you can click
13:40 - over here to open the input settings
13:42 - so this opens up the project settings
13:43 - and goes over here to the input system
13:45 - package
13:46 - and you can then create a settings asset
13:48 - and modify all the defaults
13:49 - so let's test just with the default so
13:51 - just a hold once again don't forget to
13:53 - save just in case you have autosave
13:55 - disabled
13:56 - and back here we are not using c sharp
13:57 - event so let's just clean up the code
13:59 - just get rid of this so it's easier to
14:00 - understand
14:01 - and over here on the jump let's actually
14:03 - do a debug.log on the entire context
14:06 - okay so we have the whole interaction
14:08 - now let's see just how often
14:10 - this function will be called so here i
14:12 - am and if i just
14:13 - quickly press yep we can see we've got
14:15 - the start and the cancelled phase
14:17 - but we did not get the performed phase
14:19 - that is because we did not hold on for
14:21 - long enough
14:22 - and the sphere itself did not jump
14:24 - because it only jumps on the performed
14:25 - face
14:26 - so if i click and i hold after half a
14:28 - second then it does do the performed and
14:30 - now as i let go
14:31 - now it does the cancel so as you can see
14:33 - the interactions are super useful for
14:35 - making some more complex actions
14:37 - and again remember that everything that
14:38 - we're doing here we're making it work
14:40 - with the keyboard but if we add another
14:42 - binding it would also work with the
14:43 - gamepad or touch or anything else
14:45 - and also this is a list so you can have
14:47 - multiple interactions
14:48 - so you could have a home then a slow tab
14:50 - and so on although ideally chances are
14:52 - you would make them into separate
14:53 - actions
14:54 - okay so that's interactions and then
14:56 - you've got the processors
14:57 - like i said these are really very useful
14:59 - for buttons but you can for example add
15:01 - an invert processor
15:02 - and right now before we hit play and
15:04 - clear the console we can see that
15:05 - as we were pressing we were getting over
15:07 - here the value of one
15:09 - so on the started and performed we've
15:11 - got a value of one and then on cancel we
15:12 - got a value of zero
15:14 - now if we add the invert processor so
15:16 - now as i click
15:17 - and if there you go now instead of pause
15:19 - one we get minus one so these processors
15:21 - apply
15:22 - some sort of processing on top of the
15:23 - actual event this is going to be more
15:26 - useful as we get into the movement
15:27 - joysticks but we'll see that in a bit
15:29 - okay so with this we have covered the
15:31 - absolute basics and we also saw how the
15:33 - built-in player input component works
15:36 - but like i said previously you also have
15:38 - the ability to generate a c-sharp class
15:40 - and have a lot more control over it
15:42 - so let's go into the project window and
15:44 - over here so like the actual input
15:45 - actions asset
15:46 - then you got a button to edit the asset
15:48 - which opens up this window and then
15:49 - you've got a toggle for the generate
15:51 - c-sharp plus
15:52 - so you can take this one and then you
15:54 - see all these inputs
15:55 - so if you want you can modify what file
15:57 - they're going to be generated in what
15:59 - class name what namespace and so on
16:01 - but here just leave them as defaults and
16:03 - hit on apply so as you do you can see
16:05 - over here that generated the c
16:06 - files over here the player input actions
16:08 - now if you want you can open and inspect
16:10 - this
16:11 - it just generates all kinds of functions
16:13 - fields and events based on the input
16:14 - action
16:15 - so for example we defined a player
16:17 - action map and over here we can see the
16:19 - player action map right in here
16:20 - and then for the player we define some
16:22 - actions so we define the jump action
16:24 - so over here we can see an interface
16:26 - that implements the jump action over
16:27 - here the player actions
16:29 - so all of this code is all dynamically
16:31 - generated so we've got our jump action
16:33 - and the various events started performed
16:34 - and cancel so you really don't need to
16:36 - worry about how this script works but if
16:38 - you want to feel free to inspect it
16:40 - so back in our testing input system here
16:42 - in order to use that we just need to
16:44 - create an instance of our generated c
16:46 - sharp class
16:47 - so it's called player input action so
16:49 - new player input actions
16:53 - so just construct this object
16:58 - and then on this one we need to access
17:00 - the player action map
17:02 - and then we're going to access the jump
17:04 - action and finally we're going to
17:06 - subscribe to the performed event
17:08 - so just pause equals and subscribe to
17:10 - this one and there you go the signature
17:12 - is exactly the same so on gem performed
17:13 - you've got a comeback context
17:15 - and then over here you can do anything
17:17 - so let's use this exact same function
17:19 - instead of creating a new one so just
17:21 - like this
17:22 - let's see if this works and just up here
17:24 - right now we're no longer using the
17:26 - player input so let's actually remove
17:27 - this component
17:28 - so we're just going directly through the
17:30 - c sharp class so let's try
17:32 - here i am and as i hit space and nope
17:34 - nothing happens
17:35 - now that is because we need to make sure
17:37 - to enable this input action
17:39 - so by default when you construct is
17:40 - actually disabled so it's not actually
17:42 - listening to input
17:43 - so in order to enable it we actually
17:45 - have various ways we can do that
17:47 - we can go directly into the player input
17:50 - actions and call
17:50 - enable however if you do it like this it
17:53 - will actually enable
17:54 - all of the various action maps so if you
17:56 - had one for the player one for a vehicle
17:58 - one for the ui all of them would be
18:00 - active at once which is probably not
18:02 - what you want to do
18:03 - so instead of enabling the entire input
18:05 - actions asset you can just go into the
18:07 - player
18:07 - so just go into this action map and just
18:10 - enable just this one
18:12 - and now here if i hit space if there you
18:14 - go everything works
18:16 - so i've got the performed action and it
18:18 - triggered the jump and it jumped the
18:20 - rigid body upwards and again note how
18:22 - here we only have one log
18:24 - that is because since we're going
18:25 - through this one we are only subscribing
18:27 - to the performed event
18:28 - so if we wanted of course we could also
18:30 - subscribe to the started or the
18:32 - cancelled event
18:33 - but chances are we just want to perform
18:35 - so this is actually much better
18:37 - okay with this working now let's add
18:38 - some more actions so on the input action
18:41 - asset
18:41 - let's add another action so we click on
18:43 - the plus button here
18:45 - let's name this one movement and now
18:47 - here is the reason why there's a toggle
18:49 - for the autosave which is because of the
18:51 - c sharp class generation
18:53 - if you have the generation enabled and
18:54 - you change this one tiny thing so for
18:56 - example over here change from button
18:58 - into value
18:58 - as soon as i change then you can see
19:00 - down there that unit is compiling so
19:02 - everything is frozen i gotta wait a bit
19:03 - and so on so if you do have c sharp
19:06 - generation enable then it makes sense to
19:07 - disable it do all your changes then
19:09 - save and when you save then it does
19:11 - generate the c-sharp plus
19:12 - okay so this is our movement action then
19:15 - over here for the action type
19:16 - this is not a button so we're going to
19:17 - use value and then you can see a field
19:20 - for the control type
19:21 - so this is if you want to limit it to a
19:23 - specific type like for example only
19:25 - allow the d-pad
19:26 - or analog inputs or anything or you can
19:29 - also go with any if you're not entirely
19:30 - sure
19:31 - but in this case we do know that we want
19:33 - movement which means that we want an x
19:35 - and y axis so let's go with a simple
19:37 - vector 2.
19:38 - and then let's also delete the default
19:39 - binding that was created automatically
19:41 - so just right click over here click on
19:42 - delete
19:43 - and instead let's click on this plus
19:45 - icon instead of adding a normal binding
19:47 - let's add a 2d vector composite so with
19:50 - this we get four directions so up down
19:52 - left right
19:53 - so this makes it perfect for binding to
19:55 - something like the arrow keys or w a s
19:57 - and d
19:58 - so i'm going to do that to just select
20:00 - this binding then over here on the path
20:02 - click on this one click on listen this
20:03 - one is up so press on the double key
20:05 - there you go w
20:07 - then down go over here press on s then
20:09 - left let's go
20:10 - into a and finally the right let's go
20:13 - into d
20:14 - all right wsed so again don't forget
20:17 - click on the save asn
20:18 - so now it's going to regenerate the c
20:20 - sharp plus and now once again you can
20:22 - either go through the player input
20:23 - component or access the c sharp class
20:25 - directly
20:26 - so let's use that method since we're
20:27 - already using it here so for that one
20:30 - let's go into the player input actions
20:32 - then we're going to go into the player
20:34 - action map and now the action is named
20:37 - movement
20:38 - and let's subscribe to the performed
20:39 - event
20:41 - okay so when that happens let's just do
20:43 - a debug.log on the context
20:48 - so let's test like this and see what the
20:49 - context contains
20:51 - so here and i'm going to press the
20:52 - double key and here as soon as i do you
20:54 - can see that happened
20:56 - so you can see the context triggered on
20:57 - the player action map on the movement
20:59 - action which has all these mining so w a
21:02 - s and d
21:02 - this was a perform phase on this time
21:05 - and if you look a bit further you can
21:07 - see over here the value
21:08 - we've got a value of 0.0 and then 1.0 so
21:12 - i press on w
21:13 - so that means i've got a 1 on the y then
21:16 - if i press on the s
21:17 - i've got zero minus one if i press on a
21:19 - i've got minus one zero
21:21 - press on d and i've got plus one zero so
21:23 - we've got the perfect vector two in
21:24 - order to actually move our sphere
21:26 - so let's use that to move our rigid body
21:28 - so up here on the context
21:30 - in order to read the actual value let's
21:32 - go into context
21:33 - and then you call the function read
21:34 - value and this one takes a generic for
21:37 - the actual type
21:38 - here we have a two-dimensional array so
21:40 - let's read it as a vector two
21:42 - and now in this case this is the
21:43 - movement direction that we want to apply
21:45 - to the rigid body
22:11 - okay so here we're doing context out
22:12 - read value reading a vector 2 so this is
22:15 - going to be our input vector
22:16 - then i'm just doing a sphere rigid body
22:18 - in order to add a force
22:20 - then for the force i'm constructing a
22:21 - vector 3 because the sphere is in 3d
22:24 - and the input vector is in 2d so just
22:26 - making that using the input vector x
22:28 - then 0 on the y since i don't want to
22:30 - move this here upwards but rather back
22:32 - and forward
22:32 - so just put that one multiplied by a
22:34 - certain speed and so on
22:36 - okay so let's just like this so here i
22:38 - am and as i press on w
22:40 - and if there you go it did move the
22:41 - sphere however you can see that it moved
22:43 - by a tiny amount so now i press on
22:44 - s and goes backwards and now i press on
22:47 - d
22:47 - and goes to the right press on a and so
22:50 - on so the one thing that you do notice
22:52 - is that this input gets only triggered
22:54 - once
22:55 - so it's essentially on a button press so
22:57 - if i want to actually move the sphere
22:58 - i've got to spam the buttons
22:59 - that's not supposed to be like that
23:01 - ideally for a movement input it makes
23:03 - more sense to constantly check the
23:05 - current state and constantly apply it
23:07 - so for that we can go with another
23:08 - method instead of over here subscribing
23:11 - to the performed on the movement action
23:13 - we can make a very simple private void
23:15 - update
23:16 - and over here we can actually read the
23:18 - value on every frame
23:20 - so you can go into player input actions
23:23 - so that means that we need to make this
23:24 - as a member field
23:30 - so you go into that one access the
23:32 - player action map access the movement
23:34 - action and then over here we can call
23:36 - read value read as a vector 2
23:38 - and so on so the same thing that we're
23:40 - doing here let's do it
23:41 - up there
23:50 - okay so the exact same thing except on
23:52 - the update we're going through the
23:53 - player input actions player movement and
23:55 - so on
23:55 - and then applying the force and
23:57 - everything should work so now let's see
24:00 - so now as i press and hold any there you
24:02 - go now movement is indeed being applied
24:04 - on every frame
24:05 - let me just lower the speed and since
24:08 - this is a rigid body we should probably
24:09 - do this on fixed update
24:11 - and yep now in here i can read use wasd
24:14 - in order to actually move my sphere
24:16 - so move it to the right move it upwards
24:18 - then start moving downwards and so on
24:20 - all right so now it's working and i'm
24:22 - reading the value on every single update
24:24 - so chances are for movement you want to
24:26 - go with this method instead of the event
24:28 - method
24:29 - okay so now it's probably time to look
24:30 - into how multiple
24:32 - inputs like keyboards and gamepads work
24:34 - over here on the input action assets
24:36 - if you go on the top left corner over
24:38 - here you've got a button where you can
24:39 - add a bunch of control schemes
24:41 - so let's add one let's call this the
24:43 - keyboard
24:44 - and over here on the list you select the
24:46 - type so let's select of type keyboard
24:48 - and hit on save then here for each
24:50 - individual
24:51 - binding you can go ahead and over here
24:53 - tick and make sure that this one is used
24:54 - in the keyboard control scheme
24:56 - so just select that one in there then
24:58 - over here for all these select them one
25:00 - by one
25:01 - okay so now all of these bindings are
25:03 - set as keyboard bindings
25:05 - and now we can go up here create a new
25:07 - control scheme
25:08 - name this one gamepad and on the list
25:10 - let's select a gamepad select a generic
25:13 - gamepad
25:14 - and just hit on save and when you do you
25:16 - can see that the bindings disappear
25:18 - now if you want of course that are not
25:19 - lost so you can go back into the
25:21 - keyboard and you can see the keyboard
25:22 - bindings
25:23 - then go into the gamepad and over here
25:25 - we're going to add gamepad bindings
25:27 - so right now i just connected my xbox
25:29 - controller
25:30 - and you can also see over here on the
25:31 - logs that the input system automatically
25:33 - detected that that one was connected
25:35 - so with this let's do just like we did
25:37 - so on the jump let's click on this we're
25:38 - going to add a
25:39 - binding then for this binding go into
25:41 - the path and listen and i'm going to
25:43 - press a button on my xbox controller so
25:45 - i'm going to press the a button
25:47 - however if you try this it might not be
25:49 - working that is because i
25:51 - connected the gamepad right while the
25:52 - game was running so to solve that just
25:54 - make sure you save the asset
25:56 - and just play the scene and then if you
25:58 - quit again now it should be
26:00 - identified so now i can go up here click
26:02 - on listen press on the a button and
26:03 - there you go it does connect
26:05 - in order to validate that everything was
26:06 - connected there's actually one that is
26:08 - super useful that i'm going to talk
26:09 - about in a bit
26:10 - but just here briefly you can go over
26:12 - here into window analysis
26:13 - input debugger and over here you should
26:15 - be able to see your controller connected
26:18 - okay so anyways click on listen click on
26:19 - the a button and over here you see an
26:22 - interesting thing about the input system
26:24 - if you want you can select the a button
26:26 - on the xbox controller
26:28 - so if you do that then this action will
26:30 - only be triggered by the xbox a button
26:32 - meaning that pressing x on a playstation
26:34 - controller will not trigger this action
26:37 - so the better approach you can take is
26:38 - just use this one just button south
26:40 - gamepad
26:41 - this is a generic control that won't
26:42 - work on any gamepad
26:44 - so you've got buttons south north east
26:46 - and west and with that if you sound like
26:48 - this one so button south gamepad so the
26:50 - generic one
26:51 - if it's unlike this one then don't
26:52 - trigger on an xbox a button
26:54 - or on a playstation x button or on a
26:57 - switch a button
26:58 - and anything else that has the standard
27:00 - inputs okay so that's the simple button
27:02 - input okay and then over here for the
27:04 - movement let's click on this button
27:06 - and now for the keyboard we made a 2d
27:08 - vector composite that's because it was
27:10 - based on four buttons
27:11 - but for the gamepad we really just want
27:13 - to use a joystick so
27:14 - let's use a normal binding and then over
27:17 - here for the path
27:18 - just click on listen now i'm going to
27:20 - move around the lipstick
27:22 - and it automatically identifies so once
27:24 - again you can go with the xbox
27:25 - controller or the more generic gamepad
27:27 - alright so that's it and now just with
27:29 - this we can see the true power of the
27:31 - input system which is we do not need to
27:33 - touch our code at all
27:35 - the code is already set up to work with
27:37 - the jump action and the movement action
27:39 - regardless of whatever physical input
27:40 - they come from
27:42 - so just with this if i click on save
27:44 - asset and i play the game
27:45 - now i can for example press space on the
27:47 - keyboard in order to jump
27:49 - and now without doing anything special
27:51 - i'm just going to press the a button on
27:53 - my xbox controller
27:55 - and if there you go it does trigger the
27:56 - jump now using the gamepad
27:59 - so here this is the example of the
28:01 - awesome power of the new input system
28:03 - so it allows you to completely separate
28:05 - actions from the physical inputs
28:07 - you write your code to work simply with
28:09 - actions and then you set up the input
28:10 - action asset with how those actions are
28:12 - triggered
28:13 - and then without doing anything else
28:15 - your game now works perfectly with any
28:16 - input
28:17 - so the player can seamlessly switch
28:19 - between keyboard or gamepad and anything
28:21 - else and everything works perfect
28:23 - alright awesome okay so with that you
28:26 - already know the basics but let's see a
28:27 - few more things
28:28 - for example like i said the processors
28:30 - they are super useful when it comes to
28:32 - game pads
28:33 - and by the way here since we actually
28:35 - have two control schemes
28:37 - we can add processors on the action
28:39 - itself so click on the action and add a
28:41 - processor
28:42 - this will apply to the action regardless
28:44 - of whatever control scheme you're using
28:46 - or you can just add the processor
28:48 - directly on the actual binding
28:50 - so this is useful if you want to apply a
28:51 - processor to the gamepad but not on the
28:53 - keyboard
28:54 - so then over here one of the more useful
28:56 - ones is over here the stick dead zone
28:58 - this helps when gamepads have slight
29:00 - issues and they aren't perfectly on zero
29:01 - zero
29:02 - so for example you've heard of the
29:03 - nintendo joycon drift
29:05 - that is where the actual physical
29:07 - joystick gets slightly moved to the side
29:09 - never actually goes down to zero zero
29:10 - so that is why you have the stick that
29:12 - zone so with this processor what it does
29:15 - is if you move the stick bound less than
29:16 - this amount then it won't be considered
29:18 - zero so
29:19 - it won't do anything and if you move it
29:21 - by more than this amount then it won't
29:22 - be considered one
29:24 - and also the value between these two is
29:25 - normalized so for example if i take away
29:28 - this one and i put the minimum
29:29 - at 0.5 so now it should only read a
29:32 - value of more than zero
29:33 - after i move the stick more than half
29:35 - words towards any direction
29:37 - so over here i am physically moving the
29:38 - stick and as you can see nothing on the
29:40 - console so it's not listening
29:42 - and once i get past the halfway point so
29:44 - just a bit more and there you go it does
29:46 - start to actually move
29:48 - let's add a log so we can see the actual
29:49 - values so up here
29:51 - let's do a debug.log on the input vector
29:54 - to see what this says
29:55 - so over there it's all at zero and as i
29:57 - move a bit and it's still at zero and
29:58 - only once i go past
30:00 - 0.5 then it actually reads the value 0.1
30:03 - so like i said this is normalized so as
30:05 - soon as i move past the half
30:06 - now it starts reading the value and if i
30:09 - go way past to the side
30:11 - so if i go past the 0.975 then it reads
30:13 - as an actual one
30:15 - so that's what the processors do as you
30:17 - can see adding the stick dead zones to
30:18 - gamepad 6 is something you should always
30:20 - do so your players can play the game
30:22 - even if their gamepad isn't in perfect
30:23 - condition and just as another quick
30:25 - example
30:26 - for example you've got the normalized
30:28 - vector 2 so as you saw if i move the
30:30 - stick by a tiny bit then it only shows
30:32 - like 0.1
30:33 - but if i add the normalize and now as i
30:35 - move just one tiny bit you can see the
30:37 - values are normalized so even if i move
30:39 - just a tiny bit
30:40 - the magnitude of the actual input vector
30:42 - always goes up to magnitude of one
30:45 - okay so now it's time to talk about the
30:46 - thing that i mentioned a while ago
30:48 - which is for the input action you've got
30:50 - value button and then pass through
30:52 - now pass through is similar to value but
30:53 - it bypasses something called the
30:55 - disambiguation which is the process
30:57 - through which the input system decides
30:59 - which input is
31:00 - active now like i said the input system
31:02 - handles all the complex logic when you
31:04 - have multiple inputs connected like for
31:06 - example multiple gamepads
31:08 - and when using value it will only
31:09 - trigger the action for the active
31:11 - gamepad
31:11 - whereas on passthrough it will trigger
31:13 - the action for every single gamepad
31:15 - so now i also have a playstation
31:17 - controller connected
31:19 - and if i move one you can see on the log
31:21 - that it does change but then it goes
31:22 - back into zero and so on
31:23 - that is because right now it is
31:25 - receiving input from multiple
31:26 - controllers
31:27 - so i'm just moving one controller and
31:29 - not the other one and the input as you
31:31 - can see
31:32 - it's very erratic so the issue is
31:33 - because receiving inputs from all of the
31:35 - various controllers so for example one
31:37 - of them is telling them to go right the
31:39 - other one left
31:39 - and so on so the whole thing gets all
31:41 - messed up whereas if i set this back
31:43 - into value
31:44 - and over here if i'm moving using the
31:46 - xbox controller yep now the log is
31:48 - actually correct so it's only listening
31:50 - to input from the xbox controller
31:52 - and now if i instead start moving the
31:54 - playstation controller now it's
31:55 - listening to input from download
31:57 - so now it only listens to once at a time
31:59 - so only the one that is active gets
32:01 - listened
32:01 - all the other ones get essentially
32:03 - ignored so pass-through is useful
32:05 - for if for some reason you want to read
32:07 - input from every device at once
32:09 - but for the most part you really want to
32:11 - use value now so far
32:12 - we've been playing with an input action
32:14 - that we created from scratch
32:16 - however if you want to quickly get it up
32:18 - and running you can also use the default
32:21 - so if you go onto a game object and then
32:23 - add the player input component
32:26 - if you do not assign anything here and
32:27 - instead you click on this button
32:29 - then it asks you for a path so you can
32:31 - save it and it automatically creates the
32:33 - default input actions asset
32:35 - so this one is pre-filmed with a bunch
32:37 - of action maps and a whole bunch of
32:39 - actions
32:40 - so if you want you can use this as a
32:41 - starting point instead of building your
32:42 - own from scratch
32:43 - or you can just look at this one to
32:45 - inspect and see how they implement
32:46 - things so this one has got all kinds of
32:48 - control schemes e2 action maps all kinds
32:50 - of actions and so on
32:52 - now on the lecture where i cover the
32:54 - differences between the input manager
32:56 - and the input system i said that the
32:58 - input manager is just more simple and
32:59 - more compact in general
33:01 - while that is true the input system can
33:03 - also be very compact if you want it
33:05 - so for example just testing for a simple
33:07 - mouse click you can do a private void
33:09 - update
33:10 - and on update you can do go inside the
33:13 - mouse
33:14 - access the current active mouse go into
33:16 - the left button
33:17 - and then check was presses frame
33:25 - if so then with this you've got a simple
33:26 - test testing if the mouse is pressed
33:29 - then you can also test for specific
33:30 - gamepad so you access the
33:32 - gamepad class you access the current one
33:35 - then you can access all the various
33:36 - buttons so a b button north south and so
33:39 - on
33:40 - you can also go into the keyboard and
33:41 - access the current the nexus for example
33:43 - bt key
33:45 - and so on but do remember that this
33:47 - super compact method is something you
33:49 - should really only use for a very quick
33:51 - test or prototyping something new
33:53 - when building something more permanent
33:54 - you should absolutely be using the
33:56 - actions and not be working directly with
33:58 - specific buttons at all
33:59 - one more thing here in the code is with
34:01 - regards to multiple action maps
34:04 - so as an example let's create one to see
34:05 - how it works so first of all go up here
34:08 - create a new action map let's say this
34:09 - is the ui
34:10 - so we want a bunch of inputs for
34:12 - navigating through our ui
34:13 - and up here let's just add a single
34:15 - action so just submit so
34:17 - just clicking a button and then for the
34:19 - binding let's just bind it directly into
34:21 - the spacebar
34:23 - so since it's bound to the spacebar
34:25 - which also on the player it's also bound
34:27 - to the spacebar so the player has got to
34:29 - jump to the spacebar
34:30 - and the ui has the spacebar doing a
34:32 - submit now how do you tell which action
34:35 - map should be active
34:36 - if you're using the player input action
34:38 - first of all let's
34:39 - make a function for the actual ui submit
34:42 - so over here you've got the various
34:43 - action maps so you expand upon this and
34:45 - set it
34:46 - so here let's just copy this one do the
34:48 - same thing
34:51 - except this one call it submit
35:00 - okay and now here let's just hook onto
35:03 - that event
35:04 - okay so we got both events both of them
35:06 - triggered by the same physical button
35:08 - but they are on different action maps so
35:10 - over here on the player input itself you
35:12 - can see the default map so this is the
35:13 - starting one so that you start on the
35:15 - player or the ui
35:16 - or so on and now how you change them is
35:18 - over here through code you've got the
35:19 - player input so you get the component
35:21 - and so on
35:22 - and then you trigger the function switch
35:25 - current action map
35:27 - you do that and then you pass in the map
35:29 - name or the id
35:31 - so let's use this super compact testing
35:33 - that i mentioned previously
35:35 - instead of the mouse let's go to the
35:42 - keyboard
35:56 - so if i press the t key we're going to
35:58 - swap the player input to the action map
36:00 - ui and if i press the y key we're going
36:02 - to swap it back into the player action
36:03 - map
36:04 - and then by pressing space we should see
36:06 - either this function or this function so
36:08 - let's see
36:08 - okay so here i am as i press space and
36:11 - yep it's firing the jump action on the
36:13 - player action map
36:14 - now i press t to swap out the actual
36:16 - default map
36:18 - and i press space again and you have now
36:20 - it's instead firing the submit action
36:22 - now press y to go back into the player
36:24 - and so on and down
36:25 - so yep this is the function that you
36:26 - trigger in order to swap between each
36:28 - action map
36:29 - so for example if you had a ui that was
36:32 - only meant for the pause button
36:33 - then when the player hit on pause then
36:35 - you would call this and when the player
36:36 - had on the resume
36:37 - you would go with this one so this is
36:39 - when working with the player input
36:41 - built-in component
36:42 - and when working with c sharp one is
36:44 - very simple like we saw it only works if
36:46 - we actually enable it
36:47 - so on that one we would enable the
36:49 - player by default then when we want to
36:51 - switch
36:52 - we would disable the player so just go
36:55 - into the player call disable
36:56 - and then go into player input actions
36:59 - access the ui and call enable so if you
37:02 - went with the c sharp method then this
37:04 - is what you would do
37:05 - now something that i showed a while ago
37:07 - that is super useful is the input
37:08 - debugger
37:09 - you go up here into window then down
37:11 - here into analysis and open up the input
37:13 - debugger
37:14 - and over here it shows you all the
37:16 - various connected devices so for example
37:18 - in my case i've got a mouse keyboard
37:19 - i've got a dual shock and an xbox
37:21 - controller then you can also see for
37:23 - example some unsupported devices
37:25 - so for example i recognize my microphone
37:27 - but of course it's not a
37:28 - actual gamepad then it also recognizes a
37:31 - bunch more
37:32 - and my specific mouse isn't being
37:33 - recognized but it is on the generic
37:35 - mouse
37:36 - and then you can also double click on
37:37 - each of these to go in further so for
37:39 - example double click over here on the
37:40 - xbox controller
37:42 - now for example if i press the a button
37:44 - if you can see over there on logs it
37:46 - does recognize and i'll let go and it
37:47 - goes back to zero
37:49 - so you can see up here on the valley the
37:50 - actual valley that it's reading directly
37:52 - from there
37:53 - so as i click there it goes here and so
37:54 - on and if i move the d-pad then you can
37:56 - see
37:57 - all the various directions and if i
37:59 - touch on the left trigger you can see
38:01 - yep the value going up and down
38:02 - and so on so this is very useful to
38:04 - verify and make sure that your
38:06 - controller is indeed connected and unity
38:08 - is indeed receiving the input correctly
38:10 - so with this we have the new input
38:12 - system working one thing that is
38:14 - required in pretty much
38:15 - every game is rebinding keys so let's
38:17 - see how that's done
38:19 - over here on the testing script let's
38:20 - try rebinding the player jump action
38:23 - so to do that we access the same jump
38:25 - action
38:26 - and then we call the function perform
38:28 - interactive rebinding
38:30 - so this will essentially do what we saw
38:32 - of pressing the listen button
38:34 - so you call this this creates a specific
38:36 - object and then you call start to
38:38 - actually start
38:38 - listening so when you do then listen to
38:41 - the next input and assigns that to this
38:43 - action
38:44 - however just like this we're going to
38:45 - get an error but let's see it
38:47 - and if there's the error we cannot
38:48 - rebind something once something is
38:50 - currently enabled
38:51 - so over here we are enabling the player
38:53 - action map
38:55 - so when we go to rewind we need to make
38:57 - sure to disable
38:58 - so first we disable and then we start
39:00 - actually rebinding
39:01 - so like i mentioned a while ago we
39:03 - create the various action maps so for
39:05 - example one would be for the player
39:06 - in-game
39:07 - actions and then another one for the ui
39:08 - inputs and then while the ui input
39:11 - actions was enabled then you could
39:12 - easily rebind the player input actions
39:15 - now this function this one the perform
39:17 - interactive rebinding
39:19 - this actually returns an object of type
39:21 - rebinding operation
39:23 - this object is what actually contains
39:24 - all of the data regarding the rebind
39:27 - then you can also add all kinds of
39:29 - modifiers in order to do various things
39:31 - before you actually call start
39:32 - specifically it has an uncomplete event
39:36 - so we can hook into this one in order to
39:37 - listen when the actual re-bind completes
39:39 - so for that we perform the interactive
39:41 - rebinding then instead of calling start
39:43 - right away
39:44 - let's first call on complete and on
39:47 - complete this takes an
39:48 - action so this one takes a call back as
39:51 - a parameter
39:51 - so we can do it like this so just a
39:53 - simple lambda expression
39:56 - and in here let's just do a debug.log on
39:59 - the comeback
40:00 - okay now let's play the game and that
40:02 - function was triggered on the wake so
40:04 - right now it isn't listening for a
40:05 - button
40:06 - so as i press for example the t key
40:08 - there you go it actually worked it
40:10 - rebound the key
40:11 - but we also see an interesting error
40:12 - related to a native collection that was
40:14 - not disposed of
40:16 - that is because you must manually
40:17 - dispose of this object in order to avoid
40:19 - any memory leaks
40:21 - so the object is the actual rebinding
40:23 - operation so that's the same one that we
40:25 - get over here on the comeback so on
40:26 - complete
40:27 - we do this and then we can call this
40:29 - pose so we dispose that and after the
40:32 - rebind completes let's reenable the
40:34 - action map so we try it out
40:35 - so we re-enable this one and then let's
40:38 - see
40:38 - okay so now it's listening to input so
40:40 - as i press the t key
40:42 - yep now it should have rebound the jump
40:44 - action onto the t
40:45 - action so if i press the space bar nope
40:48 - it no longer jumps and if i press t
40:50 - yep now it does indeed jump alright
40:52 - great
40:53 - now like i said there's tons of filters
40:55 - you can apply in here
40:56 - you can inspect the re-binding operation
40:58 - to see all these various filters and
41:00 - things
41:00 - so for example you can add a canceling
41:02 - button
41:03 - or you can limit the expected control
41:05 - type or for example you can limit some
41:08 - controls
41:08 - so for example you do with controls
41:11 - excluding
41:12 - and then let's say exploiting the mouse
41:17 - so with this i won't be able to rebind
41:19 - this action onto the mouse
41:21 - so if i'm here and i click with the
41:22 - mouse and nope it's not rebinding
41:24 - because the mouse is not accepted but if
41:26 - i press a different key on the keyboard
41:28 - if there you go now it doesn't rebind
41:30 - so with that we can now rebind our
41:31 - actions so i rebound this to the t key
41:33 - so as i press t
41:34 - it actually jumps okay great however now
41:37 - if i stop playing the game and i start
41:39 - playing again
41:40 - and now press the t key and nope it's
41:42 - not jumping it's once again back to the
41:43 - default back to the space
41:45 - so naturally we need to actually save
41:47 - the rebins
41:48 - and for that there's actually two ways
41:50 - depending on what version you're using
41:52 - now if you're using version 1.0 then you
41:54 - need to manually save them
41:56 - but if you're using version 1.1 then
41:57 - there's a much easier process
41:59 - so when you actually rebind so after the
42:01 - on complete
42:02 - it actually changes one thing in the
42:04 - asset so for example over here on the
42:06 - comeback
42:07 - you can access the action and then for
42:10 - each action you've got various bindings
42:12 - so you can cycle through this one or in
42:13 - this case we just have one so just zero
42:15 - for testing
42:16 - and then for each binding you've got a
42:18 - field for the override path
42:20 - so let's look at what this log and as i
42:23 - press the t key to rebind
42:24 - there you go it did rebind in order to
42:26 - the keyboard t so if you're using
42:28 - version 1.0 then this is what you need
42:30 - to do
42:31 - you need to go through your input
42:32 - actions go through all the action maps
42:35 - cycle through all the bindings for each
42:36 - action and save up the override path
42:39 - however if you're using version 1.1 then
42:42 - there is now a function to return
42:44 - some json for all of the overrides so
42:46 - you just call this function and it
42:48 - returns a json string
42:49 - which you can then easily save in a file
42:51 - or the player prefs or anything
42:53 - and then another function for actual
42:55 - loading so depending on your version
42:56 - you've got two different methods
42:58 - okay so the last thing we need to cover
43:00 - are the touch controls
43:02 - you can define the bindings like any
43:03 - other so for example
43:05 - if you look on the input actions that
43:06 - are created by default
43:08 - on this one for the control schemes you
43:10 - can see it does have a touch control
43:11 - scheme
43:12 - and that one you can see that it does
43:13 - have the very specific touch controls
43:16 - so you can do this to set up the
43:17 - individual bindings
43:19 - but beyond that there's also a super
43:21 - useful built-in component
43:22 - so here let me make a canvas and then
43:25 - inside the canvas let me make an empty
43:27 - game object
43:33 - and now inside i'm going to add a ui
43:36 - image
43:37 - and for the image i'm going to select a
43:38 - basic circle and now just take the stick
43:41 - and let's put it over here on the corner
43:43 - and now the image itself we can add a
43:45 - component and search for
43:47 - on-screen stick this one then it's got
43:50 - two fields
43:50 - so the movement range that's how much
43:52 - this image is going to move relative to
43:54 - the parent
43:55 - and then the control path which is what
43:57 - this stick will simulate so in this case
43:59 - we can click on this
44:00 - let's go into the gamepad and we're
44:01 - going to simulate the left stick
44:03 - so if we play now as i click and drag
44:06 - the
44:07 - virtual joystick and yep there you go it
44:09 - is indeed moving the sphere
44:11 - so it's moving in any direction and if i
44:12 - push to the edge and it's the 50 units
44:14 - that we saw there
44:15 - so just like this it is automatically
44:17 - working and then the other built-in
44:19 - component let's make another image
44:21 - put it on the other side and this one is
44:23 - the on-screen button
44:24 - so this one same thing is just acts like
44:26 - a button so let's pretend that this one
44:28 - is the gamepad
44:29 - south button so as i click on this one
44:31 - yep it's simulating a jump
44:33 - so for mobile you can build your own ui
44:35 - from scratch and attach the touch
44:36 - specific bindings
44:38 - or you can use these super awesome super
44:40 - useful built-in components
44:41 - in order to simulate a gamepad using
44:43 - touch and everything else in your game
44:45 - won't work seamlessly
44:46 - alright so that's a new input system
44:48 - package this was a
44:50 - pre-baking lecture since it's a pretty
44:51 - complex system but hopefully you can see
44:53 - how the complexity does pay off
44:56 - this system forces you to separate your
44:58 - logic and abstract actions away from
45:00 - physical inputs
45:01 - which in turn leads to writing better
45:03 - cleaner code and a game that can be
45:04 - played on any input device
45:06 - go watch the input manager versus input
45:08 - system lecture if you haven't seen it
45:10 - yet in order to understand the
45:11 - differences
45:12 - but if you're working on a proper game
45:14 - then this system is awesome and it's
45:15 - definitely what you should be using
45:17 - alright so this was a lecture from my
45:19 - ultimate unity overview course
45:21 - there's lots more explaining tons of
45:23 - things like shadowgraph similar
45:24 - definitions pro builder the video player
45:26 - and so on
45:27 - go ahead and get the phone course and
45:29 - learn how to master all the unity tools
45:31 - and features to help you make better
45:32 - games faster
45:33 - alright hope that's useful check out
45:35 - these videos to learn some more
45:37 - thanks to these awesome patreon
45:38 - supporters for making these videos
45:40 - possible
45:41 - thank you for watching and i'll see you
45:42 - next time

Cleaned transcript:

hello and welcome i'm your code monkey and here let's learn how to use the new input system this video is pretty big but it's the only video you need in order to learn how to use the new input system this is an excellent package that makes managing multiple inputs of different types very easy it looks a bit daunting at first but once you understand how it works it becomes actually quite easy to work with and of course the benefits of this system are immense once you have everything set up in your game working with the actions that you defined after that's done then your game is instantly playable with the mousing keyboard or touch input or maybe an xbox or playstation controller all of that works seamlessly also this video is in lecture taken from my ultimate unity overview course unity is massive so in the course i explain over 40 features and tools of the engine that you might not know about there's individual lectures explaining tons of things like shadowgraph assembly definitions pro builder the video player and so on also the course will be continuously updated with free updates as i add more lectures explaining more tools and features this specific lecture was added as a part of the first free update along with 10 other new lectures so go ahead get the phone course and learn how to master all the unity tools to help you make better games faster in this lecture we're going to learn all about the new input system package this is a lot more capable than the legacy input manager and it easily allows you to handle input from multiple sources without any issues so you can make your games work with a mouse and keyboard or an xbox gamepad or a playstation controller and all of it works seamlessly but naturally all of those awesome features come at the cost of slightly more complexity however once you understand how it's all set up what is an action what is an input and so on once you understand the basics of the system it's actually quite simple to use okay so let's learn how it works first up we need to install it by going into the package manager make sure you're on the unity registry then scroll down and find the input system package then just go ahead and install it and also over here you've got a whole bunch of samples that you can download to inspect if you want to see how they all work so these are some very specific scenarios so maybe they can be helpful now when you install you might see a message talking about enabling the new input system or the old input manager you've got two options you can click on yes which won't disable the old input manager and enable the new input system or you can click on no so nothing changes instead of using that window you can instead go into edit and go down here into project settings then go on to the player tab and then down here scroll expand the other settings scroll down here until you see the active input handling and over here you can select the old one the new one or you can select both of them now i cover the differences between both of them in another lecture so go watch that if you haven't seen it yet but essentially i find that they both have their use cases so here i just pick both and when you change this it restarts the ent editor okay now to start actually using the new input system the first thing you need is to create an input actions asset this is an actual asset in your project files so you just right click on some folder go into create and then scroll down here until you find the input actions so create it give it a name like player input actions and then double click on it so when you do out pops out the input actions window now this is where you're going to define all the actions and inputs that you can then use in your game so you see this separated in three groups you've got action maps actions and properties now let's add an action map by clicking over here on the plus icon so an action map is how you organize various actions for example if you had a game where you have a player that can walk around the world but also enter vehicles you would make one action map for the player walking another one for the vehicle inputs maybe yet another one for the ui for while the game is paused and so on so using multiple action maps really helps keep things nice and organized by having distinct action maps instead of just a huge list of actions so let's call this one just the normal player next up are the individual actions so this is what actions your game can take like for example move or shoot so for example let's name this simple action just jump then over here on the properties you can see the action type so it's a drop down menu you can select from value button and pass through now value is for continuous inputs so something like movement being controlled by a joystick would be a value type button is like the name implies for things that work like buttons so something where you press and release then passthrough is similar to value but it bypasses something called disambiguation which is the process through which the input system decides which input is active but for now don't worry about that let's just focus on value and button now this is a jump action so let's make it a button then we have interactions this is the various ways that we can interact with an action of this type so for a button you've got the whole multitab press and so on if you just want a basic button pressed and you don't need to add anything that's the default and finally processors so this is how you can apply some processing to this specific action itself this is more useful for when dealing with joystick inputs for adding a dead zone and so on but we'll see that in a bit okay so when you create a new action it also created a new binding if it didn't you can just right click and add a binding so the binding this is the actual physical input that we want to tie into this action then for selecting the physical input you can click on this drop down menu and manually select it so go into the gamepad and over here you see all the various buttons that you can map alternatively for more advanced use case you can turn this into a text box and over here type in the actual button this is a special syntax used by the input system so again for now don't worry about that let's keep things simple and the simplest of all is just to click on this button that's named listen so when you click now you can press any key you want so in my case for jump let's press the space bar and there you go that one listens to the spacebar on the keyboard and just select it all right so with that we have the most basic input asset done we made the player action map inside we defined a jump action we made it so that it works like a button and we bound that action to the physical spacebar input now let's see how to actually use this to jump an object and also one very important thing that you cannot forget is to actually save this asset so up here you've got a button for save asset and up here on the title for this window you can see a little asterisk this means that there are unsaved changes so when you see that make sure you save it and also up here on the right side you have a toggle where you can enable to auto save so the reason why this is a toggle not simply enabled all the time is because of the c sharp question generation which we're going to see in a bit but until we do and turn this on and make things simpler okay so now that we have over here our actions working in order to use them the simplest way is with a prebuilt component so i've got my testing scene here i essentially just got a floor and then i've got a basic sphere object so i want to jump the sphere and now over here let's add a component and let's search for player input so this is a builtin component that is really useful for working with the new input system over here you can see it takes an input action asset so just drag the one that we created there it is then we've got default map right now we just have one so let's default to that one then we've got some more advanced use cases for dealing with the ui camera and so on so just leave these at none and then you've got the behavior so this is how the actual notifications of each action are sent and over here you've got various methods you can use so first of all you've got send messages which uses the unity send message system so it triggers functions with these names on any script attached to this game object then the next one is broadcast messages this one is similar to send message except that it also triggers functions on any child objects but most of the time you should use one of the other two so either yinty events which you may already be familiar with or basic c sharp events so let's see the unity events now here we get an events tab that we can expand to see all the various events that this object will fire so by default we've got these three so when it's triggered when the device is lost for example a gamepad gets disconnected regained so the gamepad gets connected again or controls change so for example you swap from the keyboard to the gamepad so these are normally in the event so you can click on the plus icon select an object in a function to trigger them and then up here you've got the player so that's the specific action map that we created and up here we've got the jump so this is the event that we made the actual action so this is where we can trigger something so let's make a script that we can then feed into here in order to have our event so up here i'm just going to make a basic c sharp script call it testing input system and here let's attach it to this game object okay now in here let's just make a very simple function so let's make a public void jump and on gem let's just do a debug.log jump okay just very basic and for the object let's drag this game object as the object and for the function let's go down to the testing input system and the jump function okay so like this let's test so here i am as i press the spacebar if there you go i've got unlock all right it does work now let's just make the rigid body jump upwards so just for fun okay so just like this just add four support just to make this weird jump so here and as i press the spacebar if there you go the sphere jumps all right so far so good now however there's one interesting thing that you might notice which is even though i press the spacebar just once over here we actually see three unlocks now the reason for that has to do with the various phases that the input system goes through so it's essentially one log for when the button was pressed another one for the button is currently pressed and finally for the button release if we expand the event we can see this event can be called with a parameter of type callback context this is the type that contains more data on specifically how the button was pressed so let's modify our function to also include this parameter so back in our script let's add using unity engine.input system and then we can modify this one and we're going to receive of type input action dot callback context then of course if you want you can just directly go to definition and inspect all the source codes all the various things that this one does but over here let's just see the actual phase so let's set him to the log the context dot phase and back in the editor since we modified the function let's assign it again so once again the jump function there we go so let's test okay so here and as i press the space bar and if there you go you can see the various stages it goes through so the starting so that's as soon as i press perform so that's i'm currently pressing it and cancelling which is when i release so these are the three separate stages that the input system goes through so for example for a button chances are you really only want it to be triggered once when the button is pressed so you can use the performed event you can either test if the phase equals phase not performed or you can just go if context not performed so this is a simple boolean that simply returns true if it is in the performed phase so if on the performed then you do this okay so like this so here i am and i jump and there you go it jumps much less because only being implies the force once and you can see that we just have one log all right awesome so that's one way to make it work by using our input unity events but then like we saw the other method is using c sharp events so let's see how this one works so when you click these are c sharp events so they are not visible in here in the editor so the way you subscribe is like any other c sharp event so it's through code so first of all let's get our component so private it's of type player input okay so we have that one and then through there we can see all the various events that it has so it's got the default ones that we saw a while ago so on device lost regained and on controls changed and then for the various actions you've got this one on action triggered so regardless of how many action maps you've got you've just got this event so as you might imagine the one big difference is that this one is triggered for all actions on all action maps now right now we just defined one action but if we had more then any action input would fire this one event so let's simply subscribe to this one and as you can see this one takes a parameter of type combat context so when we get the context let's just do a debug download on the contacts just to see what this is doing okay so let's test okay so here i am as i press the spacebar and if there you go now i can see the various contacts so i can see the action is in the action map player it's the jump action it was triggered by the keyboard space then for the phase this one is disturbing it happened on the time of 5.9 seconds and once again the key keyboard space with the value of one and no interaction so you've got the starting phase the performance phase and the canceled phase so in order to use this method then you do some identification over here on the action field and depending on what action it fire then you do different things but if we're going with this method of using this builtin player input class then i think it makes more sense to use unity events for this one so again you can use both but here i'm going to switch back so just like this and make sure that on jump event it triggers the jump action okay so now it's a good time to look into action interactions so back in our input manager we've got the jump action over there it's an action type button okay and we've got the interaction so let's add one let's for example look at the whole interaction then if you want you can set how long so how much time do you have to hold the button before it's actually triggered as a hold event so you can use the default so just take this box or untick and set anything that you want and like this message says you can click over here to open the input settings so this opens up the project settings and goes over here to the input system package and you can then create a settings asset and modify all the defaults so let's test just with the default so just a hold once again don't forget to save just in case you have autosave disabled and back here we are not using c sharp event so let's just clean up the code just get rid of this so it's easier to understand and over here on the jump let's actually do a debug.log on the entire context okay so we have the whole interaction now let's see just how often this function will be called so here i am and if i just quickly press yep we can see we've got the start and the cancelled phase but we did not get the performed phase that is because we did not hold on for long enough and the sphere itself did not jump because it only jumps on the performed face so if i click and i hold after half a second then it does do the performed and now as i let go now it does the cancel so as you can see the interactions are super useful for making some more complex actions and again remember that everything that we're doing here we're making it work with the keyboard but if we add another binding it would also work with the gamepad or touch or anything else and also this is a list so you can have multiple interactions so you could have a home then a slow tab and so on although ideally chances are you would make them into separate actions okay so that's interactions and then you've got the processors like i said these are really very useful for buttons but you can for example add an invert processor and right now before we hit play and clear the console we can see that as we were pressing we were getting over here the value of one so on the started and performed we've got a value of one and then on cancel we got a value of zero now if we add the invert processor so now as i click and if there you go now instead of pause one we get minus one so these processors apply some sort of processing on top of the actual event this is going to be more useful as we get into the movement joysticks but we'll see that in a bit okay so with this we have covered the absolute basics and we also saw how the builtin player input component works but like i said previously you also have the ability to generate a csharp class and have a lot more control over it so let's go into the project window and over here so like the actual input actions asset then you got a button to edit the asset which opens up this window and then you've got a toggle for the generate csharp plus so you can take this one and then you see all these inputs so if you want you can modify what file they're going to be generated in what class name what namespace and so on but here just leave them as defaults and hit on apply so as you do you can see over here that generated the c files over here the player input actions now if you want you can open and inspect this it just generates all kinds of functions fields and events based on the input action so for example we defined a player action map and over here we can see the player action map right in here and then for the player we define some actions so we define the jump action so over here we can see an interface that implements the jump action over here the player actions so all of this code is all dynamically generated so we've got our jump action and the various events started performed and cancel so you really don't need to worry about how this script works but if you want to feel free to inspect it so back in our testing input system here in order to use that we just need to create an instance of our generated c sharp class so it's called player input action so new player input actions so just construct this object and then on this one we need to access the player action map and then we're going to access the jump action and finally we're going to subscribe to the performed event so just pause equals and subscribe to this one and there you go the signature is exactly the same so on gem performed you've got a comeback context and then over here you can do anything so let's use this exact same function instead of creating a new one so just like this let's see if this works and just up here right now we're no longer using the player input so let's actually remove this component so we're just going directly through the c sharp class so let's try here i am and as i hit space and nope nothing happens now that is because we need to make sure to enable this input action so by default when you construct is actually disabled so it's not actually listening to input so in order to enable it we actually have various ways we can do that we can go directly into the player input actions and call enable however if you do it like this it will actually enable all of the various action maps so if you had one for the player one for a vehicle one for the ui all of them would be active at once which is probably not what you want to do so instead of enabling the entire input actions asset you can just go into the player so just go into this action map and just enable just this one and now here if i hit space if there you go everything works so i've got the performed action and it triggered the jump and it jumped the rigid body upwards and again note how here we only have one log that is because since we're going through this one we are only subscribing to the performed event so if we wanted of course we could also subscribe to the started or the cancelled event but chances are we just want to perform so this is actually much better okay with this working now let's add some more actions so on the input action asset let's add another action so we click on the plus button here let's name this one movement and now here is the reason why there's a toggle for the autosave which is because of the c sharp class generation if you have the generation enabled and you change this one tiny thing so for example over here change from button into value as soon as i change then you can see down there that unit is compiling so everything is frozen i gotta wait a bit and so on so if you do have c sharp generation enable then it makes sense to disable it do all your changes then save and when you save then it does generate the csharp plus okay so this is our movement action then over here for the action type this is not a button so we're going to use value and then you can see a field for the control type so this is if you want to limit it to a specific type like for example only allow the dpad or analog inputs or anything or you can also go with any if you're not entirely sure but in this case we do know that we want movement which means that we want an x and y axis so let's go with a simple vector 2. and then let's also delete the default binding that was created automatically so just right click over here click on delete and instead let's click on this plus icon instead of adding a normal binding let's add a 2d vector composite so with this we get four directions so up down left right so this makes it perfect for binding to something like the arrow keys or w a s and d so i'm going to do that to just select this binding then over here on the path click on this one click on listen this one is up so press on the double key there you go w then down go over here press on s then left let's go into a and finally the right let's go into d all right wsed so again don't forget click on the save asn so now it's going to regenerate the c sharp plus and now once again you can either go through the player input component or access the c sharp class directly so let's use that method since we're already using it here so for that one let's go into the player input actions then we're going to go into the player action map and now the action is named movement and let's subscribe to the performed event okay so when that happens let's just do a debug.log on the context so let's test like this and see what the context contains so here and i'm going to press the double key and here as soon as i do you can see that happened so you can see the context triggered on the player action map on the movement action which has all these mining so w a s and d this was a perform phase on this time and if you look a bit further you can see over here the value we've got a value of 0.0 and then 1.0 so i press on w so that means i've got a 1 on the y then if i press on the s i've got zero minus one if i press on a i've got minus one zero press on d and i've got plus one zero so we've got the perfect vector two in order to actually move our sphere so let's use that to move our rigid body so up here on the context in order to read the actual value let's go into context and then you call the function read value and this one takes a generic for the actual type here we have a twodimensional array so let's read it as a vector two and now in this case this is the movement direction that we want to apply to the rigid body okay so here we're doing context out read value reading a vector 2 so this is going to be our input vector then i'm just doing a sphere rigid body in order to add a force then for the force i'm constructing a vector 3 because the sphere is in 3d and the input vector is in 2d so just making that using the input vector x then 0 on the y since i don't want to move this here upwards but rather back and forward so just put that one multiplied by a certain speed and so on okay so let's just like this so here i am and as i press on w and if there you go it did move the sphere however you can see that it moved by a tiny amount so now i press on s and goes backwards and now i press on d and goes to the right press on a and so on so the one thing that you do notice is that this input gets only triggered once so it's essentially on a button press so if i want to actually move the sphere i've got to spam the buttons that's not supposed to be like that ideally for a movement input it makes more sense to constantly check the current state and constantly apply it so for that we can go with another method instead of over here subscribing to the performed on the movement action we can make a very simple private void update and over here we can actually read the value on every frame so you can go into player input actions so that means that we need to make this as a member field so you go into that one access the player action map access the movement action and then over here we can call read value read as a vector 2 and so on so the same thing that we're doing here let's do it up there okay so the exact same thing except on the update we're going through the player input actions player movement and so on and then applying the force and everything should work so now let's see so now as i press and hold any there you go now movement is indeed being applied on every frame let me just lower the speed and since this is a rigid body we should probably do this on fixed update and yep now in here i can read use wasd in order to actually move my sphere so move it to the right move it upwards then start moving downwards and so on all right so now it's working and i'm reading the value on every single update so chances are for movement you want to go with this method instead of the event method okay so now it's probably time to look into how multiple inputs like keyboards and gamepads work over here on the input action assets if you go on the top left corner over here you've got a button where you can add a bunch of control schemes so let's add one let's call this the keyboard and over here on the list you select the type so let's select of type keyboard and hit on save then here for each individual binding you can go ahead and over here tick and make sure that this one is used in the keyboard control scheme so just select that one in there then over here for all these select them one by one okay so now all of these bindings are set as keyboard bindings and now we can go up here create a new control scheme name this one gamepad and on the list let's select a gamepad select a generic gamepad and just hit on save and when you do you can see that the bindings disappear now if you want of course that are not lost so you can go back into the keyboard and you can see the keyboard bindings then go into the gamepad and over here we're going to add gamepad bindings so right now i just connected my xbox controller and you can also see over here on the logs that the input system automatically detected that that one was connected so with this let's do just like we did so on the jump let's click on this we're going to add a binding then for this binding go into the path and listen and i'm going to press a button on my xbox controller so i'm going to press the a button however if you try this it might not be working that is because i connected the gamepad right while the game was running so to solve that just make sure you save the asset and just play the scene and then if you quit again now it should be identified so now i can go up here click on listen press on the a button and there you go it does connect in order to validate that everything was connected there's actually one that is super useful that i'm going to talk about in a bit but just here briefly you can go over here into window analysis input debugger and over here you should be able to see your controller connected okay so anyways click on listen click on the a button and over here you see an interesting thing about the input system if you want you can select the a button on the xbox controller so if you do that then this action will only be triggered by the xbox a button meaning that pressing x on a playstation controller will not trigger this action so the better approach you can take is just use this one just button south gamepad this is a generic control that won't work on any gamepad so you've got buttons south north east and west and with that if you sound like this one so button south gamepad so the generic one if it's unlike this one then don't trigger on an xbox a button or on a playstation x button or on a switch a button and anything else that has the standard inputs okay so that's the simple button input okay and then over here for the movement let's click on this button and now for the keyboard we made a 2d vector composite that's because it was based on four buttons but for the gamepad we really just want to use a joystick so let's use a normal binding and then over here for the path just click on listen now i'm going to move around the lipstick and it automatically identifies so once again you can go with the xbox controller or the more generic gamepad alright so that's it and now just with this we can see the true power of the input system which is we do not need to touch our code at all the code is already set up to work with the jump action and the movement action regardless of whatever physical input they come from so just with this if i click on save asset and i play the game now i can for example press space on the keyboard in order to jump and now without doing anything special i'm just going to press the a button on my xbox controller and if there you go it does trigger the jump now using the gamepad so here this is the example of the awesome power of the new input system so it allows you to completely separate actions from the physical inputs you write your code to work simply with actions and then you set up the input action asset with how those actions are triggered and then without doing anything else your game now works perfectly with any input so the player can seamlessly switch between keyboard or gamepad and anything else and everything works perfect alright awesome okay so with that you already know the basics but let's see a few more things for example like i said the processors they are super useful when it comes to game pads and by the way here since we actually have two control schemes we can add processors on the action itself so click on the action and add a processor this will apply to the action regardless of whatever control scheme you're using or you can just add the processor directly on the actual binding so this is useful if you want to apply a processor to the gamepad but not on the keyboard so then over here one of the more useful ones is over here the stick dead zone this helps when gamepads have slight issues and they aren't perfectly on zero zero so for example you've heard of the nintendo joycon drift that is where the actual physical joystick gets slightly moved to the side never actually goes down to zero zero so that is why you have the stick that zone so with this processor what it does is if you move the stick bound less than this amount then it won't be considered zero so it won't do anything and if you move it by more than this amount then it won't be considered one and also the value between these two is normalized so for example if i take away this one and i put the minimum at 0.5 so now it should only read a value of more than zero after i move the stick more than half words towards any direction so over here i am physically moving the stick and as you can see nothing on the console so it's not listening and once i get past the halfway point so just a bit more and there you go it does start to actually move let's add a log so we can see the actual values so up here let's do a debug.log on the input vector to see what this says so over there it's all at zero and as i move a bit and it's still at zero and only once i go past 0.5 then it actually reads the value 0.1 so like i said this is normalized so as soon as i move past the half now it starts reading the value and if i go way past to the side so if i go past the 0.975 then it reads as an actual one so that's what the processors do as you can see adding the stick dead zones to gamepad 6 is something you should always do so your players can play the game even if their gamepad isn't in perfect condition and just as another quick example for example you've got the normalized vector 2 so as you saw if i move the stick by a tiny bit then it only shows like 0.1 but if i add the normalize and now as i move just one tiny bit you can see the values are normalized so even if i move just a tiny bit the magnitude of the actual input vector always goes up to magnitude of one okay so now it's time to talk about the thing that i mentioned a while ago which is for the input action you've got value button and then pass through now pass through is similar to value but it bypasses something called the disambiguation which is the process through which the input system decides which input is active now like i said the input system handles all the complex logic when you have multiple inputs connected like for example multiple gamepads and when using value it will only trigger the action for the active gamepad whereas on passthrough it will trigger the action for every single gamepad so now i also have a playstation controller connected and if i move one you can see on the log that it does change but then it goes back into zero and so on that is because right now it is receiving input from multiple controllers so i'm just moving one controller and not the other one and the input as you can see it's very erratic so the issue is because receiving inputs from all of the various controllers so for example one of them is telling them to go right the other one left and so on so the whole thing gets all messed up whereas if i set this back into value and over here if i'm moving using the xbox controller yep now the log is actually correct so it's only listening to input from the xbox controller and now if i instead start moving the playstation controller now it's listening to input from download so now it only listens to once at a time so only the one that is active gets listened all the other ones get essentially ignored so passthrough is useful for if for some reason you want to read input from every device at once but for the most part you really want to use value now so far we've been playing with an input action that we created from scratch however if you want to quickly get it up and running you can also use the default so if you go onto a game object and then add the player input component if you do not assign anything here and instead you click on this button then it asks you for a path so you can save it and it automatically creates the default input actions asset so this one is prefilmed with a bunch of action maps and a whole bunch of actions so if you want you can use this as a starting point instead of building your own from scratch or you can just look at this one to inspect and see how they implement things so this one has got all kinds of control schemes e2 action maps all kinds of actions and so on now on the lecture where i cover the differences between the input manager and the input system i said that the input manager is just more simple and more compact in general while that is true the input system can also be very compact if you want it so for example just testing for a simple mouse click you can do a private void update and on update you can do go inside the mouse access the current active mouse go into the left button and then check was presses frame if so then with this you've got a simple test testing if the mouse is pressed then you can also test for specific gamepad so you access the gamepad class you access the current one then you can access all the various buttons so a b button north south and so on you can also go into the keyboard and access the current the nexus for example bt key and so on but do remember that this super compact method is something you should really only use for a very quick test or prototyping something new when building something more permanent you should absolutely be using the actions and not be working directly with specific buttons at all one more thing here in the code is with regards to multiple action maps so as an example let's create one to see how it works so first of all go up here create a new action map let's say this is the ui so we want a bunch of inputs for navigating through our ui and up here let's just add a single action so just submit so just clicking a button and then for the binding let's just bind it directly into the spacebar so since it's bound to the spacebar which also on the player it's also bound to the spacebar so the player has got to jump to the spacebar and the ui has the spacebar doing a submit now how do you tell which action map should be active if you're using the player input action first of all let's make a function for the actual ui submit so over here you've got the various action maps so you expand upon this and set it so here let's just copy this one do the same thing except this one call it submit okay and now here let's just hook onto that event okay so we got both events both of them triggered by the same physical button but they are on different action maps so over here on the player input itself you can see the default map so this is the starting one so that you start on the player or the ui or so on and now how you change them is over here through code you've got the player input so you get the component and so on and then you trigger the function switch current action map you do that and then you pass in the map name or the id so let's use this super compact testing that i mentioned previously instead of the mouse let's go to the keyboard so if i press the t key we're going to swap the player input to the action map ui and if i press the y key we're going to swap it back into the player action map and then by pressing space we should see either this function or this function so let's see okay so here i am as i press space and yep it's firing the jump action on the player action map now i press t to swap out the actual default map and i press space again and you have now it's instead firing the submit action now press y to go back into the player and so on and down so yep this is the function that you trigger in order to swap between each action map so for example if you had a ui that was only meant for the pause button then when the player hit on pause then you would call this and when the player had on the resume you would go with this one so this is when working with the player input builtin component and when working with c sharp one is very simple like we saw it only works if we actually enable it so on that one we would enable the player by default then when we want to switch we would disable the player so just go into the player call disable and then go into player input actions access the ui and call enable so if you went with the c sharp method then this is what you would do now something that i showed a while ago that is super useful is the input debugger you go up here into window then down here into analysis and open up the input debugger and over here it shows you all the various connected devices so for example in my case i've got a mouse keyboard i've got a dual shock and an xbox controller then you can also see for example some unsupported devices so for example i recognize my microphone but of course it's not a actual gamepad then it also recognizes a bunch more and my specific mouse isn't being recognized but it is on the generic mouse and then you can also double click on each of these to go in further so for example double click over here on the xbox controller now for example if i press the a button if you can see over there on logs it does recognize and i'll let go and it goes back to zero so you can see up here on the valley the actual valley that it's reading directly from there so as i click there it goes here and so on and if i move the dpad then you can see all the various directions and if i touch on the left trigger you can see yep the value going up and down and so on so this is very useful to verify and make sure that your controller is indeed connected and unity is indeed receiving the input correctly so with this we have the new input system working one thing that is required in pretty much every game is rebinding keys so let's see how that's done over here on the testing script let's try rebinding the player jump action so to do that we access the same jump action and then we call the function perform interactive rebinding so this will essentially do what we saw of pressing the listen button so you call this this creates a specific object and then you call start to actually start listening so when you do then listen to the next input and assigns that to this action however just like this we're going to get an error but let's see it and if there's the error we cannot rebind something once something is currently enabled so over here we are enabling the player action map so when we go to rewind we need to make sure to disable so first we disable and then we start actually rebinding so like i mentioned a while ago we create the various action maps so for example one would be for the player ingame actions and then another one for the ui inputs and then while the ui input actions was enabled then you could easily rebind the player input actions now this function this one the perform interactive rebinding this actually returns an object of type rebinding operation this object is what actually contains all of the data regarding the rebind then you can also add all kinds of modifiers in order to do various things before you actually call start specifically it has an uncomplete event so we can hook into this one in order to listen when the actual rebind completes so for that we perform the interactive rebinding then instead of calling start right away let's first call on complete and on complete this takes an action so this one takes a call back as a parameter so we can do it like this so just a simple lambda expression and in here let's just do a debug.log on the comeback okay now let's play the game and that function was triggered on the wake so right now it isn't listening for a button so as i press for example the t key there you go it actually worked it rebound the key but we also see an interesting error related to a native collection that was not disposed of that is because you must manually dispose of this object in order to avoid any memory leaks so the object is the actual rebinding operation so that's the same one that we get over here on the comeback so on complete we do this and then we can call this pose so we dispose that and after the rebind completes let's reenable the action map so we try it out so we reenable this one and then let's see okay so now it's listening to input so as i press the t key yep now it should have rebound the jump action onto the t action so if i press the space bar nope it no longer jumps and if i press t yep now it does indeed jump alright great now like i said there's tons of filters you can apply in here you can inspect the rebinding operation to see all these various filters and things so for example you can add a canceling button or you can limit the expected control type or for example you can limit some controls so for example you do with controls excluding and then let's say exploiting the mouse so with this i won't be able to rebind this action onto the mouse so if i'm here and i click with the mouse and nope it's not rebinding because the mouse is not accepted but if i press a different key on the keyboard if there you go now it doesn't rebind so with that we can now rebind our actions so i rebound this to the t key so as i press t it actually jumps okay great however now if i stop playing the game and i start playing again and now press the t key and nope it's not jumping it's once again back to the default back to the space so naturally we need to actually save the rebins and for that there's actually two ways depending on what version you're using now if you're using version 1.0 then you need to manually save them but if you're using version 1.1 then there's a much easier process so when you actually rebind so after the on complete it actually changes one thing in the asset so for example over here on the comeback you can access the action and then for each action you've got various bindings so you can cycle through this one or in this case we just have one so just zero for testing and then for each binding you've got a field for the override path so let's look at what this log and as i press the t key to rebind there you go it did rebind in order to the keyboard t so if you're using version 1.0 then this is what you need to do you need to go through your input actions go through all the action maps cycle through all the bindings for each action and save up the override path however if you're using version 1.1 then there is now a function to return some json for all of the overrides so you just call this function and it returns a json string which you can then easily save in a file or the player prefs or anything and then another function for actual loading so depending on your version you've got two different methods okay so the last thing we need to cover are the touch controls you can define the bindings like any other so for example if you look on the input actions that are created by default on this one for the control schemes you can see it does have a touch control scheme and that one you can see that it does have the very specific touch controls so you can do this to set up the individual bindings but beyond that there's also a super useful builtin component so here let me make a canvas and then inside the canvas let me make an empty game object and now inside i'm going to add a ui image and for the image i'm going to select a basic circle and now just take the stick and let's put it over here on the corner and now the image itself we can add a component and search for onscreen stick this one then it's got two fields so the movement range that's how much this image is going to move relative to the parent and then the control path which is what this stick will simulate so in this case we can click on this let's go into the gamepad and we're going to simulate the left stick so if we play now as i click and drag the virtual joystick and yep there you go it is indeed moving the sphere so it's moving in any direction and if i push to the edge and it's the 50 units that we saw there so just like this it is automatically working and then the other builtin component let's make another image put it on the other side and this one is the onscreen button so this one same thing is just acts like a button so let's pretend that this one is the gamepad south button so as i click on this one yep it's simulating a jump so for mobile you can build your own ui from scratch and attach the touch specific bindings or you can use these super awesome super useful builtin components in order to simulate a gamepad using touch and everything else in your game won't work seamlessly alright so that's a new input system package this was a prebaking lecture since it's a pretty complex system but hopefully you can see how the complexity does pay off this system forces you to separate your logic and abstract actions away from physical inputs which in turn leads to writing better cleaner code and a game that can be played on any input device go watch the input manager versus input system lecture if you haven't seen it yet in order to understand the differences but if you're working on a proper game then this system is awesome and it's definitely what you should be using alright so this was a lecture from my ultimate unity overview course there's lots more explaining tons of things like shadowgraph similar definitions pro builder the video player and so on go ahead and get the phone course and learn how to master all the unity tools and features to help you make better games faster alright hope that's useful check out these videos to learn some more thanks to these awesome patreon supporters for making these videos possible thank you for watching and i'll see you next time
