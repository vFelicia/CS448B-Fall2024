With timestamps:

00:00 - hello and welcome i'm your code monkey
00:01 - and here let's build a third person
00:03 - shooter controller so we have our normal
00:05 - third person controller and we can move
00:07 - our character in any direction then by
00:09 - pressing a button we can go into a mode
00:10 - where we can then shoot so we need to
00:12 - handle the two states and on the camera
00:14 - and the animations handle how the bolts
00:16 - work and put it all together in a nice
00:18 - clean way so we can expand upon it in
00:19 - the future
00:20 - and for me personally this demo project
00:22 - was a great new learning experience i'll
00:24 - talk about it in a bit this is a pretty
00:27 - long video since it involves quite a lot
00:28 - of individual elements so if you want to
00:30 - skip ahead to a particular topic or
00:32 - watch the final polish controller
00:34 - there's timestamps in the video if you
00:35 - prefer a more guided path with
00:37 - step-by-step lectures then check out my
00:39 - complete courses learn how to make a
00:41 - bundler defender game using c-sharp just
00:43 - like i make my own steam games or learn
00:46 - how to make games internally using
00:47 - visual scripting or learn all about
00:49 - unity with the ultimate overview course
00:51 - which contains over 13 lectures each
00:53 - covering a different tool or feature of
00:55 - the engine to help you make better games
00:57 - faster i'm always available in the
00:58 - courses q a section answering your
01:00 - questions every single day so check out
01:02 - all the courses with the link in the
01:03 - description okay so let's build a third
01:05 - person shooter controller now this video
01:07 - is kind of split into two parts the
01:10 - first part is a step-by-step tutorial on
01:11 - how you can recreate all the logic and
01:14 - then in the end i will take that as a
01:15 - base and polish it into a really nice
01:17 - third-person shooter and talk about my
01:19 - research process for building this but
01:21 - first of all let's actually make it
01:23 - so here is my starting scene now i
01:25 - already have a third person controller
01:27 - this is the super useful controller made
01:29 - officially by unity it's part of the
01:31 - star assets which includes this
01:32 - controller as well as a first person one
01:34 - i covered both of them in another video
01:36 - and you can grab them for free from dnt
01:38 - asset store so what i have here is
01:40 - exactly that third person controller so
01:41 - with that i can already look around i
01:43 - can move around i can walk run i can
01:46 - jump and so on so all this by default
01:48 - just by importing that package
01:50 - now on top of this we're going to build
01:51 - our third person shoot on logic so the
01:53 - first thing that we need is just like i
01:55 - mentioned in that other video we need to
01:56 - make a second virtual camera set up as a
01:58 - shooting camera
02:00 - so over here is my scene
02:01 - and the only change that i did is over
02:03 - here on the player phone camera i put
02:05 - the shoulder offset on these values so a
02:06 - bit to the right and a bit upwards so
02:08 - there you go so it's like this and i put
02:10 - the camera side all the way to one so
02:12 - this is to make it so that it's a bit
02:13 - more like a third person shooter so you
02:15 - got the crosshairs down the middle and
02:16 - the character slightly to the side so
02:18 - let's first duplicate the player follow
02:20 - camera let's call this the player aim
02:22 - camera
02:24 - and over here just modify some settings
02:26 - so in order to see difference let's just
02:28 - increase the priority so let's put it at
02:29 - 20. so this is the one that is now
02:30 - active
02:32 - okay so for these settings first of all
02:34 - we want to zoom in so a slightly lower
02:36 - fov so let's put it maybe on 30. so
02:38 - slight zoom in
02:39 - then let's also push the camera a bit
02:41 - forward so over here on the camera
02:42 - distance push it a bit forward so maybe
02:44 - something like 2.5 okay
02:46 - so with this if i enable and disable we
02:48 - can now see the difference so this is
02:49 - the normal camera and this is the zoom
02:50 - in camera
02:51 - and over here again the difference that
02:53 - i made from the default third person is
02:54 - we've got the camera side all the way up
02:56 - to one meaning that you can easily
02:58 - toggle between the left and right
02:59 - shoulder so you go from zero it's on the
03:01 - left shoulder go to one on the right
03:02 - shoulder so that's a pre-standard option
03:04 - in any third person shooter
03:06 - okay so with that that's pretty much it
03:08 - everything else is pretty much the same
03:09 - so we want third person follow so
03:11 - everything else is correct
03:13 - so with this we now have two virtual
03:15 - cameras
03:16 - so the first thing we want is just some
03:17 - basic logic to switch between them so
03:19 - let's begin by making our script so in
03:21 - uc sharp script
03:22 - called the third person shooter
03:24 - controller
03:25 - and here on the player armature let's
03:27 - just drag this script okay now here
03:30 - let's first begin by adding a reference
03:32 - to our aim virtual camera
03:34 - and for that let's make it of type
03:36 - cinemachine virtual camera just in case
03:37 - we want to change something on the
03:38 - camera itself later on so we need using
03:41 - syn machine
03:42 - and then we're going to make a thin
03:44 - machine virtual camera
03:49 - for the aim virtual camera
03:52 - make it a serialized field so we can set
03:54 - it in the editor
03:56 - so back in here just drag the reference
03:58 - all right
03:59 - now here since we already set the aim to
04:01 - have a higher priority all we really
04:03 - need to do is just enable or disable
04:04 - this game object so to do that let's
04:06 - make a private update and now here we
04:09 - need to test for input
04:10 - and for that the star assets package is
04:12 - using the new input system so for the
04:15 - aim let's use that one as well if you
04:17 - don't know how to work with new input
04:18 - system package go watch my video on it
04:20 - it's a very capable system that makes
04:22 - input handling super simple and it's
04:24 - what you definitely should be using in
04:25 - your final projects
04:27 - so it's eastern action so let's just
04:29 - open this one and here it is all the
04:31 - actions involved in this third person
04:32 - controller so let's add another one
04:34 - let's call this aim
04:35 - and now normally for type itself i would
04:37 - use it as button but here i'm trying to
04:40 - stick as close to the standard set by
04:41 - the starter assets so let's set it up
04:43 - exactly the same way as the sprint here
04:46 - so both these are meant to be hold
04:47 - actions so let's set up the example the
04:49 - same way and this one is set using
04:50 - passthrough so over here let's do the
04:52 - same thing pass through okay and then
04:54 - for the bindings let's add one let's
04:56 - listen listen to the right mouse button
04:58 - and let's also add another one and this
05:00 - one is going to be for a gamepad and for
05:03 - aiming let's go to a left trigger there
05:06 - it is then just make sure to assign this
05:08 - one to the gamepad control scheme and
05:10 - this one is on the keyboard mouse
05:11 - control scheme okay our action is
05:13 - defined let's just hit on save ascent
05:15 - now we need to listen to when that
05:16 - action happens
05:18 - so on the star asset itself we can see
05:20 - that it's using the player input method
05:22 - and for the behavior itself it's using
05:24 - send messages now personally when using
05:26 - this class i would prefer to use unity
05:28 - events but again i don't want to change
05:31 - this i want to stick with the standard
05:32 - made by the start asset so let's use the
05:34 - same method
05:35 - and if we stick with the same pattern
05:36 - then we listen to that event over here
05:38 - in this start assets input
05:40 - so for the behavior we want it really to
05:42 - be exactly like the sprint so we can
05:45 - examine just copy all that logic so
05:47 - instead of a sprint let's make an aim
05:49 - and then down here we've got the on
05:51 - events and so let's copy
05:53 - let's make this on aim
05:56 - then we're going to make an aim input
05:58 - function
06:01 - and then down here let's copy the spring
06:03 - input
06:06 - and just make it the aim input
06:15 - okay so there it is we made it work exam
06:16 - like the previous one
06:18 - and now in our third person shooter
06:19 - controller first we need a reference to
06:21 - the start inputs
06:24 - so a private star assets inputs so this
06:27 - one is inside a namespace
06:36 - all right we have the inputs and then on
06:38 - our update we're simply going to test go
06:40 - into that one and test for the aim
06:42 - volume
06:44 - so if this one is true we want to enable
06:45 - the aim virtual camera so let's go into
06:47 - this one.gameobject and we're going to
06:49 - call
06:50 - setactive
06:52 - and if it's true we're going to set it
06:54 - to true and if not we're going to set it
06:56 - back into false
06:58 - okay so just with this it should already
07:00 - be working so let's test okay here i am
07:02 - and everything looks normal now i right
07:03 - click and there you go it zooms in and
07:06 - i'll let go and yep it zooms out okay
07:08 - now it's obviously way too slow so let's
07:10 - fix that let's go into the send machine
07:12 - brain so on the main camera we've got
07:14 - this in machine brain and over here
07:15 - we've got the default transitions so
07:17 - it's taking two seconds let's make it
07:19 - quite a bit snappier so maybe point one
07:22 - let's see
07:23 - so here it is and i hold yep there you
07:25 - go now it's nice and snappy okay great
07:28 - so the next thing that we need is aim
07:30 - sensitivity right now the sensitivity is
07:32 - the same in both modes which works on
07:34 - right over here in normal mode but if i
07:36 - zoom in then it's way too intense it's
07:37 - very difficult to aim correctly so let's
07:40 - set up the logic to have two different
07:41 - sensitivities
07:43 - now in the video where i made an
07:44 - overview of the starter assets in there
07:46 - i already covered how you can add
07:48 - sensitivity to the third person
07:49 - controller which doesn't have that field
07:51 - by default
07:52 - so let's modify the third person
07:53 - controller script over here let's just
07:56 - add another one so let's make a public
07:57 - load called sensitivity
08:00 - and define it to 1f
08:03 - and then down here we just find the
08:04 - camera rotation function and on this one
08:06 - we're applying the input so we just
08:08 - multiply by the sensitivity
08:10 - and just that it's already working
08:12 - now we just need to build upon this and
08:14 - we're going to make a function to expose
08:15 - the sensitivity
08:18 - so let's go down here make a public void
08:21 - let's call it set sensitivity
08:26 - okay so we got a function to change it
08:28 - and now let's go into the shooter
08:30 - controller and over here on let's add
08:32 - fields for both of them so make it a
08:34 - serialized field make it private it's
08:36 - going to be a float for the normal
08:38 - sensitivity
08:39 - another one for the aim sensitivity
08:43 - and then we set them to the same way
08:44 - that we set the zoom so we need to get a
08:46 - component of that one
08:52 - all right so we get the component from
08:54 - the same object and then we simply go
08:56 - into that script we call set sensitivity
08:58 - and on this one we set it to the aim and
09:00 - on this one with normal
09:01 - all right so let's set these films in
09:03 - the editor
09:04 - so let's say for normal keep it at one
09:06 - and for aim let's put it at half okay
09:08 - so here i am with this sensitivity and
09:10 - as i zoom in yep now it's much smaller
09:12 - allowing me to be quite a bit more
09:13 - accurate all right great
09:16 - now the one thing missing here is a
09:17 - simple crosshair so we know where we're
09:19 - actually aiming so let's add one now
09:22 - this is very simple we just need first
09:24 - of all a canvas so let's go into ui make
09:26 - a new canvas
09:27 - then for the canvas set it up like i
09:29 - normally do so leave it on screen space
09:30 - overlay over here scale with screen size
09:33 - go with 1280x720 and match with the
09:36 - height so that's just the center that i
09:37 - like to follow and now inside let's make
09:40 - an image so a new ui image
09:43 - just called the crosshair
09:45 - and over here i've got a simple sprite
09:47 - of a crosshair so it's just something
09:49 - very basic that i do in 30 seconds
09:51 - so just sign the image and let's make it
09:53 - quite a bit smaller maybe 50 maybe 30
09:55 - something like that and that's pretty
09:57 - much it nothing else we need to change
09:58 - just make sure it's pivoted on the
10:00 - center and it's on zero zero and yeah
10:02 - there it is now we have our character
10:04 - controller and we can see exactly where
10:06 - we're aiming alright great so with that
10:08 - done now it's time to handle the
10:10 - shooting now for this there's actually
10:12 - two ways you can do it one approach is
10:14 - you can make the weapon shoot actual
10:15 - projectiles or you can make it a hitscan
10:18 - weapon so for that one there's really no
10:20 - right or wrong answer it really depends
10:21 - on the type of game that you're going
10:23 - for now i actually made a video quite a
10:25 - while ago on the various ways to handle
10:27 - projectiles in that video i covered the
10:29 - methods in 2d but the logic we're going
10:31 - to use here is quite similar so do go
10:33 - watch that video after this one to see
10:35 - how it works in 2d
10:36 - now the most complex thing to do has to
10:38 - do with where you want the ball to go
10:40 - now the reason is because this is a
10:42 - third person shooter so that means the
10:43 - camera is slightly off to the side and
10:45 - not right on top of the player
10:47 - so that means that if you have the
10:48 - player itself just shoot forward it's
10:50 - going to shoot forward and not actually
10:52 - shoot where the crosshair is
10:53 - so even if you go with the projectile
10:55 - approach it still helps to do a quick
10:57 - raycast just to see exactly where the
10:58 - projectile should go okay so let's do
11:00 - that
11:01 - now here in our script the way we're
11:03 - going to do that is with an actual
11:05 - raycast now a while ago i covered how to
11:07 - get the mouse warm position in 3d and 2d
11:10 - now that method is making a raycast on
11:12 - the mouse position and see where it
11:13 - lands and that's exactly what we're
11:15 - going to do here
11:16 - so let's actually copy the code from
11:18 - that video it's on the mouse 3d class
11:20 - that i've got on this project
11:22 - so here it is that's the code that we
11:24 - made in that video and here we've got
11:26 - the update making array and yep okay so
11:29 - like this it would work however here
11:30 - we're using the old legacy input manager
11:33 - so we could change this to use the new
11:35 - input system we could do it using unity
11:38 - engine.input system
11:42 - and then over here we could do
11:45 - for example mouse.current
11:47 - grab the position and read the value
11:50 - now we could do this however with this
11:52 - the game would break if there was no
11:54 - mouse connected so it would break for
11:56 - example if you were playing on a console
11:57 - now since we want this to work with the
11:59 - mouse but also just a gamepad let's go
12:01 - with another approach
12:02 - all we really need is the position on
12:04 - the center of the screen since it never
12:05 - actually changes so for that we can do
12:07 - some very basic math to get that point
12:16 - so yep it's that simple we just make a
12:18 - screen center point we grab the screen
12:19 - width divided by two the height divided
12:21 - by two all right so here we have right
12:23 - the center and then we do a screen point
12:25 - array so the same thing as usual
12:27 - then we've got the collider mask so
12:29 - first of all let's rename this to the
12:31 - aim to leather mask and let's define it
12:33 - up here
12:34 - so as usual serialize feel make it a
12:36 - type layer mask i cover layers and bit
12:39 - mask in another video if you're curious
12:41 - to how it actually works so this is an
12:43 - aim collider mask
12:47 - okay so our logic should be working
12:49 - except over here we do not want to
12:50 - modify the transform position but let's
12:52 - verify that it is correct so let's make
12:54 - a debug transform
12:56 - so up here add another field just a
12:59 - private transform call just the debug
13:01 - transform then down here we set that one
13:03 - on the position just make sure that this
13:05 - point is actually correct
13:07 - okay so back in the editor here we've
13:08 - got our script first of all we need the
13:10 - aim collider and layer mask now over
13:12 - here all the walls on the environment
13:14 - all this is on the default layer so
13:16 - let's collide with the foam layer okay
13:18 - then for debug transform let's create
13:20 - just a 3d sphere
13:22 - put it pretty small
13:24 - and just add a nice material just for
13:26 - fun
13:27 - okay so this sphere is going to be our
13:28 - debug transform so just over here
13:31 - let's move it okay so it says and we
13:33 - should be able to see the sphere exactly
13:35 - always on the crosshair position let's
13:37 - see
13:38 - and yep it works so wherever i unlock i
13:40 - can see the sphere is exactly on there
13:42 - so with this we now know the worm
13:44 - position of where we're actually aiming
13:46 - alright so far so good however here we
13:49 - actually have the same issue that we saw
13:51 - with the house building system in the
13:52 - third person video and the other issue
13:54 - is the sphere is approaching so that has
13:55 - to do with the call either
13:57 - so just over here let's just remove the
13:59 - call either and okay no longer has that
14:01 - issue now as i was saying we do have the
14:03 - same issue that we had with the house
14:05 - building system in third person
14:07 - so in that video if you remember there
14:09 - was an issue when we looked at the sky
14:11 - because the sky does not have a call
14:12 - either so that's the exact same thing
14:13 - here if i'm looking at the ground floor
14:16 - and so on everything works there's this
14:17 - here okay but if i look towards there's
14:19 - no collateral so if i look up at the sky
14:21 - and nope the whole thing breaks so
14:22 - there's no sphere anywhere because over
14:24 - there there's no collateral so the
14:26 - simple solution is just like it did on
14:28 - the house building system which is to
14:29 - make sure there's always a collider
14:31 - let's add some basic invisible walls all
14:33 - around the world so there's always
14:34 - something to collide with
14:36 - that's very basic let's just create a
14:38 - new cube
14:40 - let's just move it to the side
14:59 - all right so i've added colliders all
15:01 - around but obviously the player is not
15:03 - meant to be outside in here so very
15:05 - simple let's just remove the mesh render
15:08 - there you go now we've got the colliders
15:09 - but they have no visual and now if we
15:11 - test and we aim around yep everything
15:13 - works perfect alright great so far so
15:15 - good now one more small thing here
15:18 - usually in third person shooters the
15:20 - character rotates as you aim so as you
15:23 - look around right now the character is
15:24 - still facing forward but it should be
15:26 - aiming towards where i'm pointing so
15:28 - let's add that
15:29 - over here we're testing for the aim
15:30 - changing sensitivity and so on
15:32 - so in here let's just calculate the
15:34 - vector from the player to the target
15:35 - position
15:55 - okay so here first of all i have the
15:56 - mouse compilation up on the top so we
15:58 - can use it down here so just to find the
16:00 - vector3 for the mouse one position then
16:02 - we do the raycast the usual thing
16:04 - reposition the debug transform even
16:06 - though we can remove this later and then
16:07 - we just have the muzzle position all
16:09 - right
16:10 - so then we just grab that one and first
16:11 - of all we make it the y match the exact
16:14 - same one as he transformed position y
16:16 - because right now we just want about
16:18 - left to right rotation we don't care
16:19 - about up down
16:20 - so with that then we have the aim
16:22 - direction towards the world name target
16:24 - so with this now we can rotate the
16:26 - player and we can do that with
16:27 - transform.forward
16:29 - so this is the player's forward vector
16:31 - which you can read but you can also
16:33 - write in order to rotate so if you're
16:35 - like me and we prefer dealing with
16:36 - vector threes instead of quaternions
16:38 - then this is a great way to rotate
16:39 - things
16:40 - and to make it smooth let's do it using
16:42 - a vector3.org
16:48 - all right so like this we should be able
16:50 - to see the player rotate to face the
16:52 - world aim target and it should rotate
16:55 - nice and smooth okay let's test so here
16:57 - i am the character is looking forward
16:59 - and i can look around and see the
17:00 - character all right but if i zoom in now
17:03 - i'm aiming and yep there you go now the
17:04 - character does aim towards where i'm
17:06 - actually aiming and the aim itself is
17:08 - also nice and smooth so instead of being
17:10 - instant there's a nice smoothness to it
17:12 - all right great
17:14 - so everything seems to be working
17:16 - however we actually do have an issue if
17:18 - we start to move so if we're moving like
17:20 - this yep so normal i can move and look
17:21 - around but now if i move and aim at the
17:24 - same time and yep now look at that now
17:26 - the character is not looking there now
17:28 - the whole thing is messed up
17:30 - so the issue here is that the base
17:31 - character controller is trying to rotate
17:33 - based on the move direction but then
17:35 - we're also trying to rotate as we're
17:37 - actually on the aim mode so we need to
17:39 - make sure to do just one or the other
17:41 - for that let's make a function to
17:43 - disable the rotation on the base script
17:46 - so over here on the third person
17:47 - controller
17:48 - let's add a simple boolean so private
17:51 - bone let's call this rotate on move
17:55 - and let's default it to true
17:57 - and then we can go down here into the
17:59 - actual move function
18:01 - so it's over here that we're moving the
18:02 - things and so on all right and we're
18:04 - handling the target rotation so over
18:06 - here this is how it's facing the input
18:08 - direction
18:09 - so we're only going to run this if that
18:11 - volume is set to true
18:16 - okay so now we just need to expose this
18:18 - bone
18:20 - so down here do the same thing
18:28 - okay so we've got this function exposed
18:30 - and now on the character controller now
18:32 - we can do that so in here we go into
18:34 - that one
18:36 - so while aiming we set it to false so
18:38 - that one does not rotate and when we
18:40 - stop aiming we set it back to true okay
18:42 - let's see all right so here i am i can
18:44 - walk around the character rotates as it
18:46 - should all right and now if i zoom and
18:48 - if there you go now the character no
18:50 - longer rotates so now it actually always
18:52 - faces the nice same direction all right
18:54 - great
18:55 - so let's continue now the sphere is
18:58 - always on top of the crosshair which
19:00 - means that we know the world position of
19:01 - where we're actually aiming so with this
19:04 - like i said you have two options one is
19:06 - to make the bullet an actual projectile
19:08 - so you spawn the bone on top of the
19:10 - weapon position and you rotate it to
19:11 - face the crosshair worm position and
19:13 - then just move it forward and test for
19:15 - physics conditions as it moves that's
19:17 - one approach and the other approach the
19:19 - head scan weapon is to do the raycast
19:21 - and then we check the object that we hit
19:23 - we test if we hit something we can
19:24 - damage and we just deal damage directly
19:26 - so let's quickly try out both methods
19:29 - so over here i've got a bonus prefab
19:31 - that i prepared previously so there's a
19:33 - parent game object with a rigid body and
19:35 - a collider set to trigger then over here
19:37 - on interpolate set to interpolate so it
19:39 - actually moves smoothly and collision
19:41 - detection is set as dynamic since this
19:42 - one will be moving quite fast then
19:44 - inside we really just have a visual
19:46 - nothing else
19:47 - okay so let's make a script to handle
19:49 - the bone projectile so let's make a new
19:51 - uc sharp script
19:52 - for the bullet projectile
19:55 - and over here first thing is let's get
19:57 - that rigid body so private rigid body
20:04 - okay so on the weight we get it and then
20:06 - let's make it on start
20:08 - one start we're going to set the bonelet
20:10 - rigid body we're going to modify the
20:12 - velocity
20:13 - and it's going to be based on this
20:15 - transform dot forward vector
20:17 - so we do that and then maybe a certain
20:19 - speed
20:22 - all right so just like this it will move
20:24 - forward as soon as it spawns
20:25 - now testing for collisions
20:30 - since we made the collided trigger we
20:32 - test for ontrigger enter and then over
20:34 - here let's just destroy this game object
20:37 - okay now we need to define a shoot input
20:40 - so on the input actions let's define
20:42 - another action call it shoot
20:45 - and for this one this is meant to work
20:46 - like a button so let's copy exactly the
20:48 - same way as the jump action so make it a
20:50 - button then for the bindings let's add
20:53 - one first of all for the left button on
20:55 - the mouse okay
20:56 - and add another binding and this one
20:58 - will be for the controller so let's go
21:00 - with gamepad in this case for shooting
21:02 - let's go with the right trigger
21:05 - okay then set this one as a gamepad this
21:06 - one is the keyboard mouse all right so
21:08 - we have our action let's hit on save
21:10 - and now to listen to the action we need
21:12 - to add over here to the start assets
21:14 - inputs so again let's copy the exact
21:16 - same pattern as over here on the jump so
21:18 - this won't be the shoot
21:20 - so let's copy the on jump
21:25 - so you've got the onshoot then the shoot
21:26 - input so again let's copy
21:32 - all right so we've got our shoot bowling
21:33 - that we can test
21:35 - so back in the shooter script
21:36 - over here on our update what it says for
21:38 - that one so if we're going to go into
21:40 - the star assets input that's for shoot
21:43 - if it is true then we want to shoot our
21:45 - bullet so in order to spawn the prefab
21:47 - let's add another one up here
21:50 - so for the boneless projectile prefab
21:54 - so we're going to have that reference
21:56 - and then down here we're going to call
21:57 - instantiate
21:59 - so now we need to know where we're going
22:01 - to instantiate it
22:03 - so in order to define that position in
22:04 - the editor let's add another transform
22:06 - as well
22:07 - what's called the spawn bullet position
22:11 - so let's set both of these in the editor
22:14 - just comment out this line so it can
22:15 - compile
22:17 - now here on the player script let's
22:18 - first add the prefab so drag down okay
22:21 - and then let's make a game object so
22:23 - let's make it inside the player armature
22:25 - so just an empty game object so this is
22:27 - the position where we're actually going
22:28 - to fire our boat from
22:30 - so for now let's put it roughly there
22:32 - roughly around chest height okay
22:34 - the only thing is just make sure that
22:36 - it's not actually inside the player
22:37 - collider so make sure that it's a bit
22:39 - off so the ball doesn't spawn this right
22:40 - immediately
22:42 - so let's call this the spawn bullet
22:45 - position
22:47 - and on the script attach that one okay
22:50 - so then here we can now use that we are
22:51 - going to instantiate the prefab
22:53 - instantiate on the spawn ball position
22:57 - and then we need the rotation so for
22:59 - this one again we're going to make it
23:00 - face towards the mouseworm position so
23:03 - let's get it here
23:13 - okay so we call in the m direction we
23:15 - grab the mouse run position and we come
23:17 - with direction based on the spawn bond
23:19 - position all right so we've got that
23:20 - direction then we need to convert it
23:21 - into a quaternion so we use a local
23:23 - rotation and convert okay and then since
23:26 - this is meant to be a pistol we're going
23:27 - to set the issue to fall so it doesn't
23:29 - shoot constantly so as you click it
23:30 - shoots okay let's test and we should be
23:32 - able to instantiate the prefab and it
23:34 - should move forward then it should be
23:35 - destroyed when it hits a wall let's see
23:38 - all right here we are and as i aim and i
23:40 - shoot and if there you go it doesn't
23:42 - need spawn the prefab and it goes in
23:43 - there and then it vanishes so if i shoot
23:46 - into the ground yep there you go
23:48 - so yeah it is spawning correctly and it
23:50 - is going exactly towards where i aim so
23:52 - again remember the problem that we're
23:54 - trying to avoid which is to make sure
23:56 - that the player doesn't shoot just
23:57 - forward but rather it actually hits
23:59 - where it's actually aiming and yep it is
24:01 - working so aim at the corner and yep it
24:03 - hits the corner alright so far so good
24:06 - now let's identify the collisions over
24:08 - here i've got a simple visual for a
24:10 - target this is from the polygon battle
24:12 - braille asset pack there's a link if you
24:13 - want to get it so we're going to
24:15 - identify it using a tag component
24:17 - so for that let's go down here and just
24:19 - create a new c sharp script let's call
24:21 - it the bullet target
24:23 - and then let's leave it as a completely
24:24 - empty component so don't change anything
24:26 - this one is only used for identifying a
24:28 - target
24:29 - so on the target game object i'm just
24:31 - going to add this script so just add the
24:32 - bone target onto it okay that's it now
24:35 - back into the bone script when we've got
24:37 - the ontrigger enter
24:38 - let's says if we hit a target or not
24:46 - okay so that's it we just test for a get
24:48 - component if it is not now then we hit a
24:50 - target if not we hit something else
24:52 - now i just add some particles just to
24:54 - identify it
25:03 - okay so just adding two references some
25:05 - particle effects so one green one red if
25:07 - we hit the target we get green if we hit
25:09 - something else we get red then here i've
25:11 - got some particles that i've prepared
25:12 - previously so just go into the bullet
25:14 - projectile on the prefab and just assign
25:16 - the references and that's it okay let's
25:19 - test
25:20 - all right so here i am and as i zoom and
25:22 - i shoot and there goes the bolt and yep
25:24 - it hits the floor so you've got the red
25:25 - particles okay so far so good now if i
25:28 - aim towards the actual target aim and
25:29 - shoot and yep there you go now i've got
25:31 - that one alright so we are correctly
25:33 - identifying what target we're actually
25:35 - hitting so we can hit the wall or we can
25:37 - hit a target let's just speed up those
25:39 - bullets so hide the visual for debug
25:42 - since we can verify that one is correct
25:44 - and on the bonus make it move a bit
25:45 - faster so maybe 40.
25:48 - so we're here as i am and i shoot and
25:50 - yep there you go now i've got hit the
25:51 - target hit everything else and so on and
25:54 - yep everything works great alright
25:56 - awesome so we have the projectile goes
25:59 - towards the crosshair it hits something
26:01 - and it identifies what object it hit so
26:03 - that's the projectile method now let's
26:05 - see the hitscan method
26:07 - so for the hitscan method it's actually
26:08 - much simpler which is down here when we
26:10 - do the raycast okay we're grabbing the
26:13 - point which is the actual head position
26:14 - all right but then over here we also
26:16 - have the actual object so over here we
26:19 - can simply test if it is a valid target
26:21 - or not
26:22 - so we can just define a transform for
26:24 - the hit transform
26:26 - and default it to null
26:28 - and then over here we set it equals the
26:30 - raycast hit dot transform
26:32 - okay so we know the transform that we
26:34 - hit then down here when we shoot instead
26:36 - of having to instantiate something
26:39 - we don't do this for the hitscan weapon
26:43 - we just test if we hit something so if
26:45 - it is not null
26:49 - then over here we can add the same logic
26:51 - that we had on both so just this
27:04 - so if it is not known that means that we
27:06 - hit something and if so then we
27:08 - identified just like previously and
27:10 - that's pretty much it
27:12 - so here i am and as i am and i shoot and
27:14 - yep there you go it shoots instantly so
27:16 - i'm shooting here and i've got the red
27:17 - particles shoot down and have gotten
27:19 - nice and green
27:20 - alright so this is the raycast method as
27:22 - you can see there is no projectile as
27:24 - soon as you click the bullet is
27:25 - instantly fired and it instantly reaches
27:27 - the target so as you can see you've got
27:29 - both methods both of them are valid
27:31 - now there is one difference about both
27:33 - of them so here i'm using the bonnet
27:35 - projectile method and if i go towards
27:38 - the corner and i am just out there you
27:40 - would assume that i would hit that wall
27:42 - back there but if i aim and i shoot and
27:44 - yep i'm hitting the wall near me so not
27:47 - the one far away so i'm not actually
27:48 - hitting where i'm trying to hit so the
27:50 - issue is that of course the projectile
27:52 - is not being spawned right from the
27:53 - center of the screen so slightly offset
27:55 - whereas over here when using the hitscan
27:57 - method with this one even if i'm right
28:00 - on the corner yep it still hits the
28:01 - actual target now again this is really a
28:04 - design question some people see this as
28:05 - a feature others sees it as a bug so
28:08 - really it's up to you to decide what
28:10 - method works best for your game one more
28:12 - design question that you need to ask
28:13 - yourself is if you want to enable
28:15 - hipfire or not so you want to enable
28:17 - shooting like this and also while zoomed
28:19 - in or only while zoomed in again this is
28:22 - a design question and it really depends
28:23 - on what game you're going for and what
28:25 - you're trying to build okay so with all
28:27 - this we have the whole logic working we
28:28 - can move the character around in third
28:30 - person we can gauge a mode and we can
28:32 - shoot some bullets either as projectiles
28:34 - or as hit scan weapons now one final
28:36 - thing we need is just a basic animation
28:38 - so we're not actually shooting from the
28:40 - unknown position
28:41 - so for that over here the player is
28:43 - using an animator so here it is so this
28:45 - is the animator that it comes with so
28:47 - item won't run it's got the jump the in
28:49 - air and so on now the way we can handle
28:51 - aim is by using the super useful
28:53 - animated layers
28:55 - so you go up here you create a new layer
28:56 - let's call it aiming
28:59 - and creates a new layer and then down
29:00 - here i've got a pistol idle animation so
29:03 - i just grab this one from mixamo which
29:04 - is a free website with a bunch of free
29:06 - animations so i'm just going to set this
29:08 - animation and that's it now if you don't
29:10 - know about animation layers they are
29:12 - super useful here we have the layers
29:15 - and if we click on the gear icon we can
29:17 - see it has a weight so by setting this
29:19 - on zero it's playing just the base layer
29:21 - so it's currently on idle and as i move
29:23 - up if there you go now it starts playing
29:24 - the pistol idle animation
29:26 - so this is how we're going to do it
29:27 - we're going to dynamically swap between
29:29 - the normal walking and the aim
29:30 - animations
29:32 - we're going to dynamically do that as
29:33 - the player starts to aim now i cover n
29:36 - middle layers and tons of other things
29:37 - related to animation in my ultimate
29:39 - unity overview course so go ahead and
29:41 - get it if you want to learn more about
29:43 - animations and many other unity tools
29:45 - and features
29:46 - okay so here in the third person shooter
29:48 - controller we just need a reference to
29:50 - the animator
29:54 - okay and then down here when we're
29:55 - aiming we're going to modify something
29:58 - so let's go into the animator we're
29:59 - going to call set layer weight now this
30:02 - one takes a layer index we added it as
30:04 - the second layer so it's on index one
30:06 - and then the float for the weight so we
30:08 - could set this just on one f
30:10 - and when we stop aiming we set it back
30:12 - into zero f so we could do that and it
30:14 - would be instant but again like we did
30:16 - previously on the rotation let's use
30:18 - lerp to make it nice and smooth
30:25 - okay so we're just using meth.lerp in
30:27 - order to alert the layer weight
30:30 - from whatever it is up to one and then
30:32 - over here down to zero
30:33 - okay let's test all right so here i am
30:36 - it's looking normal with normal aim
30:37 - animation and as i right click if there
30:39 - you go we go into the aim animation so
30:42 - normal aim and so on all right so it
30:44 - looks pretty great alright so the
30:46 - character is working great we've got our
30:48 - normal character we can look around we
30:49 - can move around sprint jump and so on
30:52 - everything works then we can go into a
30:54 - mode and point anywhere and then we can
30:56 - shoot some bullets then those bones are
30:58 - projectiles and they identify exactly
31:00 - where they hit so i can walk around go
31:02 - here aim and shoot and there you go
31:04 - everything works great alright awesome
31:07 - by the way if you find the video helpful
31:09 - please hit the like button it's a tiny
31:10 - thing but it really does help thanks now
31:13 - over here is the final polished
31:14 - character that i made while researching
31:16 - this video so i've got the same third
31:18 - person controller i can move around i
31:19 - can run i can sprint i can stop then as
31:22 - you can see i'm using a custom character
31:24 - along with a really nice weapon
31:26 - and i'm playing around on this scene
31:28 - which is from the polygon battleground
31:29 - pack there's a link in the description
31:31 - if you want to get it and the animations
31:33 - are also from another pack that i picked
31:34 - up a while ago i can aim which causes
31:36 - the character to lift up the weapon and
31:38 - zoom in the camera so just like we did
31:40 - and of course i can then shoot so as you
31:41 - can see lots of tiny effects lots of
31:43 - polish to make the shooting feel really
31:45 - great
31:46 - so i can walk around i can run sprint
31:48 - and aim and start shooting at everything
31:50 - just like that
31:54 - so like i said in the beginning of this
31:56 - video one interesting thing was the
31:57 - research that i did in making this
31:59 - project now most of my unity expertise
32:01 - lies in making 2d games essentially all
32:03 - of my steam games are in 2d
32:05 - dealing with 3d characters and
32:07 - especially 3d animations is definitely
32:09 - not something that i'm used to so this
32:11 - specific demo has been a great learning
32:13 - experience for me i'm saying that just
32:15 - to once again remind you that your home
32:17 - life is a never-ending learning journey
32:19 - for me i've been making games for 20
32:20 - years and working with unity for almost
32:22 - 10 and yet this is the first time that i
32:24 - really dug into 3d animation so whenever
32:27 - you come across something that you know
32:28 - absolutely nothing about don't be
32:30 - discouraged it's unlikely you won't ever
32:32 - get to a point where you know everything
32:33 - so the goal is to always be learning new
32:35 - things and using that knowledge to make
32:37 - better games
32:38 - so to make online logic here is pretty
32:40 - much exactly what i covered in the rest
32:41 - of the video so it uses two virtual
32:43 - cameras and so on
32:45 - then for the animations themselves as
32:47 - you can see they also look pretty good
32:48 - so i made it pretty much exactly like
32:50 - the demo and just expand upon it so
32:52 - there's the animator i've got the base
32:54 - layer with i don't want run animations
32:56 - then on the second layer this one is
32:58 - only being affected to the upper body
33:00 - this one handles the aim and shoot
33:02 - animations this one only gets up to half
33:04 - weight so if i get into the game and i
33:06 - zoom in you can see yep that one goes up
33:07 - to one and that one only up to 0.5 so
33:10 - this one is just because the walking
33:11 - animation had a lot of up and down
33:13 - motion so when i zoom in in order to
33:15 - stabilize it a bit i put down at 0.5 so
33:17 - just stabilize the weapon quite a bit
33:18 - more then on top of that the other thing
33:20 - that i had to learn was how to work with
33:22 - the animation rigging package
33:24 - so it's super useful i'm definitely
33:26 - going to do a dedicated video on that
33:27 - sometime soon note how because of that
33:29 - the player is aiming perfectly wherever
33:31 - i am the mouse so the weapon perfectly
33:33 - matches exactly where i'm aiming so if i
33:36 - am right in there same thing there if i
33:37 - go in there it's pointing in there so
33:39 - this perfect aim perfect rotation
33:41 - perfect aiming that is handled by the
33:42 - animation rigging package so the base
33:45 - animation on the animator that one is
33:46 - just static it's just pointing forwards
33:48 - and then the animation breaking package
33:50 - that's the one that is making it so that
33:51 - it points exactly where the mouse is
33:53 - pointing then the next thing that i
33:55 - added was a muslim flash effect on the
33:57 - light
33:58 - so those are just some very basic
33:59 - effects essentially they get enabled for
34:01 - literally one frame and then disabled so
34:03 - just click enable disable just like that
34:06 - very simple and looks pretty great
34:09 - and then for the projectile itself a
34:10 - while ago i mentioned that you have two
34:12 - options you can go the raycast or the
34:14 - projectile route however in reality
34:17 - there is a third type you can make a
34:18 - hybrid between both of those which is
34:20 - exactly what i'm using here
34:22 - so first i'm doing the raycast to get
34:24 - the mouse position and then i've got
34:26 - this simple script which runs on the bot
34:28 - this one has a setup function where it
34:30 - receives the target position and then it
34:32 - simply moves this transform towards that
34:34 - target position
34:35 - so there's no physics on this object it
34:37 - just moves the transform towards the
34:38 - target position and when it gets there
34:40 - then destroys its own i went with this
34:42 - approach because i wanted the bullet to
34:43 - move really fast and the physics system
34:45 - gets a bit weird if you try to make some
34:46 - really fast projectiles so like this
34:48 - looks really good and it works perfectly
34:50 - and then as you can see i also added a
34:52 - trail for the visual so over here you
34:54 - can see the bolt is in there this is all
34:55 - the trail
34:56 - and for the trail it's just a very basic
34:58 - trail render and finally just for fun i
35:00 - added these boxes these props they've
35:02 - all got rigid body so they follow with
35:04 - gravity and then i also added some
35:06 - simple shooting logic
35:08 - so i get whatever collider i hit i try
35:10 - to get the component rigid body and if
35:12 - it does have a rigid body then simply
35:13 - add explosion force so with that i can
35:16 - name and if i shoot towards something
35:17 - with a rigid body there you go boom and
35:19 - i can shoot everything
35:27 - as you can see very simple and makes the
35:29 - scene feel much more alive with much
35:30 - more physics objects
35:32 - alright so with all that here is a
35:34 - really nice really capable third person
35:36 - shooter controller you can download the
35:38 - project files and use this as a base on
35:39 - your own projects and now that i have
35:41 - this really nice third-person shooter
35:42 - controller i will definitely be using it
35:44 - in many more videos so make sure you hit
35:46 - the bell icon to stay tuned for that
35:48 - again if you're looking for a more
35:50 - guided path with step-by-step lectures
35:52 - then check out my complete courses
35:54 - alright hope that's useful check out
35:55 - these videos to learn some more thanks
35:57 - to these awesome patreon supporters for
35:59 - making these videos possible thank you
36:01 - for watching and i'll see you next time
36:06 - [Music]

Cleaned transcript:

hello and welcome i'm your code monkey and here let's build a third person shooter controller so we have our normal third person controller and we can move our character in any direction then by pressing a button we can go into a mode where we can then shoot so we need to handle the two states and on the camera and the animations handle how the bolts work and put it all together in a nice clean way so we can expand upon it in the future and for me personally this demo project was a great new learning experience i'll talk about it in a bit this is a pretty long video since it involves quite a lot of individual elements so if you want to skip ahead to a particular topic or watch the final polish controller there's timestamps in the video if you prefer a more guided path with stepbystep lectures then check out my complete courses learn how to make a bundler defender game using csharp just like i make my own steam games or learn how to make games internally using visual scripting or learn all about unity with the ultimate overview course which contains over 13 lectures each covering a different tool or feature of the engine to help you make better games faster i'm always available in the courses q a section answering your questions every single day so check out all the courses with the link in the description okay so let's build a third person shooter controller now this video is kind of split into two parts the first part is a stepbystep tutorial on how you can recreate all the logic and then in the end i will take that as a base and polish it into a really nice thirdperson shooter and talk about my research process for building this but first of all let's actually make it so here is my starting scene now i already have a third person controller this is the super useful controller made officially by unity it's part of the star assets which includes this controller as well as a first person one i covered both of them in another video and you can grab them for free from dnt asset store so what i have here is exactly that third person controller so with that i can already look around i can move around i can walk run i can jump and so on so all this by default just by importing that package now on top of this we're going to build our third person shoot on logic so the first thing that we need is just like i mentioned in that other video we need to make a second virtual camera set up as a shooting camera so over here is my scene and the only change that i did is over here on the player phone camera i put the shoulder offset on these values so a bit to the right and a bit upwards so there you go so it's like this and i put the camera side all the way to one so this is to make it so that it's a bit more like a third person shooter so you got the crosshairs down the middle and the character slightly to the side so let's first duplicate the player follow camera let's call this the player aim camera and over here just modify some settings so in order to see difference let's just increase the priority so let's put it at 20. so this is the one that is now active okay so for these settings first of all we want to zoom in so a slightly lower fov so let's put it maybe on 30. so slight zoom in then let's also push the camera a bit forward so over here on the camera distance push it a bit forward so maybe something like 2.5 okay so with this if i enable and disable we can now see the difference so this is the normal camera and this is the zoom in camera and over here again the difference that i made from the default third person is we've got the camera side all the way up to one meaning that you can easily toggle between the left and right shoulder so you go from zero it's on the left shoulder go to one on the right shoulder so that's a prestandard option in any third person shooter okay so with that that's pretty much it everything else is pretty much the same so we want third person follow so everything else is correct so with this we now have two virtual cameras so the first thing we want is just some basic logic to switch between them so let's begin by making our script so in uc sharp script called the third person shooter controller and here on the player armature let's just drag this script okay now here let's first begin by adding a reference to our aim virtual camera and for that let's make it of type cinemachine virtual camera just in case we want to change something on the camera itself later on so we need using syn machine and then we're going to make a thin machine virtual camera for the aim virtual camera make it a serialized field so we can set it in the editor so back in here just drag the reference all right now here since we already set the aim to have a higher priority all we really need to do is just enable or disable this game object so to do that let's make a private update and now here we need to test for input and for that the star assets package is using the new input system so for the aim let's use that one as well if you don't know how to work with new input system package go watch my video on it it's a very capable system that makes input handling super simple and it's what you definitely should be using in your final projects so it's eastern action so let's just open this one and here it is all the actions involved in this third person controller so let's add another one let's call this aim and now normally for type itself i would use it as button but here i'm trying to stick as close to the standard set by the starter assets so let's set it up exactly the same way as the sprint here so both these are meant to be hold actions so let's set up the example the same way and this one is set using passthrough so over here let's do the same thing pass through okay and then for the bindings let's add one let's listen listen to the right mouse button and let's also add another one and this one is going to be for a gamepad and for aiming let's go to a left trigger there it is then just make sure to assign this one to the gamepad control scheme and this one is on the keyboard mouse control scheme okay our action is defined let's just hit on save ascent now we need to listen to when that action happens so on the star asset itself we can see that it's using the player input method and for the behavior itself it's using send messages now personally when using this class i would prefer to use unity events but again i don't want to change this i want to stick with the standard made by the start asset so let's use the same method and if we stick with the same pattern then we listen to that event over here in this start assets input so for the behavior we want it really to be exactly like the sprint so we can examine just copy all that logic so instead of a sprint let's make an aim and then down here we've got the on events and so let's copy let's make this on aim then we're going to make an aim input function and then down here let's copy the spring input and just make it the aim input okay so there it is we made it work exam like the previous one and now in our third person shooter controller first we need a reference to the start inputs so a private star assets inputs so this one is inside a namespace all right we have the inputs and then on our update we're simply going to test go into that one and test for the aim volume so if this one is true we want to enable the aim virtual camera so let's go into this one.gameobject and we're going to call setactive and if it's true we're going to set it to true and if not we're going to set it back into false okay so just with this it should already be working so let's test okay here i am and everything looks normal now i right click and there you go it zooms in and i'll let go and yep it zooms out okay now it's obviously way too slow so let's fix that let's go into the send machine brain so on the main camera we've got this in machine brain and over here we've got the default transitions so it's taking two seconds let's make it quite a bit snappier so maybe point one let's see so here it is and i hold yep there you go now it's nice and snappy okay great so the next thing that we need is aim sensitivity right now the sensitivity is the same in both modes which works on right over here in normal mode but if i zoom in then it's way too intense it's very difficult to aim correctly so let's set up the logic to have two different sensitivities now in the video where i made an overview of the starter assets in there i already covered how you can add sensitivity to the third person controller which doesn't have that field by default so let's modify the third person controller script over here let's just add another one so let's make a public load called sensitivity and define it to 1f and then down here we just find the camera rotation function and on this one we're applying the input so we just multiply by the sensitivity and just that it's already working now we just need to build upon this and we're going to make a function to expose the sensitivity so let's go down here make a public void let's call it set sensitivity okay so we got a function to change it and now let's go into the shooter controller and over here on let's add fields for both of them so make it a serialized field make it private it's going to be a float for the normal sensitivity another one for the aim sensitivity and then we set them to the same way that we set the zoom so we need to get a component of that one all right so we get the component from the same object and then we simply go into that script we call set sensitivity and on this one we set it to the aim and on this one with normal all right so let's set these films in the editor so let's say for normal keep it at one and for aim let's put it at half okay so here i am with this sensitivity and as i zoom in yep now it's much smaller allowing me to be quite a bit more accurate all right great now the one thing missing here is a simple crosshair so we know where we're actually aiming so let's add one now this is very simple we just need first of all a canvas so let's go into ui make a new canvas then for the canvas set it up like i normally do so leave it on screen space overlay over here scale with screen size go with 1280x720 and match with the height so that's just the center that i like to follow and now inside let's make an image so a new ui image just called the crosshair and over here i've got a simple sprite of a crosshair so it's just something very basic that i do in 30 seconds so just sign the image and let's make it quite a bit smaller maybe 50 maybe 30 something like that and that's pretty much it nothing else we need to change just make sure it's pivoted on the center and it's on zero zero and yeah there it is now we have our character controller and we can see exactly where we're aiming alright great so with that done now it's time to handle the shooting now for this there's actually two ways you can do it one approach is you can make the weapon shoot actual projectiles or you can make it a hitscan weapon so for that one there's really no right or wrong answer it really depends on the type of game that you're going for now i actually made a video quite a while ago on the various ways to handle projectiles in that video i covered the methods in 2d but the logic we're going to use here is quite similar so do go watch that video after this one to see how it works in 2d now the most complex thing to do has to do with where you want the ball to go now the reason is because this is a third person shooter so that means the camera is slightly off to the side and not right on top of the player so that means that if you have the player itself just shoot forward it's going to shoot forward and not actually shoot where the crosshair is so even if you go with the projectile approach it still helps to do a quick raycast just to see exactly where the projectile should go okay so let's do that now here in our script the way we're going to do that is with an actual raycast now a while ago i covered how to get the mouse warm position in 3d and 2d now that method is making a raycast on the mouse position and see where it lands and that's exactly what we're going to do here so let's actually copy the code from that video it's on the mouse 3d class that i've got on this project so here it is that's the code that we made in that video and here we've got the update making array and yep okay so like this it would work however here we're using the old legacy input manager so we could change this to use the new input system we could do it using unity engine.input system and then over here we could do for example mouse.current grab the position and read the value now we could do this however with this the game would break if there was no mouse connected so it would break for example if you were playing on a console now since we want this to work with the mouse but also just a gamepad let's go with another approach all we really need is the position on the center of the screen since it never actually changes so for that we can do some very basic math to get that point so yep it's that simple we just make a screen center point we grab the screen width divided by two the height divided by two all right so here we have right the center and then we do a screen point array so the same thing as usual then we've got the collider mask so first of all let's rename this to the aim to leather mask and let's define it up here so as usual serialize feel make it a type layer mask i cover layers and bit mask in another video if you're curious to how it actually works so this is an aim collider mask okay so our logic should be working except over here we do not want to modify the transform position but let's verify that it is correct so let's make a debug transform so up here add another field just a private transform call just the debug transform then down here we set that one on the position just make sure that this point is actually correct okay so back in the editor here we've got our script first of all we need the aim collider and layer mask now over here all the walls on the environment all this is on the default layer so let's collide with the foam layer okay then for debug transform let's create just a 3d sphere put it pretty small and just add a nice material just for fun okay so this sphere is going to be our debug transform so just over here let's move it okay so it says and we should be able to see the sphere exactly always on the crosshair position let's see and yep it works so wherever i unlock i can see the sphere is exactly on there so with this we now know the worm position of where we're actually aiming alright so far so good however here we actually have the same issue that we saw with the house building system in the third person video and the other issue is the sphere is approaching so that has to do with the call either so just over here let's just remove the call either and okay no longer has that issue now as i was saying we do have the same issue that we had with the house building system in third person so in that video if you remember there was an issue when we looked at the sky because the sky does not have a call either so that's the exact same thing here if i'm looking at the ground floor and so on everything works there's this here okay but if i look towards there's no collateral so if i look up at the sky and nope the whole thing breaks so there's no sphere anywhere because over there there's no collateral so the simple solution is just like it did on the house building system which is to make sure there's always a collider let's add some basic invisible walls all around the world so there's always something to collide with that's very basic let's just create a new cube let's just move it to the side all right so i've added colliders all around but obviously the player is not meant to be outside in here so very simple let's just remove the mesh render there you go now we've got the colliders but they have no visual and now if we test and we aim around yep everything works perfect alright great so far so good now one more small thing here usually in third person shooters the character rotates as you aim so as you look around right now the character is still facing forward but it should be aiming towards where i'm pointing so let's add that over here we're testing for the aim changing sensitivity and so on so in here let's just calculate the vector from the player to the target position okay so here first of all i have the mouse compilation up on the top so we can use it down here so just to find the vector3 for the mouse one position then we do the raycast the usual thing reposition the debug transform even though we can remove this later and then we just have the muzzle position all right so then we just grab that one and first of all we make it the y match the exact same one as he transformed position y because right now we just want about left to right rotation we don't care about up down so with that then we have the aim direction towards the world name target so with this now we can rotate the player and we can do that with transform.forward so this is the player's forward vector which you can read but you can also write in order to rotate so if you're like me and we prefer dealing with vector threes instead of quaternions then this is a great way to rotate things and to make it smooth let's do it using a vector3.org all right so like this we should be able to see the player rotate to face the world aim target and it should rotate nice and smooth okay let's test so here i am the character is looking forward and i can look around and see the character all right but if i zoom in now i'm aiming and yep there you go now the character does aim towards where i'm actually aiming and the aim itself is also nice and smooth so instead of being instant there's a nice smoothness to it all right great so everything seems to be working however we actually do have an issue if we start to move so if we're moving like this yep so normal i can move and look around but now if i move and aim at the same time and yep now look at that now the character is not looking there now the whole thing is messed up so the issue here is that the base character controller is trying to rotate based on the move direction but then we're also trying to rotate as we're actually on the aim mode so we need to make sure to do just one or the other for that let's make a function to disable the rotation on the base script so over here on the third person controller let's add a simple boolean so private bone let's call this rotate on move and let's default it to true and then we can go down here into the actual move function so it's over here that we're moving the things and so on all right and we're handling the target rotation so over here this is how it's facing the input direction so we're only going to run this if that volume is set to true okay so now we just need to expose this bone so down here do the same thing okay so we've got this function exposed and now on the character controller now we can do that so in here we go into that one so while aiming we set it to false so that one does not rotate and when we stop aiming we set it back to true okay let's see all right so here i am i can walk around the character rotates as it should all right and now if i zoom and if there you go now the character no longer rotates so now it actually always faces the nice same direction all right great so let's continue now the sphere is always on top of the crosshair which means that we know the world position of where we're actually aiming so with this like i said you have two options one is to make the bullet an actual projectile so you spawn the bone on top of the weapon position and you rotate it to face the crosshair worm position and then just move it forward and test for physics conditions as it moves that's one approach and the other approach the head scan weapon is to do the raycast and then we check the object that we hit we test if we hit something we can damage and we just deal damage directly so let's quickly try out both methods so over here i've got a bonus prefab that i prepared previously so there's a parent game object with a rigid body and a collider set to trigger then over here on interpolate set to interpolate so it actually moves smoothly and collision detection is set as dynamic since this one will be moving quite fast then inside we really just have a visual nothing else okay so let's make a script to handle the bone projectile so let's make a new uc sharp script for the bullet projectile and over here first thing is let's get that rigid body so private rigid body okay so on the weight we get it and then let's make it on start one start we're going to set the bonelet rigid body we're going to modify the velocity and it's going to be based on this transform dot forward vector so we do that and then maybe a certain speed all right so just like this it will move forward as soon as it spawns now testing for collisions since we made the collided trigger we test for ontrigger enter and then over here let's just destroy this game object okay now we need to define a shoot input so on the input actions let's define another action call it shoot and for this one this is meant to work like a button so let's copy exactly the same way as the jump action so make it a button then for the bindings let's add one first of all for the left button on the mouse okay and add another binding and this one will be for the controller so let's go with gamepad in this case for shooting let's go with the right trigger okay then set this one as a gamepad this one is the keyboard mouse all right so we have our action let's hit on save and now to listen to the action we need to add over here to the start assets inputs so again let's copy the exact same pattern as over here on the jump so this won't be the shoot so let's copy the on jump so you've got the onshoot then the shoot input so again let's copy all right so we've got our shoot bowling that we can test so back in the shooter script over here on our update what it says for that one so if we're going to go into the star assets input that's for shoot if it is true then we want to shoot our bullet so in order to spawn the prefab let's add another one up here so for the boneless projectile prefab so we're going to have that reference and then down here we're going to call instantiate so now we need to know where we're going to instantiate it so in order to define that position in the editor let's add another transform as well what's called the spawn bullet position so let's set both of these in the editor just comment out this line so it can compile now here on the player script let's first add the prefab so drag down okay and then let's make a game object so let's make it inside the player armature so just an empty game object so this is the position where we're actually going to fire our boat from so for now let's put it roughly there roughly around chest height okay the only thing is just make sure that it's not actually inside the player collider so make sure that it's a bit off so the ball doesn't spawn this right immediately so let's call this the spawn bullet position and on the script attach that one okay so then here we can now use that we are going to instantiate the prefab instantiate on the spawn ball position and then we need the rotation so for this one again we're going to make it face towards the mouseworm position so let's get it here okay so we call in the m direction we grab the mouse run position and we come with direction based on the spawn bond position all right so we've got that direction then we need to convert it into a quaternion so we use a local rotation and convert okay and then since this is meant to be a pistol we're going to set the issue to fall so it doesn't shoot constantly so as you click it shoots okay let's test and we should be able to instantiate the prefab and it should move forward then it should be destroyed when it hits a wall let's see all right here we are and as i aim and i shoot and if there you go it doesn't need spawn the prefab and it goes in there and then it vanishes so if i shoot into the ground yep there you go so yeah it is spawning correctly and it is going exactly towards where i aim so again remember the problem that we're trying to avoid which is to make sure that the player doesn't shoot just forward but rather it actually hits where it's actually aiming and yep it is working so aim at the corner and yep it hits the corner alright so far so good now let's identify the collisions over here i've got a simple visual for a target this is from the polygon battle braille asset pack there's a link if you want to get it so we're going to identify it using a tag component so for that let's go down here and just create a new c sharp script let's call it the bullet target and then let's leave it as a completely empty component so don't change anything this one is only used for identifying a target so on the target game object i'm just going to add this script so just add the bone target onto it okay that's it now back into the bone script when we've got the ontrigger enter let's says if we hit a target or not okay so that's it we just test for a get component if it is not now then we hit a target if not we hit something else now i just add some particles just to identify it okay so just adding two references some particle effects so one green one red if we hit the target we get green if we hit something else we get red then here i've got some particles that i've prepared previously so just go into the bullet projectile on the prefab and just assign the references and that's it okay let's test all right so here i am and as i zoom and i shoot and there goes the bolt and yep it hits the floor so you've got the red particles okay so far so good now if i aim towards the actual target aim and shoot and yep there you go now i've got that one alright so we are correctly identifying what target we're actually hitting so we can hit the wall or we can hit a target let's just speed up those bullets so hide the visual for debug since we can verify that one is correct and on the bonus make it move a bit faster so maybe 40. so we're here as i am and i shoot and yep there you go now i've got hit the target hit everything else and so on and yep everything works great alright awesome so we have the projectile goes towards the crosshair it hits something and it identifies what object it hit so that's the projectile method now let's see the hitscan method so for the hitscan method it's actually much simpler which is down here when we do the raycast okay we're grabbing the point which is the actual head position all right but then over here we also have the actual object so over here we can simply test if it is a valid target or not so we can just define a transform for the hit transform and default it to null and then over here we set it equals the raycast hit dot transform okay so we know the transform that we hit then down here when we shoot instead of having to instantiate something we don't do this for the hitscan weapon we just test if we hit something so if it is not null then over here we can add the same logic that we had on both so just this so if it is not known that means that we hit something and if so then we identified just like previously and that's pretty much it so here i am and as i am and i shoot and yep there you go it shoots instantly so i'm shooting here and i've got the red particles shoot down and have gotten nice and green alright so this is the raycast method as you can see there is no projectile as soon as you click the bullet is instantly fired and it instantly reaches the target so as you can see you've got both methods both of them are valid now there is one difference about both of them so here i'm using the bonnet projectile method and if i go towards the corner and i am just out there you would assume that i would hit that wall back there but if i aim and i shoot and yep i'm hitting the wall near me so not the one far away so i'm not actually hitting where i'm trying to hit so the issue is that of course the projectile is not being spawned right from the center of the screen so slightly offset whereas over here when using the hitscan method with this one even if i'm right on the corner yep it still hits the actual target now again this is really a design question some people see this as a feature others sees it as a bug so really it's up to you to decide what method works best for your game one more design question that you need to ask yourself is if you want to enable hipfire or not so you want to enable shooting like this and also while zoomed in or only while zoomed in again this is a design question and it really depends on what game you're going for and what you're trying to build okay so with all this we have the whole logic working we can move the character around in third person we can gauge a mode and we can shoot some bullets either as projectiles or as hit scan weapons now one final thing we need is just a basic animation so we're not actually shooting from the unknown position so for that over here the player is using an animator so here it is so this is the animator that it comes with so item won't run it's got the jump the in air and so on now the way we can handle aim is by using the super useful animated layers so you go up here you create a new layer let's call it aiming and creates a new layer and then down here i've got a pistol idle animation so i just grab this one from mixamo which is a free website with a bunch of free animations so i'm just going to set this animation and that's it now if you don't know about animation layers they are super useful here we have the layers and if we click on the gear icon we can see it has a weight so by setting this on zero it's playing just the base layer so it's currently on idle and as i move up if there you go now it starts playing the pistol idle animation so this is how we're going to do it we're going to dynamically swap between the normal walking and the aim animations we're going to dynamically do that as the player starts to aim now i cover n middle layers and tons of other things related to animation in my ultimate unity overview course so go ahead and get it if you want to learn more about animations and many other unity tools and features okay so here in the third person shooter controller we just need a reference to the animator okay and then down here when we're aiming we're going to modify something so let's go into the animator we're going to call set layer weight now this one takes a layer index we added it as the second layer so it's on index one and then the float for the weight so we could set this just on one f and when we stop aiming we set it back into zero f so we could do that and it would be instant but again like we did previously on the rotation let's use lerp to make it nice and smooth okay so we're just using meth.lerp in order to alert the layer weight from whatever it is up to one and then over here down to zero okay let's test all right so here i am it's looking normal with normal aim animation and as i right click if there you go we go into the aim animation so normal aim and so on all right so it looks pretty great alright so the character is working great we've got our normal character we can look around we can move around sprint jump and so on everything works then we can go into a mode and point anywhere and then we can shoot some bullets then those bones are projectiles and they identify exactly where they hit so i can walk around go here aim and shoot and there you go everything works great alright awesome by the way if you find the video helpful please hit the like button it's a tiny thing but it really does help thanks now over here is the final polished character that i made while researching this video so i've got the same third person controller i can move around i can run i can sprint i can stop then as you can see i'm using a custom character along with a really nice weapon and i'm playing around on this scene which is from the polygon battleground pack there's a link in the description if you want to get it and the animations are also from another pack that i picked up a while ago i can aim which causes the character to lift up the weapon and zoom in the camera so just like we did and of course i can then shoot so as you can see lots of tiny effects lots of polish to make the shooting feel really great so i can walk around i can run sprint and aim and start shooting at everything just like that so like i said in the beginning of this video one interesting thing was the research that i did in making this project now most of my unity expertise lies in making 2d games essentially all of my steam games are in 2d dealing with 3d characters and especially 3d animations is definitely not something that i'm used to so this specific demo has been a great learning experience for me i'm saying that just to once again remind you that your home life is a neverending learning journey for me i've been making games for 20 years and working with unity for almost 10 and yet this is the first time that i really dug into 3d animation so whenever you come across something that you know absolutely nothing about don't be discouraged it's unlikely you won't ever get to a point where you know everything so the goal is to always be learning new things and using that knowledge to make better games so to make online logic here is pretty much exactly what i covered in the rest of the video so it uses two virtual cameras and so on then for the animations themselves as you can see they also look pretty good so i made it pretty much exactly like the demo and just expand upon it so there's the animator i've got the base layer with i don't want run animations then on the second layer this one is only being affected to the upper body this one handles the aim and shoot animations this one only gets up to half weight so if i get into the game and i zoom in you can see yep that one goes up to one and that one only up to 0.5 so this one is just because the walking animation had a lot of up and down motion so when i zoom in in order to stabilize it a bit i put down at 0.5 so just stabilize the weapon quite a bit more then on top of that the other thing that i had to learn was how to work with the animation rigging package so it's super useful i'm definitely going to do a dedicated video on that sometime soon note how because of that the player is aiming perfectly wherever i am the mouse so the weapon perfectly matches exactly where i'm aiming so if i am right in there same thing there if i go in there it's pointing in there so this perfect aim perfect rotation perfect aiming that is handled by the animation rigging package so the base animation on the animator that one is just static it's just pointing forwards and then the animation breaking package that's the one that is making it so that it points exactly where the mouse is pointing then the next thing that i added was a muslim flash effect on the light so those are just some very basic effects essentially they get enabled for literally one frame and then disabled so just click enable disable just like that very simple and looks pretty great and then for the projectile itself a while ago i mentioned that you have two options you can go the raycast or the projectile route however in reality there is a third type you can make a hybrid between both of those which is exactly what i'm using here so first i'm doing the raycast to get the mouse position and then i've got this simple script which runs on the bot this one has a setup function where it receives the target position and then it simply moves this transform towards that target position so there's no physics on this object it just moves the transform towards the target position and when it gets there then destroys its own i went with this approach because i wanted the bullet to move really fast and the physics system gets a bit weird if you try to make some really fast projectiles so like this looks really good and it works perfectly and then as you can see i also added a trail for the visual so over here you can see the bolt is in there this is all the trail and for the trail it's just a very basic trail render and finally just for fun i added these boxes these props they've all got rigid body so they follow with gravity and then i also added some simple shooting logic so i get whatever collider i hit i try to get the component rigid body and if it does have a rigid body then simply add explosion force so with that i can name and if i shoot towards something with a rigid body there you go boom and i can shoot everything as you can see very simple and makes the scene feel much more alive with much more physics objects alright so with all that here is a really nice really capable third person shooter controller you can download the project files and use this as a base on your own projects and now that i have this really nice thirdperson shooter controller i will definitely be using it in many more videos so make sure you hit the bell icon to stay tuned for that again if you're looking for a more guided path with stepbystep lectures then check out my complete courses alright hope that's useful check out these videos to learn some more thanks to these awesome patreon supporters for making these videos possible thank you for watching and i'll see you next time
