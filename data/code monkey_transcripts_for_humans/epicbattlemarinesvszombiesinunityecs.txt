With timestamps:

00:00 - in this video we're going to check out a
00:01 - really cool bottle of Marines vs.
00:03 - zombies built entirely in unity ECS we
00:07 - have a lot of Units on-screen animation
00:09 - a eye movement and lots of interactions
00:11 - between systems and components we're
00:13 - going to view how all of this works
00:15 - let's begin
00:19 - [Music]
00:23 - hello and welcome I'm your code monkey
00:25 - and this channel is all about helping
00:27 - you learn how to make your own games
00:28 - with nf2 torrents made by a professional
00:30 - indie game developer so if you find the
00:32 - video helpful consider subscribing
00:34 - alright so here we are in our scene just
00:36 - a bunch of Marines
00:37 - sitting here waiting for the zombie
00:39 - apocalypse almost everything is built
00:41 - using unity ECS and over here are some
00:45 - zombies being spawned here they come and
00:47 - as they approach the Marines find them
00:49 - as targets and properly start shooting I
00:52 - can spawn more Marines found left
00:55 - clinton there we go every time spawns
00:57 - one and the number of zombies being
00:59 - spawned is constantly increasing after a
01:02 - while zombie start coming from the side
01:03 - and they stop coming all over as I said
01:07 - most of this is built in pure easiest
01:09 - and if I pause the game you can see over
01:12 - here on the hierarchy there aren't many
01:14 - things some of the things are the
01:16 - default effects that I haven't yet
01:18 - converted into is yet but most of the
01:20 - units and behavior are handled by pure
01:22 - ecs and there are no mana behaviors in
01:24 - here so the hierarchy looks mostly empty
01:26 - regarding the units however here on the
01:28 - entity debugger here you can see a much
01:30 - different picture with a bunch of
01:32 - entities all of them in a bunch of
01:33 - chunks and a bunch of systems doing all
01:35 - the work so here is our scene and
01:38 - there's all the Marines constantly
01:41 - fighting all the zombies and they keep
01:42 - going and I can spawn some more and
01:45 - eventually they won't be over up all
01:47 - right so this is our very nice demo
01:48 - scene we have two types of Units Marines
01:51 - and zombies the Marines are all looking
01:53 - for their target and once they get in
01:55 - range they start leaning shut there are
01:59 - lots of extra effects to make the whole
02:01 - scene seem very nice and as you can see
02:03 - the more they are spawned the more the
02:05 - circle closes in and soon enough they
02:07 - won't be overrun ok so this is a great
02:09 - demo scene now let's check out the code
02:11 - that makes all of this work now this
02:14 - video is mostly intended as a demo of
02:16 - what can be done with ECS so instead of
02:19 - a step-by-step tutorial I'll go over a
02:21 - brief overview of how each system works
02:23 - if you'd like to see more in the up step
02:25 - by step tutorial of any of these systems
02:27 - then let me know in the comments also if
02:30 - you have absolutely no idea how easiest
02:32 - works then start by watching the video
02:34 - on getting started after watching that
02:35 - video
02:36 - a lot of what I'm going to show here
02:37 - won't seem very familiar now there are
02:40 - many systems that work in order to make
02:41 - this scene work we have spawning
02:44 - animation ai and movement using a lot of
02:46 - systems and components there are also a
02:48 - handful of systems they use normal game
02:50 - objects as he saw mostly they are things
02:52 - like the shoot flash the fighting body
02:53 - or the blood particles which can
02:55 - certainly be done in ECS I just haven't
02:57 - poured them over yet so let's go up here
03:00 - to start off with the simplest system
03:02 - here we have just our main bootstrap
03:05 - script and here on the start function we
03:07 - initialize things and we have a function
03:09 - to spawn myrin another one to spawn a
03:11 - zombie so here is the spawn myrin
03:13 - function we just spawn it using a
03:15 - certain archetype containing all these
03:17 - components then we set all of the values
03:19 - for those components and the zombie also
03:22 - has a lot of similar components one of
03:24 - the main different are the attack
03:25 - components so this one has the zombie
03:27 - tag and this one has the marine tag and
03:29 - if we check it out you can see those are
03:31 - completely empty components really just
03:33 - tags the other components are these
03:35 - related to the animation system over
03:38 - here related to the quadrant and
03:39 - targeting system then in a very simple
03:42 - health component a component deal with
03:45 - how much the marine should shoot a
03:47 - simple move to component a component to
03:50 - handle the various animations that
03:51 - should be played any simple translation
03:53 - position component so that's a way to
03:56 - spawn a marine and a zombie and down
03:59 - here on a simple monobehaviour
04:01 - update we are simply handling our camera
04:03 - and then D zombie spawning here are just
04:05 - some timers and some spawns on me count
04:07 - that increases over time so here I can
04:10 - easily change this and all of a sudden
04:12 - amount of zombies gonna be spawned and
04:14 - Here Come a lot more zombies and very
04:17 - soon these guys won't be overrun even if
04:20 - I spawned quite a few more okay so
04:22 - that's our spawning system it simply
04:24 - checks over time and constantly
04:26 - increases the amount of zombies that get
04:27 - spawned and the components as you saw
04:30 - were different so we can pause and look
04:32 - at the entity debugger and here we can
04:34 - view all the chunks and if we click on a
04:37 - simple entity you can see that this one
04:39 - is a marine target range of a hundred
04:41 - playing these animations and in this
04:44 - position so the spawning in the
04:46 - composition of the entities is quite
04:48 - basic
04:49 - another simple system is the movement
04:50 - over here as you saw we have a move to
04:53 - component this component simply has a
04:55 - boolean to decide if he should move in a
04:57 - position any moves B and then down here
05:00 - there is a system system runs on
05:02 - entities that I've been moved to
05:03 - translation and the animation components
05:05 - and we simply use it to do a simple
05:07 - distance check in order to move and play
05:09 - the correct animations so again very
05:11 - simple stuff then for the animation
05:13 - system which is probably the most
05:15 - complex part of this demo the animation
05:17 - system is essentially the same system
05:19 - I've gone long ago but converting to ECS
05:21 - so it's essentially the same thing that
05:23 - I've used in all of my videos the way
05:25 - the system works is by having one mesh
05:27 - per frame of animation and a component
05:30 - that holds data to select which mesh
05:32 - that units should use in order to
05:34 - actually display the mesh I have this
05:36 - component system right here essentially
05:38 - how it works is by cycling through all
05:41 - of the entities then it grabs the
05:43 - correct mesh based on the current frame
05:45 - of the animation and the animation type
05:47 - and direction then it simply draws that
05:50 - mesh into the current translation
05:51 - position so the whole drawing is done in
05:54 - here rather than using the basic render
05:56 - mesh now the core of how the animations
05:58 - work is by essentially keeping a list of
06:01 - vertices and UVs
06:02 - so here on the animation system I have a
06:05 - struct for each one so each one has four
06:07 - vertices and essentially four UVs and
06:09 - each body part gets displayed in a
06:11 - single quad so the head is a quad the
06:13 - body is another quad the hand another
06:15 - quad and so on
06:16 - then all of those quads come together in
06:18 - order to make a single frame of
06:19 - animation and as soon as the game starts
06:22 - I essentially pre calculate all of the
06:24 - meshes and store them in a list so in
06:27 - here I have a dictionary that for each
06:29 - animation contains a list of mesh each
06:31 - mesh for a single frame of animation
06:33 - I've done a lot of testing in order to
06:35 - figure out the various methods for
06:37 - playing the animation and this is the
06:38 - best one I found with regards to
06:40 - performance when the game starts
06:41 - everything is pre calculated and then
06:43 - during play mode it simply grabs the
06:46 - correct mesh so back here on the mesh
06:48 - display as you can see we are simply
06:50 - grabbing the mesh from the mesh list
06:51 - which is based on that animation and
06:53 - that direction and the current frame the
06:56 - current frame is increased by a
06:57 - different job in here as you can see
07:00 - it's very simple just go
07:01 - through each entity that contains the
07:03 - accountant data increase the frame timer
07:05 - which increase the current frame here in
07:07 - the scene view we can go up here in
07:09 - order to enable shaded wireframe and you
07:11 - can see that each of them is indeed made
07:13 - up of quad so we have the head quad the
07:15 - weapon quad the foot foot and a foot
07:17 - body and so on so this is how the system
07:20 - works essentially we pre calculate the
07:22 - mesh containing all of the quads and
07:24 - then during runtime we simply select the
07:27 - correct mesh here if we don't look at
07:30 - the entity debugger you can see the
07:31 - entity count constantly increasing and
07:33 - here is the skeleton mesh display system
07:35 - which as you can see is increasing over
07:37 - time so here with 200 MTS it's taking
07:41 - roughly one millisecond so right now
07:45 - this is the approach that I found best
07:47 - for performance I've tested several ways
07:49 - of showing the animation like
07:50 - dynamically creating the meshes but
07:52 - keeping them cached works best this way
07:54 - I can have several thousand animated
07:56 - meshes and everything works over here on
07:58 - the display system there are a two
08:00 - performance bottlenecks that I need to
08:01 - improve one of them is getting the mesh
08:04 - list in order to grab the correct mesh
08:06 - this one is done by finding the mesh in
08:08 - a dictionary which takes quite a while
08:10 - to calculate so this one is quite simple
08:12 - to fix we can simply use a normal array
08:14 - and currently the index and that would
08:15 - be quite a lot faster and the other
08:17 - bottleneck is dealing with mesh itself
08:19 - here as you can see all this is running
08:21 - on a normal component system so none of
08:24 - this code is being multi-threaded it
08:26 - would be great if it was possible to
08:27 - update a mesh inside a job and maybe
08:29 - keeping just one mesh and modifying it
08:32 - instead of keeping a separate mesh but
08:34 - since mesh is a reference type it cannot
08:36 - be used inside the current job system
08:38 - also it would be very useful if we could
08:40 - access the graphics API in a
08:42 - multi-threaded environment I tried
08:44 - writing some multi-threaded code in
08:45 - order to draw the meshes but the
08:47 - graphics API must be called on the main
08:49 - thread so right now this entire system
08:51 - is not benefiting from the job system
08:53 - the more entities we have the more cycle
08:56 - this function goes through and the
08:57 - longer it takes so that's how the mesh
08:59 - and the animation system work so about
09:01 - pre calculating all the missions and
09:03 - then simply selecting them in order to
09:05 - match the correct frame of animation
09:06 - then there's also the quadrant and
09:09 - targeting systems which work very much
09:10 - together however in this case since EC s
09:14 - is so insanely fast I'm not sure if the
09:17 - quadrant system is really necessary if
09:18 - the map was a lot bigger it would
09:20 - probably make more sense but for this
09:22 - little demo not so much necessary but
09:24 - still here it is now a quadrant is
09:27 - essentially a portion of the map in this
09:29 - case it's simply a square now down here
09:32 - I have a simple debug function which
09:34 - won't draw each quadrant as I pass the
09:36 - mouse over it so let's test it so here
09:38 - we are with gizmos enabled and as you
09:40 - can see as I pass the mouse over this
09:41 - essentially what a quadrant on
09:43 - equivalent system is this system is
09:46 - designed in order to make it easier to
09:47 - look for targets since you don't have to
09:49 - look through the entire entity and list
09:50 - so in here for example in this quadrant
09:52 - you have this unit this unit and this
09:54 - unit so if these were all looking for
09:56 - targets they wouldn't look for targets
09:57 - that were in this quadrant all the way
09:58 - over here they only check the
10:00 - neighboring quadrant so the entire goal
10:02 - is to put units into buckets based on
10:04 - position so when this Marine is looking
10:07 - for a target he's not going through
10:09 - every single entity on the map rather
10:11 - only the ones in the quadrants nearby so
10:13 - as you can see only when they enter that
10:14 - quadrant does he finally start to target
10:16 - them the benefit is to limit the number
10:21 - of units you have to search through in
10:22 - order to find the closest so this marine
10:24 - here will never ever ask for the
10:26 - position in order to see if this one is
10:28 - equal to zombie it only looks for the
10:30 - ones nearby again as I said since the
10:33 - way that this is done works really fast
10:35 - so in this case the quadrant system is
10:37 - not absolutely necessary
10:38 - but if the map was massive you can see
10:40 - how this marine would not want to look
10:42 - for a zombie that would be all the way
10:43 - over here so the bigger the map the more
10:46 - important it is to have a sort of
10:47 - quadrant system so here let's go over a
10:50 - quick overview of how the system works
10:51 - now this is certainly a great system and
10:54 - something I want to cover more in depth
10:55 - in another video since it involves some
10:57 - really interesting logic each entity as
11:00 - he saw contains a quadrant entity
11:01 - component this is how we define which
11:03 - entities won't be managed by the
11:05 - quadrant system it simply contains the
11:07 - type so either a marine or a zombie now
11:10 - inside the quadrant system we are
11:11 - working with a native multi hash map
11:13 - which contains an int for the hash key
11:16 - and the quadrant data for the various
11:18 - values as you can see the quadrant
11:20 - has the entity the position and the
11:22 - quadrant entity that is in there this
11:24 - native container lets you store multiple
11:26 - values inside a single heat so inside a
11:28 - single position key you can have
11:31 - multiple quadrant data so that is how
11:33 - you have multiple units inside the same
11:34 - bucket then this function in here
11:36 - generates a key based on a certain
11:38 - position it just some math based on a
11:40 - certain sound size and ensures that
11:42 - units within a position near that cell
11:44 - always return the same key so entities
11:48 - in the same quadrant won't have the same
11:49 - hash key added to it now there are
11:51 - multiple jobs in order to make this
11:53 - whole thing work the first one is this
11:55 - one to set the quadrant data on the hash
11:57 - map so what this one does is it cycles
11:59 - through all the entities that contain a
12:01 - translation and a quadrant entity
12:02 - component it gets the position hash map
12:05 - key and simply adds a new quadrant data
12:08 - on that hash map key so here we are just
12:11 - positioning all the entities into their
12:12 - correct quadrants after we set all the
12:16 - entities into their quadrants then we
12:17 - have define causes target job
12:19 - this one cycles through every unit and
12:22 - it tries to get the closest target on
12:24 - the nearby quadrants so you start with
12:26 - the center quadrant then the one to the
12:27 - left right and so on so you check all
12:30 - nine nearby quadrants and then at the
12:33 - end we have a causes target entity now
12:35 - in here in order to benefit from the
12:37 - insane benefits of bursts instead of
12:40 - adding our hash target component we
12:42 - simply store the units and their targets
12:44 - into a native hash map and after finding
12:47 - the closest target job we have another
12:49 - job in order to set the target this one
12:51 - does not use burst since it uses the
12:53 - entity command buffer and we simply use
12:55 - it north to the has target component
12:57 - with the causes target I've done a video
13:00 - on how to find the closest target so
13:01 - check that out to see a more in-depth
13:03 - look into how this logic works and down
13:05 - here on the update we are simply
13:07 - preparing all of our data and scheduling
13:09 - our various jobs so first we position
13:11 - them in the hash map then we cycle
13:13 - through all the units are to find it
13:14 - closest and then we add the component to
13:16 - the causes turret again here we are in
13:19 - our scene you can see the highlighted
13:20 - quadrant and down here on the console
13:22 - you can see how many entities are inside
13:24 - this quadrant so this one has 6 1 2 3 4
13:26 - 5 6
13:27 - yep there are 6 and over here the
13:29 - zombies are coming so now it's got 0 and
13:31 - now it's increasing 1 and so on
13:32 - and as you can see as soon gets one
13:34 - these guys start looking for a target on
13:36 - this quadrant so as soon as they enter
13:38 - they start getting shot and if we look
13:43 - at the entity debugger you can see this
13:45 - entity for example has the historic
13:47 - component which contains the position of
13:49 - his target and the entity field again
13:52 - check out the video on finding the
13:54 - closest target in order to get a more
13:55 - in-depth look into how all of this works
13:57 - so once the unit has a has started
13:59 - component then we run another system
14:01 - over here is the marine target zombie
14:04 - system as you can see it's running on
14:06 - every entity with translation the plan
14:08 - animation component has target component
14:10 - and the Marine shoot so he checks if he
14:12 - can shoot if so he plays the shooting
14:15 - animation and he shoots the target
14:17 - entity now the shooting and cousin
14:19 - damage was an interesting problem to
14:21 - tackle doing AI in ECS is probably the
14:24 - most difficult thing to wrap your head
14:25 - around right now in order to be super
14:27 - fast it's really a requirement in order
14:29 - to use memory sequentially
14:31 - that's essentially what the entity
14:32 - chunks do grabbing a piece of random
14:34 - memory for the target Hertz things so we
14:37 - need to minimize it as much as possible
14:38 - so over here my approach has been based
14:41 - on a queue of actions
14:43 - so whenever the Marine should say target
14:46 - he doesn't directly interact with the
14:48 - zombie in order to cause some damage
14:49 - whether he just in queues that action so
14:52 - that way this system for shooting the
14:54 - zombies runs in parallel and then here I
14:57 - have the queued action system which is
15:00 - running on just a simple component
15:01 - system and he goes through all of the
15:03 - cute actions so right now the only
15:05 - action is a marine shooting a zombie so
15:08 - here this code is running on the main
15:10 - thread and it's what finally actually
15:11 - cause damage to the zone so you get the
15:13 - positions for the marine the zombie then
15:16 - we have some bonus effects running on
15:17 - single threaded code all these are not
15:20 - yet port EECS so you can see here how
15:23 - you can mix and match use some systems
15:25 - in ECS and some systems with normal game
15:27 - objects then here we grab the zombie
15:29 - health we ask the entity manager in
15:31 - order to get the health component for
15:32 - the zombie entity once we get it we'll
15:35 - reduce the health by the damage amount
15:37 - that is stored on the zombie action and
15:39 - then we test if he is dead then we spawn
15:42 - a fine body we destroyed the entity and
15:44 - we
15:44 - the component has target from the marine
15:46 - entity if he still has health then we
15:48 - simply update the zombie home so here as
15:52 - you can see for the AI we separated into
15:54 - two systems so first we have the Marine
15:57 - he does all of his data and shoots the
15:59 - zombies that he has as targets he in
16:02 - queues a specific action into a cute
16:05 - actions native queue then after this
16:08 - system runs with all of the marine
16:10 - entities we run our cute action system
16:13 - which goes through all that cute action
16:16 - queue and we do everything we need to do
16:18 - in order to handle the interaction
16:20 - between the marine and the zombies
16:21 - obviously the biggest issue is in here
16:23 - we are using a component system so this
16:25 - code is not Java 5 at all all of this
16:27 - runs on the main thread that means it
16:29 - could potentially become a performance
16:31 - bottleneck however the number of actions
16:34 - that happen every single frame is going
16:36 - to be quite small so in most cases I
16:38 - think this specific pattern would work
16:40 - well in an ECS game again making AI in
16:43 - ETS is a very tricky subject so perhaps
16:45 - this is not the absolute best way of
16:47 - doing things I continue learning as I go
16:49 - along and for now this seemed like a
16:51 - good approach so this is the complete
16:53 - simple demo scene our Marines are here
16:56 - standing around these zombies are being
16:58 - spawned and they move towards them as
17:00 - soon as they get close the quadrant
17:01 - system works in order to find a target
17:03 - for each of these Marines the animation
17:06 - system is working as you saw each
17:08 - animation frame is a mesh and we simply
17:10 - selected on every single frame the
17:13 - zombies keep spawning after a while they
17:15 - start spawning from the sides and they
17:17 - come from everywhere more and more gets
17:20 - fun more and more keep coming and here
17:22 - you can see our stats and right now you
17:24 - can see that this whole scene with all
17:26 - these zombies all these units is
17:28 - currently running at a hundred frames
17:29 - per second and again a lot of these
17:31 - effects are not using ECS so this could
17:34 - be improved even more and more and more
17:37 - keep coming and with all of these
17:39 - zombies all of them working
17:40 - independently all of them have their own
17:42 - AI their own code there aren't things
17:44 - and we're still running at 60 70 frames
17:46 - per second and they all keep going to
17:48 - keep getting a run and again I can still
17:50 - click in order to spawn a bunch more so
17:52 - spawn more in order for them to breathe
17:54 - a little and if they are pushing the Mac
17:57 - everything is working quite nice so as
17:59 - you saw there are still many years that
18:00 - can be improved but this already looks
18:02 - very nice for a pure ECS game and
18:04 - clearly demonstrates the performance
18:06 - benefits also I'm still learning easy as
18:08 - myself so what I've built here might not
18:11 - necessarily end up being the best
18:12 - practices for a pure ECS game as time
18:15 - goes on and more people play around the
18:17 - easiest the best practices will start to
18:19 - emerge so hopefully you've enjoyed this
18:22 - nice little demo of what can be done
18:24 - with ECS it's not necessarily a more
18:26 - difficult way it's just a different way
18:28 - of thinking about how to write code and
18:30 - how to do things as always you can
18:32 - download the project files in utilities
18:34 - from inti code monkey comm if you liked
18:36 - the video subscribe the channel for more
18:37 - ent tutorials post any questions there
18:39 - have in the comments and I'll do my best
18:40 - answer them alright see you next time
18:43 - [Music]

Cleaned transcript:

in this video we're going to check out a really cool bottle of Marines vs. zombies built entirely in unity ECS we have a lot of Units onscreen animation a eye movement and lots of interactions between systems and components we're going to view how all of this works let's begin hello and welcome I'm your code monkey and this channel is all about helping you learn how to make your own games with nf2 torrents made by a professional indie game developer so if you find the video helpful consider subscribing alright so here we are in our scene just a bunch of Marines sitting here waiting for the zombie apocalypse almost everything is built using unity ECS and over here are some zombies being spawned here they come and as they approach the Marines find them as targets and properly start shooting I can spawn more Marines found left clinton there we go every time spawns one and the number of zombies being spawned is constantly increasing after a while zombie start coming from the side and they stop coming all over as I said most of this is built in pure easiest and if I pause the game you can see over here on the hierarchy there aren't many things some of the things are the default effects that I haven't yet converted into is yet but most of the units and behavior are handled by pure ecs and there are no mana behaviors in here so the hierarchy looks mostly empty regarding the units however here on the entity debugger here you can see a much different picture with a bunch of entities all of them in a bunch of chunks and a bunch of systems doing all the work so here is our scene and there's all the Marines constantly fighting all the zombies and they keep going and I can spawn some more and eventually they won't be over up all right so this is our very nice demo scene we have two types of Units Marines and zombies the Marines are all looking for their target and once they get in range they start leaning shut there are lots of extra effects to make the whole scene seem very nice and as you can see the more they are spawned the more the circle closes in and soon enough they won't be overrun ok so this is a great demo scene now let's check out the code that makes all of this work now this video is mostly intended as a demo of what can be done with ECS so instead of a stepbystep tutorial I'll go over a brief overview of how each system works if you'd like to see more in the up step by step tutorial of any of these systems then let me know in the comments also if you have absolutely no idea how easiest works then start by watching the video on getting started after watching that video a lot of what I'm going to show here won't seem very familiar now there are many systems that work in order to make this scene work we have spawning animation ai and movement using a lot of systems and components there are also a handful of systems they use normal game objects as he saw mostly they are things like the shoot flash the fighting body or the blood particles which can certainly be done in ECS I just haven't poured them over yet so let's go up here to start off with the simplest system here we have just our main bootstrap script and here on the start function we initialize things and we have a function to spawn myrin another one to spawn a zombie so here is the spawn myrin function we just spawn it using a certain archetype containing all these components then we set all of the values for those components and the zombie also has a lot of similar components one of the main different are the attack components so this one has the zombie tag and this one has the marine tag and if we check it out you can see those are completely empty components really just tags the other components are these related to the animation system over here related to the quadrant and targeting system then in a very simple health component a component deal with how much the marine should shoot a simple move to component a component to handle the various animations that should be played any simple translation position component so that's a way to spawn a marine and a zombie and down here on a simple monobehaviour update we are simply handling our camera and then D zombie spawning here are just some timers and some spawns on me count that increases over time so here I can easily change this and all of a sudden amount of zombies gonna be spawned and Here Come a lot more zombies and very soon these guys won't be overrun even if I spawned quite a few more okay so that's our spawning system it simply checks over time and constantly increases the amount of zombies that get spawned and the components as you saw were different so we can pause and look at the entity debugger and here we can view all the chunks and if we click on a simple entity you can see that this one is a marine target range of a hundred playing these animations and in this position so the spawning in the composition of the entities is quite basic another simple system is the movement over here as you saw we have a move to component this component simply has a boolean to decide if he should move in a position any moves B and then down here there is a system system runs on entities that I've been moved to translation and the animation components and we simply use it to do a simple distance check in order to move and play the correct animations so again very simple stuff then for the animation system which is probably the most complex part of this demo the animation system is essentially the same system I've gone long ago but converting to ECS so it's essentially the same thing that I've used in all of my videos the way the system works is by having one mesh per frame of animation and a component that holds data to select which mesh that units should use in order to actually display the mesh I have this component system right here essentially how it works is by cycling through all of the entities then it grabs the correct mesh based on the current frame of the animation and the animation type and direction then it simply draws that mesh into the current translation position so the whole drawing is done in here rather than using the basic render mesh now the core of how the animations work is by essentially keeping a list of vertices and UVs so here on the animation system I have a struct for each one so each one has four vertices and essentially four UVs and each body part gets displayed in a single quad so the head is a quad the body is another quad the hand another quad and so on then all of those quads come together in order to make a single frame of animation and as soon as the game starts I essentially pre calculate all of the meshes and store them in a list so in here I have a dictionary that for each animation contains a list of mesh each mesh for a single frame of animation I've done a lot of testing in order to figure out the various methods for playing the animation and this is the best one I found with regards to performance when the game starts everything is pre calculated and then during play mode it simply grabs the correct mesh so back here on the mesh display as you can see we are simply grabbing the mesh from the mesh list which is based on that animation and that direction and the current frame the current frame is increased by a different job in here as you can see it's very simple just go through each entity that contains the accountant data increase the frame timer which increase the current frame here in the scene view we can go up here in order to enable shaded wireframe and you can see that each of them is indeed made up of quad so we have the head quad the weapon quad the foot foot and a foot body and so on so this is how the system works essentially we pre calculate the mesh containing all of the quads and then during runtime we simply select the correct mesh here if we don't look at the entity debugger you can see the entity count constantly increasing and here is the skeleton mesh display system which as you can see is increasing over time so here with 200 MTS it's taking roughly one millisecond so right now this is the approach that I found best for performance I've tested several ways of showing the animation like dynamically creating the meshes but keeping them cached works best this way I can have several thousand animated meshes and everything works over here on the display system there are a two performance bottlenecks that I need to improve one of them is getting the mesh list in order to grab the correct mesh this one is done by finding the mesh in a dictionary which takes quite a while to calculate so this one is quite simple to fix we can simply use a normal array and currently the index and that would be quite a lot faster and the other bottleneck is dealing with mesh itself here as you can see all this is running on a normal component system so none of this code is being multithreaded it would be great if it was possible to update a mesh inside a job and maybe keeping just one mesh and modifying it instead of keeping a separate mesh but since mesh is a reference type it cannot be used inside the current job system also it would be very useful if we could access the graphics API in a multithreaded environment I tried writing some multithreaded code in order to draw the meshes but the graphics API must be called on the main thread so right now this entire system is not benefiting from the job system the more entities we have the more cycle this function goes through and the longer it takes so that's how the mesh and the animation system work so about pre calculating all the missions and then simply selecting them in order to match the correct frame of animation then there's also the quadrant and targeting systems which work very much together however in this case since EC s is so insanely fast I'm not sure if the quadrant system is really necessary if the map was a lot bigger it would probably make more sense but for this little demo not so much necessary but still here it is now a quadrant is essentially a portion of the map in this case it's simply a square now down here I have a simple debug function which won't draw each quadrant as I pass the mouse over it so let's test it so here we are with gizmos enabled and as you can see as I pass the mouse over this essentially what a quadrant on equivalent system is this system is designed in order to make it easier to look for targets since you don't have to look through the entire entity and list so in here for example in this quadrant you have this unit this unit and this unit so if these were all looking for targets they wouldn't look for targets that were in this quadrant all the way over here they only check the neighboring quadrant so the entire goal is to put units into buckets based on position so when this Marine is looking for a target he's not going through every single entity on the map rather only the ones in the quadrants nearby so as you can see only when they enter that quadrant does he finally start to target them the benefit is to limit the number of units you have to search through in order to find the closest so this marine here will never ever ask for the position in order to see if this one is equal to zombie it only looks for the ones nearby again as I said since the way that this is done works really fast so in this case the quadrant system is not absolutely necessary but if the map was massive you can see how this marine would not want to look for a zombie that would be all the way over here so the bigger the map the more important it is to have a sort of quadrant system so here let's go over a quick overview of how the system works now this is certainly a great system and something I want to cover more in depth in another video since it involves some really interesting logic each entity as he saw contains a quadrant entity component this is how we define which entities won't be managed by the quadrant system it simply contains the type so either a marine or a zombie now inside the quadrant system we are working with a native multi hash map which contains an int for the hash key and the quadrant data for the various values as you can see the quadrant has the entity the position and the quadrant entity that is in there this native container lets you store multiple values inside a single heat so inside a single position key you can have multiple quadrant data so that is how you have multiple units inside the same bucket then this function in here generates a key based on a certain position it just some math based on a certain sound size and ensures that units within a position near that cell always return the same key so entities in the same quadrant won't have the same hash key added to it now there are multiple jobs in order to make this whole thing work the first one is this one to set the quadrant data on the hash map so what this one does is it cycles through all the entities that contain a translation and a quadrant entity component it gets the position hash map key and simply adds a new quadrant data on that hash map key so here we are just positioning all the entities into their correct quadrants after we set all the entities into their quadrants then we have define causes target job this one cycles through every unit and it tries to get the closest target on the nearby quadrants so you start with the center quadrant then the one to the left right and so on so you check all nine nearby quadrants and then at the end we have a causes target entity now in here in order to benefit from the insane benefits of bursts instead of adding our hash target component we simply store the units and their targets into a native hash map and after finding the closest target job we have another job in order to set the target this one does not use burst since it uses the entity command buffer and we simply use it north to the has target component with the causes target I've done a video on how to find the closest target so check that out to see a more indepth look into how this logic works and down here on the update we are simply preparing all of our data and scheduling our various jobs so first we position them in the hash map then we cycle through all the units are to find it closest and then we add the component to the causes turret again here we are in our scene you can see the highlighted quadrant and down here on the console you can see how many entities are inside this quadrant so this one has 6 1 2 3 4 5 6 yep there are 6 and over here the zombies are coming so now it's got 0 and now it's increasing 1 and so on and as you can see as soon gets one these guys start looking for a target on this quadrant so as soon as they enter they start getting shot and if we look at the entity debugger you can see this entity for example has the historic component which contains the position of his target and the entity field again check out the video on finding the closest target in order to get a more indepth look into how all of this works so once the unit has a has started component then we run another system over here is the marine target zombie system as you can see it's running on every entity with translation the plan animation component has target component and the Marine shoot so he checks if he can shoot if so he plays the shooting animation and he shoots the target entity now the shooting and cousin damage was an interesting problem to tackle doing AI in ECS is probably the most difficult thing to wrap your head around right now in order to be super fast it's really a requirement in order to use memory sequentially that's essentially what the entity chunks do grabbing a piece of random memory for the target Hertz things so we need to minimize it as much as possible so over here my approach has been based on a queue of actions so whenever the Marine should say target he doesn't directly interact with the zombie in order to cause some damage whether he just in queues that action so that way this system for shooting the zombies runs in parallel and then here I have the queued action system which is running on just a simple component system and he goes through all of the cute actions so right now the only action is a marine shooting a zombie so here this code is running on the main thread and it's what finally actually cause damage to the zone so you get the positions for the marine the zombie then we have some bonus effects running on single threaded code all these are not yet port EECS so you can see here how you can mix and match use some systems in ECS and some systems with normal game objects then here we grab the zombie health we ask the entity manager in order to get the health component for the zombie entity once we get it we'll reduce the health by the damage amount that is stored on the zombie action and then we test if he is dead then we spawn a fine body we destroyed the entity and we the component has target from the marine entity if he still has health then we simply update the zombie home so here as you can see for the AI we separated into two systems so first we have the Marine he does all of his data and shoots the zombies that he has as targets he in queues a specific action into a cute actions native queue then after this system runs with all of the marine entities we run our cute action system which goes through all that cute action queue and we do everything we need to do in order to handle the interaction between the marine and the zombies obviously the biggest issue is in here we are using a component system so this code is not Java 5 at all all of this runs on the main thread that means it could potentially become a performance bottleneck however the number of actions that happen every single frame is going to be quite small so in most cases I think this specific pattern would work well in an ECS game again making AI in ETS is a very tricky subject so perhaps this is not the absolute best way of doing things I continue learning as I go along and for now this seemed like a good approach so this is the complete simple demo scene our Marines are here standing around these zombies are being spawned and they move towards them as soon as they get close the quadrant system works in order to find a target for each of these Marines the animation system is working as you saw each animation frame is a mesh and we simply selected on every single frame the zombies keep spawning after a while they start spawning from the sides and they come from everywhere more and more gets fun more and more keep coming and here you can see our stats and right now you can see that this whole scene with all these zombies all these units is currently running at a hundred frames per second and again a lot of these effects are not using ECS so this could be improved even more and more and more keep coming and with all of these zombies all of them working independently all of them have their own AI their own code there aren't things and we're still running at 60 70 frames per second and they all keep going to keep getting a run and again I can still click in order to spawn a bunch more so spawn more in order for them to breathe a little and if they are pushing the Mac everything is working quite nice so as you saw there are still many years that can be improved but this already looks very nice for a pure ECS game and clearly demonstrates the performance benefits also I'm still learning easy as myself so what I've built here might not necessarily end up being the best practices for a pure ECS game as time goes on and more people play around the easiest the best practices will start to emerge so hopefully you've enjoyed this nice little demo of what can be done with ECS it's not necessarily a more difficult way it's just a different way of thinking about how to write code and how to do things as always you can download the project files in utilities from inti code monkey comm if you liked the video subscribe the channel for more ent tutorials post any questions there have in the comments and I'll do my best answer them alright see you next time
