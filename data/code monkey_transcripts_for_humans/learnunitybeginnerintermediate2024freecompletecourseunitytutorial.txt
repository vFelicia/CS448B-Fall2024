With timestamps:

00:00 - hello and welcome I'm your code monkey
00:02 - and here is a free complete course on
00:04 - making a game from start to finish if
00:06 - you've always wanted to learn how to
00:08 - make a game or if you already know the
00:10 - basics but want to see how to organize a
00:11 - more complex project then this video is
00:13 - for you it's perfect for both beginners
00:16 - and more intermediate users this is a
00:18 - completely free course video but it has
00:20 - the same level of quality as my paid
00:22 - courses or my Steam games you can
00:24 - download the project files to follow
00:26 - along or inspect the funnel game you can
00:28 - even play the final game directly on
00:29 - scene we're going to start commonly from
00:31 - scratch and build a really awesome game
00:33 - with tons of systems and mechanics
00:35 - building this design requires working
00:37 - with lots of unity and c-sharp features
00:39 - so this is a really awesome project for
00:40 - you to learn after following this course
00:42 - and learning all of these techniques you
00:44 - won't be able to build all kinds of
00:46 - games in all kinds of genres this is
00:48 - going to involve learning about the
00:49 - basics of unity and c-sharp learning how
00:51 - to make a character controller physics
00:53 - raycast learn all about c-sharp
00:55 - interface and events using script more
00:57 - objects handling UI the new input system
00:59 - and lots more
01:00 - very importantly everything that we're
01:02 - going to do here is going to be focused
01:04 - on writing good easy to understand clean
01:06 - code meaning that I will not be teaching
01:08 - you bad practices that some beginner
01:10 - tutorials teach the code that we're
01:12 - going to write here is production
01:13 - quality code this is not a throwaway
01:15 - demo the quality of the code and the
01:17 - structure of the game that we're going
01:18 - to build is on the same level of quality
01:20 - as my own Steam games as you can see
01:22 - from the video link this is indeed a
01:24 - complete very thorough course so don't
01:27 - try to watch this whole thing in one
01:28 - sitting take your time take it slow and
01:30 - just focus on learning there are
01:33 - chapters for every single lecture in the
01:34 - video here's a quick overview of the
01:36 - entire course all the steps that we're
01:38 - going to take to reach the final
01:39 - published game so first of all we're
01:41 - going to start commonly from scratch by
01:43 - selecting a Unity version and creating a
01:46 - brand new project with that new project
01:48 - we will then learn all about the basics
01:50 - of the UNT interface and setup plane
01:52 - layout
01:53 - then the other important part is Visual
01:55 - Studio which is where we're going to be
01:56 - writing all of our code
01:58 - after that comes an extremely important
01:59 - lecture all about coding style and
02:01 - naming rules like I said the code in
02:03 - this course is on the same level of
02:05 - quality as my Steam games so having
02:06 - proper naming rules and good code sound
02:08 - is Paramount next we're going to
02:10 - download and import all the assets that
02:12 - we're going to use in the course
02:13 - everything is included so you can follow
02:15 - along with every step of the way
02:17 - with yes it's important we're going to
02:19 - set up some quick post processing just
02:20 - to make the game look good then for our
02:23 - first piece of logic we're going to make
02:24 - a simple character controller with that
02:27 - logic working we will then Implement a
02:29 - proper character visual with the
02:30 - included assets
02:31 - next we're going to learn the basics of
02:34 - animation and the animator component and
02:36 - with that we're going to make our player
02:37 - really Common live with some simple but
02:39 - really nice animations then we're going
02:42 - to install the send machine package this
02:44 - isn't actually used too much in this
02:45 - course but I still wanted to include it
02:47 - because it is such a useful tool so I do
02:49 - want you to know about it after that
02:51 - comes another extremely extremely
02:53 - important lecture with regards to
02:54 - writing some good link code we're going
02:56 - to do a nice refactor to replace the
02:58 - Legacy input Venture with the brand new
03:00 - input system
03:01 - learning how to refactor is an extremely
03:04 - important and very valuable skill that
03:05 - will massively improve the quality of
03:07 - your code with that then we're going to
03:09 - implement some nice Collision detection
03:11 - to make sure our character doesn't want
03:12 - through walls
03:14 - next we're going to create the very
03:16 - first kitchen counter and make a script
03:18 - to handle how to interact with it then
03:20 - we're going to learn all about c-sharp
03:22 - events and create a proper interact
03:24 - input next we're going to build a
03:26 - selected counter visual which will
03:28 - require us to learn about the extremely
03:30 - useful Singleton pattern with the
03:32 - counters working we're going to start
03:33 - working on the kitchen objects
03:35 - themselves so these are going to be the
03:37 - ingredients and the plates we're going
03:38 - to use scriptable objects to Define all
03:40 - of the types
03:41 - then a very important part of our design
03:43 - is each kitchen object will have to be
03:46 - placed somewhere so we're going to take
03:48 - some time to really think about the best
03:49 - way to achieve that all while riding
03:51 - some good clean code next we're going to
03:53 - enable the player to pick up an object
03:55 - in doing so we're going to learn about
03:57 - c-sharp interfaces then we're going to
03:59 - make a container counter this is from
04:01 - where we can spawn new objects
04:03 - with that we will enable the player to
04:05 - pick up objects and drop them anywhere
04:07 - where there's space
04:09 - then we're going to make the cutting
04:10 - counter this one enables the player to
04:12 - cut an ingredient into slices so to do
04:15 - that we're going to make an alternate
04:17 - interaction
04:18 - and for handling the cutting we're going
04:20 - to once again use script more objects to
04:22 - define a proper cutting recipe
04:24 - then we're going to learn about a really
04:26 - awesome Unity feature we're on canvases
04:28 - and use that to display a nice progress
04:30 - Bar for our cutting progress after that
04:32 - is a quick lecture just going to make a
04:35 - very useful generic script to make any
04:36 - object look at the camera
04:38 - next for another counter we're going to
04:40 - build a trash bin this is where the
04:42 - player can drop objects to destroy them
04:45 - then the stove counter this one is going
04:47 - to be quite a bit complex we're going to
04:49 - create recipes for cooking and for
04:51 - burning we're going to learn how to make
04:53 - a basic state machine and handle timers
04:55 - next we're going to make the plates
04:57 - counter this is a simple encounter that
04:59 - just spawns a bunch of plates
05:01 - after that we're going to make some
05:03 - custom Logic on the plate to be able to
05:04 - hold other objects
05:06 - with that logic working we're going to
05:08 - build a complete visual for all the
05:09 - objects that can exist on the plate
05:11 - then make a nice UI element on the plane
05:14 - itself to showcase the icons of what
05:16 - exactly is on that plate afterwards
05:18 - we're going to make the very last
05:20 - counter the delivery counter this is
05:22 - where we drop the completed plates and
05:24 - in this lecture we're also going to
05:26 - learn about the unity share graph and
05:27 - make a quick simple custom Shader
05:30 - then we're going to build the delivering
05:31 - manager class that generates the recipes
05:33 - that the customers are requesting next
05:36 - we're going to build a UI to showcase
05:38 - the wedding recipes after that comes
05:40 - something pretty crucial we're going to
05:42 - add some music and then add some sound
05:44 - effects for all kinds of game actions
05:47 - without the game won't be almost done so
05:49 - next we're going to build a proper game
05:51 - start and a game end
05:52 - then make a simple main menu and handle
05:55 - scene loading after that hand on
05:57 - creating a basic pause window
05:59 - then make an options menu enable the
06:02 - player to modify the audio levels and
06:03 - rebound keys
06:05 - after that we're going to enable menu
06:07 - navigation with a controller and in the
06:09 - end as usual comes the Polish stage so
06:11 - we're going to add all kinds of small
06:13 - tweaks and effects to make the game feel
06:14 - really great like I've said many times
06:16 - polish is what separates good games from
06:18 - great games after all of that we will
06:20 - have our final completed project so as
06:22 - you can see you will learn about tons of
06:24 - Topics by following this course also let
06:27 - me point out one of the reasons why I
06:28 - chose this specific design is because my
06:31 - next free course won't be on taking the
06:33 - game that we're going to build here and
06:34 - make it multiplayer so if you've ever
06:36 - wanted to make multiplayer games then
06:37 - that course will be excellent for you
06:39 - definitely take your time following this
06:41 - course the multiplayer free course
06:42 - should hopefully be out next month or if
06:44 - you're watching this in the future check
06:46 - the links in description although that
06:48 - multiplayer video won't be starting from
06:49 - where this course ends so definitely
06:51 - make sure you watch this one now if you
06:53 - are new to the channel then welcome and
06:55 - here's a bit about me and my credentials
06:57 - or why you shouldn't listen to what I
06:59 - have to teach
07:00 - my name is Hugo and I've been running
07:01 - this Code Monkey YouTube channel for
07:03 - five years now in total almost 700
07:06 - videos on all kinds of topics including
07:08 - tons of tutorials sharing my knowledge
07:10 - to help you on your Game Dev Journey I'm
07:12 - also a professional indie game developer
07:14 - making games for over 10 years with 8
07:16 - successful Games published on scene so
07:18 - what I'm teaching here is based on a lot
07:19 - of years of experience making a lot of
07:21 - games just like with my paid courses I'm
07:23 - always going to be in the common
07:24 - censoring questions so if you get stuck
07:27 - at a particular point or need extra
07:28 - clarification on something go ahead post
07:31 - a comment and I'll do my best to help do
07:33 - make sure you include a timestamp of
07:34 - what you're referring to I will also be
07:36 - updating the pin comment with any
07:38 - frequently asked questions that I see so
07:40 - actually right now go ahead pause the
07:42 - video and scroll down a bit just to look
07:43 - at that comment since on YouTube I
07:45 - cannot update the video after it's
07:47 - published I will be updating that
07:48 - comment over the next months and years
07:50 - with anything that comes up also I've
07:52 - been running this channel for five years
07:53 - and in that time I've made almost 700
07:55 - videos so there's lots of topics that
07:58 - I've covered separately in more detail
07:59 - all of those videos are linked in the
08:01 - description throughout this course I
08:03 - will be focused on building this
08:04 - specific game using whatever it takes to
08:06 - build it meaning for example when we get
08:08 - to using c-sharp events I won't teach
08:10 - the basics about how they work in order
08:12 - to achieve what we want to build but if
08:14 - you then want to learn about c-sharp
08:15 - events in more detail definitely go
08:17 - watch a dedicated video and I also made
08:19 - a page on my website for this course it
08:22 - contains a link to download all of the
08:23 - project assets you can also download the
08:26 - complete project files for every single
08:27 - lecture so if you get stuck at any point
08:30 - you can download the code at that
08:31 - lecture and compare with your own
08:33 - there's also references to all of the
08:35 - videos and I will also be including
08:37 - frequently asked questions for each
08:38 - lecture so definitely keep that page
08:41 - open in a second tab as you follow along
08:43 - this course now this free course Took a
08:45 - ton of work to make so I really hope you
08:47 - find this video helpful go ahead and hit
08:49 - the like button if it helps you it's a
08:51 - small thing but it generally does help
08:52 - this video on the YouTube algorithm
08:54 - making this course was a ton of work and
08:56 - by making it commonly free it means it
08:58 - will obviously never make as much money
08:59 - as if I had just made this a paid course
09:01 - I'm personally okay with that decision
09:03 - with the hopes that by making it free it
09:05 - won't reach and help many more people
09:07 - I'm also a big believer that education
09:09 - should be free so if you can't afford
09:11 - one of my paid courses like if you're
09:13 - just a kid or going through a rough time
09:15 - I still want you to have access to high
09:17 - quality education so you can achieve
09:19 - your Game Dev dreams one easy way you
09:21 - can help me for free is simply by liking
09:23 - this video subscribing to the channel
09:24 - and just watching this course
09:26 - that will hopefully help push this video
09:28 - on the YouTube algorithm and help it
09:29 - reach many more people another free way
09:32 - to support what I do is I'm currently
09:33 - working on my next team game called turn
09:35 - one Liberation you can wish list the
09:37 - game on Steam wishlists matter a lot for
09:40 - steam visibility so just by doing that
09:42 - you won't be helping me and just in case
09:44 - you can't afford it and you find this
09:46 - free course useful you can also support
09:47 - what I do in a few other ways I spent a
09:50 - bunch of money making this course I
09:51 - hired an artist for the 3D assets so
09:53 - that I had the right to distribute them
09:55 - so that you can download it and follow
09:56 - along
09:57 - same thing for the music and sound
09:59 - effects the logo and the cost to upload
10:01 - the game to seem so I would like to at
10:03 - least not lose money on this project
10:04 - hopefully there's enough of you who
10:06 - can't afford to help me so that I can at
10:08 - least break even
10:09 - and for one way you can support is I
10:11 - added this exact same course on my
10:13 - website as a regular paid course
10:15 - although I want to be very very clear
10:17 - there is absolutely no difference
10:19 - between this free video and the paid
10:20 - course there is absolutely nothing
10:22 - behind any kind of payroll all of the
10:25 - lectures are free all of the apps are
10:27 - free everything is free you don't have
10:28 - to pay for anything if you can't afford
10:30 - it or you just don't want to the paid
10:32 - version is essentially a donation the
10:35 - only difference is this free YouTube
10:36 - video has regular YouTube ads whereas
10:38 - the paid version on the website doesn't
10:40 - have any ads that's it that's the only
10:42 - thing so the only reason why I made that
10:44 - paid version is just in case some of you
10:46 - can't afford it and you want to support
10:48 - what I do and want to help me break even
10:49 - on this project but again only do that
10:52 - if you can't afford them if you can't
10:53 - that's personally fine I hope you'll
10:55 - learn a ton from watching and following
10:57 - this free course beyond that if you
10:59 - follow this course and you enjoy my
11:01 - teaching sound perhaps look into my
11:02 - other courses if you like this video
11:04 - then I think you won't really like my
11:06 - turn-based strategy course that is the
11:08 - perfect course to follow up on this one
11:09 - one it Dives even deeper into some of
11:12 - the concepts used here and it will help
11:13 - you make the jump from beginner to
11:15 - Advanced and since you're interested in
11:17 - unity I think my ultimate unity overview
11:19 - course would also be very useful to you
11:21 - each lecture on that course is focused
11:23 - on teaching one entitled feature there's
11:25 - already over 15 lectures including
11:27 - plenty of small but very important
11:29 - things that you just wouldn't see in a
11:31 - regular YouTube video if you're
11:32 - interested in visual scripting I have
11:34 - course on making three unique games
11:35 - internally with visual scripting and no
11:37 - code at all or if you prefer code you
11:40 - can learn how to build a nice Builder
11:41 - Defender game so if you enjoy my
11:43 - teaching Style on this free course then
11:44 - check out my other ones then of course
11:46 - YouTube has Channel memberships and
11:48 - super thanks so you can use those if you
11:50 - want I also have my patreon if you
11:52 - prefer that and in a lot of my videos I
11:55 - have some affiliate links if you ever
11:56 - pick up anything through those I get a
11:58 - nice commission and I also have some of
12:00 - my own assets on the unity Astor so if
12:02 - you enjoy this free course and you want
12:04 - to support what I do there's plenty of
12:05 - ways but again don't feel obligated if
12:08 - you can't afford it or you just don't
12:09 - want to that's perfectly fine I hope
12:11 - you'll learn a ton from watching and
12:13 - following this recourse alright so
12:15 - that's enough talk of that for now
12:16 - before we begin building the game from
12:19 - scratch let's inspect the final polish
12:21 - game that we're going to build so let's
12:22 - see that in the next lecture
12:25 - hello and welcome I'm your code monkey
12:27 - here let's take a look at the final game
12:29 - that we're going to build so we start
12:31 - off on a simple but really nice main
12:33 - menu so we've got a nice visual a nice
12:35 - logo and a bunch of useful buttons then
12:37 - of course the game has a nice loading
12:39 - system so when I click on play it's
12:40 - going to load into a unloading scene and
12:42 - then funnel into the final game scene so
12:44 - let's go ahead and play and if there we
12:46 - go here we do see the game scene and
12:48 - right away we see a nice internal window
12:50 - so it's telling us how to play the game
12:52 - so the basic interactions and then over
12:54 - here the controls importantly these are
12:56 - all rebindable so over here this element
12:58 - is all Dynamic then we can look at this
13:00 - tutorial for as long as we want and we
13:02 - are waiting for the interact to continue
13:03 - there's also a really nice song playing
13:05 - in the background so the game has music
13:07 - now we can look at this tutorial for as
13:09 - long as we want and when we're ready we
13:10 - can interact and continue and as soon as
13:12 - we do if there you go we've got a nice
13:14 - countdown some nice animations a nice
13:16 - sound effect and there you go now we are
13:17 - playing okay so here I am controlling a
13:19 - nice character I can move in any
13:21 - direction
13:23 - there is Collision detection so
13:24 - obviously I cannot go inside solid
13:26 - objects so I can walk around and for the
13:28 - goal of the game over here on the left
13:29 - side we've got recipes that the
13:31 - customers are waiting for so for example
13:33 - One customer wants a simple Burger so
13:35 - for that we gonna need to pick up a nice
13:37 - bun so let's pick it up then the burger
13:39 - obviously requires a meat Patty so let's
13:41 - go ahead we can pick one up from here
13:43 - but this one is an uncooked meat padding
13:45 - so we need to drop it over here on the
13:46 - stove and there you go it starts cooking
13:48 - we've got a nice timer we've got a nice
13:50 - warm bar UI
13:51 - and there you go it keeps counting and
13:53 - we've got some nice park on some nice
13:55 - visuals and over there even a nice
13:56 - indicator telling us the meat is about
13:58 - to burn and there you go the meat has
13:59 - burned so now I can pick this up and I'm
14:02 - holding some burnt meat so the customer
14:03 - probably doesn't want to eat this so we
14:06 - can go over here to the trash or trash
14:07 - it let's try doing another one and do it
14:09 - properly so let's wait for it to cook
14:11 - pick up a plate so we can pick it up
14:13 - directly onto the plate there you go to
14:14 - the meat is cooked so let's pick it up
14:16 - then go pick up some bread and there you
14:18 - go here we have our camelli recipe so
14:20 - let's go into the delivery counter
14:21 - deliver it and there you go a nice
14:23 - delivery success all right awesome we've
14:26 - just delivered our first recipe so then
14:28 - someone else wants a salad so let's go
14:30 - ahead pick up a tomato here we have a
14:32 - big uncut tomato so let's drop it onto a
14:34 - cutting board and now we can interact
14:37 - with it so we can interact with a
14:38 - secondary interaction key
14:40 - and by interacting we cut the tomatoes
14:42 - so it takes a few cuts and there you go
14:44 - with slices and it's sliced into tomato
14:46 - slices so let's do the same thing for
14:48 - the Cabbage here we are holding a
14:50 - regular cabbage then slice it and this
14:52 - one actually takes a bunch more and
14:53 - there you go got both slices okay great
14:55 - so now let's pick up the plate pick up
14:58 - both slices and deliver to the customer
14:59 - and there you go got a nice success all
15:01 - right awesome and of course we have a
15:04 - correct identification of if we have a
15:06 - crack recipe or not
15:07 - so if I just pick up an empty plate and
15:10 - deliver it there you go got a film
15:11 - delivery because nobody wants just an
15:13 - empty plate alright so here you can
15:15 - already see quite a lot of interactions
15:16 - quite a lot of systems at work so the
15:18 - character has a nice character
15:19 - controller it has physics interaction
15:21 - you can see how it identifies the
15:23 - counter that is in from the character I
15:25 - can press a button to interact with the
15:26 - counter and interacting with different
15:28 - counters does different things so if I
15:30 - interact with a clear counter I can pick
15:31 - up or drop things over here I can pick
15:33 - up drop it with an alternate interaction
15:35 - I can do the second action then there's
15:38 - the stove machine so that one has a nice
15:40 - State machine so it counts up over here
15:42 - we've got some nice particles we've got
15:44 - a nice Bloom so all the Visions look
15:45 - really great so we've got some post
15:46 - processing we have a bunch of UI
15:48 - elements directly on the world and
15:50 - outside of here we've got some regular
15:52 - UI elements
15:53 - so we've got the recipes with Dynamic
15:55 - icons for all of them we've got a timer
15:57 - over there on the top right corner
15:59 - showing how long we have to deliver on
16:01 - our recipes and on the kitchen counter
16:03 - we're also using a custom Shader so this
16:04 - was built using shade wrap so as you can
16:06 - see lots of internalized systems then
16:09 - the game also has of course the basics
16:10 - that any game should have so I can pause
16:13 - the game and there you go we've got a
16:14 - nice pause menu so we can resume to go
16:16 - back or pause it again and of course
16:18 - while pause everything is possible
16:19 - that's great we can go back into the
16:21 - main menu or we can go into options and
16:24 - over here we can play around the sound
16:25 - effects volume the Music Volume we've
16:27 - got all of our controls importantly
16:29 - these are the controls for the keyboard
16:31 - and also the GamePad
16:33 - so the game can be played with any
16:35 - Gamepad so it can be an Xbox controller
16:37 - PlayStation switch controller it doesn't
16:38 - matter all of them work and we can also
16:41 - rebind all these Keys both the keys as
16:43 - well as the GamePad inputs so let's go
16:45 - ahead and deliver a cheeseburger so
16:47 - here's some burn meat so let's toss this
16:48 - then pick up some more meat pick up a
16:51 - plate here we've got some cheese we've
16:53 - got some bread pick up the meat and
16:55 - deliver it all right awesome and of
16:58 - course finally at the end when our
17:00 - timers left here we have a nice game
17:01 - over window showing how many recipes we
17:03 - delivered alright so this is the final
17:06 - game that we're going to build as you
17:07 - can see it involves lots of interesting
17:09 - interactions which require learning lots
17:11 - of different skills we're going to be
17:13 - using c-sharp interfaces c-sharp events
17:15 - the new input system shade graphs
17:16 - critical objects we're going to learn
17:18 - about c-sharp events making character
17:20 - controller handle collisions and so on
17:22 - like I said one thing that we're going
17:24 - to focus heavily throughout the making
17:25 - of this game is on writing good clean
17:27 - code meaning that the final game that
17:29 - we're going to build won't be very easy
17:30 - to expand upon thanks to how long the
17:33 - code is very clean it will be very easy
17:35 - to add more recipes maybe more counters
17:37 - with more actions maybe things like
17:38 - perhaps washing dishes adding an oven
17:40 - and so on or really you could make
17:42 - something completely different
17:44 - this game is all about character and
17:46 - interactions
17:47 - so that could be whatever you want you
17:49 - could take this as a base and build some
17:51 - kind of sci-fi game something like Among
17:53 - Us or FTL you could make a survival
17:55 - crafting game like rust or Minecraft or
17:57 - Don't Starve really fun learning how to
18:00 - build this game by the end you won't
18:01 - have gained the knowledge required to
18:03 - build all kinds of unique and
18:04 - interesting games alright so now that
18:06 - we've seen the final game Let's actually
18:07 - build it just before we do let's get a
18:09 - quick refresher of the absolute Basics
18:11 - you should know in the next lecture
18:13 - hello and welcome I'm your code monkey
18:15 - in this lecture we're going to just get
18:18 - a quick refresher of the absolute Basics
18:20 - you should know in order to be able to
18:21 - follow everything in this course okay so
18:24 - like I said this free course is targeted
18:26 - at both beginners and more intermediate
18:28 - users in order to start following the
18:30 - course you really only need to know the
18:31 - absolute Basics I've made three useful
18:33 - videos with all of the basic knowledge
18:35 - required to follow this course
18:37 - watch the video on how to download
18:39 - install and set up Unity then the quick
18:41 - Unity Basics and the c-sharp basics
18:44 - those three Quick videos contain all of
18:46 - the absolute basic knowledge you need so
18:48 - if you're a complete beginner go ahead
18:50 - pause this video and go quickly watch
18:51 - those and even if you are already
18:53 - somewhat familiar with unity still go
18:55 - ahead and give those videos a watch
18:57 - perhaps in a faster speed just so you
18:59 - know everything that this course assumes
19:00 - that you know here I will assume that
19:02 - you know the basics covered in those
19:04 - videos like what is a game object what
19:06 - is a transform what is a mono Behavior
19:08 - how scripts have a start and update and
19:10 - some c-sharp Basics as long as you know
19:12 - those absolute Basics you should be able
19:14 - to follow everything in this course I
19:16 - won't teach everything above the
19:17 - absolute Basics and if you are a more
19:20 - advanced users definitely keep watching
19:21 - the beginning of this course might not
19:23 - have much that is new to you but as we
19:25 - build the game and start using more
19:27 - advanced tools like script of objects
19:29 - c-sharp events and interfaces
19:30 - refactoring code and focusing on Project
19:32 - architecture and writing some good clean
19:34 - code
19:35 - if you are not a complete beginner you
19:37 - will still learn quite a lot from seeing
19:38 - how this project is built and again like
19:41 - I said I answer comments every single
19:42 - day so any questions you have just post
19:45 - them there and I'll do my best to help
19:46 - this course is split into lectures they
19:49 - are all as chapters on videos so you can
19:51 - navigate around let me also take this
19:53 - time to point out that you are not
19:54 - expected to follow this course in one
19:56 - sitting go ahead and take your time
19:58 - focus on actually learning remember
20:00 - that's the only goal you're not
20:02 - competing with anyone you're gaining
20:04 - knowledge just for yourself
20:05 - so take as much time as you need
20:07 - re-watch some lectures if you feel you
20:09 - didn't fully get it or just ask some
20:11 - questions whatever you do take your time
20:13 - and just focus on actually learning so
20:15 - again if you haven't done so go ahead
20:17 - pause this video and go watch those
20:19 - three Basics videos with that we're
20:21 - going to have everything we need to get
20:22 - started we're going to start only from
20:25 - scratch so let's begin creating a brand
20:26 - new project in the next lecture
20:29 - hello and welcome I'm your code monkey
20:31 - in this lecture we're going to begin
20:32 - actually building our game so let's
20:34 - create a chameleon 2 project and start
20:36 - building it on from scratch okay so the
20:38 - first thing that we need is to install
20:39 - Unity now I cover this in detail on that
20:41 - other Basics video so here I will assume
20:44 - that you already have Unity Hub
20:45 - installed the first decision we really
20:47 - need to make is choosing a Unity version
20:48 - Sony Hub you go into installs and
20:51 - install an editor and now Unity
20:53 - recommends that you use the LTS version
20:54 - or long term sport you should be using
20:56 - that one in most cases it's what it
20:58 - installs by default which as the time of
21:00 - this recording the latest one the latest
21:02 - LTS one is 2021.3 however I want this
21:05 - video to stay up to date for as long as
21:07 - possible so for making this game I will
21:09 - actually be using version 2022.2 if
21:11 - you're watching this video where it is
21:12 - came out then download this version and
21:15 - if you're watching this months in the
21:16 - future after version 22 on TS is out
21:18 - then you can use that one it won't
21:19 - probably be the exact same thing as
21:21 - version 22.2 so you should be able to
21:23 - follow everything exactly for any
21:24 - changes I will Point them out in the
21:26 - updated pin comment and if you're
21:28 - watching this years in the future and
21:29 - there's an even newer LTS version I
21:31 - would still recommend you follow using
21:32 - the 22 LTS don't worry about using a
21:35 - quote unquote older version everything
21:36 - you'll learn here in this version will
21:38 - still be applicable even 10 years from
21:40 - now so I said I'm going to be installing
21:41 - this one in terms of modulus doesn't
21:43 - really need anything I already have
21:45 - Visual Studio Community installed and
21:46 - all the other ones are unticked so
21:48 - install
21:52 - okay so the version is installed now
21:54 - let's create a new project let's go into
21:56 - the projects tab then create a new
21:57 - project and now first up up here make
22:00 - sure to select the right version so
22:01 - again I'm going to be using 22.2 then
22:04 - for the templates this has mainly to do
22:06 - with the UNT render pipelines now if
22:08 - you're a beginner don't worry about that
22:09 - too much just go ahead and select the 3D
22:12 - urp template so scroll down this one
22:14 - right here 3D urp make sure to select
22:16 - this one and not the one that says just
22:18 - reading the urp here stands for the
22:20 - universal render pipeline which means
22:22 - our game will be playable on literally
22:23 - any platform so we can make the funnel
22:25 - game and put it on steam or consoles are
22:27 - mobile it won't run on everything then
22:30 - over here on the right side let's
22:31 - quickly just download the template there
22:33 - it is it's done
22:34 - now select the name for your project so
22:36 - I'm going to call this kitchen chaos and
22:39 - then select the founder for it all right
22:41 - so that's it again make sure you're
22:42 - using the exact right version make sure
22:44 - you're using the 3D urp template give it
22:46 - a name a folder and let's head on create
22:53 - all right so it's open and right away
22:55 - you might or might not see a window
22:57 - talking about urp material upgrades I
22:59 - think this has to do with the template
23:00 - not having the default materials updated
23:02 - to the latest Erp version so if you're
23:04 - watching this in the future chances are
23:05 - you might not see this one at all but if
23:07 - you do then just go ahead click on OK
23:09 - and it will automatically upgrade all of
23:10 - the default materials alright so here we
23:13 - have our basic unity window now since we
23:15 - started a project starting from the RP
23:17 - template we have down here A bunch of
23:19 - Erp helper files so you can click to
23:21 - select the readme file and you can see
23:22 - it over here on the right side on the
23:24 - inspector if you want you can browse
23:25 - around these links in order to learn
23:27 - more about urp but in our case we're
23:28 - building the our game we really don't
23:30 - need this so we're here on the
23:31 - inspection let's just click this button
23:33 - to clean up these readme files just go
23:35 - ahead click on yes and okay that's it so
23:37 - basically you should only have these
23:39 - files in your project window so there's
23:41 - a scene folder and inside we've got the
23:43 - simple scene then we've got the settings
23:44 - and inside a bunch of urp assets while
23:47 - this should have been set up
23:48 - automatically since we use the 3D
23:49 - template and then finally we just have
23:51 - the urp equivalent settings asset now
23:53 - let's just verify find everything worked
23:54 - correctly so let's go to the top left go
23:56 - into edit then go down into project
23:58 - settings then over here let's go into
24:00 - the graphics Tab and you should see the
24:02 - urp High Fidelity asset assigned by
24:04 - default if not you can click on the
24:06 - circle icon and assign it then the other
24:07 - menus over here the urp mobile settings
24:09 - again this one should be set by default
24:11 - then down here on the quality tab on
24:13 - this one make sure High Fidelity is
24:15 - selected basically whatever you select
24:16 - here is the quality that we'll be using
24:18 - in the editor and in turn the selected
24:20 - quality over here also has a render
24:21 - pipeline Ascent now in order to avoid
24:23 - any confusion let's actually get rid of
24:25 - the other ones so let's just click on
24:26 - the trash icon to get rid of the
24:28 - performance and the bounce quality so
24:29 - just click and click okay so we only
24:31 - have this one then let's close the
24:33 - project settings and let's go into the
24:34 - settings folder and over here let's
24:36 - select the urp balance there are two
24:38 - assets for each quality so select those
24:39 - leave the High Fidelity and the
24:41 - performance and let's delete these
24:42 - alright that's it by the way if you made
24:44 - a mistake and accidentally deleted
24:46 - something don't worry you can always
24:47 - just click over here on the plus icon on
24:48 - the project window and then go over here
24:50 - under rendering and you can create a new
24:52 - urp asset with the universe personal
24:53 - render okay so just like this so we only
24:56 - have one quality setting we have high
24:58 - fidelity the quality setting is using
25:00 - this random pipeline asset which is also
25:01 - using this renderer so that's really it
25:03 - with this we have the absolute bare
25:05 - minimum we need if in the end after
25:06 - building the whole game you want to
25:08 - provide multiple quality settings then
25:09 - you can come back to this menu and
25:11 - recreate them but in order to avoid
25:12 - confusion while building the game let's
25:13 - keep things like this as simple as
25:15 - possible okay so that's the basic setup
25:17 - done next we want to prepare our layout
25:19 - so let's continue on to the next lecture
25:22 - hello and welcome I'm your code monkey
25:24 - in this lecture we're going to learn
25:26 - about the union layout and set it up so
25:28 - first things first let's familiarize
25:30 - ourselves with the various NT Windows to
25:31 - create our own layout it's very
25:33 - important that you feel uncomfortable
25:34 - with your layout that you have easy
25:36 - access to all the things that you need
25:37 - then you know where everything is you
25:38 - can see that there's lots of tabs
25:40 - everywhere over here on the NT window
25:41 - all of them can be dragged and dropped
25:43 - in any different position so you can
25:45 - customize your layout to get it looking
25:46 - exactly as you want you can set it up in
25:48 - any way but it will be easier to follow
25:50 - this course if you're following the same
25:51 - layout as me I'm assuming you've seen my
25:53 - quick Basics video so I'm assuming you
25:55 - know what is the inspector what is a
25:57 - game object what is a transform what is
25:59 - the console where is the hierarchy and
26:00 - so on if this is the very first time
26:02 - you're seeing the UNT interface go watch
26:03 - that other quick video first just learn
26:05 - the absolute Basics now for me I've been
26:07 - using Unity for over 10 years now so
26:09 - let's see the layout that I've developed
26:10 - over the years first the inspector on
26:12 - the right side just like default that
26:14 - way we always have a nice view of the
26:15 - selected object and whatever scripts and
26:17 - components it has then for the hierarchy
26:19 - I like to put it down here only on left
26:21 - side we're going to make sure that in
26:22 - our scene is always organized so we
26:24 - don't need the hierarchy to take up tons
26:25 - of space then with the project files
26:27 - next to it this corner is enough to
26:29 - really browse all of the files we want
26:31 - the console to be on the tab right next
26:32 - to it usually I find that when making
26:34 - the game I want to look at the project
26:36 - window but when playing the game I just
26:37 - want to look at the console so keeping
26:39 - them in the same place but on different
26:40 - tabs works great then over here on the
26:42 - center of the scene View and again with
26:44 - the game view right next to it okay so
26:46 - this is the basic layout that I normally
26:47 - use now for a couple more options let's
26:50 - go into the project window and on the
26:52 - top right corner you can see over here
26:53 - these little three dots by default it
26:55 - shows you a two column layout so there's
26:57 - a column here and a column here but
26:59 - personally I prefer the one column
27:00 - layout this shock is one of the project
27:02 - files in a nice compact list view the
27:04 - one thing where I prefer the other one
27:05 - is if you're browsing for some visual
27:07 - assets over here you can increase the
27:08 - thumbnail size but for most times I
27:10 - really like to use the one com layout
27:12 - much more compact also since we're
27:14 - talking about the project window just in
27:15 - case you don't know there's over here
27:17 - this little button with the eye this one
27:19 - has to do with package visibility if you
27:21 - toggle it then some of the inside
27:22 - compacts are hidden whereas if you
27:24 - untangle it then you can see all the
27:25 - various packages with all the source
27:27 - code and so on you can expand over here
27:29 - the packages and right now it is showing
27:30 - all of them all of them with source code
27:32 - the things everything in there and if
27:34 - you click on this then it hides it only
27:36 - shows a bunch of core ones but for most
27:37 - part you really want to leave this text
27:39 - and leave this one collapse nice and
27:41 - clean okay so then on the console over
27:43 - here once again let's go into the three
27:44 - dots and for the unlock entry for this
27:47 - one I like to select one line this makes
27:49 - the console nice and compact which I
27:51 - personally prefer you can see more logs
27:53 - without taking up more space and if you
27:55 - want to read the home log you can always
27:56 - just click on it to see the home stack
27:58 - Trace now there are also some more
27:59 - options over here if you want for
28:01 - example show the timestamp this will
28:02 - show the timestamp when each message
28:04 - were sent you can use a mono space font
28:06 - meaning a font where every character has
28:08 - the exact same width so a bunch of
28:09 - options but for me leaving it just like
28:11 - this works perfectly fine then also
28:13 - importantly over here these three
28:14 - buttons these toggle the visibility for
28:17 - the type of messages that appear in the
28:18 - console the unlocked one this one is for
28:20 - regular messages we're going to use this
28:21 - a lot then we've got warnings and
28:23 - finally errors if you untangle them then
28:25 - the messages of that type will not show
28:27 - up on the console so if you ever come
28:29 - across an issue where nothing is showing
28:30 - up on the console make sure all three of
28:32 - these buttons are ticked then on left
28:33 - side on clear you can click on the Arrow
28:35 - to see more options I like to set it to
28:37 - clear on play then collapse this one
28:39 - basically collapses messages that are
28:40 - the same all of them into one entry
28:42 - personally I do nothing like this I want
28:45 - to see every single message as it comes
28:46 - out even if it's repeated I've also seen
28:48 - this lead to a lot of confusion for some
28:50 - people they think their code is firing
28:52 - just one message when it's actually
28:53 - firing hundreds So to avoid any
28:54 - confusion make sure you leave this
28:56 - Untitled then for airpods this will
28:58 - automatically pause the game when there
28:59 - occurs you should definitely have this
29:01 - one toggled if there is an area you
29:03 - definitely want to know about it you
29:04 - want to know when it happens so you can
29:05 - fix it whereas if you untuckle this you
29:07 - might get some errors and the game might
29:09 - keep playing which will then lead to
29:10 - lots of confusion when something starts
29:12 - behaving weirdly so always leave this
29:14 - one toggled and then the editor button
29:16 - this one is for more advanced use case
29:17 - so don't worry about it okay so that's
29:19 - the console then over here for the game
29:21 - view we've got a button here to select
29:23 - the aspect ratio let's go ahead and
29:25 - select fully Gene this one is a 16x9
29:27 - aspect ratio so everything is pretty
29:29 - normal this will really only matter when
29:31 - we start working on the UI but so I like
29:33 - to keep it at 16x9 always then on this
29:35 - button that says play Focus we can
29:37 - modify some options basically Focus
29:39 - won't play exam like this on this small
29:40 - window if you choose maximize then it
29:42 - will maximize this one when playing the
29:44 - game and play in Focus won't play the
29:46 - game even when the window is not in
29:47 - Focus then another important one is
29:49 - actually on the same one as the aspect
29:50 - ratio here we've got a button to turn on
29:52 - vsync usually When developing the game
29:54 - you really want to toggle this that's
29:55 - because right in the beginning when the
29:57 - game doesn't really have anything you
29:58 - can leave it on Talent then this might
29:59 - run at like a thousand frames per second
30:01 - and that will pretty much drive your GPU
30:03 - crazy finally if your game view is
30:05 - looking a bit too pixelated make sure
30:06 - over here on the scale slider make sure
30:08 - this one is not zoomed in this one
30:10 - should always be pushed straight to the
30:11 - left as much as possible okay so that's
30:13 - the game view then over here on the
30:15 - scene view for this one default should
30:16 - be good these two buttons are extremely
30:18 - important pretty much all the time you
30:20 - want to keep the tone handles on the
30:21 - pivot it and not on the center if you
30:23 - ever see your handles on weird places
30:25 - always come back to this you want to
30:26 - sound pivot pretty much all the time
30:28 - then for rotation sometimes local is
30:30 - useful but for the most part you should
30:31 - probably be keeping in and Global then
30:33 - for the great showing the reason why yep
30:35 - down looks pretty good a nice little
30:36 - visual grid then you've got a bunch more
30:38 - options if you want then next to it
30:39 - we've got snapping this one we also
30:42 - don't need this for now and finally same
30:44 - thing for increment also don't need this
30:45 - okay then on the right for the drum mode
30:47 - let's leave it on Shaden for two then
30:49 - let's leave this disabled since we're
30:50 - working on a 3D game for lights let's
30:52 - make sure this one is enabled for sound
30:54 - we're only going to add this in the end
30:55 - so it doesn't really matter for now then
30:57 - for special effects usually you want
30:59 - this one to be enabled so it shows
31:00 - everything you can click on the arrow
31:02 - and make sure all of them are toggled
31:03 - the only exception is always refresh you
31:05 - probably don't need this little scene
31:07 - window to be refreshing at 60 frames per
31:09 - second so you can leave that one
31:10 - unticked and take on the others then
31:12 - these are for the hidden objects so
31:13 - let's leave them toggled for the camera
31:15 - here are the defaults and finally gizmos
31:17 - leave them all enabled as the defaults
31:19 - alright so down that's end here is in
31:21 - layout and going to be using throughout
31:23 - the course it will be easier to follow
31:24 - the course if you're using the exact
31:26 - same layout as me so ideally you should
31:27 - be using this but again like I mentioned
31:29 - all the windows are customizable so if
31:31 - there's something that you absolutely
31:32 - prefer differently then go ahead you can
31:34 - drag and drop and place any Windows
31:36 - anywhere you want so once you have
31:37 - layout your happy win you can go up here
31:39 - to the top right corner where it says
31:40 - default you can click on it and here
31:42 - you've got a bunch of layouts so you can
31:43 - save your new layout so I'm going to
31:45 - save this one as kitchen chaos and then
31:47 - over here you can select anyone you want
31:49 - for example if you ever have some issues
31:51 - with any kind of weird editor Windows
31:52 - you can load back the default layout and
31:54 - then go back and load your own layout
31:56 - okay so with that our layout is set up
31:58 - the next important thing is setting up
32:00 - visual studio so let's do that in the
32:01 - next lecture
32:03 - hello and welcome I'm your code monkey
32:05 - in this lecture we're going to set up
32:07 - our Visual Studio alright so with the
32:09 - Intel layout setup let's make sure
32:11 - Visual Studio is also set up correctly
32:12 - I'm going to be using version 22
32:14 - Community this one is the free version
32:16 - you don't absolutely have to use the
32:18 - same code ID that I'm using you can use
32:20 - writer or vs code or whatever you want
32:22 - so let's see my setup for visual studio
32:24 - but first let's actually set up
32:25 - something over here in unity so let's go
32:28 - up top into window and then let's open
32:30 - up the package manager then over here on
32:32 - the drop down menu let's select the
32:34 - packages and select the ones from DNT
32:36 - registry then let's scroll down to find
32:38 - the visual studio editor package so here
32:41 - it is this one this package basically
32:42 - handles the integration with visual
32:44 - studio so you can use the debugger and a
32:46 - bunch of things alternatively there's
32:47 - also a package over here for visual
32:49 - studio code and there's also one over
32:50 - here for jetbrains Rider so if you're
32:52 - using a different IDE go ahead and
32:54 - install the package for me I'm going to
32:56 - install the visual City one so this one
32:57 - just go ahead and install okay it's done
32:59 - so next let's go up into edit and let's
33:02 - open up the print preferences then over
33:04 - here let's go down into external tools
33:06 - and on the external script editor make
33:08 - sure you select the one you're using so
33:09 - again for me I'm using visual studio 22
33:11 - and also over here you've got a bunch of
33:13 - extra options now if you want to play
33:14 - around with reading the source code for
33:16 - the very CNT packages then you can tick
33:18 - on these boxes but in our case for this
33:19 - simple game we don't need that so go
33:21 - ahead and leave everything just like
33:23 - this with defaults okay so with this
33:24 - setup now we can go over here into
33:26 - assets and open up the c-sharp project
33:28 - and this should open up visual studio
33:29 - and alright so here it is now for some
33:32 - more settings inside of here in my
33:33 - visual studio I have a really nice
33:35 - extension that adds a bit more colors to
33:37 - my code which makes it easier to read
33:39 - and write so up top let's go into the
33:40 - extensions menu and manage extensions
33:42 - and the important one that I've
33:44 - installed is this one vs4 if you want
33:45 - you can go into the online Tab and over
33:47 - here search for it any Apple that show
33:49 - up in here then for the settings on that
33:51 - extension let's go up here into tools
33:53 - and let's open up the options then over
33:55 - here let's scroll down and find vs4 Yep
33:57 - this one and here are all the settings
33:59 - and expand this and a bunch more
34:00 - settings now for me I think these are on
34:02 - the defaults I don't remember if I
34:04 - changed anything the important one is
34:05 - over here the rainbow braces so these
34:08 - have a bunch of Commerce which make it a
34:10 - bit easier to read the code so let's
34:12 - create a simple script just to see this
34:13 - so back in until let's go into the
34:15 - project window let's click the plus icon
34:17 - and let's create the brand new c-sharp
34:19 - script let's call it just testing wait
34:21 - for it to compile and now let's open now
34:23 - over here I'm just going to write a
34:24 - bunch of simple code just to test it out
34:26 - you don't have to follow this alright so
34:28 - here's a bunch of sample code these are
34:30 - the colors you can see it makes
34:31 - everything a bit easier to read although
34:33 - again this is not a requirement you
34:35 - don't absolutely need this extension but
34:36 - personally I do find it quite useful I
34:38 - find that it helps make the code more
34:39 - readable than having everything be gray
34:41 - okay so that's the setup for this
34:43 - extension next for the text formatting
34:45 - options so once again let's go into two
34:47 - holes go into options and then over here
34:49 - let's go into the text editor then over
34:51 - here I think I've got pretty much all
34:52 - the same defaults then we can go into
34:54 - the c-sharp rules so here are all the
34:57 - settings if you notice something
34:58 - different on your end go ahead and pause
35:00 - the video and compare the settings but
35:01 - again I think everything here is pretty
35:03 - much defaults I believe the only
35:04 - difference that I did was over here on
35:06 - the code style over here for new lines
35:08 - personally I like to have the currently
35:10 - brackets on the same line but if you
35:12 - want you can also change it and put it
35:13 - on the second leg I think that's pretty
35:15 - much the only difference that I did
35:16 - everything else should be exactly the
35:17 - same as defaults so that's the code
35:19 - sound settings and speaking of that the
35:21 - next lecture is very important we're
35:22 - going to talk a bit about naming rules
35:24 - although just before we go let's just
35:26 - clean up our testing script so let's
35:28 - close this one click on the X then back
35:30 - into Unity we don't need the script so
35:32 - let's just delete it okay so with that
35:33 - we have Visual Studio setup and ready to
35:35 - go now let's continue in the next
35:37 - lecture to learn about some naming rules
35:40 - hello and welcome I'm your code monkey
35:42 - in this lecture we're going to learn
35:43 - something extremely important let's
35:45 - learn about naming world this one is a
35:47 - very important lecture that you should
35:48 - definitely refer back to whenever you
35:50 - have some questions so first what
35:52 - exactly are naming rules these are
35:54 - really just rules you follow when
35:55 - writing your code it is extremely
35:57 - important that you are consistent in
35:58 - applying your own rules you don't want
36:00 - one class in your game to be written a
36:02 - certain way and then a different class
36:04 - using a completely different style that
36:06 - would create tons of confusion so naming
36:08 - rules and writing the code correctly is
36:10 - very very important one mistake that I
36:12 - see a lot of beginners do is they send
36:14 - me some code and ask why it's not
36:15 - working then I take a quick look and I
36:17 - see that all of the code is written in a
36:19 - very messy way some functions are on
36:21 - lowercase others using snake case some
36:23 - films are in personal case some in camel
36:25 - case and so on remember that code is
36:27 - case sensitive so it is extremely
36:29 - important that you write the code
36:30 - correctly if you change a character from
36:32 - lowercase to uppercase then you are
36:34 - suddenly referring to something
36:35 - completely different if you're a
36:36 - beginner keep that always in your mind
36:38 - code is case sensitive so don't just
36:40 - write code semi-randomly write it
36:42 - properly as if you were doing an English
36:44 - literature test now with that said when
36:46 - it comes to naming roles you can use
36:48 - whatever name neurons you want different
36:49 - people like different rules for example
36:51 - you can use a prefix in your variables
36:53 - you can use a postpick you can use
36:55 - capitals for consonants chemical case
36:57 - for properties snake case for Fields by
36:59 - the way here are the definitions of what
37:00 - those terms actually mean Pascal K
37:02 - starts with a capital and every word is
37:04 - capitalized camel case starts lowercase
37:06 - and then uppercase for the first
37:08 - selector of every other word kind of
37:10 - like a camel hump in the middle and
37:11 - snake Haze is where you add an
37:13 - underscore in between the words I send
37:15 - every rule can be valid the important
37:17 - thing is that you are consistent in
37:18 - always following through with your rules
37:20 - as you might know Unity mono behaviors
37:21 - have some deformed functions you can
37:23 - Implement things like start and update
37:25 - which are written using pastel case
37:27 - since you can't really change in these
37:28 - rules at least on function names I would
37:30 - say you should base your rules off of
37:32 - theirs so for functions you should
37:33 - probably be using Pascal case for the
37:35 - rules like I said choose whatever makes
37:37 - sense to you here are some of my own
37:39 - personal rooms that have developed
37:39 - jumped over the last 10 years and the
37:41 - code sound that I won't be following in
37:43 - this course for functions I use Pascal
37:45 - case just like unity and just like the
37:47 - c-sharp standard for function parameters
37:49 - I use camel case for Fields also camel
37:52 - case properties are in personal case
37:54 - constants are in uppercase snake case
37:56 - then another rule is that I like to add
37:58 - the top of the variable as a postfix so
38:01 - if it's a list type in the list if it's
38:02 - an array open array and now you might be
38:04 - thinking with this wouldn't it be an
38:06 - issue if we change the type then the
38:07 - name is suddenly wrong and the simple
38:09 - solution for that is that if I change
38:10 - the type then I just use Visual Studio
38:12 - to quickly change the name that's it
38:14 - then for the currently brackets like I
38:16 - mentioned in previous lecture I like
38:17 - them on the same line some people have
38:19 - some very strong opinions about this
38:20 - really it's just a visual style and this
38:22 - is the one that I personally prefer if
38:24 - you like new online then go ahead and
38:25 - use that it doesn't change how the code
38:27 - Works in any way in a final rule spend
38:29 - some time deciding on a proper name and
38:31 - don't be afraid to rename things you
38:33 - will note how all the code that we're
38:34 - going to write in this course has proper
38:36 - names for everything you should never
38:37 - use a variable with a single letter like
38:39 - X X or k the exception of course would
38:41 - be iterated in a for Loop also don't use
38:44 - acronyms or abbreviations those might
38:46 - seem player right now but in a few weeks
38:48 - you might not remember what they mean
38:49 - remember you don't get bonus points for
38:51 - writing extremely compact code so
38:53 - prioritize making your code readable and
38:55 - understandable even if it requires
38:57 - variables and functions with long names
38:59 - so these are my general rules and the
39:01 - code style that I personally follow
39:02 - figure out what works for you and follow
39:04 - your own naming rules but naturally in
39:06 - this course I will be using my own code
39:07 - cell so if when following the course you
39:09 - are not sure how to write some type of
39:11 - code you can refer back to this lecture
39:13 - and watch it again like I've mentioned
39:14 - many times the code that I won't teach
39:15 - you how to write in this course is on
39:17 - the exact same level of quality as my
39:18 - paid courses and my Steam games so as
39:20 - such because that this lecture these
39:22 - naming rules are all extremely important
39:24 - okay so with this very important lecture
39:26 - out of the way now let's start playing
39:27 - with some visuals by importing some
39:29 - Assets in the next lecture hello and
39:32 - welcome I'm your code monkey in this
39:34 - lecture we're going to import the
39:35 - project files with all the assets that
39:36 - we're going to use by the way remember
39:38 - that if you have any questions go ahead
39:39 - and post them in the comments I go
39:41 - through those every day and I'll do my
39:42 - best to help okay so with the project
39:44 - created the next thing we want is to
39:46 - import the assets that we're going to
39:47 - use to make this game you can download
39:49 - all of the assets with the link in the
39:50 - description which by the way like I
39:52 - mentioned a while ago that link contains
39:53 - a Unity package that contains both the
39:55 - assets and the final game so when you
39:57 - download that you get ENT package just
39:59 - go ahead and double click or click and
40:01 - drag and drop it on the projects window
40:02 - here is the asset import window just
40:04 - make sure you select all and let's
40:06 - import okay so here it is let's import
40:08 - the assets folder and inside comes all
40:10 - of the assets meshes textures and so on
40:12 - so everything we're going to need and
40:14 - then it also imported inside of it
40:16 - another ENT package so if you want to
40:18 - import the final project with all of the
40:20 - code already written it's also here if
40:22 - you extract this one you're going to get
40:24 - the complete project files now of course
40:26 - don't do that if you want to follow
40:27 - along with the course and be aware that
40:29 - if you're following along and you
40:30 - accidentally end unpack this one it will
40:32 - override all of your own files so if you
40:34 - want to inspect the final project files
40:36 - go ahead and do that but do that in a
40:37 - separate project in order to make sure
40:39 - that we have no accidents I'm going to
40:41 - delete this one from the current project
40:42 - so just go ahead and delete okay so
40:45 - that's it and over here we've got all of
40:46 - our really nice visuals we can look in
40:49 - the prefabs visuals and over here we've
40:50 - got a visual for a container Sergo
40:53 - that's a container counter then we have
40:55 - a cutting counter we've got a trash bin
40:57 - then on the kitchen object visuals we've
41:00 - got all the visuals so a block of cheese
41:01 - we've got some burned meat we've got a
41:03 - plate and so on these are all the nice
41:05 - 3D models that we're going to use in our
41:07 - game and then over here on the textures
41:09 - folder we also got a bunch of General
41:11 - icons as well as actual icons for all of
41:13 - the various parts okay so all of the
41:15 - assets have been important now let's
41:17 - continue on to the next lecture
41:19 - hello and welcome I'm your code monkey
41:21 - in this lecture we're going to set up
41:23 - post processing now here let me make a
41:25 - quick note usually when making your
41:27 - games you probably don't want to hand on
41:29 - post-processing right way you should
41:30 - first get an ugly prototype up and
41:32 - working before worrying about any
41:34 - visuals so normally I would only add
41:36 - post-processing much later on in the dev
41:38 - process but since this is a course in
41:40 - video format in order for the video to
41:42 - look a bit more appealing let's set a
41:43 - post processing right away now we
41:45 - already have the project set up to use
41:46 - urp so adding post-processing is
41:48 - actually super simple it's actually
41:50 - already added by default first before we
41:52 - do that let's rename our scene with a
41:54 - proper name so inside the scenes folder
41:55 - it starts off with sample scene this
41:57 - will be our main game scene so let's
41:58 - just rename this to game scene okay and
42:01 - now here on the hierarchy we can see by
42:03 - default this scene already contains a
42:05 - global volume game object this is how
42:07 - you actually add post-processing and by
42:09 - default you can see that it also already
42:10 - has a sample and profile attached this
42:13 - is how you add all of the various
42:14 - effects you can click on this link and
42:16 - it will show it over here on the project
42:17 - window now let's film this from scratch
42:19 - instead of starting from this one so
42:20 - let's go into that file into that asset
42:22 - and just delete it okay so now we have
42:24 - no value profile now let's go ahead and
42:26 - click on new to create a brand new one
42:28 - okay so now here we can add overrides
42:30 - add all of the effects that we want
42:31 - let's drag some visual meshes that we
42:33 - imported in the last lecture to get a
42:35 - better look at all these effects and
42:36 - what they do so first let's make some
42:38 - kind of more so let's make a 3D object
42:40 - let's make it a plane let's name this D4
42:42 - also one extremely important thing
42:44 - whenever you create a brand new object
42:46 - always check the object's transform
42:47 - position by default when you create an
42:49 - object it appears in front of the scene
42:51 - camera which will probably not be on
42:53 - zero zero zero you always want to be
42:55 - very careful with the position of your
42:56 - actual objects so for a plane we do want
42:58 - this to be on the origin so on zero zero
43:01 - zero so make sure you always do that
43:02 - then let's scale it up a bit so on the
43:04 - scale let's put it on 555 which by the
43:06 - way you've got this nice little icon
43:08 - this was added in a recent Indie version
43:10 - basically if you enable this and matches
43:12 - all of these values so if you just
43:13 - change one of them it changes all of
43:14 - them so let's put this on Five okay
43:16 - great now for the visual let's go ahead
43:18 - into the mesh render on the materials
43:19 - and let's select the brand new material
43:21 - so let's click on the circle icon and
43:23 - over here let's find the floor material
43:24 - so here it is it's the one included in
43:26 - the assets there you go we've got a nice
43:28 - basic form material now let's also drag
43:30 - the player visual so let's go inside the
43:32 - assets folder and over here let's go
43:33 - inside the prefabs visuals and down here
43:35 - we find the player visual so let's just
43:37 - go ahead and drag this one so there it
43:39 - is a nice player visual let's also drag
43:41 - a counter so let's find let's say the
43:43 - Clear counter let's drag this one let's
43:45 - rotate it to face the camera something
43:47 - like this and let's also put a cutting
43:49 - counter again we're just placing some
43:50 - visuals just so we can see what the post
43:52 - processing will do and let's also place
43:54 - a bunch more things so let's say a
43:55 - tomato let's place a tomato over there
43:57 - and maybe cabbage all the way over here
43:59 - okay so we've got a handful of nice
44:01 - visual elements so we can test out our
44:03 - post pressing by the way here's a quick
44:04 - empty tip on scene controls whenever you
44:06 - are on the scene view which make sure
44:08 - you're on scene View and not game view
44:09 - those are different so on the scene view
44:10 - you can move the camera with a mouse you
44:12 - can pan with mouse 3 so the middle Mouse
44:14 - button so hold that and pan around we
44:16 - can rotate with the right Mouse button
44:18 - you can rotate around Point by holding
44:20 - down left alt and left click and just
44:22 - drag it around to rotate around an
44:24 - object you can select an object like for
44:26 - example player visual then you can press
44:27 - on F to select that object and now if
44:29 - you hold alt and click it will rotate
44:31 - around that object also another method
44:33 - is you can hold the right Mouse button
44:34 - to move it around and then you can use
44:36 - was to move so d a and so on then you
44:39 - can even press shift to move in faster
44:41 - and you can use the scroll wheel while
44:43 - holding down the right Mouse button or
44:44 - to modify the speed at which you move so
44:46 - there are plenty of camera controls to
44:48 - really get you seeing exactly what you
44:50 - want to see now for another quick empty
44:52 - tip you can move the scene camera to
44:53 - where you want the game camera to be so
44:55 - let's say I want the game camera to see
44:56 - things from about this angle so you just
44:58 - position the scene camera then on the
45:00 - hierarchy select the camera game object
45:02 - so the main camera right here and with
45:03 - that object selected you press Ctrl
45:05 - shift and F and if there you go you can
45:07 - see over here on the camera preview let
45:09 - it position the main camera looking on
45:10 - the exact same position at the exact
45:12 - same direction as the scene camera set
45:14 - the shortcut Ctrl shift F or
45:15 - alternatively go up into game object and
45:17 - over here on line with view now if you
45:19 - look here is the scene View and over
45:20 - here we've got a nice camera view so
45:22 - just position the camera somewhere where
45:24 - we can view all of the Assets Now with
45:26 - this let's add some post processing
45:27 - effects so first let's select the global
45:29 - volume game object and over here we can
45:31 - add all of our effect overrides first up
45:33 - let's begin by adding tone mapping so
45:35 - there you go we've got the effect and
45:37 - over here we've got a nice little
45:38 - checkbox so you can enable it in order
45:40 - to enable this effect and set one of the
45:42 - options now for this one I'm not too
45:43 - familiar with color correction but I
45:45 - find that usually adding a neutral tone
45:47 - map usually that helps also make sure
45:48 - you're looking at the game View and not
45:50 - the scene view if you're looking in the
45:52 - game View and you enable and disable
45:53 - this effect you should see a difference
45:54 - whereas on the scene view if you enable
45:56 - and disable it doesn't actually show
45:57 - that even if you're on the scene view
45:59 - over here you have all the effects
46:00 - enabled even with that some effects for
46:02 - some reason don't show up on the scene
46:04 - view so when playing around these
46:05 - effects almost make sure you're
46:06 - unlocking through the game view so like
46:08 - I said you should be able to toggle this
46:09 - and see a visual difference on the game
46:11 - view if you don't then make sure the
46:13 - camera has post processing enabled so
46:14 - let's select the main camera game object
46:16 - and down here there's a tongue for post
46:17 - Crossing make sure this one is enabled
46:19 - and then also on the render pipeline
46:21 - assets so let's find that one on the
46:23 - project window over here we've got the
46:24 - settings and we've got the urp High
46:26 - Fidelity this one should be using a
46:27 - renderer so if you click on the renderer
46:29 - over here you should have post-rossing
46:31 - enabled again all of this should already
46:33 - be correctly set up by default so if
46:35 - you're going to take a global volume
46:36 - enable our disabled you should see a
46:37 - visual difference okay so next Effect
46:39 - one that I always like to add is a bit
46:41 - of saturation so let's add an override
46:43 - post processing and let's add a brand
46:45 - new here it is color adjustments then
46:48 - over here you've got plenty of things to
46:49 - play around with for me I like to add a
46:51 - bit of saturation so just lift it up a
46:53 - little bit let's say just about 20 and I
46:55 - also like to add a little bit of
46:56 - contrast over here and let's also add
46:58 - 20. and there you go it makes the colors
47:00 - pop a little bit more so personally I
47:02 - don't like this effect then later on
47:03 - we're going to have some glowing objects
47:05 - for example the stove let's actually try
47:07 - dragging that into the scene so let's go
47:09 - into scene View and in the assets let's
47:11 - find the stove counter so here it is and
47:13 - inside the stove counter there are some
47:16 - things so here it is the stove on visual
47:18 - this one is disabled by default also on
47:20 - the inspector let's just enable on this
47:21 - game object to make it visible again
47:22 - don't worry about the positioning of the
47:24 - objects on the scene view right now
47:25 - we're only positioning them just to set
47:27 - up the post pressing we're going to
47:28 - delete them all at the end of this
47:29 - lecture okay so now in enable let's go
47:31 - into the game View and over here we see
47:33 - the stove enabled so now let's go into
47:35 - the local volume let's add an override
47:36 - go into post pressing let's add a volume
47:38 - effect so right now notice how that one
47:40 - is not glowing red hot for that work we
47:42 - need to have Bloom and we need to enable
47:44 - the threshold and the intensity if we
47:46 - raise the intensity we do see yep there
47:48 - we go a really nice low there by the way
47:49 - here's a quick visual attempt if you
47:51 - want to make your game feel a bit more
47:52 - ethereal and magical one good way is to
47:54 - put the threshold that on low value
47:56 - below one so something like 0.5 and then
47:58 - put the intensity as a little bit and
48:00 - with this notice how everything has a
48:02 - slight low even colors that don't have
48:03 - any extra intensity so the floor is
48:05 - glowing the character is going so
48:06 - everything looks quite a bit ethereum
48:08 - this is a bit extreme but it is an
48:09 - interesting effect also another quick
48:11 - note here in case you're not seeing
48:12 - anything change make sure you go into
48:14 - the render prop online assets so the urp
48:16 - High Fidelity and over here make sure
48:17 - AGR is enabled you can look at so low if
48:20 - I disable it yep that one stops glowing
48:22 - and with that enabled it does start
48:23 - glowing AGR stands for high dynamic
48:25 - range so that is how you can have a
48:27 - color go with an intensity above one
48:29 - which actually makes it low when you
48:30 - have the balloon post pressing if even
48:32 - with that you're still seeing issues
48:33 - then make sure you go into the renderer
48:34 - and over here for the post processing
48:36 - sometimes Unity has a weird bug and
48:38 - doesn't generate this post-process data
48:39 - file so if that does happen just go
48:41 - ahead untoggle and toggle this and it
48:43 - should work and finally like I said on
48:45 - the camera make sure you have post
48:46 - Crossing in Arrow so with all that you
48:48 - should be able to see the game view glow
48:49 - okay back into our effects with our
48:51 - balloon working like I said you can
48:52 - lower this below one to get a nice
48:54 - ethereum look but this is a bit too
48:56 - intensive on what we want so let's make
48:57 - it a bit more subtle so on the threshold
48:59 - let's put it at 0.95 so there's a slight
49:01 - low on the white Parts but nothing too
49:03 - intense and for intensity let's put it
49:05 - at a wrong number one okay so I think
49:06 - that's a nice amount of Bloom all the
49:08 - colors glow a little bit and we can see
49:10 - over there the stove it is indeed
49:11 - glowing okay great now if you ever
49:13 - forget all these steps and you can get
49:15 - your project to Glow I made a nice video
49:17 - with a nice checklist of everything
49:18 - needed for you low definitely go ahead
49:20 - and watch that video whenever you have
49:22 - issues then for another fun effect we
49:24 - have yet so let's go into ad override
49:26 - post Crossing and let's find the
49:27 - vignette what this one does is adds a
49:29 - bit of Darkness to the colors so if we
49:31 - enable the intensity and we increase it
49:33 - you can see what it does so it adds
49:34 - Darkness around the corners there
49:35 - personally I find this one looks good
49:37 - when it's quite a bit subtle so let's
49:38 - put the intensity at some like 0.25 and
49:41 - then for the smoothness let's also put
49:43 - it on 0.4 so just like that just a
49:45 - slight Darkness on the edges so
49:46 - personally I think it looks pretty good
49:48 - and that's pretty much it for the Post
49:50 - Crossing on the volume component I like
49:52 - how this looks you can see difference
49:53 - with the volume enabled or disabled
49:55 - quite a big difference looks pretty nice
49:56 - but again these are just visuals so feel
49:59 - free to play around maybe add some more
50:00 - effects using different settings these
50:03 - are just visuals they don't impact the
50:04 - game logic at all so feel free to make
50:06 - it work exactly as you wanted then yet
50:08 - another thing related to post processing
50:10 - but not in this component it's some
50:11 - anti-aliasing for that one place where
50:13 - you can change it is on the main camera
50:15 - over here you see a film for post
50:16 - Crossing and you have a bunch of types
50:18 - so fxa a or smaa or if you want some
50:21 - more higher end post processing you can
50:23 - go into the render prop online Essence
50:24 - so urp and hyphenoly and over here we
50:26 - see anti-analyzing msai this one is a
50:29 - bit more expensive but looks a bit
50:30 - better if you want to see difference you
50:32 - can go over here into the aim View and
50:34 - on the slider up top on the scale you
50:35 - can increase this quite a bit so with
50:37 - this we can now see the pixelation and
50:39 - you can see over here if I switch at the
50:40 - only thing from 4X back into the table
50:42 - you can see lots of jagged edges and if
50:45 - I put it on 2x Yep looks a bit more
50:46 - smooth 4X a bit more smooth and 8x even
50:49 - more smooth so with that you can see
50:51 - difference on all the edges on the
50:52 - things by default this renderer has on
50:54 - 4X and nothing on the camera this
50:56 - already unlocks pretty good but to make
50:57 - the video look even better I'm going to
50:59 - put it on 8X and on the main camera I'm
51:01 - also going to leave it with no
51:02 - anti-alency you can combine them but if
51:04 - you do then everything looks a bit too
51:05 - wiry so I don't quite like that effect
51:07 - so put this one on none and the other
51:09 - one on 8X although again this is just a
51:11 - visual so if you have a low end PC feel
51:13 - free to go into the urp and over here
51:16 - disable anti-alizing so the game looks a
51:18 - bit worse but it won't run much better
51:19 - okay let's drag the scale back down okay
51:22 - now one final thing we can add is some
51:25 - really nice screen space ambient
51:26 - conclusion for that let's go into the
51:28 - render so not the render pipeline asset
51:29 - the renderer and over here by default it
51:31 - already added screen space ambient
51:33 - Collision if it didn't add you can click
51:34 - on ADD render feature and over here you
51:36 - won't be able to see it I don't see it
51:37 - because I already have it okay so here
51:39 - it is basically what this effect does is
51:41 - it adds some tiny Shadows where geometry
51:43 - intersect if we enable and disable it
51:45 - quickly we can see the effect over there
51:47 - on the counters so you can see with
51:48 - default effects it already Works quite
51:50 - nicely for example look there on the
51:52 - player we can barely see the difference
51:54 - between the head and body but if we
51:55 - enable this it has that nice little
51:56 - Shadow I think it looks really nice but
51:58 - then we've got a bunch of settings we
52:00 - can play around increase the intensity
52:01 - the radius and so on Now One important
52:03 - thing when setting all these effects is
52:05 - to remember the point of view of the
52:06 - camera in this case we're making a
52:08 - top-down game so before we play around
52:10 - these settings let's actually position
52:11 - the camera in a correct position so
52:13 - let's go ahead select the main camera
52:15 - and let's position it above pointing
52:17 - down so let's put it on an X of 0 on a y
52:20 - of 21.5 on his head of minus 21.3 then
52:24 - for the rotation on the X 46 then 0 and
52:27 - 0. and finally on the camera over here
52:29 - on the field of view instead of 16
52:30 - that's really wine for this game let's
52:32 - go with 20. okay so this is the view
52:34 - that we're going to use for our game let
52:35 - me just rotate the object so they
52:37 - actually face the camera so on the
52:39 - hierarchy let's just select all the
52:41 - objects let's rotate them all around and
52:43 - just position them again we're only
52:45 - using these just to see what they look
52:47 - like we're going to delete all of these
52:48 - objects in a bit okay so yep that's the
52:50 - game view now that we have the camera
52:52 - set up let's work on the settings for
52:54 - the eminent conclusion so let's go down
52:55 - select the renderer and over here for
52:57 - the settings for the intensity and let's
52:59 - put it on four for the radiance let's
53:01 - put it at 0.3 and direct lighting
53:02 - strength let's put it all the way up to
53:04 - one okay so you can toggle this enable
53:06 - and disable to see difference and yep I
53:08 - do think these settings look pretty good
53:09 - finally the last thing we need to check
53:11 - is in lightning window so let's go into
53:13 - window then down into rendering and
53:14 - let's go into lighting how it pops up
53:16 - the unlighting window personally I like
53:18 - to Anchor it over there next thing
53:19 - inspector and over here we're really
53:20 - going to leave everything on defaults so
53:22 - you can leave it as the lighting
53:24 - settings assets and nothing assigned and
53:26 - then on the environment tab over here
53:28 - again all of the defaults I didn't touch
53:29 - any of these so we've got environment
53:31 - lighting from the Skybox and then some
53:32 - multiplier of one so everything pretty
53:34 - much on defaults although again like I
53:36 - said most of these visual effects are
53:37 - very much personal preference so if you
53:39 - want to make your game look a bit
53:40 - different than mine then go ahead you
53:42 - can play around with lighting over here
53:44 - you can change Skybox gradient color and
53:46 - so on if you want you can use some bake
53:48 - lighting then if you want you can add
53:49 - all kinds of extra effects and also by
53:51 - the way remember that the effects are
53:53 - stored on this profile over here so for
53:55 - example you can click over here on the
53:56 - Clone button and it will include the
53:58 - effects and let's click on it to find it
53:59 - yep there you go so that's the one that
54:01 - I've built and here's a clone one so if
54:02 - you want you can make a clone one and
54:04 - then make it look very different for
54:05 - example let's go into chromatic
54:06 - aberration make it really intense and
54:09 - for example let's go into the counter
54:11 - curves and over here for some reason
54:12 - let's drag the green up and so on so
54:14 - there you go completely different visual
54:16 - so if you want to play around make some
54:17 - weird effects and if you want to go back
54:19 - to just revert back into the original
54:20 - profile personally I'm quite happy with
54:22 - how this looks so I'm going to be using
54:23 - this one okay again you can enable and
54:25 - disable the volume game object to see
54:27 - quite the big difference that
54:28 - post-processing makes if you ever want
54:30 - to make your game look quite a lot
54:31 - better always make sure that some post
54:33 - processing alright so like I said this
54:34 - looks really good I like it now before
54:36 - we go to the next lecture let's just
54:38 - clean this up so let's get rid of all of
54:40 - these objects so the counter cabbage
54:41 - tomato and so on let's get rid of all of
54:43 - them except the four so let's leave the
54:44 - four and get rid of all these alright so
54:46 - here we have our nice empty scene let's
54:48 - just save our scene and let's get ready
54:50 - for the next lecture
54:52 - hi there this is a quick intermission so
54:55 - how are you doing are you enjoying the
54:57 - course so far are you having any trouble
54:58 - with anything is there something you
55:00 - didn't understand if so remember I'm
55:02 - always active in the comments answering
55:04 - all the questions so if there's anything
55:05 - you need some extra clarification go
55:07 - ahead and ask and I'll do my best to
55:09 - help also remember to check out the pin
55:11 - comment YouTube videos cannot be updated
55:14 - so for any notes or comments I'll put
55:16 - them in the pin comment and definitely
55:18 - check out the website page for this
55:19 - course as people ask more and more
55:21 - questions I will keep that page updated
55:23 - with any frequently asked questions for
55:25 - every single lecture so that way you can
55:26 - see what others have asked and learn
55:28 - from them and you can also download the
55:30 - project files for each lecture so keep
55:32 - that page open on a second Tab and check
55:34 - it every time you start watching a new
55:36 - lecture I really hope you're enjoying
55:38 - the course and I hope you've already
55:39 - learned quite a few things go ahead and
55:41 - hit the like button and subscribe to the
55:43 - channel if you haven't already
55:44 - okay so let's go to the next lecture
55:47 - hello and welcome I'm your kudmaki in
55:50 - this lecture we're going to begin
55:51 - creating our character let's make a nice
55:53 - character controller so we can move our
55:55 - character in the world
55:56 - okay so first let's begin by creating
55:58 - the character game object
56:00 - and now usually most beginner tutorials
56:02 - will tell you to just right click go
56:04 - into 3D object and create something like
56:06 - a capsule that way you would have the
56:09 - game object with the visual included
56:11 - however for a good project structure and
56:14 - good organization you should only
56:15 - separate the visuals from the logic for
56:18 - example here in let's say that I don't
56:19 - want my capsule exam like this let's say
56:21 - that I want my player to be a little bit
56:23 - more skinny to do that I would have to
56:25 - modify on the scale on this game object
56:27 - so put it maybe on 0.7.7 so something
56:30 - like this basically by doing that by
56:32 - modifying the visual I also modified the
56:34 - scale on the actual player game object
56:36 - having a non-uniform scale on a logic
56:38 - game object that can cause all kind of
56:40 - problems with any kind of logic
56:42 - component also I would prefer to have my
56:44 - character on the floor but if I put it
56:46 - on yf0 notice how the character is half
56:48 - underneath the floor so if I were to use
56:50 - this method I would have to apply some
56:52 - kind of offset in order to make the
56:53 - visual above the floor so that would
56:55 - require rearranging all the logic to
56:57 - work with an offset on the Y position so
57:00 - because of those reasons and many more
57:01 - you should not Place both the logic and
57:03 - the visual on the same game object
57:05 - instead you should separate them so
57:07 - let's get rid of this and instead let's
57:09 - create an empty game object let's name
57:11 - this the player
57:13 - let's put it on zero zero zero okay and
57:16 - now inside of it now inside let's create
57:19 - let's say a capsule now in this one we
57:21 - can easily scale this to get any size
57:23 - and shape you want so for example 0.7.7
57:25 - then since the visual is a child of the
57:28 - game object we can also easily offset
57:30 - this so let's say you put it up by about
57:31 - one unit so with this we can position
57:34 - the visual so that basically the player
57:36 - game object is over here on zero zero
57:37 - and the character is above the floor so
57:39 - we don't have any weird offsets this
57:41 - will make all of our logic much more
57:43 - simplified
57:44 - and on this empty Parent Game object we
57:46 - can attach all of the logic components
57:48 - we want and then in the child visual we
57:51 - can either replace whatever visuals we
57:52 - want so as a general rule you should
57:55 - always try to do this only separate the
57:57 - logic from the Visions in your game
57:58 - objects
57:59 - okay so with that we have the player
58:01 - game object now let's make our character
58:03 - controller script
58:04 - and before we do let's keep things once
58:06 - again organized so before we do let's
58:09 - create a brand new folder so let's right
58:10 - click on the assets create a brand new
58:12 - folder call it scripts and now inside
58:15 - let's right click and create new c-sharp
58:17 - script called the player wait for the
58:19 - code to compound then select the player
58:21 - game object and attach the script again
58:23 - remember logic components go on the
58:25 - parent game object not the channel
58:26 - vision so the challenge visual this one
58:28 - only has visual components and the
58:30 - player this is the one that actually has
58:31 - the logic components so let's open up
58:33 - this script
58:34 - okay so here's our first c-sharp script
58:37 - like I said I'm going to assume you know
58:39 - the absolute Basics go watch the c-sharp
58:41 - basics video If you haven't seen it yet
58:43 - so I won't assume that you know what is
58:45 - a function what is a variable what is
58:47 - start and update so pretty much the
58:48 - absolute basics for a character
58:50 - controller we first need some input from
58:52 - the player and for that EMT actually has
58:55 - two methods you have the Legacy input
58:57 - manager and the new input system
58:58 - basically the Legacy input manager is
59:01 - super simple and very easy to use so
59:02 - this one is perfect for quickly
59:04 - prototyping and the new input system is
59:06 - extremely capable with tons of features
59:08 - but it's also a bit more complex so what
59:10 - I do is while I'm doing a simple demo or
59:12 - testing out a new prototype by just
59:14 - using Legacy input manager but when
59:16 - making a more complex project like for
59:18 - example my sim game then at a certain
59:19 - point I refactor my code to use the new
59:21 - input system so here I'm going to teach
59:23 - you both as well as teaching you how to
59:25 - refactor code which is an extremely
59:26 - useful skill so let's first begin by
59:28 - using the Simpson Legacy input manager
59:31 - we want some basic was movement to move
59:33 - our character and we're going to need to
59:35 - run that logic on every single frame so
59:37 - let's do it on update and let's actually
59:39 - get rid of the code that Unity writes by
59:41 - default let's start coming from scratch
59:43 - and let's get rid of this just close
59:45 - okay so here let's start by writing
59:47 - private void update and now here very
59:49 - important if you're a beginner make sure
59:51 - that update is written exactly like this
59:53 - if you write update with lowercase if
59:55 - you do this then it won't work the
59:57 - function will not be calmed
59:58 - automatically I'm pointing this out
60:00 - because I have seen a bunch of comments
60:01 - from beginners wondering why their code
60:03 - doesn't work and it's as simple as this
60:04 - with a lowercase Unity will not call
60:06 - this automatically it needs to be
60:08 - exactly perfect so again if you're a
60:10 - beginner make sure you write the code
60:11 - exactly the code is case sensitive so
60:13 - this is very important
60:14 - also another note you saw that the code
60:16 - that Unity wrote by default when we made
60:18 - a new script it just had void update it
60:21 - did not have the private keyword private
60:23 - is what is called an accessor you have
60:25 - private then you have public and then
60:27 - there are some more advanced ones
60:29 - secondly you can omit the accessor and
60:32 - in most cases it will default to private
60:33 - however in writing good clean code you
60:36 - should be as explicit as possible there
60:38 - should be no room for misunderstandings
60:40 - so while technically you could emit the
60:42 - private you should always include it to
60:44 - make your code easy to read and easy to
60:46 - understand
60:47 - this one is the first of many clean code
60:49 - rules that I will teach you during this
60:51 - course like I said all of the code that
60:53 - I'm writing here is on the same level of
60:54 - quality that I use in my own
60:55 - professional games I'm not going to
60:57 - teach you bad practices like so many
60:59 - beginner tutorials do so always be
61:01 - explicit always include the accessor
61:03 - okay so we have our update Running code
61:05 - on every single frame then to test if a
61:08 - key is being pressed we just go inside
61:09 - input then over here we've got two
61:12 - functions so we have get key and get key
61:14 - down
61:15 - both these functions were turning Boeing
61:17 - so that's how the true or false the
61:19 - difference between them is that get key
61:21 - down this one only returns true for a
61:23 - single frame when the key is pressed
61:24 - whereas get key this one stays true for
61:27 - as long as the key is held down for
61:28 - example for an action like jumping you
61:30 - just want to know when the player
61:31 - presses the button so for that one you
61:34 - would use get key down however in our
61:36 - case for a character controller we want
61:37 - to know if the key is being held down we
61:39 - don't want just one frame but always
61:42 - so for movement let's make sure we go
61:44 - with get game
61:45 - then requires a key so let's write our
61:47 - key code and then choose the key let's
61:49 - say we want w
61:50 - and then let's just put this inside and
61:52 - if just like this okay so here we have
61:55 - code we want to run while holding down
61:57 - the down key let's do a quick test just
61:59 - to verify everything is working
62:00 - perfectly and for testing we can use a
62:02 - super useful debug.log this one lets us
62:05 - print a message in the console someone
62:07 - said One log here just say something
62:09 - like pressing and then let's also do an
62:11 - else and if else let's do a debug.log
62:14 - and just do a dash okay so here is our
62:16 - very basic script let's make sure to
62:18 - save it so Ctrl s then back in unity
62:21 - over here make sure you have the script
62:23 - attached to the player game object and
62:25 - now we can test and now down here on the
62:28 - console we can already see dashes so I'm
62:29 - not pressing anything also like I
62:32 - mentioned in the setup lecture if you're
62:33 - seeing just one message then maybe that
62:35 - means you have over here the collapse
62:36 - Target if you talk on it and look how it
62:38 - only shows one message but then over
62:40 - here on the right side it says the
62:41 - number of messages personally I prefer
62:43 - to always keep it untoggle so I can see
62:45 - every single message also over here on
62:47 - the right make sure you have info
62:49 - messages visible if you untangle this
62:51 - and you don't see it so make sure this
62:53 - one and actually both of them make sure
62:54 - all of them are enabled okay so we're
62:56 - seeing a whole bunch of dashes and one
62:58 - more note if over here these chromebars
63:00 - stop scrolling so right now you can see
63:01 - it's stuck up instead of being down
63:03 - there so if that happens one is easy way
63:05 - to reset that is just click over here on
63:07 - clear and it goes back into AutoZone
63:08 - okay so we have the dashes I am not
63:11 - pressing anything now as I press yep
63:13 - there you go there's a message if you
63:15 - don't see it make sure the game window
63:16 - is in focus
63:17 - so selective game View and click right
63:19 - here on the middle to make this one the
63:21 - focused window then if you press the
63:23 - down key you should see the message and
63:24 - if I Let Go yep there it is and I stash
63:26 - okay great so all the basic logic is
63:28 - working back in the code here now that
63:31 - logic is working let's get rid of the
63:32 - else here
63:34 - and let's set this for all the other
63:36 - keys so let's copy paste this so we're
63:38 - going to need w a s and D so let's make
63:41 - all of these
63:44 - okay so we have our inputs let's also
63:46 - get rid of the logs we don't need this
63:49 - all right so we have all of our key
63:50 - presses now let's construct a vector
63:52 - with our inputs and since we're just
63:55 - going to have two axes
63:56 - the double s that is forward and
63:58 - backwards and this one is left and right
63:59 - so just two axis
64:01 - so because we have just two let's use a
64:03 - vector two and let's call it the input
64:05 - vector
64:07 - let's construct it so we'll do a new one
64:09 - and start off at zero zero okay
64:12 - then over here the logic is pretty
64:13 - simple so when we press W then let's go
64:15 - into the input vector and set the Y to
64:17 - pause one
64:19 - then when we have an S we want to go
64:21 - backwards so put the Y on -1 for the a
64:23 - we want to go left so that's an x on the
64:26 - minus one and finally for the D that is
64:28 - an x on plus one okay so with this we
64:31 - have our correct input Vector let's do a
64:33 - quick log just to test so debug down log
64:35 - on the input vector
64:37 - okay so let's test all right so we can
64:39 - see in log zero zero okay makes sense
64:41 - now if I press W yep we've got an 1 on
64:44 - the Y if I press a we got minus one in
64:46 - the X press D plus one press s and minus
64:49 - one okay great so everything works
64:51 - except we also need to be careful about
64:53 - one other thing if I press both W and D
64:57 - with this look at that the vector is 1 1
64:59 - which is correct that's exactly what it
65:01 - is then except the factor one one
65:03 - actually has a bigger magnitude than
65:05 - just one vector if we leave it like this
65:07 - then the character will move faster when
65:08 - moving diagonally versus when moving in
65:10 - just one direction for our input Vector
65:12 - we really want it to be normalized
65:14 - meaning we wanted to have the same size
65:16 - regardless of the combination of keys
65:17 - that we're pressing so back in the code
65:19 - here after calculating the input vector
65:21 - and let's simply normalize it so we go
65:23 - into the input vector and we set it
65:25 - equals to input Vector Dot normalized
65:28 - so this will normalize our input Vector
65:30 - let's see and over here if I press
65:32 - doubly you've got one press s minus one
65:34 - okay so all those work now if I press
65:36 - both W and D if there go now it says
65:38 - 0.71 when you combine both these I need
65:41 - the math these do end up with a
65:43 - magnitude of one so with this our
65:45 - character will move at the same speed on
65:46 - both diagonals and straights okay so we
65:49 - have the input Vector on correct now
65:51 - let's actually apply some movement for
65:53 - that there are many ways of making a
65:54 - character controller for example you can
65:56 - decide to use physics or not over here I
65:58 - want to keep the game simple so let's
65:59 - not use physics instead let's just move
66:02 - the player transform directly over here
66:04 - we have our input Vector okay great now
66:06 - we want to apply this to our character
66:07 - position so first we access the
66:09 - transform
66:10 - this one refers to the transform where
66:12 - this script is attached to
66:14 - this script was attached to the player
66:16 - so this is going to refer to the player
66:18 - transform then we want to modify the
66:20 - position so let's access the position
66:21 - and now for moving we don't want to just
66:23 - assign it if we do something like this
66:28 - like this the player would never leave
66:29 - the center of the world he would always
66:31 - be near zero zero so instead we don't
66:33 - want to just assign it but instead we
66:35 - want to add onto it now if you're a
66:37 - complete beginner and you don't know
66:38 - this syntax then this one is exactly the
66:40 - same as this so transform dot position
66:43 - equals transform dot position plus input
66:46 - vector so both these little lines are
66:48 - doing the exact same thing personally I
66:50 - prefer to use the shorthand I find that
66:53 - equally readable and more compact okay
66:55 - so we have this and we add our input
66:57 - Vector to the transform position except
66:59 - we can also see a really nice error
67:01 - basically it's telling us that we are
67:03 - mixing two types our input is a vector
67:05 - two where we only have an X and Y but
67:08 - transform that position is a vector 3
67:10 - meaning it has an X Y and Z one simple
67:13 - solution is to cast our input Vector
67:15 - onto a vector three so we just convert
67:18 - this from one type into the other one
67:19 - and yep we don't have the error so let's
67:21 - test and now if I press W any of the
67:24 - character does move Let's ignore the
67:26 - massive speed for now so it does move it
67:28 - does seem slightly correct except you
67:31 - can obviously notice that it's not
67:32 - correct we are moving on the x-axis on
67:35 - left and right that is correct but then
67:36 - we are moving up and down instead of
67:37 - fourth and back basically we convert the
67:40 - effector 2 directly into a vector three
67:41 - so we are moving on the X and Y axes but
67:44 - in our 3D game we really don't want the
67:46 - characters to fly so instead we want to
67:48 - move on the XZ axis so back in code here
67:50 - instead of directly casting this down
67:52 - into a vector 3. let's construct a move
67:55 - to your vector similar to Vector three
67:57 - let's call it our move there for our
68:00 - move Direction and over here we
68:02 - construct a new vector3
68:04 - and basically we're just going to assign
68:05 - the input y to the Zenon here so first
68:08 - of all for the X7 is correct so input
68:09 - vector.x then for the Y let's leave this
68:12 - one on zero and finally let's use the
68:14 - input vector.y as I said on the Move
68:16 - direction also now at this point you
68:19 - might be questioning if we're using a
68:21 - vector 3 here why don't we also use a
68:23 - vector 3 appear and then just assign the
68:25 - Z directly that's certainly a
68:27 - possibility and for making a super quick
68:29 - prototype I might even do that myself
68:31 - but the proper answer to that is once
68:33 - again all about writing good clean code
68:35 - the input logically only has two axes
68:37 - there's no z-axis on your keyboard so
68:40 - logically it makes no sense for the
68:42 - input to have three axes and beyond that
68:45 - you should keep the logic separate so
68:46 - you should first get the input and then
68:48 - actually move the object we're going to
68:50 - see the benefit of that separation when
68:52 - we refactor this code to work with the
68:53 - new input system doing that will in turn
68:56 - make enabling Gamepad joystick support
68:58 - super easy because we have the input
69:00 - Vector separated from the actual
69:01 - movement some of that to say and let's
69:03 - do things properly let's keep the input
69:06 - Vector separate from the movement Vector
69:07 - so we just translate the X Y onto X end
69:10 - and then we just apply this into our
69:12 - transform position
69:14 - okay so let's test so now if I press the
69:17 - right turn left and press W and S and
69:19 - there you go okay great so it is indeed
69:21 - moving Left Right forward and back okay
69:23 - great so it is working but as you can
69:25 - see it's moving insanely fast you might
69:27 - think the issue here is just applying
69:29 - some sort of movement speed multiplier
69:30 - except there's actually one sneaky issue
69:33 - here on the game view on the top right
69:35 - corner we've got a stats button and over
69:37 - here we can see a whole bunch of things
69:38 - specifically we can look at the frame
69:40 - rate we can see that it's running at 144
69:43 - frames per second over here on the left
69:45 - side on this button I have vsync enabled
69:48 - this will cap the frame rate to the
69:50 - monitor's refresh rate so that is why
69:52 - I'm seeing 144 Hertz I can overhear
69:54 - disable vsync and the upload that goes
69:56 - all the way up to 700. basically now the
69:59 - game is running as fast as my computer
70:00 - can run it and if I press the movement
70:02 - keys and look at that now it's moving
70:04 - even faster
70:05 - now I've completely lost track of where
70:07 - my player is this is not what we want we
70:10 - don't want the player to move at
70:11 - different speeds depending on the frame
70:12 - rate we want it to always move at the
70:15 - same speed regardless of frame rate so
70:17 - when you do any kind of movement Logic
70:18 - on an update you always need to make
70:21 - sure to multiply by time dot Delta time
70:23 - what this variable contains is the
70:25 - number of seconds in Labs since the last
70:27 - frame for example let's unlock to this
70:29 - we no longer need the input Vector so
70:30 - let's unlock just the time that down to
70:32 - time okay so we can see there there's
70:35 - basically telling us how many seconds it
70:36 - is taking to render a single frame once
70:39 - again note how I have vsync enabled so
70:41 - I'm running at 144 frames per second and
70:43 - now if I disable it let's see what
70:45 - happens to that number so if I disable
70:46 - and you have a look at that that number
70:48 - is now much much smaller and the game is
70:49 - now running much much faster so by
70:52 - incorporating this value into our
70:53 - calculation we are going to be taking
70:55 - into account the frame rate
70:56 - thus making sure that movement is always
70:58 - frame rate independent right now with
71:00 - this frame rate if I move you can see
71:02 - I'm moving at this speed and now if I
71:04 - enable vsync change the frame rate and I
71:06 - move and I'm still moving at the exact
71:07 - same speed
71:08 - okay that's great except obviously it's
71:10 - not exactly great it's moving way too
71:12 - slow so let's also incorporate a
71:14 - movement speed now for this once again
71:16 - most beginner tutorials will teach you
71:17 - to go all the way up here and find a
71:19 - public float move speed
71:22 - maybe they found it to some villain like
71:24 - 7f something like that
71:26 - then you have this field and then down
71:28 - here you simply use it in the
71:30 - calculation so movement here move
71:32 - multiply it by move speed and by time
71:34 - dot time so this is what most tutorials
71:36 - will teach you by making it public up
71:39 - here what you're doing is you're
71:40 - enabling access from the editor so if
71:42 - you go over here in the editor over
71:43 - there on the player we can see the move
71:45 - speed variable we can see this exposed
71:47 - and we can modify it this makes it
71:49 - really easy for testing and for
71:50 - iterating upon the value even while the
71:52 - game is running
71:53 - so the game is playing I can move and I
71:55 - have this move speed now I can modify
71:57 - this and yep now I got a different move
71:59 - speed so I can use this to quickly to
72:00 - rate and find the perfect value
72:02 - so it's great to have this variable
72:04 - exposed in the editor and this feature
72:06 - is indeed the reason why most beginner
72:08 - tutorials will teach you to make it
72:09 - public it's so you can see it in the
72:11 - editor that is indeed a very valuable
72:13 - thing being able to easily iterate upon
72:15 - important values is always very useful
72:17 - however when you make something public
72:19 - when you do that you don't just expose
72:22 - the film to the editor you are exposing
72:24 - it to every other class in your entire
72:25 - code base so some other class could
72:28 - access this field and set the player's
72:30 - movement speed to something like zero
72:31 - and you would have no idea that was
72:33 - happening because the issue would not be
72:34 - on this code right here I have an entire
72:36 - video on this subject why you should not
72:39 - make everything public this is an
72:41 - extremely important topic to know about
72:42 - this one tiny change will massively
72:45 - improve the quality of your code
72:46 - definitely go ahead and watch that video
72:48 - to learn why such a bad thing and make
72:50 - sure you don't do it so to avoid all
72:52 - kinds of problems you should never make
72:54 - films public so very quickly the obvious
72:56 - alternative is make it private making it
72:59 - private means that only this class only
73:01 - the code in here only this can modify
73:03 - this film so you know for certain that
73:04 - no other class can ever modify this
73:06 - however making it private also means the
73:08 - editor cannot modify this film so we've
73:10 - lost our very useful iteration approach
73:13 - so what we can do to expose it just to
73:15 - the editor is to keep it private and
73:16 - then we add the attribute serialize
73:18 - field
73:19 - this way this field is still private
73:21 - meaning that it can only be modified by
73:23 - the code inside the player class but
73:26 - with this attribute over here in the
73:28 - editor yep we do have an editable field
73:30 - so only the code in that class in the
73:32 - editor can modify it nothing else can
73:34 - touch it nothing else can read or write
73:36 - which is exactly what we want one of the
73:38 - main rules in writing good clean code is
73:40 - minimizing complexity and one of the
73:42 - easier ways to minimize complexity is
73:43 - simply to minimize axis by making this
73:46 - feel private we are minimizing
73:48 - complexity because it doesn't matter how
73:49 - complex our game is maybe our code base
73:52 - is a thousand classes long it doesn't
73:53 - really matter because only this class
73:55 - can never touch this field so if we have
73:57 - a bug related movement speed we know for
73:59 - certain it has to be inside this code
74:01 - and nothing else so we minimize the
74:03 - things we need to keep in our head which
74:05 - is always a very good thing okay so with
74:07 - all that said we have our movement speed
74:08 - and down here we are incorporating it
74:10 - into our calculation just with this we
74:13 - have our character working with a
74:14 - variable movement speed and by using
74:16 - Delta time we have our movement
74:17 - correctly being frame rate independent
74:19 - so here's our character and using the
74:21 - keys I can walk around and yep the
74:23 - character moves in any direction so we
74:24 - have movement only working while using
74:26 - the Legacy input manager like I said
74:29 - we're going to learn how to refactor our
74:30 - code to use the new input system
74:31 - learning how to refactor is an extremely
74:34 - important skill to improve your own
74:35 - programming skills it is something that
74:37 - you should always do when necessary it
74:39 - will massively help you improve the
74:40 - quality of your code
74:42 - so we're going to do that but before we
74:44 - get to that let's actually do something
74:45 - a bit more fun and add some proper
74:47 - visuals and animations to our player in
74:49 - the next lecture
74:51 - hello and welcome I'm your code monkey
74:53 - in this lecture we're going to replace
74:54 - our boring capsule visual with a nice
74:57 - proper character mesh okay so in the
74:59 - included assets project files over here
75:01 - if we go inside the prefab visuals we
75:03 - see a nice player visual let's position
75:06 - it inside the player game object so
75:08 - let's drag it inside again because we
75:10 - separate the logic and visuals this is
75:12 - going to be pretty easy we don't need to
75:13 - modify the parent game object at all we
75:15 - just dropped the visualize this channel
75:17 - that's it also again very important make
75:19 - sure the visual is over here on low
75:20 - composition zero zero zero only the
75:22 - parent game object should move the
75:24 - visual itself should never move if you
75:25 - notice some weird positions as your
75:27 - player moves and rotates always check to
75:29 - make sure that the channel visual is on
75:31 - zero zero zero okay so with this let's
75:33 - delete the old capsule delete it okay so
75:35 - here we have a pretty simple but really
75:37 - nice character visual it's really just
75:39 - two spheres stacked on top of one
75:41 - another with a bunch of eyes very simple
75:42 - for the visual itself the material is
75:45 - using just a solid color so here it is
75:47 - inside the assets material you can see a
75:49 - bunch of player bodies with different
75:50 - color these different colors they won't
75:52 - be used in the upcoming multiplayer
75:54 - video basically each player will have a
75:56 - different color also by the way if
75:57 - you're a complete beginner here's a
75:58 - quick lecture on materials these are
76:00 - materials and if we call it select we
76:02 - can see a bunch of sets related to that
76:03 - material basically the materials have a
76:05 - Shader and then a bunch of properties
76:06 - now the Shader is the actual code that
76:09 - runs on the graphics card that says how
76:11 - an object should be rendered by default
76:13 - you have a whole bunch of included
76:14 - shaders we're using the universal render
76:16 - pipeline so you should mostly be using
76:18 - the ones inside the urp and by default
76:20 - you probably want to be using the
76:21 - standard light Shader then of course you
76:22 - can also build your own custom shaders
76:24 - one excellent tool for doing that is
76:26 - shade graph which I have covered in
76:27 - detail in a previous video it's a fully
76:29 - visual tool that you can use to make
76:31 - shaders without having to write any
76:32 - shutter code it's a great tool I've also
76:34 - made a bunch of tutorials on all kinds
76:36 - of effects you can make although right
76:37 - now we're not going to be using custom
76:39 - shaders we're going to do that later on
76:41 - the course but for now we're going to
76:42 - stick with default light Shader so
76:43 - materials have a combination of shaders
76:45 - and the properties on that Shader for
76:47 - example over here for the phone light
76:48 - sharing you can see that it has over
76:50 - here based map that has a counter field
76:52 - this is what you can change to apply a
76:54 - different color to your player also as
76:56 - to how you apply a material to an object
76:57 - over here on the player visual you can
76:59 - see the objects are made up of a sphere
77:01 - so this is the mesh and then the mesh
77:03 - render this is the one that has the
77:04 - material so both these are what stores
77:07 - the shape as well as the visual for the
77:09 - object the mesh is just a 3D shape but
77:11 - just by some of the mesh filter doesn't
77:12 - actually render anything so it needs a
77:14 - mesh render which needs a material
77:15 - attached to it so for example over here
77:17 - on the hierarching let's right click on
77:19 - empty space and let's create a brand new
77:20 - Cube just to see it so if there you go
77:22 - it does create an object and as you can
77:24 - see it has a mesh filter and a mesh
77:25 - render now to apply a different material
77:27 - you can click on this little circle icon
77:29 - and it shows you all the materials in
77:31 - that project alternatively you can grab
77:33 - the material directly from the project
77:34 - window so for example the player body
77:36 - just grab it and drop it in there or you
77:38 - can also drop the material over here on
77:40 - scene view as you can see as I Mouse
77:41 - over different objects it applies that
77:43 - material to a different object although
77:45 - note that only works over here on scene
77:47 - view it does not work on game view so
77:48 - this basically sets the material over
77:50 - there on the object right now one more
77:52 - very important thing on materials if you
77:54 - have multiple meshes only using the
77:56 - exact same material and then you modify
77:57 - the material it won't change the vision
77:59 - while all meshes using that material so
78:01 - for example if I modify the color here
78:03 - put it on something different there you
78:05 - go all three instances all three objects
78:07 - that are all using the exact same
78:08 - material they all update to the new
78:10 - color if for example you wanted the head
78:12 - to be a different color from the rest
78:13 - then you would just create new material
78:15 - so you can right click on the project
78:17 - window let's create a new material then
78:19 - you can give it a name give it colors
78:21 - use a different shade or whatever and
78:22 - then use this one for something
78:23 - different so that's pretty much the
78:24 - basics for materials and by the way if
78:26 - you're a complete beginner and you have
78:28 - questions remember to post them in the
78:29 - comments and I'll do my best to help
78:30 - like I said I want to keep this video
78:32 - moving I'm trying to teach as much as
78:33 - possible while still keeping the video
78:35 - reasonable length so if you need any
78:37 - further clarification on anything
78:38 - specific just go ahead and ask in the
78:40 - comments okay so when materials are out
78:41 - of the way here we have our player with
78:43 - visual let's just get rid of our Cube
78:44 - okay and just with this if we test and
78:47 - yep over here we already have a nice
78:48 - player visual walking around okay great
78:51 - except the player isn't actually
78:52 - rotating ideally the visual should be
78:55 - facing the walking direction so if I
78:57 - walk down it should be rotated to face
78:58 - down so let's have that doing that is
79:00 - actually going to be pretty simple let's
79:02 - go into our script here we are on the
79:04 - player script and over here we already
79:05 - have the movement Direction so we're
79:07 - going to use this in order to make sure
79:09 - to rotate the game object to face this
79:11 - move Direction and for rotating and
79:13 - transform there are many many ways to do
79:15 - it one obvious one is to modify the
79:17 - transform dot rotation however this one
79:19 - as you can see works with quaternions
79:21 - for me even though I've been doing Game
79:22 - Dev for over 10 years I still find
79:24 - quaternions quite a bit confusing so I
79:26 - normally don't use this method another
79:28 - method is to modify the transform dot
79:30 - Euler angles this one is much more
79:32 - intuitive and makes more sense to me it
79:34 - works with regular Euler angles which is
79:36 - much easier to understand if you don't
79:38 - know that name it really just means the
79:39 - angles that go from 0 to 360. then for
79:42 - another method you can also use the
79:43 - function transform Dot and look at this
79:45 - one makes a transform look at a certain
79:47 - point so it can be a transform Target
79:49 - can be a vector three for one position
79:50 - and anything like that so this is a very
79:52 - useful function we could calculate a
79:54 - point right in front of our move
79:55 - Direction and look at it or finally the
79:58 - method that I personally like to use for
79:59 - this specific purpose which is just
80:01 - modify the transform dot forward this
80:03 - one has the normalized vector
80:05 - representing the foreign axes and
80:06 - importantly you can get it and you can
80:08 - also set it so you have both read and
80:10 - write you can read it to get the current
80:12 - transform for it but you can also write
80:13 - to it to essentially rotate the
80:15 - transform so we can just assign this to
80:17 - our forward Vector also by the way you
80:19 - also have transform dot up and transform
80:21 - dot right both these work exactly the
80:23 - same way for example transforms are
80:25 - right this one is extremely useful for
80:26 - 2D games but over here we're working in
80:28 - 3D so we want to transform that forward
80:30 - and all we need is the forward Vector
80:32 - which is really just in move Direction
80:33 - so let's set this one equal Z move there
80:35 - okay so just like this it shouldn't
80:37 - really work let's also just clean up the
80:38 - log we already need to see the Delta
80:40 - time okay so let's see like this okay
80:42 - here we are and as I move and you better
80:44 - go and look at that the player object
80:45 - does indeed rotate to face the move
80:47 - Direction okay so it's already looking
80:48 - great all right awesome however it also
80:51 - looks a bit odd with how it's instant so
80:53 - I move left and right look at that it
80:54 - instantly rotates so there's no
80:56 - smoothing nothing it's way too janky so
80:59 - let's add some nice simple smoothing and
81:01 - for that let's use a really awesome
81:02 - really useful math function called lerp
81:04 - it helps you interpolate between two
81:06 - values I made a quick video showcasing a
81:08 - bunch of uses for it you can alert
81:10 - floats Vector 3s quaternions or just
81:12 - about anything it's really perfect for
81:14 - making some smooth movement or smooth
81:15 - rotation so for that we can access the
81:18 - function inside the vector 3 class so we
81:20 - can find an alert then here we actually
81:22 - have two options we've got learn this
81:26 - one interpolates and we've got slurp
81:28 - this one interpolates but with a
81:30 - spherical interpolation basically if
81:31 - you're dealing with rotations like what
81:33 - we have here then we want to be using
81:34 - slurp whereas if you're dealing with
81:36 - just positions and you want to use so
81:38 - here let's use slurp this one as you can
81:41 - see takes an a a b and a t like I said
81:43 - this interpolates between A and B based
81:45 - on T so for example if T is zero then it
81:48 - won't return the value a if T is one
81:50 - then it won't return to Value B if C is
81:52 - 0.5 then it won't return the point in
81:54 - between A and B if you want to learn
81:56 - some more about interpolation and the
81:58 - math behind this then I highly recommend
81:59 - you look at my video on splines splines
82:01 - are basically just a whole bunch of
82:03 - merps put together so anyways over here
82:05 - we can add some smoothing to our
82:06 - Rotation by just using the current
82:07 - transform.ford as our a
82:10 - then for the B this one is our Target so
82:12 - let's use the move there and finally 14
82:15 - let's use time dot Delta time meaning
82:17 - that with this over time the character
82:19 - won't rotate towards our Target movement
82:21 - Direction so just with this let's test
82:23 - so here if I move to the right and you
82:25 - have a look at that it is indeed
82:26 - rotating it's way too slow but yep it is
82:28 - rotating smoothly all right so let's
82:30 - just add a bit more speed so over here
82:32 - let's just find a float for the rotate
82:34 - spin let's put it at some like 10f then
82:37 - we just multiply it to times that down
82:39 - time multiplied by our speed let's see
82:40 - and move any up there you go look at
82:42 - that much much better okay great so as
82:45 - you can see everything works as I move
82:47 - the character does rotate to face the
82:48 - move Direction all right great so here
82:50 - we have our character with a nice visual
82:52 - all rotating to face the move Direction
82:54 - now next step is we want to add some
82:56 - nice animation so let's do that in the
82:58 - next lecture
83:00 - hello and welcome I'm your code monkey
83:02 - in this lecture we're going to add some
83:04 - animations to our player character now I
83:06 - have already included some pre-made
83:07 - animations with a pre-made animator over
83:09 - here inside the Asus folder but let's
83:11 - first do it from scratch so you'll learn
83:13 - how to do it first to animate we're
83:15 - going to need the animator component if
83:17 - we go inside the player visual game
83:18 - object once again remember all the
83:20 - visuals go on the visual game object so
83:22 - for adding the animator component we
83:24 - want it on the visual and not on the
83:25 - logic component so anyways over here as
83:27 - you can see by default I already attach
83:29 - it with the assets included but let's do
83:31 - it from scratch so let's remove this by
83:33 - default now let's add a new component
83:35 - let's go on an animator also one very
83:37 - very important thing here it's the
83:39 - animator component not the animation
83:41 - component these QR can only difference
83:44 - the animation component this one is
83:46 - actually related to unity's Legacy
83:48 - animation system from a very long time
83:49 - ago it's only here pretty much for a
83:51 - backwards compatibility and for super
83:53 - simple use cases so most of the time
83:55 - make sure you're using the anime tour
83:56 - component okay so to drive this animator
83:58 - component we need an NM troller let's go
84:01 - into our project files and let's create
84:02 - and create a brand new animated control
84:04 - let's call this my player animator then
84:07 - let's select the player Visual and just
84:09 - drag the controller on there okay again
84:11 - if you have issues then you cannot drag
84:12 - the animator onto the film make sure
84:14 - you're using the animator and not the
84:16 - animation component okay so with this we
84:18 - have assigned our animator controller
84:20 - now let's double click on it to open the
84:22 - animated window and if you don't see it
84:23 - then go into window then go into
84:25 - animation and open up the animator
84:27 - window and also if you still don't see
84:28 - anything that maybe you might have some
84:30 - issues with your layout if that's the
84:32 - case then go on to the top right corner
84:33 - layout and go back into the default and
84:35 - then back into your own layout and
84:36 - finally if you still don't see anything
84:38 - on this window if you don't see defontes
84:40 - make sure you have the object selected
84:42 - in the hierarchy so with that you should
84:43 - be able to see these states so this is
84:45 - our animator controller now I have a
84:47 - really detailed overview of the animator
84:49 - and the animation windows in my ultimate
84:50 - unity overview course so you can go
84:52 - watch those lectures for some really
84:54 - in-depth explanations about everything
84:55 - this does basically the animator is a
84:57 - state machine so you have various States
84:59 - and you can create transitions between
85:01 - each state by default you have these
85:03 - three special States there's the entry
85:05 - State exit and any state these are used
85:07 - for making transitions but we don't
85:08 - really need to worry about them just for
85:09 - now first let's just make a basic new
85:11 - animation and for that the easy way to
85:13 - do it is to open up the animation window
85:15 - so let's go up top into window go into
85:17 - animation and open up the animation
85:19 - window so here it is again that's a
85:21 - different window that's animation not
85:23 - anywhere and for me for this window I
85:25 - like to dock it down here so there's a
85:26 - nice timeline so I think this is good
85:28 - okay and now if we select the object in
85:30 - the hierarchy that has our animator then
85:32 - we can see the text here so to begin
85:33 - animating we've got a nice button to
85:35 - create an animation so let's go ahead
85:37 - and click on this and now let's give it
85:38 - a name for now let's first make the
85:40 - iPhone animation so let's just call this
85:42 - Idol and name just like that we have
85:43 - created an animation you can see the
85:45 - animation window down here has changed
85:47 - we now see a nice timeline showing the
85:49 - time and also on the animated controller
85:51 - you can see the new animation was added
85:53 - as a brand new state so a new state was
85:55 - created and if you click to select it on
85:57 - the right side in the inspector you see
85:59 - the motion so the actual animation
86:00 - selected and you can also see that
86:02 - there's an arrow pointing from the entry
86:04 - onto the unknown state so that means
86:05 - this one is going to be the default
86:07 - State when the animated controller
86:08 - starts it won't start playing right on
86:10 - this state let me just point out one
86:12 - more thing related to animations so on
86:14 - the project window we can see yep here
86:16 - is our animation that we just created
86:17 - and you can see the inspector unlocks
86:19 - just like this now if your inspector
86:21 - looks differently that might be because
86:22 - you accidentally created the Legacy
86:24 - animation that has to do with the
86:26 - previous animation system that I talked
86:27 - about the one that is Legacy that should
86:29 - really no longer be used so if you see a
86:31 - different inspector then a quick way to
86:33 - fix it is to click on these three dots
86:35 - on the inspector these three dots then
86:36 - you change the inspector into debug
86:38 - inspector and over here you see a toggle
86:40 - on foreign legacy so for the animations
86:42 - that we want to use right now we do not
86:43 - want to be using Legacy animations so
86:45 - make sure this one is untoggled if in
86:47 - our case is toggle just untoggle it then
86:49 - go back into the normal inspector and
86:51 - now yep it shouldn't look just like this
86:52 - okay so we have our animation and now
86:54 - it's on our animator controller now it's
86:56 - actually make an animation so let's
86:59 - select the animation window though and
87:00 - again let's make sure to select the
87:02 - objects and let's select the player
87:03 - visual game object so here on the
87:05 - animation window we see this nice little
87:06 - red button this one enables or disables
87:08 - recording so if you click on it you can
87:10 - see yep the timeline is now red meaning
87:12 - that we are now recording and now we can
87:14 - do anything to any channel objects and
87:16 - it won't record any changes we make now
87:18 - note what I said that's very important
87:19 - it needs to be challenged objects if you
87:21 - select for example the apparent game
87:23 - object then all of a sudden it stops
87:24 - recording so you can only animate child
87:26 - objects so let's select the player
87:28 - visual let's enable recording then let's
87:30 - expand the player visual let's make sure
87:32 - that our timeline is on zero so drag it
87:33 - all the way to the left and now for
87:35 - example let's grab the head object and
87:37 - let's move it just a tiny tiny bit
87:39 - basically just move it enough in order
87:41 - to make sure that the position over here
87:42 - is in red meaning that we have recorded
87:44 - a keyframe then let's drag the timeline
87:46 - by a little bit let's go over here to
87:48 - frame 30. this one is actually going to
87:50 - be half a second and soon to be that
87:52 - because over here on the samples this is
87:54 - the frame rate for the animation so at
87:55 - 6C that means we have 60 frames this
87:57 - makes one second so 30 frames would be
88:00 - half a second you can also zoom out by
88:02 - scrolling over here or dragging the
88:03 - handles down here so let's go into 30
88:05 - half a second and on this one let's move
88:07 - the head by a little bit something like
88:08 - this as you can see down there we can
88:10 - note that I record the new keyframe and
88:11 - now if we hit on the play button we can
88:13 - preview the animation any upon like that
88:15 - that does do exactly that so it starts
88:16 - off down and then moves up okay so
88:18 - that's great but we don't want to snap
88:20 - back so let's actually add another
88:21 - keyframe right at the end so let's stop
88:23 - playing the animation and to make sure
88:25 - we have a perfect Loop let's just click
88:27 - to select the keyframe let's press Ctrl
88:29 - C then let's go down into the one second
88:32 - Mark let's press Ctrl V and there you go
88:34 - there's the exact same keyframe so now
88:36 - if we hit on play the other go we have
88:37 - our nice seamless Loop so the head goes
88:39 - up and down and repeats forever alright
88:41 - awesome okay so that's great now let's
88:44 - also do one thing let's also record a
88:46 - keyframe on the body however we don't
88:48 - want it to move at least not in this
88:50 - idle animation we just want to have a
88:52 - static keyframe so let's select the body
88:54 - and let me actually move it a bit to the
88:56 - side just to make sure to record and now
88:58 - manually we can modify things over here
88:59 - here to modify the actual keyframe data
89:02 - so on this one I don't want it to move
89:03 - so let's put it all the way back at zero
89:05 - just make sure we have a nice keyframe
89:07 - recording now the reason why we are
89:08 - recording the body position even without
89:10 - moving it is because the wonk animation
89:12 - will indeed move the body but when we
89:14 - get back to idle we want the body to go
89:16 - back to this exact position so that is
89:18 - why we need the keyframe here okay so
89:19 - that's done so we can stop recording so
89:21 - let's click on the red button again okay
89:23 - great by the way one more note to make
89:25 - sure that the animation Loops go into
89:27 - the project window and over here select
89:29 - the animation and make sure on Loop time
89:30 - is enabled it should be there by default
89:32 - okay so the animation is set up and if
89:34 - we unlock in the animator it's already
89:35 - the default set so if we hit point we
89:38 - should be able to see the anal animation
89:39 - playing non-stop so let's hit play and
89:41 - if there it is the anal animation with
89:43 - the head moving up and down everything
89:44 - works perfectly alright awesome okay so
89:47 - next up let's make a wonk animation now
89:49 - for me when making an animation that is
89:51 - based on another one I like to actually
89:52 - duplicate it instead of starting from
89:54 - scratch so over here on the project
89:55 - window let's select the anal animation
89:57 - and let's duplicate it so Ctrl D let's
89:59 - learn name this one to the wonk
90:01 - animation and now if we select the
90:03 - player Visual and then we go into the
90:05 - animation window over here we see a nice
90:06 - little drop down menu for all of the
90:08 - animations except right now we don't see
90:10 - the wonk animation we only see the idle
90:12 - animation that is because this menu only
90:14 - shows animations that are attached to
90:16 - the animator so first we need to add the
90:18 - animation onto the animator component
90:19 - and how we do that is actually super
90:21 - simple let's just open up the project
90:22 - window and just write the wonk animation
90:24 - and drop it here that's it so with this
90:26 - we have attached a new state to the
90:27 - animated controller and now if once
90:29 - again we select the object in the
90:30 - hierarchy go into the animation click
90:32 - the drop down menu any up now we do see
90:34 - the wonk animation so let's click to
90:36 - select this one and now for this one
90:37 - let's make the animation so let's look
90:38 - in scene View and make it bounce just up
90:40 - and down so I'm going to enable record
90:42 - go back here and for the body this one
90:44 - already has a keyframe so let's go up
90:46 - here move it a little bit and then copy
90:48 - the keyframe put it the same one at the
90:50 - end something like this so there you go
90:51 - just goes up and down once actually
90:53 - input it offsets it looks a bit better
90:54 - so something like this by the way in a
90:56 - bit we're going to replace these
90:57 - animations with the ones that I made
90:58 - previously so don't worry about making
91:00 - the animations perfect unless you want
91:02 - to do that okay so there you go that's
91:03 - the animation although for walking
91:04 - should be much faster so here's a quick
91:06 - animated tip this top bar here lets you
91:08 - select all of the keyframes within a
91:10 - certain time so if I click the select
91:12 - note how it selects both those keyframes
91:13 - and also if you click and drag once on
91:15 - top of here you can select multiple
91:17 - keyframes so for example to select
91:18 - everything just click and drag to select
91:20 - all of them and now you see these nice
91:22 - little vertical bars so if you click on
91:24 - those and then you drag them you can
91:25 - basically modify the time of all the
91:27 - animations and everything matches up so
91:29 - for example let's make this one super
91:30 - fast let's put it just 20 frames there
91:32 - you go now it's a much faster walking
91:33 - Mission okay great let's click on the
91:35 - right to stop recording all right and
91:37 - back in the animator so over here we
91:39 - have both animations and now what we
91:40 - need is to make a transition going from
91:42 - idle into wonk otherwise the wonk
91:44 - animation will never play so how we make
91:46 - a transition is also super simple let's
91:48 - right click on the I don't say let's
91:50 - make a transition then now we have a
91:52 - nice little arrow under the mouse and
91:54 - now if we go into the wonk and click on
91:55 - it there you go we have a nice
91:57 - transition now we can click on the
91:58 - transition itself to select it and over
92:00 - here in the inspector we see a bunch of
92:01 - transition options so let's expand the
92:03 - settings yep there you go everything now
92:05 - like I said I covered all of these
92:06 - options in a lot of detail in my
92:08 - ultimate TNT of recourse so if you want
92:10 - to learn more go watch that here on
92:12 - let's just learn the basics for how to
92:13 - achieve our goal and making a simple
92:14 - player animator the important one is
92:16 - over here the exit time basically if
92:18 - this one is toggled then this transition
92:20 - won't be triggered automatically meaning
92:21 - it won't play the outline Mission and
92:23 - immediately transition into the walk
92:25 - animation so for example if we hit play
92:26 - and look at it quickly if there go
92:28 - there's the idle any of transitions into
92:30 - wonk and now it stays there forever okay
92:31 - so that's good but not exactly what we
92:33 - want we want the Wonka mission to only
92:35 - play When the character is walking and
92:37 - when it stops we want to go back into
92:38 - the idle animation now for that we need
92:40 - to use animator parameters so back in
92:42 - our animator on the top left corner we
92:45 - see something called layers we don't
92:46 - need to worry about that for now and
92:47 - then next week we see parameters then we
92:49 - can click on the plus button or to
92:51 - create the brand new parameter and you
92:52 - can see all the various types that we
92:54 - can create now for wonky we want
92:55 - something that we can set to either true
92:57 - or false so let's go with a nice bullion
92:59 - and for name let's go with is wonky
93:01 - again pay very close attention to the
93:03 - capitalization this is extremely
93:05 - important just like code is walking is
93:07 - different from is walking so make sure
93:09 - the capitalization is perfect okay so
93:11 - with that we have our nice parameter now
93:12 - let's click on transition going from
93:14 - idling to wonk and now let's untick exit
93:16 - time we don't want this transition to
93:18 - trigger automatically and as soon as we
93:19 - do we see this nice little warning
93:21 - basically it's telling us that this
93:22 - transition will never happen so over
93:25 - here we have the nice conditions if we
93:27 - click on the plus icon we can add some
93:28 - conditions and for this one we want this
93:30 - transition to happen from idling to walk
93:32 - when the parameter is walking is set to
93:34 - true so that's it this is our transition
93:36 - now let you see the reverse so let's
93:38 - right click on the wall make Transition
93:39 - go back into Idol let's click the select
93:41 - transition get rid of the exit time and
93:44 - conditions when is Walking is set to
93:45 - false okay so just like this our basic
93:48 - animation logic should be working so
93:50 - let's test so here we are and the
93:51 - character is playing the online Mission
93:53 - by the way you can look at the end
93:54 - better while the game is running so let
93:56 - me just drag the animator window just
93:58 - drag it and put it on the side of the
94:00 - game view so we can see both at the same
94:01 - time okay great and right now note how
94:04 - it's not updating so there's nothing
94:05 - moving over here on the animated
94:06 - component that is because like I said
94:08 - you must select the object so on the
94:09 - hierarchy make sure you select the
94:11 - player Visual and you have there go now
94:12 - you do see that updating so make sure
94:14 - the object is selected in the hierarchy
94:15 - and over here we see a nice little
94:17 - progress bar showing the Adeline Mission
94:19 - constantly playing in looping okay great
94:20 - another important thing is over here the
94:22 - parameters you can manually change the
94:24 - state of these while the game is running
94:25 - so for example if I click it's going to
94:27 - trigger the is walking parameter which
94:29 - should trigger this transition and
94:30 - should go into one so if I click and if
94:32 - there go transitions into the wonk
94:34 - animation and now yep it is playing The
94:36 - Walking animation and if I click to
94:37 - untick it look at over there what
94:39 - happens untake and there you go
94:41 - transitions back into idle alright
94:43 - awesome so as you can see we have
94:44 - overall logic working we have the
94:46 - animator with both of our states and by
94:48 - changing this parameter we can change
94:49 - which animation is playing now of course
94:51 - the goal is not to trigger this manually
94:53 - by clicking on it but rather doing it
94:54 - through code but at least for now we
94:56 - know that our animator is fully set up
94:58 - again if you want more detail on the
94:59 - animator and animation windows and
95:01 - everything related to animations then
95:03 - check out those lectures in my ultimate
95:04 - TNT overview course and also later on
95:06 - for more advanced use cases I have video
95:08 - on the animation rigging package this
95:10 - one is for more advanced use cases for
95:11 - making Dynamic procedural animations
95:13 - it's really fun so definitely check it
95:15 - out but only after finishing this course
95:16 - that one is a much more advanced duel
95:18 - for now let's continue here so we want
95:20 - to trigger our parameter but do it
95:21 - through code and again here we have yet
95:23 - another clean code question technically
95:25 - we could add that code directly over
95:26 - here on the player script we could just
95:28 - grab the animator component and change
95:30 - the parameter and in this case for this
95:32 - very simple game that would actually not
95:33 - necessarily be a very bad approach since
95:35 - the game is so simple with so few
95:37 - animations but like I said I want to
95:39 - teach you proper good practices so let's
95:41 - make it properly and actually separate
95:43 - the animations from the logic for then
95:44 - let's go into our project right click in
95:46 - our scripts folder create a new c-sharp
95:48 - script let's come with the player
95:49 - animator let's select the player visual
95:51 - game object and attach the component
95:53 - okay so now here first let's grab the
95:55 - animator now one approach is like we've
95:57 - seen we could just make a serialized
95:59 - film and and drag the reference in the
96:00 - editor that's one approach or
96:02 - alternatively since the animator is
96:04 - attached to the same game object as this
96:05 - script then we can just do a get
96:07 - component both approaches are really
96:08 - valid so here let's use get component
96:10 - just to see a different approach so we
96:12 - just have a field for our animator so
96:14 - animator and then we just do a private
96:17 - void awake and then awake lets you get
96:19 - component of type animator and we set
96:21 - our animator variable again like I
96:23 - mentioned very important make sure you
96:25 - don't mix animator and animation these
96:27 - are two different components we want the
96:29 - animator okay so with this we have a
96:31 - reference to our end meta component and
96:33 - now how we modify the parameter is
96:35 - actually very simple we just access the
96:37 - animator and then we have a bunch of set
96:38 - functions you can see we have one for
96:40 - each type so we've got a set bone set
96:42 - float then down here a set trigger set
96:44 - Vector so function to set any parameter
96:46 - type now we made the Boolean so let's
96:48 - use the set bone and this one as you can
96:50 - see takes the name for the animator
96:51 - parameter by the way strings are a
96:53 - horrible horrible way of identifying
96:55 - things but suddenly this system really
96:57 - does require strings to identify the
96:58 - parameter we want to change change if
97:00 - you're wondering why strings are bad for
97:02 - identifying things the reason is because
97:03 - it's very easy to make a mistake for
97:05 - example if you use is walking here then
97:07 - this won't work however if you instead
97:10 - right is walking then all of a sudden
97:11 - does not work if your right is walking
97:13 - like this doesn't work like this doesn't
97:15 - work and even though it doesn't work it
97:17 - will also not throw any compiler errors
97:19 - that is because for the compiler a
97:20 - string is a string it's always valid but
97:22 - then when the code runs this one is
97:24 - going to be different than our parameter
97:25 - which is named exam like this always
97:26 - remember that strings are case sensitive
97:28 - so that's one reason why you should
97:30 - never use strings to identify things
97:32 - it's very very easy to make tons of
97:34 - mistakes that are then very difficult to
97:36 - find out but like I said in this
97:37 - animator system we have to use strings
97:39 - there's no other way in order to
97:40 - minimize our usage of strings one thing
97:42 - we can do is for example let's define a
97:44 - constant up here so let's make a private
97:46 - make it cons for a constant meaning this
97:48 - will never change make enough type
97:50 - string and conlet is wonky again refer
97:52 - back into the naming wrong section for
97:54 - constants we always use uppercase snake
97:57 - case so is walking and let's set it with
97:59 - is wonky again make sure you don't make
98:01 - a mistake here make sure you type it
98:03 - exam like you did on the animator then
98:05 - down here let's use is one and now if
98:07 - you do make a mistake so if we
98:08 - accidentally use something different now
98:10 - we do get a compound error so at least
98:12 - we have a little bit of protection okay
98:13 - so this one takes a string for the name
98:15 - and then a simple Boolean for the value
98:16 - so this is going to be the value that we
98:18 - want to set to our parameter now for
98:20 - this one we want to set to True when the
98:22 - player is walking and false when it's
98:23 - not so for that we need to ask the
98:25 - player what it's doing so let's go over
98:27 - here into our player class and let's
98:29 - make a function to return just that so
98:31 - let's make it public because we're going
98:32 - to access it from another script we're
98:34 - going to return a boom and call it is
98:36 - wonky now over here we just need to
98:37 - return if the player is walking so let's
98:40 - make a local field to store that saved
98:41 - so over here private bone is walking
98:43 - again note the capitalization for films
98:46 - we start with camel case whereas for
98:49 - functions we have Pascal case so these
98:51 - are different okay so basically in order
98:52 - to Define if we are working that's very
98:54 - simple it's just down here we have the
98:56 - movement Direction so we are walking if
98:58 - the move direction is different from
98:59 - Vector 3.0 which by the way Vector 3.0
99:02 - is just a shorthand for writing zero
99:04 - zero zero so if the movement direction
99:05 - is different from zero then we are
99:07 - indeed walking so we Define that we
99:09 - update that film on every update and
99:10 - then over here we just return it okay
99:12 - just like this and now back in our
99:14 - player animated component over here
99:15 - first we need a reference to the player
99:17 - so let's add it here let's add a
99:19 - serialized film of type player and we
99:22 - need to compound this in order to drag
99:23 - the reference so let's just come without
99:25 - this line just make sure the code
99:26 - compounds now here with the code
99:28 - compound let's write the reference of
99:29 - our player okay that's it and then over
99:31 - here for the animator set is wonking
99:33 - let's go into the player and let's ask
99:35 - is walking and of course we don't want
99:37 - to do this just on awake we want to do
99:39 - it on every single frame so let's do a
99:41 - private void update and on update let's
99:44 - do this alright that's it so this should
99:46 - be working let's test so here we are
99:48 - starting off as Idle and as I move yep
99:50 - there you go it is playing The Walking
99:52 - animation and now if I stop and if there
99:54 - go back into idle alright Awesome
99:56 - everything does work perfectly okay
99:58 - great we can can even look at the
100:00 - animator to see the state change so here
100:02 - with both side aside and with the
100:03 - objects selected in the hierarchy right
100:05 - now you can see he's walking his phone
100:06 - so it's on idle and as I move that one
100:08 - stays true that one goes into wonk and
100:10 - now if I don't let go if there and go
100:12 - back into falls back into idle all right
100:14 - awesome so with this everything is
100:16 - working perfectly if you're having
100:17 - issues make sure you pay attention to
100:19 - the capitalization so make sure the name
100:21 - you wrote here is exactly the same one
100:24 - that you wrote here and it's exactly the
100:26 - same that you're using here alright so
100:28 - all of our animations are working
100:29 - perfectly now if you want you can go
100:31 - ahead and make your own animations or
100:33 - you can use the ones that I pre-bumped
100:34 - so in the included project files inside
100:36 - the assets here we've got the animations
100:38 - and we've got the player with the idol
100:40 - and the wonk animations if we double
100:42 - click on this don't look at it you can
100:43 - see yep it looks exactly the same so
100:46 - there's a parameter called is walking in
100:47 - our transition so everything is exactly
100:49 - the same just over here let's select the
100:51 - employer Visual and on the prefab like
100:52 - we saw we already have the animated
100:54 - component we just removed that one from
100:56 - the prefab in order to build it on from
100:57 - scratch but if you want to use my image
100:59 - then we can just go ahead remove the
101:01 - animator that we added and then right
101:02 - click on this one on the remove
101:04 - component let's revert back to changes
101:05 - and there you go here we have our
101:07 - animator with the player controller so
101:09 - that's the one in the animations and
101:11 - just like this if we had on play and
101:13 - actually over here I found an issue
101:14 - although in your case there shouldn't be
101:16 - any issue because I've updated the
101:17 - assets but this is a good time to teach
101:19 - you about any issues with animations so
101:21 - if you select the animation and you
101:23 - select the animation and over here you
101:24 - might see some of them in yellow saying
101:26 - missing basically the way that
101:27 - animations work is based on the actual
101:29 - name of the object if it cannot find an
101:31 - object with the exact same name then it
101:33 - cannot load the same animation so my
101:34 - problem is that when I initially made
101:36 - the assets package I made this animation
101:38 - and the object was previously named face
101:40 - and then I renamed it the head so now it
101:42 - normally loads so if you ever have
101:44 - problems with loading animations just
101:46 - make sure the name is perfectly matched
101:47 - so in my case I can just click in here
101:49 - in order to rename this keyframe on the
101:51 - animation and I'm just going to use the
101:52 - name that I renamed it so head and just
101:55 - like this yep the animation does play
101:56 - correctly so it's just a nice quick tip
101:58 - if you ever have problems with and
101:59 - missions always remember that the stored
102:01 - keyframes their own stored based on name
102:02 - so if you rename the thing in here or
102:05 - over here on the game object if you're
102:06 - in a name you're going to have missing
102:08 - animations but if you make sure the
102:09 - names match and the animation shouldn't
102:11 - work perfectly so let's hit on play and
102:13 - if there go there's the anal animation
102:14 - and if I move yep there's the nice wonk
102:16 - animation so everything still works
102:18 - perfectly because it's only using the
102:19 - exact same parameter alright awesome so
102:22 - like I said if you want film free to
102:23 - make your own animations or use the ones
102:25 - that I've included for me I'm going to
102:27 - be using these ones so the ones that we
102:29 - made just for learning which I created
102:30 - down here so the multiplier animator and
102:32 - these animations I'm just going to
102:33 - delete these just to keep the project
102:35 - clean so just delete and just like that
102:37 - okay so now there we have our character
102:39 - fully working let's quickly handle our
102:41 - camera
102:43 - hello and welcome I'm your code monkey
102:45 - in this lecture we're going to quickly
102:47 - install cinemachine this is a Unity tool
102:49 - that makes handling cameras super easy
102:51 - our game isn't really going to have a
102:53 - moving camera so this part isn't
102:54 - strictly necessary but same machine is a
102:56 - super useful tool so I definitely want
102:58 - you to learn about okay so let's begin
102:59 - by installing the package let's go into
103:01 - window open up the package manager then
103:03 - up top let's make sure we are in the UNT
103:05 - registry make sure you're on the all Tab
103:08 - and now just scroll down until you find
103:10 - yep there it is send machine okay so
103:11 - let's go ahead and install this
103:14 - all right Sunstone so let's close this
103:16 - and now the way that send machine works
103:18 - is by creating what is called a send
103:19 - machine virtual camera so let's go up
103:21 - top into the game object menu then
103:23 - scroll down into cinemachine and over
103:25 - here you can see that we can create a
103:27 - multitude of virtual camera types now
103:29 - just by the names you can see how this
103:30 - tool is insanely useful for example
103:32 - making a free download camera doing that
103:34 - from scratch is a bit tricky but with
103:36 - same machine it is super easy for our
103:38 - case like I said we want the absolute
103:39 - most basic thing possible so let's just
103:41 - create an empty virtual camera okay
103:43 - that's it this creates a virtual camera
103:45 - over here in the hierarchy and turn this
103:47 - object has the send machine virtual
103:49 - camera component and also importantly
103:50 - when we added this it also added over
103:52 - here on the main camera if we scroll
103:54 - down we can see it has a sin machine
103:55 - brain component basically the way send
103:57 - machine works is it works on top of the
103:59 - main camera so it doesn't replace it it
104:01 - works on top of it and drives the main
104:03 - camera so now that we're using send
104:04 - machine if we try modifying the main
104:06 - camera game object so there's one over
104:08 - here if I try to drag the field of view
104:10 - nope does not work I cannot move it if I
104:12 - try to move the position nope can't do
104:14 - it it if I try to rotate it nope that
104:16 - does not work like I said when working
104:17 - with cinemachine the sin machine brain
104:19 - is what drives the main camera so rather
104:21 - than modifying the things over here on
104:22 - the camera itself what we need to do is
104:24 - change them on the virtual camera so
104:26 - over here we have pretty much the exact
104:28 - same options that we have on the main
104:29 - camera for example modifying the fov
104:31 - over here we've got the lens so we can
104:33 - modify the fov and if we look in the
104:35 - game scene as we modify this one yep it
104:37 - does modify the actual properties on the
104:38 - actual main camera now this has tons and
104:40 - tons of options related to everything
104:42 - the most important ones are all kinds of
104:44 - options down here for the body and the
104:46 - aim so this is where the camera is
104:47 - positioned and where it's looking at
104:49 - using this you can make a funnel camera
104:50 - in five seconds it really is insanely
104:52 - useful if you want to learn about Sim
104:54 - machine in more detail I have a
104:55 - dedicated video on it I go through what
104:57 - all of these options do then I also have
104:59 - another super detailed video on how to
105:01 - make a camera system with pan Zoom
105:03 - scroll in both 2D and 3D and a bunch
105:05 - more features again all of it using send
105:07 - machine but in our case we really want
105:09 - to keep it simple so let's just position
105:10 - our virtual camera on the same settings
105:12 - that we had previously so for first
105:14 - let's set the film review so for a game
105:16 - we want something narrow so let's go
105:17 - with just 20. then for the position
105:19 - let's put it above so zero on the X then
105:21 - 21.5 on the Y and minus 21.3 on the Zen
105:25 - then for the rotation 46 on the X and
105:27 - then 0 on the others okay so our camera
105:29 - is positioned in the exact same position
105:30 - and if we head on 20 yep everything
105:32 - still works the same the camera is going
105:34 - from the same point of view and the
105:35 - character still works everything's still
105:36 - exactly the same now since we're using
105:38 - cinemachine we can easily add some
105:40 - things on top of this like for example
105:41 - we can add some noise to our scene
105:43 - machine camera to make it smoothly move
105:45 - a little bit this one is a fun simple
105:47 - effect that can make our game feel a bit
105:48 - more Dynamic especially in games like
105:50 - this where we have a fixed overhead view
105:52 - how we do that is over here on the scene
105:53 - Mission virtual camera we've got a film
105:55 - for noise so let's click and let's
105:57 - select basic multi-channel purlin and
105:59 - then over here we've got the noise
106:00 - profile so we can choose one of the
106:01 - included ones or we can create our own
106:03 - profile so for example let's go with
106:05 - handheld normal mild and by the way you
106:07 - can actually modify these settings while
106:08 - the game is playing so here it is the
106:09 - game playing and you can see what this
106:10 - effect does it adds a nice little wobble
106:13 - to the camera and then over here at my
106:14 - student frequency so we can play around
106:16 - these so you can make it really intense
106:17 - so something like this that is way too
106:19 - intense so there you go quite a lot so
106:21 - for something more subtle maybe put 0.5
106:23 - and 0.5 there you go just a slight
106:25 - little movement in the camera so this
106:27 - would help make the game a little bit
106:28 - more Dynamic so this could be a fun
106:30 - effect although actually in my case in
106:31 - order to make sure that the video
106:32 - doesn't get way too compressed I'm
106:34 - actually going to disable this on my end
106:35 - so just set the channel noise to none
106:37 - but you can see how easy it is to add
106:39 - complex camera features when using send
106:41 - machine and of course when using
106:42 - cinemachine if you want you can use it
106:44 - to make your game a lot more unique now
106:45 - for me I want to design here where the
106:47 - camera is fixed but let's say for
106:48 - example you wanted the camera to
106:50 - actually follow the player like I said
106:51 - you'll watch that dedicated video tool
106:53 - and learn all about cinemachine but over
106:54 - here very quickly let me just show you
106:56 - how to do that but at the same time
106:57 - don't bother following this part it's
106:59 - just to show what scene machine can do
107:00 - that I'm going to revert back to this
107:02 - state so first of all for testing one
107:03 - great thing about scene machine is you
107:04 - can have multiple virtual cameras you
107:06 - can have as many as you want and then
107:08 - the priority and the game object enabled
107:10 - state is what defines which camera is
107:12 - actually being used so for example on
107:13 - this second one let's make it follow the
107:15 - camera and put the priority on 20 so
107:17 - that it's above then over here for the
107:18 - body I'm going to select transposer
107:20 - let's put it with World space it
107:22 - requires a funnel Target so let me drag
107:24 - the player as the final Target and put
107:26 - it as slightly above and behind Okay so
107:29 - it's pretty similar as before then for
107:31 - the aim let me also drag the aim player
107:33 - Target and just with this it should
107:34 - already work so if I head on play if
107:36 - they're going to look at that the camera
107:37 - is now moving and following the player
107:39 - so I can move the player anywhere and
107:40 - yep the camera follows along so as you
107:42 - can see it's this simple to really make
107:43 - some complex camera movement doing some
107:45 - complex camera logic just like this
107:47 - would require a ton of work manually but
107:49 - with thin machine it is super easy then
107:51 - you can even play around with either
107:52 - priority or enable and disable and there
107:55 - you go see the machine even transitions
107:56 - between the state of only your virtual
107:58 - cameras so as you can see in lots and
107:59 - lots of things you can make with your
108:01 - camera very easily all thanks to
108:02 - cinemachine like I said in my case I
108:04 - just want the fix overhead camera so I'm
108:06 - just going to delete this secondary
108:07 - virtual camera and there you go just
108:09 - this one on top looking at the player
108:10 - and looking down with a low fov and Yep
108:12 - this is the exactly the kind of camera
108:14 - that I want for my game okay so that's
108:16 - in machine it's a really awesome tool
108:18 - for making camera handling much much
108:19 - easier so this was a quick lecture all
108:22 - about learning about Sin machine now
108:23 - let's handle the tests that was actually
108:25 - left and done quite a while ago let's
108:26 - finally learn how to refactor code and
108:28 - implement the new input system so let's
108:30 - do that in the next lecture
108:33 - hello and welcome I'm your code monkey
108:34 - in this lecture we're going to refactor
108:37 - our code from the Legacy input manager
108:39 - onto the new input system so the
108:41 - simpleton character controller that we
108:42 - made is working perfectly fine within
108:44 - Legacy input manager like I said this
108:46 - one is excellent for making quick
108:47 - prototypes and demos as you can see it's
108:49 - super easy to use
108:50 - but now let's quickly refactor this code
108:53 - to use the new input system instead also
108:55 - like I said in the beginning of this
108:56 - course here I'm going to be focused
108:57 - primarily on building this game so for
108:59 - example for any Unity tools that I use
109:01 - like the new input system I'm going to
109:03 - cover enough to be able to use a tool
109:04 - and Achieve our goals in building this
109:06 - game
109:07 - of course every tool does a lot more
109:08 - than just what we're going to use so
109:10 - definitely make sure to watch the
109:11 - dedicated videos Link in the description
109:12 - for example the input system tutorial is
109:15 - 40 minutes long covering everything you
109:16 - need to know about system whereas here
109:18 - we're just going to learn enough to know
109:19 - how to use it so let's refactor this
109:21 - code to make it work with new input
109:23 - system except before we work with new
109:25 - input system let's just refactor this
109:27 - code so we can completely decoup on the
109:29 - input from the player class again we
109:32 - want to focus on writing good clean code
109:33 - so we should keep all of our input logic
109:36 - in its own class that other scripts can
109:37 - access remember the goal with clean code
109:40 - is to minimize and manage complexity so
109:42 - every class should do one thing and just
109:44 - one thing meaning that the player class
109:46 - should only handle the player and then
109:48 - the input list should only handle the
109:50 - input the only reason why I put this
109:52 - over here in the beginning is exactly to
109:53 - teach you about refactoring and how it's
109:55 - a very common thing that you should be
109:57 - doing all the time this is exactly how I
109:59 - build my own games I start by making a
110:01 - prototype and I write the input directly
110:03 - inside the player class then at some
110:04 - point I refactor the code to split them
110:06 - up so don't be afraid to refactor code
110:09 - it's a Perfectly Natural part of the
110:10 - Game Dev process and actually a very
110:12 - very good thing okay so let's make a
110:14 - script just to manage our inputs let's
110:16 - make a new c-sharp script call this game
110:19 - input let's create an empty game object
110:22 - give it the same name input as always
110:24 - keep things lean so put it on zero zero
110:26 - zero let's attach the script and open
110:28 - okay so here's our script and let's get
110:30 - everything related to the inputs on the
110:33 - player for the input we are calculating
110:34 - the input Vector then getting the actual
110:36 - inputs from the keyboard and returning
110:38 - the input vector
110:39 - so let's put this on the other script so
110:42 - over here let's make a new function
110:44 - let's make it public since we want to
110:46 - access it from the player we're going to
110:48 - return a vector 2 and let's call it get
110:50 - movement vector
110:53 - now here let's really just copy paste
110:55 - the exact same code that we have on
110:56 - player so let's copy paste all of this
110:58 - let's go and paste it here
111:00 - okay so we get the input Vector we get
111:02 - the inputs we normalize it and then
111:04 - return the input vector
111:06 - okay so that's it super simple also by
111:09 - the way here we have an interesting
111:10 - question
111:11 - which is do we normalize the input over
111:13 - here or do we do it over here on the
111:15 - player both options can be valid you can
111:18 - make it so that the game unplug glass
111:19 - returns a regular input or you can make
111:23 - it return a normalized vector you can
111:25 - use either option but whatever you do
111:27 - make sure you are explicit so over here
111:29 - I am going to normalize input inside the
111:31 - game input class however I'm also going
111:33 - to make sure to rename this function so
111:35 - instead of get movement Vector get
111:36 - movement Vector normalize that way it is
111:39 - 100 clear this returns a movement Vector
111:41 - as a normalized vector okay great
111:44 - so now let's use this in our player over
111:47 - here in our player class we need some
111:49 - reference to our input class now later
111:51 - on in this course I'm going to teach you
111:53 - about the Singleton pattern but for now
111:55 - let's just do a simple direct reference
111:57 - again remember don't make it public make
112:00 - it a serialized film private so over
112:02 - here
112:03 - let's make a serialized film private of
112:05 - type game input and let's call it just
112:07 - game input
112:10 - okay so we have this we're going to drag
112:12 - it in the editor then over here we
112:14 - simply grab the vector 2 for the input
112:16 - Vector we simply go into this one and we
112:18 - get the movement vector normalized and
112:20 - okay that's it no more errors let's just
112:22 - make sure to save all of our scripts and
112:24 - back in the editor let's go into the
112:26 - player and just drag the reference for
112:27 - the game input okay so just like this
112:29 - everything should still work everything
112:31 - should work exactly the same as
112:33 - previously Let's test and make sure so
112:36 - here we are moving and yep everything
112:37 - still works I can move in any direction
112:39 - okay so far so good
112:41 - and what we have done here is
112:42 - essentially we have refactor our code
112:44 - and conveniently separate the input from
112:46 - the player class this is an excellent
112:48 - thing so again don't be afraid to
112:50 - refactor code also what we did here of
112:52 - putting the code in a separate class and
112:54 - then doing a quick test to make sure
112:55 - that everything soon works the same as
112:57 - previously this is exactly what you
112:58 - should do whenever you do some kind of
113:00 - reorganizational refactoring in the end
113:02 - you want to end up with the exact same
113:04 - behaviors previously just with the code
113:06 - organized in a different way okay so now
113:08 - that we have this separate game input
113:10 - class now we can very easily refactor
113:12 - the Legacy input manager onto the new
113:14 - input system so the first thing we need
113:16 - is to install the package so let's open
113:18 - up the package manager let's make sure
113:20 - up here we are in the ENT registry make
113:22 - sure we are in all and let's scroll down
113:25 - to find the input system so here it is
113:27 - let's go ahead and install
113:30 - okay the package is installed and right
113:32 - away we see this message basically it's
113:34 - asking us if we want to enable the new
113:36 - input system
113:37 - now you could click on yes but let's
113:39 - actually go ahead and click on no we're
113:40 - going to enable it manually so click on
113:42 - no then let's close this window and now
113:45 - let's go up here into edit then let's go
113:47 - into project settings then on the left
113:49 - side let's go into player and now let's
113:51 - scroll down expand over here the other
113:54 - settings tab
113:55 - and keep scrolling down until we see yep
113:57 - here it is the active input Henley this
114:00 - is where you can select which input
114:01 - system you're using basically if you
114:03 - click yes on that window it would
114:04 - automatically set this option to use the
114:06 - new input system so it would only enable
114:09 - that one and can only disable the unless
114:10 - input manager but like I said the lace
114:13 - input manager is still pretty useful so
114:14 - normally for me I prefer to enable both
114:16 - of them so let's go ahead click on both
114:18 - and this will restart the editor so okay
114:21 - let's go alright the editor has
114:23 - restarted so now the new input system is
114:25 - now enabled okay so the way that this
114:27 - system works is by creating something
114:29 - called an input actions asset so on the
114:32 - project files let's click on the plus
114:33 - icon let's create something and let's
114:35 - find the input actions so we need to
114:38 - scroll down here so click on the little
114:39 - arrow to go down and find the input
114:41 - actions creates this file let's call
114:43 - this the player input actions
114:46 - okay now let's go ahead and double click
114:48 - on it and yep there you go out pops out
114:50 - the input system window basically this
114:52 - one is where we're going to manage all
114:54 - of the settings for all of our inputs
114:55 - also by the way and like I've mentioned
114:57 - if you're watching this in the future
114:58 - and for some reason the input system got
115:00 - a new update and changed this window if
115:02 - so make sure you check the pinned
115:03 - comment I'll keep it updated with any
115:05 - changes on anything in this course so
115:07 - over here we've got the action Maps then
115:10 - we've got the actions and then we've got
115:12 - properties now action maps are how you
115:14 - can have different maps for example one
115:16 - action map would be for the player
115:18 - whilst walking normally and you could
115:19 - have another one whilst driving a
115:21 - vehicle then for the individual actions
115:23 - in each action map and finally the
115:25 - properties for each action again if you
115:27 - want to learn about the entire input
115:29 - system itself in more detail go ahead
115:31 - and watch my dedicated video on it in
115:33 - order for this course to not be 20 hours
115:34 - long I'm really only going to use enough
115:36 - to make sure that we can achieve our
115:37 - goal so over here we just need one
115:39 - action map so let's click on the plus
115:41 - icon let's name this the player and now
115:43 - for the actions right away we have a new
115:45 - action
115:46 - so let's just rename this one let's call
115:49 - this action move then with the section
115:51 - selected over here on the Action
115:53 - Properties we can select the action type
115:55 - again in the dedicated video I cover
115:57 - what all of these mean
115:58 - for movement we do not want a button we
116:01 - want movement in multiple directions so
116:02 - let's go with value then over here for
116:04 - the control type for this one let's go
116:06 - with the vector 2 and then let's expand
116:09 - our action over here we can see our
116:10 - bindings however we don't want this
116:12 - default binding so let's actually delete
116:14 - this one instead let's click on the plus
116:16 - icon and over here for the type first
116:18 - for the keyboard and let's go with this
116:19 - one up down left right composite
116:21 - so this one adds essentially four
116:23 - bindings let's go ahead and name this
116:25 - was
116:27 - then for the up let's select the
116:28 - bindings over here on the path let's
116:30 - click on it then we can either find it
116:32 - manually over here or click on the
116:33 - listen and I'll press the W button yep
116:35 - there you go W then for down let's go
116:37 - ahead and listen s then for the unless
116:40 - listen a and for the right let's listen
116:43 - d
116:44 - okay great so with this our input as it
116:47 - is correctly set up one thing you must
116:49 - never forget is up here make sure to
116:51 - save the asset you can see this little
116:53 - asterisk here that means we have unsafe
116:55 - changes also alternatively there's an
116:58 - auto save there but for now let's just
117:00 - manually save the acid okay great
117:02 - so now let's see how to actually use
117:04 - this in our code there are many ways we
117:06 - can use the input system one way is by
117:09 - using the built-in player input
117:11 - component so for example on the player
117:13 - we would add the player input
117:15 - so you could add this one attach and
117:17 - input actions asset so this is our
117:19 - player input actions then over here we
117:21 - have various behaviors in order to be
117:22 - able to trigger our actions but in this
117:24 - course like I said I'm going to be using
117:26 - the exact same code quality that I used
117:28 - in my own Steam games so I will not be
117:30 - using this component so let's remove
117:31 - this instead I won't be using the native
117:34 - c-sharp method so what's like the player
117:36 - input actions and over here on the
117:39 - inspector we see this nice toggle to
117:40 - generate a c-sharp class
117:42 - let's go ahead enable it and for these
117:44 - films we can leave them all on defense
117:46 - that's okay let's just go ahead click on
117:48 - apply
117:48 - and now it's going to generate those
117:50 - scripts and compound them okay great
117:51 - basically what this is doing is auto
117:53 - generating some c-sharp code and on the
117:56 - employer input actions we can see over
117:57 - here yep we've got the generate script
117:59 - if you want you can even open this to
118:01 - see all of the source code now all this
118:04 - like it says here this was all auto
118:05 - generated so don't make any
118:07 - modifications here
118:08 - if you change anything any manual
118:10 - changes won't be lost when you save some
118:12 - changes in the input asset so if you
118:14 - want go ahead and read through in order
118:16 - to see how all this works but in order
118:18 - to use it sectionally super simple you
118:19 - don't need to worry about this script
118:21 - first thing we need is to construct our
118:23 - script class that was Auto General so
118:25 - let's do it over here in our game input
118:27 - let's make a product void awake and on
118:29 - awake let's construct it
118:31 - so let's do a new player input actions
118:35 - so we construct an object of this time
118:41 - so we have this although just like this
118:43 - it won't be active so we need to
118:45 - manually activate whatever action map we
118:47 - want so let's go inside and let's go
118:49 - inside the player so this is the action
118:50 - map that we created and let's call
118:52 - enable one okay so just like this it's
118:55 - really already working all we need to do
118:57 - is modify our code over here on the yet
118:59 - movement Vector so for that we're going
119:01 - to need to access this so let's actually
119:02 - make this a member variable so private
119:05 - let's store it up here instead of making
119:07 - a local variable in here okay
119:09 - so we have this one and then down here
119:11 - on the input vector
119:13 - let's go inside the player input actions
119:15 - inside the player action map and then we
119:17 - called it move so we've got this one and
119:19 - then we defined it as a vector two so
119:21 - over here we can call read value and
119:23 - this one takes in the type of the value
119:25 - now we Define it as a vector two so
119:27 - let's read it as a vector two and just
119:29 - like this this returns a vector 2 which
119:31 - is really going to be our input Vector
119:33 - so let's put it exactly like this and we
119:36 - can now get rid of the rest of it all
119:39 - right so that's it and just like this we
119:40 - should already have everything working
119:42 - exactly the same as previously
119:44 - so let's just do a debug download just
119:46 - to make sure so let's test so here we
119:49 - are and the output is zero zero now I
119:50 - press W there you go plus one minus one
119:53 - left right and all of the ones in
119:55 - between all right awesome so we have the
119:58 - new input system all of it working
119:59 - flawlessly also by the way over here we
120:02 - can normalize the input just like we
120:03 - were doing previously so we do it over
120:05 - here through code or alternatively we
120:07 - can also go into the player input
120:08 - actions and over here there's something
120:10 - called a processor so you can go into
120:12 - this action add a processor and make it
120:14 - normalized so these processes here can
120:17 - be quite useful I cover the modeling
120:19 - detail in the other dedicated video but
120:21 - over here let's stick with making it
120:22 - through code that works just as well
120:23 - okay so that's our refactoring done with
120:26 - that simple change we are now using the
120:28 - new input system
120:29 - so you can see how by refactoring our
120:31 - code to make sure to use the game input
120:33 - less when we change from the input
120:35 - manager onto the new input system when
120:37 - we made that change we did not have to
120:38 - touch a player class at all the player
120:40 - class just has the game input to get the
120:42 - movement vector and does not care what
120:44 - system he uses to get them so here we
120:47 - have a very practical very excellent
120:49 - example of the power of writing good
120:50 - clean code because we separated things
120:52 - correctly we managed to change something
120:53 - completely and not have to make any
120:56 - changes on any other class
120:57 - so now that we're using the new input
120:59 - system let's just quickly see one of the
121:01 - main benefits of this system which is
121:03 - easily supporting gamepads and more keys
121:05 - for example a lot of people like using
121:08 - ones but some people also like to use
121:09 - the arrow keys with this system that is
121:12 - super easy to add so let's go into the
121:14 - move what's another one let's add
121:15 - another one up down left right composite
121:17 - let's call it arrow keys then let's just
121:20 - put them so let's listen on the up Arrow
121:22 - then over here we've got the down arrow
121:26 - then we have the left arrow and finally
121:29 - we have the right arrow alright so we've
121:31 - got all the arrows and now we don't even
121:33 - need to touch any code at all let's just
121:35 - make sure to save the ascent which again
121:37 - in turn that is going to Auto generate
121:39 - the c-sharp class and go into compound
121:40 - okay so we don't need to touch any code
121:42 - at all let's just hit on play and now if
121:45 - I move we're using the ones Keys yep
121:47 - still works and if I go into the arrow
121:48 - keys yep also still works alright great
121:51 - now for another one let's make it for a
121:53 - Gamepad so I just connected an Xbox
121:56 - controller and we can see over here on
121:58 - the log yep the game did identify it so
122:00 - this is the new input system in action
122:01 - let's once again open up the input
122:04 - actions and over here on the Move let's
122:06 - add another one and this time let's just
122:08 - make it a regular binding and over here
122:10 - on the path once again if we want we can
122:13 - go down here and specifically find some
122:15 - joysticks so you can find any of them or
122:17 - once again let's just use in listen now
122:20 - I'm just going to move the thumbstick on
122:21 - the controller yep there it is I know if
122:23 - you wanted you could go specific and
122:24 - make it just work with Xbox controllers
122:26 - or you can just use the generic left
122:28 - stick this will make it work with an
122:30 - Xbox controller or a PlayStation or
122:31 - really anything so let's go with this
122:33 - one and that's it nothing else we need
122:35 - to do let's just save the asset and
122:37 - that's it we don't need to touch any of
122:39 - our code to make our game playable with
122:40 - a controller so let's go ahead and test
122:43 - so here we are and first of all if I
122:45 - move the keys yep song Works move the
122:46 - arrow keys yep both of them works and
122:48 - now if I use my Gamepad any up there you
122:51 - go everything works perfectly alright
122:53 - awesome so as you can see this is one of
122:55 - the main benefits of the new input
122:57 - system it makes handling different
122:58 - inputs really super easily as you saw we
123:01 - didn't have to touch our code at all we
123:03 - just had new bindings and just like that
123:05 - our game is playable with all kinds of
123:07 - inputs
123:08 - so here you can really see just how
123:10 - powerful new input system is okay so
123:12 - with this our basic character movement
123:14 - is working great we can walk around
123:15 - everything looks great now in the next
123:18 - lecture let's apply some collisions to
123:19 - our player
123:22 - hey again here's another quick
123:23 - intermission I hope you've already
123:25 - learned a ton from the course have you
123:27 - seen the benefits of writing good clean
123:29 - code has the course already helped you
123:30 - understand some more advanced concepts I
123:33 - really hope the answer is yes to both
123:34 - those remember to follow the website
123:36 - page as you follow along I won't be
123:38 - adding frequently asked questions to
123:39 - every lecture if you ever get stuck you
123:42 - can just download the project files for
123:43 - a lecture and compare with your own and
123:45 - definitely check out the related videos
123:47 - when I reference them this course is
123:49 - focused on making this game but you
123:50 - should definitely learn more about some
123:52 - of these Concepts in more detail and you
123:54 - can learn that in the videos that I
123:55 - mentioned by the way if you're watching
123:56 - this right now this is the secret con
123:59 - loud so go ahead post the time step in
124:00 - the comments with a nice monk Emoji I
124:02 - want to see how many people make it this
124:04 - far okay so that's it for now let's go
124:06 - to the next lecture
124:08 - hello and welcome I'm your code monkey
124:10 - in this lecture we're going to apply
124:12 - some collisions to our player movement
124:14 - okay so here we have our game so far we
124:17 - have our player walking around and
124:18 - everything looks pretty good however now
124:20 - let's create over here in the hurricane
124:22 - let's right click create a brand new
124:24 - Cube so there you go let's place it over
124:26 - here and push it down okay there's the
124:30 - cube make it just a little bit bigger so
124:33 - there's the cube and by default it has a
124:34 - boxcon leather component so it has
124:36 - physics and the player if I move and
124:39 - nope there's our issue the player is
124:40 - going right through the object now the
124:42 - player is not meant to be a ghost so
124:44 - let's fix this over here in our player
124:46 - script we are hearing the input Vector
124:49 - calculating the move Direction and then
124:50 - just moving the transform so right now
124:52 - we're moving it no matter what now
124:54 - before we do that let's first do a test
124:56 - to see if any object is in the way and
124:58 - how we're going to do that is by firing
125:00 - a raycast this one is a physics
125:02 - operation that basically fires on laser
125:04 - from a certain point towards a certain
125:06 - direction and then tells you if it hits
125:07 - something how we do that is let's go
125:09 - inside the physics class and let's call
125:12 - the raycast function
125:14 - this one as you can see has many many
125:16 - versions of this function with all kinds
125:18 - of parameters let's use this one option
125:19 - number seven which takes a vector 3 for
125:22 - the origin a direction and a max
125:23 - distance so first for the origin that is
125:26 - from where we want to fire our recast
125:28 - let's put the player object in so that's
125:30 - transform dot position
125:32 - then for the direction this is going to
125:34 - be our move Direction so let's use our
125:35 - move there and finally for distance
125:37 - let's use some kind of player size
125:40 - player width something like that
125:42 - some lights to find up here a float for
125:44 - the player size and put that 0.7 units
125:48 - let's try out with the size just like
125:50 - this okay so basically this returns a
125:52 - Boolean it's going to return true if it
125:54 - hits something and funks if nothing is
125:56 - in the way so let's just do a bone call
125:58 - it can move and basically we can move if
126:01 - this raycast doesn't hit anything so we
126:03 - can move if this one is false so if the
126:05 - raycast is false then can move is going
126:07 - to be true
126:09 - that's very simple so if we can move
126:11 - then we move the transform position
126:12 - otherwise we don't okay that's it super
126:15 - simple Let's test
126:16 - so here we are I can move around and if
126:18 - I go towards the cube and nope no longer
126:20 - works so I can no longer go inside that
126:22 - Cube okay great now in your case if it's
126:25 - not working
126:27 - first of all make sure that the cube
126:29 - make sure it is touching the floor we
126:31 - use the transform position as the origin
126:33 - which is right on the floor so if the
126:35 - box is raised up then you won't be able
126:36 - to go through so make sure the cube is
126:38 - touching the form also make sure the
126:40 - cube has a box on leather component it
126:42 - can be any type of calendar but you if
126:43 - you made a cube then it should have a
126:45 - box layer by default and it should have
126:47 - the same shape as the visual
126:49 - and also remember that the 2D and the 3D
126:51 - physics systems those are completely
126:52 - separate they are completely different
126:54 - worlds so make sure you're using 3D
126:56 - components and not the 2D ones so for
126:58 - example if I add boxing weather 2D if I
127:01 - add this one then it will not work so
127:03 - make sure you're using the 3D and not
127:05 - the 2D components same thing over here
127:07 - on the script make sure you're using
127:08 - physics and not physics 2D also finally
127:11 - if you're still having issues make sure
127:13 - you check the player position
127:14 - again the player should be on a y of
127:16 - zero the only thing that might have an
127:18 - offset is the player Vision although if
127:20 - you're using the same acid me then this
127:22 - one should also be on a y of zero so all
127:23 - of these on y of zero and then you can
127:26 - also check the four by default this one
127:28 - has a mesh calendar but if it is exactly
127:30 - on yf0 with no rotation then it
127:32 - shouldn't cause any issues alternatively
127:34 - you can also just disable or remove the
127:36 - mesh con leather from before since we're
127:37 - not going to need that so with all that
127:39 - yep everything works I can move the
127:40 - player but I cannot go through solid
127:42 - objects alright awesome so it is working
127:45 - but for this particular use case a
127:47 - recast isn't necessarily the best method
127:49 - we should use basically Rick asses like
127:52 - I said kind of like a super thin laser
127:54 - but as you can see the player visually
127:56 - has an actual body shape so the visual
127:59 - and logic are using can only in
128:00 - different shapes if I go ahead and push
128:02 - towards the box you can see it works
128:04 - just fine however if the player is a bit
128:07 - more off to the side and the center of
128:08 - the player right in front of it is not
128:10 - the box and I move and yep there you go
128:12 - now I am going through the box the
128:14 - reason is because the erase accounts
128:15 - being fired from the center of the
128:16 - player and like I said it's kind of like
128:18 - an infinitely thin laser so it has no
128:20 - shape so as long as the center of the
128:22 - player is not hitting the box and it can
128:24 - go through it whereas what we really
128:26 - want is for the visual and logic to have
128:28 - pretty much the same shape so let's not
128:31 - use a raycast over here on the code
128:33 - instead of a recast we can use a physics
128:35 - query with an actual shape
128:37 - there are all kinds of casts you can use
128:39 - as you can see all of them with
128:41 - different shapes you've got a box cast
128:42 - if you want to have a box a capsule if
128:44 - you want the capsule or a sphere cast
128:45 - all of these were pretty much the exact
128:47 - same way except instead of a raycast
128:50 - which fires an infinitely thin laser
128:51 - these are going to have an actual shape
128:53 - and for player controllers for the most
128:55 - part you really want to be using a
128:57 - capsule cast that's usually the
128:58 - generally accepted player shape although
129:00 - alternatively a boxcast also can work
129:02 - very well in our case let's just go with
129:04 - a simple capsule cast this one to define
129:06 - a capsule has a 0.1 and a 0.2 by the way
129:09 - if you have no idea what is a capsule
129:11 - then we can go over here in the
129:12 - hurricane let's right click create a 3D
129:13 - object let's make it a capsule and there
129:15 - you go this is the capsule it's kind of
129:17 - like a stretch sphere so it has around
129:19 - the top round bottom and then over here
129:21 - in the middle it's just a cylinder and
129:23 - over here for the raycast takes a 0.1
129:25 - and a 0.2 so that is going to be the
129:27 - bottom of the capsule and the top of the
129:28 - capsule basically with those two points
129:30 - we can Define the height of the actual
129:32 - capsule okay so let's just get rid of
129:34 - this capsule let's just lean it and over
129:36 - in the code let's put those now 4.1 it
129:39 - is indeed going to be the transformed
129:41 - opposition since that is the point at
129:42 - the bottom and for the second point
129:45 - for this one it's essentially going to
129:47 - be the player head so we can take the
129:49 - transform dot position so this is the
129:51 - bottom and we can essentially just lift
129:53 - it up so let's add a vector 3 dot up and
129:56 - multiply by some kind of player height
129:58 - let's define up here a float for the
130:00 - player height
130:02 - and I tested it in the editor and the
130:04 - player is about T and Stone
130:06 - so over here let's go ahead and move it
130:07 - up by that much
130:09 - okay so next we want the radius so this
130:12 - is pretty much the player size that we
130:13 - defined previously so let's use the same
130:15 - thing
130:16 - but as always let's make sure to write
130:17 - good clean code since now we are
130:19 - referring to a radius let's actually
130:21 - rename this to be a bit more clear and
130:23 - by the way here's a quick Visual Studio
130:25 - tip you can right click on a symbol and
130:28 - then you can click on the rename option
130:29 - alternatively use a shortcut Ctrl R
130:32 - control R if you do that then now you
130:34 - can change the name so for example on
130:35 - player radius and note how it changes
130:37 - every single instance of that variable
130:40 - so this renaming feature is extremely
130:42 - useful always make sure to rename
130:44 - something if you find the name that
130:45 - works best Okay so let's rename this to
130:47 - play radius then we have Direction so
130:50 - that is as usual going to be our move
130:51 - Direction
130:52 - and then finally we have the move
130:54 - distance for that we can use the actual
130:56 - move distance so that is going to be the
130:58 - movement speed multiplied by time dot
131:00 - all the time
131:01 - so I just find here a fluid for the move
131:03 - distance
131:05 - and you should see that just move speed
131:07 - time dot Delta time we have the move
131:10 - distance and we use it both in here as
131:12 - well as down here
131:13 - okay so here we have our cancel cast the
131:16 - rest logic is exactly the same so if
131:18 - this one is false that means it didn't
131:19 - hit anything so if it didn't hit
131:21 - anything then we can move and then we
131:23 - move the transform okay let's test and
131:26 - over here now if I go towards the box
131:27 - and the Epson works is only the same as
131:29 - previously that's great and now if I go
131:30 - towards the end and make sure that the
131:32 - center is not hitting the box and I try
131:34 - to move forward and nope now we no
131:36 - longer go inside the cube so even on the
131:38 - edges everything still works perfectly
131:39 - alright awesome so it works it looks
131:43 - good but it also is a little bit janky
131:45 - for example let's stretch this cube out
131:47 - a little bit so let's put it just on One
131:50 - Direction so stretches like this let's
131:53 - see now if I move towards it then nope I
131:55 - cannot go through it so that is correct
131:57 - and if I move left and right yep that's
131:59 - also correct that works however if I now
132:01 - press W and D at the same time in order
132:03 - to move diagonally and nope right now it
132:05 - does not move the reason is because the
132:07 - diagonal Vector that one is indeed
132:09 - hitting the collider but usually in
132:11 - games when you move diagonally and you
132:13 - cannot move in when Direction then it
132:14 - tries to essentially hug the wall and
132:16 - move around it so if I press wnd it
132:19 - should essentially be moving straight to
132:20 - the right so let's solve that so here in
132:22 - our code we're making our Capstone cast
132:24 - okay that's great then we need to test
132:26 - if we cannot move so let's see if we
132:29 - cannot move so it can move is false
132:33 - if so then that means we cannot move
132:36 - towards this direction
132:40 - and if we can then essentially we
132:41 - basically want to split the movement
132:43 - Direction and just move on the X or just
132:45 - on the Z so first let's attempt just the
132:48 - X movement
132:49 - so attempt only X movement let's create
132:53 - a new vector 3.
132:55 - let's call it move the year X and we
132:57 - make a new Vector three let's take in
132:59 - the move there dot X then zero on all
133:02 - the other so we only want the test
133:03 - moving in the X Direction
133:05 - and then let's do literally the same
133:07 - thing so let's get our can move try to
133:10 - move under this direction so let's go
133:12 - inside a move there move there on the X
133:14 - so we do that capsule cast
133:16 - and if we can move then that means we
133:19 - can move only on the x-axis
133:22 - so can move only on the X
133:25 - and if so let's set the move there
133:27 - equals the move there X
133:30 - so if we can move them down here when we
133:31 - use the move there we're going to move
133:33 - only on the X
133:34 - and if we cannot move
133:36 - then that means we cannot move only on
133:38 - the X
133:39 - and if so then let's attempt only Zed
133:42 - movement so over here again let's do the
133:44 - exact same thing so let's copy this
133:46 - let's just change this one so instead of
133:48 - move to your X we've got moved here on
133:50 - the Zen so over here we use 0 on the X 0
133:53 - and Y and axis we moved here and get the
133:55 - Zen then let's use this movement
133:58 - Direction over there and finally the
134:00 - same thing so if we can move
134:03 - then that means we can move only on the
134:05 - Zen and let's set the move there equals
134:08 - the move there Z
134:10 - and if not then we cannot move in any
134:13 - direction
134:14 - okay so that's it now this might seem a
134:17 - bit confusing but it becomes a lot more
134:18 - clear When You See It In Action again
134:20 - remember the scenario we're trying to
134:21 - solve which is when moving diagonally so
134:24 - for example when we're moving forwards
134:25 - into the right if we do that then let's
134:27 - say this one is going to hit something
134:28 - so we cannot move so if we are trying to
134:31 - move both forwards and to the right then
134:33 - we're going to only attempt the X
134:34 - movement so we're only going to try
134:35 - moving to the right and then we're going
134:37 - to see yep going to the right that does
134:39 - work so we can move and we're going to
134:40 - move just to the right all right so
134:42 - let's test and see if all of this is
134:44 - working all right so here we are and if
134:46 - I move straight to the wall and nope
134:47 - there is 11 so I cannot move anymore
134:49 - okay great now if I move just left and
134:51 - just right and it does work now if I
134:53 - press W and then D and if there you go
134:55 - now it does hug the wall and continues
134:57 - to move same thing if I go on the left
135:00 - over here if I press D no I cannot go
135:02 - through it now if I press D and S at the
135:04 - same time and there you go it hugs the
135:05 - wall and moves around so now our
135:07 - controller is much more easy much more
135:09 - understandable
135:11 - okay so this is great now this is one of
135:13 - those tiny things that makes your
135:14 - character controller feel much more
135:16 - responsive so that's great however we
135:18 - also do see one more issue right now you
135:21 - can see that I'm right next to the wall
135:22 - and if I press A and D then look at that
135:24 - I'm moving with this spin however now if
135:27 - I press wnd look at that now I'm moving
135:29 - diagonally and it's actually moving
135:31 - slower basically this is the same issue
135:33 - that we saw previously where we had to
135:34 - normalize the input so we didn't go
135:36 - faster in diagonals basically now we
135:38 - have the opposite problem since we are
135:40 - normalizing the vector we are cutting
135:42 - down on the left right vector and with
135:44 - that basically if we are moving
135:45 - diagonally then we are essentially going
135:47 - slower whereas if I stop moving diagonal
135:49 - and just move left right it moves at a
135:51 - different speed that solution for this
135:53 - is really super simple over here in our
135:55 - code when we are constructing the move
135:57 - to your X and move the ears in when we
135:59 - do this very simple let's just normalize
136:01 - it so if this one is less than one then
136:03 - it won't be going into one so let's
136:04 - normalize that one and down okay that's
136:07 - it let's test and now from here move
136:09 - forward and hug the wall on left right
136:10 - yep does work and if I stop moving
136:12 - diagonally just going left right yep all
136:14 - still works with the exact same speed
136:16 - all right awesome okay so that's really
136:19 - it as you can see it's super simple to
136:21 - add Collision detection to your movement
136:23 - scripts you just do a physics query to
136:25 - testify our character should move and
136:26 - just move it by the way if you want to
136:28 - learn more about collisions and physics
136:30 - queries there's a bunch of interesting
136:32 - videos that you can watch for example
136:34 - one is on various methods of finding a
136:36 - Target then another one is on various
136:38 - methods of handling projectiles and
136:40 - finally another one is a very quick
136:42 - checklist on why collisions are not
136:43 - working basically there's lots of really
136:45 - interesting things you can do with
136:47 - physics so make sure you understand
136:48 - these functions okay so now that we have
136:50 - all of this working let's first just
136:52 - clean up our scene so over here our
136:54 - default Cube we don't want this so let's
136:56 - just get rid of this and with this we
136:58 - are ready to build our first kitchen
137:00 - counter and let's do that in the next
137:01 - lecture
137:03 - hello and welcome I'm your code monkey
137:05 - in this lecture we're going to begin
137:07 - building one of our main game mechanics
137:09 - we're going to make a kitchen counter
137:10 - and handle the logic for the player to
137:12 - be able to interact with that counter
137:14 - okay so let's begin by making our
137:16 - kitchen counter and just like we did
137:18 - when we made the player let's first make
137:20 - an empty game object and place the
137:21 - visual inside of it so let's right click
137:23 - on the hierarchy and create an empty
137:25 - game object call this the clear counter
137:27 - so it's going to be clear on top so we
137:28 - can place and pick up objects let's make
137:31 - sure to reset our transform so let's put
137:33 - it on zero zero zero let's move it just
137:35 - a little bit just so it's not exactly on
137:36 - top of the player okay now inside let's
137:39 - add the visual so let's go inside the
137:40 - assets folder and then over here we've
137:42 - got the prefabs visuals and inside we've
137:44 - got the counters visuals and over here
137:46 - let's find the clear counter Vision so
137:48 - let's go ahead and drag it inside the
137:50 - game object again make sure the
137:52 - challenge visual is on zero zero zero
137:53 - the unlockable position okay great now
137:56 - just like we did in the online lecture
137:58 - where we added Collision detection that
138:00 - shouldn't already be working by default
138:01 - but in order for it to work it needs a
138:02 - physics line either however note how the
138:05 - vision over here there's no collider and
138:07 - inside there's no collider there's only
138:08 - visuals again this is the same thing
138:10 - that relates to separating logic and
138:12 - visuals basically the visual prefab this
138:14 - one only has visual components so only
138:16 - meshes animations and that sort of thing
138:19 - and the main Parent Game object this is
138:20 - the one that is going to have all of the
138:22 - logic components set means any kind of
138:24 - scripts Behavior as well as any
138:26 - colliders
138:27 - so over here on the parent game object
138:29 - let's add new component let's find a box
138:31 - Collider again make sure you add a box
138:33 - of leather not a boxing leather 2D and I
138:36 - chose a boxing Ledges because this is
138:37 - the shape that makes most sense for our
138:39 - counter and now let's scale the boxing
138:41 - leather again that's the boxing ladder
138:43 - not the transform so leave that one with
138:44 - a scale of one one that's good and over
138:46 - here on the box leather for the size
138:48 - let's put it up with a size that fits
138:50 - the visual so 1.5 1.5 1.5 and finally we
138:54 - just need to lift it up a bit over here
138:56 - on the scene view you can see those
138:58 - little green tiny lines these refer to
139:00 - the boxing leather shape so let's lift
139:02 - it up by a little bit in order to make
139:04 - it perfect let's put it up by 0.5 on the
139:06 - Y alright so there you go that one does
139:08 - have the perfect shape
139:10 - if we test just like this it should
139:11 - already be working it's okay so here's
139:13 - my player and if I move towards it and
139:15 - yep there you go it does work so it is a
139:17 - solid object I cannot go through it okay
139:19 - great
139:20 - let's just visually rotate the calendar
139:22 - so let's do that and again for rotation
139:24 - let's make sure we rotate the apparent
139:26 - game object and not the visual we want
139:28 - the visual to be on rotation zero zero
139:30 - zero okay great so on the parent game
139:31 - object let's just rotate it around by
139:33 - the way here's a quick empty tap if you
139:35 - want to rotate hold down control and
139:37 - then click to rotate and now instead of
139:39 - rotating on every angle it goes on a 15
139:41 - angle increment so just hold down this
139:44 - way you can easily get it to 180 degrees
139:46 - so it's just for fun just make it face
139:48 - the player okay great so now let's
139:50 - interact with this counter and doing
139:52 - this is actually super simple
139:53 - we already learned how to do a raycast
139:55 - to handle collisions and for
139:57 - interactions that's exactly the same
139:59 - thing
139:59 - so let's go into our player script and
140:02 - we're going to do a recast to handle
140:03 - that
140:04 - but before we do let's organize our code
140:07 - here let's make a proper function to
140:08 - handle our movement
140:10 - so let's make it private since this is
140:12 - going to be in local function return
140:13 - void and call it handle movement
140:17 - and then inside let's put all of this
140:19 - code so let's copy all this put it in
140:21 - there and then on update we simply call
140:23 - this function okay great and now let's
140:25 - make another function so private void
140:27 - let's call it handle interactions
140:33 - and we just call this function on our
140:35 - update okay great everything is much
140:37 - more organized so now here let's do a
140:40 - raycast
140:41 - so once again go inside physics do a
140:44 - raycast
140:45 - for the origin let's start on
140:46 - transform.position
140:48 - for this obviously we want the move
140:50 - Direction so an approach would be to
140:52 - make this a film variable sorted up here
140:54 - so that way we can access it in both
140:55 - functions however if you remember how we
140:58 - handled the whole issue with the
140:59 - diagonals basically we're modifying the
141:01 - move Direction so for moving diagonally
141:03 - then this one modifies to only move left
141:05 - or right we don't want that for the
141:07 - interaction we want pretty much the
141:09 - exact same one even if it's pointing
141:10 - towards a solid object so let's not make
141:12 - the same member variable only reuse it
141:14 - instead let's just grab it again create
141:16 - it again over here so we get it and we
141:18 - want this one even if it's pointing
141:20 - towards a solid object so let's use this
141:21 - as our move Direction
141:23 - and now for the distance let's define a
141:25 - fixed distance
141:27 - so something like two units would work
141:29 - and also here's another very important
141:31 - lesson with regards to writing good
141:32 - clean code so you would think to write
141:34 - code like this so let's put the two
141:36 - right in here that would work everything
141:38 - would work perfectly but then let's say
141:40 - you get back to this code after one week
141:42 - would you remember what this 2f means
141:44 - the answer is probably not you would
141:46 - probably very easily forget exactly what
141:48 - this means so because of that you should
141:50 - never use numbers directly in the code
141:52 - like this instead you can either make a
141:54 - field appear if you want to make it
141:56 - customizable
141:57 - or much simpler is actually what we
141:59 - already did previously so let's define a
142:00 - local variable with a proper name
142:03 - so let's define a float and this one is
142:05 - going to represent our interact distance
142:07 - so let's call it exactly that interact
142:08 - with the distance and let's put 2f and
142:11 - over here instead of using a number
142:13 - let's just use that variable now if we
142:15 - were to get back to this code after a
142:17 - long time it would be extremely clear
142:18 - what this parameter represents
142:21 - the technical term for what we did here
142:23 - is called Magic numbers and I've also
142:24 - covered them in detail in another quick
142:26 - video
142:26 - but as I always remember very simply
142:29 - never use magic numbers
142:31 - okay so with this we have our recast
142:33 - it's pointing forwards for this distance
142:35 - but this is actually not very useful
142:37 - because the rickhouse this one only
142:39 - returns a bullion so all this tells us
142:41 - is if there's something in front or not
142:43 - it does not actually get as the actual
142:45 - object reference so for that let's use a
142:48 - different version of the raycast
142:49 - function so as you can see we've got all
142:51 - kinds of versions in order to get the
142:53 - object reference let's use this version
142:55 - right here this one which has an out
142:57 - parameter for a raycast hit note the out
143:00 - keyword here this is important this
143:02 - means that this is an output parameter
143:04 - whereas the other parameters those are
143:06 - all essentially inputs that you give to
143:07 - the function whereas this output this is
143:10 - basically a value that the function
143:11 - outputs so let's use this so we've got
143:13 - the origin we've got Direction then
143:15 - we've got the rake asset in order to use
143:17 - it we need to make sure to write the out
143:18 - keyword here and then also very
143:20 - important we need to write the type
143:22 - so let's call it break asset and then
143:25 - the name so let's call it break asset
143:27 - basically what we're doing here is
143:29 - essentially defining a variable of this
143:31 - type with this name we're defining it
143:33 - and giving it to the function
143:34 - immediately so we can use it afterwards
143:36 - if you don't include the type if you
143:37 - just include the name then you get an
143:39 - error because this name Rick has said
143:41 - this was never defined alternatively you
143:43 - can Define it before you pass it in so
143:44 - over here you can do recast it recast it
143:47 - and just like this it works because you
143:49 - are defining it here and using it here
143:50 - but in order to make the code a bit more
143:52 - compact you can just Define it here in
143:54 - the same place where you get it okay so
143:56 - let's use this and with this the
143:58 - function still returns just a Boolean so
144:00 - just hit something or not but then we've
144:02 - got the rake asset output this will be
144:05 - filmed with data from the Collision if
144:06 - we do hit something
144:07 - we can inspect this to see what that it
144:09 - contains so you can right click on top
144:11 - of the type and then go to definition
144:13 - and up here we do see the definition for
144:16 - the rake acid struct you can see this is
144:18 - a structure to get information back from
144:19 - a raycast you can inspect this to see
144:22 - all of the kinds of things that this one
144:23 - returns for example you have a vector 3
144:26 - point for the impact point in workspace
144:27 - where the ray actually had a collider it
144:30 - can get the normal of the surface and so
144:31 - on so you can get all kinds of things
144:33 - for a use case what we want is to
144:35 - identify the object that we hit and for
144:37 - that we can use the transform so it's
144:39 - going to be the transform of the rigid
144:40 - body or the collider that was hit so
144:42 - let's just do a quick test if we hit
144:44 - something lets you unlock on that object
144:45 - so let's do an if so if this one is true
144:48 - then that means we hit something so if
144:50 - so let's do a debug unlock go inside the
144:52 - rake asset and log the transform okay so
144:55 - like this we should be able to see on
144:56 - the console if we do hit something let's
144:58 - also do an ounce just to be able to
145:00 - easily see when we hit something so on
145:03 - else let's just log an empty Dash and in
145:06 - our game in order to make sure that our
145:07 - Collision is working that we are
145:09 - correctly detecting it let's just
145:10 - duplicate this object but before we do
145:12 - let's make this a proper prefab if you
145:14 - have an object of a certain tab that you
145:16 - want to create multiple instances of it
145:17 - you should be using a prefab rather than
145:19 - just duplicate an object that way with
145:21 - the prefab if you make any changes to
145:22 - that prefab it applies to all of the
145:24 - copies of that prefab
145:26 - so let's first make this one a prefab
145:28 - and again since this is our first prefab
145:30 - let's first make a nice folder to keep
145:32 - things organized so folder for our
145:34 - prefabs and to make game module prefab
145:36 - is super simple you just click and drag
145:38 - directly from the hierarchy and drop it
145:40 - inside the folder there you go there's
145:41 - our prefront and now let's just
145:43 - duplicate this make sure it has a
145:45 - different name so it has one so that's
145:46 - enough with this we should be able to
145:48 - see it just for testing let's put it
145:49 - just off to the side okay so let's see
145:51 - so here we are in the console we see a
145:53 - dash so by default we are not hitting
145:54 - anything okay so that makes sense now if
145:57 - I move towards this object and if there
145:58 - you go it does I didn't find that object
146:00 - and if I stop moving it stops
146:02 - identifying okay great now if I move
146:03 - towards this one and if there we go this
146:05 - is the one with the name of one and this
146:07 - is the one with the name of none all
146:08 - right awesome so just like this we are
146:10 - correctly identifying what object is in
146:12 - front except we also have an issue so if
146:16 - I move towards the object then yep it
146:17 - does work but if I stop moving once I'm
146:19 - still facing that object right now it's
146:21 - returning none now the reason for that
146:23 - is because of the move data that we're
146:24 - using here if we're not moving in any
146:26 - direction then basically this Vector
146:28 - won't be zero zero zero so we're going
146:30 - to be firing a raycast towards no
146:31 - direction at all so obviously it's not
146:33 - going to hit anything the solution to
146:35 - that is super simple we just need to
146:37 - keep track of the last interact move
146:38 - Direction so let's go up here to find a
146:40 - film for that so let's make a private
146:42 - let's make a vector 3 and call it the
146:45 - last interact Direction
146:47 - and then down here when we have our
146:48 - handle interaction so we get the
146:50 - movement here okay that's great so then
146:52 - we just check if the move direction is
146:54 - different from Vector 3.0 by the way
146:57 - this is a constant a shorthand for zero
146:59 - zero zero so if it is not zero then that
147:01 - means we are moving in some Direction
147:05 - so so let's set the unless in direct
147:07 - direction to this move Direction and
147:09 - basically if it is not if move there is
147:11 - zero then we are not going to modify
147:12 - this so this one is only going to
147:14 - contain the unless interact Direction
147:15 - and then down here instead of using the
147:17 - move Direction Let's just use this one
147:18 - so that way even when we stop moving we
147:21 - are still going to be using the last
147:22 - indirect Direction okay so with this
147:24 - let's test so here we are and if I move
147:26 - towards it yep it works and if I stop
147:28 - moving and yep it still works alright
147:30 - great so we can move towards it Point
147:32 - towards a certain object and then yep it
147:34 - still works okay great now let's
147:37 - actually interact with this counter and
147:39 - to do that let's make a class for the
147:41 - counters itself so let's make a new
147:43 - script in the UC sharp script let's come
147:45 - with the same name so clear counter
147:49 - okay there's our script
147:50 - now very importantly for attaching the
147:53 - script remember that we have two
147:55 - instances of our prefab if you just
147:58 - select it in the heart key and you just
147:59 - drag it on there if you do that then
148:01 - you're not actually adding this script
148:03 - to the prefab itself you're only adding
148:05 - it to this specific instance of that
148:07 - prefab so if you look at this one yep it
148:09 - has a script but this other one which is
148:11 - a copy of the same prefab this one does
148:12 - not have it also over here on the
148:14 - inspector you can see the little script
148:16 - icon has a nice little plus that means
148:18 - it is something that you are adding on
148:20 - top of the prefab so that means this
148:22 - script is not present on the base prefab
148:23 - basically this is not what we want we
148:26 - don't want just this object to have this
148:28 - script we want all instances of this
148:30 - prefab to have this script so instead
148:32 - let's get rid of this one from here we
148:35 - want to modify the prefab itself so one
148:37 - way to do that is to select the prefab
148:39 - on the project window so here it is the
148:40 - actual prefab and now we can drag the
148:43 - script on there so that works or another
148:45 - alternative is something like the prefab
148:47 - in the hierarchy and on the inspector
148:49 - over here we see a nice button to open
148:51 - the prefab and if we actually go into
148:53 - scene view then we can see what that
148:54 - does so with the object selected so this
148:56 - is an instance of that prefab but if we
148:58 - click on open then essentially we are
149:00 - opening and we are working inside the
149:01 - prefab so now if we make sure to add our
149:04 - script and let's go back outside this
149:06 - prefab so on the top left corner over
149:08 - here we can see where we are so we were
149:10 - inside our scene and then we are inside
149:11 - the clear counter prefab so if we click
149:14 - on the scenes we can go back now it
149:16 - tells us that we made some changes to
149:17 - the prefab so let's save them and if we
149:19 - add that script and we can see both
149:21 - instances of the prefab they both have
149:22 - the same script and we can see on there
149:24 - on the icon that this is not an override
149:26 - this is an actual script at on the base
149:28 - prefab so whenever working with prefabs
149:30 - always make very sure that you are
149:32 - adding it on the right place
149:33 - if you want something on the base prefab
149:35 - make sure you either add it on the
149:37 - prefab itself or go inside the prefab by
149:39 - double clicking on it or select an
149:41 - instance in there and open to go inside
149:42 - the prefab so always keep in mind
149:44 - different switches between a prefab and
149:46 - an instance of a prefab okay so we have
149:48 - our script let's open it and over here
149:50 - let's just make one super simple
149:52 - function
149:53 - so let's make it public because we want
149:55 - to call this from our player class let's
149:57 - return void and just call it interact
150:00 - okay that's it super simple for now
150:02 - let's just do a debug.log and just say
150:05 - interact
150:06 - okay so that's it and now over here on
150:08 - the player when we have our handle
150:10 - interactions function so interact we do
150:12 - our raycast and we find out if we hit
150:14 - something so when we do the first thing
150:16 - that we should do is identify what this
150:18 - transform is so is this something just
150:20 - like a dumb Cube or is it an actual
150:22 - counter now when it comes to identifying
150:24 - things this is another place where a lot
150:26 - of beginner tutorials will teach you to
150:28 - use the unity attack system so that's
150:30 - over here in the editor when you select
150:32 - any object over here in the inspector
150:34 - you can see a tag so you can see
150:35 - untagged and you can add all kinds of
150:36 - tags this is something that a lot of
150:38 - beginner tutorials teach but Unity tags
150:41 - are horrible you should never never use
150:43 - them I covered in more detail why that
150:45 - is in the advanced concepts video the
150:48 - main reason is because of well pretty
150:49 - much the same thing that I mentioned a
150:51 - while ago when we were handling animator
150:52 - parameters so you were doing this and I
150:54 - talked about how this one takes a string
150:56 - and how strings are horrible way for
150:58 - identifying objects they are very
151:00 - brittle very error prone it's very easy
151:02 - to make mistakes and tags have the exact
151:04 - same problems because tags are strings
151:06 - so we do not want to use tags to
151:08 - identify objects instead over here on
151:10 - the player script let's use a different
151:12 - method for identifying objects and the
151:14 - best way to do that is to Simply get our
151:15 - counter component
151:17 - so we have our transform and then from
151:19 - inside that transform we can call the
151:21 - function try get component this one then
151:24 - takes the type of component and again
151:26 - note how this is an out parameter so
151:28 - let's put out and we want to test if
151:30 - this is a type clear counter so clear
151:32 - counter and call it clear counter
151:34 - and this one basically does the same
151:36 - thing as a recast so it returns a
151:38 - Boolean so either true or false
151:40 - so if this one is true then that means
151:42 - that object has that component so over
151:44 - here we know has clear counter
151:47 - by the way if you're not familiar with
151:49 - tryget component this is pretty much the
151:50 - same thing as the regular get component
151:52 - except it automatically handles the null
151:54 - check for you
151:55 - so if we just did this it's exactly the
151:57 - same thing as this so you do an if
152:00 - recast it what's X is a transform get
152:02 - component
152:06 - component of type clear counter
152:10 - naturally this one is not inside now but
152:12 - let's store this
152:14 - well your counter equals this then you
152:16 - do if this one is not known
152:19 - then we know has a clear counter
152:22 - so basically what we have up here is the
152:24 - exact same thing that we have down here
152:25 - so just using trigate component it's
152:27 - just a bit more Compact and I find much
152:29 - easier to read than to always get
152:30 - component and test if it is not null
152:32 - over here we just have one function with
152:34 - a nice out parameter and everything
152:35 - works perfectly so that's the try get
152:37 - component I much prefer that method so
152:39 - let's use that by the way on the trackit
152:41 - component over here you can see it has a
152:43 - type inside some angle brackets
152:44 - basically these are called c-sharp
152:46 - generics these are an extremely powerful
152:49 - c-sharp tool I have a dedicated video on
152:51 - them and I've used them in tons of
152:53 - videos definitely go ahead and learn
152:54 - about them basically this lets you write
152:57 - code that works with many classes not
152:58 - just one specific type in this case the
153:00 - target component can work with any type
153:02 - of component
153:03 - so it can be Unity built-in components
153:05 - or it can be components that you made
153:07 - yourself then if it finds a type it
153:09 - returns true so for right now it's not
153:11 - strictly necessary to know the specifics
153:13 - about how c-sharp generics work but
153:16 - definitely make sure you add that video
153:17 - to your queue and watch it afterwards
153:18 - c-sharp generics are an extremely useful
153:20 - c-sharp feature okay so we do this and
153:23 - basically if we are inside of here then
153:24 - we know this object has a clear counter
153:26 - and we have our clear counter reference
153:28 - so over here it's super simple let's
153:29 - just call the interact function
153:32 - alright so that's really it let's just
153:34 - get ready else we no longer want that
153:35 - log so we should be able to see unlock
153:36 - whenever we call our interact in a
153:38 - counter alright so here we are and if I
153:41 - move around okay that's good over here
153:42 - the console is empty all right now if I
153:44 - move towards the counter if there you go
153:46 - I'm interacting with it and if I move
153:47 - towards this one if there you go
153:48 - interacting all right great so with this
153:50 - we are correctly identifying the object
153:52 - and interacting with it now let's just
153:54 - do one final thing over here we are
153:57 - doing a recast to find the counter
153:59 - and right now we are doing a raycast
154:01 - towards any object that has any kind of
154:03 - physics calendar
154:05 - so maybe that's our counter or maybe
154:06 - just a random wall for example if we had
154:09 - an invisible wall in front of our
154:11 - counter then this code would not work
154:13 - that's because this raycast and this
154:14 - raycast set it only Returns the very
154:17 - first object that it does hit so if the
154:19 - counter was behind the wall then the
154:20 - brake acid object here would be a
154:22 - reference to that long object perhaps
154:24 - that's what you want or perhaps not in
154:26 - that scenario one thing you can do is
154:28 - instead of using recast you can use the
154:30 - function raycast all
154:32 - and difference for this one is instead
154:33 - of returning just a Boeing just true or
154:35 - false instead it returns an array of all
154:37 - of the objects that it hit with that
154:39 - raycast then you could cycle through
154:40 - them and identify the object so that's
154:43 - one approach or another option is over
154:45 - here on the recast
154:47 - if we look at these function versions We
154:50 - can see that some of them has what it's
154:51 - called a layer mask basically you can
154:54 - set a certain game object to a specific
154:56 - layer and then if you're using layer
154:58 - mask then you can make sure this recast
155:00 - will only hit objects within that layer
155:01 - anything not on that layer will be
155:04 - ignored for that recast this is super
155:06 - useful so let's learn how it works for
155:08 - layer mask we can go up here and Define
155:10 - a type of layer mask so let's make
155:12 - another serialized field private let's
155:15 - make it of type layer mask let's call it
155:17 - the counters layer mask
155:20 - okay so we have this and then down here
155:22 - when we have our recast let's use it so
155:25 - let's find the function that matches up
155:27 - these parameters with the layer mask so
155:29 - here it is we have the origin then we
155:31 - have Direction Drake acid the max
155:33 - distance and then finally we have our
155:35 - layer mask and let's use our counters
155:37 - layer mask okay great now back in the
155:39 - editor let's select our player game
155:41 - object and yep there we see our field of
155:43 - type layer mask and you can see how we
155:45 - can select all kinds of layers and how
155:48 - we set these layers to an object is
155:49 - let's just select our clear counter
155:51 - although again we want to make sure that
155:53 - this change applies to all encounters
155:55 - not just this one specific instance so
155:57 - let's go inside the prefab and over here
155:59 - we've got a Film Forum layer and you can
156:02 - see we've got a bunch of default layers
156:03 - and then we can add some more so let's
156:05 - add some layers and over here let's go
156:07 - to the first empty one and let's call it
156:09 - counters okay we've added the layers so
156:11 - let's go back select our object and now
156:13 - on the layer let's put it on the
156:14 - counters now it asks you if you want to
156:16 - modify the layer for all Channel objects
156:18 - now since we made sure to keep the Dean
156:21 - logic and physics components only on the
156:22 - parent object let's just modify this one
156:24 - and leave the other ones on the default
156:26 - so let's just modify this object only
156:28 - okay so with that our counter is now on
156:30 - the counters layer let's leave the
156:32 - prefab make sure to save it okay great
156:33 - and now if we go back into the player
156:35 - and over here on the counters layer mask
156:37 - yep we do see the counters layer so
156:39 - let's just click the selected by the way
156:41 - this drop down menu can actually select
156:43 - multiple so you can select all kinds of
156:45 - layers so this is multi-select but we
156:47 - only want to counter so only like this
156:49 - and just like this if we do test and if
156:52 - I move towards it and if there you go
156:53 - get the nice interact on both them so
156:55 - everything still works is only the same
156:56 - but now if we had another physics on
156:58 - leather in front of it it would still
157:00 - work because we're using a layer mask to
157:01 - only recast against counter objects
157:03 - alright great now I should point out
157:06 - another way to work with layers is with
157:08 - something called a bit mask that's a bit
157:10 - more advanced usually the layer mask is
157:12 - much easier to follow but if you want to
157:14 - learn about bitmask go ahead and watch
157:15 - that video and also another quick note
157:17 - in this game we're only going to
157:19 - interact with one single object type
157:20 - it's only going to be a counter even
157:22 - though we're going to have multiple
157:23 - types of counters but for games where
157:26 - you want to interact with multiple
157:27 - objects like for example having an
157:29 - interact action to talk with an NPC
157:31 - another one to open a door or push a
157:33 - button for those kinds of multiple
157:35 - interactions to build the system like
157:36 - that make sure you look into my how to
157:38 - interact with objects video it covers
157:40 - how to do all of that how to interact
157:42 - with all kinds of objects it's all based
157:44 - on c-sharp interfaces which we're
157:45 - actually going to use in a few lectures
157:47 - and also have a dedicated video on that
157:49 - topic so keep following this course but
157:51 - then make sure to watch those videos add
157:53 - them to your watch list and make sure
157:54 - you do watch them watch out how to
157:56 - interact video it is something that is
157:58 - necessary in so many games and most
157:59 - tutorials don't actually teach you the
158:01 - correct way of doing it anyway so back
158:03 - in our game we are correctly identifying
158:05 - and interacting with each counter but
158:07 - obviously we don't want to interact
158:09 - automatically just like this instead we
158:11 - want to press a nice button to interact
158:12 - so that means we're going to need to
158:14 - create an interact input action so let's
158:16 - do all of that in the next lecture
158:19 - hello and welcome I'm your code monkey
158:21 - in this lecture we're going to create a
158:23 - proper interact input action and in
158:25 - doing so we're also going to learn about
158:27 - a very powerful and c-sharp feature
158:28 - called events
158:30 - okay so here we have our game so we have
158:32 - the player and if we move towards the
158:34 - counter yep we are correctly identifying
158:36 - it and interacting with it except of
158:38 - course we don't want the interaction to
158:39 - happen automatically it should be on a
158:41 - player input so let's make our interact
158:43 - action let's go inside our player input
158:46 - action so let's double click on it and
158:48 - let's make a brand new action so we've
158:49 - got to move and now we're going to have
158:50 - another one so let's click on the plus
158:52 - icon for this one let's call it interact
158:54 - and for this one action type we do want
158:56 - it to be a button okay great then on the
158:59 - default binding let's go into path let's
159:01 - listen and by default let's bind it to
159:03 - the E key just like so many games so
159:05 - let's go ahead select this one and once
159:07 - again let's make sure to save the asset
159:09 - and let the C sharp OS be generated okay
159:12 - and over here in our game input script
159:14 - in order to listen that is very simple
159:16 - so we go inside the player input actions
159:18 - then inside the player action map and
159:21 - then we can find the interact action
159:23 - and then over here we can see a whole
159:25 - bunch of events that we can interact
159:27 - with we've got these three cancel
159:29 - performed and started these are the
159:31 - three phases of every input again I
159:34 - cover these stages in detail in the
159:36 - input system video the important thing
159:38 - is that these are c-sharp events which I
159:40 - also covered in another dedicated video
159:42 - essentially they are a way for how you
159:44 - can write code to then get notified when
159:46 - something happens rather than running
159:48 - code on every single update constantly
159:50 - testing something for example over here
159:52 - on the movement movement is a
159:54 - pre-constant action so it does make
159:56 - sense to ask the input on every single
159:58 - update if any movement is pressed but
160:00 - for an action like the interact the
160:03 - player is only going to press that say
160:04 - once every five seconds so it makes no
160:06 - sense to constantly check for that
160:08 - action on every single update instead we
160:11 - just want to be notified when that
160:12 - action is triggered and that is exactly
160:14 - what an event does again watch the
160:16 - dedicated video to learn all about
160:18 - c-sharp events in detail they are
160:19 - insanely powerful and we won't be using
160:21 - them more and more as we go through this
160:23 - course
160:23 - for now here are the absolute Basics
160:25 - events have Publishers and subscribers
160:28 - the publisher creates and fires the
160:30 - event when something happens and the
160:32 - subscriber listens that event and gets
160:34 - the enlisting function called when the
160:35 - event is fired now on the generated
160:37 - c-sharp class we've got these three
160:39 - events the one that we want for this
160:42 - case is the performed event so let's go
160:44 - into this one and basically we want to
160:46 - add a listener to that event
160:48 - and we can subscribe to that by doing
160:50 - plus equals so this assigns a listener
160:52 - to that event and now Visual Studio has
160:54 - a nice shortcut so if we press on Tab if
160:56 - there go it automatically creates a
160:58 - function now if you're not using visual
161:00 - studio you can just manually write this
161:01 - function the only thing you need to make
161:03 - sure is that the function signature
161:04 - personally matches the event signature
161:06 - as usual we can inspect the event so we
161:08 - can right click on it and go to the
161:10 - definition and up here is the definition
161:12 - and you can see that this is an event of
161:15 - type action with a combat context action
161:17 - is what is called a dungit I also have a
161:20 - video on delegates if you want to learn
161:21 - more about them in detail for now we
161:23 - don't really need to worry about what is
161:24 - delegate we just need to use it so in
161:26 - order to subscribe to the event we need
161:28 - to make sure that this one returns voyne
161:30 - because an action returns void and needs
161:32 - to have a parameter of this type combat
161:34 - context if I erase this parameter if
161:37 - there go now we have an error because
161:39 - the function signature does not match so
161:41 - it always needs to match the exact same
161:42 - signature okay and also one more note
161:45 - over here when subscribing to the event
161:46 - make sure you only add the function name
161:48 - meaning you do not add parentheses we do
161:51 - not want to count function we just want
161:52 - to pass in the function itself as a
161:54 - reference okay so now when the player
161:56 - presses the interact action it's going
161:57 - to fire off this event which in turn
161:59 - will call this function so over here
162:01 - let's do a debug download just see what
162:03 - this contains for example let's print
162:05 - out the compact context okay so let's
162:07 - see so here we are and if I press on E
162:10 - if there you go I've got a nice event
162:11 - okay great so with this we know when the
162:13 - player presses the key now the next step
162:15 - is how do we get the player class how do
162:18 - we get this one to know when this is
162:19 - performed and the answer is we're going
162:21 - to do the exact same thing we're going
162:23 - to make an event over here on the game
162:24 - input class and the player won't listen
162:26 - to that which in turn the game input
162:28 - grabs from the input system again the
162:30 - home point is separating our concerns so
162:33 - the player does not care about the input
162:34 - system does not care about the interact
162:36 - action it only wants to know when
162:37 - something related to interact happens so
162:40 - over here let's make that nice event
162:41 - first of all let's make it public
162:43 - because we want the player to access it
162:45 - then we need to add the event keyword
162:47 - next we add the donkey type like I said
162:50 - you can learn more about delegates in my
162:52 - dedicated video you can create your own
162:54 - custom Delegate for your event or you
162:56 - can just follow the c-sharp standard and
162:58 - just use the standard event handler and
163:01 - this one exists inside system
163:03 - so let's make sure to go up here and add
163:05 - using system and this one has the event
163:08 - handler class this one is pretty much
163:10 - easy sharp standard for events as you
163:12 - can see it returns void it has an object
163:14 - for the sender and an event RX parameter
163:17 - like I mentioned in the events video you
163:19 - are not forced to use this target you
163:21 - can use whatever delegate you want like
163:22 - for example you saw that the performed
163:24 - uses an action delegate so you can use
163:26 - anything you want to choose that the
163:28 - event handler is the c-sharp standard so
163:30 - it's easier to follow unless you have a
163:32 - specific reason to deviate from the
163:34 - standard you should probably use this
163:35 - one so let's use this and then finally
163:37 - for the name usually you start the name
163:39 - with on and then whatever happened so in
163:41 - our case let's go with on interact
163:43 - action
163:45 - okay so we have defined our event and
163:48 - now for firing it let's go down here
163:50 - into when we have the interact performed
163:52 - and let's go into the event and for
163:54 - finding it it's pretty much exactly the
163:55 - same thing as calling a regular function
163:57 - so we just call it with parentheses then
163:59 - usually for the object sender this is a
164:01 - reference to whoever is sending this
164:03 - event so usually the this keyword and
164:05 - then for the event RX this is in case
164:07 - you want to send some arguments with the
164:08 - event in our case we don't really need
164:10 - to send any extra data for this one just
164:12 - firing the event is going to be enough
164:13 - so for that we can use the constant
164:15 - event RX dot empty okay so that's it
164:19 - with this we are firing an event except
164:21 - just like this we're actually going to
164:22 - have one potential error if we have no
164:25 - subscribers no listeners to this event
164:27 - then essentially this field won't be
164:29 - known so this one over here is going to
164:31 - trigger a non-reference exception let's
164:33 - do a quick test just to see this
164:34 - happening so here if I press on E if
164:37 - there go we have a null reference
164:38 - exception
164:39 - so when working with events you need to
164:40 - first test if there are any listeners
164:42 - and only then do you actually trigger
164:44 - the event
164:45 - so you do if this one is not null if it
164:48 - is not known that means there are some
164:49 - subscribers so we can fire the event so
164:52 - like this it won't work but there's an
164:53 - even more compact way to do this which
164:55 - is perfect for events so instead of this
164:59 - we've got our on interact action then we
165:01 - can add a question mark this is called
165:03 - the non-conditional operator basically
165:06 - the code is going to execute from left
165:07 - to right
165:09 - and then when it gets to this question
165:10 - mark it's going to evaluate the left
165:12 - side and if it is null then the
165:15 - execution won't stop right here on the
165:16 - question mark and will not throw any
165:18 - errors whereas if this one is not null
165:20 - then it continues executing to the right
165:22 - except with this syntax we have an error
165:24 - We cannot put parentheses directly after
165:26 - the question mark but what we can do is
165:29 - simply just call invoke and that does
165:31 - the exact same thing that console
165:32 - function so what we have here is exactly
165:35 - the same thing that we had previously
165:45 - so what we have over here and over here
165:47 - these are the exact same thing it's just
165:49 - this one is much nice much more Compact
165:51 - and especially for events this one is
165:54 - super useful okay so with this we are
165:56 - correctly firing for our event now let's
165:58 - actually listen to it so let's go over
166:00 - here into the player class
166:01 - and let's listen to our event
166:04 - let's do it on a private void start make
166:06 - it on start not an awake this is a very
166:09 - important rule which I'm actually going
166:10 - to cover in detail in the next lecture
166:11 - but for now just make sure to listen on
166:13 - start and not on awake so over here we
166:16 - access the game input then let's access
166:18 - the on interact action event and as
166:20 - usual let's listen to it so let's use
166:22 - press tab to listen to it so it is
166:24 - exactly over here that we want to run
166:25 - our interact code so let's go down into
166:28 - the handle interaction code that we had
166:30 - previously so this one
166:31 - so let's copy paste all this code put it
166:34 - up here
166:35 - so we get the interaction going to the
166:37 - object and Trigger the interact now
166:39 - obviously code duplication is a big
166:40 - No-No so we're only duplicating our code
166:43 - just for a quick test just make sure it
166:45 - works
166:46 - once again refactoring is super useful
166:47 - so we're going to refactor this code to
166:49 - get rid of code duplication in the next
166:51 - lecture but for now we just want to test
166:53 - to make sure that this does work
166:55 - so let's just remove the interact over
166:56 - here from the handle interactions so the
166:58 - only interact function being called is
167:00 - over here when we have our actual input
167:02 - so let's test and see if we can press to
167:04 - interact with the counter alright so
167:06 - here we are and as I move around if I
167:08 - approach a counter yep there you go we
167:09 - no longer have the automated interaction
167:12 - and now if I'm facing the counter and I
167:14 - press the enter I key if there go here
167:16 - we have our nice interaction all right
167:18 - awesome so I can approach I can interact
167:20 - and do whatever I want
167:21 - alright so here we learned about c-sharp
167:24 - events these are super powerful so if
167:26 - this is the first time you're hearing
167:27 - about them then you've just had an
167:29 - awesome new tool to your tone box
167:31 - definitely make sure you watch my
167:32 - dedicated video to learn about them in
167:34 - more detail events are super useful the
167:36 - next thing we're going to need is just a
167:38 - visual to highlight the current selected
167:40 - counter so let's do that in the next
167:41 - lecture
167:43 - hello and welcome I'm your code monkey
167:45 - in this lecture we're going to add a
167:47 - visual to our selected counter and in
167:48 - doing so we're also going to learn about
167:50 - the very useful Singleton pattern okay
167:52 - so over here we already have the logic
167:54 - to identify the counter in front of the
167:56 - player and we can interact with it
167:57 - however once the logic works there is no
168:00 - visual indicator at all so let's add
168:02 - that now as usual the super quick and
168:05 - dirty way of doing it would be pretty
168:06 - simple over here on the player script we
168:08 - could just directly enable a visual mesh
168:10 - on the target counter so down here on
168:12 - the handle interaction when we have this
168:14 - over here we can tell the clear counter
168:16 - to enable some kind of visual
168:17 - technically that would work but that
168:19 - would be some pretty dirty code we would
168:22 - basically be making the player
168:23 - responsible for enabling some kind of
168:25 - visual which would mean that we were
168:27 - mixing logic with visuals again we
168:30 - always want to try separating the logic
168:31 - from the visuals as much as possible to
168:33 - keep our code nice and organized so
168:35 - instead of doing the quick and dirty
168:36 - route let's do it properly back in the
168:39 - editor let's create a brand new c-sharp
168:41 - script call this the selected counter
168:43 - visual
168:45 - and now let's go into the prefab again
168:48 - let's go inside it so let's select the
168:49 - clear counter on the hierarchy then on
168:51 - the inspector let's open up go inside
168:52 - the prefab and now let's select the
168:55 - visual inside it and let's duplicate
168:56 - this so you can press Ctrl D to
168:58 - duplicate it let's name this when it's
169:00 - selected and then inside there's a
169:02 - visual with a mesh filter and a mesh
169:04 - render so over here let's swap out the
169:06 - material
169:07 - so let's click on the circle icon and
169:10 - now included in the assets is this
169:12 - material counter selected so it's all
169:15 - the way yep up here the counter selected
169:16 - basically it's just a solid white color
169:19 - within low Alpha so on the kitchen
169:21 - counter inside the sunlight game object
169:23 - let's make sure to use this one with
169:25 - this we have kind of like a ghost visual
169:27 - so if we enable and disable this game
169:29 - object we can see the difference Also
169:31 - let's do one tiny thing which is right
169:33 - now we duplicated the actual visual
169:35 - meaning that these objects are exactly
169:37 - the same they have the exact same size
169:39 - and when that happens you might end up
169:41 - with some rendering bugs if two meshes
169:43 - are on the exact same position you might
169:45 - sometimes see the colors constantly flip
169:46 - back and forth
169:48 - so in order to make sure that doesn't
169:49 - happen let's make this one deselected a
169:52 - tiny tiny bit bigger so over here with
169:54 - the selected game object selected on the
169:56 - inspector over here we've got the scale
169:58 - and also we've got this nice little
169:59 - button here if it's like this then we
170:01 - can modify each proportion differently
170:03 - from one another whereas if we click now
170:06 - these are all linked so now I'm
170:08 - modifying one will modify all of them so
170:10 - let's put this on 1.01 meaning this one
170:13 - is going to be literally just one
170:15 - percent bigger so that's enough of a
170:16 - difference to make sure we don't have
170:18 - any rendering bugs and by default let's
170:20 - also start with the visual hidden so
170:22 - let's do that not on the parent select
170:24 - game object but rather on the kitchen
170:25 - counter inside of it let's make sure to
170:27 - disable this game object by the way the
170:29 - quick shortcut is shift alt and a you
170:32 - can enable or disable the object very
170:34 - useful so let's start with this one
170:35 - disabled so that it's hidden and
170:37 - basically the goal is that when this
170:39 - counter is selected we're going to
170:41 - enable it and show this Visual and when
170:42 - it's not selected we're going to disable
170:44 - it okay so over here on the selected
170:46 - let's add the script that we made so
170:47 - these selected comes revision all right
170:49 - so let's open it now here first thing we
170:51 - need to know is know which counter is
170:53 - selected meaning we need to know which
170:56 - counter the player is currently looking
170:57 - at so let's go over here onto the player
171:00 - script and let's basically just do some
171:01 - simple logic to keep track of the
171:03 - selected counter so over here let's make
171:05 - a field so a private
171:07 - let's make it a type clear counter and
171:10 - just come with the selected counter
171:13 - then down here we have our handle
171:15 - interactions logic okay so we do all of
171:17 - this we try to find the counter in front
171:19 - and if we do find it then we have it
171:21 - here so here on let's just check if it's
171:23 - different so if this clear counter if
171:25 - the one in front is different from the
171:27 - current selected then let's set the
171:29 - selected to this one
171:32 - and let's also make sure to essentially
171:34 - unselect so we want to make sure to set
171:36 - this one to know when there's nothing in
171:37 - front of the player so if the raycast
171:39 - does not hit anything then there is
171:41 - nothing in front of the player so let's
171:42 - set this like the counter back into null
171:44 - and also if there is something but that
171:46 - something does not have the clear
171:47 - counter script then it's also not a
171:48 - counter so over here let's also do an
171:50 - else selected counter equals no so
171:53 - basically if there's a counter in from
171:54 - the player then it's going to set it if
171:55 - not then it's going to be no
171:57 - let's just do a simple debug download to
172:00 - check on the selected counter okay and
172:02 - also just briefly now that we've made
172:04 - this selected counter logic actually up
172:06 - here when we have our interact action
172:08 - like we saw we were previously copying
172:11 - some duplicated code
172:12 - but now we no longer need this since we
172:14 - already know the selected counter so
172:16 - over here when we've got the interact
172:17 - action
172:18 - let's just check if we do have a
172:20 - selected counter so if it is not null if
172:23 - so then we go there and we call the
172:24 - interact function so that's it we no
172:26 - longer need all of this logic okay
172:28 - that's great so let's test back in the
172:30 - editor and let's go back into scenes
172:31 - let's make sure to save the prefab
172:33 - make sure the script was attached save
172:35 - it and let's hit on play and right now
172:37 - if I'm down here yep there you go we've
172:39 - got null and as I approach if there go
172:41 - that one is a clear counter and if I
172:42 - move towards this one yep it's that one
172:44 - okay so basically we are keeping track
172:46 - of the kernel selected counter now
172:48 - basically we just need to notify the
172:50 - visual whenever this one changes so when
172:52 - this one is pointing at that one or
172:53 - pointing at no or pointing at that one
172:54 - we need to know when that happens
172:56 - and for that we basically have two
172:58 - options now one option is pretty much
173:01 - what I mentioned a while ago which is
173:03 - over here we have the selected counter
173:04 - so we can run some kind of logic on the
173:06 - sunlight counter we can do that over
173:08 - here on the player then perhaps over
173:10 - here the counter would fire off some
173:12 - kind of event saying it has been
173:13 - selected and then the counter visual
173:16 - would listen to that event and update
173:17 - itself now that approach would be useful
173:20 - if we wanted to add some kind of logic
173:22 - on the clear counter while selected and
173:24 - that approach would also have the
173:25 - benefit where the visual encounter would
173:27 - only listen to events on its own counter
173:29 - so that's one approach pretty much a
173:31 - very direct approach but another one is
173:33 - very simple the player would simply fire
173:36 - off an event whenever the selected
173:37 - counter changes and then all of the
173:39 - counter visuals would listen to that
173:41 - event then they would identify if the
173:43 - event relates to that counter and if so
173:45 - update their state
173:46 - now the benefit of this approach is that
173:48 - the logic doesn't get bothered with any
173:50 - selection logic so over here the clear
173:52 - counter script never really knows if
173:54 - it's light or not and that's a good
173:55 - thing because it doesn't need to know
173:56 - although the potential con with that
173:58 - approach is that all of these selected
174:00 - countervisions are only going to listen
174:02 - to the same event so both approaches
174:04 - have pros and cons here on let's go with
174:06 - the second approach where all the
174:08 - counters listen to a player event
174:09 - the potential performance con doesn't
174:11 - really matter on a game of this scale
174:13 - we're only going to have about a dozen
174:15 - counters so even if 11 of them are just
174:18 - wasting on listening to the event it's
174:20 - really not going to matter and going in
174:22 - with this approach will actually help us
174:24 - learn about the Singleton pattern which
174:25 - is extremely useful so first let's go
174:28 - over here onto the player class and
174:29 - let's make the event that we're going to
174:30 - fire
174:31 - so as usual let's make it public so we
174:33 - can access it let's make it an event and
174:36 - as usual let's also use the standard
174:37 - event handler let's make sure to add
174:40 - using system so here Visual Studio adds
174:42 - it automatically okay
174:44 - then let's call this on selected counter
174:46 - changed
174:52 - also this is a great moment to learn
174:54 - about the event arcs this is how you can
174:57 - extend a c-sharp event in order to pass
174:59 - in some more data so how you do it by
175:02 - following the c-sharp standard is very
175:03 - simple we just create a class
175:06 - so over here let's make a public class
175:08 - then for name usually you include the
175:11 - name of the event with eventars at the
175:12 - end so in this case on selected counter
175:15 - changed and then event arcs then on this
175:18 - class we make it extend event arcs
175:22 - and finally inside the class we add
175:24 - whatever that we want like for example
175:26 - we want the current selected counter so
175:28 - let's make a public clear counter and
175:31 - put the selected counter
175:34 - okay so we have this nice event arcs
175:37 - with a bunch of extra data and then over
175:38 - here on the event handler we use the
175:40 - version that takes a generic and we pass
175:41 - in our event arcs again I covered the
175:44 - generics in more detail in a separate
175:46 - video definitely go watch that one if
175:48 - you haven't seen it yet c-sharp generics
175:50 - are one of c-sharp's most powerful
175:51 - features okay great so we now have our
175:54 - nice event now let's fire it off so
175:57 - let's go down here to when we're
175:58 - modifying the selected counter so here
176:00 - it is we've got all of these ones so
176:02 - when we modify let's fire off the event
176:04 - so we go into this event and as usual
176:05 - let's use the question mark and then
176:07 - call invoke then for the object sender
176:09 - it's going to be this so pretty much is
176:10 - centered and then for our custom
176:12 - eventarics let's construct an object of
176:14 - that type so construct a new object and
176:17 - then inside we pass in the selected
176:18 - counter and we set it to this selected
176:20 - counter now don't be confused by the
176:22 - fact that we're using the exact same
176:23 - name if you actually Mouse over the
176:25 - cursor Visual Studio actually helps you
176:27 - by telling you which object refers to
176:29 - this so with the cursor here note how
176:31 - all of these are highlighted but this
176:33 - one is not highlighted that's because
176:35 - this field this is the film inside the
176:37 - unselected counter change event RX
176:39 - whereas this one out here is the object
176:40 - that we're referencing in here so even
176:42 - though these two have the exact same
176:44 - name here we're accessing the film
176:45 - inside of that and we're assigning it to
176:47 - the reference that we have down here
176:48 - okay so that's really it we're firing
176:50 - off the event when the selected changes
176:52 - and we're passing it in and let's also
176:54 - make sure to do it over here so let's
176:56 - copy and paste some code and there you
176:58 - go just like this except of course we
177:00 - can already see a bunch of code
177:01 - duplication usually that means it's time
177:03 - to refactor so let's do that pretty
177:05 - quickly let's go down and make a brand
177:08 - new function so let's make a private
177:10 - Droid let's call it set selected counter
177:13 - and we're going to receive a clear
177:15 - counter for the selected counter
177:20 - then over here we just set this dot
177:22 - selected counter so we're modifying the
177:23 - member variable with the one that we
177:25 - receive on the parameter and then let's
177:27 - also fire off the event so let's copy
177:28 - paste the event
177:30 - just like this the exact same thing okay
177:32 - so that's it and now up there instead of
177:34 - code duplication we just do this
177:36 - so over here we set the clear counter
177:38 - just call the function pass in that one
177:40 - and get rid of this and on that one just
177:43 - pass a null just like this get rid of
177:46 - all this and here the same thing just
177:48 - pass in no alright so with this our code
177:51 - is much cleaner and everything still
177:52 - works is all the same so here we have
177:54 - everything done on the player side let's
177:56 - just get rid of unlock we know we need
177:58 - this so we're still handling the
178:00 - selected counter logic and then down
178:02 - here we're firing off the event now we
178:04 - need to do is go over here into the
178:06 - selected counter visual script and here
178:08 - what we want to do is to listen to that
178:09 - event in order to do that we need a
178:11 - reference to the player object now so
178:14 - far when we've been listening to events
178:15 - like for example any player class up
178:18 - here we were listening to some events on
178:19 - the game input so there you go the
178:21 - uninteract action so for the game input
178:23 - reference we just added as a serialized
178:25 - field
178:26 - we did this and then we drag the
178:28 - reference directly and technically we
178:30 - could do the same thing over here on the
178:31 - sound like the counter visual but we're
178:33 - going to have like a dozen counters in
178:35 - our map so it would be pretty tedious to
178:37 - drag and drop the play reference to
178:39 - every single one of them so instead of
178:41 - using a serialized field another
178:43 - approach is to use the Singleton pattern
178:44 - this one is an extremely useful
178:46 - programming pattern it's very useful for
178:48 - things where you only have one instance
178:50 - of something
178:51 - in this case we're making this game
178:53 - single players so we're only ever going
178:55 - to have a single player by the way
178:57 - here's one obvious quick note like I
178:59 - mentioned in the beginning of this
179:01 - course
179:01 - after this video there's going to be
179:03 - another one converting this game into
179:05 - multiplayer and in that case we will
179:07 - have multiple player instances but this
179:09 - is also an excellent reminder of how
179:11 - refactoring code is perfectly fine for
179:13 - right now for this game it is intended
179:15 - as single player so for now we're going
179:17 - to use the Singleton pattern then in the
179:19 - future when we convert this to
179:21 - multiplayer we won't simply refactor
179:22 - that logic again don't be afraid of
179:25 - refactoring code it's a Perfectly
179:27 - Natural part of programming and game
179:28 - development okay so let's implement the
179:30 - single note pattern this is actually
179:32 - super simple the name sounds
179:33 - intimidating but it really is very
179:35 - simple
179:36 - over here on the player script
179:38 - let's make a public field this one let's
179:41 - make it static
179:43 - if you don't know static basically it
179:45 - means that this film belongs to the
179:47 - player class itself and not to any
179:48 - instance of a player so for example if
179:50 - you had a hundred players you would have
179:53 - a hundred instances of moose mean you
179:55 - would have one for each player but there
179:57 - would only be a single static film
179:59 - because this static film belongs to the
180:01 - class itself and not to any instance so
180:03 - let's make a field of Thai player and
180:05 - then for the name the convention is to
180:07 - call it instance and the reason why I'm
180:09 - using Pascal case here so capitalized in
180:12 - the beginning the reason for that is
180:13 - because this is actually not going to be
180:15 - a film but instead it's going to be a
180:17 - property
180:18 - remember the naming rooms that we
180:20 - covered in the beginning of this course
180:21 - it's very important you follow your
180:23 - naming rules always be consistent so
180:25 - your code is easier to understand
180:27 - so with that said since this is the
180:29 - first time we're using a property let me
180:30 - quickly explain what it is
180:32 - basically it's the exact same thing as a
180:34 - regular variable except you can add some
180:36 - logic when getting and setting that
180:37 - field so here let me write some quick
180:40 - code just to show difference between a
180:41 - property and a regular field so for a
180:44 - regular field you would call this maybe
180:45 - instance field something like this so
180:47 - this is a regular field
180:49 - then you would have some kind of public
180:51 - static
180:54 - return the player and call it get
180:56 - instance field
180:59 - then over here you would return the
181:00 - instance field
181:02 - and then maybe another public static
181:04 - void set instance field where you
181:07 - receive a player for the instance field
181:11 - and you would set the player that
181:12 - instance film into this instance field
181:14 - so this is how you do this logic with
181:16 - fields and now with properties
181:19 - you would do public static Flair then
181:22 - call it instance
181:23 - then on the property itself you open up
181:26 - the currently brackets
181:27 - inside the property you put a get then
181:30 - you return something
181:32 - so for that something usually a property
181:34 - has a field underneath it
181:36 - so you'd have a private static player
181:39 - for the instance that's a different name
181:41 - from this one
181:43 - on the get you would return that
181:45 - and on the set
181:47 - you would set the instance equals z
181:49 - value
181:50 - if you're confused here don't worry
181:52 - basically I'm just repeating just so you
181:54 - can see difference here we have a field
181:56 - with a get and a set function so regular
181:58 - functions and up here we have a property
182:00 - and inside the property the property
182:02 - itself has a get and set functions which
182:05 - can also do some logic so you can do
182:06 - some logic in between or you can just
182:09 - return the underlying value so basically
182:11 - using your property is pretty much the
182:13 - exact same thing as using a separate get
182:15 - and set function also one more bonus
182:18 - thing which is that c-sharp is smart
182:20 - enough to automatically create the
182:22 - underlying film for a certain property
182:24 - so if you just want to do a get and a
182:26 - set then you don't need to Define all
182:27 - this you can just Define a property and
182:30 - then inside you can just do get and set
182:33 - and there you go this code here works
182:35 - the exact same thing as we had
182:37 - previously which in turn is the exact
182:39 - same thing as all the code we have here
182:40 - with the getter and a Setter function so
182:42 - here it is a valid functional c-sharp
182:44 - property now I have to say that
182:46 - personally I very very rarely use
182:48 - properties in fact the only place where
182:51 - I use them is over here on the Singleton
182:52 - pattern for everything else I normally
182:55 - use regular films with get and set
182:56 - functions personally that's just the way
182:58 - that I like to code but that's really
183:00 - just personal preference so if you don't
183:02 - like to use properties then go ahead and
183:04 - use them anyway so the reason why I like
183:07 - using a property specifically for the
183:09 - single pattern is because the implicit
183:11 - implementation allows you to do
183:13 - something really nice again remember to
183:15 - go on with clean code we want to
183:17 - minimize complexity and the best way to
183:19 - do that is minimize access here if we
183:21 - set this property and we set it as
183:23 - public then that means that any other
183:25 - class can both get and set so anyone
183:27 - else can have both read and write access
183:29 - so we have the exact same problems that
183:32 - I warned you about when I spoke about
183:33 - why you should not make everything
183:34 - public and of course if we make this
183:37 - private
183:38 - then at that point we kind of lose the
183:40 - purpose of our Singleton since no one
183:41 - else will be able to access this
183:43 - basically we want to be able to access
183:45 - this reference from classes outside of
183:46 - this one we just don't want those
183:48 - classes to also have right access
183:50 - now thankfully properties have an
183:52 - excellent thing which is you can Define
183:53 - accessors for here both the get and the
183:55 - set so we can make the property itself
183:57 - public which means by default both of
184:00 - these won't be public but then we can
184:02 - also add the accessor over here private
184:04 - which in turn means that the get won't
184:06 - be public so any other class can get
184:08 - this but private means that only this
184:10 - class can set it this way we have the
184:12 - exact level of accessibility that we
184:14 - want this is the reason why for this
184:16 - specific use case properties are very
184:18 - useful with just this one line of code
184:20 - we already have our instance with the
184:22 - perfect level of accessibility
184:24 - so now that we have this field to set it
184:27 - let's make a simple awake so let's go
184:28 - over here private void awake and on
184:30 - awake we just set instance equals this
184:33 - however remember that a key point of the
184:35 - Singleton pattern is you only have a
184:37 - single instance of something
184:39 - so in this case we should never have
184:41 - more than one player if we do then
184:43 - something went wrong
184:44 - so we can add a nice safety feature here
184:46 - let's just check if instance if it is
184:50 - not known meaning it has already been
184:51 - set to something
184:53 - if so then that's an error something bad
184:55 - happened similar to a debug.log error
184:58 - because this should never happen so
185:00 - let's say there is more than one player
185:03 - instance this way we have a nice safety
185:05 - check just in case something goes wrong
185:07 - alright so that's really it for the
185:09 - Singleton pattern we just defined a
185:11 - property with a public yet in a private
185:13 - set and on the Wake we just set the
185:14 - instance that's it as you can see it's
185:17 - super simple and now for the really
185:19 - useful part over here on the selected
185:21 - counter visual now we can access the
185:23 - Singleton instance in a super easy way
185:25 - let's make a private void start and on
185:28 - start we just access the player class
185:30 - and from the class we can access the
185:32 - static instance so we can access the
185:33 - Singleton and now we can listen to The
185:36 - unselected Counter event and over here
185:38 - by default Visual Studio gives this
185:40 - function the name of the event and also
185:42 - the property
185:43 - this is in the very descriptive name so
185:45 - I like to rename this so control RR and
185:47 - just rename the instance here instead of
185:49 - instance let's rename it to player okay
185:51 - great so over here we can listen to this
185:54 - event
185:54 - however here is yet another extremely
185:56 - important thing note how I made this on
185:58 - start that is very important if you do
186:01 - this over here on a week instead of
186:03 - start and over here on the player you're
186:05 - also setting the instance on awake if
186:07 - you do that basically there is a chance
186:08 - that this code won't run before this
186:10 - code and if that happens well then this
186:12 - one the player instance has not been set
186:14 - yet so this will be null and don't throw
186:16 - a known reference exception now whether
186:18 - this happens or not it's actually
186:19 - somewhat random it depends on the order
186:22 - in which Unity decides to run both these
186:24 - scripts if Unity decides to run the
186:26 - player first and this one second
186:29 - if that happens then there's no problem
186:30 - but if Unity decides to run this first
186:32 - and then this one then we have a problem
186:34 - let me do a quick test and see if in my
186:36 - case it triggers that error any up in my
186:38 - case it did trigger that error so here
186:40 - we have a no reference exception
186:42 - any app it is being fired on this line
186:44 - now one solution to this problem is you
186:46 - can tell Unity specifically which order
186:48 - the script should run in so you can go
186:50 - up here into edit then go into the
186:52 - project settings
186:53 - then on the left side you've got
186:55 - something called The Script execution
186:56 - order and basically over here you can
186:58 - set the order in which all of these
187:00 - scripts run so if you were to make the
187:02 - player script run before the default
187:04 - time that would make sure that even
187:06 - though both these scripts aren't awake
187:07 - this one would run before this one so
187:09 - that would fix that problem however you
187:11 - should really only use this approach in
187:12 - the last case possible where there
187:14 - really is no other way in this case we
187:16 - do have another better Wing personally I
187:19 - have a very simple room that I like to
187:21 - follow that helps solve this issue as
187:23 - you know Unity has both an awake and a
187:25 - start
187:26 - and all of the awakes on all the objects
187:28 - will all run before all these starts so
187:31 - the simple rule that I follow is that I
187:32 - use a wake for the initialization of
187:34 - that script and for any external
187:36 - reference for that I use it on start so
187:39 - in this case for initializing the player
187:41 - and setting the instance that will lead
187:43 - to the initialization of the player so
187:44 - let's do it on the Wake whereas over
187:46 - here on the visual
187:47 - since here we're going to access the
187:49 - player which is an external reference
187:51 - for this one instead of doing it on Wake
187:53 - let's do it on start this way we are
187:56 - guaranteed to make sure that this
187:58 - instance has been set okay so with all
188:00 - of that here we have our instance so
188:01 - that works great and we have our events
188:03 - so that's great then here we have our
188:05 - event and inside we've got our event
188:07 - arcs so we can go inside the event arcs
188:09 - object and inside we have our selected
188:11 - counter so we need to do is just compare
188:14 - which counter this Vision belongs to
188:16 - so let's actually make a film up here so
188:19 - as usual let's make a serialized film of
188:21 - type clear counter
188:25 - so we have this one and before we go
188:27 - into the editor just make sure it
188:28 - compiles and let's comment this out so
188:30 - now let's go back into the editor and
188:32 - over here let's drag the reference but
188:34 - again remember we're working with a
188:35 - prefab so let's click on open to go
188:37 - inside the prefab and now once inside it
188:40 - let's select the selected game object
188:42 - and just drag the clear counter
188:44 - reference okay great let's go back
188:46 - outside and save the changes all right
188:48 - so now here in the code it's actually
188:49 - very simple so we just do an if
188:52 - if the selected counter matches this
188:54 - clear counter
188:55 - if so then we want to show this visual
188:57 - if not we want to hide it so let's also
188:59 - add a reference for that visual so let's
189:02 - add another serialized field of type
189:03 - game object for the visual game object
189:08 - then back in the editor again let's go
189:10 - inside the prefab and on the select
189:11 - let's drag the channel kitchen counter
189:13 - so drag down that is the visual game
189:15 - object okay let's go back save and back
189:18 - in the code here let's make some simple
189:19 - show and hide functions so private void
189:21 - show
189:22 - and a private void hides
189:25 - and now on the show just going to visual
189:27 - game object and call set active so this
189:30 - enables or disables the game object so
189:32 - for sure let's set it to true and for
189:34 - hiding let's set it back into fonts okay
189:36 - so now it's super simple if the selected
189:38 - counter is this counter then let's show
189:39 - the visual if it is not then let's hide
189:42 - the visual alright that's it super
189:44 - simple let's test so here we are and if
189:47 - I approach that counter yep there you go
189:49 - look at that nice selected Visual and if
189:50 - I get into this one yep there you go I
189:52 - can see it all right great so here we
189:55 - had a really nice visual to our selected
189:58 - counter and more importantly we'll learn
190:00 - about the super useful Singleton pattern
190:02 - as well as learning about c-sharp
190:04 - properties and a very helpful room for
190:06 - how to avoid code timing issues so this
190:08 - was a really detailed really important
190:10 - lecture if you're feeling confused about
190:12 - anything go ahead watch it again or just
190:14 - post a question in the comments and I'll
190:16 - do my best to help so with all of this
190:18 - this is all great we have these unlike
190:19 - the counter and we can see which one is
190:21 - actually being selected then by pressing
190:23 - a button we can actually interact with
190:25 - it so I can move and interact with any
190:27 - of these counters but right now just
190:29 - interacting with them doesn't really do
190:30 - anything so the next thing we need is to
190:33 - create some proper objects for all of
190:34 - our ingredients so we can later pick
190:36 - them up and drop them on counters so
190:38 - let's begin doing that in the next
190:40 - lecture
190:41 - hey again quick intermission your pass
190:43 - C15 lecture marks so congratulations
190:45 - looking at my regular core stats it
190:48 - seems about 80 of people give up by this
190:50 - point so great job with sticking with it
190:52 - the difficulty in complexity is
190:54 - increasing over the lectures so I just
190:56 - want to check in to make sure you're
190:57 - understanding everything remember to
190:59 - post in the comments if you need extra
191:01 - clarification on anything and I'll do my
191:03 - best to answer
191:04 - also check the website to see what
191:06 - questions others have asked and of
191:07 - course remember this is your Learning
191:09 - Journey you're not competing with anyone
191:10 - but yourself so take your time re-watch
191:13 - some lectures if you need to just focus
191:15 - on learning okay let's go to the next
191:17 - lecture
191:19 - hello and welcome I'm your code monkey
191:21 - in this lecture we're going to learn how
191:23 - to create the kitchen objects like the
191:25 - various ingredients okay so far we have
191:27 - our player we can walk around I can
191:29 - approach each of these counters and I
191:31 - can interact with now the next one is to
191:33 - create objects the player can pick up
191:34 - and drop when interacting with a clear
191:36 - counter so let's begin by making the
191:38 - actual objects so let's create a new
191:40 - empty game object call this one the
191:42 - Tomato then again as usual let's
191:44 - separate the visual so in the included
191:46 - assets let's go inside of it then we've
191:48 - got the prefab visuals and we've got the
191:50 - kitchen objects visuals and inside we've
191:52 - got all of the ingredients so let's just
191:54 - find the Tomato Visual and drag it as a
191:56 - child of the tomato and again as usual
191:58 - make sure to put on position low
191:59 - composition zero zero zero and for the
192:02 - main one let's put it on a y of zero and
192:04 - just push it a little bit off to the
192:06 - side just so we can see okay great
192:07 - now this one is obviously not going to
192:10 - exist over here in our world instead
192:11 - we're going to spawn it so let's make it
192:13 - a prefab let's just drag it over here
192:15 - into our prefabs okay there it is let's
192:18 - delete it from our scene and actually on
192:20 - our prefabs let's make a nice folder to
192:22 - keep things nicely separated
192:24 - so inside the prefabs let's make a
192:26 - subfolder
192:27 - currently the kitchen objects
192:30 - let's put the tomato inside of it and
192:32 - let's also make another folder
192:34 - for the counters and let's put the clear
192:36 - counter inside of it okay so everything
192:38 - is nicely organized all right now that
192:40 - we have this let's go inside our clear
192:42 - counter script and over here let's add a
192:45 - simple reference to our prefab
192:47 - so let's make a type transform called
192:49 - the Tomato prefab
192:52 - by the way here you could make this
192:54 - prefab reference of type game object
192:56 - which type you use in this scenario is
192:58 - pretty interchangeable I talked about
193:00 - those differences in another video so
193:02 - when using prefabs using them as
193:04 - transforms or game objects that's pretty
193:06 - much personal preference and personally
193:07 - I just prefer to use them as transforms
193:10 - okay so we have this let's just make
193:11 - this a serialized field so we can set it
193:13 - in the editor and over here in the
193:15 - editor let's open up go inside the
193:17 - counter prefab and just drag the Tomato
193:19 - reference okay great let's go back
193:21 - outside save now back in the code here
193:24 - when the player interacts with it let's
193:25 - just spawn it so let's call instantiate
193:27 - pass in the Tomato prefab and now here
193:30 - is a good question which is where
193:32 - exactly do we spawn this we don't want
193:34 - to spawn on this counter's origin
193:36 - remember that the counter the way we set
193:38 - it up the origin on the actual object is
193:40 - over there on the bottom we don't want
193:42 - to spawn the tomato inside the mesh that
193:44 - would not make sense instead what we
193:46 - want is to spawn up here so the next
193:48 - question is okay so how do we get this
193:50 - point on top of the counter one approach
193:52 - would be to use a vector 3 directly in
193:54 - the code that would work but not very
193:56 - usable so a more designer friendly
193:58 - method is to Simply use an empty game
194:00 - object as a Target so on the counter
194:02 - let's first go inside our prefab
194:04 - and over here let's create an empty game
194:06 - object inside of it let's call this the
194:09 - counter top point
194:10 - let's make sure to leave this one as
194:12 - empty so no components just a transform
194:14 - and now let's just position it so let's
194:16 - lift it up by just about enough so let's
194:18 - make sure we see so there you go just
194:21 - about that so let's put it on position a
194:23 - y of 1.3 all right so this point is
194:26 - going to be our spawn point let's make
194:28 - sure to save the prefab
194:29 - then back in the code here let's add a
194:31 - reference to our point
194:33 - and for reference let's also use a
194:35 - transform reference currently the
194:37 - countertop point
194:39 - okay now let's just come this line just
194:41 - so the code compiles so we can drag the
194:43 - reference back in the editor inside the
194:45 - prefab let's just write the countertop
194:46 - Point reference okay great so now here
194:49 - when we call instantiate let's
194:51 - instantiate it inside the countertop
194:53 - point so this one's found the object so
194:55 - let's say the transform for the Tomato
194:57 - transform
194:59 - and then we go inside this one and let's
195:01 - just make sure we position it correctly
195:02 - so let's put it on in local position of
195:04 - vector 3.0 so this one put the object
195:07 - exactly on top of our countertop point
195:09 - also here very important don't make a
195:11 - mistake make sure you're modifying the
195:13 - low composition and not the global
195:15 - position okay so with this let's test
195:17 - over here in the editor let's go back
195:19 - save our prefab and hit on play so here
195:22 - we are let's approach a counter and
195:23 - interact with it and if there you go it
195:25 - does work the Tomato was indeed spawned
195:27 - all right awesome okay so with this we
195:29 - have pretty much our Basics working
195:31 - we can move up to a counter we can
195:33 - interact with it and spawn an object but
195:36 - now let's say that we want to spawn a
195:37 - different object so let's say now we
195:39 - want to spawn some genes first of all
195:41 - let's make the actual object so on the
195:43 - Tomato let's press Ctrl D to duplicate
195:45 - this one let's rename this to the cheese
195:47 - block and let's go inside of it
195:50 - now in here instead of the Tomato visual
195:52 - let's drag here it is the cheeseboard
195:54 - visual so let's use this one instead
195:56 - okay there's our nice visual
195:58 - let's make sure to save the prefab and
196:00 - go back out and now let's say that we
196:02 - want this one to spawn a tomato and this
196:04 - one on the left to spawn some cheese so
196:06 - let's override the prefab and over here
196:07 - drag the cheese block and now if we hit
196:10 - on play
196:11 - can go up to this one yep there's a
196:12 - tomato go this one any up there's some
196:14 - cheese okay so it all looks great but
196:17 - now let's say we want to know what
196:18 - object we just spawned like what object
196:20 - is on top of this spawn transform just
196:22 - like this in the code all we have is a
196:24 - transform reference so with this the
196:27 - only way to know what type we spawned
196:28 - would be if we had different prefabs for
196:30 - every single object then we could
196:32 - compare them one by one and see which
196:34 - one this matches but then let's say what
196:36 - if we wanted an actual string for the
196:38 - object well then we would need to add
196:40 - tons of fields for all these strings for
196:42 - all of the objects then what about an
196:45 - icon for each type once again we would
196:46 - need tons of fields each one for each
196:49 - icon but if we did it just like that
196:51 - with a bunch of lists then they would be
196:52 - separate that's not very good we should
196:54 - have a proper way of defining our object
196:56 - types and all the data related to them
196:59 - so this is exactly where scriptable
197:01 - objects come in these are objects you
197:03 - can create in your project funnels which
197:05 - are perfect for anything where you have
197:06 - multiple instances of a type like for
197:08 - example multiple weapons multiple armors
197:11 - multiple recipes or maybe multiple
197:13 - ingredients as usual I have a dedicated
197:15 - video on script along objects they are
197:17 - super useful definitely watch out for
197:19 - more detail over here on let's just use
197:21 - them so the first thing we're going to
197:22 - need is to actually Define the type and
197:24 - we do that in a c-sharp script so in our
197:27 - scripts folder let's create new c-sharp
197:28 - script call this the kitchen object so
197:32 - now personally so is just what I like to
197:34 - open to my scriptable object definitions
197:36 - just to make it very clear that it's a
197:38 - script mode object however this is not a
197:40 - requirement it's just a naming room that
197:42 - I like to follow and we're calling this
197:44 - kitchen object because we're going to
197:45 - use this to Define any kitchen object we
197:47 - want to interact with
197:49 - so that's going to be our ingredients
197:50 - like for example the tomato and cheese
197:52 - but also things like a plate and then
197:54 - potentially you could Implement things
197:55 - like a frying pan or framing signature
197:57 - or anything like that so it's going to
197:59 - represent any kind of kitchen object the
198:01 - player can interact with Okay so let's
198:03 - make the script and now let's open it
198:05 - and over here okay first things first is
198:08 - this is not a monobehavior instead let's
198:11 - extend scriptable object and then
198:14 - technically you can have functions
198:15 - inside a straight ball object but for
198:17 - now let's just get rid of this so just
198:19 - an empty class and over here on let's
198:21 - just Place whatever fields we need to
198:22 - store whatever that we want so like I
198:24 - said first we want a prefab so let's
198:26 - make a public transform for our prefab
198:29 - by the way here note how I am indeed
198:31 - using public this is pretty much the one
198:33 - exception to the room I only use
198:35 - scripting objects as read-only data
198:37 - containers I never write to them so
198:39 - since I found that rule I usually make
198:41 - the fields in the description object
198:42 - public that way I can access them
198:44 - directly without having to make a public
198:46 - getter but if you want to feel free to
198:48 - keep following the general rule of not
198:50 - making anything public you could
198:52 - definitely make this just a regular
198:53 - serialized film then exposed with a get
198:55 - function that would work personally I
198:57 - just find it simpler to make it public
198:58 - since I know that as a personal rule I
199:01 - will never write to a script mode object
199:02 - field okay so we have a transform for
199:04 - our prefab let's also add a Sprite for
199:07 - the icon Sprite and finally let's just
199:10 - add a simple string for the object name
199:13 - all right so we have our scribble object
199:15 - definition we have all of the fields for
199:17 - all of the data we want to store now how
199:20 - do we actually create a scribble object
199:22 - for that let's go up here before the
199:24 - class name and we're going to add the
199:25 - attribute so let's add the square
199:27 - brackets and the attribute is the create
199:29 - asset menu this takes some optional
199:31 - parameters again I cover them in detail
199:33 - in the dedicated script and objects
199:35 - video for now let's just leave all the
199:37 - parameters as empty just use defaults
199:39 - and close the attribute okay so that's
199:41 - it let's save this and go back into the
199:43 - editor and over here if we go into the
199:45 - project window click on the plus icon
199:47 - and right up top yep we do see a kitchen
199:49 - object so
199:50 - so if we selected if there you go it
199:52 - creates a brand new object inside of our
199:54 - project files let's name this one tomato
199:57 - and obviously let's keep our project
199:58 - nice and organized so we don't want this
200:00 - inside the scripts folder instead let's
200:03 - make a proper folder so create a new
200:04 - folder come with our scriptable objects
200:07 - and then inside let's put a different
200:09 - folder for each type so let's make
200:11 - another subfolder call it the kitchen
200:13 - object so and let's place the tomato
200:16 - inside of it okay now with the Tomato
200:18 - selected we can look in the inspector
200:20 - and you can see yup it does have all of
200:22 - the fields that we Define okay great so
200:25 - now we can just assign them so this is
200:27 - the tomatoes let's drag the Tomato
200:28 - prefab for the icon Sprite let's find it
200:31 - so there are Sprites included in the
200:33 - regular assets so here is the Tomato
200:35 - Sprite so it's inside the acids then
200:37 - inside textures icons and we have all
200:39 - the icons and finally for the readable
200:42 - name let's just call it tomato alright
200:44 - so that's it here we have a really nice
200:46 - scribble object containing all the data
200:48 - required for our tomato okay awesome
200:50 - with that then we can now go back into
200:52 - our clear counter script and here
200:54 - instead of having a field for our tomato
200:56 - prefab instead of this let's sort of
200:58 - reference of type kitchen object so and
201:01 - let's go on with kitchen object so and
201:03 - then when spawning let's go inside our
201:05 - scriptball object and just spawn the
201:07 - prefab reference so this is going to be
201:09 - the kitchen object transform then over
201:13 - here in the editor let's go inside the
201:14 - clear counter and let's assign the
201:16 - Tomato Kitchen object okay so let's save
201:18 - it and test
201:20 - so here we are on let's approach hit any
201:22 - up there you go it still spawns eat
201:23 - tomato okay great now let's make another
201:26 - type for our cheese block so let's
201:28 - create a brand new kitchen object so
201:30 - called the cheese block and again let's
201:32 - assign first of all the prefab there it
201:34 - is then for the Sprite of the cheese
201:36 - walk and finally this is the cheese well
201:39 - okay so now for example let's go into
201:41 - the second one and on the second counter
201:43 - let's override and say this one spawn a
201:45 - cheese block so let's test so here we
201:48 - are approach this one yep there's tomato
201:49 - this one any of there's some cheese okay
201:51 - great so everything is working so far
201:53 - however the original problem that we're
201:55 - trying to solve identifying the spawn
201:57 - prefab we still don't have a solution
201:59 - for that basically when we spawn a
202:01 - prefab we need to know from which script
202:03 - No Object this prefab came from so
202:06 - essentially what I like to do is just
202:07 - attach some reference to the scripting
202:08 - object in our prefab however again
202:10 - remember that scripting objects are not
202:12 - mono behaviors so if I select the prefab
202:15 - and I try dragging the description
202:16 - object nope it does not work so what we
202:18 - can do is just create a new script so
202:21 - let's make a brand new c-sharp script
202:23 - let's call it kitchen object
202:26 - let's attach this to both prefab so both
202:28 - the cheese and the block attach the same
202:30 - one to both of them and let's open
202:32 - and over here very simple let's just add
202:34 - a serialized film for our kitchen object
202:36 - so a serialized film of type
202:39 - kitchen object so for the kitchen object
202:42 - the cell
202:43 - then let's also make a quick function to
202:45 - expose it so we're going to return
202:46 - kitchen object as so get kitchen object
202:48 - so and we just return the kitchen object
202:51 - as well yep just like this so now here
202:53 - in the editor for the Tomato yep we've
202:55 - got the film so let's say this one is a
202:57 - tomato and the cheese block this one is
202:58 - a cheese block now here obviously we
203:01 - need to make very very sure to drag the
203:03 - correct reference to the right scriven
203:05 - object if you drag the wrong one like
203:07 - for example over here on cheese you
203:08 - would say this one is a tomato if you
203:10 - did that then obviously you would get
203:11 - some very weird results so make sure to
203:14 - check and double check that you drag the
203:16 - right preferences both over here on the
203:18 - prefabs make sure they are referencing
203:19 - the correct Circle object and on the
203:21 - script module itself make sure they are
203:23 - referencing the correct prefont okay so
203:25 - now if you go here on the clear counter
203:27 - we spawn our object okay great then on
203:30 - this object we can do get component of
203:32 - type kitchen object and then we can just
203:35 - ask it to give us the kitchen object as
203:37 - well so for example let's do a debug
203:39 - download on this one
203:41 - so inside you get the kitchen object to
203:43 - sew and then let's print out the object
203:44 - name all right so here we are let's
203:46 - interact with this one and if there you
203:48 - go interacted and spawn the tomato and
203:50 - on this one yep interacted and spawned a
203:52 - cheese block okay awesome we spawned a
203:54 - transform prefab and we identify the
203:56 - spawn object is indeed this type of
203:58 - object all right so here we'll learn
204:00 - about one of the most powerful ENT
204:02 - features scribble objects these are
204:04 - extremely useful for defining a type and
204:06 - then creating multiple instances of that
204:08 - type with whatever that we want so there
204:10 - can be some ingredients like we have
204:12 - here or it could be some weapons could
204:14 - even be some NPC data maybe some Quest
204:16 - data and so on it really is an insanely
204:19 - very useful feature definitely go ahead
204:21 - and watch a dedicated video on script on
204:23 - objects then if you want you can also
204:25 - watch some more videos where I've used
204:26 - scriven objects for example in the
204:28 - Minecraft crafting system using
204:30 - scripting objects or the hydrogenated
204:32 - crafting system which again also uses
204:34 - scribdon objects okay so this is done
204:36 - it's working great now let's continue to
204:38 - the next lecture where we're going to
204:40 - help the kitchen object know where it
204:42 - belongs and help each counter know what
204:44 - kitchen object is on top of it
204:46 - hello and welcome I'm your code monkey
204:49 - in this lecture we're going to create a
204:51 - kitchen object parent meaning that the
204:53 - kitchen object will know where it is and
204:55 - the counter will know if something is on
204:57 - it this is important so that later on we
204:59 - can pick up a kitchen object from one
205:01 - place and drop it in another okay so
205:03 - here we have our player I can move
205:05 - towards this counter interact with it
205:07 - and yep spawn a tomato then on this
205:08 - one's want some cheese okay great but I
205:11 - cannot do anything else in fact if I
205:13 - interact a bunch more times really all I
205:16 - did was just spawn a whole bunch more
205:17 - cheese so instead I want to be able to
205:20 - spawn some cheese and then pick it up so
205:22 - let's think about exactly what that
205:23 - means we want a kitchen object to
205:25 - essentially be placed on a specific
205:27 - Place based on the design that we're
205:29 - trying to implement we're never going to
205:31 - have a kitchen object just randomly
205:32 - thrown around the world we're not going
205:34 - to have tomatoes all over the floor
205:36 - instead the objects will always need to
205:38 - be placed somewhere and that somewhere
205:40 - can be either a counter or it can be
205:42 - being held by the player so essentially
205:44 - that means that each kitchen object is
205:46 - going to have some kind of parent that
205:47 - it's attached to we're going to make
205:49 - sure the counter knows if there is a
205:50 - kitchen object placed on top of it and
205:52 - we're also going to make sure the
205:53 - kitchen object itself knows where it is
205:55 - so first let's do that logic over here
205:57 - on the counter
205:58 - so on the clear counter script let's
206:01 - keep a field for a kitchen object
206:03 - so just a simple private of type kitchen
206:06 - object kitchen object
206:10 - then when the player interacts with it
206:12 - by the way we can get rid of these debug
206:14 - transforms debug logs in all you need
206:16 - them okay so when the plane interacts so
206:18 - if the kitchen object is known
206:20 - if so then we're going to spawn it then
206:23 - when we spawn it let's assign it so this
206:25 - one equals the kitchen object get
206:27 - component of type kitchen object okay
206:30 - so if that one is no we spawn it and we
206:32 - assign it and just with this we should
206:34 - have fixed the issue where we can spawn
206:36 - infinite objects
206:37 - so over here I can interact and now I've
206:40 - interact a bunch more times
206:41 - and now look in the hierarchy inside the
206:43 - clear counter
206:44 - and I go inside the counter top Point
206:47 - nope there's only one tomato okay great
206:49 - so with this basically we made the clear
206:51 - counter know if there's something on top
206:52 - of it
206:53 - now let's do the other side so let's go
206:56 - into the kitchen object and make sure
206:57 - that it knows where it is so over here
206:59 - on the kitchen object script
207:01 - let's add a simple field for a counter
207:03 - so private of type clear counter for the
207:06 - clear counter
207:08 - and now let's just basically make two
207:09 - functions one to set it and one to get
207:11 - it so a public void set clear counter
207:18 - and we're going to receive a parameter
207:20 - of type clear counter okay great and
207:22 - then we're going to have a public return
207:24 - a clear counter for the get clear
207:26 - counter
207:27 - and we're just going to return our clear
207:29 - counter and on this one just set this
207:32 - dark layer counter equals this layer
207:33 - counter
207:34 - all right so on this function we're
207:36 - assigning this field and on this
207:37 - function we're returning this field
207:39 - so now back on the counter script we get
207:41 - the kitchen object reference so on this
207:43 - one let's call set clear counter and
207:45 - pass it in this one
207:47 - and if it is not known so if there's
207:48 - something on top of this let's just do a
207:51 - debug.log let's go on to the kitchen
207:53 - object and get the clear counter
207:56 - so we should be able to click once and
207:58 - spawn an object and click twice and the
208:00 - second time we should be able to see the
208:01 - name of this layer counter
208:03 - all right so over here let's approach
208:05 - and click and yep it's spawn now click
208:07 - again
208:08 - and if we've got the message this one is
208:10 - on the planet counter okay great so far
208:13 - so good
208:13 - so the counter knows if there's a
208:15 - kitchen object on top of it and the
208:17 - kitchen object itself knows where it is
208:19 - now let's add some logic to be able to
208:21 - change a parent counter it's over here
208:23 - on the clear counter script we basically
208:26 - just need to call the set layer counter
208:28 - function with a different counter
208:30 - reference so just for testing let's add
208:32 - a serialized film for the second counter
208:34 - so clear counter for the second clear
208:37 - counter
208:38 - now we're doing this just for testing
208:40 - just make sure the logic Works before we
208:42 - come up with a more General system
208:44 - so just for testing let's come up with
208:46 - some input and again for testing using
208:48 - the lazy input manager to get something
208:50 - quickly up and running is a great thing
208:52 - so let's quickly get a button input on
208:54 - the counter so let's make a private void
208:56 - update
208:57 - and for testing we only want the testing
208:59 - to work on one counter so let's also add
209:01 - up here just a ball testing
209:04 - and then on update if we are testing and
209:08 - we have the input.getkeydown on let's
209:11 - say the T key
209:12 - so if you have that then we can run some
209:14 - kind of testing code so let's say for
209:16 - example if the kitchen object does not
209:18 - know so if we have something on top of
209:20 - this kitchen counter let's go into the
209:22 - kitchen object and call set counter and
209:25 - let's pass in the second clear counter
209:28 - so basically with this we should be able
209:30 - to interact to spawn an object and then
209:32 - press the T key and we should be able to
209:34 - see that object be set to a different
209:36 - parent
209:37 - so here in the after I'll let you set
209:39 - down let's say this one is our main
209:40 - counter so let's drag a reference to the
209:43 - second one the second higher counter
209:44 - drag it and make this one the testing
209:46 - script and also just to verify that it
209:48 - worked over here and lets you a get on
209:49 - the clear counter all right so let's
209:52 - test and see
209:53 - okay so here we are let's approach this
209:55 - one interact and there you go spawn
209:57 - tomato and now if I interact again yep
209:59 - it says the tomato is on the similar
210:00 - counter now if I press the testing key
210:02 - if there go the Tomato was moved onto
210:04 - the other counter
210:06 - okay so the parent change the logic
210:08 - worked however obviously we have two big
210:10 - issues the first one is just a visual
210:12 - you can see the object is still placed
210:14 - on top of this counter even though
210:15 - technically now it belongs to this one
210:18 - and the second issue is that this
210:19 - counter still thinks that it owns this
210:21 - kitchen object and this other counter
210:23 - does not know that it now owns this
210:25 - object so we need to sort all of that
210:27 - first for the visual it's actually very
210:29 - simple
210:30 - here when spawning we are spawning it
210:32 - inside the counter top point and then
210:33 - setting the alarm position to zero so
210:36 - whenever we move to a different second
210:38 - parent when we do that we can just ask
210:40 - that second parent to return the
210:42 - countertop point and move it there so
210:43 - for that let's make a function to return
210:45 - that
210:46 - so public we're going to return
210:48 - transform so get the kitchen object
210:50 - follow transform so it's going to be our
210:53 - countertop point
210:55 - so let's return the counter top point
210:58 - then let's go into the function on the
211:00 - kitchen object when we set the clear
211:01 - counter so over here on the kitchen
211:03 - object on this function so we set the
211:05 - color counter
211:06 - then let's modify this transform.parent
211:08 - go into the nuclear counter in order to
211:11 - get the kitchen object funnel transform
211:13 - and again let's make sure to set the low
211:15 - composition back into Vector 3.0
211:18 - okay so with this when we set the clear
211:21 - counter to a different one it should
211:22 - automatically teleport to the other
211:24 - counter so let's test so here we are in
211:27 - first let's interact with this one there
211:28 - you go it's Pawn now if I press C
211:29 - testing key and if there go it does move
211:31 - visually okay great so far so good
211:33 - however the counters still have the
211:35 - wrong data by the way here's a quick
211:37 - empty tub on the inspector you already
211:40 - know that you can only see the public
211:42 - and the serialized Fields however there
211:44 - is actually a way to look at private
211:46 - fields on the inspector on the top right
211:48 - there's these three dots and if you
211:50 - click on it over here you can modify it
211:52 - into a debug inspector
211:54 - and when you go into this one Yep this
211:55 - one does show all the private fields
211:58 - so you can see for example on the clear
211:59 - counter so that's the right one this one
212:01 - over here the kitchen object is indeed
212:02 - assigned and we can go into the other
212:04 - one and we can see this one has it as
212:06 - null so debug inspector is really useful
212:08 - in these kinds of cases if you want to
212:10 - inspect any kind of private Fields you
212:12 - can go to this and see it now let's swap
212:14 - back into the regular inspector and
212:17 - let's fix that issue by notifying the
212:18 - counters that the object has changed
212:20 - so over here basically we have two
212:22 - options over here on the calendar
212:24 - counter when we modify the parent when
212:26 - we tell the kitchen object to go to a
212:28 - new parent when we do that we can make
212:30 - the new parent responsible to updating
212:32 - itself or we can just make the kitchen
212:34 - object itself be the one responsible for
212:36 - notifying the new parent both approaches
212:39 - can work personally I think it makes
212:41 - more sense for the kitchen object to
212:42 - handle itself
212:44 - so we just call this function to set the
212:46 - new parent and when this happens
212:48 - basically this kitchen object needs to
212:49 - tell the old parent that it is no longer
212:52 - there and needs to tell the new parent
212:53 - that it is on there so on the counter
212:55 - let's make some function to set and get
212:57 - a kitchen object
212:59 - so over here on the calendar counter
213:00 - script let's go down
213:02 - let's make first one to set so public
213:04 - void set kitchen object and receive a
213:07 - kitchen object
213:10 - and just do this dot kitchen object
213:12 - equals this kitchen object okay great
213:14 - then let's make a getter so public
213:16 - return a kitchen object get the kitchen
213:19 - object
213:20 - and just return this kitchen object okay
213:23 - then let's also make one just to clear
213:25 - it so probably avoid clear kitchen
213:27 - object
213:30 - and this one just sets the kitchen
213:32 - object into null
213:34 - and finally just a nice sample function
213:35 - to test if this counter has anything on
213:37 - top so just a public Bowl has kitchen
213:40 - object
213:42 - and over here we just return if the
213:44 - kitchen object is not known
213:46 - okay so some four very simple functions
213:49 - now if we go into our kitchen of the
213:51 - script
213:51 - over here when we tell it to change the
213:53 - parent let's first go into the current
213:55 - parent and clear it
213:58 - so let's first of all do a quick test
214:00 - for null so if this documentary counter
214:02 - which is the current parent so if this
214:04 - one is not null then we go into the
214:07 - current parent so the clear counter and
214:09 - we tell it to clear the kitchen object
214:12 - and then we go into the new parent
214:14 - and we tell new parent to set the
214:16 - kitchen object and the kitchen object is
214:18 - this one
214:19 - now here will be very very important
214:21 - don't make the mistake of clearing the
214:23 - wrong counter keep in mind that over
214:25 - here this documentary counter this
214:27 - refers to the previous player counter
214:29 - whereas the one in the parameter this is
214:31 - the one this is the new one so make sure
214:33 - you clear the kitchen object from the
214:35 - previous clear counter before you assign
214:37 - it and then you set it on the new clear
214:39 - counter so be very very careful here
214:41 - make sure you don't make mistakes
214:43 - between the quote unquote old color
214:45 - counter and the nuclear counter
214:47 - okay so that's it basically we have this
214:49 - function to set the nuclear counter so
214:51 - set the new parent we clear the kitchen
214:53 - object from the old player counter we
214:55 - added a new one and we update the visual
214:57 - now we can also add some nice safety
214:59 - checks here just to make sure we never
215:01 - make a mistake the kitchen object should
215:03 - never be set to a parent that is already
215:05 - holding something so before we set the
215:08 - kitchen object before we do that let's
215:10 - make sure that one is empty
215:11 - so over here just do an if if the clear
215:14 - counter so that's a new one if this one
215:16 - has a kitchen object then it already has
215:18 - something on there this should never
215:20 - ever happen so let's see what debug.log
215:23 - error and say counter already has a
215:26 - kitchen object
215:28 - we're going to eventually add tests to
215:30 - make sure that this never ever happens
215:31 - but having the air here won't be helpful
215:33 - just in case we missed something
215:35 - so far as the kitchen object we're going
215:37 - to fire an error but this should never
215:39 - happen so we just set the error update
215:40 - to visual and so on
215:42 - okay so finally let's just go over here
215:44 - into the clear counter script and down
215:47 - here we have the interact action so we
215:49 - instantiate the kitchen object we're
215:51 - currently repositioning it and then
215:53 - we're setting this field assigning it to
215:55 - this one now we made the kitchen object
215:58 - responsible for doing all that for
215:59 - modifying the position and for setting
216:01 - the field so we don't need to do this
216:02 - instead we really just need to go and
216:05 - get the component of that
216:07 - and just pass in set for your counter
216:09 - and pass in as this one
216:12 - so we no longer need all this now our
216:14 - code is much more simple also
216:16 - importantly up here we were previously
216:18 - setting the color counter and then doing
216:19 - a debug.log but when we set it a new one
216:22 - that is actually going to clear this
216:23 - field so if we leave this then this is
216:25 - going to throw a null reference
216:26 - exception so let's just get rid of the
216:28 - slog here we normally need it okay so
216:30 - let's test and see if all of our logic
216:32 - is working
216:33 - all right so here we are let's go to
216:35 - this one interactive spawn it okay great
216:38 - and once again we can look in the debug
216:40 - inspector so let's put it on debug look
216:42 - at this layer counter so that's the
216:43 - right one and yep there you go it does
216:45 - have the kitchen object and if I'm
216:46 - looking the other one Yep this one has
216:47 - no okay great
216:49 - now if I press the testing key yep
216:51 - visually it did change and if you look
216:53 - at the counter so if you look at the old
216:55 - ones that's the right one this one is at
216:56 - no okay that's great correct and if you
216:58 - look at the new one Yep this one does
217:00 - have the reference all right awesome
217:03 - so now that we are correctly changing
217:04 - the kitchen object parent for example we
217:07 - can now interact again with this one and
217:08 - yep it does spawn a brand new one and of
217:11 - course if we try moving it to the other
217:12 - one then we should have our error as
217:14 - intended this one is currently already
217:16 - occupied the kitchen object so we should
217:18 - not be able to drop something on there
217:20 - but if I press the testing key if there
217:22 - go nicer okay so that's great
217:24 - we're basically going to fix this error
217:25 - later on when we check to make sure the
217:27 - object can only be spawned when it can
217:29 - be spawned but for now all of our basic
217:31 - logic is working we can spawn an object
217:33 - and change a parent alright so with that
217:35 - here we have added a really important
217:37 - feature to our game that is the ability
217:39 - to know where a kitchen object is now
217:42 - the next step is to enable the player to
217:43 - be able to pick it up and drop it
217:45 - somewhere so let's do that in the next
217:46 - lecture
217:48 - hello and welcome I'm your code monkey
217:50 - in this lecture we're going to enable
217:52 - the player to pick up a kitchen object
217:54 - and in doing so we're going to learn
217:56 - about another awesome c-sharp feature
217:58 - called interfaces
217:59 - okay so right now with our game I can
218:01 - already move the player I can approach a
218:03 - counter and try to spawn an object and
218:05 - with the testing key I can move it to a
218:07 - different parent
218:08 - so all of that logic is working now
218:10 - let's make it work actually with the
218:11 - player let's say when we interact once
218:14 - we want to spawn it and if there's an
218:16 - object already on top of it and I
218:18 - interact again then I want to give it to
218:19 - the player
218:20 - okay so here on the clear counter script
218:22 - we've got our interact function in order
218:24 - to make that work we need to have a
218:26 - reference to the player so I just passed
218:28 - it in over here as an argument for our
218:30 - interaction so just pass in the player
218:32 - reference
218:33 - now over here let's do the logic that I
218:35 - send so if the kitchen object is known
218:37 - so if there's nothing here then let's
218:38 - spawn it okay great but if there is
218:40 - something
218:42 - then let's give the object to the player
218:45 - so how we change the object parent is
218:48 - just like what we did up here so let's
218:50 - go into that one set the clear counter
218:51 - and pass in deploy a reference except of
218:54 - course this obviously does not work the
218:56 - parameter on this function is supposed
218:58 - to be of clear counter it does not work
219:00 - with the type of player recently on the
219:02 - logic that we built for setting the
219:04 - parent and change the parent this whole
219:06 - thing only works with the counter so it
219:08 - does not work with any other type so we
219:10 - cannot set the player as a parent now to
219:12 - solve this problem is exactly where
219:14 - c-sharp interfaces come in again I have
219:16 - a video going through them in detail
219:18 - definitely watch it and learn everything
219:19 - about interfaces basically what it is is
219:22 - a contract you define some functions in
219:24 - the interface and then any type can
219:27 - Implement that interface and you can
219:29 - write some code that works with the
219:30 - interface which in turn means that the
219:32 - code won't work with any type as long as
219:33 - it implements that interface
219:35 - so in this specific example we're going
219:38 - to make an interface to represent a
219:39 - kitchen object parent then we're going
219:41 - to implement that interface on both the
219:43 - counter and the player and that way both
219:45 - of them won't be able to be parents of a
219:47 - kitchen object so let's do exactly that
219:49 - now the first thing we do to Define an
219:51 - interface is Let's Make a c-sharp script
219:53 - so let's right click create new c-sharp
219:55 - script and now the standard is to start
219:57 - interface names with the capital I and
220:00 - then the name so in this case let's name
220:01 - it I
220:03 - kitchen object parents
220:05 - and let's open it okay so now to make an
220:09 - interface first of all this does not
220:11 - extend mono Behavior nope and secondly
220:13 - this is not a class instead this is an
220:16 - interface now like I said an interface
220:18 - is essentially a contract where each
220:20 - class that implements that interface
220:22 - must follow that contract
220:23 - what that really means is you can define
220:25 - a bunch of functions here by the way
220:27 - quick note you can also define
220:29 - properties but not Fields I cover all of
220:31 - that in the dedicated interface video
220:33 - but for now here we just want some
220:35 - functions like for example let's just
220:37 - put all of the parent functions that we
220:38 - made previously on the counter
220:40 - so over here on the corner counter a
220:42 - while ago we made all these functions
220:44 - that we needed to make it work as a
220:45 - kitchen object parent
220:47 - so we got the transform set kitchen
220:49 - object get it clear it then has it so
220:51 - let's just copy all this and paste it
220:52 - over here on the interface
220:54 - however one important note is on the
220:56 - interfaces you don't actually include
220:58 - any function implementation
221:00 - the implementation is up to the class
221:01 - that implements this interface although
221:03 - again I should also point out another
221:05 - quick note as of c-sharp 7 you can
221:07 - include a default implementation but
221:09 - that's for more advanced use cases so
221:11 - for here let's just use the basic and
221:13 - not apply any default implementation
221:15 - right here so we just defined the
221:17 - function
221:17 - and put a semicolon so just like this
221:20 - just the function definition with the
221:22 - exact signature so just like this okay
221:25 - so now that we have defined our
221:27 - interface and all the functions that we
221:28 - want to have with this now let's go on
221:31 - to the counter script so over here on
221:33 - the clear counter script over here let's
221:35 - implement the interface and the way we
221:37 - do that is pretty much exactly the same
221:39 - as by extending a class so over here we
221:41 - are already extending Model Behavior
221:43 - then let's set a comment and let's say
221:44 - we are also implementing the ikitchen
221:47 - object parent interface
221:48 - so right now you might be wondering so
221:51 - this is pretty much the same thing as
221:52 - extending a base class and kind of
221:55 - except for one huge difference
221:57 - when extending a base class you can only
221:59 - have a single Base Class like for
222:02 - example over here we have monobehavior
222:04 - you cannot extend multiple base classes
222:06 - there can only be one however when it
222:09 - comes to interfaces you can Implement as
222:11 - many interfaces as you want so over here
222:13 - we have defined our interface and right
222:15 - now we don't even have any errors that's
222:17 - because we already implemented pretty
222:19 - much all the exact functions also Visual
222:21 - Studio has a really nice software icon
222:23 - over here on the left side it is
222:25 - basically saying that this function this
222:27 - implementation is based on the interface
222:28 - but let's see what happens if I decide
222:30 - to comment out these functions so if I
222:33 - comment out all of this
222:35 - and if there we go over here we have an
222:37 - error it is telling us that this class
222:39 - does not implement the members for the
222:41 - interface like I said an interface is
222:43 - like a contract so you must write all of
222:46 - the functions included in the interface
222:48 - so we must Implement these so let's get
222:50 - rid of the comments okay
222:52 - with this our interface is perfectly
222:54 - working over here on the calendar
222:55 - counter
222:56 - now let's just go into the kitchen
222:58 - object over here on this script
223:00 - for now we're still working with the
223:02 - type clear counter so let's just
223:04 - refactor this to instead of working with
223:06 - a clear counter let's make it work with
223:07 - a kitchen object parent
223:09 - so let's just change this from type that
223:12 - to Kitchen object parent let's also
223:14 - rename this so let's use Ctrl RR for the
223:16 - kitchen object parent
223:19 - then we've got a function to return the
223:20 - kitchen object okay that's good for this
223:22 - one instead of setting your counter and
223:23 - let's once again rename this to set
223:25 - kitchen object parent
223:28 - and inside again we receive of type I
223:31 - kitchen object parent
223:34 - then let's also rename the parameter to
223:36 - Kitchen object parents
223:38 - okay so all the names here I have
223:40 - changed okay they're all correct we set
223:42 - it we assign it over here instead of
223:44 - counter let's say kitchen object parent
223:46 - already has that so just like this
223:49 - and finally down here let's return I
223:51 - kitchen object parent and rename this to
223:54 - get kitchen object parent
223:57 - and we return that
223:59 - all right so we have changed everything
224:00 - I can even do control F to search for
224:02 - counter and nope there's no instance of
224:04 - any counter so all this code has now
224:06 - been Rewritten to work with a kitchen
224:08 - object parent
224:09 - something like this everything should be
224:11 - working it's only the same as previously
224:12 - we have no errors here
224:14 - and over here on the clear counter we
224:16 - just have this error on the player and
224:17 - let's fix this in a little bit for now
224:19 - let's just comment it let's just test it
224:21 - out to see if everything still works
224:22 - exactly the same as previously also one
224:24 - final thing since we modified the
224:26 - interact function over here on the
224:27 - player class when we have the interact
224:29 - we just need to pass in this reference
224:31 - okay so let's test
224:33 - all right so here we are let's approach
224:35 - this one interact yep there it is now
224:37 - let me press the testing key and if
224:39 - there go it does move okay so everything
224:41 - is still working exactly the same as
224:42 - previously once again another successful
224:44 - refactoring now here comes the magical
224:47 - moment so right now again everything is
224:49 - still working exactly the same as
224:50 - previously so we can only have counters
224:52 - as parents but now let's go over here
224:54 - onto the player script and over here
224:56 - let's also implement the same interface
224:58 - so let's implement the eye kitchen
225:00 - object parent
225:01 - and again as usual we have our error so
225:03 - we need to implement this
225:04 - also again Visual Studio is very helpful
225:06 - so we can click on the light bulb icon
225:09 - and let's say implement the interface
225:11 - and if we scroll down here it will
225:13 - automatically create all these functions
225:15 - so let's just actually Implement them
225:18 - so for implementing this interface the
225:20 - code is really going to be exactly the
225:21 - same
225:22 - so let's go up here into the clear
225:24 - counter let's go down find all of these
225:26 - functions let's copy them and on the
225:28 - player let's paste them down here at the
225:30 - bottom
225:31 - so we just need to also pick up the
225:33 - kitchen object as well as a reference to
225:35 - the top point so over here on the clear
225:37 - counter and let's just grab both those
225:40 - so let's just grab the kitchen object so
225:42 - go into the player and over here let's
225:43 - add a film for the kitchen object and
225:46 - finally let's add another one for the
225:47 - counter top point so over here a
225:49 - serialized film for the counter top
225:50 - point
225:51 - except obviously the player is not a
225:53 - counter so this name makes no sense on
225:55 - the player so let's just quickly rename
225:57 - this and set call it kitchen object home
226:00 - point
226:01 - okay here we have our new name we've got
226:03 - the kitchen object and down here all of
226:05 - our functions they're all working no
226:07 - errors all right now let's just assign
226:09 - this in the editor
226:11 - so over here let's just go into our
226:13 - player there's a player script and
226:14 - requires a reference to the kitchen
226:16 - object home point
226:17 - so for that let's do it just like we did
226:19 - for the Counterpoint so inside the
226:21 - player let's create an empty game object
226:23 - currently the kitchen object hold points
226:26 - and I always just position it just
226:29 - slightly in front of the player
226:31 - so let's put it on a x of 0 on a y of
226:34 - 1.3 and on a set of one so there you go
226:36 - just ahead that's where the player is
226:38 - going to be holding the objects finally
226:40 - over here on the player let's just drag
226:42 - that reference
226:43 - okay so far so good also one note here
226:46 - like I mentioned previously in order to
226:48 - implement the interface it requires you
226:50 - to write the function code
226:51 - basically what this means is that
226:53 - different objects can implement the
226:55 - exact same interface whilst having
226:56 - different implementations
226:58 - so for example over here on the player
227:00 - when setting the kitchen object
227:02 - perhaps over here you could play some
227:04 - kind of item grab animation or maybe
227:06 - when clearing a kitchen object you could
227:08 - do some kind of logging
227:09 - the only thing that needs to match
227:11 - perfectly is just the function signature
227:13 - and the function signature that means
227:15 - the return type as well as the name and
227:17 - any parameters the implementation itself
227:19 - that is up to the class that wants to
227:21 - implement that interface but in this
227:23 - case we wanted to behave pretty much
227:25 - exam the same way so like this it should
227:26 - be working
227:28 - so we can now go back here onto the
227:29 - clear counter script and okay we have
227:32 - our interaction all right great
227:33 - so if there's nothing we're going to
227:35 - spawn it and if there is something on
227:36 - top of it we want to give it to the
227:38 - player so now let's go into the kitchen
227:39 - object and call the function set kitchen
227:42 - object parent and pass in the play
227:43 - reference
227:44 - and that's it no errors because again
227:46 - this takes a parameter of type kitchen
227:48 - object parent and the player does
227:50 - implement that interface so that's all
227:51 - valid
227:52 - now with this let's says and see if our
227:54 - code is working
227:55 - alright so here we are and let's
227:57 - interact with this counter and there you
227:58 - go the object has been spawned and now
228:01 - if I interact again if they're going to
228:03 - look that the player picked up the
228:04 - object and since our logic is using a
228:06 - transform home Point as the parent the
228:09 - player is automatically carrying this
228:10 - tomato alright awesome so this is really
228:13 - great
228:15 - now over here on the counter we no
228:16 - longer need all of this testing code we
228:18 - now have the ability to actually pick up
228:20 - objects from the player so let's get rid
228:23 - of all this so we don't need this
228:24 - testing code don't need a reference to
228:26 - the second color counter or the testing
228:28 - okay great so here you can see the power
228:31 - of interfaces by just implementing the
228:33 - interface we can now place an item
228:35 - anywhere we want and importantly on any
228:38 - type we want
228:39 - so the counter can hold a kitchen object
228:41 - the player can also hold it we could
228:44 - make a dog character and make it hold a
228:46 - kitchen object we could make a vehicle
228:47 - hold it or anything again interfaces are
228:50 - really really awesome one of the best C
228:52 - sharp features definitely go ahead pause
228:54 - this course for now and watch a
228:56 - dedicated video on them you should be
228:58 - very very familiar with interfaces they
229:00 - will help you in making all kinds of
229:01 - systems and games
229:03 - if you want to see a clear example of
229:04 - the power of interface you can go watch
229:06 - my how to interact with NPC's video that
229:09 - video takes advantage of interface to
229:10 - make sure that the player can interact
229:12 - with any kind of object alright so
229:14 - thanks to interface we can now change
229:16 - the parent of the kitchen object and put
229:18 - it on either a counter or the player now
229:20 - in the next lecture let's make a proper
229:22 - different counter type
229:24 - hello and welcome I'm your code monkey
229:26 - in this lecture we're going to create a
229:28 - different counter type from where we can
229:30 - grab some ingredients
229:32 - okay so far here we have our character
229:34 - working and we have an empty counter and
229:36 - by interacting with it we can spawn an
229:37 - object but obviously that's not the
229:40 - behavior we want in the final game we
229:42 - want different counter types that do
229:43 - different things the cleaner counter
229:45 - should only be used as a place for
229:46 - putting down and grabbing objects it
229:48 - should not spawn anything
229:50 - so let's build a new counter type
229:52 - and for that one option is to make a
229:54 - brand new prefab and build it on from
229:56 - scratch another option is we can
229:58 - duplicate this counter and change a
230:00 - bunch of things or there's a third
230:02 - option that was added in recent TNT
230:03 - versions
230:04 - you can now have what is called prefab
230:07 - variants meaning that we can have a base
230:09 - counter and then we can make variants
230:11 - for all the types so let's do exactly
230:14 - that to learn about prefab variants now
230:16 - first let's duplicate this one just so
230:18 - we don't lose any changes
230:19 - let's rename this prefab to underscore
230:22 - base counter
230:23 - no I'd like to add an underscore just so
230:26 - that the bass prefab is on top since
230:27 - this window is sorted alphabetically
230:30 - now let's go inside the base counter
230:31 - let's go into the scene view so here it
230:33 - is
230:34 - and recently over here we only want to
230:37 - have all of the things that all of the
230:38 - counters will have so all the counters
230:40 - will have a boxing ladder only the same
230:43 - shape so that's good they will also all
230:45 - have a counter top point
230:47 - however for the visual different
230:49 - counters will have different Visions so
230:50 - let's get rid of this same thing for the
230:52 - selected let's get rid of this
230:54 - and on the actual object different
230:56 - encounters will have different Scripts
230:58 - so let's also get rid of this
231:00 - okay so that's it this is the base
231:02 - counter it only has all the things that
231:05 - every single encounter will have so
231:07 - let's go ahead save this prefab go back
231:09 - outside and now let's right click on the
231:11 - base counter
231:13 - and go into create and over here let's
231:16 - scroll down and find the prefab variant
231:18 - now let's name this the clear counter
231:20 - except obviously we can't have two
231:22 - different names so let's put this one
231:24 - into backup we're going to get rid of
231:26 - this one in a little bit
231:27 - so on the very end let's name it clear
231:29 - counter
231:31 - let's open up this variant
231:33 - and now here let's add everything just
231:34 - like we had on the own player counter so
231:37 - since it's going to be exactly let's
231:38 - actually go inside the backup one so
231:41 - here let's just copy the visual in the
231:43 - selected so let's copy this
231:45 - go back inside the clear counter variant
231:47 - and over here only let's paste it so
231:48 - Ctrl V
231:50 - see if there it is he selected any
231:52 - visual
231:53 - finally just scripts over here let's add
231:55 - the clear counter script
231:57 - and now let's just write the references
231:59 - so the kitchen object we're actually
232:01 - going to remove this in a little bit but
232:02 - for now let's assign it the counter top
232:04 - Point Let's drag it and on the selected
232:06 - we also need to drag the kitchen counter
232:08 - reference
232:09 - okay so here is our clear counter as a
232:12 - variant of the base counter so let's go
232:15 - ahead save this and go back outside
232:17 - and now we can finally delete the owned
232:20 - prefab of the clear counter so let's go
232:21 - ahead and delete this
232:23 - and of course over here on the scene
232:24 - we've got some broken prefabs so let's
232:26 - get rid of both these and let's drop the
232:28 - clear counter variant so let's drop it
232:30 - place it over here so let's put it on X
232:33 - of 0 y of zero and Z of 3.5
232:37 - okay so that's the clear counter and
232:39 - let's just put another one to the side
232:40 - and perfectly on the side so on an X of
232:42 - minus 1.5 okay now we can begin making
232:45 - our container counter
232:47 - so for that once again let's make a
232:49 - variant so right click on the base
232:51 - counter and go into create and let's
232:52 - create a prefab variant
232:54 - call this the container counter
232:57 - and let's go inside of it now here first
232:59 - thing we need is the visual so let's go
233:01 - inside our assets we've got the prefab
233:03 - visuals inside we have the counters
233:05 - visuals and let's find the container
233:08 - counter so let's drag it inside again
233:10 - for the low composition make sure it's
233:12 - on zero zero zero okay great
233:14 - then we need to make the selected so
233:16 - let's duplicate this visual let's rename
233:18 - this to selecton
233:20 - let's go inside on all of these
233:23 - then let's modify the material for the
233:25 - selected material so let's click on the
233:27 - circle icon and select the counter
233:28 - select material okay we've got our nice
233:30 - little ghost icon
233:32 - and just like we did previously let's
233:34 - start with these disabled so all these
233:35 - game options disabled so they are hidden
233:37 - and on the selected let's make sure the
233:39 - scale is one percent bigger so 1.01
233:42 - also in the selected this one does not
233:44 - need an animator so let's get rid of
233:45 - this
233:46 - now let's add the selected counter
233:49 - visual and obviously for this one we're
233:51 - eventually going to need to refactor it
233:53 - to support multiple visual objects as
233:55 - you can see this selected has multiple
233:57 - but for now just make sure that it works
233:59 - let's just drag just the first one okay
234:01 - great
234:02 - so our container counter has been built
234:04 - the only thing that we need is the main
234:06 - logic script so let's do that
234:08 - let's go into our scripts folder let's
234:10 - create a brand new c-sharp script
234:12 - name it the container counter
234:15 - and let's select the main game object
234:17 - attach a script and let's open it
234:20 - alright so now here let's first think
234:22 - what we want for this counter we want
234:24 - the player to interact with it and when
234:26 - it does we want to spawn an ingredient
234:28 - and give it to the player so that means
234:30 - that we're going to want pretty much the
234:31 - exact same behavior that we made over
234:33 - here on the clear counter so when the
234:35 - player interacts we spawn and we give it
234:37 - to the player so let's actually copy all
234:39 - of this code let's go into the Container
234:41 - counter and over here let's face this
234:44 - we just need to grab the references to
234:46 - the kitchen object and the kitchen
234:47 - object as so so again just like we did
234:49 - on the container counter let's copy all
234:51 - these references
234:53 - and over here let's paste all of them
234:55 - and of course here we have an error in
234:57 - order for this work this needs to
234:58 - implement our interface and let's do
235:00 - exactly that so let's implement the eye
235:02 - kitchen object parent
235:04 - and back in the clear counter let's just
235:06 - copy the exact same code so all of these
235:07 - functions let's just copy them and on
235:09 - the container counter just paste them
235:11 - okay great
235:12 - so we don't have any more errors here so
235:15 - everything should work we should be able
235:17 - to interact with the container counter
235:18 - and we should be able to see an object
235:20 - being spawned on top of it
235:22 - over here in the editor let's just make
235:23 - sure to assign it so let's assign a
235:25 - default kitchen object so let's say
235:27 - tomato and the counter top Point Let's
235:29 - drag the reference and okay everything
235:31 - else should be working so over here on
235:33 - the selected we've got the visual game
235:35 - object on the container counter we've
235:36 - got this okay great so let's go outside
235:38 - into scene View
235:39 - and over here let's just Place some
235:41 - container counters so let's drag one up
235:43 - there
235:44 - let's place it on an X of 1.5 on a y of
235:47 - 0 and Z of 3.5 and let's also Place
235:50 - another one down here so let's rotate it
235:53 - to face it upwards
235:55 - okay so on position zero zero minus five
235:57 - okay great
235:59 - and let's make them spawn different
236:00 - things
236:01 - so on this one up here let's actually
236:03 - spawn a cheese block and on this one
236:05 - down here let's one tomato so let's also
236:07 - modify the icon here
236:09 - so from cheese block and let's put a
236:12 - tomato icon so here it is
236:14 - okay we've got two counters and two
236:16 - clear counters so let's test
236:18 - so here we are and if I approach a
236:20 - container counter and I press the
236:21 - interact button and nope nothing
236:23 - happened we cannot interact with that at
236:25 - all even the selection visual even that
236:28 - one is broken so as I approach note the
236:30 - visual is not showing up
236:32 - now the reason for this is actually
236:33 - pretty obvious
236:34 - if we go over here on the player script
236:36 - down here when we're handling our
236:39 - interactions so let's go into the handle
236:41 - interactions function
236:42 - over here we are doing a recast and we
236:45 - are trying to get component of type
236:46 - clear counter
236:48 - so basically we're not doing anything if
236:50 - that object has a container counter
236:51 - instead of a clear counter so again we
236:54 - have a similar issue to the one that we
236:55 - had in the object parent logic basically
236:58 - we have two types a clear counter and a
237:00 - container counter and we want the player
237:02 - to be able to interact with both them
237:04 - so as a solution for this exact same
237:07 - problem we could also Implement an
237:08 - interface just like we did that would
237:10 - work that would enable the player to
237:12 - interact with multiple counters but in
237:14 - this case since the counters are all
237:16 - very similar very related objects
237:18 - they're all going to be kitchen counters
237:19 - as opposed to object parents where the
237:21 - player and encounter are completely
237:23 - different
237:23 - in this case since they are all very
237:25 - similar a better approach is actually to
237:27 - use inheritance now here I should point
237:29 - out that inheritance is one of those
237:31 - things that is simultaneously very
237:33 - powerful but also very dangerous usually
237:35 - beginners get really excited when they
237:37 - first hear about inheritance but after
237:38 - gaining some experience they start to
237:40 - see the massive downsides
237:42 - one funny joke about it is let's say you
237:44 - want to write some code that all it
237:45 - needs is a Banana class but because of
237:48 - messy inheritance you end up with a
237:49 - monkey and the entire jungle behind it
237:51 - basically the banana extends a monkey
237:53 - which extends a tree which extends the
237:55 - jungle and so on so you just want a
237:57 - small thing but because of a complex
237:59 - inheritance you end up picking up a huge
238:00 - object some of that to say inheritance
238:02 - is something you must use very very
238:04 - carefully it's a powerful tool
238:06 - definitely but you need to make sure
238:08 - that you absolutely use it in the right
238:10 - approach for the problem you're trying
238:11 - to solve now in this case like I said
238:13 - since all of the counters are going to
238:15 - be very closely related in this case it
238:17 - does make sense
238:18 - and of course in the future if that does
238:20 - change we can always refactor
238:22 - if you're a beginner definitely go ahead
238:24 - and research a bit more on c-sharp
238:26 - inheritance the pros and cons
238:28 - I don't have any dedicated video on that
238:30 - topic myself but if you search I'm sure
238:32 - you'll find tons of content again it's a
238:34 - very powerful but also very dangerous
238:36 - tool so definitely use it wisely
238:38 - over here let's make sure we rise so
238:40 - let's use it
238:42 - first thing we need to do is to find the
238:43 - base counter class so let's create a new
238:45 - c-sharp script let's call it the base
238:48 - counter
238:49 - so over here on the script let's get rid
238:51 - of the functions we don't want any
238:53 - default functions and let's also make
238:55 - sure that we do extend mono Behavior we
238:57 - do want that we still want to use this
238:59 - as a component
239:00 - so let's leave the script just like this
239:02 - let's save it
239:03 - then let's go over here into the clear
239:06 - counter script
239:07 - and on this one instead of extending
239:09 - Model Behavior let's extend the base
239:10 - counter
239:12 - okay that's it that's the only change
239:13 - and now let's go into the Container
239:15 - counter and over here same thing let's
239:16 - extend the base counter inside of Model
239:18 - Behavior so now both these counters
239:20 - extend the exact same base counter
239:22 - script so now if we go into the player
239:24 - score so here we are on the player
239:26 - script and on the handle interactions
239:28 - function over here instead of trying to
239:30 - get a component of type player counter
239:32 - let's try to get component of type base
239:34 - counter so let's also rename the so
239:36 - control RR to rename rename this to base
239:39 - counter and of course we need to rename
239:42 - all these references that expect a clear
239:44 - counter instead of the base counter so
239:46 - over here for the selected counter let's
239:47 - modify the type to base counter then
239:50 - also up here when we've got the event RX
239:53 - let's modify the type okay
239:55 - so over here we have the interactor
239:57 - let's leave this for a bit let's go down
239:59 - and let's fix this issue so let's go
240:01 - down into that function to set the
240:02 - selected counter instead of this time
240:04 - let's receive a base counter
240:06 - okay so all of these errors have been
240:08 - solved there's only one left and it's
240:10 - this one the interact
240:11 - we see this error because obviously the
240:13 - base less does not have any kind of
240:15 - interact method so let's add that
240:18 - now for adding methods to a base layer
240:20 - it's sectionally very simple it's really
240:21 - just like any other method so first the
240:23 - accessor for the interact we want the
240:25 - player to be able to access it so let's
240:27 - make it public
240:28 - and also since we're talking about
240:29 - inheritance I should probably mention
240:31 - the other accessor now you already know
240:33 - about public and you also already know
240:35 - about private but there's another one
240:37 - you might not know which is called
240:38 - protected
240:40 - basically this one means that whatever
240:42 - function we defined with this successor
240:43 - it is going to be accessible to this
240:45 - class and any class that extends it so
240:48 - for example if we had a function that
240:50 - was protected the clear counter could
240:52 - count this function because it does
240:54 - extend this Base Class however the
240:56 - player would not be able to call this
240:57 - because it is protected now in our case
241:00 - for the interact action we do want to
241:01 - play the comet so let's make it public
241:03 - just like we had previously then another
241:05 - keyword for every function that we want
241:08 - the chunk lesses to be able to implement
241:10 - in their own way we can Define it as
241:11 - virtual
241:12 - and finally the function signature as
241:14 - normal so for the interact we made a
241:16 - return void call it interact and we
241:19 - received a player argument
241:24 - okay so that's it that's our basic
241:25 - signature
241:27 - for the implementation let's leave it
241:28 - empty over here on the base counter so
241:30 - by default it's not going to do anything
241:32 - in the game design that we're building
241:34 - we're never actually going to end up
241:35 - with anything like this
241:37 - so if you want for safety we can just
241:38 - add a debug.log error
241:41 - to say just base counter.interact
241:44 - because this should never be triggered
241:46 - also I shouldn't point out for a more
241:48 - advanced method
241:49 - instead of making it virtual you could
241:51 - make it abstract and basically what that
241:53 - does is that forces all the classes to
241:55 - implement their own implementation
241:58 - so you would make this extract and just
242:00 - put it just like this as if this were an
242:02 - interface but in doing so you would also
242:05 - need to define a base counter as
242:06 - abstract and so on so basically this is
242:08 - a more advanced method so don't worry
242:10 - about it for now let's keep it a bit
242:11 - more simple so let's make it just
242:14 - virtual void interact okay great
242:17 - so we have this let's save this and now
242:19 - if we go on the calendar counter
242:21 - over here on the interact notice how we
242:24 - have a green screen line
242:26 - basically this is a warning it's telling
242:28 - us that we are hiding the base function
242:30 - now in reality we don't want to hide it
242:32 - instead we want to override it so before
242:35 - the void before the return type we just
242:37 - have the keyword override
242:39 - and Yep this will now override the base
242:41 - function so when the player interacts
242:44 - with an object of type based counter and
242:46 - that object is actually a clear counter
242:47 - when the player calls the interact
242:49 - function instead of running this code
242:51 - it's actually going to run this code
242:53 - now let's do the same thing on the
242:55 - container counter so over here let's
242:56 - also add the
242:58 - keyword override to override the base
243:01 - function okay great so we have no errors
243:03 - here and on the player we also don't
243:05 - have any more errors since that one does
243:07 - now implement the interact function
243:09 - so with this one it says and everything
243:10 - should still be working so over here
243:12 - let's approach the entire counter and
243:14 - let's interact with it any up it does
243:16 - work it spawn some cheese and down here
243:18 - yep it's on the tomato and then if we go
243:20 - on to the empty counter and interact and
243:22 - yep it still works okay so here we added
243:25 - the ability to interact with two
243:27 - different counter types alright great
243:28 - now knows how the selected logic isn't
243:31 - really working well you can see the
243:33 - container counters they are both
243:35 - selected even though the player is not
243:37 - looking at them and actually if I
243:39 - approach it then it actually becomes
243:40 - deselected basically the reason for that
243:42 - is because these selected square of that
243:44 - one is still referencing the clear
243:46 - counter inside of the base counter
243:48 - so right now it's only being selected
243:49 - when the sunlight the counter is known
243:51 - so that is why as I approach it actually
243:52 - hides itself so let's fix this let's go
243:56 - inside the container counter prefab and
243:58 - inside we've got the selected any up
244:00 - over there we have a reference to that
244:01 - so let's open up this script and over
244:03 - here all we need to do is just modify
244:05 - this time so let's make it a type base
244:07 - counter and let's rename this to base
244:09 - counter
244:12 - okay that's the only change we need
244:14 - and by the way since we're here let's
244:15 - also fix the other issue the issue we
244:18 - had where we need to support more than
244:20 - one visual game object
244:22 - so instead of having a field of type
244:24 - just game object let's receive a game
244:25 - object ring
244:27 - so let's modify this to game object
244:28 - array
244:30 - and then down here on the show hide is
244:32 - actually very simple so let's just do a
244:33 - four inch game object for the visual
244:36 - game object
244:40 - in the visual game object ring we go
244:43 - inside set it to true and on this one we
244:46 - set it to false
244:48 - okay that's it super simple
244:51 - now let's just update the prefabs so
244:53 - first over here on the container counter
244:55 - let's write the container counter
244:56 - reference as the base counter okay great
244:59 - and for divisions let's just drag all of
245:01 - them
245:02 - so let's write the counters only drag it
245:04 - on top then the counter hole drag it on
245:06 - top then the single door drag it and the
245:09 - black drag it and also by the way over
245:11 - here on this counter this one actually
245:13 - has an objects right
245:15 - this is the actual Sprite in there but
245:17 - for the selected we really don't want
245:18 - that so if I enable this game object
245:21 - here we've got the object Sprite let's
245:22 - actually delete this
245:24 - we don't need the actual icon Sprite to
245:26 - be highlighted so let's leave it just
245:27 - like this so we only have these four
245:29 - objects and all four of them are on the
245:31 - list
245:31 - okay that's right so all the references
245:33 - in here they're all working perfectly
245:36 - so let's go back outside let's save the
245:38 - prefab let's go inside the empty clear
245:40 - counter
245:41 - and on this one same thing on the
245:43 - selected let's Drag The Insider
245:45 - reference and for the base counter let's
245:47 - also drag that reference
245:49 - okay so let's go outside save it and
245:51 - let's test
245:53 - and now let's see if the selected Works
245:54 - once I approach this one yep it works
245:56 - yep it works and on this one yep it
245:58 - works and down here yep it works all
246:00 - right awesome so we can interact and we
246:02 - can highlight our selection okay
246:04 - everything is working great so now that
246:07 - all the code is working we can inspect
246:08 - the code to see if we can refactor
246:10 - anything
246:11 - we can see for example if there's any
246:13 - kind of common logic that all of the
246:15 - counters share that we should probably
246:16 - write in the base counter
246:19 - and you can see right away that both the
246:20 - clear counter and the container counter
246:22 - both of them implement the kitchen
246:24 - object parent interface that behavior is
246:26 - something that all of the encounters
246:28 - will share
246:29 - so instead of defining it on each
246:30 - counter itself let's actually do it on
246:32 - the base class instead
246:34 - so let's get rid of the interface
246:36 - implementation here and also on the
246:38 - container counter let's get rid of that
246:40 - and set on base counter and let's
246:42 - Implement that one so I catch an object
246:44 - parent and for the functions let's do
246:46 - the same thing so let's cut this one
246:49 - from here and let's paste it on the base
246:51 - counter
246:52 - it's okay now we need these two points
246:54 - so let's go ahead copy all of this let's
246:56 - go into the base counter and paste in
246:58 - except for the base one doesn't need a
247:00 - kitchen object so so just the counter
247:02 - top point and the kitchen object
247:04 - okay so there are no errors on this one
247:06 - let's go into the container
247:08 - let's get rid of the kitchen object and
247:10 - the counter top Point okay great
247:12 - now we see an error but before we worry
247:14 - about that let's actually go into the
247:15 - clear counter and let's do the same
247:16 - thing so let's get rid of this get rid
247:18 - of this and down here get rid of all
247:20 - these functions
247:22 - okay so now the counter scripts are much
247:24 - much more simple
247:25 - all of the common code is now written
247:27 - directly on the base counter
247:29 - now for solving this the container
247:31 - counter needs to know if there's a
247:33 - kitchen object on top of it so now here
247:35 - we have an interesting question with two
247:37 - possible approaches
247:39 - basically we need access to this object
247:42 - so one approach would be to make this
247:44 - protected like I said protected means
247:46 - that any classes that extend this base
247:48 - counter class any of those classes can
247:51 - then modify that field something like
247:52 - this yep there is no more errors that's
247:54 - one approach
247:55 - and the other approach is to instead
247:57 - keep this one as private and whenever we
248:00 - want to interact with it we simply
248:02 - interact through these functions both
248:04 - approaches can work and when in doubt as
248:06 - usual you should probably go with the
248:08 - more limited option so let's leave it as
248:10 - private and work with these functions
248:12 - and send
248:13 - over here on the container counter
248:14 - instead of testing if the kitchen object
248:16 - is no let's just test has kitchen object
248:19 - so if it does not have a kitchen object
248:21 - then we're going to spawn it and for
248:23 - spawning over here we could grab the
248:25 - actual transform funnel
248:27 - so this one up here we could call this
248:29 - function to get it or since that is
248:31 - actually going to be handled
248:32 - automatically when we call this function
248:33 - to set the parent then let's actually
248:35 - not use this at all
248:37 - so we just spawn it and set the kitchen
248:39 - object parent okay great
248:41 - so now let's just look at the clear
248:43 - counter for this one like I said it's
248:45 - not really meant to spawn anything solid
248:47 - sectionally remove all of this code
248:49 - this one is only going to serve to pick
248:51 - up and drop items we're going to handle
248:53 - that in the next lecture but for now
248:55 - let's just go back into the Container
248:57 - counter and let's do the proper logic
248:59 - that I mentioned in the beginning
249:00 - basically on this one we want to spawn
249:02 - the object and we want to immediately
249:04 - give it to the player so when we call
249:06 - set kitchen object parent instead of
249:08 - passing in this let's pass in the player
249:10 - reference
249:10 - and that's really it for the container
249:12 - counter this is all we're going to do so
249:14 - the player interacts and it spawns an
249:16 - object and gives it to the player okay
249:18 - so that's it with this as you can see
249:20 - the code for all of our counters is much
249:23 - much more simplified so basically it
249:25 - only handles the logic related to that
249:26 - specific counter everything else is on
249:28 - the base counter so let's test this
249:31 - so here we are and if I approach the
249:33 - counter interact any of their go spawn
249:35 - some cheese and gave it to the player
249:37 - okay great now just for fun when I made
249:40 - these assets I shall include a nice
249:41 - animation
249:42 - so if you go inside the container
249:44 - counter over here on the visual note how
249:46 - this already has an animator with an
249:48 - animator control and attached to it
249:50 - you can double click to open it up and
249:52 - over here you can see it's very simple
249:54 - basically just has two animations one is
249:56 - the container close and one is container
249:58 - opening and closing these transitions
250:00 - are basically triggered by this
250:01 - parameter this is a trigger parameter so
250:04 - when triggers goes into the open close
250:06 - and when this one ends goes back into
250:07 - closed so let's just quickly add these
250:10 - nice animations however again as usual
250:12 - let's make sure to write some good clean
250:13 - code so let's not add the visual over
250:16 - here on the logic script instead let's
250:18 - make a proper new script over here let's
250:20 - create a new c-sharp script
250:23 - call this the container counter visual
250:27 - okay now we want to attach this only to
250:29 - the visual game object so only this one
250:31 - let's attach okay
250:33 - and over here the first thing we need is
250:35 - to get the animator
250:37 - so let's sort of film for the animator
250:39 - and since it's on the exact same object
250:41 - we can just make an awake and get
250:43 - component of type animator
250:46 - and we just assigned this field okay
250:51 - so with this we have the animator now we
250:53 - just need to know when we should play
250:55 - the animation so let's go over here on
250:57 - the container counter script and
250:58 - basically let's make an event that we're
250:59 - going to fire when the player grabs an
251:01 - object
251:02 - so let's make a public event of time
251:05 - let's stick with the standard so let's
251:06 - use event handler inside using system
251:08 - okay
251:09 - let's name this on player grabbed object
251:14 - then down here when the player interacts
251:16 - and gets an object let's fire off this
251:17 - event so invoke
251:19 - let's invoke with this and event RX dot
251:21 - empty
251:24 - okay so we are firing off this event
251:27 - and over here on the visual first we
251:28 - need the film for the container counter
251:30 - so let's set it up here let's add a
251:31 - serialized field of tribe container
251:34 - counter
251:37 - okay we have this build now let's listen
251:39 - to the event but again we're accessing
251:41 - an external reference so let's make sure
251:43 - to do it on start and not on awake
251:46 - so let's go into this one and listen to
251:48 - the on player grabbed object event okay
251:49 - so here we have the event and it's over
251:52 - here that we want to access the animator
251:53 - and call set trigger in order to play
251:55 - the animation again when working with
251:57 - animator parameters suddenly we do need
251:59 - to use strings there's no way around
252:01 - that but at least we can make it a bit
252:03 - more clean by defining a constant
252:05 - so here a private con string call it
252:08 - open close and let's make sure to use
252:10 - the exact same parameter name so open
252:12 - close
252:15 - and then down here on the set trigger
252:17 - let's call this trigger
252:19 - okay so that said some very simple
252:21 - visual logic
252:22 - and now over here inside the prefab all
252:24 - we need is to drag the container counter
252:26 - reference so let's drag it also make
252:28 - sure that it has the animator and the
252:30 - animated controller so with that
252:31 - everything should already be set up so
252:33 - let's go back into the scenes save the
252:35 - changes and let's hit on play
252:37 - so here we are and if I go towards the
252:39 - tomato and interact any of that I go it
252:41 - plays a nice little animation alright
252:43 - awesome okay so here we created a brand
252:46 - new counter type and we refactored our
252:48 - interact code to be able to interact
252:50 - with any counter type the player can
252:52 - interact with the container counter to
252:54 - pick up an object now the next obvious
252:56 - thing that we need is to enable the
252:57 - player to drop an object on the clear
252:59 - counter so let's do that in the next
253:01 - lecture
253:02 - hello and welcome I'm your code monkey
253:04 - in this lecture we're going to enable
253:06 - the player to pick up and drop objects
253:09 - okay so we already have the player
253:11 - working I can approach this container
253:13 - counter interact with it and yep the
253:14 - player picks up something now that's
253:16 - left is being able to put our shade
253:18 - clear counter and being able to drop
253:19 - this object so let's do that
253:21 - let's go over here on the clear counter
253:23 - script and when we interact with it
253:25 - we're going to do a bit of logic first
253:27 - let's just check if this counter is
253:29 - empty meaning if there is no kitchen
253:31 - object on it so let's test if has
253:34 - kitchen object or if not so let's say if
253:37 - we don't have a kitchen object then
253:40 - there is no kitchen object here
253:43 - and if not then there is a kitchen
253:46 - object here
253:50 - okay these are the two valid options
253:52 - so if there is nothing here then let's
253:55 - check the player itself so we go into
253:57 - the player and we can ask the same
253:59 - question so it has kitchen object
254:01 - so if the player is carrying something
254:05 - so over here the player is carrying
254:07 - something
254:09 - if so then basically we just want to
254:11 - drop that object from the player and
254:13 - drop it in here so that's very simple we
254:15 - just go into the player we get the
254:17 - kitchen object that the player is
254:19 - holding and we just modify the kitchen
254:21 - object parent onto this object
254:24 - all right so that's it just with this it
254:26 - should already be working let's do a
254:28 - quick test before we handle the rest of
254:29 - the interactions
254:30 - okay so here moving the player and if I
254:33 - just interact with a clear counter and
254:34 - nope nothing happens okay great since
254:36 - the player is not carrying anything nope
254:37 - nothing happens all right great
254:39 - now let's pick up something from the
254:41 - container counter okay so now the player
254:42 - is carrying a tomato approaching clear
254:44 - counter press a button and yep there you
254:46 - go there it is alright Awesome
254:48 - everything worked
254:49 - now this is an excellent point to know
254:51 - just how easy this was to implement and
254:54 - the reason why it was so easy was
254:55 - because we focus hard on running some
254:57 - good clean code for how the object and
254:59 - the appearance system works because we
255:01 - took some time to think about that it
255:03 - was now very easy to implement this
255:04 - brand new action so this is a very very
255:07 - clear example of the power of writing
255:09 - good clean code okay so with that now
255:11 - let's implement the rest so over here
255:14 - there's no kitchen object here and the
255:15 - player is carrying something but if not
255:17 - we've got the L so player has nothing
255:21 - so if the player doesn't have anything
255:23 - so let's not do anything so player not
255:25 - carrying anything
255:28 - so those are all the possible States up
255:30 - there and then down here if there is a
255:31 - kitchen object on this layer counter if
255:34 - so then let's check if the player has a
255:36 - kitchen object
255:38 - so in this deep layer is carrying
255:41 - something
255:42 - and if not
255:44 - then the player is not carrying anything
255:49 - so basically if there is a kitchen
255:50 - object here and the player is carrying
255:52 - something if so then we don't want to do
255:53 - anything since we can't give the player
255:55 - two items however if there is a kitchen
255:57 - object here and the player is not
255:59 - carrying anything then we want to give
256:01 - it to the player so let's just get the
256:03 - kitchen object the one that is on this
256:04 - clear counter
256:06 - and let's do the exact same thing so set
256:08 - the parent and set the parent onto the
256:10 - player okay so that's it as you can see
256:12 - some very simple logic so let's test
256:14 - okay here we are and if we interact nope
256:17 - nothing happens okay great now pick up a
256:18 - tomato go there drop it yep there it is
256:20 - now if I interact again yeah there you
256:22 - go I picked it up again so I can go
256:24 - somewhere pick it up drop it and
256:26 - everything works perfectly all right
256:28 - awesome
256:29 - now the last thing that we need to fix
256:30 - is the container counter
256:32 - right now it's giving out an object
256:34 - every time even if the player has
256:35 - something so if I pick up the other
256:37 - works now if I pick up again there you
256:39 - go we've got our nice helpful error this
256:41 - should never happen
256:43 - so let's add some nice checks
256:45 - so over here on the container counter
256:46 - okay we have our interaction
256:48 - and before we spawn anything let's just
256:50 - see if the player can pick up something
256:52 - so once again very simple let's just go
256:54 - into the player and we check does the
256:56 - player have a kitchen object if so we're
256:58 - not going to give it anything but if the
257:00 - pointer does not have a kitchen object
257:01 - then yep the player picks it up and we
257:03 - give it the object
257:10 - okay so that's it it's this simple Let's
257:13 - test
257:14 - so here we are let's pick up some cheese
257:15 - okay great now pick up another one and
257:17 - nope nothing happens okay great we're
257:19 - already carrying something so we cannot
257:20 - drop anything now drop it in there now
257:22 - pick up a tomato any of it works I can
257:24 - pick it up drop it and yep everything
257:26 - works okay great let you see one more
257:29 - thing
257:30 - over here the container counter is
257:32 - spawning the object and the object is
257:34 - the one that we assigned
257:35 - so over here in scene view we've got the
257:37 - container counter this one is placed on
257:40 - the scene and we made an override to
257:41 - spawn a cheese block
257:43 - technically we could keep doing this
257:45 - pretty much just duplicate objects
257:47 - modify the Sprite modify over here the
257:49 - kitchen object that would work but
257:51 - another better approach would be to
257:53 - Simply make some prefab variants and yep
257:55 - that does work you can make a variant of
257:57 - a variant so let's do examine that over
257:59 - here on the container counter let's
258:02 - right click going to create and let's
258:03 - create another prefab variant and let's
258:06 - say container counter this one will be
258:08 - the Tomato now let's go inside the
258:10 - prefab and over here make sure it has
258:12 - the kitchen object for the Tomato okay
258:14 - great and over there on the Sprite so
258:16 - let's find the object Sprite and choose
258:19 - the Tomato Sprite so there you go this
258:21 - one okay let's exit and Save
258:24 - all right now once again let's right
258:26 - click on the container and let's make it
258:27 - another one this is going to be the one
258:29 - for the cheese block
258:31 - so let's go inside of it and over here
258:34 - modify it for the cheese block and
258:36 - inside the actual visual let's modify
258:38 - the Sprite and sectionally down so the
258:40 - cheese block okay great let's go back
258:42 - outside
258:43 - and since we're here doing this let's
258:45 - make all of the other grab my objects
258:47 - from the containers
258:48 - so let's first make the kitchen object a
258:50 - so so let's go over here we can right
258:52 - click go into create create new kitchen
258:54 - object so let's make one for the brand
258:58 - then let's see if we get this one we're
259:00 - going to have a cabbage and finally
259:02 - we're going to have the meat Patty
259:04 - uncooked
259:05 - all right so now let's make sure to
259:06 - assign all the data for all these script
259:08 - along objects
259:09 - first we need to make the actual kitchen
259:11 - object so let's duplicate tomato name
259:13 - this one bread let's go inside of it
259:16 - and first for the kitchen object the
259:18 - song Let's make sure to drag the correct
259:19 - one okay there's the bread and for the
259:21 - visual this one is not a tomato so let's
259:23 - go inside our visual acids inside the
259:26 - prefab visuals let's pick up the bread
259:27 - visual okay there it is
259:30 - that's all we need so let's go outside
259:31 - save the changes and then select the
259:34 - bread scripting object drag the prefab
259:36 - reference okay for the Sprite this is
259:38 - the bread and finally just call it bread
259:40 - okay let's do the same thing for the
259:42 - other one so next up for the Cabbage
259:44 - let's do the Cabbage drag the Cabbage
259:47 - script object let's go inside and modify
259:49 - the visual so the Cabbage visual
259:52 - okay that's it
259:54 - then on the Cabbage scorpion object drag
259:56 - the reference for the prefab let's
259:58 - assign the Sprite and finally give it a
260:00 - name cabbage
260:02 - and finally the meat Patty and cooked so
260:04 - let's do that one so let's duplicate it
260:06 - name it meet Patty uncooked
260:11 - let's go inside modify the kitchen
260:14 - object so for this one and for the
260:16 - visual let's select here it is the meat
260:19 - Patty uncooked
260:20 - okay let's go back outside and on the
260:23 - escort mode object
260:25 - let's just drag the prefab
260:27 - assign the Sprites so this one is the
260:29 - uncooked so it's this one
260:31 - and finally meet Patty uncooked okay
260:34 - great so we added all of these squared
260:36 - more objects
260:37 - we also have the pre-files with the
260:39 - visuals and the electric scripts now
260:41 - let's just make the container counter so
260:42 - once again let's create another variant
260:44 - so prefab variant this one is for let's
260:47 - say for the brand
260:49 - then let's make all the other ones
260:51 - already so let's go make another prefab
260:53 - variant
260:54 - this one is going to be for the meat
260:56 - Patty uncooked
260:58 - and finally another variant also here
261:00 - make sure you're creating a variant of
261:02 - the container counter don't make an
261:04 - accident of creating a variant of
261:05 - something else let's make another
261:07 - variant one final one
261:09 - and this one is going to be for the
261:11 - cabbage
261:13 - okay we have all the variants now let's
261:14 - just sign them so let's go inside the
261:16 - bread and over there modify the
261:18 - description object for the brand and for
261:20 - the icon modify for the bread icon okay
261:23 - let's go to the Cabbage save the changes
261:25 - modify that one for the cabbage
261:28 - go into the icon and modify the icon and
261:32 - finally the meat Patty uncooked let's go
261:34 - ahead modify this one for that one and
261:37 - the icon put it on that one all right
261:39 - everything is working
261:41 - now let's just place them over here in
261:43 - our scene so let's get rid of the ones
261:45 - that we made some overrides
261:46 - so let's get rid of that container
261:48 - counter and set for that one let's drag
261:51 - the cheese block put it right in there
261:52 - let's put it on X 1.5 y of 0 Z of 3.5
261:57 - okay
261:58 - then down here for this one let's put
262:01 - the Cabbage next to it let's rotate it
262:03 - to face upwards
262:05 - so like that let's put it on next of
262:08 - minus 1.5 y of 0 and -5 on the Zen then
262:12 - for tomato let's get rid of this one and
262:13 - use the proper tomato one
262:16 - so let's rotate it put it on an X of 0 y
262:18 - 0 and -5
262:20 - okay next we want some bread so let's
262:23 - put the bread up here on the left side
262:24 - let's put it on X of minus three zero on
262:28 - the Y and 3.5 on the Zen
262:31 - and finally the meat Patty and Coke
262:33 - let's put it over here a bit more on the
262:34 - side
262:35 - let's put it over here on X of 7.50 and
262:38 - 3.5 alright so we have positioned all of
262:41 - them let's just make some more clear
262:43 - counters so we can actually place the
262:45 - objects so let's put this one over here
262:47 - on minus 4.5 this one over there let's
262:49 - also put some counters let's say one on
262:52 - the right side and a bunch more down
262:54 - here let's rotate them upwards
262:58 - let's put this one on 1.5 minus 5.
263:02 - and one more over here on the side
263:06 - okay great so we have all of our
263:08 - container counters as well as a bunch of
263:09 - clear counters so let's test and make
263:11 - sure that everything works okay so here
263:13 - we are let's go down pick up a tomato
263:14 - yep there's tomato now a cabbage yep
263:17 - there's a cabbage now some bread there's
263:18 - some bread and some cheese there's some
263:20 - cheese and some meat and yep there's
263:22 - some meat all right Awesome everything
263:24 - works
263:25 - so with this over here we added the
263:27 - ability to pick up and drop objects on
263:29 - an empty container and spawn them from
263:31 - all kinds of container counters now in
263:33 - the next lecture let's build the counter
263:35 - we can interact with in a very
263:36 - interesting way
263:37 - hello and welcome I'm your code monkey
263:39 - in this lecture we're going to create a
263:42 - cutting counter so this is going to be a
263:44 - counter where we can place an object
263:45 - like for example tomato and after doing
263:47 - a secondary interaction we can slice it
263:50 - however before we do that let's just fix
263:52 - one slightly annoying issue
263:54 - so right now the player is walking
263:55 - around okay that's great I can approach
263:57 - a counter and interact with it that's
263:58 - great however if I approach account from
264:00 - the sign look how the player is pointing
264:02 - towards the right and if I press the
264:05 - double key I can indeed select it but
264:07 - the player does not rotate to face the
264:08 - counter so that's just a minor visual
264:10 - issue but still I'd like to fix it so
264:12 - let's do that very quickly basically the
264:14 - issue is over here on our player script
264:15 - so we scroll down and find our handle
264:18 - movement function okay
264:19 - so here we were doing a bunch of
264:21 - Capstone cans in order to fix the
264:23 - problem with the diagonal movement so
264:25 - you try to move in One Direction if not
264:27 - try to move in just one of those and if
264:29 - we can move then we assign a move
264:31 - Direction and then move it basically the
264:33 - problem that we have here is that if I
264:36 - press W to face towards the counter then
264:38 - over here when we do this logic so it's
264:40 - going to first attempt the X movement
264:42 - only and the x is going to be zero so
264:44 - the move there X is going to be zero
264:45 - zero zero so it won't actually move
264:47 - anywhere which means it won't be able to
264:49 - move so this one becomes true which then
264:52 - sets the move direction to zero zero
264:54 - zero which then down here when we have
264:55 - our rotation it's not actually going to
264:57 - rotate to anything so we want the player
264:59 - to still not go through any objects but
265:02 - we only want to modify the move there
265:04 - over here if we actually move in any of
265:05 - these directions so the solution is
265:07 - actually super simple it's over here for
265:09 - the can move we can move if there's
265:11 - nothing on there and if the move
265:13 - direction.x is not zero
265:16 - so that's really it if we are attempting
265:20 - to move in the X at all and if there is
265:22 - nothing on there then we can move which
265:23 - means we then assign the move direction
265:25 - if not then we don't touch this and same
265:28 - thing down here so we can move if
265:30 - there's nothing on it and if the move
265:32 - there dot Zed is not zero
265:35 - so that's it just this one simple change
265:38 - and now the player should be able to
265:39 - rotate
265:40 - so here we are and if I look over there
265:42 - and the player is currently unlocking to
265:44 - the left and if I press W to point
265:46 - towards the container counter and if
265:48 - there you go the player does rotate a
265:49 - little bit so that feels a bit more
265:51 - natural
265:52 - all right so that's just a tiny visual
265:54 - thing that I wanted to fix okay so let's
265:56 - keep going
265:57 - now let's handle the actual cutting
265:59 - counter
266:00 - so first of all as usual let's make a
266:02 - counter variant so let's right click on
266:04 - the base counter create a new prefab
266:06 - variant call it the cutting counter
266:09 - let's go inside of it
266:11 - and over here first thing we need is the
266:13 - visual so let's pick up from the assets
266:15 - The Cutting countervision so here it is
266:18 - then we need the selected so let's
266:20 - duplicate this one let's rename this one
266:22 - to seal lectin and on the animator let's
266:24 - get rid of it and instead at the
266:26 - component the selected counter visual
266:28 - okay great now let's write divisions for
266:31 - the visual game object array and by the
266:33 - way here's a quick tip on the right side
266:36 - on the inspector you can see this nice
266:37 - little lock icon
266:39 - so if you click on it then that means
266:41 - this inspector will not change as you
266:43 - select other objects
266:45 - so I can click on and select something
266:46 - different and this one does not change
266:48 - it is still showing the selected object
266:50 - now this is this one when you want for
266:51 - example to drag multiple things so you
266:53 - can unlock the inspector then the
266:55 - hierarchy you can use shift click to
266:57 - select multiple objects and then just
266:58 - drag them all directly inside the array
267:01 - that's it just a nice quick tip so
267:03 - everything is done let's unlock it there
267:05 - it is okay so that said let's just
267:07 - assign the selected material so the
267:10 - counter select material let's make it
267:12 - just one percent bigger so let's select
267:15 - them all 1.01 okay and let's start with
267:18 - all of them disabled okay
267:20 - so the basic setup is done
267:22 - now let's make our script to run this so
267:24 - let's go down let's create a brand new
267:26 - c-sharp script for The Cutting counter
267:29 - let's select the apparent game object
267:31 - and attach a cutting counter and let's
267:33 - open
267:34 - now here as usual instead of all this
267:36 - let's start off by extending the base
267:39 - counter okay
267:41 - once again thanks to how we set things
267:42 - up using such clean code this is pretty
267:44 - much all we need to make a counter
267:46 - with this the counter already works as a
267:48 - counter then next thing we need is to
267:50 - customize any logic specific to this
267:52 - counter by just overriding the interact
267:54 - function so that's it now over here we
267:57 - can put whatever logic we want just for
267:58 - the cutting counter and for this one for
268:01 - star is actually going to be just like
268:02 - the empty counter meaning we're going to
268:04 - be able to drop objects on this
268:06 - so let's just go directly into the clear
268:08 - counter so here it is and let's just
268:10 - copy all of this code go into the
268:11 - cutting counter in Payson okay so the
268:13 - exact same logic so checks if there is a
268:15 - kitchen object or not checks if the
268:17 - employer's carrying something or not and
268:18 - picks up or drops in with this let's do
268:20 - a quick test just to make sure this one
268:21 - is working exactly like the clear
268:23 - counter
268:25 - so over here let's just make sure to
268:26 - drag in less references so on The
268:28 - Cutting counter let's make sure to drag
268:29 - the countertop point so drag that
268:31 - reference and then on the selected Drag
268:33 - The Cutting counter reference okay
268:35 - everything is good let's exit this
268:37 - prefab make sure to save all the changes
268:39 - and over here in the scene view let's
268:41 - Place one of our cutting counter so
268:42 - let's Basin right in there let's put it
268:45 - on X of 4.5 0 and 3.5
268:48 - okay so let's test
268:50 - all right so here we are now if I
268:51 - approach and I interact nope nothing
268:53 - happens okay great pick up some cheese
268:54 - and drop it on there any of there it is
268:56 - I can pick it up I can pick up some
268:58 - bread drop it and yep everything works
269:01 - okay so far so good
269:03 - now the next goal is to use the knife
269:05 - and actually slice the object that is on
269:07 - there and for that the first thing that
269:09 - we need is we're going to need a
269:10 - different input right now we only have
269:12 - the movement and the interaction so
269:14 - let's add another alt interaction
269:16 - for that let's go into our input action
269:19 - so let's open it up
269:21 - let's make another action so create a
269:24 - new action call it interact alternate
269:28 - and for The Binding let's put it on
269:30 - another key so let's listen and I think
269:31 - on F makes sense
269:33 - so let's go ahead select this one
269:35 - then as usual let's make sure to save
269:37 - the asset which in turn is going to
269:39 - generate C sharp plus and compound the
269:40 - code okay great
269:42 - now we can go here into our game input
269:43 - class and let's do the exact same thing
269:45 - with it for the interact action so first
269:47 - of all let's listen to it so let's go
269:49 - inside the player input actions inside
269:51 - the player action map so this one is the
269:53 - interact alternate and let's listen to
269:55 - the performed event
269:56 - okay and when we have that let's fire
269:58 - off an event pretty much the same thing
269:59 - so interact alternate action
270:05 - and down here let's just fire off this
270:07 - event so
270:08 - let's invoke using this and even RX dot
270:11 - empty
270:13 - okay so we have the input for the
270:15 - interact alternate
270:17 - now let's go on the player to listen the
270:19 - same way we're listening to the regular
270:20 - interact action
270:22 - so over here on the player script let's
270:25 - see how we're doing things so we go into
270:26 - game input and listen to that so it's
270:28 - the same thing game input and on
270:30 - interact alternate action let's listen
270:32 - to this one and when this one happens
270:34 - lets you pretty much exactly the same
270:36 - thing except we're just going to call a
270:37 - different function
270:39 - so instead of interacting let's call
270:41 - interact Alternate which in turn
270:43 - obviously means we need to Define this
270:44 - function
270:45 - so let's go into our base counter
270:48 - so here we are on the base counter we've
270:50 - got the interact and let's make another
270:52 - one exactly the same just different name
270:54 - interact alternate
270:57 - okay that's it and now we are only going
270:59 - to implement this in the ones that need
271:01 - implementation
271:03 - so for example on The Cutting counter
271:05 - over here let's write down so public
271:07 - override
271:08 - and let's override the interact
271:10 - alternate
271:12 - and now here let's check check if
271:14 - there's something placed on here so if
271:16 - there's a kitchen object placed on this
271:18 - counter
271:19 - if so then let's basically cut it
271:29 - and for cutting it the simplest way is
271:31 - really to destroy whatever object is on
271:33 - there and just spawn the slice object
271:35 - so let's handle destroying a kitchen
271:37 - object
271:39 - for handling that let's go over here on
271:40 - the kitchen object script
271:42 - and let's make a simple function for
271:44 - this object to destroy itself so let's
271:46 - go up here make it public return void
271:48 - and for name I like to use the name
271:49 - destroy itself to make it destroy this
271:52 - object
271:53 - and really all we need to do is just
271:55 - destroy and call destroy on this game
271:57 - object
271:58 - however before we do let's make sure to
272:00 - clear the parent so let's go into the
272:01 - kitchen object parent clear it and then
272:03 - destroy the game object okay that's
272:05 - great it's really this simple
272:07 - and then on the cutting counter let's
272:09 - get the kitchen object that is on here
272:11 - and tell it to destroy itself okay so
272:13 - let's raise the object
272:14 - and after we do let's just spawn the
272:16 - slices object so for now just keep
272:19 - things simple let's make a direct
272:20 - reference up here let's make a
272:22 - serialized film
272:24 - let's make it a type kitchen object so
272:26 - and for the cut kitchen object the cell
272:29 - okay so we have this then here in the
272:32 - editor and let's make sure to drag the
272:33 - reference so let's go inside the cutting
272:36 - counter and let's open up the prefab and
272:38 - inside let's assign this one that means
272:40 - we need to create the object so let's
272:41 - actually do that first
272:44 - so let's create a brand new kitchen
272:45 - object to sell let's come out for the
272:48 - tomato slices
272:50 - then if we do this we need to create the
272:51 - prefab so let's once again do the same
272:53 - thing tomato slices make the prefab
272:56 - let's go inside this prefab let's modify
272:58 - the visual so use the tomato slices
273:00 - visual okay and drag the reference for
273:03 - the other kitchen object for the tomato
273:05 - slices okay
273:06 - so the visual prefab is good and let's
273:09 - just go into the kitchen object let's
273:11 - just make sure to drag the prefab
273:13 - reference then let's assign the tomato
273:15 - slices icon and just come with tomato
273:18 - slices
273:20 - okay so we have the kitchen object so
273:22 - now we can go into the kitchen counting
273:24 - counter and over here let's open up and
273:27 - set this one to the tomato slices
273:29 - okay so we have all the references let's
273:31 - go back outside save it
273:33 - and back over here in our code so we
273:35 - have this now we just need to spawn this
273:37 - object
273:38 - so we're really just going to spawn it
273:39 - pretty much exactly like we did over
273:40 - here on the container so we just go into
273:43 - the description object spawn the prefab
273:44 - and set the appearance so let's do
273:46 - exactly that
273:47 - over here we destroy the object then we
273:50 - instantiate the cut kitchen object and
273:53 - instead of getting into the player let's
273:54 - put it on this
273:56 - okay so that's it we should be able to
273:58 - place a tomato directly on top of the
274:00 - cutting counter and it should be able to
274:02 - transform from a tomato into a tomato
274:04 - slices
274:05 - okay so here we are let me pick up a
274:07 - tomato go up there drop it and okay that
274:09 - works now if I press the onton track key
274:12 - press it and if there go it did work the
274:15 - Tomato was destroyed and the tomato
274:16 - slices were spawn and I can pick them up
274:18 - place them anywhere and yep everything
274:19 - works alright awesome so with this the
274:23 - basics are fully working let's just
274:25 - briefly clean up this code
274:27 - we already saw a little bit of code
274:29 - duplication so the cutting counter is
274:31 - going to spawn an object and the
274:32 - container counter is also spawning an
274:34 - object so we're copy pasting these two
274:36 - lines of code in multiple places so
274:38 - instead of doing that let's put it in
274:39 - just one place
274:41 - and actually a good place to put this is
274:43 - on the kitchen object list itself so it
274:45 - makes sense that this one is responsible
274:46 - for spawning more objects
274:48 - so let's put it over here however let us
274:51 - not make it a regular function instead
274:53 - let us make it a static function again
274:55 - just like we saw for The Singletons by
274:57 - making it static it means that the
274:59 - function is going to belong to the class
275:00 - itself as opposed to any instance so
275:03 - let's go all the way down to the bottom
275:05 - of the file personally I like to put
275:06 - settings at the end and over here let's
275:08 - make public make it static we're going
275:10 - to return a kitchen object and let's
275:13 - call it just spawn kitchen object
275:16 - and for our parameters let's receive the
275:19 - kitchen object that so
275:21 - and let's also receive the kitchen
275:22 - object parent
275:25 - okay so that's it and we're going to do
275:26 - the exact same thing so let's go into
275:28 - the cutting counter and copy the code
275:29 - that we're using and over here just
275:31 - paste it in there so we go inside here
275:34 - spawn the prefab and set it on this
275:35 - parent
275:36 - and finally let's return it
275:40 - so let's return the kitchen object over
275:42 - here let's pick it up so the kitchen
275:43 - object
275:45 - we get it and then we do kitchen object
275:49 - set the parent and finally we return the
275:51 - kitchen object
275:54 - all right so that's it here we have a
275:56 - super simple function that we can call
275:57 - very easily it won't automatically spawn
276:00 - an object and set to parents so now
276:02 - let's just call this from somewhere so
276:04 - over here on the cutting counter instead
276:05 - of doing all this let's just go into the
276:07 - kitchen object again remember let's go
276:09 - through the class name itself and not
276:11 - any instance and over here let's call
276:13 - the function pass in the cut kitchen
276:15 - object the cell and for the parent it's
276:17 - going to be this
276:18 - all right so that is now much much
276:20 - simpler and let's do the same thing over
276:22 - here on the container counter so if the
276:24 - player is not carrying anything
276:26 - let's give the player this object and
276:29 - give it to the player just like this
276:32 - as usual when we do some kind of
276:34 - refactoring let's do a quick test make
276:35 - sure everything still works exactly the
276:37 - same
276:38 - okay so here we are and if I go to the
276:39 - counter and pick it up yep it does work
276:41 - to spawn the object now I can drop it in
276:43 - there I can cut it and yep there you go
276:44 - everything does work all right so far so
276:46 - good
276:47 - so with all this basically we have
276:49 - created a brand new counter where we can
276:51 - cut objects however right now there's
276:53 - obviously one huge layering funnel if I
276:56 - now pick up a cabbage and I drop it on
276:58 - the cutting counter and I interact with
276:59 - it that cabbage has suddenly magically
277:01 - turned into tomato slices now that is
277:04 - obviously not intended so for that let's
277:06 - define a proper cutting recipe and let's
277:08 - do that in the next lecture
277:11 - hello and welcome I'm your code monkey
277:12 - in this lecture we're going to create
277:14 - another scriptable object type this one
277:16 - is going to be for handling our cutting
277:18 - recipes
277:19 - so here's our game I can pick up a
277:21 - tomato drop it on the cutting counter
277:23 - cut it there you go slice Tomatoes
277:25 - however if I could pick up a cabbage go
277:27 - there cut it and there you go cabbage
277:29 - turns into tomatoes so we have an
277:31 - obvious issue The Cutting object is
277:33 - currently hard-coded instead of being
277:34 - based on the object we put on top of it
277:37 - so to solve that let's make another
277:38 - scribble object type like I mentioned
277:40 - scribble objects are excellent for
277:42 - storing and organizing data so it's
277:44 - perfect for this use case basically we
277:46 - want a script mode object to hold a
277:48 - reference to the regular object and the
277:50 - cut object so we can then identify the
277:52 - input in order to spawn the output okay
277:55 - so let's build that let's create a brand
277:57 - new c-sharp script
277:58 - call it the cutting recipe so
278:01 - and let's open it
278:03 - okay so now here on let's do exactly
278:05 - that so something extremely simple so
278:06 - instead of modern behavior this one is a
278:08 - script mode object let's add the create
278:10 - asset menu and finally for the fields
278:13 - let's do just an input and output so
278:15 - we've got of type kitchen object so
278:17 - let's go for the input and another one
278:19 - for the output
278:21 - okay so that's really it super simple
278:23 - now here in the editor before we create
278:25 - and let's keep things organized so let's
278:26 - make another folder
278:28 - let's make it for the cutting recipe so
278:32 - and inside let's frequently create a new
278:34 - cutting recipe
278:35 - let's call it tomato two tomato slices
278:40 - and over here let's select the reference
278:42 - so the input is going to be our tomato
278:43 - and the output the tomato slices
278:46 - okay so this is how we're going to
278:48 - handle things
278:49 - so let's go ahead and make actually the
278:51 - final kitchen object that sews
278:53 - so let's make yet another one a kitchen
278:55 - object to sell
278:57 - let's make it for the Cabbage slices
279:00 - and then let's have another one for the
279:02 - cheese slices
279:04 - okay so now let's make these so as usual
279:06 - let's if we get tomato make the cheese
279:08 - slices and another one for the Cabbage
279:10 - slices
279:12 - let's go inside of it and first of all
279:14 - drag the kitchen object as so so this
279:16 - one is the Cabbage slices
279:18 - and let's go modify the visual so
279:21 - instead of this one the Cabbage slices
279:23 - okay
279:24 - so we have this let's save the prefab go
279:26 - outside then the other one we made the
279:29 - cheese slices so let's swap this out
279:31 - let's find the cheese slices
279:34 - and modify the kitchen object as well
279:37 - okay
279:39 - so finally just assign the references so
279:42 - on the cheese slices drag the cheese
279:44 - slices prefab let's assign the icon and
279:48 - call it cheese slices
279:51 - okay so finally on the Cabbage slices so
279:53 - these are the Cabbage slices
279:56 - let's pick up the icon and let's drag
279:59 - the prefab reference okay so far so good
280:02 - we have created our new icons
280:04 - and over here let's just make all of the
280:06 - other cutting recipes so we've got two
280:08 - more so one is going to be the cheese
280:10 - block onto cheese slices and the other
280:13 - one is going to be cabbage onto cabbage
280:15 - slices
280:17 - so we need is just to drag drop the
280:19 - scriptable objects so for this one
280:21 - cabbage let's drop the cabbage on the
280:23 - input cabbage slices on the output for
280:26 - cheese mug that's the cheese Wok on the
280:28 - input and the cheese slices on the
280:30 - output
280:31 - okay great all of our data is now stored
280:34 - in some really nice script mode objects
280:36 - so now let's go here into our cutting
280:38 - counter
280:39 - instead of having a hard-coded kitchen
280:41 - object let's receive a field of type
280:43 - cutting rest BSO except we're going to
280:46 - have multiple so let's actually make an
280:48 - array of this
280:49 - call it the cutting recipe so array
280:53 - now for the interaction this is picking
280:55 - up and dropping things so let's leave
280:56 - that the same for now and over here on
280:58 - the alternate
280:59 - basically we need to find out which
281:01 - recipe we should apply to this
281:03 - so how I didn't find that is pretty
281:05 - simple so we've got the kitchen object
281:06 - that is placed on this object and we've
281:08 - got a list of cutting recipes which in
281:10 - turn has the input so we just need to
281:12 - cycle through all the recipes in order
281:13 - to find the one where the input matches
281:15 - okay so let's go down here make a
281:17 - function to do just that let's make it
281:19 - private we're going to return a kitchen
281:20 - object as so let's come with get output
281:23 - for input so we give it a certain input
281:25 - and Returns the one that matches that
281:27 - one
281:28 - so it turns a kitchen object as so for
281:31 - the input kitchen object as well
281:34 - here on let's cycle so do a for each
281:36 - cutting recipe so in the cutting recipe
281:39 - so right so let's cycle through all
281:41 - these and just check if the cutting
281:43 - recipe so if this one dot input matches
281:46 - the input that we received
281:48 - if so then this is the one we want so
281:50 - let's return the cutting recipe
281:53 - so.output and to make sure that the
281:55 - function Works down here let's return no
281:59 - okay so that's it we give it an input
282:01 - and we get back the output
282:03 - so now here we just need to make sure to
282:05 - do it before we destroy the current
282:07 - kitchen object
282:09 - so let's store a kitchen object as so
282:11 - for the output kitchen object SL and we
282:14 - just get the output from the input and
282:16 - for the input pass in the get kitchen
282:18 - object so that's the one inside of this
282:20 - cutting counter and let's get the
282:22 - kitchen object this out so that gives us
282:24 - the output and then we just spawn that
282:26 - output
282:27 - okay so that's it let's test
282:30 - finally back in the scene let's just go
282:32 - inside the prefab and over here on
282:33 - cutting counter we need to make sure to
282:35 - add all the recipes
282:36 - so let's add so the cabbage
282:39 - then a second one for cheese Mock and
282:41 - finally for the Tomato okay so there are
282:44 - of our recipes let's go outside save the
282:46 - changes and let's test okay so over here
282:48 - let's pick up a tomato go up there slice
282:50 - it there you go got some tomato slices
282:52 - now pick up some cheese go here slice it
282:54 - and there you go got some cheese slices
282:55 - and finally the Cabbage go up there
282:58 - slice it and there you go some cabbage
282:59 - slices all right awesome
283:02 - so everything is working perfectly
283:04 - however now let's say that I want to
283:06 - pick up some bread and bread should not
283:08 - really be able to be cut so if I go
283:10 - ahead and I cut it and there you go
283:12 - there's our air we have no recipe that
283:15 - takes bread as an input So that
283:16 - obviously leads to a known reference
283:18 - exception
283:19 - now here we have two options for solving
283:22 - this problem
283:23 - one option is simply over here when we
283:25 - do the interact alternate
283:27 - we get the output for the input and if
283:29 - this one returns null then we just don't
283:31 - cut it
283:32 - so we don't destroy it and we don't
283:34 - spawn it or alternatively we can
283:36 - actually add some Foundation over here
283:37 - when dropping objects so we can make
283:39 - sure that we only drop valid cutable
283:41 - objects now both approaches are valid
283:43 - and actually we do need to implement
283:44 - both them we'll see why in a bit
283:46 - so let's do both starting off with the
283:48 - validating the drop
283:50 - so first we check if there is no kitchen
283:52 - object on this cutting counter then we
283:54 - check if the player is carrying
283:55 - something and then we drop it from the
283:57 - player on this
283:58 - so over here let's just check if there's
284:00 - any recipe that has whatever the player
284:02 - has as an input
284:04 - so let's go down here make a function to
284:06 - do that private let's return a bone and
284:08 - call it has recipe with input
284:12 - and we're going to receive a kitchen
284:14 - object episode for the input kitchen
284:17 - object lesson
284:19 - and over here lets you pretty much
284:20 - literally the same logic so we have this
284:22 - and if we find a match then let's return
284:24 - true so there is a recipe with that
284:26 - input if not return false so now up here
284:30 - when the player is carrying something
284:31 - let's check
284:33 - if has recipe with input and give it the
284:37 - player get the kitchen object the player
284:39 - is holding and get the kitchen object as
284:41 - so
284:42 - so if there's any recipe that takes
284:44 - whatever the player is carrying as an
284:45 - input
284:47 - if so then we drop it
284:55 - okay so like this let's test and see if
284:57 - we can drop the bread
284:59 - okay so let's pick up some bread go
285:01 - ahead drop it and nope does not work
285:03 - pick up some cheese and yep that one
285:04 - does work
285:06 - however now we actually also need the
285:08 - other validation that I mentioned the
285:10 - reason is because if we place a valid
285:11 - option like for example the cheese there
285:13 - so that works and I can cut it and yep
285:16 - that does work however Now the recipe
285:18 - the cheese moth became cheese slices and
285:21 - now cheese slice is no longer an input
285:22 - to any cutting recipe so now if I try
285:24 - cutting again
285:25 - I've got another no reference exception
285:28 - so we need to validate putting objects
285:30 - on top of it and also actually cutting
285:32 - them Technologic is also pretty simple
285:34 - so let's go down to the interact
285:36 - alternate so we just check if there's a
285:38 - kitchen object on The Cutting counter
285:40 - and has recipe input
285:43 - and let's get this kitchen object get
285:46 - kitchen object as so just like this
285:48 - so we're only going to cut if there is a
285:50 - kitchen object here and it can be cut
285:55 - okay so let's test
285:57 - so first of all the other one let's pick
285:59 - up bread and nope cannot travel okay
286:00 - great now pick up some cheese and I can
286:02 - drop now interact cut now cut again and
286:05 - yep there you go no more errors all
286:07 - right awesome okay so here we have
286:10 - everything working perfectly I can pick
286:12 - up a cabbage go up there cut it into
286:14 - slices I can slice some cheese and I can
286:16 - even slice some Tomatoes everything
286:18 - works perfectly now the one thing
286:20 - missing from our design is we don't
286:21 - actually want this action to be instant
286:23 - we don't want to just press a button
286:25 - everything slices instantly instead we
286:27 - want to have the player press the button
286:29 - a few times in order to actually cut so
286:31 - let's do all that in the next lecture
286:34 - hello and welcome I'm your code monkey
286:36 - in this lecture we're going to add the
286:38 - mechanic for the player to be able to
286:40 - cut multiple times in order to actually
286:41 - cut an object
286:43 - okay so we have our cutting counter I
286:45 - can drop a tomato and press button there
286:47 - you go it cuts it straight away now we
286:49 - want the exact same logic but we want it
286:50 - to take a few Cuts before the cut object
286:52 - is spawned
286:54 - so let's start off by going here onto
286:55 - the cutting counter and basically let's
286:57 - keep track of some kind of progress
287:00 - basically the way we do that is pretty
287:01 - arbitrary it's up to you to decide for
287:03 - example you could use a normalized float
287:05 - however for cutting since this is going
287:08 - to be a discrete action let's actually
287:09 - count the numbers with an end so let's
287:11 - store a private end just call it cutting
287:13 - progress
287:15 - okay so now let's begin by actually
287:17 - initializing this progress so when the
287:19 - player drops something on there let's
287:21 - set this one to zero
287:23 - and then down here when we have the
287:25 - interact alternate we do our logic and
287:27 - when we do let's just increase this by
287:29 - one
287:30 - and now we need to know if the object
287:32 - has been cut so we need somewhere to
287:34 - Define some kind of maximum
287:36 - and for that we can actually do it
287:38 - directly on the recipe so so inside the
287:41 - cutting rest PSO over here we've got the
287:43 - input we've got the output and let's
287:45 - also Define an end
287:46 - for The Cutting progress Max
287:50 - okay that's it
287:51 - and back here in the editor let's go
287:54 - into the Tomato to tomato slices let's
287:55 - say this one takes just three Cuts then
287:58 - for the cheese let's also take three
287:59 - cuts and for the Cabbage let's say it's
288:01 - a bit thicker so let's say it takes five
288:03 - cuts
288:04 - okay so back in the cutting counter here
288:07 - down here we are adding to our cutting
288:09 - progress
288:10 - so then we just need the recipe so in
288:12 - order to grab the maximum so on
288:14 - sectionally go down here and actually
288:15 - make a different function so this one
288:17 - just returns a Boolean this one a
288:19 - kitchen object or so let's make another
288:21 - one this one is going to return a
288:23 - cutting recipe so
288:25 - so get the cutting recipe so with input
288:31 - and we're going to receive as usual the
288:33 - kitchen objects so for the input
288:37 - I'm really going to do the exact same
288:39 - thing that we did up here next time
288:41 - instead of returning the output let's
288:42 - return the recipe itself
288:44 - okay so now that we have this more
288:46 - logical one we can actually get rid of
288:48 - all this copy paste code
288:50 - so over here we just get the cutting
288:52 - recipe so
288:55 - and we just get it and pass in the input
288:59 - so we have this one over here if this
289:02 - one is not no then we're going to return
289:04 - this on the output
289:06 - and if not we're just going to return
289:07 - null
289:09 - okay so we're doing the exact same logic
289:11 - just a bit similar okay and up here
289:13 - pretty much the same thing
289:15 - so has recipe with input let's get the
289:18 - cutting recipe a cell
289:20 - and basically just return if this one is
289:22 - not known
289:24 - okay so we have our three nice sample
289:26 - functions so let's just use this one to
289:28 - get the cutting rest BSO so let's
289:30 - actually copy this and go up here so we
289:33 - do the cutting progress then let's pick
289:35 - it up the one for this input so the
289:37 - input is going to be this one the object
289:39 - currently on the cutting counter and
289:41 - over here we already know that there's
289:42 - going to be a recipe with this input
289:44 - since we've gone through this if
289:46 - so then we can just check if the cutting
289:48 - progress is bigger or equal to The
289:51 - Cutting recipe so and let's grab the
289:54 - maximum
289:57 - if so then yep we do spawn it
290:00 - okay so that's it some very simple logic
290:02 - Let's test
290:03 - so here we are let's pick up a tomato go
290:05 - up there and okay now I'm going to press
290:07 - enter direct okay press once and yep
290:10 - okay so far so good nothing now two
290:12 - times and Alpha press a third time boom
290:15 - any up there you go got the nice slices
290:16 - now for cheese same thing one two three
290:19 - yep it works and finally for the
290:21 - Cambridge this one should be five so one
290:23 - two three four and five any up there you
290:26 - go everything does work perfectly all
290:29 - right awesome
290:30 - so with this we now have progress in our
290:32 - cutting logic although of course just
290:34 - like this it's not very good for the
290:35 - player the player has no way of knowing
290:37 - what exactly is going on so we need some
290:39 - kind of visual feedback so for that
290:41 - let's add a really nice visual progress
290:43 - bar and for doing this we're also going
290:45 - to learn about a really awesome Unity
290:46 - feature these are World canvases
290:49 - so before we make the world canvas on
290:51 - The Cutting counter let's actually set
290:52 - something up over here on the scene
290:54 - itself
290:55 - let's first create a regular canvas
290:57 - we're only going to use this in a couple
290:58 - of lectures but let's first do that one
291:00 - just for now
291:02 - so let's go on the plus button go into
291:04 - UI and let's create a brand new canvas
291:07 - okay so there you go that creates a
291:09 - canvas and an event system
291:11 - like I said we're only going to worry
291:12 - about this in a little bit but for now
291:14 - let's just leave those as is
291:16 - and also since we're here creating some
291:17 - objects let's also take some time to
291:19 - organize our hurricane
291:21 - Unity suddenly doesn't really have any
291:23 - folder objects so you can't organize the
291:25 - hierarchy in any folders however you can
291:28 - use empty game objects essentially as
291:29 - folders
291:31 - so let's make a brand new empty game
291:32 - object let's call it counters
291:35 - and now very importantly for empty
291:37 - folder objects make sure you put them on
291:38 - zero zero zero so nothing breaks
291:41 - so make sure you put it on there before
291:43 - you drag the counters
291:44 - and now let's just drag on the counters
291:46 - inside so all the clear counters put
291:48 - them outside this one also drag it
291:50 - inside and all of these counters put
291:52 - them all inside so there you go now
291:54 - hierarchy is quite a bit more clean
291:56 - okay so now let's make the cutting
291:58 - progress so let's click on the cutting
292:00 - counter
292:01 - and let's go inside our prefab so let's
292:03 - go inside of it
292:05 - now over here let's right click on the
292:07 - hierarchy and we're going to create a UI
292:09 - let's create another canvas
292:11 - now for this one let's give it a name
292:12 - let's name it the progress bar UI and
292:15 - for this one over here on the inspector
292:16 - for the settings instead of being screen
292:18 - space overlay let's make this one a
292:20 - world space canvas
292:22 - basically screen space means that it
292:24 - would occupy the entire screen whereas
292:25 - World space means that this exists in
292:27 - the world in whatever position it is
292:29 - so let's make it World space and over
292:31 - here the fields actually unlock so let's
292:34 - put the positions on zero and for the
292:36 - width and height let's also put it on
292:38 - zero
292:39 - so basically the canvas is going to be
292:41 - exactly over here by the way the
292:43 - shortcut that I just used was the F in
292:45 - order to focus on the object
292:47 - so this useful if you're zoomed out or
292:49 - zoomed in way too much okay
292:51 - so we have this and we want the bar to
292:53 - be a little bit above so let's actually
292:54 - lift it up on the Y by a little bit so
292:56 - over here let's put it on y of 2.5 okay
293:00 - now I said the going with this is to
293:01 - make a progress bar so inside the
293:03 - progress bar UI let's create a new UI
293:05 - image let's name this one our bar
293:09 - let's put it with a width of one and a
293:12 - height maybe of 0.2
293:14 - so there you go just a really thin bar
293:16 - and for the color you can play round
293:18 - tinted with any color you want now for
293:20 - progress I think maybe a blue or a
293:22 - yellow something like that makes sense
293:23 - so let's go with the yellow kind of like
293:26 - this
293:27 - okay so there's our really nice progress
293:29 - bar
293:30 - and for this let's actually use one
293:32 - really nice trick for making a super
293:33 - easy progress bar the image component
293:36 - has a really easy way of making a slider
293:38 - image however it only actually works if
293:41 - you assign an image over here
293:42 - so let's assign one in order to be able
293:44 - to see those options
293:45 - and for that in the project files
293:48 - there's a texture white one by one this
293:50 - is literally just a one by one white
293:52 - pixel
293:53 - so here it is just a one by one image if
293:55 - only white
293:56 - and as soon as we assign it we do see
293:58 - over here the image type so we see a
294:00 - bunch more options and the one that we
294:02 - want is to set the Sprite as filled this
294:04 - one lets you do some really cool really
294:06 - easy effects for example you can make it
294:08 - radial and look at what happens in there
294:10 - as I modify over here on the film Mount
294:12 - so as I go down look at that it's
294:14 - radiantly filling so for some kind of
294:16 - circular progress bar this would be
294:17 - excellent but in our case what we really
294:20 - want is just a horizontal bar so we're
294:22 - here for the film method instead of
294:24 - Radion let's go with horizontal
294:25 - and if there you go now by playing
294:27 - around this we have a really nice
294:28 - progress bar
294:30 - then if you want you can modify on left
294:31 - to right right and left but yep like
294:33 - this it looks great
294:34 - now in order to modify this visual
294:36 - really only we're going to need is
294:37 - modify over here the film Mount this one
294:39 - is a normalized value so between 0 and 1
294:41 - so 0 is commonly empty one is commonly
294:43 - full however one issue with this is when
294:46 - the bar is empty then we can pretty much
294:48 - not see so we can see the actual size of
294:50 - the bar we can see what size it should
294:52 - be
294:53 - so with this it's pretty difficult to
294:54 - see how far along we are but something
294:57 - that is pretty simple we can really just
294:58 - add some kind of background
295:00 - so let's duplicate the bar let's name
295:02 - this one the background
295:04 - for this one for the image type we don't
295:06 - want anything so let's leave it on
295:07 - SIMPLE and for the color let's put it on
295:09 - kind of a dark gray okay great and now
295:12 - here's one very very important thing is
295:15 - over here on the hierarchy let's click
295:16 - and drag and place it above the bar
295:19 - the reason why that is super important
295:20 - is because the Sorting order and how it
295:22 - works in unity basically when it comes
295:24 - to UI elements inside a canvas the
295:27 - Sorting order is based on The Horde in
295:29 - the hierarchy basically it renders from
295:31 - top to bottom
295:32 - so the bar on top the background this is
295:34 - going to render first and then the one
295:36 - below it the bar is going to render
295:37 - afterwards which means it's going to
295:39 - render on top
295:40 - so for the background we want to be
295:42 - behind so place it above on the
295:43 - hierarchy and that way it renders the
295:45 - background and then renders the bar also
295:47 - by the way for 2D Sprites Unity has
295:49 - another different sorting method it's
295:51 - all based on sorting layers and sorting
295:53 - orders
295:54 - I have video on that topic if you're
295:56 - interested in 2D games
295:57 - okay so with this we have the background
295:59 - and then we have our film bar this way
296:01 - we can see if the progress is being
296:02 - filmed or not
296:04 - also one more tiny thing that I like to
296:05 - add is Unity has some really nice really
296:08 - easy to add effects
296:09 - so you can go into that component and
296:11 - let's search for a shadow
296:13 - this one does exactly what you expected
296:15 - as a nice drop shadow over here on the
296:17 - effect distance let's put it on 0.1.1 in
296:19 - order to see
296:21 - next one let's not do it on this one
296:23 - we'll do it on the background so let's
296:24 - get rid of this instead of going to the
296:26 - background over here let's add the same
296:27 - shadow
296:28 - so if you put it on point one and minus
296:30 - point one you better go a nice simple
296:32 - and drop shadow or the other one that I
296:34 - prefer so instead of the Shadow let's
296:36 - add a really nice outline once again for
296:39 - the effect distance 0.1.1 or maybe
296:41 - actually 0.05 just to be just a tiny bit
296:44 - and let's raise it on the alpha so there
296:46 - you go nice little outline tour bar this
296:49 - is just a visual thing so you don't have
296:51 - to add this but personally I find that
296:52 - it looks pretty good
296:54 - so with all of this we have our Visual
296:55 - and perfectly set up we've got our nice
296:57 - bar all we need to do is play around the
296:59 - filament in order to fill it
297:01 - so now all we need to do is to connect
297:03 - this to the logic but as usual let's
297:04 - make sure to write some good clean code
297:06 - so we do not want the cutting counter to
297:08 - directly touch on this image
297:10 - instead let's make a script to handle on
297:12 - that so let's right click create a new
297:14 - c-sharp script call it the progress bar
297:16 - UI
297:18 - and just personally as a rule I like to
297:20 - open the UI to any UI script
297:23 - you don't have to do that it's just a
297:25 - rule that I personally find helpful to
297:27 - follow that way just by looking at these
297:29 - scripts I can immediately see this one
297:30 - is a UI this one is script and logic and
297:32 - so on
297:33 - so on the progress bar UI on the main
297:35 - game object let's attach the script and
297:38 - let's open it
297:39 - okay so now here we're going to need a
297:41 - reference to our image
297:44 - so let's add a serialized field private
297:47 - and we're going to need the image type
297:49 - and importantly this is inside using
297:51 - Unity engine.ui so let's go up here
297:52 - using Unity engine dot UI so we have our
297:56 - image component okay great let's call it
297:59 - the bar image
298:01 - so we have a reference and now with this
298:04 - obviously we need to have some kind of
298:05 - reference to the counter so we know when
298:07 - the progress changes so it's really the
298:09 - same thing that we've already done so
298:10 - many times throughout this course so
298:12 - let's set a film up here serialize film
298:14 - private cutting counter for our cutting
298:18 - counter
298:19 - then over here in the editor let's write
298:21 - new references so drag the reference to
298:23 - The Cutting counter and another one to
298:24 - the bar image okay great
298:26 - now we just need some kind of event to
298:28 - update the bar image
298:30 - so let's go over here into our cutting
298:32 - count script let's make an event to
298:34 - spawn that so public event let's use the
298:37 - event handler the default standard
298:39 - let's go with on progress change
298:43 - and let's also make a nice event artist
298:45 - to be able to send the current progress
298:47 - amount
298:48 - so let's make a public class on progress
298:51 - changed event arcs and let's extend
298:53 - event arcs
298:55 - and then inside and let's put the
298:57 - current progress
298:58 - however let's also pass in the progress
299:00 - as normalized since that's the what the
299:02 - bar will use
299:04 - so public Cloud progress normalized
299:08 - and we're going to make this event of
299:10 - this type
299:11 - okay great so we have our event
299:13 - now whenever we modify the progress we
299:16 - just need to fire this event so over
299:17 - here when resetting the progress let's
299:19 - fire it so let's invoke pass in this
299:21 - instantiate our event args and pass in
299:24 - the progress normalized and to get the
299:27 - normalized progress sectionally very
299:28 - simple basically we just need to divide
299:30 - the current progress by the maximum so
299:32 - cutting progress divided by cutting
299:34 - progress Max which is actually inside
299:36 - the rest BSO so we need to pick that one
299:38 - up
299:39 - so let's go down there to pick up the
299:42 - cutting progress recipe
299:44 - so we picked this one up and we go in
299:47 - there and get the maximum
299:49 - however over here we also need to be
299:51 - very careful because there is one sneaky
299:52 - issue here this has to do with how
299:55 - c-sharp works and how instar divided
299:57 - with other ends
299:58 - for example if we had a cutting progress
300:00 - of one and cutting progress Max of five
300:02 - you would think one divided by 5 would
300:04 - equal 0.2 however if we actually did
300:07 - that over here we would actually get a
300:09 - zero and the reason for that is because
300:11 - we are dividing two ends cutting
300:13 - progress is an end cutting progress Max
300:14 - is also an INT and if you divide an end
300:17 - by an end then the end result will also
300:19 - be an end
300:20 - since you cannot Define 0.2 in an end
300:22 - the decimal gets cut down and you end up
300:24 - with just zero so that would not be
300:27 - correct in order to get the right value
300:29 - from this calculation we need to make
300:30 - sure to convert one of these values onto
300:32 - a float so that's really simple we just
300:34 - cast one of them so just cast this one
300:36 - to the float just like that
300:38 - basically now this one will first be
300:40 - cast to a float and then we're going to
300:42 - have a float divided by an end and the
300:43 - end result won't be afloat so if you
300:46 - ever do some math and you get some weird
300:47 - results always make sure to check the
300:49 - type of your numbers
300:50 - okay so here we are correctly firing the
300:53 - event and then down here when adding our
300:55 - progress let's do the same thing let's
300:57 - also fire on the event
301:00 - so now we can go back into our progress
301:02 - bar UI
301:03 - and over here let's listen to the event
301:05 - and again remember that if we're
301:07 - accessing an external reference let's do
301:09 - that around start and not an awake
301:12 - so cutting counter listen to the on
301:14 - progress changed event
301:16 - when that happens let's just go bar
301:18 - image and set the fill amount to what we
301:20 - received from the event so the progress
301:22 - normalized
301:23 - okay so that's really it and also appear
301:25 - on start let's initialize it as 0f so
301:28 - the bar is nice and empty
301:30 - okay so let's test
301:32 - back in the editor let's just go back
301:34 - into the scenes make sure the prefab has
301:35 - been saved and let's head on play
301:37 - and right away yep we do see the bar yep
301:39 - it is empty now pick up some cheese drop
301:41 - it and if I cut and if there go add a
301:44 - little bit of progress now a bit more
301:45 - and there you go there's our cheese
301:48 - okay great everything does work now
301:51 - let's add just one more tiny bonus thing
301:53 - we can add some extra logic in order to
301:55 - hide this visual if the bar is either
301:56 - completely empty or completely full that
301:58 - is actually pretty simple
302:00 - over here on the progress bar UI script
302:03 - let's just make some basic show and
302:04 - height functions
302:05 - so private void show and then we're
302:08 - going to have
302:11 - a private void Hind
302:14 - on these one just game objects that
302:16 - active this one set it to true and this
302:19 - one set it to false
302:20 - now on start we subscribe to the event
302:22 - and then let's hide it okay
302:26 - also here it's very important make sure
302:27 - you hide it after you listen to the
302:29 - event if for example You Can't Hide on
302:31 - awake that would disable the game object
302:33 - and the start would never run so it
302:34 - would never listen to the event
302:36 - so if you have reset the game object as
302:38 - inactive make sure you do it only after
302:41 - you're listening to whatever events you
302:42 - want so we have this that's great and
302:45 - then when the progress changes
302:47 - let's just do a basic test so if e dot
302:49 - progress normalized equals zero f or if
302:53 - the progress normalized equals one F so
302:55 - if the bar is similarly empty or
302:56 - completely full
302:57 - if so then let's hide it and if not then
303:01 - let's show it
303:04 - okay that's it let's test
303:06 - okay and yep by default starts off
303:08 - hidden let's pick up the Tomato go up
303:10 - there and yep still hidden now I cut and
303:12 - there you go there it is cut again and
303:14 - yep there you go it hides itself okay
303:16 - great so we've got a nice little visual
303:18 - let's do just one more final thing let's
303:20 - add a really nice animation
303:23 - if we go inside the cutting counter and
303:25 - we'll look at the cutting counter visual
303:27 - over here note how it already has an
303:28 - animator
303:29 - just like we did for the container
303:31 - counter it's all very simple
303:33 - so basically just has a cut parameter
303:35 - when that happens it just cuts the
303:37 - counter so just plays a simple animation
303:39 - since it's going to be pretty much
303:41 - exactly like the container counter and
303:42 - let's actually duplicate that script so
303:45 - let's go down find that script so the
303:47 - container comes to visual let's
303:48 - duplicate this so Ctrl d
303:50 - let's rename this to The Cutting counter
303:53 - visual
303:54 - okay let's open
303:56 - and over here let's rename the script so
303:57 - the cutting countervision okay great
304:00 - then for the parameter let's rename this
304:02 - instead of open close is going to be
304:03 - called cut
304:05 - and for the string it's cut again make
304:08 - sure you write it case sensitive make
304:09 - sure it's all correct
304:11 - then instead of having a container come
304:12 - through we've got a cutting counter and
304:14 - a cutting counter
304:17 - and finally we just need to listen to
304:18 - the correct event so technically we
304:21 - couldn't listen to the unprogressed
304:22 - changed however that one also gets fired
304:24 - over here when the cutting progress is
304:25 - zero we don't want the current mission
304:27 - to play when this happens so let's just
304:29 - make another simple event so a public
304:31 - event event handler
304:34 - let's call this just on cut
304:36 - okay and then down here when we have our
304:39 - cutting progress so we cut and let's
304:41 - just invoke this event
304:44 - okay that's it super simple
304:47 - so now on The Cutting counter visual
304:48 - let's go into the cutting counter and
304:50 - into the uncut event let's listen to
304:52 - this and we're going to set the trigger
304:54 - example like this so get rid of the
304:57 - container counter like this
305:00 - okay there you go a very simple script
305:02 - so now here back in the scene view
305:04 - inside the container counter prefab
305:07 - let's just go inside the visual let's
305:09 - attach The Cutting counter visual just
305:10 - need to drag The Cutting counter
305:12 - reference and that's it let's exit the
305:14 - prefab save it and let's play okay so
305:16 - now let's pick up a cabbage go up there
305:18 - drop it and aren't interact and if there
305:21 - you go we've got a nice little animation
305:23 - all right awesome so I can drop things I
305:26 - can cut them and everything works
305:27 - perfectly
305:28 - all right
305:30 - so here we added a cutting progress to
305:32 - our cutting counter and we also learned
305:35 - about yet another very useful ENT
305:36 - feature called World canvases
305:39 - and at the same time you might have also
305:40 - noticed that the canvas is looking at
305:42 - the camera in kind of a weird way
305:43 - basically just pointing straight forward
305:45 - this can sometimes make it difficult to
305:48 - see so let's work on that in the next
305:50 - lecture
305:51 - hello and welcome I'm your code monkey
305:53 - in this lecture we're going to build a
305:55 - very simple but very useful script to
305:57 - make an object look straight at the
305:59 - camera with various options
306:01 - okay so we previously made the cutting
306:03 - counter and when I placed something yep
306:05 - there's a nice progress bar
306:07 - so now that this is working let's do one
306:09 - more thing right now look at how the bar
306:11 - is oriented it's looking quite a bit
306:13 - slanted that's because we have a
306:15 - perspective camera and it's looking from
306:16 - top down
306:17 - now this is one of those things that is
306:19 - kind of personal preference so maybe you
306:20 - don't like it just like this
306:22 - but a lot of the times you want these
306:24 - World UI elements to face the camera
306:26 - just like a regular UI
306:28 - one example of this problem is for
306:29 - example let me pick up the cutting
306:31 - counter duplicated and let's put one
306:33 - down here so rotate it upwards
306:37 - okay let's put it on 4.50 and minus 5.
306:41 - now if I place something on there and I
306:43 - cut it yep like that the bar is Now
306:45 - inverted so let's make a simple script
306:47 - to solve this problem
306:49 - let's go into our scripts create a new
306:51 - c-sharp script call it look at camera
306:55 - let's go on to The Cutting counter
306:57 - prefab let's open it up go inside on the
306:59 - progress bar let's attach the script so
307:01 - the unlocked camera okay now let's open
307:03 - so from here let's use an interesting
307:06 - function so let's use a private void
307:08 - late update so not update we have the
307:11 - late update so if this is the first time
307:14 - you're hearing about this like the name
307:15 - flies this one is going to run after the
307:17 - regular update so every single update
307:20 - and all the objects is going to run and
307:22 - then on the late updates so kind of like
307:24 - you've got awake and start you have
307:25 - update and late update why this is
307:27 - useful specifically for this script is
307:30 - because for this element you really want
307:32 - us to run the orienting logic you want
307:34 - that to be done after whatever that
307:35 - object does in the update in this case
307:38 - this object will never move so it's not
307:39 - really an issue
307:40 - but for example if you had some kind of
307:42 - moving vehicle with a warm cameras on
307:44 - top if you have that you would want to
307:46 - set the Warren canvas and location to
307:47 - unlock the camera after the vehicle had
307:49 - moved otherwise the canvas would not
307:52 - look perfect so anyways because that
307:54 - here we're doing on late update and now
307:56 - we can just look straight the camera so
307:58 - we can just do transform dot lookup
308:03 - and for the Target passing the camera
308:05 - Dot main.transform
308:07 - this function makes this transform look
308:09 - at another transform or another point so
308:11 - this will make it look straight at the
308:12 - camera
308:13 - also by the way one quick note here in
308:15 - some other tutorials you might see
308:17 - people telling you not to use
308:18 - camera.main the reason for that is
308:21 - because this field did not used to be
308:22 - cached so every time you use this it
308:25 - would cycle through every single game
308:26 - object in the scene until it found the
308:28 - main camera so that was obviously really
308:30 - bad for performance but nowadays this
308:32 - field is now cached by default on the
308:33 - ENT backend so you no longer need to
308:35 - Cache it yourself accessing it directly
308:37 - just like this is now fine
308:39 - okay so with this let's test
308:41 - just make sure to save the prefab and
308:44 - let's hit on play
308:45 - let's go ahead pick up a cabbage put it
308:47 - up there and if they're young look at
308:49 - that how it's looking straight at the
308:50 - camera and for this one down here same
308:52 - thing cut it any up there you go both of
308:54 - them are looking straight at the camera
308:56 - okay so that's great
308:58 - you can also see exactly what it's doing
309:00 - if we try to move the camera again we're
309:02 - using cinemachine so let's move the
309:04 - virtual camera
309:05 - so over here if I just play around with
309:07 - the position.x look at that look how as
309:09 - I move the camera yep the objects are
309:11 - perfectly looking straight at the camera
309:13 - so that's great that's what we want but
309:16 - also you might notice one thing notice
309:18 - under the bars are actually inverted
309:20 - instead of going left to right they're
309:22 - actually going right and left basically
309:23 - this has to do with how the canvas by
309:25 - default assumes you are essentially
309:26 - going to look at it from behind instead
309:28 - of looking forward so that is why when
309:30 - this game object is pointing straight at
309:32 - the camera it's essentially inverted
309:34 - so to sum this is actually quite simple
309:36 - we basically just need to look in the
309:37 - exact opposite direction
309:39 - but at the same time sometimes we might
309:41 - want this exact Behavior having
309:43 - something looks right at the camera
309:44 - maybe we do want it to be inverted
309:46 - sometimes so for that let's make a nice
309:48 - complete script with all of our possible
309:50 - options and for the finding options it's
309:52 - also an excellent way to learn about one
309:54 - more thing which are c-sharp enums enums
309:57 - are an enumeration meaning a fixed set
309:59 - of options that you can have of
310:01 - something
310:01 - so these are really useful when you have
310:03 - a fixed set of something like for
310:05 - example maybe a fixed number of options
310:07 - so for example up here let's make it
310:10 - private make it an enum and let's call
310:12 - it mode and then inside we can Define
310:14 - all of our options so let's say we have
310:17 - the regular look at it and then look at
310:19 - inverted
310:20 - okay so we have these two options in our
310:22 - enum now let's do a field of this type
310:25 - and expose it in the editor
310:26 - so let's make a serialized film private
310:29 - of type mode and call it mode
310:31 - okay let's save this and look what this
310:34 - looks like in the editor and if we go
310:36 - inside the cutting counter and we'll
310:38 - look at the progress bar
310:39 - even look at that the mode shows up and
310:41 - it shows up as a really nice drop down
310:43 - menu so since we have a limited number
310:45 - of options we've got a really nice menu
310:47 - where we can choose each round if you
310:49 - want
310:50 - so that's really awesome that's one of
310:51 - the benefits of enums they are really
310:53 - easy to use over here in the editor
310:55 - now back in the code here and let's
310:57 - decide which one to use
310:59 - so on The Late update let me just do a
311:01 - switch on our mode in case we are on the
311:04 - regular look at mode then let's see
311:06 - exactly this let's simply look in in
311:08 - case we are on the look at invertent
311:11 - for this we just want to look at the
311:12 - inverse position so that's actually
311:14 - pretty easy we just calculate the
311:16 - direction Vector from the camera to this
311:18 - object
311:19 - so a vector 3 call it deer from camera
311:23 - and to get direction from the camera we
311:25 - start from this object so this
311:26 - transformed that position subtract the
311:28 - camera dot main transform position
311:31 - so this gives us the direction pointing
311:33 - from the camera and then just to
311:35 - transform down look at
311:38 - and instead of looking at the camera
311:39 - let's look at the opposite position so
311:41 - let's look at transform that position so
311:42 - our current position points the
311:44 - direction from the camera so we're going
311:46 - to be looking at the exact opposite
311:47 - point
311:48 - okay so that's it let's test
311:50 - and right now by default we have the
311:52 - regular look at so let's just see it
311:55 - let's just play some objects okay so
311:57 - right now it's still inverting
311:59 - and something real nice is you can play
312:01 - around the enums even as the game is
312:03 - running so let's go inside the cutting
312:04 - counter on the progress bar UI for this
312:06 - one let's swap from Lookout to unlock
312:08 - inverten anything like that that one is
312:10 - now looking perfectly
312:11 - so this one is using Lookout and this
312:13 - one using look at inverted
312:15 - okay great it's all working
312:17 - however yet another thing that is all
312:19 - about personal preference
312:21 - note how the visual has a slight slant
312:23 - this is due to how the visual section
312:25 - looking directly at the center of the
312:27 - camera
312:28 - so you can really see it if I move the
312:30 - camera left and right how it Slants
312:32 - going left or going right
312:34 - again the Zone personal preference it's
312:36 - just a visual so maybe you do want this
312:38 - look but let's see another method so
312:40 - over here in our modes let's add two
312:42 - more let's add camera forward and Camera
312:44 - forward inverted
312:47 - and then down here on our late update
312:49 - let's add those so the camera forward
312:51 - and then we have the camera forward
312:53 - inversion
312:54 - so for this one for the camera forward
312:56 - super simple let's just take this
312:57 - transform use the forward which again
312:59 - you can get or you can set it and let's
313:01 - set it to the exact same one as the
313:03 - camera Dot main.transform.4
313:06 - and for the inverting example the same
313:08 - thing X7 set of four do we do minus four
313:11 - okay so let's see what this looks like
313:14 - okay so here's the game with both
313:15 - counters they're both currently using
313:17 - the unlockit mode now if we put a look
313:19 - at inverting yep that one goes left to
313:21 - right okay great now if I put camera 4
313:23 - in give a look at that now that one is
313:25 - perfectly straight
313:26 - so even as I move the virtual camera on
313:28 - left and right look how that one is
313:30 - always perfectly facing the camera as if
313:32 - it was a regular UI owned
313:34 - and for the inverter does the exact same
313:36 - thing but invert and so just like that
313:38 - so that's it these are the four modes
313:40 - again these are all just visual elements
313:42 - so pick whatever you prefer for me I'm
313:44 - going to be using this one the camera.4
313:46 - so that everything is perfectly
313:47 - horizontal so I'm just going to make
313:49 - sure to go inside the prefab and on the
313:52 - prefab itself modified and set it as
313:53 - camera.4
313:55 - and now if I add the cheese there yep
313:57 - looks great and if I had a cabbage here
313:59 - and yep it also looks right
314:01 - all right so here we created a really
314:03 - nice useful generic script to make an
314:05 - object look straight at the camera in
314:07 - various ways note how this one has
314:09 - nothing to do with canvas or a progress
314:11 - bar or anything it's really a generic
314:13 - script to look at the camera so you can
314:15 - apply this to anything where you want it
314:17 - to look at the camera
314:18 - okay so with that the cutting counter is
314:20 - fully done
314:21 - now let's handle the trash counter in
314:23 - the next lecture
314:25 - hello and welcome I'm your code monkey
314:27 - in this lecture let's create the trash
314:29 - counter this one is actually pretty
314:31 - simple it's how we're going to drop
314:33 - something and just destroy it okay so
314:35 - making the trash counter is going to be
314:37 - super super easy once again going to be
314:39 - another great practical example of the
314:41 - power of writing good clean code and
314:43 - having good organization in your project
314:44 - so let's do the same thing that we've
314:46 - already done a bunch of times so first
314:48 - of all let's make the prefab variant so
314:51 - let's right click on the base counter
314:52 - and create a brand new prefab variant
314:54 - come with the trash counter
314:58 - okay let's go inside and first of all
315:00 - let's drag the visual so find the visual
315:03 - prefab on the trash counter okay then
315:05 - let's duplicate it to make the selecting
315:07 - so let's rename this to selected
315:10 - let's add the selected counter visual
315:13 - let's add the visual inside of it and on
315:17 - the visual let's select the other
315:20 - material so the counter selected and
315:23 - finally on the selected put it one
315:25 - percent bigger 1.01
315:28 - and start off with visual disabled okay
315:31 - so that's the basics just like we've
315:33 - already done so many times now let's
315:35 - make this script to run this so let's
315:37 - frequently create a new c-sharp script
315:39 - call it the trash counter
315:42 - and by the way here we're already
315:43 - starting to have quite a bunch of
315:44 - scripts so we should probably organize
315:46 - the scripts folder so let's make a new
315:49 - folder let's come with counters
315:52 - and let's make another one and call it
315:55 - scriptable objects
315:57 - so on the counters let's drag the base
315:59 - counter clear counter the container the
316:01 - container visual The Cutting The Cutting
316:03 - visual then down here the trash counter
316:06 - okay let's drag them all onto the
316:08 - counters folder and on these critical
316:10 - objects let's put the cutting recipe and
316:12 - the kitchen object as so okay now our
316:14 - phone there is a bit more organized so
316:16 - let's open up the trash counter
316:18 - and over here as usual let's begin by
316:20 - extending the base counter okay great
316:24 - then let's implement the regular
316:25 - interaction so override the interact
316:29 - and on this one again it's going to be
316:31 - super simple we just check if the player
316:33 - is holding something and if so we
316:34 - destroy it so just check if player that
316:37 - has kitchen object so if the player is
316:39 - holding something go into the player get
316:41 - the kitchen object the player is holding
316:43 - and simply call destroy itself
316:46 - and that's it it's this simple back in
316:49 - the editorial let's just attach a script
316:51 - let's make sure to drag the countertop
316:53 - Point reference and on the selected drag
316:55 - the base counter reference
316:57 - okay with this it should be working so
316:59 - let's exit the scene let's save the
317:01 - prefab and let's drag it over here onto
317:03 - our scene so let's drag the trash
317:05 - counter and put it maybe somewhere over
317:07 - here on the corner
317:08 - so let's put it here on an X of 7 y 0
317:11 - and -3.5
317:14 - then let's also fill out these spots
317:16 - down here so let's duplicate the clear
317:18 - counter put one in there put another one
317:21 - in there
317:22 - let's put another one on the side and
317:24 - for the crash counter and let's align it
317:26 - so let's put it a bit more to the side
317:28 - so on 7.5 okay great and let's put it
317:31 - inside the counters and now we can test
317:33 - okay so let's see if we can interact
317:35 - with it and yep as I approach yep I do
317:37 - see it highlighted okay great and if I
317:39 - interact obviously nothing happens since
317:40 - the player isn't holding anything now if
317:42 - I pick something up let's say a tomato
317:44 - and I don't want this tomato so I want
317:46 - to trash it and if there you go it does
317:47 - get trashed all right awesome so this is
317:50 - literally it like I said this is once
317:52 - again another excellent example of the
317:54 - power of writing good clean code this
317:56 - was super simple to implement because we
317:58 - have a really nice structure for how all
318:00 - of our Counters work also because our
318:02 - interaction system is very well built
318:04 - also because the kitchen object system
318:06 - is very well made it's because of all of
318:09 - that great very clean code that we were
318:10 - able to implement a brand new counter in
318:12 - literally about 60 seconds
318:14 - so once again I hope that by following
318:16 - this course you know understand why I'm
318:18 - always talking about the importance of
318:19 - writing good clean code it's exactly
318:21 - because this if you write your code
318:23 - correctly it makes developing the game
318:25 - so much easier at first it might seem
318:27 - like the quick and dirty approach is
318:29 - faster and usually in the beginning it
318:30 - is faster but as soon as you add some
318:32 - complexity the quick and dirty approach
318:34 - suddenly won't scale whereas the
318:36 - well-built clean code approach this one
318:38 - will continue scaling very well so here
318:40 - we have a fully functional trash bin so
318:42 - we can dispose of unwanted objects next
318:45 - let's build a much much more complex
318:47 - Hunter let's build a stove counter which
318:49 - also requires building a really nice
318:51 - State machine so let's do that in the
318:53 - next lecture
318:55 - hey again another quick intermission
318:56 - you're past the halfway point so
318:58 - congrats again by now I really hope
319:01 - you've already learned a ton from the
319:02 - course we've already covered lots of
319:04 - topics and built a ton of systems I hope
319:06 - you've been following the website as you
319:07 - go through the lectures and I hope
319:08 - reading the frequently asked questions
319:10 - that I sent you in some way let me know
319:12 - in the comments how you've used the
319:13 - course website did you just read the FAQ
319:16 - or did you also download some project
319:18 - files let me know I'm curious to know if
319:20 - you enjoy my teaching song also look at
319:22 - my other courses after finishing this
319:23 - one especially the turn-based strategy
319:25 - course that one is an excellent
319:27 - follow-up for this one okay there's
319:29 - still quite a bit more for us to build
319:30 - and learn so let's continue in the next
319:32 - lecture
319:33 - hello and welcome I'm your code monkey
319:36 - in this lecture we're going to build the
319:38 - stove counter so we want to place some
319:40 - uncooked meat then we wait for a bit for
319:42 - it to be cooked however if we weigh too
319:44 - much it's going to get burnt so let's
319:46 - Implement that alright so as usual let's
319:48 - first begin by making our counter so
319:49 - let's go inside the prefabs the counters
319:51 - let's right click on the base counter
319:53 - and create new prefab variant call this
319:55 - the stove counter and as usual let's go
319:58 - inside of it let's find the visual so
320:00 - inside the prefab visuals it counters
320:02 - visuals here is the stove counter so
320:04 - let's drag it then let's duplicate this
320:07 - rename this one the selecton let's set
320:09 - the component the selected counter
320:11 - visual
320:12 - then let's go inside on all of these and
320:15 - by the way this visual actually has some
320:17 - nice visuals that we're going to
320:18 - implement in a little bit but for the
320:19 - selected we really just want the static
320:21 - objects so let's pick up all of these
320:23 - and let's select the counter slide
320:24 - visual okay nice and white then let's
320:27 - lock over here the parents so I can
320:28 - select all of these and drag all of them
320:30 - okay great and start off with all of
320:32 - them disabled okay so that's the basic
320:34 - setup as usual
320:36 - just for the Counterpoint
320:38 - since this one has a nice little sub on
320:40 - top let's lift it up by a little bit so
320:42 - put it on a y of 1.456
320:45 - okay that looks pretty good just move it
320:48 - a little bit to the center okay great
320:50 - so now let's make our script so let's go
320:52 - inside our scripts folder we've got our
320:54 - counters so in here let's create the
320:56 - brand new c-sharp script for the stove
320:58 - counter let's wait for it to compile
321:01 - let's attach the script and open okay so
321:04 - here as usual let's extend the base
321:06 - counter
321:07 - now like I said the going for this one
321:09 - is to be able to cook our meat and for
321:11 - that it's going to be based on a timer
321:13 - and to actually cook the meat we're
321:15 - going to need to know which one is the
321:16 - uncooked meat type and which one is the
321:18 - cook me type
321:19 - so for that we really want the exact
321:21 - same logic that we did for the cutting
321:22 - action we want some kind of place where
321:25 - we can store an input and output as well
321:27 - as a cook timer so for that let's
321:29 - actually just duplicate so let's go
321:30 - inside our scribble objects for The
321:32 - Cutting recipe and let's duplicate this
321:33 - one so Ctrl D and let's name this one
321:36 - the frying recipe so
321:38 - okay let's go inside
321:40 - and over here let's rename the object
321:42 - then we have an input we have an output
321:44 - and then a set of progress let's have
321:46 - the frying timer Max and since this one
321:49 - is a timer instead of an in let's make
321:51 - it a float okay so that's it pretty
321:53 - simple then back here in the editor
321:55 - let's create our script mode object so
321:57 - let's go inside let's make a nice folder
321:58 - so a folder for the frying recipe so
322:06 - and inside let's create one so let's
322:08 - create a brand new frying recipe so for
322:10 - this one let's call it meat Patty
322:12 - uncooked into meat Patty cooked
322:16 - then for the inputs let's choose the
322:18 - meat Patty uncooked now we have to make
322:20 - the other one so let's go ahead and make
322:22 - that one let's duplicate this one rename
322:24 - it to the meat Patty cooked
322:27 - and the object name meat Patty cooked
322:30 - let's select the different Sprites so
322:32 - this one is going to be the meat Patty
322:34 - cooked okay
322:35 - and finally for the prefab let's also
322:37 - make it so for the meat Patty cooked
322:41 - let's go inside of it and also make sure
322:43 - to save changes on our stove counter
322:45 - it's okay now in here let's get rid of
322:47 - this Visual and use the other visual so
322:49 - we want to meet Patty cooked and let's
322:51 - make sure to drag the script monk object
322:54 - okay so it's all good here and let's go
322:56 - back outside save it and finally over
322:58 - here on meat Patty cooked let's just
323:00 - grab the prefab reference so there you
323:02 - go that one okay so this one is working
323:04 - and since we're here and let's actually
323:05 - make the other one right away
323:07 - so let's make the meat Patty burned so
323:10 - the prefab and let's also duplicate this
323:13 - to make the meat Patty burned then on
323:16 - the text let's rename this to Burnt
323:18 - let's choose the burn icon
323:21 - and for the prefab let's go into our
323:23 - meat Patty burned and swap it out for
323:26 - the burned one so there you go nice and
323:28 - charred and over here swap it for the
323:30 - meat Patty burned okay let's save it and
323:33 - finally down here just make sure
323:34 - everything is correct
323:38 - object the transform prefab just like
323:41 - that okay so all of our burn references
323:44 - over here all of our cooked and over
323:46 - here all of our uncut and again when
323:48 - going through this process always make
323:49 - sure that you match all the references
323:51 - on the certain objects and also over
323:52 - here on the kitchen objects so meet
323:55 - Patty burn yep meet Patty burn for the
323:57 - uncooked the uncooked and for the coke
323:58 - there it is okay everything is good
324:00 - great so now we can go back over here
324:02 - into our frying recipe so and for the
324:04 - output let's output the meat Patty
324:06 - cooked and for the frying timer let's
324:08 - put it on three seconds
324:09 - okay so that's it great now back in the
324:12 - code here on the stove counter let's add
324:15 - an array of our frying recipes so a
324:17 - serialized field private it's going to
324:19 - be an array of frying recipe so frying
324:21 - recipe so array make omelette frying
324:23 - recipe so a ring okay great then back
324:26 - here in the editor let's go inside the
324:28 - stove counter let's make sure to drag
324:31 - that so let's drag the mid Patty from
324:33 - uncooked into cut okay let's also drag
324:36 - the counter top point and finally since
324:38 - we already made the script over here on
324:39 - the selected we can also drag the
324:41 - selector okay so our stove prefab should
324:43 - be working okay let's go outside make
324:45 - sure to save the prefab okay now let's
324:47 - continue with the rest of the script
324:49 - so let's make our override so override
324:53 - the interact action
324:54 - and when we interact with it let's
324:57 - validate dropping the object just like
324:59 - we did on the cutting counter
325:02 - so let's go over here into our cutting
325:04 - count script and let's just copy pretty
325:06 - much the exact same thing so let's copy
325:07 - all of this interact code let's go over
325:10 - here in the stove counter and just paste
325:11 - it now we also need to copy in our
325:14 - recipe
325:15 - so over here on the cutting counter
325:17 - let's copy paste those functions so
325:19 - these functions go into the cell counter
325:21 - and over here on let's face them they're
325:22 - going to work pretty much the same thing
325:24 - so we get an input except instead of
325:26 - being a cutting recipe so we're going to
325:28 - have a frying recipe so so let's replace
325:31 - all the cutting recipe references with
325:33 - frying recipe reference
325:35 - then for the array this one is the
325:37 - frying rasps array and obviously let's
325:39 - rename these so Ctrl R to rename all of
325:41 - them into frying recipe so
325:44 - let's also rename the function instead
325:46 - of get cutting rest BSO it's the frying
325:48 - recipe so okay so there's no more
325:50 - mentions of cutting over here so let's
325:52 - use this function up here and up here
325:54 - and just make sure to rename these the
325:56 - frying recipe as so
326:00 - and down here on same thing so the
326:02 - frying recipe so okay so down here we
326:05 - have no more mentions of any cutting
326:07 - let's just go up here and solve all
326:09 - these problems so first we check if
326:11 - there's no kitchen object here and if
326:13 - the player is carrying something then we
326:14 - see if what the pointer is carrying
326:16 - matches any kind of frying recipe if so
326:18 - then the player is carrying something
326:20 - that can be primed then we set the
326:22 - parent and for now let's not worry about
326:24 - the progress
326:26 - so let's just get rid of all this just
326:28 - like this okay so with this we should be
326:30 - able to drop but only in uncooked meat
326:32 - so back in the afternoon let's just set
326:34 - up our scene so let's drag a stove
326:36 - counter onto our scene let's put over
326:38 - there on X of 6 y of 0 and 3.5 alright
326:42 - so let's test okay so now if I pick up
326:45 - some cheese I go up there and I drop it
326:47 - and nope doesn't work okay great but if
326:50 - I pick up some uncooked meat and I go
326:51 - and I drop it and yep that does work
326:53 - okay great so it works and I can only
326:55 - drop the actual objects and matchy
326:57 - recipe now unlike the cutting counter
326:59 - this one will not be based on a player
327:01 - alt interaction and actually over here
327:04 - and let's fix this minor issue
327:06 - basically we added this debug.log error
327:09 - to the base interact because pretty much
327:11 - every single counter is going to
327:12 - implement this interact function but not
327:14 - all encounters are going to have the
327:16 - interact alternate action
327:17 - so this one lets us do nothing let's not
327:19 - spawn error okay just a quick fix
327:22 - so like I said the stove counter this
327:24 - one is going to be based on a simple
327:26 - timer and for making some time based
327:28 - logic basically we have two approaches
327:30 - one approach is to use a simple foil
327:32 - timer or you can also use a co-routine
327:35 - now a lot of tutorials will teach you
327:37 - how to use a co-routine and that's not
327:39 - necessarily a bad practice it does work
327:41 - it does achieve desired result so to do
327:44 - that you would just make a function like
327:45 - Freight timer
327:47 - so you'd make a private you have to
327:49 - return I in numerator
327:52 - then call it something like handle fry
327:54 - timer
327:56 - then inside you can do a yield return
328:00 - and return a new weight for seconds
328:06 - and to start this co-routine you would
328:08 - do maybe on start you would call start
328:10 - Co routine
328:14 - and start the handle for right hammer
328:17 - so this one approach this is definitely
328:19 - perfectly foundly timer code
328:21 - however personally I am not a fan of
328:23 - co-routines it's not because of
328:25 - performance or anything it's simply
328:27 - because I don't like the pattern that
328:28 - they force you to use I don't like being
328:31 - forced to make a function that returns I
328:32 - numerator I don't like using yield
328:35 - return I don't like having to use the
328:37 - start core routine function I don't like
328:39 - being forced to use this on a
328:41 - monobehavior object those are all
328:43 - requirements for making a CO routine
328:45 - work and personally I find those are way
328:47 - too many requirements that create a very
328:49 - strange pattern that I really don't like
328:51 - so that's really the only reason I don't
328:53 - like Co routines because I find this
328:55 - pattern to be quite a lot convoluted so
328:57 - instead of core routines what I like to
328:59 - use are simple basic flow timers so just
329:02 - make a simple and private void update
329:04 - then we just need to keep track of a
329:06 - certain timer so for example a simple
329:08 - private float frying timer
329:11 - then on the update let's first check
329:13 - that we have an object so it has a
329:15 - kitchen object if we have a kitchen
329:16 - object then let's increase the timer by
329:19 - time dot of time by the way here when
329:21 - working with a timer you can increase or
329:23 - decrease it's pretty arbitrary both ways
329:25 - work the obvious difference is only if
329:27 - you test if it's above the max or if
329:29 - it's under zero in here for frying it
329:31 - does make sense to start at zero and
329:33 - then the defraying timer Max
329:35 - so either that and if the frying timer
329:37 - if it is bigger than the maximum
329:40 - so let's get the frying rest PSO frying
329:42 - recipe so
329:43 - let's get the frying recipe so with
329:45 - input so let's get this kitchen object
329:47 - and get the kitchen object itself okay
329:50 - so we go into the frying rest BSO and we
329:52 - get the frying timer Max okay so if it's
329:54 - above the max then this one has been
329:56 - fried so here I'll let you see what we
329:58 - did on the cutting counter
330:00 - so let's get this kitchen object and
330:02 - tunnel to destroy itself
330:04 - and then let's go into the kitchen
330:06 - object class in order to spawn another
330:07 - kitchen object let's go into the frying
330:09 - recipe and spawn the output
330:12 - and we're going to spawn it inside of
330:13 - this counter
330:16 - right so that's it this should already
330:17 - be working we don't have a visual yet so
330:20 - let's add a debug log
330:21 - so here just say debug.log on the frying
330:24 - timer
330:25 - and up here let's also just reset the
330:28 - timer so frying time now let's put it on
330:30 - zero f and let's also do a debug.log and
330:32 - say fried
330:34 - however like this you might already be
330:35 - guessing that we're going to have a
330:37 - bunch of bugs but still let's just test
330:38 - it just like this
330:40 - okay so over here I can move around I
330:42 - can pick up some uncooked meat I can
330:44 - drop it there and after a little bit
330:46 - there you go there's the timers and if
330:48 - there you go it did work you can see the
330:50 - timer increase until three then it was
330:52 - fried then it was reset and then we've
330:54 - got a known reference exception
330:56 - basically this is the exact same problem
330:58 - that we had on the cutting counter where
331:00 - first we put an object like tomato and
331:02 - that is indeed an input for a recipe so
331:04 - we cut tomato into slices but then the
331:06 - slices are not an input for any recipe
331:08 - so over here we put some uncooked meat
331:10 - so that's great we frying which means we
331:12 - destroy the uncooked meat and we spawn
331:14 - the cooked meat but then next time the
331:16 - cooked meat is not an input for anything
331:17 - so obviously this one is going to return
331:19 - no one thing we can do to sort of solve
331:22 - this problem which is also going to be
331:24 - beneficial in terms of performance is
331:25 - simply caching this field so let's go
331:28 - here to find a frying recipe a cell
331:30 - frying recipe so
331:32 - instead of constantly getting it on
331:34 - every single update which might be a bit
331:36 - costly in terms of performance instead
331:38 - of this let's just get it over here when
331:40 - the player drops something so the player
331:42 - drops something and we assign the Frank
331:43 - rest BSO so we sign it cache the value
331:45 - and then do this okay that should have
331:48 - fixed the non-reference problem but we
331:50 - still have a bunch more problems but
331:51 - still let's test it out okay so here
331:53 - let's pick up some meat put it there and
331:56 - let's look at the timer and if there you
331:57 - go everything is cooking great any of
331:59 - their yo it finished it cooked and the
332:01 - time was reset and now it's finishing
332:02 - it's cooking and so on so this is
332:04 - obviously another pretty serious problem
332:06 - basically it's constantly frying the
332:08 - meat and spawning more and more objects
332:09 - instead of constantly spawning from the
332:12 - same recipe what we want is for the
332:14 - stove to First fry the object but then
332:16 - if the object is fried then we want to
332:18 - burn it so really that means that we
332:21 - want the stove to have multiple States
332:22 - meaning that we're going to need to make
332:24 - a simple State machine so let's do just
332:26 - that now if you're a beginner the
332:28 - concept of a state machine might seem
332:30 - daunting at first but it's actually
332:31 - extremely simple at least to make a very
332:33 - basic one all we need is really just a
332:36 - bunch of saints so to define those
332:37 - States let's go up here and make a
332:39 - simple enum so let's make a private enum
332:42 - call it state
332:44 - and now let's put all the states for our
332:46 - state machine now for the server let's
332:47 - say we have idle when there's nothing on
332:49 - top
332:50 - then let's say we have a frying state
332:52 - for when the ingredient is actually
332:54 - being fried then we have fried for when
332:56 - the ingredient has already been cooked
332:58 - but it's still getting some heat and
333:00 - finally if we leave it too long in that
333:01 - state then everything ends up burned
333:03 - okay so these are all of our states for
333:05 - our state machine
333:06 - and how to make the actual stick machine
333:08 - it's actually quite simple first of all
333:10 - we just need to store the current state
333:11 - so here make a private of type State and
333:14 - sort the current state
333:15 - and then on update let's just do a
333:17 - switch on the current state
333:20 - okay now here basically we're going to
333:21 - do different logic depending on the
333:22 - state that we're at
333:24 - so let's say if we're I don't we do
333:26 - something then if we are frying we're
333:28 - going to do something else then if we
333:30 - are on the front also something else and
333:33 - finally if we are on Burn do something
333:35 - else
333:36 - so here are all of our states and the
333:39 - logic that we did down here this is the
333:41 - frame logic so let's actually just copy
333:43 - on this
333:44 - and let's face it inside the frying
333:46 - logic and for the seed machine we're
333:49 - only going to run any of these states if
333:51 - there's a kitchen object inside of it so
333:52 - it's actually put that switch in there
333:54 - just like this
333:55 - okay so that's it so when I don't we're
333:58 - not doing anything and when frying we're
333:59 - going to run our frying timer we're
334:01 - going to fry the object let's also get
334:03 - rid of the low we no longer need this
334:04 - then we destroy the current object and
334:06 - we spawn a brand new object now what we
334:08 - need is to handle over here the State
334:10 - field we need to modify this winching in
334:12 - Saints so first of all let's handle the
334:14 - start so let's make a private void start
334:17 - and on start let's begin with the state
334:20 - on state DOT Idol okay great then down
334:23 - here when we interact when the player
334:24 - drops something when the player drops
334:26 - something that can be fried
334:27 - over here on let's set the state and put
334:30 - it on state DOT frame
334:32 - and over here we should also probably
334:33 - reset the timer so let's set the frying
334:35 - timer back into zero f okay we set the
334:38 - timer and we reset the state finally up
334:40 - here let's not reset the timer since
334:43 - we're resetting the timer down there
334:44 - since it makes more sense down there so
334:46 - we do the frying the frying timer we end
334:48 - the frying and then obviously we need to
334:49 - modify the state so modify State and put
334:51 - it on state DOT fright
334:53 - okay so that's the basics of our state
334:55 - machine with this everything should be
334:57 - working just the same as previously
334:58 - except we're only going to fry once so
335:01 - let's actually just put them out here
335:02 - debug the hog
335:04 - object Pride
335:06 - and let's put one down here outside of
335:09 - the save machine just do a debug.log on
335:12 - the state
335:14 - okay like this let's test
335:16 - okay so here we are let's pick up some
335:19 - meat and drop it on there and there you
335:21 - go it goes from idle directly into
335:22 - frying and then it's fried and after you
335:25 - go now it stays on fried so it no longer
335:27 - goes on frying and it's no longer
335:29 - spawning any more objects it went from
335:30 - frying into fried and yep everything
335:32 - worked alright awesome
335:34 - so we have the Frank State working
335:36 - perfectly now let's handle the burning
335:38 - in terms of logic it's really going to
335:39 - be the exact same thing
335:41 - we're going to have a frying timer so
335:43 - let's copy this code and paste it down
335:45 - here now technically we could reuse the
335:48 - exact same float timer but that would be
335:50 - a bit confusing so let's keep our code
335:52 - as clear as possible and really just
335:54 - make a different timer with a more
335:56 - descriptive name
335:57 - so pure a private float called The
336:00 - Burning timer
336:01 - then let's initialize this timer so when
336:03 - we go into the fried State let's set the
336:06 - timer the burning timer into zero then
336:08 - down here let's use this Burning timer
336:10 - okay great when timers and lapse and the
336:13 - object is spawn let's go into the
336:15 - Burnside
336:16 - and obviously we need another recipe
336:18 - so let's make another scriptable object
336:20 - back in the editor let's find the frying
336:23 - recipe so let's duplicate this call it
336:25 - the burning recipe so
336:28 - then over here let's modify the name
336:29 - instead of frying timer Max let's call
336:31 - it burning timer Max okay great so now
336:34 - over here on the stove let's use pretty
336:36 - much the exact same thing and let's make
336:38 - over here private of burning recipe so
336:40 - the burning recipe so
336:43 - then down here we just need a function
336:45 - to get the burning recipe so so let's
336:47 - copy this and paste it over here this
336:50 - one's going to return a burning rest BSO
336:52 - so let's replace this and this
336:54 - rename this into burning recipe so we're
336:58 - going to need an array and over here
336:59 - let's just change the name instead of
337:01 - frying recipe so the burning recipe so
337:05 - let's just find a new array so let's go
337:08 - all the way up here make another array
337:09 - an array of burning recipe so and this
337:12 - is the burning recipe SL ring and
337:15 - finally if we go down here let's use
337:16 - this array okay that's it so now let's
337:19 - use this function to set our burning
337:21 - rest BSL so when we set it to find let's
337:24 - set the burning recipe so and let's get
337:27 - it with the input and the input is going
337:28 - to be the object that is on here so the
337:31 - kitchen object dot get the kitchen
337:32 - object.so
337:36 - okay so we're initializing our fright
337:39 - State and setting up the burning recipe
337:40 - so and over here we use that one dot Max
337:43 - and we get into that one and use the
337:45 - output so over there object frying over
337:48 - here object burned all right so that's
337:50 - pretty much it we modified everything to
337:52 - say burning timer over here we are
337:54 - correctly initializing so we go through
337:56 - the burning timer through the burning
337:57 - rest PSO which we are grabbing up here
337:59 - then we spawn the output on the burning
338:01 - rest BSO and we go into state.burn okay
338:04 - so all that's left is just filling in
338:05 - this array so back in the editor over
338:08 - here on let's make the object so let's
338:10 - make a brand new folder for the burning
338:13 - recipe and so and now inside let's
338:15 - create a new Burning recipe so call this
338:18 - one the meat Patty cooked into meat
338:22 - Patty burned and over here let's set the
338:24 - input so the meat Patty cooked onto the
338:27 - meat Patty burned and for timer let's
338:29 - make it take a bit longer to burn so
338:31 - let's say five seconds okay that's great
338:33 - let's just drag the reference so let's
338:34 - go into the stove counter and let's make
338:36 - sure to open up and go inside the prefab
338:38 - and over here on the prefab just write
338:40 - the burning recipe okay that's great
338:42 - let's go outside save the prefab and
338:44 - let's test alright so here we are let's
338:47 - pick up some meat drop it on there and
338:49 - look over there it's frying and after a
338:51 - bit yep it's right there you would spawn
338:52 - that one and now if we wait for five
338:54 - seconds it should go from frying to burn
338:56 - any up there you go that one is charred
338:58 - everything is burned everything is great
338:59 - all right awesome so everything worked
339:02 - as intended with this song of our logic
339:04 - is working now let's handle on picking
339:05 - up objects from the stove now
339:07 - technically it's already working so I
339:09 - can approach yourself and pick it up the
339:11 - object and there you go drop it in there
339:12 - so that does work however if we look
339:15 - over here in the log the state machine
339:16 - is now in the wrong state so over here
339:19 - let's do a quick fix let's go down into
339:22 - the interact action okay so here it is
339:24 - so if there's no kitchen object then the
339:26 - player places it okay that's good but if
339:28 - there is a kitchen object so if there's
339:29 - something on the stove counter when the
339:31 - player picks it up let's also manually
339:33 - set the state
339:34 - and put the state back into idle just
339:38 - like this okay that's it so let's test
339:41 - okay so over here let's pick up some
339:42 - meat put it in there it's cooking and
339:44 - let's wait until it gets finished yep
339:46 - there you go it's done pick it up and
339:48 - there you go out now if I want I can put
339:50 - another one and if there you go the
339:51 - logic is reset and everything is back to
339:53 - normal okay great so often logic is
339:55 - working perfectly now let's just get rid
339:57 - of our logs so we don't need this so
339:59 - let's get rid of that debugging log this
340:01 - one and this one okay great everything
340:03 - is nice and clean and now let's add some
340:06 - nice fun visuals so if we go inside the
340:08 - stove counter and over here is the
340:10 - visual and I include these two prefabs
340:13 - inside the visual so one of them this
340:15 - one the stove on visual this one is just
340:18 - a glowing red square now again there's a
340:20 - weird bug on this specific empty version
340:22 - so post processing isn't showing over
340:24 - here on scene view but if I leave it
340:26 - enabled and I go back outside
340:28 - and now from work in the game view if
340:30 - there you go there's a nice glowing red
340:32 - square if you don't see glowing make
340:34 - sure you add the balloon post Crossing
340:35 - effect
340:36 - so if you missed something you can go
340:37 - back into the post-processing lecture
340:39 - and make sure everything is set up
340:40 - correctly so there's a nice glowing red
340:43 - square and there's also a bunch of
340:44 - particles so you can name on this one
340:46 - press on restart and there you go just
340:47 - some nice particles just jumping up this
340:49 - was made with the unity particle system
340:52 - so for example on the hierarchy you can
340:54 - right click go up here into effects and
340:56 - you can create a particle system
340:58 - so that's what this is it has a particle
341:00 - system over here you can see all of the
341:02 - various settings for these particles
341:04 - they just jump up and fall down so for
341:07 - jumping up that is the emission you can
341:09 - actually see a visual over there of the
341:10 - cone that is the spawning cone which you
341:12 - can find over here on the shape so in
341:15 - the shape it has the shape of a cone
341:17 - then you can see the radius radius
341:19 - thickness and so on so that is from
341:20 - where the objects are being spawned then
341:22 - up here you can see the lifetime of each
341:24 - object so each particle is going to last
341:26 - for 0.7 seconds
341:28 - you can all see the speed so that's
341:29 - speed at which they come from there the
341:31 - start size that's how big they are on
341:33 - start
341:34 - and note how the particles are spawning
341:36 - jumping up and falling down
341:39 - so that Falling Down is over here the
341:40 - gravity modifier if you put it at zero
341:43 - then they just keep going up and if you
341:44 - put a two yep they go up and they fall
341:46 - down
341:47 - next down here on the emission this is
341:49 - how many are being spawned so if I put
341:51 - this on 200 there you go tons and tons
341:53 - of particles next is over here the size
341:56 - of our lifetime so this one has just a
341:58 - basic curve so they started off on font
342:00 - size and over the x-axis this one is in
342:03 - a lifetime so as the particle goes from
342:05 - the beginning until the end their life
342:06 - they basically go down on size so that
342:08 - is why they become quite a bit smaller
342:09 - also by the way this one down here this
342:11 - one is called an animation curve this is
342:13 - another really useful ENT feature I have
342:16 - a dedicated video on animation curves
342:17 - and finally down here just have the
342:19 - renderer so it's just using some basic
342:21 - particles so we can inspect the material
342:23 - simple in the assets and there you go
342:25 - we're just using the default particle
342:27 - material just with the alpha on half and
342:29 - that's pretty much it so as you can see
342:31 - just a very basic very simple particle
342:33 - system now all we really want to do is
342:36 - just for both of these we want to enable
342:38 - or disable them depending on if the
342:40 - stove is on or not so let's make a
342:42 - script to handle the visuals so let's go
342:44 - down and create a brand new c-sharp
342:45 - script let's go with the stove counter
342:48 - visual then let's go into the stove
342:50 - counter Visual and let's attach the
342:52 - script
342:53 - so here it is attach it and open right
342:55 - so now here we just need references to
342:57 - those two objects so as usual let's make
342:59 - a basic serialized film let's make it of
343:02 - type game object
343:04 - for the stove on game object and the
343:07 - other one is the particles game object
343:10 - okay let's save and back here in the
343:12 - editor let's drag the references so the
343:14 - stove on Visual and the sizzling
343:16 - particles okay great so now all we
343:18 - really need to know is know when to turn
343:20 - these on or off and for that is really
343:22 - going to be based on the state over here
343:24 - on the stove counter so if it is on the
343:26 - state frying or fried then we want to
343:28 - show them if it is on idle or burned we
343:30 - want to hide them but as usual we don't
343:32 - want to mix the logic and Visions
343:33 - directly so let's do that through a
343:36 - really nice event
343:37 - let's make a public event let's use a
343:40 - standard event handler let's call it on
343:43 - stay changed
343:45 - and let's also include the state on the
343:47 - event Arc so let's make a public class
343:48 - call it on state change event args and
343:53 - let's expand event arcs and then in here
343:56 - let's just put a public state
343:58 - for our state
344:00 - however here we also have a really nice
344:02 - error so this one is telling you there's
344:04 - inconsistent accessibility basically
344:06 - that's because we made this one public
344:08 - so any class link for his Mr visual
344:10 - class can indeed see this class however
344:13 - from outside that class cannot see the
344:15 - private state
344:16 - so that is why we have inconsistent
344:18 - accessibility we cannot have something
344:20 - public which inside has something of a
344:22 - specific type which is private
344:24 - so in order to make this work we need to
344:26 - modify this state and make it public so
344:28 - that the other classes can see it okay
344:30 - so that's great now let's just fire this
344:31 - event whenever the state changes so over
344:34 - here when you go into the frying State
344:35 - let's go and invoke and as usual just
344:38 - this
344:40 - and I actually forgot to add that so
344:42 - let's go up here let's use the one with
344:44 - generics so the on state change event
344:46 - arcs okay great so then down here we
344:48 - invoke the event let's create of this
344:51 - time
344:52 - and inside passing the state equals this
344:54 - state
344:55 - okay so this one we need so then down
344:57 - here go into the burn State let's fire
344:59 - the event and down here frying fire the
345:02 - vent and on idle fried event alright
345:04 - that's it so we have all of our state
345:06 - logic and over here on the stove counter
345:08 - visual obviously we need a reference to
345:10 - the counter so let's add that so a
345:13 - serialized field private
345:15 - maker of type stove counter for the
345:18 - stove counter and then we can do an as
345:20 - usual for accessing external references
345:22 - let's do it on start go into the stove
345:25 - counter and let's listen to the on say
345:27 - change event
345:29 - and over here it's going to be very
345:30 - simple we just want to show if it's on
345:32 - the state frying or fried and if not we
345:35 - don't want to show so let's define a
345:37 - bone called show visual
345:39 - and this one is going to true if the E
345:40 - dot State equals the state DOT frying or
345:44 - E dot State equals
345:46 - the state DOT fried
345:49 - so if it's either of these then this is
345:50 - going to be true if not it's going to be
345:52 - false so then let's just go into the
345:54 - stove on game object
345:57 - and constant active and pass in this
346:00 - and same thing for the other for the
346:02 - particles game object okay that's it
346:04 - super simple let's just drag this
346:05 - reference so over here inside the prefab
346:07 - just drag the reference let's leave the
346:10 - prefab save the changes and let's hit on
346:12 - play and all right so it starts off
346:14 - disabled okay so there's no visuals now
346:16 - if I pick it up and I drop it and there
346:17 - you go a nice visual so the glowing red
346:19 - hot and the particles and now it's
346:21 - running and if I leave it until it burns
346:23 - when it burns and it's going to turn it
346:25 - off and if there go turns off
346:26 - all right awesome so now if I pick it up
346:29 - wait until it gets cooked so let's go
346:32 - pick it up and the other you go turns it
346:33 - off
346:34 - all right awesome we've got a really
346:36 - nice visual all that's left is to have a
346:38 - proper visual progress bar and with this
346:40 - we actually have another interesting
346:42 - clean code question
346:43 - right now the progress bar that we made
346:45 - over here on the cutting counter that
346:47 - one is great so we would like to reuse
346:49 - that however if we look over here on the
346:52 - progress bar UI we can see this is only
346:54 - working with the specific type cutting
346:56 - counter
346:57 - so by default this will not work with a
346:59 - stealth counter so as usual we have
347:01 - multiple approaches to solving this
347:03 - problem one option would be to Simply
347:05 - commonly duplicate the script then we
347:07 - would make a completely different
347:09 - progress bar UI class that would work
347:10 - only with the stealth counter so that's
347:12 - one approach that would work and that
347:14 - approach might be good if you want the
347:16 - progress bar to behave very very
347:18 - differently
347:18 - but over here I want both of them to
347:20 - behave exactly the same so instead of
347:22 - having some code application we can
347:25 - write some good clean code but doing
347:26 - exactly what we did with regards to the
347:28 - kitchen object parent meaning we can use
347:31 - a nice interface we can then Implement
347:32 - on anything that has some kind of
347:34 - progress so let's do exactly that first
347:37 - of all let's actually go inside the
347:39 - cutting counter so let's go inside the
347:40 - prefab then over here we've got the
347:42 - progress bar and this one is just a
347:43 - regular game object but since we're
347:45 - going to reuse this let's make this a
347:47 - proper prefab so let's find over here
347:49 - all of our prefabs and just drag the
347:51 - progress bar UI inside the prefabs
347:52 - folder okay great so this is now a
347:54 - proper prefab now let's define our
347:57 - interface so let's create a brand new
347:59 - c-sharp script as usual interface start
348:01 - with I so let's go on I and for this one
348:03 - we wanted to represent anything that has
348:05 - progress so let's just call it literally
348:07 - has progress
348:09 - personally I like to use the word has to
348:11 - indicate that a certain object has
348:12 - certain Behavior so in this case objects
348:15 - that implement this interface will have
348:16 - some kind of progress Behavior so now
348:18 - over here for the interface let's first
348:20 - make it so this one does not extend
348:22 - amount of behavior instead of a quest
348:23 - this one is an interface okay great so
348:26 - now for the functions that we're going
348:27 - to need if we look in the progress bar
348:30 - and we'll look at the cutting counter
348:31 - references we can see the only one is
348:33 - literally just this so we just have to
348:35 - listen to the event and then the rest of
348:37 - progress bar Works inside of it so real
348:39 - and interface is the only thing we need
348:41 - to Define so let's actually go inside
348:42 - the cutting counter so here we have the
348:44 - unprogress change event and then we have
348:46 - this so we can literally just copy this
348:48 - go into the I has progress and let's put
348:50 - exactly this
348:52 - okay that's it that is literally all we
348:54 - need now if we wanted we can also make a
348:56 - function to expose the progress amount
348:57 - but since we included over here on the
349:00 - event then we really don't need it just
349:01 - this is enough now let's go over here on
349:03 - the progress bar UI script instead of
349:06 - working with the type cutting counter
349:07 - instead let's work with a type that has
349:09 - I has progress so let's rename this Q
349:12 - has progress
349:14 - and it's going to have the exact same
349:15 - event the only difference is over here
349:18 - instead of the event RX being the one
349:19 - inside the cutting counter is the one
349:21 - inside the eye has progress so let's
349:22 - make sure to change this I has progress
349:25 - okay so the signature matches let's just
349:27 - obviously rename this
349:29 - so let's rename instead of cutting
349:30 - counter let's rename has progress on
349:33 - progress change and that's pretty much
349:35 - it we don't have any more errors so
349:37 - everything over here is now working
349:39 - nicely with our interface and back here
349:41 - in the editor once we're still inside
349:43 - the cutting counter
349:44 - suddenly interfaces do have one downside
349:46 - when it comes to Unity
349:48 - if we look in the progress bar UI down
349:50 - there we can see the progress bar UI and
349:52 - previously we had the counter field
349:54 - exposed in the editor however now by
349:56 - changing into an interface there we have
349:58 - the issue the film does not show up here
350:00 - interfaces do not show up in the editor
350:02 - because Unity basically has no way of
350:04 - knowing that the interface won't be
350:05 - implemented by some kind of game object
350:07 - so sadly this is the one thing that
350:09 - doesn't work very well with unity the
350:12 - solution that I normally do is actually
350:13 - pretty simple instead of exposing the
350:15 - interface which does not work and said
350:17 - let's just make this a regular private
350:19 - field
350:19 - and then let's make a serialized film
350:21 - and for this one let's make it a type
350:23 - game object and let's call it has
350:25 - progress game object
350:27 - okay so like this we have a regular
350:29 - serialized field with a regular game
350:31 - object so if you look here yep we do
350:33 - have that field so now we can indeed
350:35 - Drag The Cutting counter reference and
350:37 - then over here in the code in order to
350:39 - get the has progress that is super
350:40 - simple has progress we just go into the
350:43 - hash progress game object and get
350:44 - component of type I has progress
350:47 - okay so that's it now our code does work
350:50 - however of course one big potential
350:52 - issue with this is that over here we
350:53 - have a field of type game object meaning
350:56 - that we have no guarantee that this
350:58 - field does have a component that
350:59 - implements the interface so we cannot
351:01 - make sure that we drag the correct
351:03 - reference we can drag any reference
351:04 - doesn't have to have our progress
351:06 - interface so in order to keep our sound
351:08 - safe let's add a nice safety warning so
351:10 - over here if has progress equals no so
351:14 - if this one is known that means that
351:15 - that game object does not have any
351:17 - progress interface if so let's do a
351:19 - debug download error
351:22 - and let's say the game object and let's
351:25 - pass in this game object
351:29 - does not have a component that
351:31 - implements I has progress
351:35 - so this way if we make a mistake we
351:37 - won't have a nice error message
351:38 - basically this is the one workaround
351:40 - that you need to use since Unity does
351:42 - not support dragging references in the
351:44 - editor if they are interface references
351:46 - okay so with that everything is good so
351:49 - all of our progress bar UI this should
351:51 - all be working perfectly we just need to
351:53 - go over here into our cutting count
351:55 - script and let's make it so that we
351:57 - Implement our interface so I has
351:59 - progress and we got an error just
352:01 - because even though we did Define that
352:03 - interface remember the on progress
352:04 - change again keep in mind that the types
352:07 - depend on not just their name but where
352:09 - they're at so this type that we have
352:11 - here is the one that we Define here
352:12 - which is not the same one that we have
352:14 - here so even though they have the exact
352:16 - same name because they are in different
352:17 - places they are actually different types
352:19 - so we need to make sure to use the type
352:21 - in the interface over here let's just go
352:22 - into the I has progress and use that
352:25 - exact type and get rid of this one okay
352:27 - so that's it that's the change we need
352:28 - and down here when firing let's just
352:30 - fire with that type and down here the
352:32 - same thing with that type okay great so
352:35 - like the this The Cutting counter should
352:37 - still be working exactly the same as
352:38 - previously again when refactoring any
352:40 - code always do a quick test and let's do
352:42 - that let's make sure to save our counter
352:44 - save the prefab go back outside head on
352:46 - play now let's pick up some cheese put
352:48 - it there cut and there you go the
352:50 - progress bar still does work okay great
352:52 - now let's apply it to the stove and that
352:54 - is actually going to be very simple
352:55 - first let's go inside the stove so let's
352:57 - find the stove counter let's open it up
352:59 - go inside the prefab and over here let's
353:01 - drag the progress bar UI prefab so let's
353:04 - drag that then down here we already have
353:06 - the has progress game object so let's
353:07 - drag the stove counter and that's it
353:09 - there's nothing else we need to touch
353:10 - here we just need to go over here into
353:13 - the stove counter and as usual let's
353:15 - implement the interface so the eye has
353:17 - progress
353:18 - and now let's implement it pretty much
353:19 - just like we did on the cutting counter
353:21 - so we can actually just copy this so we
353:23 - just need to implement the event so
353:25 - that's it and now for firing the event
353:27 - let's go down and see where we are
353:29 - modifying all of our timers so let's go
353:32 - down to when the player drops something
353:34 - so we do the on say change and now let's
353:36 - invoke this event so this and for the
353:40 - progress bar for the progress normalize
353:42 - this one is very simple so just frying
353:44 - timer divided by the frying recipe so
353:47 - dot frying timer Max
353:49 - okay that's it we are modifying the
353:51 - progress now let's go up here when we
353:53 - are in the Frank State and when we do
353:55 - let's fire off the on progress change
353:57 - event okay great and finally down here
354:00 - when we have defined over here let's
354:02 - also fire except obviously we have the
354:05 - burning timer and the burning timer Max
354:08 - and then just to make sure that the bar
354:10 - actually hides itself when we go into
354:12 - burned let's also find an event this one
354:14 - doesn't have a timer so let's just put
354:15 - it on xeraf okay that's really it
354:18 - we don't need to touch the progress bar
354:20 - UI at all Let's test this just make sure
354:22 - to save the prefab let's go back outside
354:25 - and hit on point and right away yep the
354:27 - bar is indeed hidden now if I pick up
354:29 - some meat and I drop it and there you go
354:31 - got a really nice bar going up any up
354:34 - going up on the burning site and let's
354:35 - get to the end let's see if the bar
354:36 - hides so it gets to the end and you have
354:38 - to go the bar that's high all right
354:40 - awesome and if I pick up something
354:43 - actually this was the one event that we
354:44 - forgot so let's fix that so let's just
354:47 - copy the one where we set the progress
354:48 - normalized to zero and over here if the
354:50 - player picks up something let's add the
354:52 - progress back into zero
354:54 - so here we are let's pick up some meat
354:56 - drop it on there okay let's wait for it
354:58 - to be cooked okay it's cooked now before
355:00 - it burns pick it up and there you go the
355:02 - bar is gone all right awesome okay so
355:05 - here we have again another example of
355:07 - the power of writing good clean code we
355:10 - made a nice generic progress bar and we
355:12 - very easily made it work with a
355:13 - completely different counter which of
355:15 - course would also work with literally
355:16 - anything that implements that interface
355:18 - doesn't have to be a counter now let me
355:20 - make one note here basically I showed
355:22 - you how to make a generic progress bar
355:24 - and reuse it but let's say you want to
355:26 - do something specific just for the solve
355:28 - well one approach like I mentioned is to
355:30 - duplicate the code and make a progress
355:32 - bar that works only with the solve but
355:34 - another approach is to Simply add more
355:36 - elements on top
355:37 - for example during the Polish stage
355:39 - we're going to do exactly that
355:41 - we're going to add an extra UI element
355:43 - that won't show up to one of the player
355:45 - when the food is about to burn so I just
355:47 - want to point out how you can mix and
355:48 - match both them you can have both
355:50 - generic components coupled with specific
355:52 - components
355:53 - but for now our progress bar everything
355:55 - is looking pretty good so let's leave
355:57 - that burn warning just for the police
355:58 - age now the next very important thing we
356:01 - need is some points so let's do that in
356:03 - the next lecture
356:04 - hello and welcome I'm your kudmaki in
356:07 - this lecture we're going to create the
356:09 - plates counter this one is just going to
356:10 - spawn some points which we can then pick
356:12 - up to grab some objects okay so let's
356:15 - begin making the counter as usual so
356:17 - let's go inside our prefabs inside our
356:19 - counters right click the base counter
356:21 - make a new prefab variant
356:23 - called the plates counter
356:26 - let's go inside and let's drag the
356:29 - visual for the plates counter let's go
356:31 - into scene view so we can see it okay
356:32 - let's duplicate this make this the
356:34 - selected let's go inside and we can
356:37 - actually hide the Eternal Sprite we only
356:39 - need this one so on this one let's
356:40 - modify it for the counter selected on
356:42 - the selected let's make it just one
356:44 - percent bigger and let's add the
356:47 - selected counter Vision okay then inside
356:49 - obviously drag the reference for the
356:51 - kitchen counter okay that's our basic
356:53 - setup now let's make our script to run
356:55 - this so let's create a brand new c-sharp
356:57 - script for the plates counter let's
357:00 - attach the scrub to the plates counter
357:02 - and open okay now here as usual let's
357:05 - extend our base counter and then first
357:08 - let's handle the spawn timer logic so
357:11 - basically we want to spawn some plates
357:12 - every once amount of time
357:14 - somewhat sorry simple float for the
357:17 - spawn plate timer then let's make a
357:20 - simple update on timer let's increase
357:22 - the spawn point timer by time dot of
357:24 - time
357:27 - and then just check if it's above a
357:29 - certain maximum
357:31 - so if it is above something in this case
357:34 - we're going to have a fixed value
357:36 - but still like I mentioned in the very
357:37 - beginning of this course let us not use
357:39 - magic numbers here you should never use
357:41 - magic numbers
357:42 - instead if you wanted to make it edible
357:44 - you could also make it up here as the
357:46 - serialized field but in my case for
357:48 - design that I'm going for I'm perfectly
357:49 - content with having a fixed value so
357:51 - just appear pretty simple the spawn
357:53 - complete timer Max and let's define it
357:56 - to 4f
357:58 - and let's use it over here okay great so
358:01 - this is what we want
358:02 - however for spawning it's actually going
358:04 - to be a bit tricky the plate is supposed
358:07 - to be a kitchen object the player should
358:09 - be able to carry the plate and right now
358:12 - for design that we Define is that each
358:13 - kitchen object can only have one parent
358:15 - and each parent can only have one object
358:18 - but over here we want to spawn multiple
358:20 - objects now let's quickly see what
358:22 - happens if we try spawning multiple as
358:23 - usual so let's just go into the kitchen
358:25 - object spawn a kitchen object which
358:28 - means we need the plate so so let's do
358:30 - it up here as usual a serialized film
358:33 - private kitchen object so for the Plate
358:36 - Kitchen object SL
358:40 - so we're going to need to make this and
358:42 - then we're just going to spawn this
358:43 - object on this
358:46 - okay so this is going to throw an error
358:47 - but so let's see let's first create the
358:49 - object
358:50 - over here let's go inside our objects
358:53 - our kitchen objects let's create a brand
358:55 - new kitchen object call it just the
358:57 - plate for the object name this one is a
358:59 - plate for the Sprite let's go with the
359:02 - plate Sprite and for the prefab let's
359:04 - make it so let's duplicate one of these
359:06 - called the plate
359:09 - let's go inside it and obviously make
359:11 - sure to change say the changes then over
359:14 - here let's drag the plate visual get rid
359:16 - of the tomato and on the plate let's
359:19 - make sure to assign the plate and
359:21 - finally let's exit this let's make sure
359:23 - to save it and on the plate let's drag
359:25 - the plate prefab okay so we have the
359:28 - kitchen object so now let's just go
359:30 - inside our plates counter and over here
359:32 - let's drag the reference so the
359:35 - reference to the play kitchen object
359:36 - let's also drag the reference to the
359:38 - counter top point then on the selected
359:40 - drag the reference to our base counter
359:42 - and finally start off with a selected
359:44 - disabled okay so this should be working
359:46 - let's just add a plate counter over here
359:48 - onto our scene so let's pick up a police
359:50 - counter and put it somewhere in here
359:51 - over there on the side so on an X of 7.5
359:54 - then 0 and let's say on zero Maybe
359:58 - let's make sure we have space for one
360:00 - more counter over there so let's
360:02 - duplicate this empty counter and let's
360:04 - put it over there pointing to the side
360:05 - so this one is on 7.50 and -2
360:10 - okay so now let's just make sure that
360:11 - they perfectly match so let's put this
360:14 - one on a set of minus 0.5 okay so let's
360:17 - test all right so here we are and look
360:19 - at that and after four seconds if there
360:22 - go it spawns the object and then it
360:24 - immediately tried to spawn another one
360:25 - and there you go we have the error
360:27 - kitchen object parent only has a kitchen
360:29 - object basically the way we designed our
360:31 - game and set up the code assumes that a
360:33 - single encounter will only hold a single
360:35 - kitchen object so we cannot have
360:37 - multiple plates on the same counter now
360:40 - when solution for this problem is
360:41 - actually quite simple when we spawn the
360:43 - plates instead let's not spawn a kitchen
360:46 - object instead we're just going to spawn
360:48 - a dumb visual then when the player
360:50 - interacts with the counter that is when
360:52 - we're going to spawn the proper kitchen
360:53 - object so let's do that although again
360:56 - let's keep the logic and division
360:57 - separate so over here let's first just
361:00 - handle the logic so we just need to keep
361:02 - track of how many points respond so for
361:04 - that let's start up here you private end
361:06 - for the plates spawn amount and let's
361:09 - also do another private end for the
361:11 - plates Pawn amount Max
361:17 - and let's say we can spawn at most four
361:18 - plates
361:19 - okay so over here instead of spawning
361:21 - the object let's first of all actually
361:23 - reset the timer
361:25 - so let's put it back to zero zero and on
361:27 - the plate spawn the mount let's check if
361:30 - this one is under the plate spawn Max
361:34 - and if so
361:37 - let's go into the plate spawn amount and
361:39 - increase it by one okay so that's logic
361:41 - super simple now let's send the visual
361:43 - so let's first make our script so let's
361:46 - create a brand new c-sharp script for
361:48 - the plates counter visual
361:51 - now let's make sure that the visual so
361:53 - let's go inside the prefab and over here
361:56 - we've got the visual let's attach it
361:57 - okay open now here basically the first
361:59 - thing we need is we need to know where
362:01 - to spawn the visuals
362:02 - so let's actually add a reference to our
362:04 - counter top point
362:06 - so let's add a serialized film for
362:08 - private transform for the counter top
362:11 - point then let's also add a reference
362:13 - for the prefab we're going to spawn so
362:15 - let's call it the plate visual prefab
362:17 - then here in the editor let's drag the
362:19 - references so the countertop Point Place
362:21 - it in there and for the plate vision
362:23 - prefab let's go a pair and find the
362:26 - visuals for the kitchen object so these
362:28 - are just the visuals and let's write the
362:29 - plate visual so the plate visual not the
362:31 - Plate Kitchen object okay now back in
362:33 - the code here we obviously need to know
362:35 - when I play this Bond so let's go into
362:37 - the plates counter and make a nice event
362:39 - so fun week event event handler as usual
362:42 - on plate spawned
362:45 - and down here let's just find the event
362:47 - so we just invoke
362:51 - with this and eventar is not empty
362:55 - okay that's it very simple and then on
362:58 - the other script over here let's just
362:59 - listen to it which also means that we
363:01 - need a reference to our counter so let's
363:03 - add up here the plates counter for the
363:05 - plates counter so we're going to need to
363:07 - drag the reference and then on start
363:09 - let's listen to the on plate spawned
363:12 - event
363:12 - and when that happens then let's spawn
363:14 - so let's call instantiate on the plate
363:17 - visual prefab
363:19 - let's put it inside the counter top
363:21 - point so this is the transform for the
363:23 - plate visual transform and that's pretty
363:26 - much it okay so unlike this it should be
363:28 - working
363:29 - when the plate is spawned we should be
363:31 - spawning a brand new visual back in the
363:33 - editor we just need to drag the plates
363:34 - counter reference like that let's exit
363:37 - save the prefab and let's test okay so
363:39 - here we are and if we wait for four
363:41 - seconds we should be able to see a play
363:43 - spawn yep there you go and if we wait
363:45 - for a little bit more we should also be
363:47 - able to see some more play Swing spawn
363:49 - except we can't really see them that's
363:51 - because we're spawning them on the exact
363:52 - same spot every time but if we pause the
363:55 - game and over here I'm looking the
363:57 - hierarchy and find the plate counter and
363:59 - inside the counter top Point yep we do
364:01 - have four visions and if we wait for
364:03 - longer then nope it's not going to spawn
364:05 - anymore it's only going to spawn four
364:07 - plates okay great
364:08 - so some of the visual let yourself set
364:10 - them by a tiny bit to know how much we
364:13 - shouldn't offset let's keep track of how
364:14 - many plates haven't spawned
364:16 - so let's store up here on the visual
364:18 - script in list of Game object
364:21 - call it the plate visual game object
364:23 - list
364:25 - let's also make sure that you initialize
364:27 - this so it lets you on awake let's
364:29 - initialize this list
364:31 - and then when we spawn them okay so here
364:33 - we have the object that we spawned now
364:35 - basically we just need to modify the low
364:37 - composition
364:39 - and let's put it on new Vector 3 on the
364:41 - X so let's put it on zero then on the Z
364:43 - we're also going to have zero and then
364:45 - over here on the one let's offset it by
364:47 - a certain amount and basically it's
364:48 - going to be based on how many plates
364:50 - have been spawned
364:51 - so let's define up here a float for the
364:53 - plate offset y let's put it at save 0.1
364:56 - f
364:58 - and over here we're going to offset it
364:59 - by this much multiplied by how many
365:01 - plates have been spawned so we can go
365:03 - into our visual list account so you can
365:05 - delete this and then we just need to add
365:07 - it to the list so let's add this plate
365:09 - visual transform.game object okay so now
365:12 - each game object should respond at a
365:14 - different height so let's see so here we
365:16 - are and if we wait for four seconds we
365:18 - should be able to see a plate and there
365:20 - you go and now after four seconds we
365:22 - should be able to see another one placed
365:23 - slightly above and yep there it is okay
365:25 - great
365:26 - so everything is spawning perfectly both
365:29 - in the logic as well as the visual now
365:30 - let's actually pick up a plate so on the
365:33 - plates counter as usual let's implement
365:34 - the interact
365:35 - so let's do a public let's override the
365:38 - interact function
365:40 - and now for picking up let's first see
365:42 - if the player is actually empty-handed
365:45 - so if and we check the player has
365:48 - kitchen object so if the player does not
365:50 - have a kitchen object
365:52 - then the player is empty-handed okay
365:55 - great then let's see if we have a plate
365:58 - that we can give them so if the plate
366:00 - spawned the mount if it is bigger than
366:02 - zero
366:04 - then there's at least one plate here and
366:08 - if so let's give it to the player so how
366:10 - we do that is one over here for logic
366:12 - let's just increase it by one then let's
366:15 - actually spawn the object so on the
366:17 - kitchen object let's spawn the Plate
366:19 - Kitchen object so and spawn it on the
366:22 - player
366:23 - and finally we just need to update the
366:24 - visuals so let's make another event
366:27 - so up here on plane spawn and on plate
366:30 - removed
366:32 - okay we have this event and then down
366:34 - here on let's just whenever the player
366:36 - picks it up let's invoke this with this
366:38 - an event RX dot empty
366:41 - okay great so now the visual let's
366:43 - listen to this so we're here on start
366:45 - for the plates counter listen to this
366:47 - event
366:48 - and when this event happens we just want
366:50 - to destroy the very last plate
366:52 - so let's grab the game object for the
366:54 - played game object and recently just
366:56 - going to go into our list so the plate
366:59 - visual game object list
367:01 - and let's pick up the very last one
367:03 - so let's go into the list.count minus
367:05 - one so this is going to be the very last
367:07 - element of the list then let's remove
367:09 - this one from the list so Point dot
367:11 - remove this one that we just grabbed and
367:14 - then we simply call destroy on this one
367:17 - all right so that's it super simple
367:19 - so we're here on the plates counter we
367:21 - do all of our checks we cut it down by
367:23 - one
367:23 - we spawn the actual kitchen object then
367:25 - we fire the event and over here the
367:27 - event listens and updates a visual okay
367:29 - let's test
367:30 - so here we are let's wait for a play to
367:32 - be spawned and when this phone there it
367:34 - is I'm going to pick it up and if there
367:36 - go the player is now carrying a plate
367:37 - let's drop it here and there you go
367:39 - there's another one now let's wait for a
367:40 - bunch more to be spawned okay so the
367:42 - plates counter is full now if I pick up
367:43 - it should only eliminate the last visual
367:45 - pick it up any of there you go it'll
367:47 - eliminate that one now I can drop it in
367:49 - there any other ones one all right
367:51 - awesome okay so that's really it for the
367:54 - basics of the play counter it
367:56 - periodically spawns some points which
367:57 - the player can then pick up
367:59 - now in the next lecture we're going to
368:01 - add the ability for the player to be
368:02 - holding a plate and pick up another
368:04 - object onto the plate
368:06 - hello and welcome I'm your code monkey
368:08 - in this lecture we're going to add the
368:10 - ability for the player to be carrying a
368:12 - plate and pick up objects onto that
368:14 - plate okay so here we already have the
368:16 - plate counter working it has some basic
368:18 - logic after a bunch of time it spawns a
368:21 - plate it spawns up to a certain maximum
368:23 - and I can pick up a plate and if the
368:26 - player is carrying a plate so I can put
368:27 - it anywhere
368:28 - then I can for example pick up some
368:30 - Tomatoes slice them and pick them up
368:32 - however now I am not able to place the
368:34 - tomatoes on the plate so let's add that
368:36 - logic let's begin over here on the clear
368:39 - counter script first we're testing if
368:41 - there is no catch an object here and the
368:43 - player is carrying something that the
368:44 - player drops something in there but then
368:46 - we're testing if there is a kitchen
368:47 - object here and if the player is
368:48 - carrying something so it's over here
368:50 - that we want to check if there's
368:52 - something that the player is carrying if
368:53 - it is a plate now our plate is also
368:55 - going to have a bit of custom logic so
368:58 - to help both identify and hold that
369:00 - custom logic let's make a proper script
369:01 - to handle it
369:03 - so back in India let's create a brand
369:05 - new script currently the Plate Kitchen
369:07 - object
369:09 - and let's open this now over here on
369:11 - this one instead of extending Model
369:13 - Behavior we're going to extend kitchen
369:15 - object
369:16 - so the plate is really just a more
369:18 - specific type of a kitchen object
369:20 - again like I mentioned quite a while ago
369:22 - you want to be very careful with
369:23 - inheritance you need to have a very good
369:25 - reason to do it here we want the play to
369:28 - behave exactly like a kitchen object
369:29 - just with a tiny bit of extra logic so
369:32 - in this case it makes perfect sense
369:33 - let's just go ahead and save this and
369:36 - wait for ENT to compile and over here
369:38 - let's find our kitchen object with the
369:40 - plate so here it is the prefab as you
369:42 - can see we have a kitchen object now
369:44 - instead of having that one let's replace
369:45 - that with the play kitchen object and
369:48 - since we are extending kitchen object we
369:49 - have the same Fields so let's make sure
369:51 - to add the kitchen object as so and get
369:53 - rid of the other one okay great so now
369:56 - back here on the on your counter when
369:58 - there is a kitchen object here and the
369:59 - player is carrying something we can
370:01 - check if the player is holding a plate
370:03 - and for that we can check the type
370:05 - so if let's go into the player and let's
370:08 - get the kitchen object the player is
370:10 - holding and we test if this object is of
370:12 - type Plate Kitchen object
370:15 - if so then that means player is holding
370:17 - a plate and if that is the case then we
370:19 - basically want to give the player
370:21 - whatever object is over here we want to
370:23 - add it to the plate so let's go into the
370:25 - plate script to add that function so
370:27 - over here let's make a public Point
370:29 - let's call it add ingredient
370:35 - as a parameter we're going to receive a
370:37 - kitchen object as so we really only care
370:39 - about the type we're going to destroy
370:40 - the actual kitchen object like we've
370:42 - been doing when creating different types
370:43 - so the plate is really just going to
370:45 - store in list of types so here let's
370:47 - store a list of kitchen object a cell
370:50 - for the kitchen object that sell list
370:54 - then when we add the ingredient let's
370:56 - just add it to the list so this kitchen
370:58 - object is so let's also make sure to
370:59 - initialize the list so let's see what
371:01 - I'm awake let's initialize our list and
371:04 - now from the other side we just need to
371:06 - call this so over here on the clear
371:07 - counter if the player is holding a plate
371:09 - let's first get the type of plate so
371:11 - play kitchen object or the Plate Kitchen
371:13 - object we go into the player to get the
371:16 - kitchen object and we cast this as a
371:19 - plate kitchen object
371:21 - okay so we have this and then over here
371:22 - let's call add ingredient
371:24 - and let's add whatever is currently on
371:26 - this counter so let's get the kitchen
371:28 - object and get the kitchen object itself
371:30 - okay so we're adding it to the plate and
371:32 - then let's destroy what is here so get
371:34 - kitchen object and destroy itself
371:37 - okay so that's it so if there is
371:38 - something here and if the player is
371:40 - holding something and that's something
371:41 - the player is holding as a plate if so
371:43 - we're going to add that ingredient to
371:44 - the plate and then destroy the object in
371:46 - here so let's test okay so here let's
371:48 - pick up a tomato let's slice it let's
371:51 - put it on a clear kitchen counter
371:52 - because that's the only one where we
371:53 - added logic so on this one let's pick up
371:56 - a plate and now whilst I'm carrying the
371:58 - plate and if I approach and I interact
372:00 - with it and if there you go it does work
372:01 - the object vanished from the counter and
372:03 - supposedly was added to the plate again
372:05 - we can use a really nice debug inspector
372:07 - to see it so let's pause the game Let's
372:09 - select the plate let's see the play
372:12 - kitchen object so here it is this one
372:13 - and let's change the inspector into
372:16 - debug mode and down here yep we do see
372:19 - the kitchen object that's on list and it
372:20 - does have some tomato slices okay
372:22 - awesome so with this here we have our
372:24 - basics
372:25 - we can have some ingredients and we can
372:27 - basically pick it up from a plate now
372:29 - one thing about our plate this is where
372:31 - we're basically going to carry the final
372:33 - recipe that we're going to deliver to
372:34 - the customers and based on the design
372:36 - that I defined I want something pretty
372:38 - simple meaning for the design that I'm
372:40 - going for there won't be any kind of
372:41 - double burgers or double cheese so each
372:44 - final recipe will only have at most one
372:46 - of each ingredient
372:48 - so let's add some basic logic just to
372:50 - prevent adding duplicates over here on
372:52 - the Plate Kitchen object when we add an
372:54 - ingredient
372:55 - since the function will now not
372:57 - necessarily succeed every time let's
372:59 - actually rename this and again use a
373:01 - very useful Visual Studio shortcut so
373:03 - you can press Ctrl RR or right click and
373:05 - let's rename
373:06 - since this function will no longer
373:08 - succeed we're just going to try to add
373:10 - an ingredient so try add ingredient and
373:12 - then let's also make it return a buoying
373:14 - basically for any function where you're
373:16 - not sure if it won't succeed I like to
373:18 - add try and make it return ball so this
373:20 - way it works pretty much exactly like
373:21 - the try again component that we've
373:23 - already seen so many times so it tries
373:25 - to do something and returns whether it
373:27 - succeeds or not so over here instead of
373:29 - always adding the ingredient let's see
373:31 - if this one is a duplicate so let's do
373:33 - an if and let's go into the list and
373:35 - check if the contains and if the list
373:37 - summary contains this kitchen object as
373:39 - well
373:40 - if though then already has this type so
373:43 - let's return false and if not
373:46 - then that means it's a brand new
373:48 - ingredient
373:49 - so let's add it and return true okay so
373:52 - that's it now let's go over here onto
373:54 - the clear counter so we try to add the
373:56 - ingredient but then we only want to
373:58 - destroy if this one succeeds so let's
374:00 - put this one inside an if so if we do
374:02 - manage to add the ingredients
374:04 - then yes let's destroy itself if not
374:06 - then we don't destroy anything okay so
374:09 - let's test
374:10 - so let's go ahead and slice two tomatoes
374:12 - so one slice it put it here then another
374:14 - one slice it and put it here now let's
374:17 - pick up a plate go up here try to pick
374:19 - up this one and yep it does work now for
374:21 - this one and I hope it doesn't work okay
374:23 - great now one more thing in our logic we
374:25 - only want to pick up certain things like
374:28 - I said only things that won't be used in
374:29 - the final recipe
374:31 - for example no customer is ever going to
374:33 - request a full entire tomato the recipes
374:35 - only have sliced tomatoes so we should
374:37 - not be able to drop a foam tomato
374:39 - directly on top of a plate so let's
374:41 - change that so over here on the plate
374:43 - script let's basically just create a
374:44 - list of our valid ingredients
374:47 - so let's make a serialized film private
374:50 - make it a list of kitchen object SL
374:53 - ope and call it the valid kitchen object
374:55 - SL list okay so we have this list and
374:58 - over here in the editor let's just write
375:00 - the ones that we want so let's first of
375:01 - all select the plate object okay here is
375:04 - the flight prefab and over here we've
375:06 - got all of our kitchen objects so let's
375:08 - just write the ones that we want to add
375:10 - to the point
375:11 - so the final recipes will have some
375:13 - bread yep but they will not have entire
375:15 - cabbages they will only have cabbage
375:16 - slices same thing no cheese only slices
375:19 - for the meat we're only going to be able
375:22 - to add meat cooked but also meat burned
375:24 - then we're not going to be able to add a
375:27 - plate onto a plate of course not and
375:28 - finally inside of a tomato just tomato
375:30 - slices okay that's our Vellum list and
375:33 - over here again it's very simple
375:34 - so we can just go if the evaluate
375:36 - kitchen object that's on list if this
375:39 - one contains the one that we want to add
375:41 - then we can add it but if not then let's
375:44 - return phones
375:45 - not a valid ingredient
375:48 - okay so let's test alright so let's pick
375:51 - up a tomato and also some tomato slices
375:53 - and now if I pick up a plate and I go
375:55 - into the Tomato nope doesn't work but
375:57 - the slices yep it does work okay great
375:59 - so here we have all of our basic plate
376:01 - rooms everything is working perfectly
376:03 - but it's only working over here with the
376:05 - clear counter so let's do a little bit
376:07 - of code cleanup and then let's add this
376:09 - logic to all the other counters so first
376:11 - to clean up this cone over here we are
376:13 - testing if this is a plain kitchen
376:15 - object then we cast to an object and
376:17 - then we count the function so let's
376:19 - simplify all this
376:20 - and let's do it just like yinty does
376:22 - with their try and get the component
376:23 - function so let's make a custom function
376:26 - that takes an output parameter the best
376:28 - place to put it is on the kitchen object
376:30 - so here we've got the kitchen object
376:32 - script okay great let's scroll down and
376:34 - make a nice function here so let's make
376:37 - it public we're going to return Boolean
376:39 - in case this succeeds or not let's
376:40 - currently try get plate and over here
376:43 - let's make an out parameter so don't
376:45 - forget the out keyword let's return of
376:47 - type Plate Kitchen object for the play
376:50 - kitchen object then over here we do
376:52 - examine what we did so we test if this
376:54 - object is a plate kitchen object
376:57 - if so then let's set the play kitchen
376:59 - object equals this as a play kitchen
377:01 - object and we return true but if not
377:04 - then this is not a plate so let's return
377:06 - false and one thing when working with
377:09 - output parameters you always need to
377:10 - make sure to set the output before you
377:13 - exit the function
377:14 - so over here that's the error that it's
377:16 - telling us
377:17 - we must assign it to something when we
377:19 - return so over here we don't have a play
377:21 - kitchen object so to solve this we just
377:23 - set this to no okay great now over here
377:26 - on the clear counter instead of doing
377:27 - all this basically let's ask the player
377:30 - if this is a kitchen object
377:32 - so let's try to get the plate
377:35 - out Plate Kitchen object for the Plate
377:38 - Kitchen object
377:40 - so you try to get it then we try to add
377:41 - the ingredient and so on now obviously
377:43 - we could further simplify things by
377:45 - making a function that would try to get
377:46 - the plate and try to add the ingredient
377:48 - that could work but since some counters
377:50 - are going to have a bit more custom
377:51 - logic I think keeping them separate like
377:53 - this makes more sense so first we try to
377:55 - get the plate then we try to add the
377:57 - ingredients so let's apply the same
377:59 - logic to The Cutting counter
378:01 - so over here on the cutting counter
378:03 - let's scroll down to where there is a
378:05 - kitchen object here and the point is
378:06 - carrying something so on the earlier
378:08 - counter we just want to copy all of this
378:10 - so let's go over here and we do the
378:12 - exact same thing okay that's it and the
378:14 - other counter from where we can pick up
378:16 - things is from the stove counter
378:19 - so here we are on the stove let's scroll
378:21 - down until we find the interaction okay
378:23 - there's something here The Player's
378:24 - carrying something so it's over here
378:25 - let's do that and do the exact same
378:27 - thing except on the stove again let's
378:29 - remember that this is using a save
378:30 - machine so when we pick up something
378:32 - let's do pretty much the same thing that
378:33 - we did here so let's make sure to reset
378:36 - the State Fire the events and so on okay
378:39 - so those are the only counters that we
378:40 - need to implement we cannot drop things
378:42 - on top of a container we cannot drop
378:44 - things on top of the plate counter or
378:46 - the trash so these are the only three
378:48 - types that we need to implement so with
378:49 - this let's test okay so let's begin with
378:52 - some meat so let's pick up some meat put
378:53 - it on the stove let's pick up a plate
378:55 - wait for it to cook pick it up any up
378:57 - there you go it does work now it says
378:59 - the cut encounters and let's pick up
379:00 - some cheese and let's slice it pick up
379:02 - some plate and go any up there you go it
379:04 - does work and again if we inspect we can
379:07 - make sure that it is indeed working so
379:08 - let's get into the plate and let's put
379:10 - this on debug inspector and if there we
379:12 - do see this one has a meat Patty cooked
379:14 - and some cheese slices okay great now
379:17 - the last piece of logic that we need is
379:19 - pretty much the opposite so right now it
379:21 - works if there's a sliced object on the
379:23 - plate and the player is holding a plate
379:24 - object but now we want the opposite so
379:27 - let's say there's a plate in here and we
379:29 - slice some cheese and now I want to drop
379:31 - the cheese on the plate so let's do that
379:33 - and basically for this one this one is
379:35 - only going to happen on the clear
379:36 - counter that's the only counter type
379:38 - that can have a plate on top of it so
379:40 - over here on the clear counter then we
379:43 - check if there is no object there but
379:44 - that's not what we want we want if
379:46 - there's a plate on the counter so if
379:47 - there is an object there and if the
379:49 - player is carrying something
379:50 - then we check if the player is holding a
379:52 - plate but if not so if the player is not
379:55 - holding a plate
379:56 - so player is not carrying plate but
380:00 - something else over here we need pretty
380:02 - much exact same logic except just
380:04 - testing for the object on this counter
380:05 - so let's do if let's get the kitchen
380:07 - object on this counter this one try to
380:10 - get the plate so out play kitchen
380:12 - objects for the Plate Kitchen object so
380:15 - if so if so there's a plate over here
380:19 - that means the counter is holding a
380:21 - plate
380:23 - so then let's go into this play kitchen
380:25 - object let's add the ingredient
380:27 - and we're going to try to add whatever
380:29 - the player is currently carrying so the
380:31 - player dot get kitchen object
380:34 - and get the kitchen object as so
380:39 - so we're going to try to add this
380:42 - and if we can add then we're just going
380:44 - to destroy whatever is on the player
380:47 - okay that's it and over here we've got a
380:49 - nice error just because we've defined it
380:51 - with the same name appear so up here
380:53 - we're already defining the variable and
380:55 - over here we're defining the same
380:56 - variable with the same name
380:58 - so we can either give this a different
381:00 - name or just not Define a brand new
381:01 - variable here so just it's a fine up
381:03 - here and we're using it here okay so
381:05 - while logic is working now here make
381:07 - very sure that you're not mixing
381:08 - references keep in mind when you're
381:10 - referencing the kitchen object on this
381:12 - counter and the one on the player those
381:14 - are two different things so over here if
381:16 - the player is not carrying a plate but
381:17 - something else then you check the
381:19 - kitchen counter so over here you're not
381:21 - checking the player but checking the
381:22 - counter then you go into that point and
381:24 - try to add the ingredient and you try to
381:26 - add the one that the player is carrying
381:27 - and then you destroy the one the player
381:29 - is carrying so again be very careful
381:31 - here make sure you don't mix references
381:33 - so with this it should work so let's
381:35 - make sure to save our script and let's
381:36 - test okay so here we are let's first
381:39 - pick up a nice plate let's drop the
381:41 - plate in there pick up some bread drop
381:42 - the bread any of there you go it does
381:44 - work alright so now we can do a bit more
381:46 - natural interactions so for example
381:48 - let's pick up some meat and put it on
381:49 - cooking and there you go the meat is
381:52 - fried so now I'm currently carrying just
381:53 - some meat so I place it there then I
381:55 - pick up some bread and put some bread on
381:56 - top of the meat and yep everything does
381:58 - work policy okay so here we created the
382:00 - plate and we created some custom logic
382:02 - to Define what the plate can and cannot
382:04 - account no that's left is actually being
382:07 - able to see what is on the plane so
382:08 - let's do that in the next lecture
382:11 - hello and welcome I'm your code monkey
382:13 - in this lecture we're going to add a
382:15 - nice visual to our plate okay so right
382:17 - now we can already pick up ingredients
382:19 - under the plate so if I pick up the
382:20 - plate and I pick up some cheese there
382:22 - you go there's some cheese on the plate
382:23 - but we cannot see it so let's solve that
382:25 - and we were going to do that it's
382:27 - actually in a very simple way
382:29 - if you look in the included assets
382:31 - inside the prefab visuals there's this
382:33 - nice plate complete visual that I built
382:35 - basically it's a foam burger that
382:37 - contains all the ingredients what we're
382:39 - going to do is actually very simple
382:40 - we're just going to enable or disable
382:42 - these game objects that's it so let's do
382:44 - example that let's make a new c-sharp
382:47 - script quality plate complete visual
382:50 - let's attach a script over here and
382:53 - let's also make sure to put this one
382:54 - inside the plate so let's save this
382:57 - prefab let's go inside the play prefab
382:59 - so inside the prefabs here the kitchen
383:02 - objects we've got the plate so inside of
383:04 - the point let's drag that let's drag the
383:06 - plate complete visual okay great so now
383:08 - let's open up this script over here on
383:11 - let's first have the reference to our
383:12 - Plate Kitchen object
383:14 - film private for the Plate Kitchen
383:17 - object for the Plate Kitchen object
383:19 - back in the editor let's drag the
383:21 - reference okay great so now here
383:23 - basically we need to update this visual
383:24 - whenever the plate gets any ingredient
383:26 - added to it
383:28 - so let's go over here into the point
383:29 - script and basically just need to fire
383:30 - off an event when that happens
383:32 - so let's make a public event event
383:35 - handler and let's call it on ingredient
383:37 - added
383:41 - okay and for this one let's also make an
383:42 - event RX to contain the data of what
383:45 - object we added so let's make a public
383:47 - class on ingredient added event args
383:51 - let's extend event args and inside let's
383:55 - make just a kitchen object a cell
383:57 - kitchen object as well
384:00 - okay great and let's make the event of
384:02 - this time
384:04 - all right so now let's just fire off
384:05 - this event so down here when we try to
384:07 - add an ingredient if we do add the
384:09 - ingredient let's fire off this event so
384:11 - let's invoke with this and let's create
384:14 - a brand new one passing the kitchen
384:15 - object as so as this kitchen I'll take
384:17 - this off okay so we have our event
384:19 - correctly being sent now we're here on
384:22 - the play complete visual let's listen to
384:23 - it again as always let's make sure to do
384:25 - it only on start so the play kitchen
384:27 - object on ingredient added let's listen
384:29 - to this event and over here we just need
384:32 - to either enable or disable the visuals
384:34 - that relate to the kitchen object inside
384:36 - over here the event arcs however of
384:38 - course the question is how exactly do we
384:40 - find them the point complete visual has
384:42 - all these game objects how do we know
384:44 - which one belongs to that kitchen object
384:46 - now technically one way would be to do a
384:49 - simple transform find and find the
384:51 - channel objects by name technically that
384:53 - would work but like I mentioned in the
384:55 - beginning of the course strings are a
384:57 - horrible way to identify things they are
384:58 - very air prone so let's not do that
385:01 - instead let's use a proper approach
385:03 - where we can Define some kind of link
385:05 - between a kitchen object a so and a game
385:07 - object and we can do this very easily by
385:09 - justifying a struct so here in our
385:12 - script let's do exactly that let's
385:14 - define a public
385:16 - make it a struct
385:18 - and name it kitchen object so underscore
385:21 - game object
385:25 - then inside it's very simple we just
385:27 - have a kitchen object so field
385:31 - and then also a game object field
385:37 - that's it super simple by the way if you
385:40 - don't know what is a struct basically
385:41 - it's very similar to a class except it's
385:44 - stored in different places in memory and
385:46 - behaves somewhat differently
385:48 - I have a very very important video on
385:50 - that subject what is the difference
385:51 - between value types and reference types
385:53 - classes are reference types so when you
385:56 - pass in a class into a parameter you are
385:57 - passing in a reference to that object
385:59 - whereas struts are value types so when
386:02 - you pass in a struct onto a parameter
386:03 - you are passing in a copy it's a bit of
386:06 - a tricky thing so definitely make sure
386:08 - you go watch that video for more details
386:09 - so you don't get confused in the future
386:11 - here I Define that as a struct simply as
386:13 - kind of a teaching moment but also
386:15 - because it just makes sense that if I
386:16 - just want to store some data without any
386:18 - logic then it should probably be a
386:20 - struct and not a class although in this
386:22 - case the class would work just as well
386:24 - anyway so here we have a struct inside
386:26 - the struct we have a field of type
386:28 - kitchen object so another one of type
386:30 - game object so now let's just make a
386:32 - list of this type that we can expose in
386:33 - the editor so here a serialized film
386:36 - private let's make it a list of kitchen
386:38 - objects so game object and call it
386:41 - kitchen object so game object list
386:44 - okay that's it super simple so let's
386:46 - save and make sure this compounds so
386:48 - actually let's just comment this out
386:49 - just make sure our code compounds okay
386:51 - and over here in the editor we see the
386:53 - tricky thing when it comes to using
386:55 - fields of custom types if we look in the
386:57 - inspector no we don't see anything so we
386:59 - cannot see our custom type in the
387:01 - inspector if you make a custom time like
387:03 - this front and you want to show it in
387:05 - the inspector then you need to add the
387:07 - attribute serializable which exists
387:09 - inside system so let's go up here using
387:12 - system
387:15 - and let's say the attribute serializable
387:17 - just like this okay so do this save and
387:20 - let's look and if there you go now we do
387:23 - see our custom struct so we've got a
387:25 - list then we can click on the pause icon
387:26 - and there you go we've got an element
387:27 - and it does have a film for a kitchen
387:29 - object so and one for a game object so
387:32 - that's great with this now we have a
387:34 - really nice place where we can link one
387:35 - object to another so let's just do
387:37 - exactly that so for example let's put
387:39 - the bread over there and let's assign
387:41 - the kitchen object as so for the one
387:42 - with bread let's do the same thing for
387:44 - all of the others so let's add a whole
387:47 - bunch more Okay so we've got the bread
387:49 - then we're going to have the meat Patty
387:51 - cooked then the tomato slices then we
387:54 - have the cheese slices the Cabbage
387:56 - sliced and finally the meat Patty burned
387:58 - so I've got number zero through five so
388:00 - you have six elements and over here yep
388:02 - we do got six so we have all of them we
388:04 - can get rid of these last two okay great
388:06 - and now let's assign the proper objects
388:08 - so this one for the meat Patty cooked
388:10 - then we've got the tomato slices then we
388:13 - have the cheese slices then the Cabbage
388:17 - slices and finally the meat Patty burned
388:19 - okay great so all of the references
388:21 - match now back in the code here so we
388:24 - have this List fully filmed out and when
388:26 - we have this really very simple we just
388:29 - cycle through the list to find the right
388:30 - game object it's similar to a 40 inch of
388:33 - type kitchen object so game object
388:36 - in our kitchen object so game object
388:38 - list and we check if this kitchen object
388:41 - is so dot kitchen object matches the one
388:43 - that we received in the event
388:45 - if they do match then go into this one
388:47 - grab the game object and set active into
388:49 - true
388:51 - okay so that's it some very simple logic
388:53 - and also we can start with them disable
388:55 - them by default in the editor or just
388:58 - over here just use something very simple
388:59 - just do a for each second through every
389:02 - single one of them and set every single
389:04 - one of them to false so that they are
389:07 - hidden okay so with this on the
389:09 - ingredients on the plate should be
389:10 - visible so here in the editor let's just
389:12 - make sure all the references have been
389:14 - set let's go back save the prefab and
389:16 - let's set on play okay so here we are
389:18 - and by default like that an empty plate
389:20 - and yep it is empty and now let's slice
389:22 - some cheese now let's Place some cheese
389:24 - on there and there you go we've got some
389:25 - cheese now let's pick up some bread drop
389:28 - some bread and there you go got some
389:29 - cheese and some bread
389:31 - then let's cook some meat so let's cook
389:34 - it and let's pick it up with a plate and
389:36 - as soon as I go boom there you go I've
389:37 - got a nice cheese butter
389:39 - all right awesome so wait a second I'll
389:41 - do a complete Burger so let's finish it
389:43 - let's just add some more tomatoes so
389:45 - slice them and add the tomatoes and
389:48 - finally some sliced cabbages slice them
389:50 - put them there and there you go here we
389:52 - have a fully complete Burger okay so
389:54 - that's great all of our vision logic is
389:56 - indeed working however this visual is a
389:59 - bit hard to see it's not very clear to
390:00 - the player so just looking at it from
390:03 - this distance does that have a tomato or
390:05 - not
390:06 - there's a tiny sliver of red in there
390:08 - but you can't really see it
390:10 - so we should probably add some nice
390:11 - clear icons on top to clearly indicate
390:14 - what exactly is on this plate so that's
390:16 - exactly what we're going to do in the
390:18 - next lecture
390:19 - hello and welcome I'm your code monkey
390:21 - in this lecture we're going to add some
390:24 - really nice icons on top of our plate so
390:25 - we can easily see what is on there okay
390:28 - so for the icons let's do the exact same
390:30 - thing that we did for the progress bar
390:31 - meaning let's use a warm space canvas so
390:34 - let's go inside our play kitchen after
390:36 - prefab and over here on let's right
390:38 - click let's create a brand new canvas
390:40 - let's name this the plate icons UI then
390:44 - for the settings let's make it World
390:46 - space put it on zero zero everything
390:48 - width and height also on zero then let's
390:51 - lift it up a little bit so put it on a y
390:53 - of one okay like that now inside let's
390:56 - define an icon
390:57 - so let's start by making an empty game
390:59 - object call this just the icon template
391:03 - let's put it with a size of 0.3.3 it's
391:06 - okay something like that then inside
391:08 - let's add a new UI image name this the
391:11 - background
391:12 - and make it stretch to film The
391:14 - appearance so put 0 on everything okay
391:17 - there's our background
391:18 - for the background image instead of a
391:20 - square and let's actually go with a
391:22 - circle for that Unity actually has a
391:24 - bunch of built-in Sprites that are
391:26 - tatted in the last versions however it's
391:28 - not actually over here by default
391:30 - in order to see those default Sprites we
391:32 - need to install the 2D Sprite package so
391:34 - let's quickly just go into window
391:36 - package manager let's make sure we are
391:38 - in the UNT registry make sure we aren't
391:40 - looking at all and over here let's find
391:42 - the 2D Sprite package okay so let's
391:44 - install this
391:45 - okay there's the package so now if we go
391:48 - into the background and we search for a
391:49 - Sprite and over here make sure you click
391:52 - to actually show the assets from the
391:54 - packages and now we see a bunch of
391:56 - default hexagons a bunch of isometric
391:58 - tiles the square so on and if we search
392:01 - for Circle yep here we've got a bunch of
392:03 - circle so let's use this one over here
392:05 - on this path so let's use it there you
392:07 - go we have a nice circle now let's
392:09 - duplicate this image and for the second
392:11 - one let's name it icon
392:13 - then for this one let's assign just a
392:15 - random Sprite so let's say the bread
392:17 - and again remember how the Sorting order
392:19 - on the UI this one is based on the
392:20 - ordering the hierarchy
392:22 - so make sure that the icon is underneath
392:25 - the background the hierarchy that way it
392:26 - shows up on top okay so we have our icon
392:29 - template that's great of course we're
392:31 - going to dynamically generate all of
392:33 - this through code we're going to have
392:34 - multiple icons and for positioning them
392:36 - Unity actually has some really useful
392:38 - components let's select the plate icons
392:41 - UI and over here now let's add a
392:42 - component now for example a built-in
392:45 - component is the grid layout group this
392:47 - basically helps you position all the
392:49 - charm objects so let's put the size of
392:51 - the canvas over here on 0.9.9 okay so
392:54 - there you go a nice Square window then
392:56 - over here on the settings for this for
392:58 - the cell size let's put it at 0.3.3 and
393:01 - if there you go already shows up over
393:02 - there on the corner
393:03 - and we can see what it will look like if
393:05 - we just duplicate this object so let's
393:07 - make a bunch more templates and if there
393:09 - you go that's what it looks like so as
393:11 - you can see this component is super
393:12 - useful for automatically positioning all
393:14 - of the challenge objects now if we want
393:16 - we can play around all of these we can
393:17 - add a little bit of spacing on the XR on
393:19 - the Y but let's actually leave both
393:21 - those with zero let's leave everything
393:23 - on defaults just over here on the
393:25 - channel alignment let's put it on middle
393:26 - Center okay so there you go that looks
393:29 - pretty nice so you can see how this
393:31 - built-in component is super useful
393:32 - there's actually two more so this one
393:34 - for the grid layout this is great when
393:36 - you want to put things horizontally and
393:38 - vertically
393:39 - but if you just want horizontally then
393:41 - there is the horizontal layout group and
393:43 - if you just want vertically there's the
393:45 - vertical layout group so all of these
393:47 - components are really awesome really
393:48 - useful okay so with this our objects are
393:51 - placed and note how I named this an icon
393:53 - template basically a template is just
393:56 - what I call something that is kind of
393:58 - like a prefab but not really a prefab
393:59 - through code we're going to duplicate
394:02 - this template and dynamically modify the
394:04 - icon so we're going to use it very much
394:06 - like a prefab
394:07 - we could actually make this into a
394:09 - proper prefab so I could just drag it
394:11 - over here onto the project files and
394:12 - make a regular prefab that could work
394:14 - and the only reason why I prefer this
394:17 - method of not using a prefab
394:19 - he's just because this object this
394:21 - template stays here on the object as
394:23 - opposed to cluttering over here your
394:24 - project files if you have tons of
394:26 - single-use UI elements with tons of
394:28 - objects you need to spawn you can end up
394:30 - with tons and tons of prefabs and you
394:32 - might not even know where each of those
394:33 - is used whereas with this method the
394:35 - template says exactly where it's used
394:37 - and does not take an asset slot over
394:39 - here on the project files so personally
394:41 - this is just approach that I prefer for
394:43 - spawning UI elements but like I said
394:45 - prefabs work as well so if you prefer
394:47 - using prefabs go ahead and make it okay
394:49 - so let's make our script to run the
394:51 - plate icons UI so let's go into our
394:54 - scripts and on the scripts folder let's
394:56 - create a brand new c-sharp script for
394:58 - the plate icons UI over here let's
395:00 - attach a script and open it okay so now
395:02 - the first thing we need is a reference
395:04 - to our plate
395:06 - so let's begin by making a serialized
395:07 - film private for the played kitchen
395:09 - object for our play kitchen object
395:13 - okay let's save it and drag the
395:14 - reference so over here there's the point
395:16 - icons let's just drag the plate
395:18 - reference okay great now on the plate we
395:20 - already made this event when an
395:22 - ingredient is added so basically we just
395:24 - need to listen to this in order to add
395:25 - the new icon so over here on the UI
395:28 - let's do as usual private void start and
395:30 - on start let's go into the Plate Kitchen
395:31 - object and listen to that event
395:34 - and when that happens let's spawn an
395:36 - icon although here let's actually use a
395:38 - different method from the one we used on
395:39 - the plaint visual over here on the plate
395:42 - visual whenever we had the event we
395:44 - really just modified the object that was
395:46 - added so over here the equivalent would
395:48 - be to spawn a new icon whenever that one
395:50 - was added but instead of doing that
395:52 - right now let's listen to this event and
395:54 - when this happens let's update all the
395:56 - icons in this display basically this
395:58 - other method is useful when the contents
396:00 - can be added as well as removed now in
396:02 - this case they are never going to be
396:03 - removed so in this case both methods
396:05 - were fine but still I want to show you
396:07 - the second method just so you can use it
396:08 - when you need it so for that method we
396:10 - just need to know exactly what is on the
396:12 - plate so over here on the Plate Kitchen
396:14 - object we just need to expose the
396:16 - kitchen object as some list so let's do
396:18 - example that so fun week we're going to
396:19 - return a list of kitchen object SL
396:23 - let's go and look get the kitchen object
396:24 - the sewn list and we just return the
396:27 - kitchen object that's always okay very
396:29 - soon then over here on the planet icons
396:31 - UI let's just make a function to update
396:33 - the visuals so private Droid let's call
396:35 - it update visual
396:38 - and when we have the event let's call
396:41 - our update visual okay
396:43 - so now here let's basically just cycle
396:46 - through all the ingredients so let's do
396:48 - a 40 inch kitchen object so in the plate
396:52 - and get the kitchen object the sewn list
396:54 - okay so we're cycling through all the
396:57 - ingredients on the plate and then we
396:59 - want to duplicate our template so that
397:01 - means we need a reference up here so
397:02 - let's add a serialized film private type
397:04 - transform complete the icon template
397:07 - okay and let's save the code
397:09 - and over here in the editor let's drag
397:11 - the reference so let's drag the icon
397:13 - template by the way I'll have the others
397:14 - over here that's not a problem since
397:16 - these are going to be destroyed those
397:17 - we're going to see in a little bit the
397:19 - only one that matters is the first one
397:20 - okay so here we have the icon template
397:23 - so to spawn it we do it just like we do
397:25 - with any preform so we just call
397:27 - instantiate pass in the icon template
397:30 - and then transform parents so let's put
397:32 - it as a child of this object this part
397:34 - is important we need to make sure the
397:37 - object is spawned as a child of this
397:38 - object if over here you put something
397:40 - like no then the template won't be
397:42 - spawned as a mobile object so it won't
397:44 - be somewhere in the world so in order to
397:46 - make it positioned properly let's make
397:48 - sure to use transform to become a child
397:49 - of this object okay and then since we're
397:52 - using the other script the green layout
397:55 - group this is already going to be
397:56 - automatically positioned so just like
397:58 - this it should be spawning the icon and
398:01 - with the icon spawned all that's left is
398:03 - really just setting the image and now
398:04 - again the quick and dirty approach would
398:06 - be over here when we spawn let's say we
398:08 - pick up the item transform
398:11 - and over here we could go inside and do
398:13 - a find in order to find the image in
398:16 - order to get the component of Type image
398:18 - and so on so that is one approach that
398:20 - would be the quick and dairy approach
398:22 - but again we want to do things properly
398:24 - so let's do it the proper way instead so
398:26 - instead of this
398:27 - let's make a proper script that we're
398:29 - going to run on the icon template so
398:31 - let's create a new script so a new
398:33 - c-sharp script come with the plate icon
398:35 - single UI so this one represents just a
398:38 - single icon let's go ahead and attach it
398:41 - to the template so over here let's drag
398:43 - it and now when using this template
398:45 - method really the only one we need to
398:47 - worry about is this one the other
398:49 - duplicates we can just leave them they
398:51 - don't really matter but don't just
398:52 - avoiding confusion I'm actually going to
398:54 - delete them it's okay we just have one
398:56 - icon template okay and it has our script
398:58 - okay let's open now over here let's
399:00 - basically just make a function to set a
399:02 - kitchen object or so so public void
399:04 - let's go on set kitchen object so
399:10 - we receive parameter of type kitchen
399:12 - object that so okay great so then we
399:14 - need to set the image so let's just go
399:17 - into a serialized film private of Type
399:19 - image which is inside the unity
399:21 - engine.ui
399:22 - so for this one for the image we have a
399:24 - reference and then we set the
399:26 - image.sprite go into the kitchen object
399:28 - and grab the Sprites
399:30 - okay so we need to do is drag this
399:32 - reference so over here in our template
399:34 - let's drag the icon image okay great so
399:37 - now back here on the plate icon Ty so we
399:39 - spawn it that's great then let's we get
399:41 - component in order to get our script
399:44 - so the plate icon signal UI okay and
399:47 - then we just call set kitchen object so
399:49 - and pass in this okay that's great this
399:52 - is much better now again you might be
399:55 - thinking that this method is a lot more
399:56 - verbose than just setting the image
399:58 - Sprite here we had to create another
400:00 - completely new script we had to write
400:02 - this logic and over here get it and use
400:04 - it the quick and dirty approach would
400:06 - indeed be quicker but remember that
400:08 - while the equationary approach might be
400:10 - faster at first it will mess you up over
400:12 - time so just take a few extra seconds to
400:14 - do things properly this approach is much
400:16 - more scalable let's say for example on
400:19 - this function you want to change not
400:20 - just Sprite but also trigger some kind
400:22 - of Spawn effect or animation with this
400:24 - it's very simple we've got this function
400:26 - right here we receive the kitchen object
400:27 - of so and we can do whatever we want
400:29 - with it so like this we have this grip
400:31 - that is responsible for anything related
400:33 - to the single template and if you've got
400:36 - the general one which just spawns him
400:38 - and just gives them the kitchen object
400:39 - so so all of our logic is nicely
400:41 - separate okay so just like this it
400:44 - should already work however like this
400:46 - you might already be thinking want to
400:47 - spawn way too many icons and yep it will
400:50 - basically every time we add an
400:51 - ingredient we're updating the visual
400:53 - where we're cycling through every single
400:54 - one and spawning all of them so with
400:57 - this we're constantly going to spawn
400:58 - more and more items this is not what we
401:00 - want over here on the update visual we
401:02 - do want to update and spawn all of the
401:04 - icons but before we do that we actually
401:06 - need to clean it up we need to clean up
401:08 - the icons from the previous event
401:10 - so before we do that let's just cycle
401:12 - through all the children on this
401:13 - transform so that's pretty simple you
401:15 - can just do a for each transformed child
401:17 - in the transform
401:19 - so this way Cycles through all the
401:22 - children and then just call destroy on
401:24 - this channel that game object so that
401:27 - won't work that won't destroy all of the
401:28 - previous children however of course we
401:30 - also have one issue the icon template
401:33 - itself is also a child
401:35 - so if we do this we're going to destroy
401:37 - the icon template which then over here
401:38 - we're going to have an error because
401:40 - we're going to instantiate no so we want
401:42 - to destroy all the children except for
401:44 - the template so over here that's pretty
401:46 - simple we just check if the child equals
401:49 - the icon template if so then let's just
401:51 - skip it so we can just call continue and
401:53 - there you go it skips
401:55 - okay great so just one more final thing
401:59 - if we leave the template like this
402:01 - meaning the game object is enabled like
402:03 - this the template will always be visible
402:05 - plus whatever ingredients we have we
402:07 - don't really want the template to be
402:09 - visible this is just meant to be a
402:11 - template that we can instantiate so
402:13 - that's pretty simple to fix let's make a
402:15 - private void awake and on a week let's
402:17 - grab the icon template grab the game
402:19 - object set active into false okay so now
402:22 - the icon template won't be disabled so
402:24 - it won't be visible and then over here
402:26 - when we are instantiating the
402:27 - instantiated ones will also be disabled
402:29 - so let's make sure we go in there and
402:32 - enable these all right that should do it
402:34 - so all of our logic should be working
402:36 - there's only one more tiny thing we need
402:38 - to take care of this one is a world
402:40 - canvas so like we saw with the progress
402:42 - bar we need extra logic to make it look
402:45 - towards the camera and thankfully we
402:47 - already wrote an excellent generic
402:48 - script to do just that so let's go into
402:50 - the point icons UI and let's add a
402:53 - component and let's add our very nice
402:54 - look at camera something like this and
402:57 - let's set the mode the same that we use
402:58 - so let's put it camera.org okay so
403:00 - everything is great everything should be
403:02 - perfect so let's finally test let's
403:03 - leave the scene save the prefab and hit
403:05 - on play all right so let's go pick up a
403:08 - plate and there you go there are no
403:09 - icons visible okay that's great now I'm
403:11 - going to place a bread on top of the
403:13 - plate and there you go I've got a nice
403:14 - bright icon okay great now let's make
403:17 - some meat cook it and as soon as it's
403:19 - done going to pick it up and there you
403:21 - go I've got a bread and some meat now
403:23 - let's put some cheese slice it put it
403:25 - there and there you go now I can easily
403:27 - see that plate has some bread some meat
403:29 - and some cheese now let's just add the
403:31 - rest of the ingredients to make a foam
403:32 - Mega Burger so let's add some tomatoes
403:34 - and add some nice cabbage slices any of
403:38 - there you go it works perfectly so here
403:40 - we have a complete burger with
403:42 - everything and we can easily see on the
403:43 - icons everything this contains alright
403:46 - awesome
403:47 - okay so here you'll learn how to make
403:49 - yet another Super useful element that
403:51 - you can easily add to all of your games
403:52 - personally I use this kind of logica ton
403:55 - in all kinds of UI things for example in
403:58 - my upcoming steam game total warm
404:00 - Liberation the items in the inventory
404:02 - they're all added using this method so
404:04 - there's a template and I duplicate that
404:06 - template same thing for all of the
404:08 - action buttons all of those are based on
404:10 - having a template and duplicating it
404:12 - it's a really easy way to do this kind
404:14 - of thing with all that here we have a
404:16 - phone plate and we can easily see what
404:17 - is on there so with this the next
404:20 - obvious step is to actually deliver some
404:21 - orders so let's do that in the next
404:23 - lecture
404:25 - hello and welcome I'm your code monkey
404:27 - in this lecture we're going to build the
404:28 - delivery counter this is where we're
404:30 - going to drop some items that the
404:32 - customers have requested in order to
404:33 - complete the orders also just for fun
404:35 - we're going to learn how to use Shader
404:37 - graph to make a simple custom Shader
404:39 - okay so let's begin by making our
404:41 - counter so let's go into our base
404:43 - counter let's create a new prefab
404:45 - variant for the delivery counter let's
404:48 - go inside and now let's find the visual
404:50 - the visual for delivery counter let's
404:53 - duplicate it to make the selecting let's
404:56 - go inside modify the material then on
405:00 - the selected make it one percent bigger
405:01 - one zero one add the component the
405:04 - selected counter visual let's drag the
405:06 - kitchen counter like that okay that's
405:08 - our basic setup and also start with the
405:10 - kitchen count disable okay great now
405:13 - let's make a script to run this so let's
405:15 - go into our counters folder and let's
405:16 - create a brand new c-sharp script for
405:19 - the delivery counter let's attach it and
405:22 - open okay so now here as usual let's
405:24 - begin by extending our base counter
405:27 - class all right now let's override the
405:30 - interact function
405:32 - and for now let's actually do it it's
405:33 - not like the trash counter meaning let's
405:35 - just destroy the object so we just check
405:38 - if the player is holding something so if
405:40 - the player has a catch an object let's
405:42 - go into the player the kitchen object
405:44 - then let's destroy it
405:45 - however another room over here for an
405:47 - Oliver counter is this is only going to
405:49 - accept plates so let's see if the player
405:51 - is carrying a plate object so player get
405:54 - kitchen object and test try to get the
405:57 - plate so out played kitchen object for
405:59 - the Plate Kitchen object
406:02 - we try to get this and if it is a point
406:04 - then we destroy it
406:08 - okay that's it here in the editor let's
406:10 - just compound the script and drag the
406:12 - references so the countertop point and
406:14 - on the selected let's drag the counter
406:16 - reference and let's exit this save the
406:18 - prefab and let's drop it over here on
406:21 - the corner so let's find over here the
406:23 - delivery counter and let's put it over
406:24 - there hang on it on this side put it
406:27 - like this let's also just quickly
406:29 - reposition all of our counters since we
406:31 - already have all the types that we're
406:33 - going to use so on the lever counter
406:34 - let's put it over here on this corner so
406:36 - x 7.5 0 and Z of two then next to it
406:40 - let's put the plates counter so over
406:42 - there okay
406:43 - then next week let's put a clear counter
406:45 - after that let's put the trash counter
406:48 - and then let's also put another empty
406:49 - one there so let's duplicate this one
406:51 - move it up to about this and put it like
406:54 - that now we just need to move all of
406:55 - these down here so just select all of
406:58 - these counters and let's move them down
407:00 - by about this okay so on minus 5.5 like
407:04 - this okay so everything is nicely
407:06 - positioned just over there right now we
407:09 - cannot access that container so let's
407:10 - actually modify those as well which by
407:12 - the way over here there's the canvas in
407:14 - front so as I click I'm actually
407:15 - selecting the canvas in the hierarchy so
407:18 - here's a quick empty tab on the
407:19 - hierarchy on the left side you've got
407:21 - these two buttons so one of them hides
407:22 - the object and the other one simply
407:24 - makes it unselectable so if I click on
407:26 - this and I click through any of the
407:27 - click goes through the canvas so that
407:29 - makes it much easier to select over here
407:31 - on the items in our scene so let you
407:33 - select all of these okay all of these
407:36 - now just push them all to the side and
407:39 - make another empty one and put it over
407:40 - here okay that's a nice layout now let's
407:43 - just finish the rest so over here let's
407:45 - just duplicate our empty counters and
407:47 - place a bunch more let's put one more to
407:49 - the side
407:50 - and now these ones over here so let's
407:52 - put it over there and rotate it here
407:54 - and duplicate another one and another
407:57 - one
407:58 - and another one and just one more and
408:01 - get rid of this one okay great so here
408:03 - we have pretty much our complete map
408:04 - let's also just move the camera tiny
408:07 - tiny bit just make sure that it is
408:08 - nicely organized so put it over there
408:11 - just so everything is nice and centered
408:12 - okay so there's our map now let's get
408:15 - back to working on our delivery counter
408:16 - we already added this code so let's just
408:18 - quickly test so here we are and if I
408:21 - pick up something like for example some
408:22 - cheese go into the delivery counter and
408:23 - interact and nope nothing happens
408:25 - because that one only accepts plates now
408:27 - if I pick up a plate go there don't wait
408:28 - for any of there you go it does work
408:30 - okay great so this is the basic logic
408:32 - that we want
408:33 - for defining the actual recipe and logic
408:35 - we're actually only going to do that in
408:36 - the next lecture but for now let's add
408:38 - one more nice thing let's add a simple
408:40 - custom visual over here using Shader
408:42 - graph this is a great way for you to
408:44 - learn the pottery of Shader graph and
408:45 - just how easy it is to use this is a
408:48 - visual tool for making shaders it's
408:49 - really very easy personally I don't know
408:52 - how to write shaders with code but I can
408:53 - build some pretty nice things using
408:55 - Shadow graph as usual I have a dedicated
408:57 - video on it I also have an entire
408:59 - playlist showcasing how to make all
409:01 - kinds of interesting effects and even
409:03 - one special video covering some changes
409:05 - in recent shareware versions so over
409:07 - here let's learn the basics how to use
409:08 - it so first here in our project window
409:10 - let's create a brand new folder let's
409:12 - name it just shaders and now inside
409:15 - let's create one so let's create then go
409:17 - up here into sheet graph then we're
409:19 - using urp so let's go inside there and
409:22 - here we've got a bunch of options now
409:24 - don't worry about picking the quote
409:25 - unquote wrong option all this does is
409:27 - just create a template so for example if
409:29 - you accidentally create an unlit Shader
409:31 - you can then easily swap it out from it
409:33 - so right right now let's go with the
409:34 - English hitter and for the name let's
409:36 - name it moving visual
409:38 - okay there's our shade Rafael now now
409:40 - let's just double click to open it and
409:42 - up here we have the nice shade graph
409:44 - window by the way you can make this
409:45 - phone screen so you can either right
409:47 - click over there on the tab and maximize
409:49 - or alternatively you can just click on
409:51 - this window and then use the hotkey
409:53 - shift space and if there you go it does
409:55 - maximize okay great now by default we
409:58 - have this down the center this is called
409:59 - the master stack these are the actual
410:02 - properties that we're going to need to
410:03 - use then on the left side we have the
410:06 - properties Blackboard on the right side
410:08 - we've got the graph inspector and
410:10 - finally down here we've got the main
410:12 - preview all of these windows can be
410:13 - scaled and also if you don't see these
410:15 - windows or if you accidentally hide them
410:17 - they're all appear on these three
410:19 - buttons so the Blackboard that's on the
410:21 - left the graph inspector and the main
410:22 - preview okay so now here we've got a
410:24 - nice empty board so we can add whatever
410:25 - nodes we want so we can right click and
410:28 - go into create node and then we can
410:30 - write something or just click anywhere
410:31 - and press on space and there you go now
410:33 - we can cycle through and browse all of
410:35 - these menus to see all of the nodes that
410:37 - exist there's tons and tons of them or
410:39 - alternatively just go up here and use
410:41 - the search bar so for example let's find
410:43 - the sample texture 2D node so here it is
410:45 - this one okay we've got this node what
410:48 - this one does is it takes a texture and
410:51 - grabs the color from it so on the left
410:53 - side of the node are the inputs and on
410:54 - the right side are the outputs within
410:57 - the parentheses you can actually see the
410:58 - types so for the input texture this one
411:00 - is of type T2 so that means it's a
411:02 - textured 2D then on the output you can
411:04 - see there's a 4 meaning it contains four
411:06 - floats which in this case refers to the
411:08 - four colors so that's red green blue and
411:11 - Alpha so for an input we want a texture
411:13 - so let's set it over here as a property
411:15 - let's click on the plus icon and we've
411:17 - got a whole bunch of types for texture
411:20 - we want a textured 2D so let's go with
411:21 - that and then for the name now usually
411:24 - there are two standard names there's one
411:26 - called main text or base map main tags
411:29 - used to be the more common name but when
411:31 - working with urp for some reason they
411:33 - decided to name the main texture as base
411:34 - map so we're here let's stick within the
411:36 - urp standard and just call this basement
411:38 - okay there's our property and if we
411:40 - click the select it and on the right
411:42 - side we can see the graph inspector and
411:44 - we can see all the properties for this
411:45 - Actron property so we see a name
411:47 - reference and a bunch more things now
411:49 - the really important one is over here
411:51 - the reference this is the actual name
411:53 - that you're going to use if you want to
411:54 - interact with this Shader through code
411:56 - the name on the property this one is
411:58 - just a text ring so this can be whatever
411:59 - you want you can even have spaces and so
412:01 - on whereas the reference name this is
412:03 - the really important one and by default
412:05 - when you set up a name it should already
412:07 - accept the correct reference usually the
412:09 - standard is to name it just like the
412:11 - name both without any spaces and with an
412:13 - underscore in the beginning so just like
412:15 - this okay then we can give it a default
412:17 - texture so let's go ahead and select
412:19 - something for example over here the
412:20 - bread texture remember this is just the
412:22 - default this will not be hard-coded
412:25 - directly into the Shader we can then
412:26 - modify this okay so we we have our nice
412:29 - base map property definition now we can
412:31 - just drag it over here on the board and
412:32 - yep there it is and now we can just
412:34 - click on the server icon in order to
412:35 - drag a connection and let's connect it
412:37 - over here onto the sample textures to
412:39 - the input and yep right away we do see
412:41 - it does work so we are correctly
412:42 - sampling the texture however if you look
412:45 - on the main preview over here there's
412:46 - still nothing that's because we don't
412:48 - have this node connect to anything we
412:50 - need to connect it to the final Master
412:52 - sack in order to render something so
412:54 - again on the output over here we can see
412:55 - a four so these are all of our colors
412:57 - and actually one very useful node is the
413:00 - preview since so many things in Shader
413:02 - graph can be hard to visualize so we can
413:05 - move these nodes around and let's add
413:07 - the preview node
413:08 - and this does examine that so you can
413:10 - fit it an input and you can see down
413:11 - here what that input contains so for
413:14 - example let's drag just the red Channel
413:16 - and if they go over there we can see the
413:18 - red channel for this texture we can drag
413:20 - the green channel the blue Channel or
413:22 - look at the alpha Channel yep there you
413:24 - go it does work so this preview node is
413:26 - super useful for being able to see what
413:28 - your Shader is actually doing over here
413:30 - we have the colors so let's get rid of
413:32 - the preview right now in order to make
413:34 - it work we really just need to connect
413:35 - the rgba and go up here into the base
413:38 - color and right away it should work but
413:41 - you might not be able to see anything
413:42 - over here on the main preview
413:44 - I believe this is a rendering bug in the
413:46 - current Tech version so right now
413:48 - nothing is shown
413:49 - so if you still don't see anything it's
413:51 - actually pretty simple just go up here
413:52 - on the top left side and make sure to
413:54 - save the ascent okay save it great then
413:56 - let's exit from our maximize View and
413:59 - now let's close this tab let's click on
414:01 - play just to play the game now let's
414:04 - stop playing and now if we open the
414:06 - Shader again if there go now we do see
414:08 - the Shader compiling over there that
414:09 - color that is the Shader compilation and
414:11 - after a little bit it should work let's
414:13 - just maximize this
414:14 - see if there you go there we do see our
414:16 - texture okay great
414:17 - so again it's just a simple rendering
414:19 - plug on the current Tech version if
414:21 - you're watching this video in the future
414:22 - chances are you don't even have this box
414:24 - so there's no need to worry okay so
414:26 - right now we do see it working we can
414:27 - see our bread texture and it's currently
414:29 - being applied on a sphere for a use case
414:31 - we're working with 2D textures so this
414:34 - would be best to be seen on the Quan so
414:35 - we can right click over here on the
414:37 - preview in order to select the preview
414:38 - mesh so let's go with a simple quad and
414:40 - if there it is we have our Knight Squad
414:42 - okay great
414:43 - so over here we have our basic Shader
414:45 - all it does is just shows the texture
414:48 - that's it now it's actually use this and
414:50 - first let's always make sure to save the
414:52 - asset on the top left side on the moving
414:55 - visual if you see an asterisk here that
414:57 - means you have unsafe changes so always
414:59 - make sure to save them in my case I
415:01 - don't but still never hurts to save now
415:03 - over here in scene view let's go inside
415:04 - art only three counters and let's open
415:06 - it and now for the display for our Arrow
415:09 - let's make it a flat one so let's right
415:11 - click in the hierarchy and let's create
415:12 - a new 3D object and let's make it a quad
415:15 - let's call this the delivery Arrow
415:18 - let's place this on top of the counter
415:20 - so let's rotate it to face upwards by
415:22 - the way on the rotation make sure the
415:24 - collar is facing upwards most shaders by
415:26 - default they only render one face and
415:28 - not the other one so make sure you put
415:30 - the face with the collar upwards and not
415:32 - the other one okay so let's rotate this
415:33 - one upwards so there we go 90 over there
415:36 - and let's just put it just exactly on
415:38 - top of the counter so just enough so
415:40 - that it's visible okay great so now
415:43 - let's make a material for our Arrow so
415:45 - let's go inside the materials folder and
415:47 - over here let's create a brand new
415:49 - material
415:50 - let's call this the delivery Arrow let's
415:52 - make sure to use this material on the
415:54 - quad so let's just drag it over there on
415:56 - the mesh render okay so it's using our
415:57 - custom material and over here on this
416:00 - Shader graph drop down menu over here we
416:02 - can select what Shader we want to use so
416:04 - in our case let's go inside the founder
416:06 - Shader graphs and inside yep here we
416:08 - have our moving visual Shader so let's
416:11 - go ahead and use this and here right
416:12 - away we do see that it does work here we
416:15 - have our texture being drawn exactly on
416:16 - top of our material okay so far so good
416:19 - now again here remember one very very
416:22 - important thing that I said the texture
416:24 - that you define the Shader over here the
416:25 - default for the property this one is
416:28 - only the default the important one is
416:30 - the one that we have on the material I'm
416:32 - emphasizing this point because I've seen
416:34 - a bunch of people make this mistake if
416:36 - you modify default texture whilst inside
416:38 - the Shader like for example if I change
416:40 - here from bread let's say into the
416:42 - Cabbage slices
416:43 - if I modify that note how it does not
416:46 - modify any materials that were created
416:48 - we are only changing defaults so if you
416:51 - want to change the texture that is
416:52 - actually used make sure you change the
416:54 - one on the material that you created and
416:56 - not the defaults I changed the default
416:58 - but did not change this Shader however
417:00 - if I now were to make another material
417:01 - which by the way here's a quick tip you
417:04 - can recollect directly on the Shader
417:05 - file and going to create and create new
417:07 - material and it will automatically
417:09 - create the material using that Shader
417:10 - naturally here then update default just
417:12 - because I didn't save the Shader so I
417:15 - modified this one for the camera slices
417:16 - and now if I save the asset and now if I
417:18 - right click there and I create a brand
417:20 - new material and yep now that one does
417:22 - have the new default but again remember
417:24 - what you said over here is just the
417:26 - default what really matters is what is
417:29 - on the material after the material has
417:31 - been created modifying default here does
417:33 - nothing so always keep that in mind in
417:35 - most cases you want to be changing the
417:37 - property on the material itself not the
417:39 - default on the Shader okay let's just
417:41 - clean up both of these all right so
417:42 - let's continue now here we have our
417:44 - Sprite working okay except we don't want
417:46 - to show some bread so let's actually use
417:48 - the proper Arrow Sprite so let's select
417:49 - this one
417:50 - and yep it does work it is printing the
417:52 - Sprite however one obvious thing is that
417:54 - the arrow is not transparent like it
417:56 - should be so let's solve that back in
417:58 - our Shader graph in order to make this a
418:01 - transparent Shader we need to actually
418:02 - go into the graph settings so on the
418:04 - graph inspector go into graph settings
418:05 - and over here you see a bunch of
418:07 - settings that relate to the graph itself
418:08 - and not any selected property so let's
418:10 - go into graph settings for example like
418:12 - I mentioned a while ago you can modify
418:13 - between lit and lit and so on so this is
418:16 - where you would change that you can also
418:18 - appear at multiple targets so you can
418:20 - create a Shader in Shader graph and make
418:22 - it work with the Universe on random
418:23 - pipeline or the high definition render
418:25 - pipeline or the built-in render pipeline
418:26 - all of those are supported through
418:28 - Shader graph now for a goal in order to
418:30 - make this a transparent Shader let's
418:32 - just go over here onto service type
418:33 - instead of opaque and let's change to
418:35 - transparent and as soon as we do look
418:37 - what happens there and if there go it
418:39 - adds a brand new Alpha Channel if we
418:40 - just save the asset right now and open
418:43 - look at that it still doesn't work it's
418:44 - still not transparent basically we made
418:46 - this Shader transparent but now we need
418:48 - to fit in the transparent Channel over
418:50 - here onto the alpha this is the one
418:52 - thing that is different from a previous
418:54 - version of shadowgraph previously you
418:55 - could just feed the alpha Channel over
418:57 - here onto the base color and Shader
418:59 - graph would automatically apply it but
419:01 - in recent versions you need to add it
419:03 - over here separately so if you have any
419:05 - issues with transparency when following
419:07 - some older share graph tutorials always
419:08 - remember this change I covered that
419:10 - along with some other changes in a very
419:12 - useful video so if you're following
419:13 - along some other shade graph tutorials
419:15 - make sure you watch that video to learn
419:17 - what you need to do to update them to
419:18 - the latest version okay so here on the
419:20 - similar texture we already have the
419:22 - alpha channel so we just connect this
419:23 - onto the master Alpha and right there we
419:25 - already see it working let's just go
419:28 - ahead save our asset and here in scene
419:30 - view if there go now we do see our Arrow
419:32 - now one more small thing you might
419:35 - notice that from some angles it's not
419:36 - exactly transparent basically it
419:39 - actually is transparent but since we
419:40 - made this in literature sometimes the
419:42 - light might make the transparent Parts
419:43 - visible one option to solve that is over
419:46 - here on the graph settings instead of
419:47 - making it lit let's make it unlit that
419:49 - would work say up with the unload Shader
419:51 - the transparency is perfect but if you
419:53 - really want to keep it lit then the
419:55 - other thing you can do is just over here
419:56 - play around with these settings you've
419:58 - got smoothness AO and so on and over
420:00 - here you can even modify the workflow
420:01 - mode so for transparency instead of
420:03 - making it metallic let's go with a
420:05 - specular workflow and then over here set
420:07 - the smoothness to 1 and the ambient
420:09 - occlusion down to zero and now if we
420:11 - save this Shader look at that and yep
420:13 - now the transparent parts are indeed
420:15 - fully transparent finally over here on
420:17 - the right side on the mesh render if you
420:19 - want you might want to play around over
420:20 - here with the cast Shadows so maybe you
420:23 - don't want this one to cast Shadows
420:24 - maybe you don't want it to impact light
420:26 - probes and so on okay so with this we
420:28 - have our nice transparent Arrow
420:30 - let's make sure to save our delivery
420:32 - counter so let's go outside back into
420:33 - scenes
420:34 - and let's head on playing and if there
420:36 - you go we have our transparent counter
420:38 - with our nice Arrow now we want the
420:40 - arrow to actually move and doing that is
420:42 - actually super simple going back here in
420:44 - our shadow graph let's just modify
420:46 - default just so we can see the arrow
420:47 - that we want to see so let's select the
420:49 - arrow Sprite okay there's our Arrow now
420:53 - for moving over here on the simple
420:54 - texture we've got an input for the UV
420:56 - the UV is what defines what portion of
420:59 - the texture we're going to grab which by
421:00 - default just gets the whole texture so
421:03 - since this field represents where we're
421:05 - going to grab from texture by playing
421:07 - around with this we can grab different
421:08 - parts so to do that let's just add a
421:11 - standard UV node so here it is this is
421:13 - the standard UV channel so if we connect
421:15 - this then nothing changes everything
421:17 - still renders exactly the same but now
421:19 - we can modify this and to do that we're
421:21 - really just going to use some basic math
421:23 - remember that when working with shaders
421:25 - even though you do see colors everything
421:27 - is really just numbers so uv2 is just
421:30 - number the converges the number the
421:32 - alpha is just a number so visually
421:33 - everything might look like images might
421:35 - look like colors but really in the end
421:37 - it's all just numbers so for example how
421:39 - do we move this texture well it's
421:41 - actually pretty simple we just add a
421:42 - number onto it so we're here on the UVM
421:45 - let's just add an add node so this just
421:48 - adds two numbers together very basic so
421:50 - let's take the regular UV and let's add
421:52 - something on top of it for example we
421:55 - can make a vector two
421:56 - and let's put it on say 0.10
421:59 - and let's add this one onto this one and
422:01 - now if we drag this one onto the input
422:03 - and look over there on the preview what
422:04 - happens and if they're going like that
422:06 - it moves slightly to the left so if I
422:08 - modify this one put it on zero there you
422:10 - go and that point one on that point two
422:12 - on that and so on so you can see that by
422:14 - modifying here I'm essentially
422:15 - offsetting the texture I'm offsetting on
422:18 - the X and over here I can also offset it
422:20 - on the y basically I'm offsetting the
422:22 - texture by ten percent the UV is a
422:24 - normalized value this is not pixels so
422:26 - that is why point one is ten percent
422:27 - regardless of how big the texture is and
422:30 - if we go way past one then texture
422:32 - essentially Loops back so this is really
422:34 - all we need
422:36 - for our moving Arrow we're going to have
422:38 - zero on the Y and on the X we're going
422:40 - to constantly either increase or
422:42 - decrease that's how we're going to have
422:44 - our moving Arrow so again the only issue
422:46 - here is that I'm modifying this manually
422:47 - we don't want a fixed amount on the
422:49 - Shader instead we want a nice animation
422:51 - so for that we have the very useful the
422:53 - time node
422:54 - this one has various time-based outputs
422:57 - the one that we want for this case is a
422:59 - time which is just the total time this
423:01 - one is constantly increasing since the
423:03 - start of the game by the number of
423:04 - seconds so if you use this over here
423:06 - directly on the end and they're gonna
423:08 - look that texture is constantly
423:09 - scrolling okay so that's great except
423:12 - obviously we have one issue we don't
423:14 - want it to scroll diagonally we only
423:16 - want to scroll in One Direction so for
423:18 - that we can essentially create a simple
423:20 - property to act as our spin so let's
423:23 - over here on the Blackboard let's create
423:25 - a new Vector two column Tower speed
423:27 - property and for the phone let's see if
423:29 - I want to say 0.1 on the x0 on the Y and
423:32 - now if I drag the speed over here onto
423:34 - our Blackboard okay great this is
423:36 - basically a multiplier so we just need
423:38 - to multiply the time by this so let's
423:40 - add a multiply node also by the way
423:43 - quick tip over here on each node you've
423:44 - got a nice little arrow so if you want
423:46 - to make it a bit more compact so if you
423:47 - don't actually need to see the preview
423:49 - so make that and in this case let's take
423:51 - our time multiply it by our speed and
423:54 - then for the output pass it into the end
423:55 - okay so like that now it is indeed
423:57 - moving in this direction and over here
423:59 - on the speed we can play around the
424:00 - values so if we put that 0.5 now it's
424:03 - moving faster and if I put it on the Y
424:05 - now it's moving diagonally put zero on
424:07 - the X and now it's only moving
424:08 - vertically okay so this is really what
424:11 - we want let's just go ahead save our
424:13 - Shader and now let's just select our
424:15 - delivery Arrow material and over here
424:17 - yep we've got the spin if you don't see
424:20 - it make sure they're on the speed
424:21 - property over here you have it exposed
424:23 - so we have the speed instead of moving
424:24 - on the Y let's move on the X and
424:27 - actually like this it's reverse going
424:29 - backwards so over here we can just put a
424:31 - negative value so let's put it on minus
424:32 - one and if there go now the arrow is
424:34 - moving perfectly also here let me make
424:37 - one important note just in case you're
424:39 - using this Shader with a custom texture
424:41 - instead of the one included in the
424:42 - course if you do that make sure that the
424:44 - texture that you use over here I'm using
424:45 - the arrow texture
424:47 - over here on the Arrow import settings
424:49 - down here under wrap mode make sure it
424:51 - is set to repeat if you set it as clamp
424:53 - you might get some weird visuals or
424:55 - nothing at all in order for the texture
424:57 - to constantly Loop and constantly repeat
424:59 - itself that one needs to be set to
425:00 - repeat okay so here it is in game and we
425:03 - have a really nice moving texture for
425:05 - that we created the simple but really
425:07 - nice useful custom Shader definitely go
425:09 - ahead and watch the various effects that
425:11 - I made in the shadow graph playlist this
425:13 - tool is super useful definitely make
425:15 - sure you know how to use it I've used it
425:17 - for making a building effect I've made
425:19 - some nice outlines a really nice wind
425:21 - Shader also a really interesting the
425:23 - sound of effect and even a cool
425:25 - transition Shader just like in the game
425:27 - Hades so this really is a super powerful
425:29 - tool make sure you watch that playlist
425:31 - to really learn how to use it alright so
425:33 - here we'll learn about share graph and
425:34 - created a really nice custom Shader
425:36 - however the delivery counter still only
425:38 - has a visual so let's create some proper
425:41 - Logic for generating and delivering the
425:43 - correct recipes in the next lecture
425:46 - hello and welcome I'm your code monkey
425:48 - in this lecture we're going to build a
425:50 - proper delivery manager that will
425:51 - generate recipes that customers are
425:53 - ordering and validate to see if the
425:55 - player made the right dishes alright so
425:57 - right now we have the player capable of
425:58 - making dishes so for example I can put
426:00 - some cheese cook some meat cut the
426:02 - cheese and then pick up both of them
426:04 - then let's say pick up some bread there
426:06 - you go got a nice cheeseburger and
426:08 - deliver it okay so that works but right
426:10 - now they just vanish on delivery counter
426:12 - so there's no recipe we need to follow
426:14 - no validation none of that so let's add
426:16 - both those things okay first of all
426:19 - let's make our script so let's create a
426:20 - brand new sharp script for the delivery
426:22 - manager let's make a new game object to
426:25 - run it so we need delivery manager
426:26 - attached to script let's make sure to
426:28 - keep things lean so reset the transform
426:30 - and also by the way since we're here
426:32 - let's go ahead and put the plates and
426:33 - delivery counter inside the counter so
426:35 - everything is nice and organized okay
426:37 - great so let's open up this script now
426:40 - here basically we need to Define some
426:42 - sort of list to store all the recipes
426:43 - that the customers are waiting for which
426:46 - of course begs the question what type is
426:47 - that going to be now technically one
426:50 - thing we could do since a recipe is
426:52 - around just a list of kitchen objects
426:53 - over here we could have a list of list
426:56 - of kitchen objects this would be our
426:58 - recipe list technically that would work
427:01 - but that really looks quite dirty
427:02 - instead of having a list of lists we
427:04 - should probably have a proper type for
427:06 - this so let's write some good clean code
427:08 - and Define a proper recipe Script Mod
427:10 - object back in unity let's go inside
427:12 - script knowledge's folder and create a
427:14 - brand new one let's call this the recipe
427:16 - so and over here let's make this a
427:19 - script Mall object so extend script on
427:21 - object make the create asset menu
427:24 - and over here for the films for that
427:26 - that we need well like I said a recipe
427:28 - is just a list of ingredients so just
427:30 - taking a list of kitchen object that
427:32 - sell for the kitchen object SM list
427:35 - okay that's it that's really all the
427:37 - data that we need to define a recipe
427:38 - just to be able to identify them for the
427:41 - player let's also add a public string
427:43 - for the recipe name
427:45 - so just a nice name String okay great
427:47 - now back in the editor let's define so
427:49 - let's go inside the certain objects and
427:51 - make a brand new one for our recipe so
427:54 - and now inside let's create a brand new
427:57 - recipe SL for this one let's call it
427:59 - just burger and over here first of all
428:01 - for the name just name it burger and
428:03 - then for the kitchen object list well to
428:05 - make a burger let's well first let's add
428:07 - some meat and we want some cooked meat
428:09 - we don't want to serve uncooked or burnt
428:11 - meat so only the cooked meat then for a
428:13 - simple Burger obviously we need some
428:15 - bread and that's about it so some bread
428:17 - some meat that's our very basic Burger
428:19 - now let's also make another one so let's
428:21 - duplicate this one and name this one the
428:23 - cheeseburger over here let's name it
428:25 - cheeseburger
428:28 - and lightning place has bread meat and
428:31 - obviously some nice cheese slices
428:33 - so there you go okay we have a
428:35 - cheeseburger now let's also make a mega
428:38 - Burger so something with everything
428:39 - so let's call this one the mega burger
428:41 - and over here for the string name for
428:44 - the Mega burger and for that we have
428:46 - meat bread cheese let's also have some
428:50 - nice cabbage slices and also some tomato
428:52 - slices alright that's our Mega burger
428:54 - with everything and finally let's also
428:56 - make just a nice simple salad so let's
428:58 - duplicate this for a salad
429:00 - let's name it salad
429:03 - and for the salad we don't have any meat
429:05 - we don't have any bread and also no
429:07 - cheese so just cabbage slice and tomato
429:09 - slice that's a simple salad okay so here
429:12 - we have all of our recipes so back here
429:14 - on the delivery manager script instead
429:16 - of making a list of lists of game
429:18 - objects let's just make a list of recipe
429:20 - recipe so and name it the recipe so list
429:23 - this is where we're going to probably
429:24 - see recipes that the customers are
429:26 - waiting for so it's actually rename this
429:28 - let's put it waiting recipe on list okay
429:31 - so the customers are waiting for
429:32 - whatever is inside this list and now we
429:35 - could make this a serialized field then
429:36 - set it in the editor but we don't want
429:38 - to have a fixed list we want to
429:40 - periodically spawn new recipes in order
429:42 - to spawn new recipes we also need to
429:44 - know which ones we can spawn so for that
429:46 - we could add a list of all of the
429:48 - recipes then we could pick a random one
429:50 - from the list and add it over here to
429:52 - the waiting list that would work that's
429:53 - one good approach but since we already
429:55 - did something similar to that various
429:57 - times in this course here don't let me
429:58 - teach you a different approach that
430:00 - sometimes might make more sense for that
430:02 - second approach we just need one thing
430:03 - we need a script more object to hold all
430:05 - of our recipes so let's do that let's do
430:08 - a brand new c-sharp script this is the
430:10 - recipe list scriptable object and then
430:13 - inside this one is going to be a
430:15 - scriptable object let's add the create
430:18 - asset menu
430:19 - and inside we're just going to have a
430:21 - list of recipe so
430:23 - for the recipe SLS so that's it super
430:26 - simple now let's just create one object
430:28 - of this type we can put it inside the
430:30 - recipe as soon as since we're only going
430:32 - to have one so let's make a recipe on
430:34 - Lister so namely the recipient list SL
430:36 - and then over here let's just drag our
430:38 - recipe so we've got a burger a
430:40 - cheeseburger we have a mega burger and
430:43 - finally a salad okay so basically we
430:45 - have a script ball object with all of
430:47 - our recipes and now just for safety
430:49 - since we only want to ever have a single
430:51 - one of these objects a recipe on SSO for
430:54 - this one we can go back here in the
430:55 - script and simply comment out the create
430:56 - asset menu so now back in the game over
430:59 - here we can no longer create another
431:01 - type of recipient list so so just say
431:03 - nice safety thing since we probably only
431:05 - need just one and let's also add an
431:07 - underscore just so it shows up at the
431:09 - top-down list okay great so we have this
431:11 - and over here on the recipe manager we
431:14 - can basically expose that in a
431:15 - serialization so let's make a serialized
431:17 - field
431:18 - make it private of type recipe so list
431:22 - recipe enlisted so for the recipient
431:24 - list so and now here in the editor we
431:27 - just drag that reference alright that's
431:29 - it so basically the difference that we
431:31 - did with this method is over here on
431:33 - delivery manager instead of having a
431:34 - list of all of our recipes we just have
431:36 - a reference to one object and then that
431:37 - object holds a list of all the recipes
431:39 - in this specific use case like I said
431:41 - this approach doesn't really have many
431:42 - benefits compared to just starting the
431:44 - last year but let's say we had another
431:46 - script that also needs a list of all of
431:48 - our recipes if we did that we would
431:50 - basically have duplicate references so
431:53 - this script would have a list of all the
431:54 - recipes then some other script would
431:56 - also have a list of all the recipes and
431:57 - then if you wanted to add a brand new
431:59 - recipe you'd need to add it to all the
432:01 - lists on all the scripts whereas like
432:03 - this any script that needs to know about
432:05 - all of the recipes just needs a
432:07 - reference to the recipe on SSO and
432:09 - whenever we want to add or remove a
432:10 - recipe we just need to update this one
432:12 - object and everything works perfectly
432:14 - that's one of the benefits of this
432:16 - approach where you have a script mode
432:17 - object to hold a list of all the objects
432:19 - of some type personally I find this
432:21 - pattern to be quite useful okay so on
432:23 - delivery manager we have a list of all
432:25 - of our recipes now let's just make a
432:27 - simple timer to spawn them like I
432:29 - mentioned previously in the spawn point
432:30 - logic you could just use Echo routine if
432:32 - you like that
432:33 - core routines can be useful for running
432:35 - timers but personally like I mentioned I
432:37 - do not like Co routines I don't like the
432:39 - pattern they force it to use so over
432:41 - here I'm just going to make a simple
432:42 - flow timer
432:43 - so a private fluid for the spawn recipe
432:46 - timer another one for the recipe timer
432:49 - Max and let's say 4 seconds
432:51 - then we just do a simple and private
432:53 - weight update
432:55 - on update let's count down the timer so
432:57 - time dot down for time
432:59 - and if the spawn timer is under 0f let's
433:03 - reset the timer
433:04 - and now let's basically spawn a recipe
433:06 - so for that let's grab a random one from
433:08 - the list so we go into the recipe list
433:10 - so and grab the recipe as a list then
433:13 - we're going to grab a random one so
433:15 - let's get a random index so random.range
433:18 - between 0 and the recipient list so dot
433:21 - recipes dot count so you get a random
433:24 - one this is going to be a recipe so for
433:26 - the waiting recipe so
433:28 - and then we simply go into the waiting
433:30 - rest PSL list and we add a brand new
433:33 - recipe okay that's it super simple let's
433:35 - just make sure to initialize the list so
433:37 - let's do here a simple awake for the
433:39 - waiting recipes and just initialize it
433:42 - okay so like this it should be working
433:44 - however we're also going to generate
433:46 - recipes non-stop we don't want that so
433:48 - let's define some kind of maximum
433:50 - so let's Define a simple end for the
433:53 - waiting recipes Max
433:56 - let's say we kind of have a maximum of
433:58 - four recipes waiting
434:00 - and then down here when camera lapses so
434:02 - if the waiting recipes only stock count
434:04 - if it is under the maximum then we
434:07 - generate and add it okay that's it
434:09 - pretty simple
434:10 - now for testing let's just set allow
434:12 - here to print the name so debug.log on
434:14 - the waiting recipe so that we generate
434:16 - so let's print out the recipe name okay
434:19 - so let's test so here we are in yep one
434:22 - will spawn right away so we have a solid
434:24 - and after four seconds Yep they're going
434:25 - out of salad and if we wait for four
434:27 - seconds we should have another one there
434:29 - you go a mega butter recipe and finally
434:31 - after four seconds we have yep we have
434:33 - another burger and now no matter how
434:35 - much time passes there should be no more
434:38 - since we're at the limit any uptime pass
434:40 - then no more okay all right awesome so
434:42 - we are correctly generating recipes that
434:44 - the customers are waiting for now it's a
434:47 - logic to try to fulfill these orders so
434:49 - over here on delivery manager let's make
434:51 - a function to deliver a recipe
434:53 - so let's make a public Point make it
434:55 - public since we're going to access this
434:57 - from the delivery counter currently
434:59 - deliver recipe
435:01 - and the recipes are going to be
435:02 - delivered whilst on a point so let's
435:04 - receive a parameter of type Plate
435:06 - Kitchen object
435:07 - and over here the logic is actually
435:09 - going to be pretty simple we just need
435:11 - to cycle through all of the recipes that
435:13 - the customers are waiting for and see if
435:15 - the ingredients on this plate matches
435:17 - the ones on any waiting recipe
435:19 - so over here let's cycle through all of
435:21 - our recipes so let's do before
435:23 - entire zero going through the entire
435:26 - recipe only star count I plus plus okay
435:29 - let's grab the recipe so for the waiting
435:32 - recipe so
435:34 - and we grab from The Waiting recipes on
435:36 - list on this index okay so we have that
435:38 - then first let's do a quick test just to
435:40 - check if the waiting recipe has the same
435:42 - number of ingredients as they are on the
435:44 - plate if not then we already know that
435:46 - it's not valid so over here let's do a
435:48 - quick test SO waiting recipe so let's
435:51 - check the kitchen object that's only
435:53 - it's not count if this one matches the
435:55 - play kitchen object let's get the
435:57 - kitchen object that's on the list and
435:59 - also check the count so over here we
436:01 - know that has the same number of
436:03 - ingredients
436:04 - so this is the first check then we need
436:07 - to cycle through all the ingredients on
436:08 - this recipe and all of the ingredients
436:10 - on the plate and basically see if both
436:12 - of them match so let's first cycle
436:14 - through the ingredients on the recipe so
436:16 - for each
436:18 - kitchen object as so let's call it the
436:20 - recipe kitchen object so in the waiting
436:25 - recipe so let's go into the waiting
436:26 - recipe and get the kitchen object list
436:29 - okay so here we are cycling through all
436:33 - ingredients in the recipe
436:35 - then we need to cycle through all the
436:37 - ingredients on the plate so let's do
436:39 - another cycle for the Plate Kitchen
436:41 - object SL and we're going to go inside
436:43 - the Plate Kitchen object get the kitchen
436:45 - object that's on the list like this
436:47 - so here we are cycling through all the
436:49 - ingredients on the plate
436:52 - okay so now here basically we need to
436:54 - see if this ingredient that we're
436:55 - cycling through if this one matches the
436:57 - ingredient on the recipe so here we
437:01 - check if the Plate Kitchen object does
437:02 - so if this one matches the recipe
437:05 - kitchen outlet
437:07 - if so then the ingredient does match
437:10 - so in order to keep track if it does
437:12 - match
437:13 - over here before we cycle through all
437:15 - the ones on the plane let's define a
437:16 - bone for found or ingredient found
437:20 - let's default it too false and over here
437:23 - if we have match then this one becomes
437:25 - true and by the way over here we can
437:27 - also break out of the cycle
437:28 - now if you're not familiar with break
437:30 - basically this is going to break out at
437:32 - the for each so let's say the plate has
437:34 - 10 ingredients and the second one
437:36 - matches when this cycle gets to the
437:38 - second one it triggers a break so it no
437:40 - longer goes through the remaining eight
437:41 - so basically it breaks out of the cycle
437:43 - so keeps writing some code right down
437:44 - here okay so we cycle through all of the
437:46 - ones on the aggressively then recycle
437:48 - through the plate and if we do find that
437:50 - ingredient on that plate then we have an
437:53 - ingredient found so over here
437:55 - if we have a not ingredient found
437:59 - then over here that means this recipe
438:03 - ingredient was not found on the plate
438:07 - so if that happens then essentially over
438:08 - here we have a phenocate so the
438:10 - ingredient that this recipe requires is
438:12 - not on the plate so let's go up here
438:14 - when we have the same number of
438:16 - ingredients let's define a Boolean
438:17 - called the plate contents matches recipe
438:20 - let's see found it to true and over here
438:23 - if we don't find at least one of them
438:24 - then the plate contents do not match the
438:27 - recipe and afterwards we can check this
438:29 - bowl again
438:31 - so if this one is true that means they
438:33 - all match if just one of them does not
438:35 - matches then this one won't be false
438:37 - so over here we know player delivered
438:39 - the correct recipe
438:42 - so over here on let's do a quick debug
438:44 - down log and print out a message
438:47 - and after we do let's also do a return
438:49 - so we stop the rest of the execution so
438:51 - basically if we find a waiting recipe
438:52 - that matches we don't want to keep going
438:55 - and also here if we do find it let's
438:57 - also remove it from the list
438:59 - so let's go into waiting queue remove at
439:01 - and remove at this index okay so we're
439:04 - going to remove this recipe but if this
439:06 - doesn't happen then it's going to be
439:07 - keep cycling and it's going to cycle
439:09 - through all the recipes so basically if
439:10 - it reaches the end this far
439:12 - then basically no match is found
439:16 - so the player did not
439:19 - deliver a correct recipe
439:23 - so let's do another debug in here
439:29 - okay so this is done for logic it looks
439:31 - a bit complex but I hope this was easy
439:33 - to follow when we see it in action It
439:35 - all becomes a bit more clear so all
439:37 - that's left is just calling this
439:39 - function from the delivery counter so
439:40 - let's do that over here on the delivery
439:43 - counter it accepts plates and destroys
439:45 - plates but before we destroy
439:47 - let's go into the delivery manager which
439:49 - means we need to access a reference so
439:51 - again we could add a serialized field or
439:53 - in this case it makes perfect sense to
439:55 - make this a Singleton so let's make it
439:57 - here public static of type delivering
439:59 - manager call it instance with a public
440:01 - get and a private set
440:05 - okay then over here on awake let's set
440:08 - instance equals this
440:10 - all right so now over here on the
440:13 - delivery counter we can go into the
440:14 - delivery manager access the instance and
440:17 - deliver our recipe and pass in the Plate
440:19 - Kitchen object
440:21 - okay that should do it let's test all
440:24 - right so let's look in the log to see
440:25 - what they are waiting for so there are
440:27 - two cheeseburgers waiting another Mega
440:30 - burger and a cheeseburger so let's make
440:32 - a cheeseburger to deliver so first of
440:34 - all let's cook some meat let's slice
440:36 - some cheese let's pick up the meat
440:38 - before it burns pick up the cheese and
440:40 - we just need the bread okay this is a
440:42 - valley cheeseburger so let's deliver it
440:45 - and if there go the players delivered
440:47 - the correct recipe okay great
440:49 - now let's deliver something that nobody
440:51 - asked for let's say just some meat
440:52 - actually let's burn it just for fun all
440:55 - right so there we have a bunch of
440:57 - charred meat so nobody really wants this
440:58 - but if we deliver if their yield player
441:01 - did not deliver a correct recipe alright
441:03 - awesome so over here everything worked
441:05 - we have a bunch of recipes being
441:07 - generated and then we have the logic so
441:10 - that when the player delivers something
441:11 - it checks if the players delivered
441:13 - something correct or incorrect so
441:15 - everything is great all that's missing
441:17 - is obviously some nice UI so let's do
441:19 - that in the next lecture
441:21 - hello and welcome I'm your code monkey
441:23 - in this lecture we're going to create a
441:25 - nice UI visual to display our waiting
441:27 - recipes okay so our delivery manager is
441:29 - already working we are randomly spawning
441:31 - some random recipes every once in a
441:33 - while now instead of looking at the
441:34 - console let's add a proper UI so for
441:37 - that over here in the editor let's go
441:38 - inside the canvas and by the way let's
441:40 - click on the button to unlock the canvas
441:42 - and this is actually the first time
441:44 - we're using the Ragnar canvas quite a
441:46 - while ago we just created it we didn't
441:47 - really set it up so let's quickly do
441:49 - that for the render mode this one is
441:51 - meant to be a regular UI so let's leave
441:53 - it on the screen space overlay then over
441:55 - here on the canvas scaler instead of
441:57 - constant pixel size let's go with scale
441:59 - with screen size then for the reference
442:01 - resolution I like to use 1920x1080
442:05 - and finally unlike to fully match with
442:07 - the height basically this means that
442:08 - objects in the canvas will be scaled if
442:11 - the height changes for example let's add
442:13 - inside just a quick UI image just a test
442:15 - let's look in the game View
442:17 - so there you go there's the image let's
442:18 - just put on a different color okay so
442:20 - there's the image and note how if I
442:23 - modify the aspect ratio here so let's
442:25 - say I put it on 5x4 there go the
442:27 - horizontal side of the window change but
442:28 - note how the element was not scaled so I
442:31 - can put it even on free aspects so
442:33 - really wide and does not change the size
442:35 - whereas if I modify this if I modify the
442:37 - vertical size the image does indeed get
442:40 - Scaled up or down personally I like the
442:42 - setup because means that I only have to
442:44 - worry about positioning things
442:45 - horizontally if the vericon part gets
442:47 - changed everything gets automatically
442:48 - scaled okay so great so over here let's
442:51 - go back into 4G all right and let's get
442:53 - rid of the image all right back in the
442:55 - scene view let's quickly look at the
442:57 - canvas so we can select the canvas press
442:59 - the F in order to zoom out and also we
443:01 - can press the 2D button up here to go
443:03 - into 3D mode okay so here's our nice UI
443:06 - now inside the canvas let's create them
443:08 - to game object call it the delivery
443:10 - manager UI then in the inspector let's
443:13 - make it stretch to occupy the whole
443:14 - thing so let's put zero on everything
443:17 - okay so this window now occupies the
443:19 - entire screen
443:20 - now inside let's do just like we did a
443:22 - while ago for the plate icons meaning
443:24 - let's make a template that we can then
443:26 - clone but let's also put those templates
443:28 - inside of a container so first of all
443:30 - let's make the containers so a new empty
443:31 - game object
443:32 - of currently just the container the
443:34 - reason why I'm going with this approach
443:36 - is because I also want to have other
443:38 - objects outside of here if you remember
443:40 - how we did with the templates we can
443:42 - actually go there and see so let's go
443:45 - inside the prefabs inside the counters
443:46 - actually it's on the kitchen objects
443:48 - let's go inside the plate over here for
443:51 - the template basically we use the play
443:53 - tokens UI this main canvas as the
443:55 - container but if you remember how we did
443:57 - that in order to make sure we didn't end
443:58 - up with duplicate icons we always
444:00 - destroyed the previous one when we
444:01 - spawned a brand new one so every time we
444:04 - were cycling through the children of
444:05 - this object in order to destroy all of
444:07 - them except the template so over here
444:09 - we're going to use a container so that
444:10 - we can apply the logic only to the
444:12 - children of the container and that way
444:14 - we can have other objects outside of the
444:16 - container for example outside of here
444:18 - let's say we want some nice text just
444:19 - saying recipes and waiting so on
444:22 - delivery mansion let's make it a
444:23 - challenge down let's go into UI and
444:25 - let's make a text text mesh Pro and this
444:28 - is the first time that we're using text
444:29 - mesh Pro so this window pops out it's
444:32 - actually import mesh Pro Essentials okay
444:34 - just let it import okay that's it we
444:36 - don't need the examples are extras so
444:38 - let's just close this window and over
444:40 - here on this window let's name this the
444:41 - title text let's set the text to
444:43 - something like recipes waiting
444:46 - let's put it up there on the corner so
444:48 - let's anchor it on the top left corner
444:50 - also for the text I like to put it on a
444:52 - width and height of zero but of course
444:54 - that makes the text really vertical so
444:56 - then down here on the wrapping let's
444:57 - just disable it so there you go looks
444:59 - like that and let's put it over there on
445:01 - that corner now in scene view we are
445:03 - seeing things different so if you want
445:05 - to see what this looks like just go into
445:06 - the game View and over there yep we do
445:08 - see the recipes and let's just make it
445:09 - in bond so there you go just some nice
445:10 - text okay so that's our text and then
445:13 - for the container let's make inside the
445:15 - delivery template so let's create an
445:18 - empty game object let's go with the
445:20 - recipe template and for this one we're
445:22 - going to want to Anchor it to the top
445:24 - left corner so with the template
445:26 - selected over here in the inspector
445:27 - let's click and we want to click up here
445:29 - however we also want to set the pivot so
445:33 - let's make sure to hold down shift in
445:34 - order to set the pivot over there okay
445:37 - great that's exactly what we want so we
445:38 - want the template right on the corner
445:40 - then let's give it a size of say 250 by
445:43 - 100 okay now inside template we just
445:45 - need two things we want to name the
445:48 - recipe as well as the list of all the
445:49 - ingredients although before that let's
445:51 - actually make a nice visual for the
445:52 - background so a new UI image for the
445:55 - background
445:55 - let's make this one stretch to occupy
445:57 - the whole thing let's put everything on
445:59 - zero okay that's the background let's
446:01 - put it on a black we're just a little
446:03 - bit lower Alpha okay that's good then
446:06 - for name let's make a text field so
446:08 - inside the template let's create another
446:10 - text call it the recipe name text then
446:13 - over here let's put it a bit small so on
446:15 - the font size of maybe just 20 let's put
446:17 - it in bold
446:18 - and let's also again put the width and
446:20 - height of 0 and over here make sure to
446:22 - disable wrapping okay so that's the text
446:25 - so we've got it up there let's just
446:27 - anchor it to the top left corner okay
446:28 - great
446:29 - over here we can change the name to
446:31 - recipe and then what we need is the
446:33 - icons on here and for that we're going
446:35 - to do pretty much the exact same thing
446:37 - that we done on plate but before we do
446:39 - that logic let's just get this basic
446:40 - setup working so let's just position
446:42 - everything so first of all the container
446:45 - for all the templates let's anchor it on
446:47 - the top left corner and let's push it
446:49 - all the way over there and for
446:51 - positioning them let's use this time the
446:53 - vertical layout group so inside let's
446:56 - duplicate the template just to be able
446:57 - to see them okay so that's pretty much
446:59 - we want we can actually set the width
447:01 - and height both to zero and let's set
447:03 - the spacing to something like 30. okay
447:05 - so that's our basic UI now let's make
447:07 - the script to run this
447:09 - so over here in our scripts let's create
447:11 - a brand new C sharp script for the
447:13 - delivery manager UI let's go into the
447:15 - parent game object and let's attach your
447:18 - script let's open okay so now here first
447:20 - we need a field for the container
447:21 - another one for the template
447:24 - so let's do a serialized film private
447:27 - transform for the container
447:29 - and another one for the transform and
447:31 - this is going to be the recipe template
447:34 - then let's do pretty much same thing we
447:35 - did previously so first of all let's
447:37 - actually go on a way in order to hide
447:39 - the template so game objects set active
447:41 - into false okay so first we hide the
447:43 - template then let's make an update
447:45 - visual function so private void update
447:47 - visual
447:48 - and for updating we're going to do the
447:50 - exact same thing that we did so first
447:52 - let's cycle through the container and
447:54 - destroy everything except for the
447:55 - template so do a 40 inch transform child
447:58 - in the container
448:02 - and if the child is the template
448:05 - if so then we're going to continue and
448:07 - if not we're going to destroy the child
448:09 - game object okay so we have the cleanup
448:12 - now we need is the second through all of
448:14 - the waiting recipes so that means that
448:16 - over here on delivery manager we need to
448:18 - expose our waiting recipes on list so
448:20 - let's go down here make a function to do
448:22 - that probably going to return a list of
448:24 - recipes so get waiting recipe so list
448:28 - and we just return the waiting recipes
448:31 - on list
448:33 - okay great
448:35 - so now here on the UI we can now go into
448:37 - the delivery manager xsc static instance
448:40 - in order to get the waiting recipes on
448:42 - list so let's cycle through this so do a
448:45 - 40 inch for each recipe so recipe so in
448:48 - the waiting rest vsl list
448:51 - for each of them let's instantiate
448:54 - and let's spawn our recipe template
448:56 - spawn it inside the container and then
448:59 - we just need to set this to enabled so
449:01 - let's read the transform for the recipe
449:03 - transform we grab this one grab the game
449:05 - object and set active into true okay so
449:09 - like this the only thing missing is the
449:10 - text but that's okay for now
449:12 - let you see where we're going to call
449:13 - this function to update the visuals and
449:16 - as usual we want to be smart and write
449:18 - some good clean code so let's not do the
449:20 - dirty approach of just updating this on
449:22 - every single update instead let's only
449:24 - call this function when something
449:25 - actually changes so over here on the
449:27 - delivery manager let's just make some
449:29 - simple events
449:30 - so if I'm like event event handler
449:33 - let's go on recipes fund and another one
449:37 - call it on recipe completed
449:41 - and actually as soon as I add the event
449:43 - handler which also add the using system
449:44 - now here we have an interesting thing
449:46 - we've got a nice namespace Collision
449:48 - it's telling us that random is an
449:50 - ambiguous reference between Unity engine
449:51 - now random and system.r random that is
449:54 - because both these namespaces Unity
449:55 - engine and system both of them have a
449:57 - class named exactly random so the code
450:00 - here does not know which class we're
450:01 - trying to use to solve this component we
450:03 - really just need to be more specific in
450:06 - this case here we want to use the UNT
450:07 - engine version so let's just write the
450:09 - full name Unity engine.renom and yep
450:12 - that works okay so now let's fire off
450:14 - the events so first of all the own
450:16 - recipe spawns over here when we spawn a
450:18 - recipe let's invoke this event so this
450:21 - is ventar is not empty and let's also
450:23 - get rid of the log we know we need that
450:25 - okay now we could also add the wedding
450:27 - recipe on the event artist but in this
450:28 - case we don't need it just firing the
450:30 - event is enough and then down here when
450:32 - the players delivers something if the
450:33 - player delivers the correct recipe we
450:35 - remove it from the list and then let's
450:37 - fire off the event so on recipe
450:39 - completing let's invoke with this and
450:42 - event rx.mt okay so we have the event
450:44 - and down here we also don't need analog
450:47 - okay so that works and finally over here
450:49 - on the delivery man GUI let's just make
450:52 - a private void start on start going to
450:54 - the delivery manager access the static
450:57 - instance and listen to both these events
450:58 - so they spawned and let's also listen to
451:01 - the other ones the library manager
451:02 - instance on recipe completed
451:05 - when either of these work let's just go
451:07 - and update the visual so just like this
451:09 - let's also rename this because again
451:12 - instance doesn't sound like a very good
451:14 - name let's actually rename this to only
451:16 - remanager and same thing up here by the
451:18 - way I'm using the visual studio shortcut
451:20 - control RR in order to rename this to
451:23 - delivering manager
451:25 - and finally we also need to update the
451:27 - visual OnStar just make sure the
451:29 - previous ones do not show up okay that's
451:31 - it so like this it should be working we
451:34 - should be able to see no Visual and then
451:36 - as more our spawned we should be able to
451:37 - see each one being spawned until the
451:39 - maximum so let's see just over here in
451:41 - the UI let's make sure to drag the
451:42 - references so the container and the
451:44 - template and let's hit on play and okay
451:46 - right away actually it spawned one
451:48 - recipe it spawned instantly then after
451:50 - four seconds there you go a second one
451:52 - and after four seconds we should be able
451:54 - to see yep another one now four more
451:56 - seconds and we should see the final one
451:58 - and now no matter how long we wait it
452:00 - should no longer spawn anymore and yep
452:03 - that works alright awesome so the basic
452:05 - logic is working now let's handle the
452:07 - proper Logic on the template for that
452:10 - like I mentioned previously one approach
452:12 - would be over here you could go and do a
452:15 - transform.find
452:16 - the actual recipe name text then get the
452:20 - text mesh component and set it that
452:21 - would work but like I mentioned
452:23 - previously that would be very dirty not
452:25 - good at all we should avoid using find
452:27 - at any time and we should also avoid the
452:30 - individual logic from the total logic so
452:32 - let's do it properly and make a proper
452:34 - script to handle each spawn template so
452:37 - let's create a brand new c-sharp script
452:39 - call this delivery manager single UI
452:42 - single just because it refers to a
452:44 - single recipe and also right now we
452:46 - already have quite a few UI scripts so
452:48 - let's organize our project again so
452:50 - let's organize new folder for the UI and
452:54 - inside let's put all of our UI scripts
452:55 - so if we manage is single this one
452:57 - deployed icons white icons and the
453:00 - progress bar so let's put all of these
453:02 - nicely organized in the UI folder okay
453:04 - so with the script let's go into the
453:05 - recipe template and attach the script
453:07 - now let's open and over here let's begin
453:09 - by adding a film for our text so a
453:12 - serialized field
453:13 - and over here it's also very important
453:16 - for the text we are not using the text
453:19 - inside DNT engine.ui this is the in
453:21 - Legacy text it is not text mesh Pro so
453:24 - this is not what we were using instead
453:26 - we want to use text mesh Pro U going
453:28 - which is inside TM Pro
453:31 - so we need to go up here and add using
453:33 - TM Pro and now we can use this type and
453:36 - also make sure you're using text mesh
453:37 - Pro ugui and not text mesh Pro this one
453:40 - also exists but don't mix these two
453:41 - these are two very different types if we
453:44 - go over here in the editor and if
453:47 - outside the canvas if I just create and
453:49 - create new 3D object a new text object
453:51 - if I do that then if we look over here
453:54 - in the inspector we see this one as a
453:55 - type text mesh Pro whereas for the ones
453:58 - that we're using inside the canvas if we
453:59 - unlock this is text mesh Pro it's a UI
454:01 - text so these are the two different
454:03 - classes within text mesh Pro you have
454:06 - text mesh Pro and text mesh Pro ugly
454:08 - we're working on the UI so we want this
454:10 - one okay so we named this the recipe
454:12 - name text
454:14 - okay that's it over here in the editor
454:17 - let's drag our reference all right so
454:19 - now this group let's make a function to
454:21 - set the recipe so a public void and
454:24 - let's call it set recipe SL
454:29 - they're going to receive a recipe so
454:31 - recipe so
454:33 - then we just go into the recipe name
454:35 - text and we set the text to recipe so
454:37 - dot recipe name
454:38 - okay so that's pretty much it now over
454:41 - here on the Y script when we instantiate
454:43 - our recipe transform let's get component
454:46 - of type of our
454:49 - delivery manager single UI and call set
454:52 - recipe so and pass in the recipe so okay
454:55 - so let's see if the name shows up any
454:57 - operator wait does show up so we can see
454:59 - that we generate a cheeseburger recipe
455:00 - and right now a mega burger recipe okay
455:03 - great so all that's left are the icons
455:05 - on here so like I said that is going to
455:07 - be yet another usage of our template
455:10 - pattern
455:11 - so inside the recipe template let's
455:13 - create an empty game object currently
455:15 - the icon container and then inside that
455:18 - let's make the template and template is
455:20 - just going to be an image so we can just
455:21 - create an image to our way
455:23 - called the ingredient image let's scale
455:26 - it with a size of 40 and 40. let's put a
455:30 - image by default just like that and on
455:32 - the icon container let's put the width
455:34 - of zero height of zero and let's put a
455:36 - horizontal layout group put it over
455:39 - there on the left side and we can create
455:41 - a bunch more just to see how it looks
455:43 - okay so that's pretty much it now over
455:45 - here on the single script let's add a
455:48 - serialized field private transform for
455:51 - the icon container another one for the
455:54 - icon template
455:56 - then we do the same thing as usual so
455:58 - when we set the recipe so let's first of
456:00 - all clean up the container so let's do a
456:02 - 40 inch transform child in the icon
456:05 - container
456:07 - and if the channel is the template
456:10 - then we want to continue and ignore it
456:12 - if not we want to destroy the child.game
456:14 - object okay so that's the cleanup
456:17 - and then let's do a four inch kitchen
456:19 - object as so
456:21 - in the recipe so dot kitchen object.zone
456:25 - list
456:26 - second through all of this let's
456:28 - instantiate our icon template
456:31 - instantiate it inside the icon container
456:34 - so this is going to be the transform for
456:36 - the icon transform
456:38 - then as usual we need to go into the
456:40 - game object set active in order to
456:41 - enable it
456:43 - and also let's go up here make a private
456:45 - way to wake and on awake the icon
456:47 - template game object let's disable it
456:50 - okay we don't want the template to be
456:52 - visible
456:53 - okay so we instantiate the template we
456:56 - set it as active then since this one
456:59 - just has an image we can just do a get
457:01 - component of Type image
457:03 - that's image not image conversion
457:06 - so image so it's this one the one inside
457:08 - Unity engine.ui so let's get this image
457:11 - and let's modify the Sprites and set it
457:14 - to this kitchen object so that's right
457:16 - okay so that's it that should do it
457:18 - let's test over here in the editor let's
457:20 - just go into the template let's drag the
457:22 - container reference and the template
457:24 - reference and let's also rename this
457:26 - instead of ingredient image put icon
457:28 - template just to be a bit more clear and
457:30 - we can get rid of the other ones or
457:31 - leave them doesn't really matter okay
457:33 - great so let's hit on play and see and
457:36 - yep right away does work so we can see a
457:37 - burger is composed of a burger and a bun
457:40 - a satellite yep there you go some sliced
457:42 - cabbage and sliced tomatoes then
457:44 - cheeseburger same thing as the burger
457:45 - with some cheese and then another Burger
457:47 - let's just deliver until we see the mega
457:49 - Burger so let's deliver a cheeseburger
457:52 - let's cut it
457:54 - get this get some bread place it in
457:57 - there pick it up before it burns that's
457:58 - a cheeseburger so that one should vanish
458:00 - and if they're good does vanish let's
458:02 - see something else not cheeseburgers so
458:04 - let's keep doing until we get a Mega
458:06 - burger just see that everything works
458:08 - so let's deliver a regular burger okay
458:11 - now let's deliver a regular salad
458:17 - okay just pick up like that like that
458:19 - and drop it
458:21 - okay let's see
458:23 - any up there it is the Mega butter all
458:25 - right great so the visual logic is fully
458:28 - working and the delivery logic all of it
458:30 - is working
458:31 - so I can deliver the right recipes and
458:33 - get rid of them from the recipe waiting
458:35 - list and more are spawned every time
458:36 - here we can see the name of the recipe
458:38 - as well as all of the nice icons okay so
458:41 - with all this our game is really taking
458:42 - shape everything is very close to being
458:44 - done
458:45 - one massive thing we're still missing is
458:47 - an obvious one which is sound so let's
458:49 - do that in the next lecture
458:52 - hey again quick intermission you're
458:54 - almost at the end so once again congrats
458:56 - for making it this far this is the
458:58 - second secret call out go ahead Post in
459:00 - the comments a timestamp and a nice monk
459:02 - Emoji it won't be fun to see how many
459:04 - people make it to this point by now you
459:06 - already know about the website I hope
459:07 - it's been very useful to you and you
459:09 - already know to ask any questions in the
459:11 - comments if you need help with anything
459:12 - so that's life for me to say right now
459:14 - is thanks for watching the course so far
459:16 - and I really hope you've already learned
459:18 - a ton there's only a bunch more lectures
459:20 - until we get to the final polish game so
459:22 - let's continue on the next lecture
459:25 - hello and welcome I'm your code monkey
459:27 - in this lecture we're going to add some
459:29 - audio to our game starting with a really
459:31 - nice music track okay so our game is
459:33 - already looking pretty good but
459:35 - everything is still way too silent so
459:37 - let's begin by adding some music adding
459:39 - this is actually extremely new in the
459:42 - included assets over here inside the
459:44 - sounds we've got a really nice music
459:46 - track I hired a musician to make this it
459:48 - sounds really good it's a seamless Loop
459:50 - so to add to our game it's going to be
459:52 - super simple we just want a constant
459:54 - never-ending Loop so let's begin by
459:56 - creating an empty game object call it
459:58 - the Music Manager
460:00 - let's reset transform keep things
460:02 - organized and let's add a component and
460:04 - we want the component an audio Source
460:06 - here it is this one like name implies
460:09 - this one acts like a source of audio
460:11 - you will note how by default on the main
460:13 - camera down here it already has an audio
460:16 - listener so the source plays some sound
460:18 - and The Listener listens to it now for
460:20 - here we just need to set these fields so
460:22 - for example on the autoclave let's make
460:24 - sure to drag the music audio okay great
460:26 - next over here and let's enable and play
460:28 - on a wink we wanted to start playing
460:30 - right wing and for this track we do want
460:32 - to enable looping okay great then for
460:35 - priority basically UNT has limited to
460:37 - how many sounds can be played at once if
460:40 - you play too many then some sounds won't
460:42 - play and which ones do you play is all
460:44 - based on priority we always want the
460:46 - music to play so let's put this one on
460:47 - Max priority
460:49 - then for the volume later on we're going
460:51 - to make a proper option screen to handle
460:53 - this
460:54 - but for now let's put it on something
460:55 - like 0.4 or 0.5 just make a nice
460:58 - background track then we have here the
461:01 - spatial blend for this music track we
461:03 - wanted to play the same regardless of
461:05 - where the camera is so let's make this
461:07 - all the way if only a 2d sound okay
461:09 - that's it we don't need to play around
461:11 - with any of the other settings and just
461:13 - like this if we are on play any up
461:15 - there's the music now if you're not
461:17 - hearing anything make sure that on the
461:19 - game view first of all that the game is
461:20 - actually selected make sure the scene is
461:22 - in Focus so over here I can move around
461:24 - so the game's in Focus then on game view
461:26 - we are on the top right corner make sure
461:28 - this sound icon is toggled if not then
461:31 - everything is muted and also again make
461:33 - sure like I mentioned on the main camera
461:35 - that it has the audio and listener
461:36 - component with all that yep you should
461:38 - be able to hear the music
461:40 - now this song is playing and it won't
461:42 - Loop forever just like we wanted
461:43 - personally I really like how it sounds
461:45 - I'm really happy with what the composer
461:47 - made it perfectly matches the E5 of the
461:49 - game so it really is this simple to add
461:51 - some music to the game let me just point
461:53 - out one thing also related to sound one
461:56 - of the things you can make is an audio
461:57 - mixer so for example on the project
461:59 - files let's create a brand new and let's
462:02 - find over here the audio mixer so there
462:05 - you go here is an audio mixer then you
462:06 - can double click to open up the audio
462:08 - mixer window and then over here you have
462:10 - the masternode
462:11 - and then you can create multiple groups
462:13 - so let's create a brand new groove for
462:15 - something else
462:16 - and then you can play around over here
462:18 - with the effects with the volume all
462:20 - kinds of things all kinds of effects
462:22 - everything then for each sound where you
462:24 - have the audio Source over here note how
462:25 - you have an output and for this output
462:28 - you can set it to play on the message so
462:29 - it plays on everything or set it on just
462:31 - one individual group so with this you
462:33 - could assign a group to one individual
462:35 - type of sound effect or the music or so
462:38 - on maybe you could even have your music
462:40 - split into multiple stems so there's a
462:42 - lot you can do but for me I'm not an
462:44 - audio engineer audio is probably the
462:46 - part of game development that I know
462:47 - least about I just stick with the
462:49 - absolute Basics but if you want to learn
462:51 - more definitely look into the audio
462:52 - mixer this is an extremely powerful tool
462:55 - but like I said for me I don't know how
462:57 - to work with it so I'm just going to
462:58 - stick with the basics so on the output
463:00 - let's revert back into none close the
463:02 - audio mixer and get rid of this and
463:05 - there it is music is playing and the
463:06 - wrong sounds really nice alright so here
463:09 - we very easily added some music to our
463:11 - game this lecture is actually super
463:12 - short because it is generally that
463:14 - simple now the next thing that we need
463:16 - is not going to be a little bit more
463:17 - complex and that is adding sound effects
463:19 - so let's do that in the next lecture
463:22 - hello and welcome I'm your code monkey
463:24 - in this lecture we're going to add some
463:27 - sound effects for our game okay so
463:29 - previously we already added some really
463:31 - nice music now let's add a whole bunch
463:33 - of sound effects in the project files if
463:35 - we go inside the assets over here we've
463:37 - got all kinds of sound effects recently
463:39 - I heard the really nice sound designer
463:40 - to make all of these and I think they
463:42 - all sound really great so let's add them
463:44 - to our game now when it comes to sound
463:46 - effects there are two main ways to play
463:47 - a sound one is just like we did for the
463:50 - music so we can create a game object at
463:52 - the audio Source component and play it
463:53 - that's one approach but that basically
463:55 - requires pre-preparing the sound objects
463:58 - so there is another simpler way that
464:00 - just requires one line of code so let's
464:02 - begin by making a Sound Manager game
464:03 - object so a new empty game object for
464:05 - The Sound Manager let's reset the
464:08 - transform now let's make our script so
464:10 - let's go in the scripts folder create a
464:13 - brand new c-sharp script for The Sound
464:14 - Manager let's attach the script and open
464:17 - okay so now here let's make a function
464:19 - to play Simple sound so let's do a
464:22 - private void just call it play sound and
464:25 - over here the way we play sound through
464:27 - code is actually super simple we just go
464:29 - inside the audio Source class
464:31 - and in here there's a static function
464:33 - play clip at point this as you can see
464:35 - it takes an audio clip a vector 3 for
464:37 - the position and finally a volume so
464:40 - basically it won't play that sound on
464:41 - that position by default TNT already has
464:44 - 3D sound so if you play the sound on the
464:46 - left or the right side of the camera it
464:47 - won't play in the correct place also for
464:49 - the volume the further away it is from
464:51 - the camera the lower it will be and if
464:53 - we don't want the 3D sound we can just
464:55 - play it directly on top of the camera
464:56 - position okay so in this function let's
464:58 - receive our arguments so for the audio
465:01 - clip
465:02 - it's going to be our audio clip
465:04 - then let's receive the vector 340
465:06 - position and let's also receive an
465:08 - optional one for the volume
465:11 - let's just default this to 1f okay so
465:13 - here we just pass this in into our
465:15 - function so the position and the volume
465:17 - okay great so now let's call this nice
465:19 - function and for example let's start
465:22 - with a simple one so let's start with
465:23 - the delivery sounds so over here on the
465:25 - delivery manager script down here we
465:28 - have the logic for delivering a recipe
465:30 - and over here we know when we completed
465:32 - a successful recipe or when we failed
465:34 - and the player delivered a wrong recipe
465:36 - so this is where we want to play some
465:38 - sounds and again here we have yet
465:40 - another very important clean code
465:42 - question
465:42 - we could definitely call the play sound
465:45 - function directly from here that would
465:47 - work but of course that would make this
465:48 - class tightly coupled with The Sound
465:50 - Manager for a simple game on this scale
465:53 - that approach can work just play sounds
465:55 - directly from the logic code however
465:57 - again to make things properly we should
465:59 - really separate the logic from the sound
466:00 - just like we separated in logic from the
466:02 - visuals so instead let's not call the
466:05 - sound directly from here instead let's
466:07 - make two more events
466:09 - so let's make one on recipe success
466:12 - another one on recipe failed
466:15 - okay so now let's fire off these events
466:18 - so over here we have the success so on
466:20 - recipe success and if we get down here
466:23 - then we have a fail so on recipe fail
466:25 - okay great we have two events now back
466:28 - here on The Sound Manager we can just
466:30 - listen to those so let's do a start go
466:32 - into the delivering manager access the
466:34 - instance and listen to the on success
466:36 - and on failed events let's listen to
466:39 - that one delivery manager instance on
466:41 - recipe film listen to both of these
466:43 - again let's write some good clean codes
466:46 - so let's rename this one instead of
466:48 - instance let's put it delivery manager
466:50 - and same thing on this one also name it
466:54 - correctly delivery menu
466:56 - okay great so now when you have this we
467:00 - want to call and play sound
467:02 - and now I want to pass in a reference to
467:04 - the recipe film sound so technically one
467:07 - approach would be appear to add a
467:08 - serialized film for an audio clip that
467:10 - would work but since we've already done
467:12 - that so many times in this course here
467:14 - let's use a different approach that I
467:15 - also like to use
467:17 - let's create a scriptable object to home
467:19 - the reference to all of our sounds so
467:21 - similar to how we Define the script
467:22 - object on all of our recipes let's just
467:25 - comment this out just make sure the code
467:26 - compounds okay great so back here in the
467:28 - editor let's make a new script more
467:30 - object type so let's create a brand new
467:32 - c-sharp script
467:33 - for the audio clip refs script long
467:36 - object now here let's make this a simple
467:39 - scriptable object with a create asset
467:42 - menu
467:43 - okay so now for the fields if we
467:46 - unlocking the S over here the audio
467:47 - design that I hired actually made
467:49 - several variations for each sound so
467:51 - we've got multiple chops multiple
467:53 - delivery fails and so on
467:55 - so back in the code here instead of
467:56 - storing a reference for a single audio
467:58 - clip let's store an array for all of
468:01 - them so we have the chop then we have on
468:03 - the other Solutions and all of the
468:06 - references
468:07 - so there's a job there's the delivery
468:09 - fail
468:10 - then we have delivery success then we
468:14 - have footsteps
468:17 - then the object drop then the object
468:20 - pickup
468:21 - then we have the stove Sizzle although
468:24 - this one is just one then we have the
468:26 - trash and finally we have the warning
468:30 - alright so these are all of the sound
468:32 - references we're going to use back in
468:34 - the editor let's just create the object
468:36 - so on the script mode objects let's
468:38 - create a brand new one let's make it of
468:40 - audio clip per episode
468:42 - just name it audio clip refs so
468:46 - and over here let's just write the
468:47 - references so let's use that quick ENT
468:49 - tip in order to unlock the inspector now
468:51 - I can select all the chops and drag them
468:53 - all the delivery fails drag them it's
468:56 - only re-success drag it then for all of
468:59 - the footsteps after that are all of the
469:02 - object drops then the pickups then we
469:06 - have the sizzle which is just one
469:08 - finally we have the trash and the
469:11 - warning okay those are all the
469:13 - references so our script on object now
469:15 - has all of the data we need let's unlock
469:18 - the inspector okay and back in the code
469:20 - here on The Sound Manager let's make
469:22 - another version of this function so
469:24 - let's make one play sound except instead
469:25 - of receiving an audio clip it receives
469:27 - an array of audio clips
469:29 - then basically we just call the other
469:31 - function so we call the other place on
469:33 - function and pass in an audio clip from
469:35 - this array so let's actually rename this
469:36 - so audio clip array
469:38 - and let's pass in an audio clip from
469:41 - here so do a simple random.range
469:44 - between 0 and the array down length
469:47 - pressing the position and the volume
469:50 - okay so just like this now we need is a
469:53 - reference to our suitable object so it's
469:55 - generalized film private of the audio
469:57 - clip refs SL
470:00 - okay we have this then here in the
470:02 - editor and let's just assign the
470:04 - reference so the audio clip refs okay
470:05 - great and over here when we have the
470:07 - recipe failed let's go into the audio
470:10 - clip refs
470:11 - and let's pick up this one instant
470:13 - delivery fail
470:14 - and then the other one is going to be
470:16 - delivery success
470:17 - for the position let's just default to
470:19 - the camera dot main transform that
470:22 - position
470:24 - so like this it sounds like exactly on
470:26 - top of the camera okay so let's test and
470:29 - see if it all works okay so here we are
470:31 - and let's do a wrong delivery now quick
470:33 - warning if you're following along or if
470:35 - you're just watching the video this
470:37 - sound will probably be way too loud but
470:38 - let's test
470:40 - so if I just pick up the plate and I
470:42 - just deliver an empty plate yep there
470:44 - you go there's the sound
470:46 - and now if I deliver a correct one so
470:47 - someone wants a salad so let's cut a
470:50 - nice salad
470:51 - chop that chop this pick up the plate
470:54 - pick up that one and that one don't be
470:56 - the correct salad
470:57 - any of that I go with those were all
470:59 - right great so the sound effects work
471:01 - they played perfectly but they're a bit
471:03 - too loud basically that's because these
471:05 - sounds were designed to be played in the
471:06 - world rather than on top of the camera
471:09 - so when we play the sound let's actually
471:10 - play it on the position of the delivery
471:12 - counter
471:13 - here is the delivery counter script and
471:16 - based on our design we're only going to
471:18 - have a single military counter so we can
471:19 - just make this a Singleton
471:21 - so as usual public static of type on
471:24 - Livery counter call it instance where
471:26 - they probably get and a private set
471:29 - then on privatoid awake
471:32 - let's just set the instance equals this
471:35 - okay so over here on The Sound Manager
471:38 - we can just grab delivery counter
471:40 - delivery counter and we just go into
471:42 - Library counter and grab the static
471:44 - instance
471:45 - and then for the sound position we can
471:47 - just go into delivery counter access the
471:49 - transform that position
471:51 - okay so just like this on that one and
471:53 - on this one
471:58 - okay so it says now it shouldn't be as
472:00 - loud
472:01 - okay so here we are and let's do a wrong
472:03 - delivery any hope it does work
472:06 - now let's be successful delivery so
472:08 - let's make a nice cheeseburger so grab
472:10 - some cheese slice it grab plate just
472:14 - need some bread
472:16 - and delivered any of there you go it
472:18 - worked all right awesome
472:20 - okay so this is really it this is how
472:22 - we're going to play our simple sounds
472:24 - now there are some that are going to
472:26 - require more logic like the footstep
472:27 - sounds and the stove Sizzle but first
472:30 - let's begin by adding the simple ones
472:32 - so let's begin with the chop sounds this
472:35 - is super simple we just need to go over
472:37 - here onto the cutting counter and
472:39 - actually we already have the uncut event
472:41 - that we made previously this was used to
472:43 - spawn the visual so we can also use it
472:45 - to spawn these sounds
472:46 - however there's actually one difference
472:48 - we're going to have multiple cutting
472:50 - counters and this one as you can see
472:53 - this one is not a static event meaning
472:55 - each different counter is going to have
472:57 - each list of listeners and we really
472:59 - don't want to have to subscribe to every
473:01 - single one of the counters individually
473:02 - so what we can do is instead of making
473:04 - it a regular event that belongs to each
473:06 - instance of a cut encounter we can make
473:09 - a static event which won't belong to the
473:11 - entire class but we still want to leave
473:12 - this one just for the visual so let's do
473:14 - another one a public static event event
473:17 - handler
473:18 - and let's call it on any cut basically
473:21 - for any static events that belong to any
473:24 - object type I like to add the keyword
473:25 - any we're going to fire this event when
473:28 - any cutting counter is going to trigger
473:30 - a cut action so where we fire this event
473:33 - is exactly the same thing so over here
473:34 - we've got the uncut and let's do the
473:35 - exact same thing so on any cut with this
473:38 - an event R is not empty okay so we have
473:40 - our nice static event and over here on
473:42 - The Sound Manager let's listen to it so
473:44 - let's go into the cutting counter again
473:46 - we're going to access through the class
473:47 - name and let's listen to the on any cut
473:50 - event and over here let's just play the
473:52 - sound so let's play the sound let's go
473:55 - inside the audio play prefsl and let's
473:57 - grab the chop sound then for the
474:00 - position
474:01 - we want to know who fired this event and
474:03 - by following the c-sharp standard over
474:04 - here we already have the object sender
474:07 - so we know this was the object that
474:08 - fired this event and we know this is
474:10 - going to be of type cutting counter so
474:11 - we can just get cutting counter cutting
474:14 - counter and we just grab the sender as a
474:16 - cutting counter
474:18 - okay so we have this and then over here
474:19 - very simple access transform that
474:21 - position
474:22 - okay that's it great
474:24 - that won't play The Cutting sound on
474:26 - that position on that cutting counter
474:28 - okay great now let's handle the player
474:31 - picking up something and for that let's
474:32 - go over here onto the player class and
474:35 - the way we set up the kitchen object
474:36 - parent system is actually already
474:37 - perfect for this
474:39 - down here we have a function so if we
474:42 - scroll down Yep this function set
474:43 - kitchen object this one is called
474:45 - whenever the player receives a kitchen
474:47 - object which means really when the
474:49 - player picks up something so if this
474:51 - kitchen object is not known then that
474:53 - means the player picked up something so
474:54 - let's do that
474:55 - so up here and let's make the event
474:57 - so a public event event handler
475:01 - call it on pick something
475:04 - and then down here just to be test so if
475:06 - the kitchen object is not known so if
475:08 - the player did pick up something then
475:10 - let's just fire off this event so just
475:12 - view our usual invoke with this an event
475:15 - RX rmt
475:18 - okay so that's great
475:20 - then on the sound management let's just
475:22 - listen to it so let's go into the player
475:24 - Quest let's access these static instance
475:26 - and let's listen to the on picked up
475:28 - something event and again let's rename
475:31 - this to a proper name so player on pick
475:33 - something
475:34 - and over here let's just play the sound
475:36 - and for the sound go into the refs and
475:39 - grab in this case the object pickup
475:42 - and for the position let's just go
475:43 - player
475:44 - dot instance and gravity transform that
475:47 - position
475:48 - okay that's it next for item dropping
475:51 - now we can only drop items on a counter
475:53 - so over here we have the base counter
475:55 - class and again we have the same thing
475:57 - so we have the set kitchen object and
475:59 - again the same thing as with the cutting
476:01 - counter we don't want to be required to
476:03 - listen to every single counter we just
476:05 - want to listen to one event so let's
476:07 - make it up here so if I'm like static
476:09 - event of type event handler
476:11 - and let's name it on any object placed
476:15 - here
476:17 - and then down here when we have the set
476:19 - kitchen object we do the usual if
476:21 - kitchen object is not known if so then
476:23 - let's fire off this event
476:28 - okay great
476:30 - and on the song Imagine let's listen so
476:32 - go into the base counter on any object
476:34 - placed here when that happens play the
476:37 - sound then let's go into the other top
476:39 - prefs and this one is the object drop so
476:42 - that one and for the position let's do
476:44 - the same thing we did so we cast the
476:46 - base counter equals the sender as a base
476:49 - counter and then we go into the base
476:52 - counter and let's grab the transformed
476:54 - up position okay so we just need one
476:56 - more special counter type
476:58 - here we have the trash counter and this
477:01 - one it never really changes the parent
477:02 - it just destroys the object it's over
477:04 - here on the trash counter itself let's
477:06 - fire off an event but again let's make
477:08 - it static even though we're only going
477:09 - to have one trash but make it Saturday
477:11 - just to be able to support multiple so
477:13 - public static event
477:15 - Handler
477:17 - on any object trashed
477:22 - and then over here just fire off this
477:24 - event
477:25 - so invoke with this and eventar is not
477:29 - empty okay
477:30 - so now if we go into The Sound Manager
477:33 - and over here once again the trash
477:35 - counter on any not the on any object
477:38 - place but on any object trashed
477:41 - and on this one let's do pretty much
477:43 - exactly the same thing so let's copy
477:44 - this the sound is going to be the trash
477:47 - sound instead of a bass counter
477:49 - we could just cast it to a base counter
477:51 - but let's make it proper so let's make a
477:53 - trash counter as a trash counter and
477:55 - this is a trash counter okay great
477:58 - that's it so these are all of our basic
478:00 - simple sounds as you can see all the
478:01 - logic is super simple so let's test and
478:03 - see if it all works
478:05 - okay so first of all let's pick up an
478:07 - object so if I go into a container and I
478:09 - pick it up and if there you go there's
478:10 - the sound now if I drop it somewhere and
478:13 - if there's a sound now for the trash
478:14 - pick it up drop it on the trash anyhow
478:17 - there's the trash down okay great
478:19 - then also let's check out the cutting so
478:22 - if I pick up some cheese drop it there
478:23 - and cut and if there go got a really
478:26 - nice cutting sound okay so far so good
478:29 - now let's handle the more complex ones
478:31 - starting off with the stove for this one
478:33 - the sound is meant to be on looping but
478:35 - only when the sub is on so we don't want
478:37 - to just play once but play and stop
478:40 - playing depending on the state of the
478:41 - stove
478:42 - so for this one instead of spawning the
478:44 - sound through code let's actually spawn
478:46 - it on the object itself so let's go
478:48 - inside the stove object let's go on the
478:51 - stove counter and open up the prefab and
478:54 - inside this prefab let's create a brand
478:56 - new empty game object name it sound
478:59 - let's reset transform make sure it's on
479:01 - zero zero zero okay great now let's add
479:04 - an audio Source component
479:06 - and for the auto clip let's use the pan
479:08 - sizzle let's make sure to not talk on
479:11 - play on awake but we do want it to Loop
479:13 - and let's also make it a 3D sound
479:17 - okay so that's the basic setup Now to
479:20 - control this let's make a script so
479:22 - let's go into our scripts folder and
479:24 - let's create a brand new c-sharp script
479:26 - come with the stove counter sound
479:29 - let's attach the script over here and
479:32 - let's open it
479:33 - so now here first let's grab the audio
479:35 - Source component so we've got a private
479:37 - audio source for the audio source and
479:40 - just go on awake and audio Source
479:43 - sequence get component of type audio
479:45 - Source okay
479:46 - then we're also going to need a
479:48 - reference to the stove counter so let's
479:50 - uh appear a centralized film private
479:53 - of type stove counter for the stove
479:56 - counter
479:57 - then back in the editor let's drag that
479:59 - reference all right
480:00 - now on the stove counter over here we
480:02 - already have the states and we have the
480:04 - on-site change event again the same one
480:06 - that we use to modify the visual so on
480:08 - the sound lets you pretty much examine
480:10 - the same thing
480:11 - over here let's do a private void start
480:14 - and on certain let's go into the stove
480:15 - counter and listen to the on stay
480:17 - changed event
480:19 - and basically when this changes we want
480:22 - to check if it's frying or fried if so
480:24 - then we want to play the sound if no
480:25 - then we don't want to play it so let's
480:27 - define a ball call it play sound and
480:29 - we're going to play if the state equals
480:32 - we are frying or the state equals that
480:36 - it is currently fried and about to burn
480:39 - Okay then if we have a play sound
480:42 - then let's go into the audio source and
480:44 - comp play
480:47 - and if not then let's go into audio
480:49 - source and call pause
480:51 - all right so that's it pretty simple
480:53 - let's just make sure to save our prefab
480:55 - go back outside and let's start on play
480:57 - and okay four stars there's no sound
481:00 - playing now if I pick up some meat and I
481:01 - drop it on there
481:03 - and if there go there's a sizzling sound
481:05 - and continues going and now it is still
481:07 - sizzling but if it burns it should stop
481:09 - so if I go
481:11 - and if there go the sizzling soundstomp
481:12 - all right awesome so let's take this one
481:14 - out let's actually trash it now let's
481:17 - pick up another one let it cook
481:19 - and once let's go pick it up and there
481:21 - you go the sound of the Stomp all right
481:22 - awesome
481:24 - so we just have one more final sound
481:26 - remaining that's the footsteps
481:28 - by the way the warning sound is going to
481:30 - be added during the Polish lecture
481:32 - for the footsteps we want very much the
481:34 - same thing that we did on the stove so
481:37 - we're going to want a script to handle
481:38 - that logic
481:39 - but this time we don't need an audio
481:41 - Source on the player we're going to use
481:42 - the same play Method as the other ones
481:45 - let's just make a script to run the
481:47 - sounds so let's make a new c-sharp
481:48 - script for the player sounds
481:51 - let's go into the player game object and
481:54 - attach the sound okay so here let's
481:56 - first grab the player reference
481:58 - so private player player and on private
482:02 - way the way let's get the component of
482:03 - type player and assign it to the player
482:06 - okay
482:08 - then for the footsteps basically we want
482:10 - to play them every certain amount of
482:11 - time so let's do appear a private Cloud
482:13 - for the footstep timer another one for
482:16 - the footstep tower Max and let's say you
482:18 - want to play say 10 times per second
482:21 - then we do a basic update and on update
482:23 - footstep timer countdown by time.com
482:26 - time and if the footstep timer is under
482:29 - zero
482:31 - then let's reset it so set it to the
482:33 - maximum
482:34 - and it's in here that we're going to
482:36 - play the sound so now here we have two
482:38 - options we can fire an event here and we
482:41 - can listen to it on The Sound Manager so
482:42 - exactly the same thing that we've been
482:44 - doing previously or we can just trigger
482:46 - the sound directly from here doing that
482:49 - will mean that this class is tightly
482:51 - coupled with The Sound Manager usually
482:53 - we want to avoid tight couplings however
482:55 - in this case the player sounds class
482:57 - this one is really only meant to exist
482:58 - alongside the sound manager so in this
483:01 - case it's perfectly fine to totally
483:02 - coupon them so let's play the sound
483:04 - directly from here which means we need a
483:06 - reference to The Sound Manager we can
483:08 - make a serialized field or just make
483:09 - this a Singleton so let's do that
483:12 - so a public static type Sound Manager
483:16 - name it instance where they probably get
483:18 - any private set
483:21 - then on private void awake
483:25 - we just set the instance equals this
483:27 - okay
483:28 - so then over here we can just access it
483:30 - so just go into the sound manager access
483:32 - the instance and we call play sound
483:35 - which we actually need to make public
483:37 - however this function also takes a
483:39 - reference to the audio clip array
483:42 - so that means we need a reference to the
483:43 - audio clips so again we have multiple
483:46 - options we could add over here on the
483:48 - player sounds at a serialized film for
483:50 - the footstep sounds or we can just make
483:52 - a specialized function over here on The
483:54 - Sound Manager both options can work just
483:56 - fine let's go with the second one just
483:58 - to be different so just make here a
484:00 - public void play
484:02 - footstep sound
484:05 - we're just going to receive a vector 3
484:07 - for the position
484:09 - and then we just call play sound let's
484:11 - go into the audio clip refs ASL and
484:15 - let's pick up the footsteps and play it
484:17 - on this position
484:19 - and let's also receive the volume
484:21 - just appear a fault for the volume
484:23 - okay so that's right now we just need to
484:25 - call this function
484:26 - it's over here on the player instead of
484:28 - calling play sound let's go on the other
484:29 - one play the footstep sound
484:31 - then for the position that's the player
484:33 - transformed that position and for the
484:36 - volume I just exposed the volume just in
484:37 - case you want to make the footsteps a
484:39 - bit more sound or not
484:40 - but for now let's begin with one F and
484:42 - then see if that's waiting around as
484:44 - usual instead of using magic numbers
484:46 - let's define a fluid for the volume put
484:48 - it at 1f and over here use the volume
484:51 - okay great however you might be noticing
484:53 - an obvious issue here right now this is
484:55 - going to play non-stop obviously we
484:57 - don't want to do that we only want to
484:59 - play footstep sounds if the player is
485:00 - actually moving so this pre-semble we
485:03 - just need to ask the player if it is
485:04 - moving
485:05 - and we already did that so player is
485:08 - walking so if the player is walking then
485:10 - you play The Sounds if not we don't okay
485:12 - that's it so let's test so here we are
485:15 - and if I'm standing still there's no
485:16 - footsteps okay that's great and as soon
485:18 - as I move yep there you go we got some
485:20 - nice WhatsApp sounds
485:21 - all right great so with all that we
485:24 - added all of our sounds
485:26 - now here note how we mostly use this
485:28 - method of going into the audio source
485:30 - and using the play clip at Point
485:31 - function this one is great because it is
485:33 - so simple but it does have limitations
485:35 - specifically with regards to all of the
485:37 - options if we look on the audio Source
485:39 - component here we have all these options
485:42 - so you can use an output use an audio
485:44 - mixer like we saw in the previous
485:45 - lecture we can play around priority play
485:48 - around the pitch make it 2D or 3D play
485:50 - around over here with how the sound
485:51 - falls off so tons and tons of options
485:54 - that you can't really access if you use
485:55 - that simple function so one approach if
485:58 - you need these options you could make
486:00 - each sound a prefab so make a prefab for
486:02 - each different audio clip and then
486:04 - instead of calling that function you
486:05 - would simply instantiate that prefab to
486:07 - spawn that audio so if you have lots of
486:09 - options depending on how complex you
486:11 - want your sound to be
486:12 - but for a simple game and for simple
486:14 - sounds this one line of code is super
486:16 - simple
486:17 - alright so here we have added sound
486:19 - effects to our game that component with
486:21 - the music that we had previously already
486:23 - makes everything sound so much more
486:25 - alive it's really starting to look like
486:26 - a proper game
486:28 - the one thing we still don't have is
486:30 - some kind of game start and game and
486:32 - scenario so let's have that in the next
486:34 - lecture
486:37 - hello and welcome I'm your code Maki in
486:39 - this lecture let's add a simple and
486:41 - beginning state to our game so right now
486:43 - we can play the game of the mechanics
486:45 - everything works perfectly and it's all
486:47 - been implemented however in the
486:49 - beginning of the game it just starts
486:50 - right away as it loads there's no start
486:52 - no countdown no time for the player to
486:54 - get ready
486:55 - someone sort that out with a simple
486:57 - countdown let's begin by making a
486:59 - general game manager script to handle
487:01 - all of our general game States so let's
487:03 - create a brand new c-sharp script
487:05 - and now here you could use the name game
487:07 - manager so you could use this name
487:10 - however for some reason yantian likes uh
487:13 - this custom icon when a script is named
487:15 - exactly game manager personally I don't
487:17 - like this I don't want it to be a
487:19 - different icon I want this script to
487:20 - look and behave just like any other one
487:22 - of my scripts so personally I don't like
487:24 - this but if it doesn't bother you then
487:26 - go ahead use it doesn't really change
487:27 - anything just a visual but in my case I
487:30 - prefer to give it a different name so
487:31 - sometimes I call it game Handler or
487:33 - other times just something related to
487:35 - this game like for example the kitchen
487:36 - game manager and just like that it won't
487:39 - have that custom icon just need to go
487:41 - inside and rename this to Kitchen game
487:43 - manager okay save the script and all
487:46 - right now let's make a game object to
487:47 - run it so a new game object with the
487:49 - same name let's attach the kitchen game
487:51 - manager and reset transform okay let's
487:53 - go now here we're going to Define all of
487:55 - the various game states that our game
487:57 - can be in so for that let's define an
487:59 - enum so a simple enum call it state
488:02 - and for the various States let's say we
488:05 - are first of all waiting to start then
488:08 - we are on countdown to start then the
488:11 - game is playing and then we have a game
488:13 - over okay so these are our states let's
488:16 - do a private void awake and on the
488:19 - waiting list of the state so we need to
488:20 - store a state for our state
488:22 - and on a week we set the state equals
488:25 - and let's begin on waiting to start by
488:27 - the way the point with this waiting to
488:29 - start say it will also be very important
488:30 - in the next video covering multiplayer
488:32 - basically we're going to wait until
488:33 - everyone is connected before we start
488:35 - the actual countdown but over here for
488:37 - now we're just going to wait a little
488:39 - bit on the waiting to start then we're
488:41 - going to trigger the countdown and then
488:42 - after some time trigger the game playing
488:44 - state so pretty much all of these states
488:45 - are going to be time based so let's make
488:47 - a simple timer so a private float for
488:51 - the waiting to start timer let's begin
488:54 - on something like 1f so we just wait for
488:57 - one second then let's make a private
488:58 - void update and let's make a state
489:00 - machine just like we've done previously
489:02 - so do a switch on our state
489:06 - in case we are on state DOT waiting to
489:09 - start
489:09 - if so then let's go into the waiting to
489:11 - start timer count it down by time dot
489:14 - Delta time
489:15 - then if the waiting to start timer if it
489:17 - is under zero if so then let's move into
489:20 - the state equal state DOT let's go into
489:22 - the countdown to start okay so that's it
489:25 - and the other states are going to be
489:26 - pretty much exactly the same so let's
489:27 - just copy this so we have the winning
489:29 - start and the countdown to start then we
489:31 - have the game playing and finally we
489:34 - have the game over and that one doesn't
489:35 - have anything so just like this like I
489:38 - said we could reuse the same timer but
489:40 - let's write our code nice and proper so
489:42 - let's make different timers for each so
489:44 - let's make three timers so we're going
489:46 - to have the countdown to start timer
489:49 - so countdown
489:50 - for this one let's see Fallen two three
489:52 - so we're going to wait three seconds
489:53 - before we start and then the game
489:55 - playing timer
489:57 - and for this one let's put it something
489:58 - short just for testing so let's put it
490:00 - just test and then down here let's just
490:02 - use them so on the countdown let's count
490:04 - down this timer on the game playing
490:06 - count down this timer when the countdown
490:08 - ends we go into game playing and when
490:10 - the game playing ends we go into game
490:12 - over alright so that's our super basic
490:15 - state machine just a bunch of timers
490:16 - super simple
490:17 - let's do a quick look just to see so
490:19 - over here just say debug.log and let's
490:22 - just print out the current state
490:24 - okay so just like this let's test and
490:26 - yep right away we are waiting to start
490:28 - after one second going to countdown then
490:30 - after three seconds go into game playing
490:31 - and now if we wait for 10 seconds
490:34 - after 10 seconds we should be able to
490:37 - see just a little bit and yep there you
490:39 - go we've got our game over okay great
490:41 - all the logic is working although we
490:43 - actually didn't change anything
490:44 - technically the game right now is on a
490:46 - game over but everything still works the
490:47 - same experience only so I can still play
490:48 - I can still do everything
490:50 - so let's sort them when we are in any
490:53 - state other than the game playing State
490:55 - we don't want the player to be able to
490:57 - interact with anything we want to leave
490:59 - it movement because that's usually nice
491:00 - and fun but we don't want it to be able
491:02 - to interact pickup objects or do
491:04 - anything so let's do that basically over
491:06 - here on the game manager let's just
491:08 - expose the function so public pool let's
491:10 - call this is game playing
491:12 - then over here pretty simple just return
491:14 - if the state equals state DOT gameplay
491:17 - that's it
491:18 - so now we can go into the player script
491:20 - so over here on the player script let's
491:23 - go down into the interaction function so
491:25 - over here we've got the interact
491:26 - alternate and the interact and on both
491:29 - of these basically let's just ask if the
491:31 - game is in the game playing state if so
491:33 - we want to interact but if not then we
491:35 - don't want to do anything so to access
491:37 - the game manager we could add a pure
491:39 - serialized field or as usual let's just
491:40 - make a nice Singleton so pure public
491:42 - static of type kitchen game manager the
491:45 - instance make a public get and a private
491:48 - set
491:49 - then down here on awake let's set the
491:51 - instance equals this okay so now over
491:54 - here on the player let's just go into
491:55 - the kitchen game manager access the
491:57 - instance and test is game playing
491:59 - and we're going to do an if if the game
492:01 - is not playing so if we are not playing
492:03 - we want to stop this so let's just
492:05 - return so if the game is not playing the
492:07 - code is going to stop executing here and
492:09 - same thing on the interaction so just
492:10 - like that we won't be able to interact
492:12 - with anything once we are not in the
492:14 - game playing State okay so here we are
492:16 - waiting to start nope I cannot pick up
492:18 - anything count down to start nope I
492:19 - can't and as soon as we go into game
492:21 - playing yep now I can't interact so I
492:22 - can cut a bunch of things
492:24 - and as soon as it goes into game
492:26 - overstate
492:28 - there you go currently in game over
492:29 - state so now if I try and interact nope
492:31 - can't do it okay awesome everything
492:33 - works perfectly
492:35 - so in terms of logic this is really it
492:37 - there's nothing else we need to do
492:39 - but of course right now the player would
492:40 - have no clue as to why sometimes they
492:42 - can grab and sometimes they can't so
492:44 - let's add a proper visual
492:46 - first let's add a visual to the starting
492:48 - countdown
492:49 - so let's do that as a canvas element so
492:51 - let's go inside our canvas create an
492:52 - empty game object name this the game
492:55 - start countdown UI let's press F to
492:59 - focus on the object press 2 to turn this
493:01 - into 2D okay so let's see and over here
493:03 - we really just need a text object so
493:05 - let's leave this one anchored on the
493:06 - center let's put the width and height
493:08 - both on zero we don't need that and then
493:10 - let's go inside create a new text object
493:12 - call this the countdown text and then
493:15 - inside let's just put a number so just a
493:17 - three
493:18 - let's put the width and height both on
493:20 - zero then down here let's put it in bond
493:22 - on a really big font size so let's say
493:24 - something like 250 okay really nice big
493:26 - number then let's also put it centered
493:28 - and down the middle okay that's right
493:30 - we've got our nice big countdown number
493:32 - also by the way when using text mesh Pro
493:34 - we can easily add a whole bunch of
493:36 - effects if we'll look down here we have
493:38 - the default text mesh Pro material and
493:40 - over here we can add an outline another
493:42 - line and so on so that's really great
493:44 - however there's one very very crucial
493:46 - thing when you want to add some effects
493:49 - always remember that the effects are
493:50 - being applied to the material meaning
493:52 - any text objects that are sharing this
493:54 - material all of them won't modify so for
493:57 - the most part usually you don't want to
493:58 - modify the default material if you do
494:01 - then everything using this default
494:02 - material will change like for example I
494:04 - want to add a nice thick outline to this
494:06 - one but over here I've got some regular
494:08 - text that is also using the default
494:10 - material so if I now add an upline and I
494:13 - increase the thickness and if there you
494:14 - go those also got an upline as well as
494:16 - this and if I wanted download make it
494:18 - quite a lot bigger there you go all of
494:20 - them modify because all of them are
494:22 - sharing the same material so usually you
494:25 - don't want to modify the default
494:26 - material if you want to add some kind of
494:28 - special effects always make sure to
494:30 - create a brand new material beforehand
494:31 - so over here let's remove the outline
494:34 - put it back on the dilation and let's go
494:37 - up here to create the brand new material
494:38 - first we need to find our phones over
494:40 - here on the font asset we can just click
494:41 - on it and we can see it over here
494:42 - highlighted on the project window so
494:45 - it's inside the text mesh profiler the
494:46 - resources phones and so on so here is
494:48 - the default font and inside this one is
494:50 - the font that we're using now in this
494:52 - font there's a nice little error icon
494:54 - and inside we can see the default
494:55 - material so let's duplicate this
494:57 - material although it's important make
494:59 - sure you duplicate the material and not
495:00 - the font so with this material selected
495:02 - I'm going to press Ctrl D and there you
495:04 - go it duplicates the material and over
495:06 - here let's give it some name so let's
495:09 - say this is material that I want to use
495:10 - for the start countdown
495:12 - so there you go just like this also one
495:14 - very very important thing the name of
495:16 - the material needs to include the font
495:18 - name otherwise it won't show up for
495:20 - example if I get rid of this the only
495:22 - version Sans SDF if I name the material
495:24 - just like this and now I'll look over
495:26 - here on the countdown text look on text
495:28 - mesh Pro here is the drop down menu for
495:30 - selecting material and over here note
495:32 - how that one does not show up so it is
495:34 - extremely important in order for it to
495:36 - show up in here it needs to have the
495:38 - same starting name so over here if I
495:40 - rename this material put Liberation
495:41 - sends SDF and then the name and now back
495:44 - in here now look and yep now I do see my
495:46 - material okay so that's great and over
495:48 - here we can add what kind of effects we
495:51 - want and it will only affect this one
495:52 - and not any others okay so for this one
495:55 - let's add a nice outline and let's make
495:57 - some nice thick numbers so over here on
495:59 - donation let's handle it by quite a
496:00 - little bit
496:01 - then for the outline color let's put it
496:03 - maybe on a blue something a bit like
496:06 - this okay let's push it back just a
496:08 - little bit okay I think that looks
496:10 - pretty good now if you want you could
496:12 - add even more effect to this I made
496:15 - another video covering how to use custom
496:16 - Textures in your font doing that you can
496:19 - just import the font directly into
496:21 - Photoshop and edit it with all kinds of
496:23 - effects for example in that method is
496:25 - example what I used in my game hypernite
496:26 - make the head counter look really nice I
496:28 - also have a tutorial specifically on
496:30 - that so if you want even more custom
496:32 - text definitely go ahead and watch those
496:33 - videos but anyways here we have our
496:35 - countdown text looking pretty nice now
496:37 - the number itself will be written
496:39 - through code so let's do that let's go
496:41 - into our scripts into our UI folder
496:42 - create a brand new c-sharp script for
496:45 - the game start countdown UI okay and
496:48 - let's select the parent object and
496:50 - attach the script now here first thing
496:52 - we need is a reference to that text
496:53 - object so let's add a serialized film
496:56 - private and again remember what I
496:58 - mentioned a couple of night years ago
496:59 - with regards to the types so we want
497:02 - xmesh Pro U GUI we want this one so it's
497:05 - going to be our countdown text and now
497:07 - for updating this text basically we just
497:10 - need to know the game state so we need
497:11 - to know when the countdown should show
497:13 - up and as usual let's use some nice
497:15 - events so over here on the kitchen game
497:17 - manager let's fire an event whenever the
497:19 - state changes
497:20 - so a public event event handler
497:25 - let's call it on stay changed
497:28 - okay just like this no need for the
497:30 - arguments so let's go down here whenever
497:32 - the state changes and let's just invoke
497:34 - this event so invoke this eventar is
497:36 - that empty
497:38 - so we change in there change in there
497:40 - and change down there okay that's it so
497:42 - now over here on the game start
497:43 - countdown let's see we've probably start
497:45 - and on start let's go into the kitchen
497:47 - game manager access the instance listen
497:49 - to the on say changed event as usual
497:52 - write some nice clean codes so let's
497:53 - rename this the kitchen game manager
497:56 - so when they say changes we basically
497:58 - want to show this if we are on the
498:00 - countdown to start so let's go here to
498:02 - the kitchen game manager and let's make
498:04 - another function so public boom is
498:07 - countdown to start active
498:12 - and we just return if the state
498:15 - equals the state DOT countdown to start
498:18 - okay so that's a nice simple function
498:20 - and on the UI script if the kitchen game
498:23 - manager
498:25 - if this one dot is countdown to start
498:27 - active
498:29 - if so then let's show if not then let's
498:31 - hide so else
498:33 - let's do a hide
498:35 - so let's make these functions so proud
498:37 - void show
498:39 - and a private void hide and on this
498:41 - let's just do the usual thing so game
498:43 - objects and active into true or over
498:45 - here set it into false and on start
498:48 - right after we subscribe to the event
498:49 - let's also hide it by default okay so
498:52 - that's the basic logic for showing or
498:54 - hiding it and now for the timer text
498:56 - technically over here once inside the
498:59 - countdown to start we could fire an
499:00 - event on every single update that would
499:02 - work but it would have some unnecessary
499:04 - overhead
499:05 - so instead another option is just make a
499:07 - function to expose it so let's go here
499:10 - make a public returning float get the
499:12 - countdown to start timer
499:15 - and we just return the countdown to
499:17 - start timer very simple so then over
499:19 - here on the UI script we can just make a
499:22 - regular proud void update and on update
499:25 - go into the countdown text in order to
499:27 - set the text
499:28 - and let's go into the kitchen game
499:30 - manager and let's get the countdown to
499:32 - start timer and just do A2 string okay
499:35 - so that's it super simple so on update
499:37 - we're going to constantly update the
499:39 - timer so let's see if this works
499:41 - back here in the editor let's just make
499:42 - sure to drag the countdown text
499:44 - reference and let's hit on play and okay
499:46 - waiting to start and after a bit yep
499:48 - there you go there's the number it's
499:49 - currently on countdown and now the game
499:51 - is playing so the show and high did work
499:52 - on the number seem quite a bit odd
499:54 - that's because over here on the settings
499:56 - we have wrapping enamel so now I just
499:58 - quickly disable this and let's test
500:00 - again
500:01 - sir we are waiting to start and there
500:02 - you go there's our countdown three two
500:04 - one zero and there you go gameplay
500:07 - okay so it did work now of course as it
500:10 - comes to the visuals it depends on what
500:11 - you want
500:12 - for example if you want to limit the
500:14 - decimals you can use over here the two
500:16 - string this one can include all kinds of
500:18 - string formats for example for
500:20 - displaying just two decimal places you
500:22 - can add the string format F2
500:25 - let's see what this looks like waiting
500:27 - for the countdown and there you go now
500:29 - it does Show with two decimals okay so
500:31 - this is one approach alternatively
500:33 - another format you can use is
500:35 - number sign Point number number and
500:38 - let's see this one
500:40 - and yep there you go now it looks like
500:42 - this
500:43 - so as you can see there's lots of things
500:45 - you can play around with when it comes
500:46 - to the two string formats but in our
500:49 - case I don't really want any decimals I
500:51 - really just want to see whole numbers so
500:53 - for that let's just seal out this number
500:54 - so in mathf.cl
500:57 - let's see on this one out and then just
500:59 - do a two string okay let's see
501:02 - so wait a bit and we got three two and
501:05 - one and there you go the game is winning
501:07 - alright awesome so here we have our
501:10 - waiting to start and the countdown to
501:12 - start all of that logic is working
501:13 - perfectly now the next thing we need is
501:16 - to handle the game end so let's do that
501:18 - in the next lecture
501:21 - hello and welcome I'm your code monkey
501:22 - in this lecture we're going to handle
501:24 - the game over State now for the game
501:27 - over State this is obviously a game
501:28 - design question for example you can make
501:30 - it so that each recipe had a timer
501:32 - attached to it and the player had to
501:33 - create that recipe within time limit
501:35 - then if they failed enough recipes you
501:37 - could trigger some kind of game over or
501:40 - for something more simple let's just do
501:41 - exactly what we did for the game start
501:43 - let's just do a basic countdown timer
501:46 - after the game is over let's pop up a
501:48 - game over window and show how many
501:50 - recipes the players delivered so let's
501:51 - do that let's go into our canvas and
501:54 - inside make an empty game object call it
501:56 - the game over UI then over here let's
501:59 - stretch it to occupy the entire parent
502:01 - like this now inside let's begin by
502:04 - making a UI image this is going to be
502:06 - the background let's put it in black
502:09 - with just a little bit of transparency
502:11 - and let's also stretches to occupy the
502:13 - entire thing
502:14 - so just like this then let's make some
502:17 - text so let's make a new UI text click
502:20 - the game over text
502:22 - and let's say just game over
502:24 - let's set the width and height both at
502:27 - zero then down here disable wrapping put
502:29 - it centered let's put it pretty big so
502:32 - maybe 135 put it a little bit higher
502:35 - then for some more text let's duplicate
502:38 - this let's call this the enlay bone
502:41 - recipes delivered text and over here we
502:44 - just say recipes
502:46 - delivered
502:48 - let's put this one a bit lower and quite
502:50 - a bit smaller
502:51 - say on 50 okay and also on this one
502:54 - let's put it in bold then change the
502:56 - color a little bit okay next let's make
502:59 - yet another text this one is going to be
503:01 - for the final number so let's call this
503:03 - recipes don't deliver text
503:06 - and this one is just going to have
503:07 - whatever number of recipes we've
503:09 - delivered and let's put it over here and
503:10 - quite a bit bigger okay so this is the
503:12 - game over window that we want also a
503:15 - quick note like I mentioned previously
503:16 - the Sorting order over here on the UI is
503:18 - based on the ordering the hierarchy so
503:21 - for the game over we want this one to
503:23 - show up on top of everything else so
503:24 - make sure the game over it is the last
503:26 - one over here on the UI make sure it is
503:28 - the bottom most child on the canvas okay
503:31 - now let's make a game object to run this
503:33 - so let's create a brand new script game
503:36 - over UI let's go into the object wait
503:39 - for the compilation and let's drag the
503:41 - script okay now here the only reference
503:43 - that we need is just for the text so
503:45 - let's just make a serialized film of
503:47 - type text mesh Pro ugly for the recipes
503:50 - delivered text here in the editor let's
503:53 - just drag the reference okay now let's
503:56 - make some show and height functions and
503:58 - also show it just on the game over so
504:00 - really we're going to do the exact same
504:01 - thing that we did over here on the game
504:03 - start countdown so let's actually copy
504:05 - exactly this let's go into game over UI
504:07 - pass the exact same thing Okay so we've
504:10 - got the show and hide functions we test
504:12 - and then over here on the state change
504:14 - instead of showing this one on the
504:15 - countdown we want to show it on the game
504:17 - over
504:18 - so let's go over here and just make
504:19 - another function so public goal is game
504:22 - over and we just return if the state
504:26 - equals the state that game over okay
504:28 - that's a function
504:30 - so over here if we are is State game
504:32 - over
504:33 - if so then we show if not we hide okay
504:36 - the last thing we need is just for the
504:38 - text so this is going to be the recipes
504:39 - only vertex so we're going to set this
504:42 - to something
504:43 - which really means that we just need to
504:45 - keep track of all of the recipes that
504:46 - have been delivered so until here onto
504:49 - the delivery manager script and let's
504:51 - just keep track so just a simple end so
504:53 - a private end for the successful recipes
504:56 - amount
504:58 - and then whenever we have a recipe
505:00 - success so let's go here into our
505:01 - delivery recipe function whenever we
505:04 - have a success let's just increase this
505:06 - by one okay so that's it now we just
505:08 - need a function to expose this so we
505:10 - probably can't for the get the
505:12 - successful recipes amount and just
505:14 - return the successful recipes amount
505:16 - okay so finally back here on the game
505:18 - over UI let's just print it so go into
505:21 - the delivery manager xsc static instance
505:23 - and get the successful recipes amount
505:26 - and of course we need the string so to
505:27 - string except for this one this is never
505:30 - going to change after the game is
505:31 - already over so let's not do this on
505:33 - update that would be quite wasteful so
505:34 - let's just do it up here so as soon as
505:37 - we have the game over we show we print
505:38 - the recipes and that's it okay so let's
505:41 - test so here we are waiting for the
505:43 - timer and let's wait and just wait five
505:47 - seconds for it to finish and we should
505:49 - see a zero so let's just make sure that
505:51 - works so after a little bit of time yep
505:54 - there you go we've got recipes all over
505:55 - zero okay
505:57 - now back here again let's try and
505:59 - deliver some recipes now so let's try
506:00 - and make a cheeseburger try it only for
506:02 - that
506:03 - cut this one pick up this one
506:06 - pick it up put it in there
506:08 - and okay quickly all right good and
506:11 - there you go we've got a one all right
506:13 - Awesome everything worked perfectly
506:15 - let's just add one more final element
506:17 - right now we cannot see what is the time
506:19 - left in the game so let's add a nice
506:21 - lock element
506:23 - so over here on the canvas let's make
506:24 - another empty game object
506:26 - let's name this the game playing clock
506:29 - UI
506:31 - and let's also put it behind the game
506:33 - over UI so let's put it above on the
506:34 - hierarchy so that it shows up behind in
506:37 - order to be able to see what we're doing
506:38 - let's also just hide the game over UI
506:40 - but only here on scene view so let's
506:41 - click on the I icon okay so here we have
506:44 - our window let's just anchor it on the
506:46 - upper right corner so let's put it
506:49 - somewhere in there then inside let's
506:51 - create a new UI image come with the
506:54 - background for the Sprite
506:56 - let's go with these circles right so
506:58 - let's click on the eye icon to show all
507:00 - the default Sprites and let's use the
507:02 - one included with the circle
507:04 - so you have this one let's also add a
507:06 - nice little outline so let's put it on 2
507:09 - 2 with phone Alpha and let's also add a
507:12 - nice shadow just nice visual so on five
507:15 - minus five like that and for the color
507:17 - let's also put it some kind of dark gray
507:19 - okay so this is our background now let's
507:22 - duplicate this so Ctrl d
507:24 - and let's rename this one the timer
507:26 - image and for this one let's give it a
507:28 - different color so maybe something like
507:30 - a blue so something like this okay and
507:33 - now over here on the image type instead
507:34 - of simple let's go with filmed let's
507:37 - choose Radeon 360. okay great and now
507:39 - over here we can play around the film
507:41 - Mount and this will be our timer then
507:43 - you can set it up however you want for
507:45 - me I'm going to choose to start from the
507:47 - top so as it starts the time we're going
507:49 - to countdown Until the End okay so
507:51 - that's great now let's make the script
507:53 - to run this so let's create the brand
507:55 - new c-sharp script same thing the game
507:57 - playing clock UI and over here let's
508:00 - just attach a script so now all we need
508:02 - is reference to our image
508:04 - so let's make a serialized field
508:08 - private image let's make sure to use
508:10 - this one the image inside Unity
508:11 - engine.ui this is going to be our timer
508:14 - image okay like this back here in the
508:17 - editor let's drag the reference all
508:19 - right now that we have this we need to
508:21 - ask the game manager to get the timer
508:23 - normalized so let's go over here onto
508:25 - the kitchen game manager and let's make
508:27 - a function to return just that so a
508:29 - public float let's call it get plane
508:32 - timer normalized or game point timer
508:35 - actually just to match the state
508:38 - so get this one and up here we have the
508:41 - playing timer we just need to define a
508:42 - maximum in order to be able to calculate
508:44 - the normalized value so let's duplicate
508:46 - this call it the game timer Max and set
508:49 - this one to 10 and this one leave it
508:51 - like this
508:52 - and down here when we change the timer
508:54 - when we go into game pointing let's set
508:56 - this one equals this.mex that way we
508:59 - only Define the timer just up here okay
509:01 - so with that now down here we can do the
509:03 - compilation so we can return the game
509:05 - playing timer divided by the game
509:07 - playing timer Max
509:09 - except just like this going to be
509:10 - inverted because for the game playing
509:12 - timer we're counting down instead of
509:14 - counting up so all we need to do is our
509:16 - simple just reverses so just one minus
509:19 - just like this okay great so we have
509:21 - this function and then over here on the
509:23 - clock just go private void update and on
509:26 - update let's go into the kitchen game
509:27 - manager the instance let's get that and
509:29 - we're going to use that on the timer
509:31 - image.fillment okay that's it super
509:34 - simple let's see okay here we are on the
509:36 - waiting to start all right waiting and
509:38 - as soon as we start if there you go
509:40 - there's the timer going and we can see
509:42 - it constantly increasing
509:43 - so it's at the halfway point
509:46 - and just a little bit more
509:49 - and there you go yep we've got the time
509:51 - over and we have our game over
509:53 - all right awesome so over here we
509:56 - implemented a really nice game over
509:57 - Saint we have a playing timer with an
510:00 - icui element and when it ends we get a
510:02 - game over window showing you a bunch of
510:03 - stats now with this working the next
510:06 - task is to have some kind of main menu
510:08 - so we can play again after the game is
510:10 - done so let's do that in the next
510:11 - lecture
510:13 - hello and welcome I'm your code monkey
510:15 - in this lecture we're going to make a
510:18 - super simple main menu and downloading
510:20 - system okay so every game needs a main
510:22 - menu so let's build one let's begin by
510:25 - making the scene so let's go into our
510:26 - scenes and create a brand new scene call
510:29 - this the main menu scene
510:31 - and okay here's our default scene now
510:33 - over here for the most part you really
510:35 - just want some basic buttons so nothing
510:36 - too special so let's create a brand new
510:39 - UI canvas and let's set up as usual so
510:41 - screen space overlay yep then let's go
510:43 - with scale with screen size 1920 by 1080
510:47 - and let's match with the height okay so
510:50 - there's our canvas now inside let's make
510:53 - an empty game object name this the main
510:55 - menu UI let's stretch it to occupy the
510:58 - entire thing so zero zero on everything
510:59 - okay
511:00 - now inside let's create a brand new UI
511:03 - button let's name this the play button
511:06 - then inside for the text let's say play
511:09 - Let's size the button to be quite a bit
511:12 - bigger so let's say 450 by 150 and on
511:15 - the text itself let's put it in bold
511:17 - only font size quite a bit bigger let's
511:19 - say 70 then let's also change the color
511:22 - let's put the text in White and the play
511:24 - button over here the normal color for
511:26 - the image let's put it on a dark gray
511:27 - then also over here on the button
511:29 - background let's add a nice outline
511:32 - let's put it on foam black say something
511:34 - like three three then let's make a
511:37 - Shadow and for this one five minus five
511:39 - okay so that's our basic button let's
511:42 - just anchor the button so choose the
511:43 - play button let's anchor it on the lower
511:45 - left corner and let's push it just a bit
511:48 - like this okay pre-symbal now let's
511:51 - duplicate this one push it a bit lower
511:53 - let's also make it just a tiny bit
511:55 - smaller so just 120 this is going to be
511:58 - our quit button so let's rename this to
512:00 - the quit button and inside for the text
512:02 - just say quit and put a bit more on the
512:05 - font size okay like this okay so we have
512:08 - the two basic buttons that we need now
512:10 - let's make this crypto random so let's
512:12 - make script with the same name so main
512:14 - menu UI so let's go into our script UI
512:16 - folder create new script for the main
512:18 - menu UI let's attach the script and open
512:21 - okay so now here let's begin by making
512:23 - serialized films for our buttons so it's
512:26 - always film private of type button
512:28 - inside Unity engine.ei this is the play
512:31 - button and then we have another one for
512:33 - the quit button okay back in the editor
512:35 - let's drag the references so that's the
512:37 - only button and the quit button okay now
512:39 - here in the code let's add some
512:41 - listeners to these buttons and let's do
512:43 - a private way to wake and on the way
512:44 - let's go into the play button and going
512:46 - to the on click event so the event when
512:49 - the player clicks on the button and
512:51 - let's add in listener and now we pass in
512:53 - The Listener now for here to do this we
512:55 - can add a function so we can make a
512:57 - private void Play Click we can define a
513:00 - function kind of like this and over here
513:02 - add it as The Listener so that's one
513:04 - approach or another alternative that
513:05 - personally I like to use is to use what
513:07 - is called a Lambda expression so instead
513:10 - of defining an external function down
513:11 - here we just go up here and directly
513:13 - with the finding Lambda so we open
513:15 - parameters to display the parameters for
513:18 - the function which in this case we have
513:19 - none so just open and close then we do a
513:22 - nice little arrow and then we have
513:24 - whatever we want to be our clear code so
513:27 - both the code that I have here and one
513:29 - that I have here both of these are
513:30 - exactly the same thing this one is
513:32 - called the unlimited expression which is
513:34 - also a type of delegate definitely go
513:36 - ahead and watch my video on C sharp
513:37 - delicates in detail it's yet another
513:39 - extremely powerful c-sharp feature I
513:42 - find them especially useful especially
513:44 - over here to setting the click listeners
513:46 - there's no need to make another function
513:47 - just use a Lambda expression that's it
513:49 - so over here I'm going to use that
513:51 - instead of an external function Okay so
513:53 - we've got the play and then let's also
513:55 - listen to the equip so on the quit
513:57 - button the exact same thing okay now
513:59 - first on the equip button it's actually
514:01 - very simple we just go into application
514:03 - and we call the quit function this will
514:05 - quit the game that's it very similar
514:07 - although one note if we actually test it
514:09 - like this so here is the game playing
514:11 - and if I click on quit and nope nothing
514:13 - happens now the logic is actually
514:15 - working we can see visually that the
514:17 - button is changing state so we are
514:19 - indeed capturing clicks however when the
514:21 - game is running inside the editor
514:22 - calling that function the
514:24 - application.quit doesn't do anything but
514:26 - if this were a phone bill then clicking
514:28 - on that would indeed close their game
514:29 - okay so now for the play button for this
514:32 - one it's also very simple we just need
514:34 - to go inside the scene manager which is
514:37 - inside the unity engine.scene management
514:38 - we just need to go inside of this one
514:41 - and we call load scene
514:43 - this function will load with a certain
514:45 - scene and for loading we can either use
514:47 - the scene film index or we can use the
514:49 - scene name like I've mentioned several
514:51 - times string names are horrible although
514:53 - in this case the alternative using an
514:55 - INT is also not very good just a number
514:57 - is very hard to read the code and being
515:00 - able to know what scene this is loading
515:02 - so there's one better approach that I
515:04 - prefer to use but first over here let's
515:05 - just use the index just for testing so
515:08 - we're going to load the scene on index
515:10 - one so just like this and then here in
515:13 - the editor and let's go into file and
515:15 - build settings
515:16 - and over here we see the scenes in our
515:17 - build right now we just have the game
515:19 - scene so let's just add our scene so
515:21 - let's drag the main medicine and drag it
515:23 - on there and also let's make sure it's
515:24 - on the top of the list basically the
515:26 - first scene is the one that won't be
515:27 - unloaded as soon as the game starts so
515:29 - let's try it right up top just like that
515:31 - then over here on the right we see the
515:33 - index so by loading the scene on the
515:35 - next one we're going to be unloading the
515:36 - game scene okay so with the slits test
515:39 - so here we are and if I click on playing
515:42 - and if there you go it doesn't load the
515:43 - main scene okay great everything is
515:46 - working so this is the seamless way to
515:48 - do scene loading however this method
515:50 - does have one issue it's not super
515:52 - noticeable when a game of this scale
515:53 - because it loads pretty quickly
515:55 - but like this note how when we click on
515:58 - play there you go everything freezes for
515:59 - a little bit while the game is loading
516:01 - like I mentioned in this case the freeze
516:03 - is so small so not necessarily an issue
516:04 - but if the game was much more complex
516:06 - then the player would be staring at a
516:08 - frozen main menu for perhaps 30 seconds
516:09 - that would not be good one way to avoid
516:12 - that is actually very simple basically
516:13 - it's what I already covered in detail in
516:15 - the scene loading video that video was
516:17 - made quite a while ago but it's still
516:18 - very much up to date here we're going to
516:20 - do pretty much the same thing so we
516:22 - first create the scene just empty just
516:24 - saying loading and then from that scene
516:26 - we load the final scene that way the
516:28 - game stays Frozen on a scene that says
516:29 - loading which is much more clear to the
516:31 - player so let's do that first let's make
516:33 - our scene so inside our scenes folder
516:35 - let's create a brand new scene call this
516:38 - the unloading scene okay let's go inside
516:40 - and on this one we want this one to be
516:42 - fully black so let's go into the main
516:44 - camera and scroll down over here under
516:46 - environment and instead of rendering the
516:48 - Skybox for the background let's go with
516:49 - a solid color and let's go with phone
516:51 - black okay there's our black main camera
516:54 - now let's make a canvas so a new UI
516:57 - canvas let's set up as usual so scale
517:00 - with screen size 1920 by 1080 and match
517:04 - with the height okay then inside let's
517:06 - just make a simple text object so just
517:08 - say text then over here on let's say
517:10 - just loading
517:13 - let's put the text width and height on
517:15 - zero put it on Bold let's make sure to
517:18 - disable wrapping
517:19 - and push it over there on the side and
517:22 - maybe increase the font size down a
517:23 - little bit okay there you go we have our
517:25 - very basic loading screen now we're
517:27 - going to unload this scene and then once
517:29 - on this scene we're going to load the
517:30 - final scene although also one very
517:32 - important thing related to loading
517:34 - scenes is you need to remember the
517:36 - lifetime of the objects regular game
517:38 - objects only for example the ones that
517:39 - we see here in the hierarchy these get
517:41 - destroyed when you do a scene change
517:43 - so for the goal that we're trying to
517:45 - achieve we need to unload this loading
517:47 - scene but then also somehow transfer
517:49 - data so that the loading scene here
517:51 - knows which one is the final scene now
517:53 - you might think that over here on the
517:54 - main menu we could create a game object
517:56 - attach a script that would hone the
517:57 - reference to the final scene but like I
517:59 - said game objects get destroyed as soon
518:01 - as we unload the unloading scene so for
518:03 - transferring data between scenes we
518:04 - can't really use a regular script on a
518:06 - regular game object now one approach is
518:09 - to use the don't destroy on loan this is
518:11 - a Unity function that helps you stop a
518:13 - particular script or a game object from
518:15 - being destroyed that way the object
518:17 - won't process through scene changes so
518:19 - that's one option but another option
518:21 - that I prefer is very simple let's just
518:24 - make it another class so let's create a
518:26 - new c-sharp script call this loader and
518:29 - over here let's go ahead and make this
518:30 - class a static class and we are not
518:33 - going to extend Model Behavior so just
518:35 - like this
518:36 - basically by making it static it means
518:38 - that this one is not attached to any
518:40 - specific instance of an object this
518:42 - class cannot be attached to any object
518:44 - and cannot have any instances
518:45 - constructed then inside we can add
518:47 - static functions in fields like for
518:49 - example a static and for the Target
518:51 - scene index
518:53 - so now this field we could set this
518:55 - field from over here on the main menu UI
518:57 - and when we would load we would not be
519:00 - resetting this field also here I should
519:02 - point out one quick thing you can make
519:04 - field static without making the entire
519:06 - class itself static making the class
519:08 - static is just a good approach if the
519:10 - entire thing if everything in this class
519:12 - is also meant to be static if you don't
519:14 - make it static then you can have regular
519:16 - films here
519:18 - you can have both static and non-sanic
519:20 - whereas if you make this static
519:23 - then you're going to have an error
519:24 - because you cannot have non-static
519:26 - feelings so this is another clean code
519:28 - thing if it's only meant to contain
519:30 - static logic then make the class itself
519:32 - static okay so we have a static field
519:34 - for our Target scene but as usual we
519:37 - don't want this to be a public field we
519:39 - don't want the main menu to directly
519:41 - write to this field so let's make this
519:43 - class the only one responsible for
519:45 - anything related with scene loading
519:46 - since then let's make a function so a
519:48 - public static void call it load
519:51 - and for a printer let's receive a string
519:54 - for the Target scene name then over here
519:56 - we will load the actual scene so let's
519:57 - go into the scene manager and load the
520:00 - scene
520:01 - analyst best in the Target scene name
520:03 - okay that's it
520:05 - and then over here on the main menu UI
520:07 - instead of directly unloading a scene
520:08 - let's go into the loader and con load
520:11 - and pass in the scene name so that's the
520:13 - game scene
520:14 - okay so this is what we're going to do
520:16 - that's good except it's obviously not
520:18 - good over here we're using string names
520:20 - that's horrible we should never use this
520:22 - so let's avoid using strings as much as
520:24 - possible in one simple way is to just
520:26 - Define an enum for all of our scenes so
520:29 - let's go here on the other and let's
520:30 - define that so a public enum let's call
520:33 - it scene
520:34 - and for all of our scenes so we have the
520:37 - main menu scene then we have the game
520:39 - scene and the unloading scene
520:42 - okay so then down here on this function
520:44 - inside receiving a string we just
520:46 - receive a scene for the Target scene and
520:49 - we use the target scene although of
520:51 - course the NT API does not support
520:53 - unloading our custom enum it has to be
520:55 - an index or string so the simple
520:57 - approach is just to convert this one
520:58 - into a string that's it so the only
521:00 - thing you need to make sure is that the
521:02 - enum values over here match the actual
521:04 - name on the actual scenes perfectly so
521:07 - don't make any mistakes keep it case
521:09 - sensitive so don't do this make sure
521:11 - everything matches perfectly okay so
521:13 - just like this everything should already
521:14 - be working the same as previously so the
521:17 - main menu calls that let's actually just
521:19 - use that so let's use scene Dot Game
521:21 - scene
521:22 - so on the main menu we do this and
521:24 - unloader we load the scene okay let's
521:25 - test here is the main menu and if we
521:28 - click and wait a bit and after you go it
521:30 - didn't load the game scene okay great so
521:32 - everything still works the same as
521:33 - presently except now all of the
521:34 - unloading logic is inside of this class
521:37 - and over here let's open a loading scene
521:39 - in the middle basically when we have
521:41 - this function to load a final scene
521:42 - let's first off set this field so this
521:44 - one instead of being type in let's make
521:46 - it a type scene and this is going to be
521:48 - the target scene and let's make it
521:50 - private okay
521:52 - so when we have this function let's set
521:54 - that field although here remember how
521:56 - this is a static class so in order to
521:58 - access this field we need to exit
521:59 - through the class name because over here
522:01 - we also have a local variable with the
522:03 - exact same name so what sex is the
522:05 - unloader.target scene and set it to the
522:07 - Target scene
522:08 - so again don't be confused here you can
522:11 - even use visual studio and put the
522:12 - cursor on top to see what object
522:14 - represents what so you can see the
522:15 - unloader.target scene is referencing
522:17 - this field whereas this one over here is
522:19 - referencing the local field so we want
522:21 - to assign the member field to the one
522:23 - that we received as a parameter okay so
522:25 - we store that and then let's immediately
522:27 - unload the unloading scene so scene
522:28 - manager let's load the scene and we're
522:31 - going to load
522:33 - the scene dot loading scene dot to
522:36 - string okay so we're going to download
522:37 - that and now here comes the tricky part
522:40 - if we do this so if we load the
522:42 - unloading scene and then immediately
522:43 - unload the target scene if we didn't
522:45 - like this it won't actually show the
522:47 - loading scene
522:48 - we're calling these functions one right
522:50 - after the other so to unload the one and
522:53 - immediately the other basically we need
522:55 - to wait at least one frame to render so
522:57 - that the unloading scene is visible and
522:59 - then we can alert the final scene so
523:01 - let's make a script to do a very simple
523:02 - jump let's create a brand new c-sharp
523:05 - script for the unloader comeback and now
523:08 - let's go inside the unloading scene so
523:10 - this is important let's make this on the
523:11 - loading scene not the main menu or the
523:13 - game scene so over here let's create an
523:15 - empty game object for the unloader
523:16 - comeback let's reset transform just keep
523:19 - things nice and clean and let's attach a
523:21 - script so the only other comeback okay
523:22 - and on this script we want to basically
523:25 - just wait for the very first update
523:27 - so let's see private ball is first
523:29 - update and we started off as true
523:32 - actually
523:33 - so is the first update is true then we
523:36 - do a product void update so if it is the
523:39 - first update if so then let's set is
523:41 - first update to false
523:43 - we have the first update although
523:46 - technology I should point out that we
523:47 - don't really need this we're going to
523:49 - load right away so either way it will
523:50 - only run One update but still I like to
523:53 - add this just to make the logic
523:54 - perfectly clear basically if it is the
523:56 - first update then let's call a function
523:58 - on the unloader so on the loader over
524:00 - here let's make a function public static
524:02 - void call it below their comeback
524:05 - okay we have this function it's over
524:07 - here on the other convex let's just go
524:09 - into the unloader and call the unloader
524:11 - convex function all right so basically
524:13 - now here we have this function that is
524:15 - going to be triggered on the first
524:16 - update so we know for certain the
524:18 - unloading scene has been rendered so
524:20 - it's over here that we want to load the
524:21 - actual final scene okay that's it here
524:24 - we have a super simple loading system
524:26 - just make perfectly sure that the
524:28 - unloader come back with the script this
524:29 - one only exists on the loading scene it
524:31 - should not be on any of the other ones
524:33 - so let's test and for that let's go
524:35 - inside the main menu scene okay and now
524:37 - let's hit on play okay so here we are on
524:39 - main menu now if I click on play and
524:41 - actually here's the thing that I forgot
524:43 - so make sure you don't forget this we
524:45 - need to add the unloading scene to the
524:46 - builds in order to be able to load
524:48 - so let's go up here into the build
524:50 - settings let's go into the project drag
524:52 - the unloading scene like that okay so
524:53 - now let's test so here we are on the
524:56 - main menu let's hit on play and there's
524:58 - the loading scene after a bit yep here
524:59 - we have our game scene all right awesome
525:01 - so with that everything is working
525:03 - perfectly all of the logic is working
525:05 - great now the wrong words great let's
525:08 - just make a nice proper visual for our
525:09 - main menu so for that let's go inside
525:12 - the game scene and over here let's copy
525:14 - a few things so let's pick up the four
525:16 - object and let's also pick up the global
525:19 - volume with the post pressing so let's
525:21 - copy both of these let's go into the
525:23 - main menu scene and over here on let's
525:25 - paste both objects okay now let's also
525:28 - drag some player visuals so let's put
525:30 - this in 3D go back down into the floor
525:32 - and let's pick up some visuals so let's
525:34 - go inside our assets on the prefabs
525:36 - visuals let's find over here the player
525:39 - visual again make sure you drag the
525:41 - visual only we don't want any logic
525:43 - components and by the way this is yet
525:45 - another great benefit of separating the
525:47 - logic from the visuals right now it's
525:49 - super simple for us to play some players
525:51 - here because we have just the visuals
525:53 - commonly separated from the logic okay
525:54 - so on the visual let's just make it look
525:56 - at the camera let's position a bunch
525:59 - more players so let's duplicate this
526:01 - and put one to the side we're going to
526:04 - move the camera in a bit but now let's
526:05 - just place them and included assets
526:08 - there are a bunch of materials so over
526:09 - here we see the employer body then we've
526:11 - got a blue a green and a red like I said
526:13 - this first course is on making this game
526:15 - in single player but the goal is to then
526:17 - make a second course after this one on
526:19 - converting this game into multiplier so
526:21 - that's why I included multiple colors so
526:23 - let's just drag these let's go into this
526:25 - player Visual and on this one make it
526:27 - blue so on the head and on the body then
526:31 - on this one on the side here let's make
526:33 - this one green so green there and green
526:36 - on the head and for the one behind let's
526:39 - make this one the red one so put it in
526:40 - red and in red Okay so we've got our
526:43 - nice four players now let's also add a
526:46 - camera so we're going to have the camera
526:47 - kind of like this kind of from below and
526:49 - looking upwards I think that looks
526:51 - pretty good for that let's use cine
526:52 - machines and let's go into game object
526:54 - go into cinemachine and let's create a
526:57 - brand new version on camera okay unlike
526:59 - this let's just push it up a little bit
527:01 - okay so this is our nice composition
527:03 - now on the virtual camera let's just go
527:05 - ahead and add some noise so let's add
527:07 - basic multi-channel purlin so let's do
527:10 - it just like we did when we first had
527:11 - the thin machine so let's use the
527:13 - handheld normal mild and now let's just
527:15 - play around these films which by the way
527:16 - you can do that while the game is
527:18 - playing so let's hit on play and over
527:19 - here you can play around down the fields
527:21 - although actually defaults already look
527:23 - pretty good but let's put the frequency
527:25 - maybe a little bit less and the
527:27 - amplitude maybe a little bit bigger so
527:29 - just some nice little Sway and by the
527:31 - way if you make any changes to the send
527:33 - machine virtual camera and now you stop
527:35 - playing it will actually lose those
527:36 - changes but over here on the virtual
527:38 - camera there's this nice toggle save
527:40 - during play so if you tick this and now
527:42 - you exit play mode and there you go
527:45 - those changes were saved okay great now
527:47 - let's just make sure to untick this so
527:48 - we don't accidentally modify okay so
527:50 - here we have the basic Vision that we
527:52 - want finally there's also a game logo in
527:54 - the included assets
527:56 - so let's just go into our canvas into
527:57 - our main menu let's create a brand new
527:59 - UI image let's assign the logo Sprite
528:03 - then let's just position it on that
528:05 - corner so let's move it all the way up
528:08 - there we can anchor it to the top left
528:09 - corner and let's make it a bit bigger
528:11 - and by the way I want something like
528:13 - this if you play around this it might
528:15 - get a bit scratched so if so over here
528:17 - on the options on the image you can
528:18 - download this one to preserve the aspect
528:20 - ratio so that way even if you stretch it
528:22 - won't actually be stretch it will always
528:23 - be perfect okay just like this okay so
528:26 - here we have our basic main menu it's a
528:28 - basic setup but it looks pretty good and
528:30 - with that we have built a nice main menu
528:32 - alongside with the unloading system so I
528:34 - can click on play it goes into the
528:36 - loading scene and then into the game
528:37 - scene so that's great
528:39 - the next thing that we need is some kind
528:41 - of pause button so let's do that in the
528:43 - next lecture
528:44 - hello and welcome I'm your code monkey
528:46 - in this lecture we're going to add a
528:48 - pause button with a pulse window that
528:50 - also has the ability to quit back to the
528:52 - main menu and in doing so we're also
528:54 - going to solve some sneaky issues with
528:55 - loading okay so here in the main menu we
528:57 - can click the play button in order to
528:59 - unload the game and yep everything works
529:01 - now I'm in the game but now let's say I
529:03 - want to pause the game for a bit or quit
529:04 - back to the main menu right now there's
529:06 - no way so let's do that let's go here
529:08 - onto the game scene and first let's send
529:10 - on the pause and for that we're actually
529:12 - going to need some input so let's first
529:14 - go inside our player input actions let's
529:16 - open this and then over here let's make
529:19 - a brand new action let's name it the
529:21 - pause
529:22 - for the action type let's go with button
529:24 - okay and for the bindings over here
529:25 - let's go with escape and actually if we
529:28 - use the same method that we've been
529:29 - using if we listen and press on Escape
529:31 - nope doesn't work because Escape just
529:33 - cancels it so instead we need to use a
529:35 - search bar here Search for escape
529:36 - keyboard just like this okay great now
529:39 - again as always let's make sure to save
529:41 - the asset and wait for the compilation
529:43 - to happen there it is so now here on the
529:46 - game input list let's listen to it and
529:48 - fire the event as usual so go into the
529:50 - player input actions the player action
529:52 - map let's go into the pause action and
529:55 - listen to the performed event
529:58 - and when this happens let's fire off an
530:00 - event so a public event event handler
530:04 - let's go on pause action
530:07 - and then down here we're simply going to
530:09 - invoke this event
530:15 - okay just like this now from listening
530:17 - to it here's the question where does
530:19 - that make more sense should we do it
530:21 - over here on the player script or
530:23 - perhaps over here on the kitchen game
530:24 - manager I think over here on the game
530:26 - manager makes more sense since a pause
530:28 - is more related to the game itself
530:30 - rather than a specific action by the
530:31 - player so let's add it over here let's
530:34 - first of all listen to the event so
530:35 - let's see what private void start and on
530:37 - start let's listen to it so let's go
530:39 - into the game input and we didn't
530:41 - actually make it a Singleton yet so
530:42 - let's do that over here let's make a
530:44 - public static game input
530:47 - for the instance with a public yet and a
530:50 - private set
530:52 - then down here on the Wake let's set
530:54 - instance equals this okay there's our
530:56 - Singleton so now back in the kitchen
530:57 - game manager what's going to be instance
530:59 - and listen to the on pause action event
531:02 - and again let's rename this to give it a
531:05 - proper name
531:07 - so the C game input on pause action okay
531:09 - so here we have it when we have this
531:12 - let's call some kind of pause game
531:14 - function so let's define this let's go
531:16 - to the end of the file here and over
531:18 - here let's make that function
531:20 - so a private void pause game and over
531:22 - here we're going to pause the game now
531:24 - for pausing doing this is actually
531:26 - surprisingly easy
531:27 - basically all of our logic is using time
531:29 - dot on time for example over here on the
531:31 - player script we have our movement speed
531:33 - yep then we get the inputs and over here
531:36 - on the handle movement function yep for
531:38 - the movement distance we have move speed
531:40 - multiplied by time.10 is done or another
531:42 - use case over here on the stove counter
531:44 - we've got a frying timer and how we
531:46 - count it down again is the same thing
531:48 - time dot double time well it turns out
531:50 - that behind the scenes time to time the
531:52 - time actually already has a multiplier
531:54 - when you access this it is after that
531:56 - multiplier calculation so over here on
531:58 - the pause game function we can just go
532:00 - into time and we can modify the time
532:01 - scale this one is the multiplier so if
532:04 - we just put this at 0f then that's it
532:06 - this is going to pause all of the other
532:08 - Delta times so let's test so here we are
532:11 - pay attention to that in the countdown
532:12 - timer and I press on escape and there
532:14 - you go everything pauses the countdown
532:16 - timer pauses over here the script pauses
532:18 - and I can no longer move nothing works
532:20 - everything is perfectly paused alright
532:22 - Awesome everything works except one
532:24 - problem obviously right now we cannot
532:26 - unpause if I press Escape it's not in
532:28 - pausing so let's do that over here on
532:30 - the kitchen game manager let's add a
532:32 - simple bone so a private bone let's come
532:34 - with is game paused and let's see found
532:37 - it to phones okay so is game paused and
532:39 - then down here on the pause game
532:40 - function let's simply flip this one so
532:42 - we set this one equals not this one so
532:44 - that is going to flip that Boolean and
532:46 - then we check if the game is paused if
532:48 - so set it to zero f and if not then
532:51 - we're going to set the time.time scale
532:53 - back into one F okay so now this should
532:56 - pause and unpause so essentially rename
532:58 - this function since this is no longer
533:00 - just going to pause let's rename this to
533:03 - toggle and pause game this is going to
533:05 - pause and unpause
533:06 - okay so let's test
533:08 - okay so here we are everything is
533:10 - running now I pause and there you go
533:11 - everything freeze I cannot move the
533:13 - arrow will stop the countdown to stop
533:14 - when I press again and there you go nice
533:16 - and redeemed all right great so all of
533:19 - the logic is working perfectly the only
533:21 - thing we need is we don't just see
533:22 - visual and as usual let's separate the
533:24 - logic from the visuals so let's go
533:27 - inside the canvas let's go into the
533:28 - scene View and inside the canvas let's
533:30 - create an empty game object call it the
533:33 - game pause UI then let's stretch to
533:36 - occupy the entire screen so zero on
533:38 - everything okay great now inside let's
533:41 - first of all add a background so a new
533:43 - image name this the background let's
533:46 - once again stretch to occupy everything
533:49 - and on the color let's put it in black
533:51 - with just a little bit of alpha okay
533:53 - just like that then let's add some text
533:55 - so let's create a brand new UI text
533:58 - let's name it pause text
534:00 - and in here let's just say paused let's
534:03 - just make it big so the width and height
534:05 - both on zero let's disable wrapping Put
534:08 - It Center down the middle and let's
534:10 - increase the font size by quite a bit
534:12 - and put it in bold and let's also change
534:14 - the color maybe a nice yellow something
534:16 - like this okay that looks pretty good
534:19 - let's just lift it up by a little bit
534:21 - now let's make a script to show this so
534:25 - on the UI folder let's create a brand
534:27 - new c-sharp script call this the game
534:29 - pause UI let's attach it then open now
534:33 - here let's do the usual thing so let's
534:34 - make two show and hide functions so
534:36 - private void show and then a private
534:38 - void hide
534:40 - so on the show game object set active
534:43 - into true and on the hides set it into
534:45 - false
534:47 - okay that's it pretty simple now we need
534:49 - to know when to show our hide these
534:51 - functions so we're here on the kitchen
534:53 - game manager let's make two events to do
534:55 - that so let's go up here make a public
534:57 - event event handler
534:59 - and let's name this on game pause
535:02 - another one for on game unpaused okay we
535:06 - have both events then down here on the
535:08 - toggle pause game if we have this one
535:10 - time scale 0 that means we have pause so
535:12 - let's invoke the on game pause this
535:15 - eventar is not empty okay and on this
535:17 - one let's trigger the other one so on
535:19 - game unpause
535:21 - okay we've got the two basic events now
535:24 - back here on the game pause UI let's
535:25 - listen to it and as usual let's do it on
535:27 - start so private start let's go into the
535:29 - kitchen game manager access the static
535:31 - instance and let's listen to the on game
535:34 - pause
535:35 - and I'm going to listen to the other one
535:37 - so the instance on game unpaused so
535:39 - listen to both of them and as usual
535:41 - let's write the clean codes and let's
535:43 - rename this so kitchen game manager and
535:46 - on this one the same thing
535:48 - so also the kitchen game manager
535:51 - okay we have both and when the game is
535:54 - unpaused then we want to hide the pause
535:56 - window and when the game is paused then
535:58 - we want to show the pause window and
536:00 - finally of course we want to hide it by
536:01 - defaults over here on sart after we add
536:03 - listeners let's just hide it okay so
536:06 - that's it that should work so let's test
536:08 - so here we are everything is running now
536:10 - press the pause and there you go got a
536:12 - nice pause window press again and there
536:14 - you go everything resumes okay great so
536:16 - the last thing that we want is just a
536:18 - button over here to go back to the main
536:19 - menu and let's also add a button to
536:22 - resume without having to press the
536:23 - hotkey so over here let's create a new
536:25 - UI let's make it a button this is going
536:28 - to be the main menu button now let's
536:31 - make it quite a bit bigger okay width
536:33 - and height of 30 and 80. let's put this
536:36 - one quite a bit down there and inside
536:38 - for the text this one is the main menu
536:41 - let's put the color in White and the
536:44 - background for the button let's put this
536:46 - one in a dark gray and let's also just
536:49 - for fun add a nice upline and let's also
536:52 - add a shadow
536:53 - for the outline let's put it on for
536:55 - Alpha and let's put it on about 3 3 and
536:58 - for the effect on the shadow 5 minus
537:00 - five okay so that's a nice outline and
537:02 - nice shadow
537:03 - and then for the text itself let's put
537:06 - it in bold and raise it by just a little
537:08 - bit okay just like that looks pretty
537:10 - good so this is the main menu button and
537:13 - then let's also make so duplicate this
537:14 - let's make this one rename it this is
537:16 - the resume button
537:18 - and inside on the text let's say resume
537:21 - okay we have our two basic buttons so
537:24 - let's handle them in the script so over
537:26 - here let's add as usual a serialized
537:28 - field private of type button so that's
537:30 - inside Unity engine.ui so it's for the
537:34 - resume button and then we're going to
537:36 - have the main menu button
537:39 - okay let's save the script and back in
537:41 - the editor let's drag those references
537:43 - so that's the main menu button and the
537:45 - resume button okay so now for these
537:48 - let's add the click action so let's do a
537:50 - private awake and on the way go into the
537:52 - resume button the on click and let's add
537:54 - a listener so this is going to be our
537:55 - listener
537:57 - and same thing for a main menu button so
537:59 - main menu now for the main menu this one
538:02 - is super simple let's just go into the
538:03 - loader and call the unload function and
538:06 - we're going to download the main menu
538:07 - scene
538:08 - okay that's the main menu very simple
538:10 - and for the resume this one is only
538:12 - going to be clickable when the game is
538:14 - paused so we can just trigger the same
538:16 - function on the kitchen game manager to
538:18 - toggle the pause so kitchen can manager
538:20 - the instance and toggle the pause game
538:23 - this one is actually private so let's go
538:26 - to it and let's make this public so we
538:28 - can count from there okay that's it
538:30 - super simple Let's test okay so here we
538:32 - are and let's pause the game and now if
538:34 - I click on resume if there go it does
538:36 - work everything resumes and now pause
538:38 - again and now let's go back to the main
538:40 - menu loading any up there you go back in
538:42 - the main menu alright awesome so
538:44 - everything works perfectly
538:46 - however there's one sneaky issue here
538:48 - you can already see the issue by seeing
538:50 - that all of these animations are still
538:51 - but let's click on play and notebook
538:54 - that issue everything is still frozen I
538:56 - cannot move the character and over there
538:58 - the Shader that one is completely Frozen
539:00 - so the times can only still set to zero
539:03 - basically we need to manually reset it
539:05 - and the simplest way to do this is
539:07 - really just in the main menu
539:08 - so we can go here on the main menu UI
539:11 - and we can just use this as our reset
539:13 - function so let's just go into time.time
539:16 - scale and let's set this one back into
539:18 - one F that's it that's the only change
539:20 - Let's test so here we are let's pause
539:22 - let's go back into the main menu
539:24 - and we can see the animations are indeed
539:26 - playing and if we go back into play and
539:28 - if there you go everything works
539:30 - perfectly we can pause and yep here we
539:32 - do see one of the other two sneaky
539:34 - issues left basically it has to do with
539:36 - scene loading and cleanup so the first
539:39 - one is on input
539:40 - over here on the game input class we are
539:43 - constructing our player input actions
539:45 - and we are listening to these events and
539:48 - technically this object the one where
539:49 - the game input is attached this object
539:51 - is going to be destroyed when the scene
539:53 - changes
539:54 - however this object that we're creating
539:56 - this instance of player input actions
539:58 - this one does not get destroyed
540:00 - automatically so that is why when I went
540:02 - into the pause menu again for the second
540:04 - time over here we've got a missing
540:06 - reference exception basically the player
540:09 - input actions of the previous game is
540:11 - trying to show the pause window also of
540:12 - the previous game which has since been
540:14 - destroyed so obviously we have a missing
540:16 - reference exception because that object
540:18 - no longer exists so in this case we have
540:21 - two options to solve this one option is
540:23 - we can just unsubscribe to these events
540:25 - Unity mono behaviors have a really nice
540:28 - combat called on destroying so over here
540:30 - private void on Destroy so this is the
540:32 - default one this one is called when the
540:34 - mono behavior is destroyed
540:36 - so we can go into this one and we can
540:38 - manually unsubscribe and the way that
540:40 - you unsubscribe is you just do minus
540:42 - equals
540:45 - so this would solve that problem because
540:47 - when this object is destroyed it's going
540:48 - to unsubscribe from those events so the
540:50 - next time it will no longer trigger so
540:52 - that would fix it however on the game
540:54 - input class we are still creating a new
540:57 - object of this type I'm not 100 sure how
541:00 - the input system works in the background
541:02 - so perhaps this object might say in
541:04 - memory which is not good so another
541:06 - approach we can do or perhaps in
541:08 - combination with this is we can
541:09 - unsubscribe and then we can properly
541:11 - dispose of this object how we do that is
541:14 - very simple let's just go into the
541:16 - player input actions and we just call
541:18 - the dispose function that's it
541:21 - this should clean up that object and
541:23 - free up any memory so let's test so here
541:25 - in the game view let's pause let's go
541:27 - back into the main menu now let's go
541:29 - back into the main game and now if I hit
541:31 - pause and if there you go we no longer
541:33 - have any errors okay so that's good
541:35 - however now we still have one more
541:38 - potential issue and this one has to do
541:40 - with Statics like I mentioned before
541:42 - Statics belong to the class and not any
541:44 - instance of that class so that means
541:46 - that static films will not be destroyed
541:48 - or reset when the scene changes in the
541:51 - case of our unloader here where we have
541:52 - a private static field this one the fact
541:55 - that this one doesn't reset
541:56 - automatically that was a good thing
541:57 - that's what allowed this to make the
541:58 - unloading system but in the case of
542:01 - maybe static events that might not be as
542:02 - good it might mean that we might be
542:05 - keeping some state from the previous
542:06 - game which might cause everything to
542:08 - break so basically we have a similar
542:10 - problem to what we had in the input
542:12 - where some logic from the previous game
542:14 - might be affecting the next game in all
542:16 - the code that we wrote the main place
542:18 - where we use Statics were in The
542:19 - Singletons and these are going to be
542:21 - cleared automatically when the
542:23 - underlying instance object when that one
542:24 - is destroying so these do not cause any
542:27 - problems however for example over here
542:29 - on the cutting counter we've got a
542:31 - static event when the scene changes this
542:34 - will not be cleared so this will still
542:36 - have the same number of listeners we can
542:38 - actually see how many listeners there
542:40 - are by printing it so let's go down here
542:41 - before we're invoking the event let's do
542:44 - a debug download let's go inside the on
542:46 - any cut event and over here we can get
542:49 - the invocation list this one is a list
542:52 - of all of the functions that are
542:53 - listening to this event
542:54 - and we can just print out the link to
542:56 - see how many listeners are listening to
542:58 - this event so let's see what this
543:00 - returns okay so over here let's pick up
543:03 - some cheese and slice it and if I'm
543:04 - working the log yep there you go one
543:06 - there's only one listener okay that's
543:08 - correct
543:09 - however now if I go back into the main
543:11 - menu and now I go back and I play again
543:14 - okay so let's play let's just wait for
543:16 - the countdown and once the countdown
543:19 - ends pick up some cheese go there slice
543:20 - it and there you go there's the problem
543:21 - now we have two listeners in this case
543:24 - doesn't really cause an error because
543:25 - the tune listeners they're just over
543:27 - here on The Sound Manager so we are
543:29 - subscribing to this event and we're
543:31 - doing the cut and playing the cut object
543:32 - however if here we do something with
543:35 - this transform like for example let's
543:37 - just do a debug download on this
543:39 - transform that position if we do this
543:41 - here let's go ahead on the first one
543:44 - let's slice and okay that works let's go
543:46 - back into the main menu now play again
543:48 - now wait for the timer
543:50 - pick up some cheese go there slice any
543:52 - of that I go there we have our air that
543:54 - is because we are now accessing The
543:55 - Sound Manager transform and that one has
543:57 - since been destroyed so if you do use
543:59 - static events like this one here if you
544:02 - do that always remember you need to
544:03 - manually reset that state it won't
544:05 - happen automatically on the scene load
544:07 - and one way that I normally do it is
544:09 - just make a class responsible for doing
544:11 - that so let's go ahead and let's create
544:13 - a brand new c-sharp class let's call
544:15 - this the reset static data manager and
544:19 - for this one we want this one to run
544:20 - only on the main menu That's only where
544:22 - we're going to reset things so let's go
544:25 - inside the main menu scene let's go
544:27 - there let's create a brand new empty
544:29 - game object for the reset static data
544:32 - manager let's reset transform just keep
544:35 - things clean and let's attach that
544:37 - script again it's very important that
544:39 - this object only exists on the main menu
544:41 - then over here we're basically just
544:42 - going to go into any script and reset
544:44 - any data so for that on all those
544:46 - scripts let's make a function
544:48 - so over here on the cutting counter
544:50 - let's make a public static function
544:52 - let's call this reset static data in
544:56 - order to reset any listeners let's just
544:57 - go into the on any cut and set it to
544:59 - null that will clear all the listeners
545:01 - so we just do this and then on this
545:04 - script Let's see we practically awake
545:05 - and on awake let's go into the cutting
545:08 - counter under the class so not any
545:10 - instance so we're going to access the
545:11 - static and we're going to reset the
545:13 - static data that will clear all the
545:15 - listeners on The Cutting counter all we
545:17 - need to do is make sure to do this on
545:19 - every single static event that we have
545:21 - so on The Sound Manager and by the way
545:23 - here we can get rid of the testing code
545:25 - here we can see all the static events
545:28 - that we're using so we've got the
545:29 - cutting counter then we've got the base
545:30 - counter and trash counter so let's go
545:32 - here on the base counter and paste the
545:34 - exact same thing and reset this event
545:36 - okay and now let's go into the trash
545:38 - counter
545:39 - so here on trash counter same thing
545:41 - reset this event set them all into null
545:44 - and by the way here we have a warning
545:46 - that's because trash counter extends
545:48 - base counter so basically this is
545:49 - telling us that we are hiding another
545:50 - function with the exact same name in
545:52 - this case we do want to hide it so
545:54 - what's actually make this new to make
545:55 - sure that this one is a different one
545:57 - just to avoid that warning and same
546:00 - thing over here on the cutting counter
546:01 - we also need to make a new okay so
546:03 - that's it and now we just need to go
546:05 - over here onto the reset static data
546:07 - manager let's go into the base counter
546:09 - and reset the static data go into the
546:11 - trash counter and reset the static data
546:13 - okay that should do it let's see so here
546:16 - we are in the game let's pick it up and
546:18 - slice it and yep we've got just one
546:20 - listener that's good let's go back
546:21 - outside back into the main menu let's
546:23 - play once more and over here let's pick
546:26 - it up again go there drop it and there
546:28 - you go still just one listener because
546:29 - we are now correctly eliminating all of
546:31 - the previous listeners
546:32 - so this is the one sneaky issue that you
546:35 - must be careful with when it comes to
546:36 - object Lifetime and Statics for static
546:39 - Fields you need to remember that they
546:40 - don't manually get cleaned up that's up
546:42 - to you so that's something you have to
546:44 - keep in mind but you can also see how
546:45 - easy it is to solve now that this is
546:47 - solved let's just go into the cutting
546:49 - counter and just get rid of our testing
546:50 - log alright so with all of that all of
546:52 - our scenes are working so we can start
546:54 - from here from the main menu and go
546:56 - straight into the game then here we are
546:58 - in the game playing normally we can
547:00 - pause the game at any point from the
547:02 - pause screen we cannot resume or we can
547:04 - go back into the main menu and from back
547:06 - into the main menu we can once again
547:08 - play the game from scratch and if there
547:10 - you go everything works alright awesome
547:13 - now the next thing that every game
547:15 - requires is some options so let's do
547:17 - that in the next lecture
547:19 - hello and welcome I'm your code monkey
547:21 - in this lecture we're going to create a
547:23 - simple options menu where we can modify
547:25 - the audio levels okay so here let's make
547:28 - the options menu so on our game scene
547:30 - let's go into the canvas and create a
547:32 - new empty game object let's make this
547:34 - the options UI let's stretch out this
547:37 - one to occupy the entire screen
547:39 - then inside let's make a UI image once
547:42 - again let's stretch out everything
547:45 - let's put this one in black in just
547:48 - almost full Alpha okay now let's make
547:50 - some texts so let's create a brand new
547:52 - UI text call it the options text
547:56 - then for text let's say just options
547:58 - let's put the width and height at zero
548:02 - let's disable wrapping Put It Center
548:04 - down the middle and put it quite a lot
548:07 - bigger
548:08 - okay that's the options now just move it
548:10 - slightly upwards all right now let's
548:12 - make some simple buttons to handle our
548:14 - audio controls we're going to make it
548:16 - super simple literally just a button we
548:18 - can click so inside the options UI let's
548:20 - create a brand new button
548:22 - call this the sound effects button then
548:26 - let's make the button a bit bigger
548:27 - something like this okay
548:32 - and inside for the text let's say sound
548:35 - effects and then we're going to have a
548:36 - number for the sound effects let's just
548:39 - quickly change the color so put the text
548:41 - in White and the button over here the
548:44 - button image let's put it in a dark ring
548:46 - okay let's also make it just a tiny bit
548:49 - thinner it's just like that okay so this
548:51 - is the sound effects button now let's
548:52 - duplicate this one this one is going to
548:54 - be the music button so let's name this
548:56 - the music button
548:58 - then inside for the text music and then
549:00 - a number
549:01 - and that's pretty much it so by clicking
549:04 - on either of these buttons we're going
549:06 - to increase and then Loop the volume so
549:08 - let's make a simple script to handle our
549:10 - options window so in our scripts inside
549:12 - the UI let's create a brand new c-sharp
549:14 - script for the options UI let's go ahead
549:17 - and attach a script and open
549:19 - so here as usual let's get some films
549:22 - for our buttons so a serialized film
549:24 - private of type button for the sound
549:27 - effects button and then there's another
549:30 - one for the music button
549:35 - okay both buttons now let's add the
549:37 - click event so on private awake let's go
549:39 - into the sound effects button and on the
549:41 - on click let's add a listener
549:45 - and we're going to do the same thing on
549:46 - the music button
549:48 - okay so now when we click we want to
549:51 - change the volume so let's go here onto
549:54 - The Sound Manager and make a function to
549:55 - modify the volume
549:57 - let's make a private void change volume
550:03 - and here we're going to increase the
550:04 - volume by 0.1 percent so constantly
550:06 - increase in 10 increments so that means
550:09 - we need to keep track of the volume so
550:10 - up here in order to find a SIM phone
550:12 - private float for the volume
550:18 - well it's default it to one F okay so
550:22 - now down here we take the volume and we
550:24 - increase it by 0.1 F and now let's Loop
550:27 - it back to zero
550:28 - now for looping usually you do it using
550:30 - the modular operator so here you could
550:33 - do volume equals volume module of 1.1 f
550:37 - that way when it gets to 1.1 f it would
550:39 - reset back to zero but here since we're
550:42 - working with floats which can have a bit
550:44 - of odd Precision with this let's just do
550:46 - a simple lift to make sure that always
550:48 - works
550:49 - so if the volume is above one f
550:52 - if so then let's just reset it to zero
550:55 - okay
550:56 - so here we modified volume and let's
550:58 - just make sure to use it over here when
550:59 - we actually call the audio
551:01 - source.playclip Point here we've got a
551:03 - volume but this is the one that we
551:04 - received as a parameter so let's
551:06 - actually receive this one rename this to
551:09 - volume multiplier
551:11 - and we're going to basically multiply
551:13 - the one that we receive in the parameter
551:15 - by the one that we actually store
551:17 - so this way on these functions when we
551:19 - play a certain sound we can still give
551:21 - an optional volume if we want to make it
551:23 - louder or quieter then the regular sound
551:25 - effects okay so we have our change
551:27 - volume function now we just need to call
551:29 - this from the options UI so that means
551:31 - this one actually needs to be public
551:32 - okay so now here on the options UI we go
551:36 - into the sound manager access the
551:37 - instance and call change volume okay so
551:40 - that is going to change the volume then
551:41 - we just need to update the values on the
551:43 - options UI so let's make a proud void
551:46 - update visual
551:48 - and this one we need to update the text
551:51 - so up here on let's add once again some
551:53 - more serialized Fields so text mesh Pro
551:56 - ugly one for the sound effects text and
551:59 - another one for the music text
552:02 - okay we have both these then here the
552:04 - sound effects text not text
552:07 - equals and we go into The Sound Manager
552:09 - the instance
552:13 - and then we need to get the volume
552:15 - so over here on the sound management
552:16 - let's make a function together so a
552:18 - public float return get volume and we
552:22 - just return the volume okay so then here
552:25 - let's get volume except volume is going
552:28 - to be a normalized value so rather than
552:30 - showing 0.1.2.3 on the UI let's just
552:34 - multiply the volume by 10f that way we
552:37 - show between 1 and 10 okay then let's
552:39 - just round out this number
552:42 - and then add the text
552:45 - so here's sound effects and then we have
552:48 - the bone okay so that's pretty much it
552:50 - and up here when we change the volume
552:52 - let's just update the visual
552:55 - and let's also make a private void start
552:57 - and on start let's also update the video
552:59 - okay that's it pretty simple now let's
553:01 - do the exact same thing on the music
553:03 - except on the Music Manager we named it
553:06 - music manager but over here we just have
553:07 - an audio Source there's no actual
553:09 - manager so let's actually make one let's
553:11 - create new c-sharp script for the Music
553:14 - Manager let's go into the Music Manager
553:17 - object let's attach a script and let's
553:20 - open so here we really just need pretty
553:22 - much exactly the same thing that we had
553:24 - so let's just go here into The Sound
553:26 - Manager and just copy these
553:28 - so on the Music Manager let's paste them
553:29 - we need a volume so a private mode for
553:32 - the volume just like this okay so that
553:34 - changes the volume except again the
553:36 - Music Manager this one the music is
553:38 - constantly going to be unlooping so
553:40 - after we modify the volume we need to
553:42 - update the actual audio source so let's
553:44 - begin by grabbing the audio source audio
553:47 - source and we just do a pro void awake
553:50 - and on a week let's grab the audio
553:52 - source
553:53 - get the component of time Body Source
553:55 - okay so we have this and when we change
553:57 - the volume let's go here and update this
553:59 - phone okay that's it and let's also
554:01 - default it to some like 0.3f okay good
554:04 - then in order to be able to call this
554:06 - from the option Cy we just need to make
554:08 - it a single turn so as usual public
554:10 - static Music Manager for the instance
554:12 - and we have a public get and a private
554:15 - set
554:16 - and then an awake just set instance
554:18 - equals this okay
554:20 - so then here on the options UI we can go
554:22 - into the Music Manager the instance and
554:24 - change the volume and afterwards let's
554:26 - update the visual and down here on the
554:28 - update visual lets you pretty much the
554:30 - same thing so on the music text modify
554:33 - the text to say music then we go into
554:36 - the music manager and get the volume all
554:39 - right that's it all this should be
554:41 - working let's just drag our references
554:42 - so back in the afternoon let's drag
554:44 - firstly button so the sound effects
554:46 - button that's this one then the music
554:48 - button that's this one then we have the
554:50 - music text that's this one and the sound
554:53 - effects that's like that okay let's test
554:55 - okay so here we are the music is playing
554:58 - and as I click the music is currently
555:00 - getting louder and louder
555:01 - and their game I'm using is at max
555:03 - volume and if I click again no the music
555:05 - is completely muted alright awesome any
555:07 - sound effects also work so like this
555:09 - they should be less leather than usual
555:11 - okay great so everything works perfectly
555:13 - except obviously we have one big issue
555:16 - the options window is on top of
555:18 - everything
555:19 - the goal is for the options window to be
555:21 - kind of a sub menu of the pause window
555:23 - we want to have an options button on the
555:25 - pause window that won't bring up the
555:27 - options window so let's do that let's
555:29 - first hide the options window let's go
555:31 - into the game pause UI and over here we
555:34 - have these buttons let's just make one
555:35 - more let's put it down the middle this
555:37 - is going to be the options button
555:40 - and inside let's modify the text to
555:42 - options okay
555:43 - now let's edit this script so we're
555:46 - going to have another button so this is
555:47 - the options button and down here we're
555:50 - going to have another click so the
555:51 - options button okay
555:53 - and when this happens we want to just
555:56 - show the options window so in order to
555:58 - access it let's make this a Singleton so
556:00 - public static for the options UI
556:04 - a static instance
556:08 - with a getting a private set
556:11 - and on weak as usual instance equals
556:13 - this
556:14 - so over here on the game POS UI we go
556:17 - into the options UI access the instance
556:19 - and then call a show function so we need
556:21 - to make this
556:23 - so here on the options UI let's make
556:25 - those so a public void show
556:28 - and this one as usual just game objects
556:31 - that active into true
556:39 - and then we have a private hide
556:42 - and this set active in two phones
556:45 - okay we have both these on the other
556:47 - side we show it and over here on start
556:50 - let's also hide it okay
556:53 - then let's also hide it manually so
556:55 - let's add a button to close the options
556:57 - UI so over here let's show the options
556:59 - UI and let's make another button let's
557:02 - put it on the bottom this one is the
557:04 - close button
557:05 - and over here let's just say close
557:08 - so then here on the options UI just make
557:10 - another button the close button and down
557:12 - here for the click event
557:16 - we go into the close button and we just
557:18 - call height
557:20 - okay so that won't hide the window
557:22 - however remember that the pause window
557:24 - can also be closed by just pressing
557:26 - escape if we resume with the hotkey it
557:29 - won't hide the pause window so let's
557:31 - also make sure this one hides on the
557:32 - same thing so we can do pretty much
557:34 - going to the kitchen game manager the
557:36 - instance and let's listen when the game
557:37 - is unpaused so when that happens let's
557:40 - hide this window
557:41 - so once again let's do things nice and
557:43 - clean let's rename this so the kitchen
557:46 - game manager
557:48 - and when this happens let's just hide
557:50 - okay this should work let's just drag on
557:53 - the references so first here on the
557:55 - options UI let's drag the close button
557:57 - and then on the game pause UI let's drag
558:00 - the options button okay so let's test
558:03 - and if right away the options window is
558:05 - not showing the trade and if I press in
558:07 - this game there you go there's the pause
558:08 - window and if I can click on options if
558:10 - there's the options window now if I can
558:12 - go and close back here back into resume
558:13 - okay works now if I pause options and
558:17 - now press on the Escape key and you
558:19 - better go closes everything all right
558:21 - great so everything is working fine
558:23 - however we have one slight issue
558:27 - the option does work so I can modify
558:30 - this to change the sound effects and
558:31 - Music volume so for example let's mute
558:34 - the music and put the sound effects on
558:35 - five so I put it like this but now if I
558:39 - stop playing and I hit play again
558:42 - and working the options and oh there's
558:44 - the issue basically that is back to the
558:46 - default obviously that is resetting
558:48 - since we didn't actually save anything
558:50 - so let's save it now in unity the
558:53 - easiest way to save some data is using
558:55 - player prefs so let's go over here on
558:57 - The Sound Manager and when we modify the
559:00 - volume over here when we do that let's
559:02 - access the Unity Player prefs and over
559:05 - here we've got a bunch of set functions
559:07 - so we can save a float an INT or a
559:09 - string this one as you can see it takes
559:11 - a string and a value so this is pretty
559:14 - much essentially just a dictionary now
559:16 - for the key as you can see it's a type
559:18 - string but again we should not be using
559:20 - strings directly
559:21 - so let's go up here in order to make a
559:23 - proper constant so a private con string
559:25 - let's go with Pro layer
559:27 - prefs sound effects volume
559:32 - and let's go sound effects volume
559:36 - okay we have our nice Center in content
559:38 - and down here when we set the float
559:40 - let's use this string and say the volume
559:43 - okay so that is going to set the float
559:45 - and now technically Unity is going to
559:48 - automatically save the player perhaps
559:49 - basically there are only problems if
559:51 - Unity somehow crashes in between when
559:54 - you can't set float and when it actually
559:56 - saves but if you want to prevent that
559:59 - from happening you can just go and tell
560:00 - it to save manually just like that that
560:03 - won't definitely save it and now we just
560:05 - need to handle loading so here on awake
560:08 - when we have this let's go into the play
560:10 - prefs and let's use get float let's pass
560:13 - in the same key so this one takes the
560:15 - key and default value so let's default
560:17 - it to one F basically the default value
560:19 - is used if there's no save data on
560:22 - display prefs on this key so the first
560:24 - time we run it's actually going to use
560:25 - this default and this one's going to
560:28 - return these saved value so let's just
560:29 - set it on the volume
560:30 - okay so that's it that's only takes to
560:32 - save some basic data now let's do the
560:34 - exact same thing on music so over here
560:37 - on the Music Manager let's first Define
560:39 - our private con string for the player
560:43 - pref's music volume
560:46 - and this is going to be the music volume
560:50 - okay we have our string and then down
560:52 - here when you change the volume layer
560:54 - press
560:58 - and let's set the float on this key and
561:01 - let's pass in the Music Volume okay and
561:03 - then what's going to player prefs and
561:05 - actually save it and now appear on the
561:08 - wake
561:08 - let's grab the volume
561:11 - and it's going to be going to the player
561:13 - prefs in order to get the float on this
561:15 - key
561:17 - and default value is 0.3f however over
561:20 - here on the music again we are not
561:21 - spawning the sound afterwards the sound
561:24 - starts playing right away
561:26 - so let's make sure to set the audio
561:28 - Source volume to the one we grab from
561:29 - there okay that's it so like this it
561:32 - should be working so let's test so here
561:35 - we are and the music is playing let's
561:36 - pause go into the options let's bring
561:39 - the music completely down so let's mute
561:41 - the music okay the music is gone and
561:43 - sound effects let's put a note 5. now
561:45 - let's stop playing and now play again
561:47 - and going to the menu options and if
561:50 - there you go the data was indeed saved
561:52 - and the music is indeed muted alright
561:54 - awesome so here we have some basic data
561:57 - being saved and also just quick note
561:59 - related to saving for this simple game
562:01 - decisions are pretty quick so I didn't
562:03 - include any kind of save system for the
562:05 - actual game data but if you want to know
562:07 - how to do that I also have video
562:08 - covering that topic okay so with that we
562:11 - have our options window working the
562:13 - volume sliders work perfectly the next
562:15 - thing we need to add to our options is
562:17 - some key rebinding so let's do that in
562:19 - the next lecture
562:21 - hello and welcome I'm your code monkey
562:23 - in this lecture we're going to add key
562:25 - rebinding to our options menu so here we
562:28 - already have this nice options menu we
562:30 - can modify the volume of the sound
562:31 - effects or the music next let's handle
562:33 - key rebinding okay so first let's build
562:36 - the elements over here on the UI so
562:38 - let's create a bunch more buttons but
562:40 - before that let's actually make some
562:41 - text on the side and buttons in the
562:43 - middle so let's create a brand new UI
562:45 - text
562:46 - call this move of text
562:49 - let's put it on the same size as the
562:50 - other one so these got a font of 24 so
562:52 - let's put it same thing font of 24 width
562:55 - and height let's put both of these on
562:57 - zero and down here anchor it to the left
562:59 - okay down the middle and with no
563:00 - wrapping okay so then over here this is
563:03 - going to be the move up action
563:05 - so we have move up then we have the move
563:08 - down move left move right then we have
563:11 - the interact the interact alternate and
563:13 - finally the pause so these are all of
563:15 - our actions so let's just make all of
563:16 - these
563:17 - so rename this so this one is the move
563:19 - down
563:20 - then this one over here is the move left
563:23 - this one is the move right this one is
563:27 - the interact text then the interact
563:30 - alternate text and finally the pause
563:33 - text now let's just modify the text on
563:35 - these so that's the pause
563:37 - that one is the indirect Alt
563:40 - then this one is the interact then we've
563:44 - got the move right
563:46 - then over here the move left and finally
563:49 - we have the move down
563:51 - okay so those are our labels for our
563:54 - controls now let's just make buttons
563:56 - over here on the right side so let's
563:57 - duplicate one of these buttons let's put
563:59 - it over here and put it on something
564:01 - like 50 by 50. so this is going to be
564:04 - the move up button and inside on the
564:07 - text this is going to be pretty much
564:09 - just a w okay so we have the move up
564:12 - then we're going to have the move down
564:14 - move left move right the interact the
564:19 - interact alternate and the pause
564:21 - so we just need a bit more space so
564:23 - let's move all of these up by quite a
564:25 - bit let's also move the music and the
564:28 - sound effects so move all of these like
564:31 - that okay let's just name all these
564:33 - buttons so this one
564:35 - is the second one so this may move down
564:38 - then over here the move left
564:42 - then the move right then the interact
564:45 - button the interact alternate button
564:50 - and finally the pause button okay those
564:53 - are on the buttons let's just position
564:55 - all of the labels exactly where they
564:57 - should be
565:02 - okay so here we have all of the options
565:04 - all of our bindings now in code let's
565:06 - grab references to all the buttons and
565:08 - all the text inside the buttons so here
565:11 - inside the options URL let's add all of
565:12 - those so first of all for the attacks
565:15 - we're going to have the move of text
565:16 - then the down left right and so on so
565:19 - let you see all of these so down
565:21 - then over here the left then the right
565:24 - then the interact text the interact
565:27 - alternate text and finally we have the
565:30 - pause text
565:31 - and for the buttons let's go up here
565:33 - make all the buttons so they move up
565:35 - button then they move down button
565:40 - then we have the move left button then
565:43 - the move right button then we have the
565:46 - interact button the interact alternate
565:48 - button
565:49 - and finally the pause button
565:52 - okay so we have all of these references
565:55 - over here in the editor let's just drag
565:56 - them so let's make sure we drag them on
565:58 - correctly so let's do it one by one so
566:01 - the move up this is the text and
566:03 - actually it's not that one so that's
566:04 - already a mistake right there we want
566:06 - the text from inside buttons
566:07 - so let's pick up all of these text
566:09 - objects so let's go into the options so
566:11 - text inside the move up let's grab that
566:13 - one then inside the move down let's grab
566:15 - that one and then left and so on so
566:18 - definitely make sure you grab the right
566:20 - ones okay that's on text now for the
566:22 - button so let's move up button then you
566:25 - move down
566:26 - then they move left
566:28 - the move right the interact interact
566:32 - alternate and finally the pause button
566:34 - okay great and just to verify that
566:36 - everything is working let's give proper
566:37 - names to these objects
566:39 - so the move up button text
566:48 - okay so I've renamed all the buttons so
566:50 - now over here it's much easier to verify
566:52 - that we have the correct references so
566:54 - the sound sound music music and so on so
566:56 - definitely make sure all of these are
566:57 - correct otherwise you might go crazy
566:59 - when things start to go a bit weird so
567:01 - make sure these are all correct all
567:02 - right now let's begin by updating the
567:04 - text inside over here so let's go into
567:07 - our update visual so we go into this set
567:09 - the text and now we need to get the
567:10 - binding text for this binding so for
567:13 - that let's make that function on the
567:14 - game input over here let's just comment
567:16 - this out
567:17 - then over here on the game input script
567:19 - let's make a function to get the
567:21 - bindings certainly we could make
567:23 - something just to grab this player input
567:24 - actions but again we don't want the
567:26 - options UI to know what input system
567:28 - we're using it should work regardless of
567:31 - what input system
567:32 - so we don't want the game input to
567:34 - return anything of this type instead we
567:36 - want to make a nice layer of abstraction
567:38 - so for that let's make an enum to Define
567:40 - all of our bindings so let's make a
567:43 - public since we're going to access it
567:44 - enum call it binding
567:46 - and over here let's add all the bindings
567:48 - so we've got the move up then we have
567:51 - the move down the move left the move
567:55 - right then we have the interact the
567:58 - interact alternate
568:00 - and finally the pause so these are all
568:03 - of the bindings now let's make a
568:04 - function to return the binding text
568:07 - so over here let's make a public we're
568:09 - going to return a string
568:11 - let's just name it get binding text and
568:13 - as a parameter let's receive a binding
568:17 - okay so now here let's just do a switch
568:19 - switch on this binding and basically
568:22 - just match up the enum to whatever
568:24 - action we have
568:25 - so for example let's begin with the
568:27 - interact since these are the simplest
568:29 - ones
568:30 - so for this one to get the bindings we
568:32 - first go inside the player input actions
568:35 - then let's go inside the player action
568:37 - map then for the action so in this case
568:39 - the interact and anything inside we've
568:41 - got the bindings this is an array of all
568:44 - of the bindings in our input map we
568:46 - defined all of the keyboard bindings on
568:48 - index 0. later on we're going to add
568:50 - Gamepad bindings but for now we're going
568:52 - to have the keyboard always on index 0.
568:55 - so over here going to bindings axis on
568:57 - zero and let's just do a two string
568:59 - okay so let's just return this and let's
569:02 - do a default to return always this one
569:04 - just like this okay so let's do a quick
569:06 - unlock to see what this returns so let's
569:08 - do it over here on the game input just a
569:10 - debug.log go into there get the binding
569:12 - tags for the interact
569:14 - okay so let's test and right away yep we
569:17 - do see it working so the interact and
569:19 - The Binding is on keyboard slash e but
569:22 - we don't want all of this text we really
569:24 - just want to see the E thankfully the
569:26 - input system has a really great function
569:28 - for just that so instead of calling the
569:29 - general to string let's call to display
569:32 - string let's see any of this one does
569:35 - return just easy okay great so this is
569:37 - the one that we want let's do the same
569:39 - thing for all of the other simple
569:40 - actions
569:42 - so we've got the interact then we have
569:44 - the interact alternate and we have the
569:47 - pause so these are all the super simple
569:49 - ones so just going to interact alternate
569:51 - grab the binding on zero and for the
569:54 - pause binding on zero okay so these are
569:55 - all super simple now the more complex
569:58 - one is the move it's more complex
570:00 - because you can see all the others just
570:02 - have one binding except for the move
570:04 - over here we have a composite binding so
570:06 - that's basically a binding which inside
570:08 - has four separate bindings basically the
570:10 - way that this works is that when you use
570:12 - a composed binding all of these are
570:13 - added to the array so this to the vector
570:16 - is going to be on binding 0 then the up
570:18 - is going to be on binding one two three
570:19 - four and so on then the arrow keys this
570:22 - one is going to be on five then we have
570:25 - six seven eight nine and ten let's do a
570:27 - log just to verify
570:29 - so here if we do one for the move up
570:32 - action for this one let's go into the
570:35 - move and let's print out just the
570:37 - binding zero let's do a regular two
570:38 - string let's see what this returns so up
570:41 - here let's just modify our log to say
570:44 - the move up okay so let's see any up
570:46 - index 0 does have the move to the vector
570:48 - and now if we print the one on binding
570:51 - of one yep now this one does have the
570:53 - move on the w
570:54 - so like I said we can see that all of
570:56 - these Composites these are technically
570:58 - inside that one but in terms of that
571:00 - array it's just a flat array so this one
571:02 - index 0 1 2 3 and 4. so that makes it
571:05 - super simple to add over here so they
571:08 - move up down left right
571:10 - and let's just do all these
571:13 - so we have all the bindings and over
571:15 - here just one two three and four
571:19 - and set a two string let's call the
571:21 - display string okay so the binding text
571:24 - this is all set up so let's go up here
571:26 - and get rid of our testing code we can
571:28 - now call this from the options UI so
571:30 - over here let's do exam with that so
571:32 - when we update the visual
571:33 - let's go into the game and put let's
571:36 - access the static instance let's get the
571:38 - binding text and this one is going to do
571:40 - the move up
571:42 - so that's it this one is going to return
571:43 - a string
571:44 - let's write all of them
571:52 - okay here are all of them so let's see
571:54 - and if there they are all perfect don't
571:57 - we SCD EF Escape okay great so the
572:00 - visual is working now let's end on the
572:01 - rebinding so let's add a click event
572:04 - let's go into the move up button
572:07 - let's go into the on click let's add in
572:10 - listener and for the enlistener over
572:12 - here let's make a function on the game
572:14 - input to rebind this binding
572:16 - so over here on the game input let's see
572:19 - public void rebind binding and we
572:22 - receive a binding
572:25 - now for rebinding I cover this in detail
572:27 - in the dedicated input system video
572:29 - first basically we need to disable the
572:31 - action map so let's go into the player
572:33 - input actions let's access the player
572:36 - and disable it so we need to do this
572:37 - first then we're going to need to find
572:39 - the action so player input actions and
572:42 - for now let's go into the player and
572:44 - let's just modify the move up action so
572:47 - we're going to call the function perform
572:48 - Interactive rebinding
572:51 - this one as you can see takes a binding
572:53 - index and if you remember up here we saw
572:55 - that in order to modify the move up it's
572:58 - on bindings index one so let's modify
572:59 - the one on index one
573:01 - okay so this is the function this
573:04 - returns an object of this type a
573:05 - rebinding operation this is a pretty
573:08 - complex object where you can modify all
573:10 - kinds of things add a bunch of
573:12 - limitations and so on like for example
573:14 - make a key not be able to be bound to
573:15 - the mouse or something so there's tons
573:18 - and tons of options you can play with
573:19 - over here for the simple thing let's
573:22 - just add an on complete listener so this
573:24 - one takes in a convex and this will be
573:26 - called whenever the interactive
573:29 - rebinding completes
573:30 - so over here on let's define and Lambda
573:33 - so we come back and inside we have this
573:35 - by the way over here this is the same
573:37 - line of the expression that we saw
573:38 - previously so exactly the same thing as
573:40 - this except when we have just one
573:42 - parenthesis we don't need to add them
573:44 - okay so like this so then on this convex
573:46 - we can see all kinds of things like for
573:48 - example we can see the action that we
573:50 - just rebound this is going to contain
573:52 - all the data on the rebind operation so
573:54 - for example let's print out the path so
573:56 - let's go into the action
573:58 - let's go into the bindings
574:00 - on index 1 and let's print out the path
574:03 - similar to a debug.log
574:09 - and there's actually another one so
574:11 - let's log the path and also the override
574:14 - path these are two different things
574:16 - let's see why in a bit we do this and
574:18 - after we log we also need to rename on
574:20 - the player action map so let's go into
574:21 - the player input actions deep layer and
574:24 - back enable this okay so we're only
574:26 - going to need these settings on the
574:28 - rewind action then we can just call
574:30 - start in order to start the rebinding
574:32 - process okay so this should work let's
574:34 - just call this from the options UI so
574:36 - over here we have the click let's go
574:38 - into game input instance and let's
574:41 - rebind The Binding and for this one is
574:43 - the move up
574:46 - okay with this let's test okay so here
574:49 - if I click on the button and I click on
574:51 - the T key and if there go it did work so
574:54 - you can see that it print out the
574:55 - regular path that is w and the override
574:57 - path which is C so now if I exit out of
575:01 - the options go back into the game if I
575:03 - press W nope it does not move but if I
575:05 - press T yep it does move upwards okay
575:08 - great so we have successfully rebound
575:10 - this one key now here just one thing in
575:14 - previous versions of the input system
575:15 - when doing a rebind operation you need
575:18 - to manually dispose of this comeback
575:20 - otherwise it would throw a memory error
575:22 - in the recent version that I'm using
575:23 - here there's no error so it seems
575:25 - perhaps it's no longer needed to dispose
575:27 - of the compact manually but still
575:29 - there's no harm doing it just in case
575:30 - over here combat dot dispose
575:33 - okay so with that the key rebinding is
575:35 - working except we have two issues the
575:37 - first one is that it's not very clear
575:38 - that it's listening for an input and the
575:41 - second one is that the text options also
575:43 - does not update so it's on both those
575:45 - first let's add a visual when waiting
575:47 - for a key press so inside the game
575:49 - options UI let's create an empty game
575:51 - object call this the press to rebind
575:54 - team
575:56 - let's stretch it out so put it on zero
575:58 - on everything okay then inside let's add
576:01 - a UI image
576:03 - let's put it in black and once again
576:05 - let's stretch it out
576:07 - okay now let's also add a simple text
576:10 - and for text let's say press a key
576:14 - to rebind as usual let's put the width
576:17 - and height on zero put it in bold Center
576:20 - down the middle with no wrapping and
576:22 - increase the size by quite a bit okay so
576:25 - that's our super basic window now in the
576:27 - code we just want to show and hide this
576:28 - so let's do that and let's actually
576:30 - begin with this hidden by default so
576:32 - let's disable this object so here on the
576:34 - options UI let's add another serialized
576:36 - film it's going to be a transform for
576:39 - the press to rebind key transform
576:45 - so you have this let's make two show and
576:47 - hide functions
576:49 - so we show press to rebind key
576:53 - we just go into that one game objects
576:55 - and active this one into true
576:58 - and another one where we set it to
576:59 - phones so just
577:01 - hide and set it to false okay pretty
577:03 - simple let's make sure to hide this over
577:06 - here on our start okay just like that
577:09 - and for showing let's show it when we
577:12 - actually rebind an action so right in
577:13 - here but since we're going to have tons
577:16 - of listeners to these events let's
577:17 - actually make a nice separate function
577:19 - to handle all of the rebinding logic so
577:21 - down here let's make a function rebind
577:24 - binding
577:26 - we receive a game input.binding
577:31 - then first we show the press rewind key
577:33 - and then let's go into game input access
577:36 - the instance and time to rebind binding
577:38 - and pass in the same binding
577:40 - okay so we have this and now up here on
577:42 - the button event let's just call in this
577:44 - function okay very simple so this will
577:47 - work for actually showing the window but
577:50 - now we need to know when to hide it and
577:52 - for that let's use something that we've
577:54 - used a few times in this course but
577:55 - never directly let's use a c-sharp
577:57 - donate as usual I have a dedicated video
577:59 - on them this is basically how you can
578:01 - define a field or a parameter of a type
578:04 - which can hold a function it's another
578:06 - Super useful CCR feature definitely
578:08 - watch that video to learn all about it
578:10 - let's go here on the game input and down
578:13 - here when we have our rewind binding
578:16 - over here let's receive a second
578:17 - parameter this one is going to be of
578:19 - type action this is one of the built-in
578:21 - dongates it takes no parameters and
578:23 - returns void so this one is perfect for
578:26 - a simple comeback just like this one
578:27 - let's go with on action rebound and
578:30 - we're going to trigger this right here
578:32 - after we achieve the convex so we get
578:34 - the comeback let's trigger this just
578:36 - like that and let's also get rid of
578:38 - these testing logs we no longer need
578:39 - them so just like this
578:40 - now back here on the options UI so we've
578:43 - got that and for the second parameter
578:45 - let's just pass in the function to hide
578:47 - that window so hi the press the rewind
578:50 - key that's it again remember we're
578:52 - passing in the function itself we're not
578:54 - calling it so there's no parentheses
578:56 - we're just passing in the function
578:58 - itself okay so with this let's test so
579:01 - here on the options let's rebind the
579:03 - move W and there you go it does show up
579:04 - to window and now if I press the key you
579:06 - better go down hides okay great so this
579:09 - is working but over here the text is
579:10 - still not updating so over here on the
579:12 - second comeback instead of just calling
579:14 - this function we need to call this and
579:16 - then also call the update visual
579:18 - function so as usual let's use a simple
579:20 - Lambda expression to do exactly both
579:22 - so let's open and close the parentheses
579:25 - and we do exactly this
579:28 - so we hide the price of rebind and then
579:30 - we update the visual okay that's it
579:32 - let's test so here we are let's rewind
579:34 - the move down we press on the T key and
579:36 - there you go we did rebind and it did
579:38 - update all right great now let's just
579:41 - apply this to all of the other bindings
579:42 - so first up here on the buttons let's
579:45 - set listeners to all the buttons so
579:47 - let's see move left
579:49 - actually be moved down
579:51 - then the move left move right the
579:55 - interact button
579:56 - the interact alternate button and
579:59 - finally the pause button and for the
580:01 - bindings this one is the fast binding
580:03 - the interact alternate then the interact
580:07 - then the move this one is the right
580:10 - again make sure you don't make mistakes
580:12 - here you call them the exact same one so
580:14 - they move down okay so all of it is
580:16 - correct here
580:17 - and over here on the player input let's
580:19 - do a switch on our binding
580:30 - so Keys move up we do something and now
580:33 - we could write this code directly up
580:34 - here and then make a move down and write
580:37 - a bunch more code that would work but
580:38 - that would be way too worthy so let's
580:40 - write our code in a nice clean way
580:42 - basically the only thing we need down
580:44 - here is we need to know the actual
580:46 - action we're going to rebind and we need
580:48 - to know the action index so let's just
580:50 - find up here exactly that so an input
580:52 - action for the input action
580:54 - and then an end for the binding index
580:57 - okay and then over here when we have the
580:59 - switch for all of our bindings we just
581:00 - set those so the input action in this
581:03 - case it's going to be the player input
581:05 - actions player and it's the move action
581:08 - and for The Binding index
581:10 - this one is on index one
581:13 - then we're going to have the other moves
581:14 - so they move down is going to be on
581:17 - index 2.
581:19 - then left and right
581:25 - these are on index 3 and 4. okay so we
581:28 - have all these and now for the other
581:30 - ones
581:31 - so for the interact this is the interact
581:33 - action on binding zero then we've got
581:36 - the interact alternate and the pause
581:38 - so interact alternate and the pause
581:42 - and this one is the pause action and the
581:44 - interact alternate action and all of
581:45 - them are on finding index of zero okay
581:48 - so that's good so over here we are
581:49 - assigning the input action and defining
581:50 - index and also one thing we need to make
581:52 - sure to always assign these values
581:55 - so let's make sure to add a default here
581:57 - just make sure it always works okay
581:58 - great so now down here instead of always
582:01 - accessing the move let's access whatever
582:03 - is stored in the input action
582:05 - and for The Binding whatever it is on
582:07 - The Binding index okay so now this will
582:09 - work with all of our bindings so here we
582:11 - are and let's try rebinding all of them
582:13 - so let's put them over here on the side
582:15 - so before it move up let's put on T down
582:17 - on G A on F then D on H for the interact
582:22 - on y interact jumped on J and for the
582:26 - Escape let's put it on E okay so all
582:28 - these Keys have been rebound let's just
582:30 - make sure they work so here I am moving
582:32 - with these keys and yep it does work go
582:34 - up here to interact and do the alt
582:36 - interact and now the pause and if there
582:38 - you go everything works perfectly
582:39 - alright awesome so everything worked
582:42 - perfectly although again we have the
582:44 - same issue as previously so all the keys
582:46 - have been rebound so it's not correct
582:48 - right however now if I stop playing and
582:51 - now if I play again
582:52 - and nope there's the issue the rebinding
582:54 - was lost so just like with the sound we
582:57 - also need to save the new state now
582:59 - thankfully the new input system has a
583:01 - function that makes that super easy
583:03 - let's go down to where we are rebinding
583:05 - things and when we finish rebinding
583:07 - let's just go into the player input
583:09 - actions and let's call this function the
583:12 - save bindings overrides as Json
583:15 - this one is going to return a Json
583:17 - string now if you don't know what is
583:19 - Json go watch my quick video on it
583:21 - basically it's a super easy to
583:22 - understand and widely used file format
583:25 - it's very easy to read and modify it's a
583:28 - format where it's stored as just text so
583:30 - let's look at what this says once we
583:32 - debug down log over here after rebinding
583:34 - something let's see so here if I rebind
583:37 - one of these and if there you go there
583:39 - we have our Json so the override
583:41 - Bindings that overload the move on this
583:44 - ID on this new path so basically we just
583:46 - need to sort this string somewhere and
583:48 - just like we did with the sound let's
583:50 - just store it in the player prefs so
583:52 - first let's define our constant so
583:54 - private constring for the player prefs
583:58 - bindings
583:59 - and let's call this the input bindings
584:04 - okay just like this
584:07 - so then down here after we rebind the
584:09 - king
584:10 - let's go into player prefs and let's set
584:13 - a string on the player prefs
584:17 - bindings
584:18 - and we're going to save the overrides as
584:20 - Json
584:23 - and after we do let's just make sure the
584:24 - player perhaps is correctly saved okay
584:26 - so that saves it then let's go on a way
584:29 - to unload it so over here on awake let's
584:31 - load that
584:33 - let's first do a quick test to see if
584:34 - there's a save so if the player prefs if
584:38 - it has a king and if it has this key
584:42 - if so then let's get it so the player
584:45 - prefs let's get the string on this key
584:48 - that returns this ring and we're going
584:49 - to use the string let's just go into the
584:51 - player input actions
584:53 - and let's call the function load binding
584:55 - overrides from Json just like this and
584:58 - also let's make sure we do this right
584:59 - after we construct the object and before
585:01 - we enable the action map okay so that's
585:04 - really it let's test so here we are
585:06 - let's rebind the move up to T okay hit
585:09 - rebound now stop playing now playing
585:11 - again and you appeared is still rebound
585:13 - to T alright awesome okay so here we
585:16 - created a really nice options menu where
585:19 - we can modify the volume and rebind keys
585:21 - the only issue that we still have is
585:23 - that we can only navigate the menus with
585:25 - the mouse so let's add support for many
585:27 - navigation with a controller in the next
585:28 - lecture
585:30 - hello and welcome I'm your code monkey
585:32 - in this lecture we're going to set up
585:34 - phone controller support for our game
585:35 - including regular actions and menu
585:38 - navigation okay so first let's just set
585:40 - up the controller input I have an Xbox
585:42 - impact controller connected so let's
585:45 - open up our player input actions and
585:47 - over here we have all of our actions and
585:49 - we already made the move one a long time
585:51 - ago so let's just add the bindings for
585:53 - the other ones for example over here on
585:55 - the interact let's add a brand new
585:56 - binding let's go into the path and
585:58 - listen and for interact I'm going to
586:00 - press the A Button and again here you
586:03 - can specify just the a button on Xbox
586:05 - controller or you can use the generic
586:07 - South button which will mean a on an
586:09 - Xbox or cross on a PlayStation or B on a
586:12 - switch or anything else so let's go with
586:14 - the generic one for the internal
586:16 - alternate let's add a binding and for
586:18 - this one I'm going to put it on the X on
586:19 - the Xbox so the button West
586:21 - and for the pause let's add let's listen
586:24 - and I'm going to press the menu which is
586:26 - the start button okay so these are the
586:28 - basic inputs let's make sure they work
586:31 - and thanks to this new input system we
586:33 - really don't need to modify any code
586:34 - let's just save this asset
586:37 - let's wait for the compilation and then
586:39 - we can do a test so here we are and yep
586:41 - I'm using my control to move now let's
586:43 - just wait for the countdown
586:45 - and go up there and pick up a cheese put
586:47 - it and slice some cheese yep I can do
586:49 - that pick up a plate and so on all right
586:51 - so everything works let's also pause and
586:53 - yep that also works okay great so
586:55 - everything works except there are two
586:57 - issues with the GamePad especially one
587:00 - with the movement that I only noticed
587:01 - just now the first issue that we have is
587:04 - the dead zone right now we don't have
587:05 - one so if I just lightly touch my
587:08 - Gamepad joystick there you go it starts
587:10 - moving automatically in Gamepad games
587:12 - you should always have some kind of dead
587:13 - zone to prevent any kind of joy-con
587:15 - drift thankfully that is super easy to
587:16 - Zone let's just go into the player input
587:18 - action so let's go into the move find
587:20 - the left stick binding
587:21 - and over here for the processors let's
587:23 - add one and let's add a stick dead zone
587:25 - so that's it pretty simple this
587:28 - basically considers that inputs under
587:30 - this minimum to be zero and above this
587:32 - maximum to be one so if you have
587:34 - joystick drift where when the joystick
587:36 - is Idle it's always moving by say 0.1
587:39 - and direction this helps solve that
587:41 - problem except in our case for a game
587:42 - we're only using normalized inputs so
587:45 - actually for our use case let's increase
587:46 - the minimum by quite a bit I did some
587:49 - testing in 0.5 Works quite great and the
587:51 - max that default that is just fine okay
587:54 - so that's it one problem solved let's
587:56 - just go ahead save this Ascent now the
587:58 - other bigger issue that we have is if I
588:00 - approach a counter and I try and look at
588:01 - it it's really difficult it tries moving
588:04 - left and right instead of actually
588:05 - facing the counter that's because the
588:07 - logic that we added in a long time ago
588:09 - that logic to help the character
588:10 - controller feel better when moving on
588:12 - diagonals against the counter
588:14 - that works great for keyboard because
588:16 - it's digital so it's either moving phone
588:18 - and left probably right or on the
588:19 - diagonals
588:21 - but it messes up the control which is
588:22 - analog on the player movement if we are
588:25 - not moving perfectly up or perfectly
588:26 - down then it's considered a diagonal and
588:28 - on a Gamepad it's really difficult to
588:30 - get a perfect just up or just down input
588:32 - we're always going to have a tiny bit of
588:34 - either left or right so that's the issue
588:36 - that we have here and thankfully the
588:38 - solution is actually pretty simple let's
588:40 - go over here on to our player script and
588:42 - let's scroll down into the handle
588:43 - movement function okay
588:45 - so we're doing a can move using the
588:47 - regular move Direction and if it doesn't
588:48 - work then it's over here that we are
588:50 - attempting only the X movement or only
588:51 - the Z movement and for doing that we
588:54 - made it so we can move if there is
588:56 - nothing only on the X and if we have any
588:58 - movement at all on the X so if it is
589:00 - different from zero basically the issue
589:02 - here is if the move dear.x is let's say
589:05 - 0.001 that is still different from zero
589:07 - so it is still going to trigger this
589:08 - logic so basically let's just widen this
589:11 - Gap instead of testing literally just
589:13 - different from zero let's test if they
589:15 - moved here.x if it is under say minus
589:18 - 0.5 F or if moved here dot X if it is
589:22 - bigger than plus 0.5 f
589:24 - so instead of being exactly just on zero
589:27 - we're only going to consider diagonals
589:28 - if we are at least moving 0.5 either
589:30 - left or right so we just did this and
589:33 - same thing over here except we just test
589:34 - for this n so we moved here.z and they
589:37 - move the other dot set okay so like this
589:40 - it should feel much better on the
589:41 - GamePad and still work exactly the same
589:43 - on the keyboard so let's test
589:45 - so here I am moving around and yep now
589:47 - it is much easier to just stay around
589:48 - and look straight at the counter okay so
589:51 - that's great so I can pick up and this
589:53 - is all much much easier and the
589:55 - character is no longer just sliding left
589:56 - and right Non-Stop okay that's great so
590:00 - now that this is working let's set
590:01 - support for rebinding our controller
590:03 - bindings so over here on the game input
590:05 - let's do it just like we did for the
590:07 - keyboard so let's add a bunch more
590:08 - bindings over here on the enum let's add
590:10 - the GamePad interact then the GamePad
590:13 - interact alternate and then the GamePad
590:17 - pause
590:18 - okay so we have our bindings then let's
590:20 - go down and add them to both our
590:22 - functions so of course the text and then
590:23 - the bindings so we're here on the text
590:25 - let's copy pretty much this we're going
590:28 - to have the GamePad interact then we're
590:30 - going to have the other two so the
590:32 - GamePad tracked alternate and the
590:34 - GamePad pause okay
590:36 - now for these bindings we're going to
590:38 - use the same actions so this one is the
590:40 - interact alternate and over here we have
590:42 - the interact and over here on the input
590:44 - actions we saw that we added for all of
590:45 - them on index 0 we have the keyboard and
590:48 - on the next one we have all the gamepads
590:50 - so over here that's literally don't
590:52 - change for the GamePad let's go into
590:54 - bindings and access the array on index
590:56 - one
590:57 - okay and then over here on the rebind
590:59 - binding it's going to be pretty much the
591:01 - exact same thing so let's copy all these
591:03 - change this to the GamePad interact then
591:06 - the GamePad interact alternate and then
591:09 - the GamePad pause some of these all we
591:12 - need to change is just by an index put
591:14 - them all on one okay so with that all of
591:16 - the code over here on the game input is
591:18 - working perfectly now let's go over here
591:20 - into our options UI so we've got all of
591:22 - our buttons so let's duplicate our
591:25 - buttons let's just go into the
591:26 - interactive pause and so on let's
591:27 - duplicate push them to the right side
591:29 - okay
591:30 - and just change the name so let's get
591:32 - into all of them so this one's the game
591:35 - pad interact button then the game pad
591:38 - interact alternate and finally the
591:40 - GamePad Parts okay
591:42 - also inside let's also rename these
591:44 - buttons just to make sure the text works
591:46 - great
591:49 - and let's also make sure that these show
591:51 - up behind the press the rebound key so
591:53 - let's drag them put them above okay so
591:56 - that's our setup over here on the
591:57 - options UI now let's go over here on the
591:59 - options UI script and let's add
592:01 - references to our buttons and to our
592:03 - text objects
592:04 - so let's copy all these the GamePad and
592:07 - add all these this is the pause the
592:09 - interact and the interact confident and
592:12 - then down here the exact same thing
592:14 - let's add all of these
592:18 - okay like this now over here let's drag
592:21 - all of our references so on the options
592:22 - UI let's make sure to always write the
592:25 - correct things so the GamePad interact
592:27 - text the interact alternate text and the
592:31 - pause button text and then the buttons
592:33 - themselves so the pause button interact
592:36 - alt and the interact button again make
592:38 - sure you always drag the correct
592:40 - references so check and double check
592:41 - make sure everything is correct okay
592:43 - then over here for our code let's first
592:46 - handle the text over here
592:48 - so the text for all these
592:51 - so the GamePad interact text then the
592:54 - GamePad interact alternate text and
592:56 - finally the GamePad pause text and we
592:58 - just go the game file pause the GamePad
593:01 - interact alternate and the GamePad
593:03 - interact finally over here on the
593:05 - buttons let's do the exact same thing
593:08 - so Gamepad interact interact alternate
593:10 - and the pause
593:14 - okay so we added everything let's do a
593:17 - test and see if everything is working so
593:19 - over here let's pause the game go into
593:21 - the options and for the interact let's
593:23 - modify this one instead of a and let's
593:25 - put it on B and yeah there you go it did
593:27 - go so let's close let's resume and now
593:29 - let's see so if I approach and I press a
593:31 - nothing happens Press B and there you go
593:33 - it does interact okay awesome so the
593:36 - rebinding is all working perfectly
593:37 - except we have another obvious issue
593:40 - I can pause with the GamePad however now
593:43 - with this pause I cannot click on any of
593:45 - those buttons and if I go back to the
593:47 - main menu
593:48 - over here I also cannot do anything with
593:50 - a controller so at some of that the
593:52 - first step is on the event system object
593:54 - look at how it shows us this warning
593:56 - basically if we're using the new input
593:58 - system we should be using a different
594:00 - input Handler here thankfully this is
594:02 - super easy we just need to click on this
594:04 - button and yep that's it it
594:05 - automatically sets it up now the way
594:07 - that this works is by pre-selecting
594:09 - buttons in order to better see which
594:11 - button is selected we should probably
594:13 - add a more visible color let's go into
594:15 - our pause window so for now let's hide
594:17 - over here the options UI show the pause
594:19 - window and we have these three buttons
594:21 - let's select all of them
594:23 - and over here on the right side on the
594:25 - button we can see one option for the
594:27 - selected color
594:29 - so instead of being white which is going
594:30 - to be really difficult to see let's put
594:32 - something really visible so let's say
594:33 - like a bright green okay like this
594:37 - let's do the same thing for all of the
594:39 - buttons on the options UI so let's show
594:41 - this one and find all the buttons so
594:44 - we've got all of these ones down here
594:47 - and these three ones up here and let's
594:49 - do the same thing so on the selected
594:50 - let's put it all on my screen okay so
594:53 - all the buttons have a nice selected
594:55 - color and just like this if we test and
594:57 - if I pause the game
594:59 - and right now nothing is selected so
595:01 - right now I cannot do anything with the
595:03 - controller however if I press over here
595:05 - with the mouse on this button and then
595:07 - let go once outside the button yep look
595:10 - at that now that button is selected so
595:12 - now as long as that one is selected now
595:13 - if I move with the mouse pad yep now I
595:15 - can navigate through this menu and if I
595:17 - press on a yep I can essentially click
595:19 - that button so that's great basically
595:22 - all we need is to make sure that we
595:23 - select the button as soon as the pause
595:24 - menu shows up so let's go over here on
595:27 - the game pause UI script and then over
595:29 - here let's go into the show function so
595:30 - when we show this window when we do
595:32 - let's go into the resume button and just
595:34 - call the select function this will make
595:36 - it selected so that's it and with this
595:38 - if we test and now here with the game
595:40 - playing if I pause whilst pressing the
595:42 - button on the GamePad and if they go
595:45 - down and selected and now I can select
595:46 - any option okay that's great so now it
595:49 - works fully with just the GamePad except
595:51 - now if I go into options yep now you can
595:54 - see that the button that is selected is
595:55 - on the options one over there on the
595:57 - background so let's also make sure to
595:59 - select a button on the options as soon
596:00 - as the options window shows up so over
596:02 - here on the options UI let's go into our
596:05 - show function
596:06 - and let's just select the sound effects
596:08 - button and just console it okay let's
596:10 - test so here let's pause go into options
596:13 - select any of the Lego that did work
596:15 - okay great except we have another issue
596:18 - as I move up or down over here on these
596:21 - buttons you have a look at that some of
596:23 - them are a bit strange like for example
596:25 - over here on a I'm moving up and look at
596:28 - that it actually selected the resume
596:29 - button behind it so as we are moving up
596:32 - or down we are actually selecting
596:34 - buttons on both menus that's very
596:36 - strange basically what is going on is
596:39 - that since both windows are visible the
596:40 - game is trying to guess which button we
596:42 - want to select basically what is
596:44 - happening is Unity is trying to use
596:46 - automatic navigation if we select the
596:48 - button so let's go for example let's
596:50 - hide the options and show just the game
596:54 - pause okay let's select one of these
596:55 - buttons and over there on the button
596:57 - component we can see navigation is set
596:59 - to automatic and we have a button to
597:01 - visualize and if we click on that yep
597:03 - over here we can see all kinds of arrows
597:05 - for example we we can see one over here
597:07 - on the options that seems to be going to
597:09 - some button in there that is going to be
597:11 - the button that is showing over there so
597:14 - if we move down from the options we're
597:15 - going to end up over here on the
597:16 - interact alt button now usually the
597:19 - automatic navigation actually works very
597:21 - well the only reason why we're having
597:22 - problems is because we have both windows
597:25 - active at once one solution to this is
597:27 - to make the navigation explicit so let's
597:29 - hide the options here and over here on
597:31 - the resume on the navigation instead of
597:33 - automatic let's put none and then let's
597:36 - select explicit and if now we have our
597:38 - own four Fields so we can decide which
597:40 - object gets selected when we are here
597:42 - and we move up down left or right so for
597:45 - example here we would drag for the up
597:46 - going up we could go into the main menu
597:48 - so we will drag that button and going
597:51 - down we could drag the options button so
597:53 - that's one solution just add the
597:55 - explicit navigation to every single
597:56 - button or another simpler solution is
597:59 - let's leave this one on automatic and it
598:02 - said we're just going to hide the pause
598:03 - window once we are in the options window
598:05 - so over here on the game pause UI let's
598:08 - see over here we are showing the options
598:10 - you Ai and when we do let's just call
598:12 - hide on this so we are going to hide
598:14 - this window when we show the options and
598:17 - then on the options we want to know when
598:19 - the options closes so that we can show
598:21 - this one again so over here on the show
598:23 - function let's receive an action this is
598:26 - what we're going to do when we close the
598:28 - options let's call it on close button
598:31 - action
598:32 - and let's store it up here so let's
598:34 - store
598:36 - a simple and private action for this
598:38 - okay so we have this and then down here
598:40 - when we have our show function when we
598:43 - have let's set this equals this we store
598:45 - this and then we're just going to run
598:46 - this action whenever we click on the
598:48 - close button so let's go over here the
598:50 - close button we've got that one let's
598:52 - hide the options window and Trigger this
598:54 - action so now we need is over here on
598:56 - the game plus UI let's pass in and
598:58 - basically when we close the options UI
599:01 - we want to show the POS UI okay so let's
599:04 - test so here we are let's pause the game
599:06 - okay let's go into options and open it
599:08 - and if there go it only shows the
599:10 - options and over here moving up or down
599:11 - works perfectly and moving left and
599:13 - right also works perfectly
599:15 - and now if I want to go back let's go
599:17 - into close press it and there you go
599:18 - back into the pause menu
599:20 - all right awesome so everything is
599:22 - working perfectly now the last thing we
599:24 - need is over here on the main menu so
599:26 - let's do the same thing first let's open
599:28 - up the main menu scene
599:30 - let's save the changes okay and over
599:32 - here let's begin by doing the same thing
599:34 - on the event system so let's replace it
599:36 - okay great
599:37 - then let's go inside our canvas inside
599:39 - main menu y let's select our buttons and
599:43 - once again let's modify the select color
599:45 - put it on my screen all right and since
599:47 - over here we only have one menu we could
599:50 - set a test selected over here on the
599:52 - main menu UI script
599:54 - that's one option or we can just go into
599:56 - the event system and over here on the
599:58 - event system there's a film for the
599:59 - first selected so you can just drag the
600:02 - play button and that will automatically
600:03 - make it the selected one so it says and
600:06 - yep the play button starts off as
600:08 - selected and I can move up or down
600:10 - and if I press a button yep there you go
600:13 - here I am playing the game I can pause I
600:14 - can resume go back to the main menu and
600:16 - so on all right awesome so here we have
600:18 - the final thing we needed to make our
600:20 - game fully playable with the GamePad
600:22 - thanks to how the input system works and
600:24 - the menu automatic navigation this was a
600:26 - pretty simple task for this our game is
600:28 - pretty much completely done however the
600:30 - next lecture is also one of the most
600:32 - important lectures it's all about
600:34 - publish so let's do that in the next
600:35 - lecture
600:37 - hello and welcome I'm your code monkey
600:39 - in this lecture we're going to add all
600:41 - kinds of small things to polish our
600:43 - power game if you are regular on this
600:45 - channel then you've certainly heard me
600:46 - say that polish is what separates good
600:48 - games from great games so as you build
600:50 - your own games make sure you don't
600:51 - neglect polish here let's add a bunch of
600:54 - small tiny things that will make a big
600:56 - difference in the final game let's begin
600:58 - with a very simple very visual one let's
601:01 - just add some ones to our map and first
601:03 - let's just hide our canvas so that it's
601:05 - not blocking our view so again over here
601:07 - we can use the buttons on the hierarchy
601:09 - to hide it okay great
601:11 - so let's add some walls and for that
601:13 - let's create a brand new 3D cube let's
601:16 - name this a wall let's put it quite a
601:18 - bit thin so over here on the scale for
601:20 - the X so let's put it 0.25 then on the
601:23 - one let's put three so something like
601:25 - this then we modified Z so let's put it
601:27 - over here on the side right next to the
601:29 - counters okay so that's the wall let's
601:31 - just stretch it out One Direction and
601:34 - the other one okay so that's our basic
601:37 - one
601:37 - now when you included project files
601:40 - there's a nice one material so let's go
601:41 - over here into assets under materials
601:43 - and you appeared as you want material so
601:45 - let's just drag it and use this one and
601:47 - if there you go it's just a nice simple
601:48 - gradient this is also an example of how
601:51 - you can take something simple and make
601:52 - it a bit more interesting if you look at
601:54 - this material the base texture is really
601:56 - just this it is literally just a simple
601:59 - vertical gradient texture and then with
602:02 - the color point to it and looks pretty
602:03 - good okay so this dual let's put the
602:06 - wall on on three sides so let's
602:07 - supplicate this so just select and press
602:09 - Ctrl D 2.8 let's put one on the other
602:12 - side so right there right next to the
602:15 - counters okay and finally the one there
602:17 - so Ctrl D to duplicate it let's push it
602:19 - over there on the side and rotate it 90
602:21 - degrees
602:23 - and let's put it just like that let's
602:26 - just scale it to get to that end and to
602:29 - get to that end okay so we have our nice
602:31 - walls but over here if we're playing the
602:33 - game we can still see the floor on the
602:35 - outside that looks a bit ugly so let's
602:37 - fix that
602:38 - let's create another object and let's
602:40 - create a 3D object another Cube and for
602:43 - this Cube let's put it over here on the
602:45 - side and this one let's use the black
602:46 - material so again in the included assets
602:48 - there's this nice black material there
602:50 - you go it's completely black nothing to
602:52 - it
602:53 - so let's just use this as kind of a
602:55 - Hider so let's just scale it quite a bit
602:58 - and lift it up
603:02 - okay so there it is a black material
603:04 - right next to the wall and let's put
603:06 - another one over here on the left side
603:09 - and just like that
603:10 - you can also put another one on the back
603:12 - there even though I don't think the
603:13 - camera can see that part but still let's
603:15 - put it so just put it like that and
603:18 - stretch it out okay that's good by the
603:21 - way over here on the outside it doesn't
603:23 - have to be perfect doesn't have to
603:24 - perfectly match the camera is never
603:26 - going to see that position so it doesn't
603:27 - matter it only matters what the camera
603:29 - can see and if we pull it like this and
603:32 - if they're yellow now that looks quite
603:34 - nice if we want over there we can get it
603:36 - together just a little bit and we can
603:38 - also move the camera forward a tiny bit
603:41 - so over here on this one let's push it
603:44 - just a little bit to the left okay and
603:46 - now in the virtual camera
603:48 - let's play the game
603:50 - and now here if we want we can push it
603:52 - up a little bit something like this so
603:54 - let's put it on this set so let's copy
603:56 - it stop playing the game and let's paste
603:59 - it just like that
604:00 - okay so here's our game and as you can
604:02 - see with just this one tiny chain just
604:04 - adding some walls and a nice black
604:06 - outside just with that it already looks
604:08 - so much better than having some counters
604:10 - in wide open space now for another
604:12 - simple one let's add some nice particles
604:14 - while the player is moving
604:16 - so in the included assets if we go
604:18 - inside the prefab visuals over here is a
604:20 - nice one for player moving particles
604:21 - this one as you can see is a particle
604:24 - system so let's drag it over here into
604:26 - the world see what it looks like and as
604:28 - you can see by default it's actually not
604:29 - spawning anything so I can make sure
604:31 - that this one is running and nope
604:32 - nothing is spawning so this is actually
604:34 - set up in a really interesting way is
604:36 - that instead of spawning particles all
604:38 - the time it only emits while moving so
604:40 - if I click to move this object there you
604:42 - go the particles start emitting and if I
604:44 - stop they stop so this one is definitely
604:46 - perfect for a player particle system the
604:49 - way this setup is over here on the
604:51 - emission on rate over time it is set to
604:54 - zero so it doesn't spawn anything
604:55 - automatically and it only has over here
604:57 - the rate over distance so as it moves
604:59 - it's going to spawn that number of
605:01 - particles then the other settings
605:02 - they're all pretty basic so there's some
605:05 - gravity so they fall down just like the
605:07 - stove counter particles simulation is
605:10 - over here on space so that as I move the
605:12 - particle stay behind this is important
605:14 - if I were to put that in local and I
605:16 - move it around look at that this is not
605:17 - what we want we want the particles to
605:19 - essentially stay behind instead of
605:21 - following this transform so that is why
605:23 - this change is super important if that
605:25 - one is set to whirl and as I move yep
605:27 - the particles stay behind okay great and
605:29 - the other property is around pretty
605:31 - basic for the shape it's a cone pointing
605:33 - upwards then for the size of our
605:35 - lifetime again just a basic curve
605:37 - constantly becoming smaller and smaller
605:39 - and down here on the renderer instead of
605:42 - rendering your quads actually rendering
605:43 - a mesh and it's rendering a sphere mesh
605:45 - so that's just so that it looks a little
605:47 - bit better I think than just having a
605:49 - Sprite particle okay so that's it so in
605:51 - order to make this work really all we
605:53 - need is just attach it to the player
605:55 - so let's find the player make this
605:57 - object a child of the player game object
605:59 - and again let's also make sure to set
606:01 - all of this to zero so the position on
606:03 - zero zero and zero
606:06 - and there you go just with this that's
606:07 - all we need if we test here we are
606:09 - stopping there are no particles and as I
606:11 - start moving if there you go some nice
606:13 - particles around the player okay great
606:16 - next let's add a pretty obvious one some
606:18 - kind of mini tutorial we want a window
606:21 - to show the controls and the goal of the
606:23 - game and wait for the player input
606:24 - before we start the countdown
606:26 - so for that let's go into our canvas so
606:28 - let's show our canvas and inside let's
606:31 - create an empty game object called the
606:34 - tutorial UI
606:35 - let's drag this one above the game pause
606:37 - window so that it shows up behind it
606:39 - let's double click to center it and
606:41 - let's press on the 2D button to go into
606:43 - 2D mode okay let's also hide those two
606:46 - windows so you can actually see what
606:47 - we're doing so outside all of these okay
606:49 - great
606:50 - now this one first of all let's stretch
606:52 - it to occupy everything so put zero on
606:54 - everything okay then inside let's make a
606:57 - UI image for our background once again
607:01 - let's stretch it put it like this
607:04 - and for this one instead of black like
607:06 - we've used for all of our Windows let's
607:07 - actually leave it on white put it on an
607:09 - alpha something like half so something
607:11 - like this just to be a bit different
607:12 - then on top of this let's make another
607:14 - image so let's make another UI image and
607:17 - for this one instead of stretching let's
607:18 - give it a size so let's put it on 1280
607:20 - by 800 and for the image I created a
607:24 - nice image for the tutorial if we go
607:26 - inside the assets and then inside
607:28 - textures yup here is a really nice
607:30 - tutorial image
607:32 - so let's just go ahead and use it so on
607:34 - the image let's drag it all right
607:36 - there's our nice internal image so this
607:38 - has a pre-based tutorial so the recipe
607:40 - is coming from the customers then the
607:42 - player has to prepare the correct
607:43 - recipes and deliver them on a plate on
607:45 - the delivery counter so just a very base
607:47 - tutorial and also over here it's very
607:50 - important for the player to know how to
607:51 - actually play the game so there are some
607:53 - labels for the controls and now we're
607:55 - going to dynamically add some keys on
607:57 - top so let's do that let's create an
607:59 - empty game object call this the king
608:02 - let's put it on a size of 40 by 40 okay
608:06 - now let's go inside and inside let's
608:09 - make an image let's name this the
608:11 - background
608:12 - and for the Sprite let's go with the
608:15 - included Circle so default Circle
608:18 - and for the size let's stretch it occupy
608:20 - everything put it on zero zero zero okay
608:23 - there's our nice key
608:25 - so we have the background and for the
608:27 - background let's actually make it just a
608:29 - little bit darker
608:30 - and let's also add just a nice shadow so
608:34 - maybe three minus three and let's also
608:36 - make a nice upline
608:38 - let's put it on two by two
608:41 - full Alpha so something like this just
608:43 - to be a nice one maybe one by one okay
608:45 - so that's just the visual and then on
608:47 - top of it let's add a text
608:49 - and this one's essentially going to be
608:51 - the king so let's put a key for the
608:53 - width and height let's stretch it to
608:56 - match the parent size okay then for the
608:58 - phone here let's go with maybe just say
609:00 - 20 let's put it Center down the middle
609:02 - and also let's put it on bond okay so
609:05 - that's our nice key indicator
609:07 - so this is our key and we're going to
609:10 - have the movement so the movement on the
609:11 - keyboard is going to have four keys so
609:13 - let's just implicate so one two three
609:16 - and four Keys okay then on the GamePad
609:20 - that one is actually not rebindable so
609:22 - let's put this one as static
609:24 - so let's just go inside inside the text
609:27 - and just say left stick and let's lower
609:31 - the font size so that it fits in there
609:32 - okay great
609:33 - then for some more keys
609:36 - we're going to have the interact action
609:38 - then the interact alternate
609:41 - and finally the pause action
609:43 - then let's just duplicate these to be on
609:45 - the other side
609:52 - okay so these are all of our keys now
609:55 - instead of having key one two three this
609:57 - is very difficult to understand so let's
609:58 - give it some proper names so this is the
610:00 - key move up then we have the key move
610:03 - down
610:05 - then the key moves left then the key
610:08 - move right
610:09 - then this one is going to be the key
610:12 - Gamepad move
610:14 - then we have the key interact
610:17 - the key interact alternates
610:21 - the key pause
610:23 - this one is the key Gamepad interact
610:26 - alternate
610:28 - this one is the key Gamepad interact and
610:31 - finally the key Gamepad pause
610:36 - okay all of these and since we're going
610:38 - to drag references to the text objects
610:40 - let's also give those a name
610:41 - so just copy drop it with text
610:45 - just like this
610:51 - okay so those are all the names so
610:53 - everything is nice and organized okay
610:54 - great now let's make the script to run
610:57 - this so our tutorial UI let's go down
610:59 - into our UI scripts create the brand new
611:02 - c-sharp script for the tutorial UI and
611:05 - let's attach the script okay
611:07 - so first let's drag references to all of
611:09 - our keys we only need the text so let's
611:12 - do a serialize field of type text mesh
611:15 - Pro U going again never make the mistake
611:17 - always use the ugly one if we're working
611:19 - the UI so the key move of text
611:23 - so let's add all of these
611:28 - okay these are all the references then
611:30 - over here let's drag on and make sure to
611:32 - drag the correct ones
611:37 - okay let's double check to make sure all
611:40 - the references are correct okay they
611:41 - don't seem correct all right great and
611:43 - then over here only to pretty much
611:45 - exactly the same thing that we did over
611:46 - here on the options so we need exactly
611:49 - this so let's copy this and over here
611:52 - and let's do just that
611:54 - let's see a private void update visual
611:57 - and on this one let's do pretty much
611:59 - this so the key move up text
612:01 - I know this one you get binding text to
612:03 - move up yep let's just do all the others
612:15 - okay so those are all the bindings
612:17 - that's great now let's go over here on a
612:20 - proud void start and on start let's
612:23 - update our visual all right and also
612:25 - let's make sure this updates just in
612:27 - case the player rebinds something from
612:29 - the pause menu once the tutorial is
612:31 - still visible
612:32 - so we just need to know when that
612:34 - happens so let's go over here onto the
612:35 - game input and make a nice event so
612:37 - public event even Handler let's call it
612:40 - on binding rebind
612:43 - okay we have this event and down here
612:45 - when we have our rebind binding function
612:47 - we do this we rebind and over here let's
612:50 - invoke this event
612:57 - okay just like this
612:59 - so then on TTR only y let's go into the
613:02 - game input the instance on binding
613:05 - rebind let's listen to this event and as
613:08 - always let's rename this so let's put a
613:10 - game input okay when this happens let's
613:13 - simply update the visual
613:15 - okay that's it pretty simple so let's
613:17 - test and see if the inputs are correct
613:19 - and if there it is we do see it correct
613:21 - so we've got ones we've got e to
613:23 - interact F and over there we've got the
613:25 - GamePad okay great so all the buttons
613:28 - are correct all that's left is the show
613:30 - and hide so over here let's make the
613:32 - usual two functions so product void show
613:35 - and a proud boy in Hind and for these
613:38 - game objects set active and this one is
613:41 - going to be into false and this one's
613:43 - going to be true okay
613:45 - so for show up here on start let's
613:47 - actually show it by default even though
613:49 - it's actually already going to be shown
613:51 - but still okay then for the hind this
613:54 - one we want to hide when we press the
613:56 - interaction
613:57 - however when that happens we don't want
614:00 - just this window to hide we want the
614:02 - kitchen game manager to change the state
614:04 - so we're here on the kitchen game
614:06 - manager we currently have the waiting to
614:08 - start and that one actually has a timer
614:10 - so we count down the timer and then we
614:12 - start whereas right now we want it to be
614:14 - based on player input so let's modify
614:16 - this to not be based on timer so let's
614:18 - just get rid of this timer
614:20 - and now let's see all these errors so
614:22 - I'm waiting to start we are not going to
614:24 - count down any timers instead let's
614:26 - listen to the game input so game input
614:30 - let's listen to the on interact action
614:32 - event and rename this to the game input
614:36 - okay so when we have this event when the
614:39 - player presses the interact action let's
614:41 - check if the state if this one is on
614:44 - waiting to start
614:45 - if so then let's modify the state so
614:47 - let's go into State and we're going to
614:49 - go into the countdown to start and let's
614:51 - trigger the on state changed event
614:58 - okay so that's it so we're only going to
615:00 - change it on the player input and
615:01 - nothing over here on the updates then
615:04 - for hiding the tutorial over here one
615:06 - approach would be to listen to the
615:08 - interact action and hide it but I think
615:10 - it makes more sense for this to only
615:12 - listen to the kitchen game manager state
615:14 - that way if we wanted we could also
615:16 - modify how this one changes the waiting
615:18 - to start
615:19 - so let's listen to distinct over here on
615:22 - tutorial we want let's go into the
615:23 - kitchen game manager the incense and
615:25 - let's listen when the state changes
615:30 - so here we are going to check if the
615:33 - kitchen game manager instance if it is
615:35 - on the countdown to start active so if
615:37 - the countdown is active then we're going
615:39 - to hide this
615:40 - okay so that should do it now let's just
615:42 - do one more small thing the delivery
615:45 - manager is currently spanning a recipe
615:46 - whilst we're still reading the tutorial
615:48 - that's not quite right
615:50 - so let's go over here on the delivery
615:52 - manager and right now this one starts
615:55 - off at 0f and starts counting it down
615:56 - right away
615:57 - instead of only doing it like this let's
615:59 - just make sure that we only spawn a
616:01 - recipe if the game is playing so that's
616:02 - super simple over here kitchen game
616:04 - manager instance is game playing if so
616:08 - then we are going to spawn a recipe and
616:10 - let's do the same thing on the points
616:12 - counter so let's go in the plates
616:14 - counter
616:15 - so here we are on the plates counter so
616:17 - we count on time responsive lights but
616:19 - let's also make sure we only spawn
616:20 - plates if the game swing
616:22 - okay so with all of this let's test and
616:25 - right away here we are we can see our
616:27 - nice tutorial teaching the player how to
616:28 - play okay great here we've got the
616:30 - controls everything and we're currently
616:32 - waiting for an interaction we can see
616:34 - over there plates are not being spawned
616:36 - and recipes are also not being spawned
616:37 - but as soon as I press the E key
616:40 - and if there go the countdown starts
616:41 - playing and we've got everything else
616:43 - any up there you go the game starts and
616:45 - after a while yep we've got plates and
616:47 - we've got recipes alright awesome so
616:50 - next let's publish the countdown visual
616:52 - right now it's pretty basic it's just a
616:54 - static number so let's add a nice
616:56 - animation to it let's go inside the
616:58 - canvas let's find the countdown UI so
617:00 - the game start countdown okay
617:02 - so here it is we just have some basic
617:04 - text now let's go into the main game
617:07 - object and let's add an animator
617:08 - component
617:10 - then let's create a brand new animated
617:12 - controller so let's create a new down
617:14 - here an animated controller for the
617:16 - countdown UI over there let's assign
617:19 - this controller okay now let's open up
617:21 - the animation window so window animation
617:23 - open up the animation window okay let's
617:24 - create an animation clip and over here
617:26 - on let's name this the countdown UI
617:28 - number pop-up okay that's great now for
617:31 - making the animation we want to
617:33 - basically make it shake and also make it
617:35 - fade away so one very useful component
617:37 - is the canvas group so over here once on
617:39 - the parent let's attach a canvas group
617:42 - component this one is a really useful
617:44 - component in this case the main benefit
617:46 - is it let's just easily animate the
617:48 - alpha so let's go ahead and turn on
617:50 - recording let's go into the frame just
617:53 - before one second so let's go into 60
617:55 - frames because we are on 60 frames per
617:57 - second over here let's record the normal
617:59 - keyframe so let's modify the scale on
618:01 - the tiny bit just to record it and let's
618:03 - reset it back to one okay just to record
618:05 - the keyframe then for rotation let's
618:07 - rotate on Z then put it on zero again
618:09 - just record the keyframe okay great so
618:12 - now we can go back into the first frame
618:14 - and over here let's first make it
618:16 - smaller so for the size let's put it on
618:18 - 0.6 then let's rotate it to the left so
618:20 - let's put 17 over here on the set
618:22 - rotation okay like that now let's move
618:25 - up by just three frames so on frame
618:26 - three over here let's make it quite a
618:28 - lot bigger so let's put it on 1.3 and
618:31 - let's rotate it to the opposite position
618:33 - so -17 okay that's great that's a nice
618:36 - start now let's put it on frame 10 and
618:39 - over here let's set the rotation to zero
618:42 - and for the scale put it on 1.1 okay so
618:44 - now finally over here on frame 50 let's
618:47 - set the alpha onto one and then on one
618:51 - second let's put the alpha zero okay so
618:53 - let's preview and if they go a nice
618:55 - simple animation okay so that was great
618:57 - now we just need to play this when the
618:59 - countdown happens so let's stop
619:01 - recording let's go inside the animator
619:04 - controller so here it is we've got our
619:06 - number pop-up and we basically just want
619:08 - to play this animation whenever we want
619:10 - so let's put it and make a transition
619:12 - from the any state onto the number
619:14 - pop-up on this transition let's make
619:16 - sure we have no exit time and for the
619:18 - settings over here for the duration
619:19 - let's put it on zero so that it's
619:21 - instant okay great now obviously we need
619:23 - a condition so on the parameters let's
619:25 - create a brand new trigger call this the
619:28 - number pop-up let's select that one and
619:30 - Trigger it on this trigger okay great so
619:33 - now for handling this logic here we have
619:36 - the usual question
619:37 - so do we put this visual Logic on the
619:39 - same UI script or do we separate the
619:41 - animations from the UI for me I find
619:43 - that UI is usually part of the visual so
619:46 - sometimes I like to mix the two and
619:48 - sometimes I keep them separate it really
619:50 - depends on a case-by-case basis this
619:52 - visual is so simple and so connected to
619:54 - the actual UI Logics over here let's put
619:56 - them together so let's open up the game
619:58 - start countdown script and over here
620:00 - let's first grab the animator so private
620:02 - animator for the animator and on private
620:05 - void awake let's just get the animator
620:06 - and just get the component of type
620:08 - animator okay so we have the animator
620:10 - now we basically just need to keep track
620:13 - down here where we're modifying the text
620:14 - we're doing this on every update but now
620:17 - we need to know when this number changes
620:18 - so let's basically just keep track of
620:20 - the current number and the previous
620:22 - number so first of all over here an end
620:24 - for the countdown number
620:27 - and we're going to get this so this is
620:29 - our countdown number and over here we
620:31 - set it to string
620:33 - okay and we just need to use a different
620:35 - function so instead of Cl lets you cl2n
620:37 - just to convert the output into an
620:39 - integer okay great
620:40 - so we have the countdown number now we
620:42 - just need to know if this one is
620:43 - different from the previous one so let's
620:45 - go up here let's define a private tint
620:48 - for the previous countdown number
620:51 - then when we go down here we've got the
620:53 - current countdown number okay then just
620:55 - check if it's different
620:58 - if it is different from the current
621:00 - countdown number if so then let's update
621:02 - it so the previous one becomes this one
621:04 - and now let's fire off the animation so
621:06 - let's go into the animator and set the
621:07 - trigger and again we don't want these
621:09 - strings so let's go up to the top of the
621:11 - file make a private cons string let's
621:14 - call this the number pop-up
621:17 - and number pop-up
621:20 - okay so we have this end down here we
621:22 - just set this trigger okay so that's it
621:25 - pretty simple and just for fun let's
621:27 - also add a nice sound effect so let's go
621:29 - over here onto The Sound Manager and
621:31 - let's make a function to play sound so
621:33 - just like we did over here for the play
621:35 - footstep sound let's make another one
621:37 - for this one let's go and play countdown
621:40 - sound and for this one let's not receive
621:42 - a volume or position and we just play
621:45 - let's say just the warning sound so just
621:47 - down on Vector 3.0 and with the current
621:50 - volume
621:52 - okay so we have this function and then
621:54 - down here just going to sound manager
621:56 - instance and play the countdown sound
621:58 - again we could refactor this code to
622:00 - separate the Yuan logic from the
622:02 - animation from the sound that is one
622:04 - approach and sectionally one thing that
622:06 - we're going to do in the next polish
622:07 - stage but this one is also a possible
622:09 - thing since the UI is only so directly
622:12 - connected to visuals okay so with this
622:14 - let's test so here in the options let's
622:16 - just make sure that we have our sound
622:18 - effects so let's make sure they are
622:19 - playing okay great now let's go ahead
622:21 - and play and there you go we have our
622:24 - nice countdown number and there you go
622:26 - it looks great so it looks great and
622:27 - sounds great alright awesome as you can
622:30 - see just by adding a simple animation
622:31 - and some simple sounds that already
622:33 - looks so much better now the next thing
622:35 - we want to publish is on the stove so
622:37 - let's go into our stove back into our
622:39 - counters back into 3D and zoom in over
622:42 - here okay let's also make sure that we
622:44 - hide the canvas just so we can play
622:46 - around this all right great so there's
622:48 - our stove and for this we want to add
622:51 - basically a warning icon on any nice
622:53 - sound when the meat is about to burn so
622:55 - let's go inside the stove counter prefab
622:57 - okay so now inside of this we already
622:59 - have a nice generic progress bar UI and
623:02 - like I mentioned if you want to get some
623:04 - more custom Behavior you can combine a
623:06 - generic bar like this one with some
623:08 - specific components so that's exactly
623:09 - what we're going to do right now so over
623:11 - here let's create a brand new canvas as
623:14 - usual let's make it a world space canvas
623:16 - for position let's put all of this on
623:19 - zero
623:20 - let's just lift it up by a bit so set it
623:22 - on a y of three okay great then let's
623:25 - add our super useful look at camera
623:26 - component and make it camera phone okay
623:29 - now inside let's go ahead create a new
623:31 - image let's put it on a size of 0.5 by
623:34 - 0.5 okay just a nice square and for the
623:37 - Sprite there's a nice warning image in
623:39 - the asset so it's this one here we have
623:41 - the warning okay great basically we want
623:44 - to show this when the meter is about to
623:46 - burn so let's make a screen to run this
623:48 - and on the canvas let's give it a proper
623:49 - name so let's call this the stove burn
623:52 - warning UI
623:53 - okay so let's make this crypto render so
623:55 - when you c-sharp script with the exact
623:57 - same name and over here let's attach a
623:59 - script okay great so now the first thing
624:02 - that we need is obviously a reference to
624:03 - the stove so let's make a serialized
624:05 - film private for the stove counter for
624:08 - the stove counter
624:10 - okay here in the editor let's drag the
624:12 - reference of the sub counter okay great
624:14 - so now we basically just need to know
624:17 - when the food is about to burn and for
624:19 - that we can actually listen to the on
624:20 - progress event so let's do a private
624:23 - void start and on start let's go into
624:25 - the stove counter and let's listen into
624:28 - the on progress change event okay so we
624:30 - have this one
624:32 - and recently we're going to want to show
624:34 - this element so let's find a bone show
624:36 - we're going to want to show this when
624:38 - the progress normalized is above a
624:40 - certain amount so let's define a float
624:42 - for the burn show progress amount and
624:45 - let's say 1.5
624:46 - so on this one we show it except
624:49 - obviously we don't want it to be shown
624:50 - when the food is just cooking we only
624:53 - want it to show when it's about to burn
624:54 - so that means we also need to check the
624:56 - state on the stove counter so let's make
624:58 - a function to check if we are in the
625:00 - state that we want so we're here on the
625:01 - stove counter let's go down to the
625:03 - bottom
625:03 - and let's make a public bowl is fried
625:07 - and over here we just return if the
625:09 - state equals state DOT frame
625:11 - okay that's great so now here we're
625:14 - going to show if the progress is above
625:15 - 0.5 and the stove counter is on the
625:18 - Fright state
625:20 - all right so that's the logic that we
625:22 - want then we just want to show our
625:23 - height so let's make the original
625:24 - functions private show and a private
625:27 - void hide
625:28 - and just do game objects and active into
625:31 - either true or false
625:36 - and over here if show then let's call
625:39 - the show function and if not let's call
625:42 - the Hide function and of course on start
625:44 - let's start off as hidden okay that's it
625:47 - let's test just over here in the editor
625:50 - make sure the reference is right and
625:52 - let's save the prefab go outside and hit
625:54 - on point and yep right away there's no
625:56 - element okay great now I place it and it
625:58 - won't cooking there's no element and now
626:00 - once it's on the halfway point for
626:02 - burning and if there you go we've got a
626:03 - nice warning okay awesome so now that
626:06 - this is working let's just add a nice
626:07 - animation so once again let's go inside
626:09 - the stove counter and on the burn
626:11 - warning UI let's add an animator
626:14 - controller
626:16 - then let's actually create the animated
626:18 - controller so let's create a brand new
626:19 - animated controller
626:20 - for the stove burn warning UI
626:23 - then let's assign it okay and over here
626:26 - on the animation window let's create an
626:27 - animation
626:29 - let's put it on the same folder and call
626:31 - it
626:32 - for this one let's say flash we're going
626:34 - to make it Flash and then again for
626:36 - making it flash let's use the same
626:37 - component that we used a while ago so
626:39 - let's add a canvas group so here it is
626:41 - now we can play around the alpha so
626:43 - super useful although I should say that
626:45 - at this point since we just have a
626:46 - single image we could just record a
626:49 - change over here on the alpha for the
626:50 - image itself however one place where
626:52 - this component is super useful is if you
626:54 - have multiple images so if over here I
626:57 - duplicate this one and I put it off to
626:58 - the side if I change the alpha on one of
627:00 - them then obviously it only affects that
627:02 - one but if I go over here and I modify
627:04 - the canvas group that changes the amp
627:06 - for both of them so if you have a group
627:07 - of images then using the canvas group
627:10 - makes it super simple so anyway so here
627:12 - we have just our image let's go ahead
627:15 - and record and let's say we start off on
627:17 - Alpha zero then after 10 frames going to
627:19 - Alpha One and after 20 frames back into
627:22 - an alpha of zero okay so that's it a
627:25 - super simple very basic animation we
627:27 - don't even need analogic since we just
627:29 - want this animation to play Non-Stop so
627:31 - that's great that should be working now
627:33 - let's add some sound so for that we
627:36 - could make another script but already on
627:37 - the stove counter we already have a nice
627:39 - sound component so let's open up this
627:41 - grip the stove counter sound so this is
627:44 - basically where we're playing or
627:45 - stopping the sizzling sound so over here
627:47 - we can just add the warning sound we're
627:50 - going to play the sound just like we
627:52 - have over here for the burning UI so
627:54 - let's actually copy these same
627:55 - components and over here let's face it
627:58 - so for this one instead of show let's
628:00 - give it a proper name so play warning
628:03 - sound except it's not on say change so
628:05 - let's actually listen to the other one
628:06 - so still counter on progress change
628:08 - let's listen down and it's on that one
628:11 - that we use this
628:12 - Okay so we've got that one and then for
628:15 - playing the warning sound we're going to
628:17 - want to basically play it every certain
628:19 - amount of time
628:20 - so let's make over here a private void
628:22 - update and an update let's just Define a
628:25 - private float for the warning sound
628:28 - timer
628:29 - and so down here we just count down as
628:32 - usual time dot Delta time
628:34 - and if this one is under zero
628:38 - if so then let's reset it so Define a
628:41 - certain maximum
628:42 - let's say 10 times or maybe just five
628:45 - times per second that should be good so
628:47 - we have this but obviously we only want
628:49 - this to run if we should be playing the
628:50 - warning sound so let's actually save
628:52 - this one up here so probably won't for
628:54 - these play the warning sound and then we
628:56 - set it on this one
628:58 - and down here let's just go and we're
629:00 - only going to run this if play the
629:02 - warning sound then we're going to run
629:04 - our timer logic all right and then over
629:06 - here all we need is to play that warning
629:08 - sound
629:08 - so let's actually go into The Sound
629:10 - Manager and just like we added the
629:12 - countdown sound let's add another one so
629:14 - let's say the play warning sound and for
629:16 - this one let's receive a vector 3 for
629:18 - the position and we're going to play the
629:20 - warning sound on this position so now
629:22 - over here on the stove counter let's go
629:24 - into The Sound Manager the instance and
629:26 - let's play the warning sound and pass in
629:29 - the stove dot transform that position
629:31 - okay that should do it so we now should
629:34 - have a nice warning sound and over here
629:36 - we should have a nice animation on the
629:37 - burn warning UI so let's see both those
629:40 - okay so let's pick up some meat and drop
629:42 - it and right now it's cooking okay great
629:44 - and once it gets a halfway point
629:47 - if there go now we have a nice warning
629:49 - sound all right awesome let's just add
629:52 - one more tiny thing let's make the bar
629:54 - itself also flash red when we're about
629:56 - to burn so once again let's go inside
629:59 - the stove counter and on the progress
630:01 - bar UI let's add a nice animator and
630:04 - let's go ahead and make one so let's
630:06 - create a new animated controller for the
630:09 - stove burn flashing bar
630:11 - let's go ahead and assign it so it's the
630:13 - one on the progress bar let's add the
630:16 - stove burn flashing bar then on this one
630:18 - let's create new animation let's go
630:20 - inside the assets animations let's make
630:21 - one and just call it idle for this one
630:24 - we're going to want the exact same color
630:25 - as the normal color so let's go into the
630:28 - bar and set the color just save a
630:30 - keyframe over there okay so that's what
630:32 - we want now let's make another animation
630:34 - so let's stop recording and let's
630:36 - actually duplicate this one so duplicate
630:38 - it and for this one name it flash now of
630:41 - course we need to add it to the animated
630:42 - controller so let's go over here and
630:44 - drag it on top okay now for the
630:46 - animation let's select the Flash and for
630:49 - this one let's go ahead click on record
630:50 - let's start off on this one and after a
630:53 - few frames so let's say maybe after 10
630:55 - frames let's Flash in red and after 20
630:58 - frames let's copy paste the same frame
631:00 - okay so that's our nice flashing bar now
631:02 - let's just set it up so let's go into
631:04 - the animator and over here we're going
631:05 - to have a transition from that
631:07 - deformation form flashback now all we
631:10 - need of course is an animator to control
631:11 - this so let's make a new animator
631:13 - parameter let's make it a Boolean and
631:15 - call it is flashing and again make sure
631:18 - to be careful with cane sensitive
631:20 - okay so from idle into flash let's go
631:23 - ahead remove the exit time for the
631:25 - duration make it instant so zero and for
631:27 - the conditions when that one is true
631:28 - okay great and for going back once again
631:31 - same thing so instant and let's make the
631:34 - condition when it's false okay that's it
631:36 - super simple now let's make a script to
631:38 - run this so let's go ahead create a
631:40 - brainy sharp script for the stove burn
631:43 - flashing bar UI let's go ahead and add
631:46 - it to the bar so that's the flashing bar
631:47 - UI okay over here let's do pretty much
631:50 - the same thing that we did on the other
631:51 - one
631:52 - so let's go over here onto the stove
631:54 - burn warning UI I might actually copy
631:56 - exactly this so let's go on this one and
631:58 - paste this one then back here in the
632:00 - editor let's drag the reference to the
632:02 - self counter and over here the logic is
632:04 - going to be very very similar so the
632:06 - only difference is we have an animator
632:08 - so the animator and we're going to grab
632:11 - it on private wide awake and later get
632:13 - component of type animator
632:16 - so we have the animator then let's
632:17 - define the parameter so private con
632:20 - string
632:21 - for the is flashing
632:24 - and let's set it is flashing okay we
632:27 - have our parameter and now down here
632:29 - instead of showing and hiding we'll just
632:31 - go into the animator in order to set a
632:33 - ball
632:34 - and the bone will be the is flashing and
632:37 - let's set it based on show so either we
632:39 - show or hide and we actually don't need
632:41 - these functions and by default of course
632:43 - let's leave it on false okay so that's
632:45 - it super simple Let's test just make
632:48 - sure to save the prefab and hit on play
632:50 - okay let's go ahead and cook so let's
632:52 - pick it up and drop it alright so it's
632:54 - cooking let's wait for it to be burning
632:56 - and as soon as it gets there yeah there
632:59 - you go we've got a nice warning a nice
633:01 - flashing bar and a nice sound effect so
633:03 - all three warnings making ourselves much
633:05 - more polished alright awesome now just
633:08 - for balancing let's play around the
633:09 - timers so let's go into our script ball
633:12 - objects on the frying rest BSO let's
633:14 - make this one take five seconds
633:17 - then on the burning recipe for this one
633:19 - let's make it take six
633:21 - and finally let's also add another stove
633:23 - so let's take our self counter duplicate
633:26 - the prefab let's put it over here so
633:28 - rotate it to the side and let's get rid
633:29 - of this one and put this one right in
633:32 - there so on 7.5 0 and minus 1. all right
633:36 - so we now have two stoves I can put one
633:38 - cooking put another one and I can start
633:41 - cutting down some cheese start cutting
633:43 - and before they start to burn what's
633:45 - actually here there you go that one is
633:47 - about to burn so let's pick it up
633:48 - quickly and that one is actually gonna
633:50 - burn but I got it okay great all right
633:53 - awesome everything's working great now
633:55 - for one more polish element let's make a
633:57 - nice visual when we deliver either a
633:59 - correct or incorrect recipe I think it
634:01 - wouldn't look good as a warm canvas on
634:03 - top of the delivery counter so let's do
634:04 - that let's over here find the delivery
634:07 - counter let's go inside the prefab and
634:09 - now in here let's create a new UI canvas
634:11 - let's name this the delivery result UI
634:14 - and as usual let's make this a worm
634:16 - space canvas so put it on worst face
634:19 - and for the position let's actually lift
634:22 - it up and then we're going to make it
634:23 - look at the camera but just like this it
634:26 - might actually go inside the wall so
634:27 - let's put it over here to the side a
634:29 - little bit so let's put it on this
634:30 - position so on the X of minus 1.6 on a y
634:33 - of three and on a z of 1.2 okay that's
634:37 - the position so right there that is
634:39 - going to be unlocking at the camera now
634:41 - inside let's create a new UI image it's
634:44 - going to be our background and for the
634:47 - size the width and height let's put it
634:48 - on 2.2 by 0.9
634:51 - okay that's our background for the
634:53 - Hunger let's tinted in a nice green so
634:55 - let's put it something like this
634:58 - then let's also add a nice outline let's
635:01 - put it on full Alpha and for the size
635:04 - let's put it on 0.1.1 then let's also
635:07 - add a nice shadow component for this one
635:09 - leave it on half Alpha and let's put it
635:12 - on 0.2 and minus 0.2
635:14 - okay so that's a nice visual now on top
635:17 - of it let's create a new UI text let's
635:19 - call it the message text and for the
635:22 - message we're going to say something
635:23 - like delivery and then underneath
635:25 - success let's put it on a width and
635:27 - height of zero let's put it on a super
635:29 - tiny font so let's say just 0.25 let's
635:32 - put it in bold and put it down Center
635:34 - and get rid of wrapping okay that's it
635:37 - let's just push it a little bit on the
635:38 - left side so on minus 0.32 on the X okay
635:41 - and now next to it let's make another UI
635:44 - image for this one call it the icon
635:46 - image let's put it with a size of 0.5 by
635:49 - 0.5 and put it over to the right side so
635:52 - on an X of 0.7 okay and now for these
635:55 - Sprites including the assets are too
635:56 - nice sprites so there's a nice cross for
635:58 - when we get it wrong and there's a nice
636:00 - tick okay so that's the setup that we
636:03 - want now on the delivery result UI let's
636:05 - go ahead add our own look at the camera
636:06 - component and for this one let's go
636:08 - different so instead of the camera four
636:10 - let's go ahead with the unlock at
636:12 - inverting so there it is this is our
636:14 - setup now let's make the script run this
636:16 - so let's go ahead create the new UI new
636:19 - c-sharp script for the delivery result
636:21 - UI let's attach the script and open okay
636:24 - so now here on let's make serialized
636:26 - films for our elements so a serialized
636:28 - film
636:29 - first of all for the background image
636:31 - and this is actually going to be a Type
636:33 - image image inside in the engine.ui okay
636:36 - our background image then we're going to
636:38 - have another one for the icon image and
636:41 - we're going to have another one this one
636:42 - is a text mesh Pro e GUI for the message
636:44 - text
636:45 - okay let's save okay so let's drag the
636:48 - references to the background the message
636:51 - text and the icon image okay great and
636:53 - over here let's listen when a delivery
636:55 - is delivered so let's make a private
636:57 - start let's go into the delivery manager
637:00 - the instance and we have all of our next
637:03 - events so we've got a success and a
637:05 - field so let's listen into both them
637:07 - so both the success and on the recipe
637:10 - failed let's listen to all these and as
637:13 - always let's write good point code and
637:14 - rename this so the delivery manager on
637:17 - recipe success and for this one is the
637:19 - on recipe failed
637:22 - okay we have both of our events
637:25 - so over here it's actually going to be
637:27 - very simple we just want to play around
637:28 - the text the icon and the background
637:30 - color so for example when we fail let's
637:33 - go
637:34 - and we want to set the background image
637:36 - to about a red so for defining the
637:38 - column let's actually go here and Define
637:40 - a color for the success color and we're
637:44 - going to have another one for the failed
637:46 - color
637:47 - and then for the Sprites let's also have
637:48 - that so Sprite for the success Sprite
637:51 - and another one for the failed Sprite
637:54 - okay those are on the elements so we're
637:56 - here in the editor let's just set them
637:58 - so for the success column let's actually
637:59 - use the exact same color by the way
638:01 - here's a quick tip if you go up to film
638:04 - for example like this one on the color
638:05 - you can right click and copy and then go
638:08 - into delivery results and over here
638:09 - right click and paste there go the
638:11 - perfect color then for the final color
638:13 - let's go with the red maybe a bit darker
638:15 - and also importantly make sure you set
638:17 - the alpha to phone okay so we have a red
638:19 - nice and like that okay then the success
638:22 - Sprite this one is going to be the tech
638:24 - and for the fail this is going to be the
638:26 - cross okay those are all of our elements
638:28 - so over here when we fail let's go into
638:30 - the background image and set the color
638:32 - and let's put the fan color then for the
638:36 - icon image let's set the Sprite to the
638:37 - Fey on Sprite
638:39 - and for the message text let's set this
638:42 - one for delivery and then failed
638:46 - by the way this backward slash n this
638:48 - means a new line so we're going to let
638:50 - you set the text on this one so it
638:51 - essentially means that it won't write
638:53 - delivery then new line and then failed
638:55 - underneath just make sure you're using
638:57 - the Packer slash and not the forward
638:58 - slash so use the backwards one there you
639:01 - go there's a new line okay so that's the
639:03 - on recipe film and now on the recipe
639:04 - success let's use the success color the
639:07 - success Sprite and over here the
639:10 - delivery success okay so that's great
639:12 - that should be working now just one more
639:15 - visual thing let's add a nice animation
639:17 - so just like we did previously let's go
639:19 - over here over here and let's add an
639:21 - animator component
639:23 - let's create an animation for this one
639:25 - for delivery result UI so let's go up
639:27 - here create a brand new animated
639:29 - controller for this and let's go ahead
639:31 - and assign it so delivery result UI all
639:34 - right now let's make an animation so
639:36 - this delivery result UI let's call it
639:38 - just pop-up and for this one let's do
639:40 - just like we did for numbers so let's
639:42 - scale and rotate it however if we rotate
639:45 - that's actually not going to work that
639:47 - is because we have the unlocked camera
639:48 - and this one is already going to be
639:49 - setting the rotation so we would end up
639:52 - with this script finding the animator
639:53 - for the rotation so that would mess
639:55 - things up however one nice and simple
639:57 - solution to this
639:59 - basically we just put this inside
640:00 - another game object so let's create a
640:03 - new game object and let's put it inside
640:04 - what's an empty game object for the
640:06 - delivery result rewind then look at the
640:08 - camera
640:09 - so we have this one now the reason why I
640:11 - created it inside is that so over here
640:13 - we can set everything to zero and now
640:16 - with that one on zero we can go ahead
640:18 - and drag this outside of this object and
640:20 - there you go that one keeps the exact
640:21 - same settings and on this one we can add
640:23 - the unlocked camera component and set it
640:25 - up just like we had so then we'll look
640:27 - at inverting and on this one we're going
640:29 - to make a channel live down and there
640:31 - you go now everything is on zero exactly
640:32 - as it should be and on this one we can
640:34 - get rid of the unlocked camera and now
640:36 - we can indeed play around the rotation
640:38 - so for the animation let's just go ahead
640:39 - and set it so for this one let's go up
640:42 - to one second
640:43 - and let's record a keyframe on a scale
640:45 - of one and on a rotation of zero then
640:49 - let's go back into the beginning and for
640:51 - this one let's scale it backwards so
640:53 - maybe something like this maybe a 15
640:56 - let's put it quite a bit smaller then
640:58 - let's go up by three frames let's put
641:00 - that one on -15 so rotation on the other
641:02 - side and put it quite a bit bigger and
641:05 - then on frame 10 put it on say 1.1
641:09 - with a rotation of zero just like that
641:11 - so there you go there's a nice pop-up
641:13 - and for the alpha let's also go over
641:16 - here into the 50 and let's just add the
641:19 - canvas group let's set this one over
641:21 - here is on one and then we scroll it
641:24 - down to zero okay so that's our nice
641:26 - animation let's stop recording let's
641:29 - open up the animated controller and over
641:31 - here let's make our nice animations
641:33 - transition so transition from any state
641:35 - into that one let's make it based on a
641:37 - trigger let's call it just pop-up
641:40 - and for this one this says no exit time
641:43 - duration of zero and let's go when the
641:46 - condition when we have this trigger okay
641:47 - so that's it although one thing by
641:49 - default this animation is going to Loop
641:51 - so let's just go ahead we can select the
641:53 - animation and over here let's just
641:55 - untick Loop time so that way the
641:57 - animation will not Loop okay so that's
641:59 - great now let's go into the script and
642:01 - over here let's get our animator so
642:03 - private animator animator
642:06 - let's get the animator just get
642:08 - component of type animator
642:12 - and let's define over here the private
642:15 - constring for the pop-up
642:22 - so we have this and then when we have
642:24 - either fail or success let's just go
642:26 - into the animator
642:28 - and let's set the trigger for our pop-up
642:31 - both up here and over here now we just
642:34 - have obviously one issue which is that
642:36 - it starts off as visible we don't want
642:37 - that so over here we can just do game
642:40 - objects set active into false in order
642:42 - to hide it and when we get either of
642:44 - these let's set it both to true
642:46 - then afterwards the animation won't make
642:48 - it invisible so it will still be active
642:50 - but it won't be invisible so that's fine
642:52 - so just with this everything should be
642:53 - working as we want so let's test let's
642:55 - just make sure to save it and go back
642:57 - okay so here we are let's try delivering
642:59 - an incorrect plate and there you go
643:01 - Gotta delivery film okay great now let's
643:03 - try delivering a correct one so someone
643:05 - wants a cheeseburger so let's cook it
643:07 - slice some cheese let's get some bread
643:10 - so bread cheese and pick up the burger
643:13 - and deliver and there you go a nice
643:14 - delivery success all right awesome
643:17 - okay so with these handphone changes you
643:19 - can already see how we made quite a big
643:21 - difference in our game we didn't do
643:23 - anything to change any core mechanics we
643:25 - just made what was already there pop out
643:26 - we added a nice visual boundary to make
643:29 - the map look nice we added some nice
643:31 - particles when the character is moving
643:32 - then we added a nice tutorial and
643:34 - controls right as the game starts we
643:36 - also added a bunch of effects on the
643:38 - stove so it flashes has a warning and
643:40 - some sound and lastly we also added a
643:42 - nice pop-up when delivery is delivered
643:44 - whether correctly or incorrectly
643:46 - now of course we can always keep
643:47 - publishing the game until Infinity
643:49 - there's always more small things you can
643:51 - add to punish the game just a little bit
643:52 - more but at this point I'm very happy
643:54 - with what the game looks like so after
643:56 - all this work let's go into the next
643:58 - lecture where we're going to play our
643:59 - game from start to finish and see what
644:00 - we've done
644:02 - hello and welcome I'm your kudmaki in
644:05 - this lecture we're going to look at all
644:06 - the work that we've done and have some
644:08 - fun playing the final game okay so here
644:11 - we are in our nice starting main menu
644:13 - it's simple but it works I actually
644:14 - thinking looks pretty good so we have
644:16 - our main menu working and we also have
644:18 - the unloading system that we made so as
644:20 - soon as I click on Play There You Go
644:22 - loads in loading scene and here we are
644:23 - on the game scene so we start off with
644:25 - our really nice tutorial window and down
644:27 - here we have the controls of course some
644:29 - of these are dynamics so depending on if
644:31 - the player rebinds or something this one
644:32 - is going to update so we can look at
644:34 - this window for as long as we want the
644:36 - game is paused in the background so it's
644:38 - on a paused game state
644:39 - then whenever ready we can interact
644:42 - so again that's the game input class
644:44 - listening to the input and again all of
644:46 - the code in here is really nice and
644:47 - clean so when we press enter key the
644:50 - tutorial isn't directly listening to
644:52 - that but rather the general kitchen game
644:54 - manager that main State machine is the
644:55 - one listening to the input and this one
644:57 - is listening to that state
644:58 - so our logic is very well organized all
645:01 - of the elements only listen to the
645:03 - things that make sense to them so
645:05 - anyways here we have tutorial let's
645:06 - interact and there you go we've got our
645:08 - nice game start countdown some really
645:10 - nice animation really nice sound and yep
645:12 - here we are then we've got our clock
645:14 - showing the game time and on the left
645:15 - side we can see our recipes once again
645:18 - all of the elements they're all Dynamic
645:19 - they're all spawn randomly and the icons
645:22 - for all of the recipes they're also all
645:24 - Dynamic so over here we have the
645:26 - character control that we built we have
645:28 - the collisions that we implemented and
645:30 - of course we have the raycast testing
645:32 - for interaction so we can identify all
645:33 - the objects in front
645:35 - let's begin delivering some recipes so
645:37 - for example we need to cook some meat so
645:39 - let's go ahead put it on the stove so
645:40 - here is the really nice tape machine
645:42 - that we built so we've got all the
645:44 - various States we've got the visual
645:45 - completely separated from the logic so
645:47 - everything is really nice and of course
645:48 - here we have the nice burning elements
645:50 - that we added in the Polish lecture so
645:52 - that one is burned so let's go ahead and
645:54 - use the trash bin to get rid of that
645:56 - so let's go ahead cook another one and
645:58 - let's make a cheeseburger so let's put
646:00 - some cheese let's listen to the aunt
646:01 - interaction key and we can slice the
646:03 - cheese we can pick up the meat pick up
646:05 - the cheese then also pick up some bread
646:07 - and deliver the recipe and there you go
646:09 - our nice polish visual all right awesome
646:12 - so here you can already see everything
646:13 - that we've built the character the
646:15 - physics the logic the input all of the
646:17 - UI elements all of the worm UI elements
646:19 - of the various counters and how they are
646:21 - on prefab variants of the plates the
646:24 - separation between the visuals and logic
646:26 - separation between the sounds and logic
646:28 - of the Polish elements that we made over
646:30 - there the nice shadow graph that we made
646:32 - then of course some of the basic things
646:34 - that a lot of tutorials won't teach you
646:35 - like for example how to make a pause
646:37 - menu how to make the options
646:39 - how to modify the Sound and Music Volume
646:41 - how to rebind the Keys and so on
646:43 - so with all that here throughout this
646:44 - course we'll learn how to make a really
646:46 - nice game with lots of interesting
646:48 - interactions which you can now apply to
646:49 - any kind of game any kind of genre you
646:51 - want so like I mentioned in the very
646:53 - beginning
646:54 - you can take pretty much what we've made
646:55 - here which is really just a character
646:57 - controller and a bunch of interesting
646:59 - interactions you can take everything
647:00 - that you've learned here and make
647:02 - something on a Sci-Fi space like for
647:04 - example make something like Among Us you
647:06 - can make something like FTL or perhaps
647:08 - make some kind of survival crafting game
647:10 - some of the interactions you would have
647:12 - like resource nodes in the world then
647:14 - you can interact together those
647:15 - resources so with that you could build
647:17 - something like rust or Minecraft or
647:19 - Don't Starve so hopefully in this course
647:21 - you'll learn a ton that you can now
647:22 - apply to your own custom original
647:24 - projects and if you've made it this far
647:26 - then congratulations let's go into the
647:28 - next lecture where I'll give you my
647:29 - closing thoughts
647:31 - hello and welcome I'm your code monkey
647:33 - and congratulations you have completed
647:35 - this course awesome seriously congrats
647:38 - looking at the stats on my courses very
647:40 - few people stick with it until the very
647:42 - end so if you're hearing this then
647:44 - that's excellent you're on the top 10
647:45 - percent it means you are serious about
647:47 - learning game development and I
647:49 - generally hope this course has helped
647:50 - you on your own Game Dev Journey
647:51 - throughout this course you'll learn
647:53 - about the basics of unity and c-sharp
647:55 - you'll learn how to make a character
647:57 - controller how to do a physics raycast
647:59 - and use that for both Collision
648:00 - detection and identifying objects to
648:02 - interact with you'll learn about c-sharp
648:04 - interface and events two extremely
648:06 - useful c-sharp features you'll learn
648:08 - about script mode objects how to use the
648:10 - new input system should graph and tons
648:12 - tons more and the most important thing
648:14 - of all you'll learn how to build a
648:16 - relatively complex game while writing
648:18 - good clean code I really hope that's the
648:20 - main takeaway you'll learn from this
648:22 - course learning how to write better high
648:24 - quality code learning how to refactor
648:26 - how to keep the visuals and logic
648:28 - separate keep the UI the couple from
648:29 - logic learning all those things has now
648:31 - made you a 10 times better developer
648:33 - than when you started
648:34 - so I really hope you enjoyed learning
648:36 - all that let me know in the comments
648:38 - what was the most important thing you'll
648:39 - learn throughout this course I really
648:41 - hope this was very fun and very
648:43 - educational if you enjoyed my teaching
648:45 - style check out my other courses I
648:47 - really think the turn-based strategy
648:48 - course would be excellent for you right
648:49 - now it Dives even deeper into some
648:52 - Advanced topics and since you've watched
648:53 - this entire course all the way you now
648:55 - have all the knowledge needed to follow
648:57 - that course it will help you really
648:58 - simply the final knowledge you gained
649:00 - especially everything related to writing
649:02 - good high quality clean code and since
649:04 - you use Unity check out my ultimate DND
649:06 - overview course it covers lots of tools
649:08 - and features of the engine so you can
649:10 - really use all the tones at your
649:11 - disposal to make any game you can think
649:13 - of alternatively if you like visual
649:15 - scripting I have course on that or learn
649:17 - how to make a really nice Builder
649:19 - Defender game and definitely make sure
649:21 - that you wishlist my upcoming steam game
649:22 - total one Liberation I won't be posting
649:25 - devlogs and in those you will see how
649:27 - the code that I use in my own steam game
649:28 - is on the same level of quality as what
649:30 - you learned in this course okay so
649:32 - that's it for me this course was a ton
649:34 - of work so I generally hope it helped
649:36 - you a ton on your gamedev journey thank
649:38 - you so much for watching and I'll see
649:40 - you next time

Cleaned transcript:

hello and welcome I'm your code monkey and here is a free complete course on making a game from start to finish if you've always wanted to learn how to make a game or if you already know the basics but want to see how to organize a more complex project then this video is for you it's perfect for both beginners and more intermediate users this is a completely free course video but it has the same level of quality as my paid courses or my Steam games you can download the project files to follow along or inspect the funnel game you can even play the final game directly on scene we're going to start commonly from scratch and build a really awesome game with tons of systems and mechanics building this design requires working with lots of unity and csharp features so this is a really awesome project for you to learn after following this course and learning all of these techniques you won't be able to build all kinds of games in all kinds of genres this is going to involve learning about the basics of unity and csharp learning how to make a character controller physics raycast learn all about csharp interface and events using script more objects handling UI the new input system and lots more very importantly everything that we're going to do here is going to be focused on writing good easy to understand clean code meaning that I will not be teaching you bad practices that some beginner tutorials teach the code that we're going to write here is production quality code this is not a throwaway demo the quality of the code and the structure of the game that we're going to build is on the same level of quality as my own Steam games as you can see from the video link this is indeed a complete very thorough course so don't try to watch this whole thing in one sitting take your time take it slow and just focus on learning there are chapters for every single lecture in the video here's a quick overview of the entire course all the steps that we're going to take to reach the final published game so first of all we're going to start commonly from scratch by selecting a Unity version and creating a brand new project with that new project we will then learn all about the basics of the UNT interface and setup plane layout then the other important part is Visual Studio which is where we're going to be writing all of our code after that comes an extremely important lecture all about coding style and naming rules like I said the code in this course is on the same level of quality as my Steam games so having proper naming rules and good code sound is Paramount next we're going to download and import all the assets that we're going to use in the course everything is included so you can follow along with every step of the way with yes it's important we're going to set up some quick post processing just to make the game look good then for our first piece of logic we're going to make a simple character controller with that logic working we will then Implement a proper character visual with the included assets next we're going to learn the basics of animation and the animator component and with that we're going to make our player really Common live with some simple but really nice animations then we're going to install the send machine package this isn't actually used too much in this course but I still wanted to include it because it is such a useful tool so I do want you to know about it after that comes another extremely extremely important lecture with regards to writing some good link code we're going to do a nice refactor to replace the Legacy input Venture with the brand new input system learning how to refactor is an extremely important and very valuable skill that will massively improve the quality of your code with that then we're going to implement some nice Collision detection to make sure our character doesn't want through walls next we're going to create the very first kitchen counter and make a script to handle how to interact with it then we're going to learn all about csharp events and create a proper interact input next we're going to build a selected counter visual which will require us to learn about the extremely useful Singleton pattern with the counters working we're going to start working on the kitchen objects themselves so these are going to be the ingredients and the plates we're going to use scriptable objects to Define all of the types then a very important part of our design is each kitchen object will have to be placed somewhere so we're going to take some time to really think about the best way to achieve that all while riding some good clean code next we're going to enable the player to pick up an object in doing so we're going to learn about csharp interfaces then we're going to make a container counter this is from where we can spawn new objects with that we will enable the player to pick up objects and drop them anywhere where there's space then we're going to make the cutting counter this one enables the player to cut an ingredient into slices so to do that we're going to make an alternate interaction and for handling the cutting we're going to once again use script more objects to define a proper cutting recipe then we're going to learn about a really awesome Unity feature we're on canvases and use that to display a nice progress Bar for our cutting progress after that is a quick lecture just going to make a very useful generic script to make any object look at the camera next for another counter we're going to build a trash bin this is where the player can drop objects to destroy them then the stove counter this one is going to be quite a bit complex we're going to create recipes for cooking and for burning we're going to learn how to make a basic state machine and handle timers next we're going to make the plates counter this is a simple encounter that just spawns a bunch of plates after that we're going to make some custom Logic on the plate to be able to hold other objects with that logic working we're going to build a complete visual for all the objects that can exist on the plate then make a nice UI element on the plane itself to showcase the icons of what exactly is on that plate afterwards we're going to make the very last counter the delivery counter this is where we drop the completed plates and in this lecture we're also going to learn about the unity share graph and make a quick simple custom Shader then we're going to build the delivering manager class that generates the recipes that the customers are requesting next we're going to build a UI to showcase the wedding recipes after that comes something pretty crucial we're going to add some music and then add some sound effects for all kinds of game actions without the game won't be almost done so next we're going to build a proper game start and a game end then make a simple main menu and handle scene loading after that hand on creating a basic pause window then make an options menu enable the player to modify the audio levels and rebound keys after that we're going to enable menu navigation with a controller and in the end as usual comes the Polish stage so we're going to add all kinds of small tweaks and effects to make the game feel really great like I've said many times polish is what separates good games from great games after all of that we will have our final completed project so as you can see you will learn about tons of Topics by following this course also let me point out one of the reasons why I chose this specific design is because my next free course won't be on taking the game that we're going to build here and make it multiplayer so if you've ever wanted to make multiplayer games then that course will be excellent for you definitely take your time following this course the multiplayer free course should hopefully be out next month or if you're watching this in the future check the links in description although that multiplayer video won't be starting from where this course ends so definitely make sure you watch this one now if you are new to the channel then welcome and here's a bit about me and my credentials or why you shouldn't listen to what I have to teach my name is Hugo and I've been running this Code Monkey YouTube channel for five years now in total almost 700 videos on all kinds of topics including tons of tutorials sharing my knowledge to help you on your Game Dev Journey I'm also a professional indie game developer making games for over 10 years with 8 successful Games published on scene so what I'm teaching here is based on a lot of years of experience making a lot of games just like with my paid courses I'm always going to be in the common censoring questions so if you get stuck at a particular point or need extra clarification on something go ahead post a comment and I'll do my best to help do make sure you include a timestamp of what you're referring to I will also be updating the pin comment with any frequently asked questions that I see so actually right now go ahead pause the video and scroll down a bit just to look at that comment since on YouTube I cannot update the video after it's published I will be updating that comment over the next months and years with anything that comes up also I've been running this channel for five years and in that time I've made almost 700 videos so there's lots of topics that I've covered separately in more detail all of those videos are linked in the description throughout this course I will be focused on building this specific game using whatever it takes to build it meaning for example when we get to using csharp events I won't teach the basics about how they work in order to achieve what we want to build but if you then want to learn about csharp events in more detail definitely go watch a dedicated video and I also made a page on my website for this course it contains a link to download all of the project assets you can also download the complete project files for every single lecture so if you get stuck at any point you can download the code at that lecture and compare with your own there's also references to all of the videos and I will also be including frequently asked questions for each lecture so definitely keep that page open in a second tab as you follow along this course now this free course Took a ton of work to make so I really hope you find this video helpful go ahead and hit the like button if it helps you it's a small thing but it generally does help this video on the YouTube algorithm making this course was a ton of work and by making it commonly free it means it will obviously never make as much money as if I had just made this a paid course I'm personally okay with that decision with the hopes that by making it free it won't reach and help many more people I'm also a big believer that education should be free so if you can't afford one of my paid courses like if you're just a kid or going through a rough time I still want you to have access to high quality education so you can achieve your Game Dev dreams one easy way you can help me for free is simply by liking this video subscribing to the channel and just watching this course that will hopefully help push this video on the YouTube algorithm and help it reach many more people another free way to support what I do is I'm currently working on my next team game called turn one Liberation you can wish list the game on Steam wishlists matter a lot for steam visibility so just by doing that you won't be helping me and just in case you can't afford it and you find this free course useful you can also support what I do in a few other ways I spent a bunch of money making this course I hired an artist for the 3D assets so that I had the right to distribute them so that you can download it and follow along same thing for the music and sound effects the logo and the cost to upload the game to seem so I would like to at least not lose money on this project hopefully there's enough of you who can't afford to help me so that I can at least break even and for one way you can support is I added this exact same course on my website as a regular paid course although I want to be very very clear there is absolutely no difference between this free video and the paid course there is absolutely nothing behind any kind of payroll all of the lectures are free all of the apps are free everything is free you don't have to pay for anything if you can't afford it or you just don't want to the paid version is essentially a donation the only difference is this free YouTube video has regular YouTube ads whereas the paid version on the website doesn't have any ads that's it that's the only thing so the only reason why I made that paid version is just in case some of you can't afford it and you want to support what I do and want to help me break even on this project but again only do that if you can't afford them if you can't that's personally fine I hope you'll learn a ton from watching and following this free course beyond that if you follow this course and you enjoy my teaching sound perhaps look into my other courses if you like this video then I think you won't really like my turnbased strategy course that is the perfect course to follow up on this one one it Dives even deeper into some of the concepts used here and it will help you make the jump from beginner to Advanced and since you're interested in unity I think my ultimate unity overview course would also be very useful to you each lecture on that course is focused on teaching one entitled feature there's already over 15 lectures including plenty of small but very important things that you just wouldn't see in a regular YouTube video if you're interested in visual scripting I have course on making three unique games internally with visual scripting and no code at all or if you prefer code you can learn how to build a nice Builder Defender game so if you enjoy my teaching Style on this free course then check out my other ones then of course YouTube has Channel memberships and super thanks so you can use those if you want I also have my patreon if you prefer that and in a lot of my videos I have some affiliate links if you ever pick up anything through those I get a nice commission and I also have some of my own assets on the unity Astor so if you enjoy this free course and you want to support what I do there's plenty of ways but again don't feel obligated if you can't afford it or you just don't want to that's perfectly fine I hope you'll learn a ton from watching and following this recourse alright so that's enough talk of that for now before we begin building the game from scratch let's inspect the final polish game that we're going to build so let's see that in the next lecture hello and welcome I'm your code monkey here let's take a look at the final game that we're going to build so we start off on a simple but really nice main menu so we've got a nice visual a nice logo and a bunch of useful buttons then of course the game has a nice loading system so when I click on play it's going to load into a unloading scene and then funnel into the final game scene so let's go ahead and play and if there we go here we do see the game scene and right away we see a nice internal window so it's telling us how to play the game so the basic interactions and then over here the controls importantly these are all rebindable so over here this element is all Dynamic then we can look at this tutorial for as long as we want and we are waiting for the interact to continue there's also a really nice song playing in the background so the game has music now we can look at this tutorial for as long as we want and when we're ready we can interact and continue and as soon as we do if there you go we've got a nice countdown some nice animations a nice sound effect and there you go now we are playing okay so here I am controlling a nice character I can move in any direction there is Collision detection so obviously I cannot go inside solid objects so I can walk around and for the goal of the game over here on the left side we've got recipes that the customers are waiting for so for example One customer wants a simple Burger so for that we gonna need to pick up a nice bun so let's pick it up then the burger obviously requires a meat Patty so let's go ahead we can pick one up from here but this one is an uncooked meat padding so we need to drop it over here on the stove and there you go it starts cooking we've got a nice timer we've got a nice warm bar UI and there you go it keeps counting and we've got some nice park on some nice visuals and over there even a nice indicator telling us the meat is about to burn and there you go the meat has burned so now I can pick this up and I'm holding some burnt meat so the customer probably doesn't want to eat this so we can go over here to the trash or trash it let's try doing another one and do it properly so let's wait for it to cook pick up a plate so we can pick it up directly onto the plate there you go to the meat is cooked so let's pick it up then go pick up some bread and there you go here we have our camelli recipe so let's go into the delivery counter deliver it and there you go a nice delivery success all right awesome we've just delivered our first recipe so then someone else wants a salad so let's go ahead pick up a tomato here we have a big uncut tomato so let's drop it onto a cutting board and now we can interact with it so we can interact with a secondary interaction key and by interacting we cut the tomatoes so it takes a few cuts and there you go with slices and it's sliced into tomato slices so let's do the same thing for the Cabbage here we are holding a regular cabbage then slice it and this one actually takes a bunch more and there you go got both slices okay great so now let's pick up the plate pick up both slices and deliver to the customer and there you go got a nice success all right awesome and of course we have a correct identification of if we have a crack recipe or not so if I just pick up an empty plate and deliver it there you go got a film delivery because nobody wants just an empty plate alright so here you can already see quite a lot of interactions quite a lot of systems at work so the character has a nice character controller it has physics interaction you can see how it identifies the counter that is in from the character I can press a button to interact with the counter and interacting with different counters does different things so if I interact with a clear counter I can pick up or drop things over here I can pick up drop it with an alternate interaction I can do the second action then there's the stove machine so that one has a nice State machine so it counts up over here we've got some nice particles we've got a nice Bloom so all the Visions look really great so we've got some post processing we have a bunch of UI elements directly on the world and outside of here we've got some regular UI elements so we've got the recipes with Dynamic icons for all of them we've got a timer over there on the top right corner showing how long we have to deliver on our recipes and on the kitchen counter we're also using a custom Shader so this was built using shade wrap so as you can see lots of internalized systems then the game also has of course the basics that any game should have so I can pause the game and there you go we've got a nice pause menu so we can resume to go back or pause it again and of course while pause everything is possible that's great we can go back into the main menu or we can go into options and over here we can play around the sound effects volume the Music Volume we've got all of our controls importantly these are the controls for the keyboard and also the GamePad so the game can be played with any Gamepad so it can be an Xbox controller PlayStation switch controller it doesn't matter all of them work and we can also rebind all these Keys both the keys as well as the GamePad inputs so let's go ahead and deliver a cheeseburger so here's some burn meat so let's toss this then pick up some more meat pick up a plate here we've got some cheese we've got some bread pick up the meat and deliver it all right awesome and of course finally at the end when our timers left here we have a nice game over window showing how many recipes we delivered alright so this is the final game that we're going to build as you can see it involves lots of interesting interactions which require learning lots of different skills we're going to be using csharp interfaces csharp events the new input system shade graphs critical objects we're going to learn about csharp events making character controller handle collisions and so on like I said one thing that we're going to focus heavily throughout the making of this game is on writing good clean code meaning that the final game that we're going to build won't be very easy to expand upon thanks to how long the code is very clean it will be very easy to add more recipes maybe more counters with more actions maybe things like perhaps washing dishes adding an oven and so on or really you could make something completely different this game is all about character and interactions so that could be whatever you want you could take this as a base and build some kind of scifi game something like Among Us or FTL you could make a survival crafting game like rust or Minecraft or Don't Starve really fun learning how to build this game by the end you won't have gained the knowledge required to build all kinds of unique and interesting games alright so now that we've seen the final game Let's actually build it just before we do let's get a quick refresher of the absolute Basics you should know in the next lecture hello and welcome I'm your code monkey in this lecture we're going to just get a quick refresher of the absolute Basics you should know in order to be able to follow everything in this course okay so like I said this free course is targeted at both beginners and more intermediate users in order to start following the course you really only need to know the absolute Basics I've made three useful videos with all of the basic knowledge required to follow this course watch the video on how to download install and set up Unity then the quick Unity Basics and the csharp basics those three Quick videos contain all of the absolute basic knowledge you need so if you're a complete beginner go ahead pause this video and go quickly watch those and even if you are already somewhat familiar with unity still go ahead and give those videos a watch perhaps in a faster speed just so you know everything that this course assumes that you know here I will assume that you know the basics covered in those videos like what is a game object what is a transform what is a mono Behavior how scripts have a start and update and some csharp Basics as long as you know those absolute Basics you should be able to follow everything in this course I won't teach everything above the absolute Basics and if you are a more advanced users definitely keep watching the beginning of this course might not have much that is new to you but as we build the game and start using more advanced tools like script of objects csharp events and interfaces refactoring code and focusing on Project architecture and writing some good clean code if you are not a complete beginner you will still learn quite a lot from seeing how this project is built and again like I said I answer comments every single day so any questions you have just post them there and I'll do my best to help this course is split into lectures they are all as chapters on videos so you can navigate around let me also take this time to point out that you are not expected to follow this course in one sitting go ahead and take your time focus on actually learning remember that's the only goal you're not competing with anyone you're gaining knowledge just for yourself so take as much time as you need rewatch some lectures if you feel you didn't fully get it or just ask some questions whatever you do take your time and just focus on actually learning so again if you haven't done so go ahead pause this video and go watch those three Basics videos with that we're going to have everything we need to get started we're going to start only from scratch so let's begin creating a brand new project in the next lecture hello and welcome I'm your code monkey in this lecture we're going to begin actually building our game so let's create a chameleon 2 project and start building it on from scratch okay so the first thing that we need is to install Unity now I cover this in detail on that other Basics video so here I will assume that you already have Unity Hub installed the first decision we really need to make is choosing a Unity version Sony Hub you go into installs and install an editor and now Unity recommends that you use the LTS version or long term sport you should be using that one in most cases it's what it installs by default which as the time of this recording the latest one the latest LTS one is 2021.3 however I want this video to stay up to date for as long as possible so for making this game I will actually be using version 2022.2 if you're watching this video where it is came out then download this version and if you're watching this months in the future after version 22 on TS is out then you can use that one it won't probably be the exact same thing as version 22.2 so you should be able to follow everything exactly for any changes I will Point them out in the updated pin comment and if you're watching this years in the future and there's an even newer LTS version I would still recommend you follow using the 22 LTS don't worry about using a quote unquote older version everything you'll learn here in this version will still be applicable even 10 years from now so I said I'm going to be installing this one in terms of modulus doesn't really need anything I already have Visual Studio Community installed and all the other ones are unticked so install okay so the version is installed now let's create a new project let's go into the projects tab then create a new project and now first up up here make sure to select the right version so again I'm going to be using 22.2 then for the templates this has mainly to do with the UNT render pipelines now if you're a beginner don't worry about that too much just go ahead and select the 3D urp template so scroll down this one right here 3D urp make sure to select this one and not the one that says just reading the urp here stands for the universal render pipeline which means our game will be playable on literally any platform so we can make the funnel game and put it on steam or consoles are mobile it won't run on everything then over here on the right side let's quickly just download the template there it is it's done now select the name for your project so I'm going to call this kitchen chaos and then select the founder for it all right so that's it again make sure you're using the exact right version make sure you're using the 3D urp template give it a name a folder and let's head on create all right so it's open and right away you might or might not see a window talking about urp material upgrades I think this has to do with the template not having the default materials updated to the latest Erp version so if you're watching this in the future chances are you might not see this one at all but if you do then just go ahead click on OK and it will automatically upgrade all of the default materials alright so here we have our basic unity window now since we started a project starting from the RP template we have down here A bunch of Erp helper files so you can click to select the readme file and you can see it over here on the right side on the inspector if you want you can browse around these links in order to learn more about urp but in our case we're building the our game we really don't need this so we're here on the inspection let's just click this button to clean up these readme files just go ahead click on yes and okay that's it so basically you should only have these files in your project window so there's a scene folder and inside we've got the simple scene then we've got the settings and inside a bunch of urp assets while this should have been set up automatically since we use the 3D template and then finally we just have the urp equivalent settings asset now let's just verify find everything worked correctly so let's go to the top left go into edit then go down into project settings then over here let's go into the graphics Tab and you should see the urp High Fidelity asset assigned by default if not you can click on the circle icon and assign it then the other menus over here the urp mobile settings again this one should be set by default then down here on the quality tab on this one make sure High Fidelity is selected basically whatever you select here is the quality that we'll be using in the editor and in turn the selected quality over here also has a render pipeline Ascent now in order to avoid any confusion let's actually get rid of the other ones so let's just click on the trash icon to get rid of the performance and the bounce quality so just click and click okay so we only have this one then let's close the project settings and let's go into the settings folder and over here let's select the urp balance there are two assets for each quality so select those leave the High Fidelity and the performance and let's delete these alright that's it by the way if you made a mistake and accidentally deleted something don't worry you can always just click over here on the plus icon on the project window and then go over here under rendering and you can create a new urp asset with the universe personal render okay so just like this so we only have one quality setting we have high fidelity the quality setting is using this random pipeline asset which is also using this renderer so that's really it with this we have the absolute bare minimum we need if in the end after building the whole game you want to provide multiple quality settings then you can come back to this menu and recreate them but in order to avoid confusion while building the game let's keep things like this as simple as possible okay so that's the basic setup done next we want to prepare our layout so let's continue on to the next lecture hello and welcome I'm your code monkey in this lecture we're going to learn about the union layout and set it up so first things first let's familiarize ourselves with the various NT Windows to create our own layout it's very important that you feel uncomfortable with your layout that you have easy access to all the things that you need then you know where everything is you can see that there's lots of tabs everywhere over here on the NT window all of them can be dragged and dropped in any different position so you can customize your layout to get it looking exactly as you want you can set it up in any way but it will be easier to follow this course if you're following the same layout as me I'm assuming you've seen my quick Basics video so I'm assuming you know what is the inspector what is a game object what is a transform what is the console where is the hierarchy and so on if this is the very first time you're seeing the UNT interface go watch that other quick video first just learn the absolute Basics now for me I've been using Unity for over 10 years now so let's see the layout that I've developed over the years first the inspector on the right side just like default that way we always have a nice view of the selected object and whatever scripts and components it has then for the hierarchy I like to put it down here only on left side we're going to make sure that in our scene is always organized so we don't need the hierarchy to take up tons of space then with the project files next to it this corner is enough to really browse all of the files we want the console to be on the tab right next to it usually I find that when making the game I want to look at the project window but when playing the game I just want to look at the console so keeping them in the same place but on different tabs works great then over here on the center of the scene View and again with the game view right next to it okay so this is the basic layout that I normally use now for a couple more options let's go into the project window and on the top right corner you can see over here these little three dots by default it shows you a two column layout so there's a column here and a column here but personally I prefer the one column layout this shock is one of the project files in a nice compact list view the one thing where I prefer the other one is if you're browsing for some visual assets over here you can increase the thumbnail size but for most times I really like to use the one com layout much more compact also since we're talking about the project window just in case you don't know there's over here this little button with the eye this one has to do with package visibility if you toggle it then some of the inside compacts are hidden whereas if you untangle it then you can see all the various packages with all the source code and so on you can expand over here the packages and right now it is showing all of them all of them with source code the things everything in there and if you click on this then it hides it only shows a bunch of core ones but for most part you really want to leave this text and leave this one collapse nice and clean okay so then on the console over here once again let's go into the three dots and for the unlock entry for this one I like to select one line this makes the console nice and compact which I personally prefer you can see more logs without taking up more space and if you want to read the home log you can always just click on it to see the home stack Trace now there are also some more options over here if you want for example show the timestamp this will show the timestamp when each message were sent you can use a mono space font meaning a font where every character has the exact same width so a bunch of options but for me leaving it just like this works perfectly fine then also importantly over here these three buttons these toggle the visibility for the type of messages that appear in the console the unlocked one this one is for regular messages we're going to use this a lot then we've got warnings and finally errors if you untangle them then the messages of that type will not show up on the console so if you ever come across an issue where nothing is showing up on the console make sure all three of these buttons are ticked then on left side on clear you can click on the Arrow to see more options I like to set it to clear on play then collapse this one basically collapses messages that are the same all of them into one entry personally I do nothing like this I want to see every single message as it comes out even if it's repeated I've also seen this lead to a lot of confusion for some people they think their code is firing just one message when it's actually firing hundreds So to avoid any confusion make sure you leave this Untitled then for airpods this will automatically pause the game when there occurs you should definitely have this one toggled if there is an area you definitely want to know about it you want to know when it happens so you can fix it whereas if you untuckle this you might get some errors and the game might keep playing which will then lead to lots of confusion when something starts behaving weirdly so always leave this one toggled and then the editor button this one is for more advanced use case so don't worry about it okay so that's the console then over here for the game view we've got a button here to select the aspect ratio let's go ahead and select fully Gene this one is a 16x9 aspect ratio so everything is pretty normal this will really only matter when we start working on the UI but so I like to keep it at 16x9 always then on this button that says play Focus we can modify some options basically Focus won't play exam like this on this small window if you choose maximize then it will maximize this one when playing the game and play in Focus won't play the game even when the window is not in Focus then another important one is actually on the same one as the aspect ratio here we've got a button to turn on vsync usually When developing the game you really want to toggle this that's because right in the beginning when the game doesn't really have anything you can leave it on Talent then this might run at like a thousand frames per second and that will pretty much drive your GPU crazy finally if your game view is looking a bit too pixelated make sure over here on the scale slider make sure this one is not zoomed in this one should always be pushed straight to the left as much as possible okay so that's the game view then over here on the scene view for this one default should be good these two buttons are extremely important pretty much all the time you want to keep the tone handles on the pivot it and not on the center if you ever see your handles on weird places always come back to this you want to sound pivot pretty much all the time then for rotation sometimes local is useful but for the most part you should probably be keeping in and Global then for the great showing the reason why yep down looks pretty good a nice little visual grid then you've got a bunch more options if you want then next to it we've got snapping this one we also don't need this for now and finally same thing for increment also don't need this okay then on the right for the drum mode let's leave it on Shaden for two then let's leave this disabled since we're working on a 3D game for lights let's make sure this one is enabled for sound we're only going to add this in the end so it doesn't really matter for now then for special effects usually you want this one to be enabled so it shows everything you can click on the arrow and make sure all of them are toggled the only exception is always refresh you probably don't need this little scene window to be refreshing at 60 frames per second so you can leave that one unticked and take on the others then these are for the hidden objects so let's leave them toggled for the camera here are the defaults and finally gizmos leave them all enabled as the defaults alright so down that's end here is in layout and going to be using throughout the course it will be easier to follow the course if you're using the exact same layout as me so ideally you should be using this but again like I mentioned all the windows are customizable so if there's something that you absolutely prefer differently then go ahead you can drag and drop and place any Windows anywhere you want so once you have layout your happy win you can go up here to the top right corner where it says default you can click on it and here you've got a bunch of layouts so you can save your new layout so I'm going to save this one as kitchen chaos and then over here you can select anyone you want for example if you ever have some issues with any kind of weird editor Windows you can load back the default layout and then go back and load your own layout okay so with that our layout is set up the next important thing is setting up visual studio so let's do that in the next lecture hello and welcome I'm your code monkey in this lecture we're going to set up our Visual Studio alright so with the Intel layout setup let's make sure Visual Studio is also set up correctly I'm going to be using version 22 Community this one is the free version you don't absolutely have to use the same code ID that I'm using you can use writer or vs code or whatever you want so let's see my setup for visual studio but first let's actually set up something over here in unity so let's go up top into window and then let's open up the package manager then over here on the drop down menu let's select the packages and select the ones from DNT registry then let's scroll down to find the visual studio editor package so here it is this one this package basically handles the integration with visual studio so you can use the debugger and a bunch of things alternatively there's also a package over here for visual studio code and there's also one over here for jetbrains Rider so if you're using a different IDE go ahead and install the package for me I'm going to install the visual City one so this one just go ahead and install okay it's done so next let's go up into edit and let's open up the print preferences then over here let's go down into external tools and on the external script editor make sure you select the one you're using so again for me I'm using visual studio 22 and also over here you've got a bunch of extra options now if you want to play around with reading the source code for the very CNT packages then you can tick on these boxes but in our case for this simple game we don't need that so go ahead and leave everything just like this with defaults okay so with this setup now we can go over here into assets and open up the csharp project and this should open up visual studio and alright so here it is now for some more settings inside of here in my visual studio I have a really nice extension that adds a bit more colors to my code which makes it easier to read and write so up top let's go into the extensions menu and manage extensions and the important one that I've installed is this one vs4 if you want you can go into the online Tab and over here search for it any Apple that show up in here then for the settings on that extension let's go up here into tools and let's open up the options then over here let's scroll down and find vs4 Yep this one and here are all the settings and expand this and a bunch more settings now for me I think these are on the defaults I don't remember if I changed anything the important one is over here the rainbow braces so these have a bunch of Commerce which make it a bit easier to read the code so let's create a simple script just to see this so back in until let's go into the project window let's click the plus icon and let's create the brand new csharp script let's call it just testing wait for it to compile and now let's open now over here I'm just going to write a bunch of simple code just to test it out you don't have to follow this alright so here's a bunch of sample code these are the colors you can see it makes everything a bit easier to read although again this is not a requirement you don't absolutely need this extension but personally I do find it quite useful I find that it helps make the code more readable than having everything be gray okay so that's the setup for this extension next for the text formatting options so once again let's go into two holes go into options and then over here let's go into the text editor then over here I think I've got pretty much all the same defaults then we can go into the csharp rules so here are all the settings if you notice something different on your end go ahead and pause the video and compare the settings but again I think everything here is pretty much defaults I believe the only difference that I did was over here on the code style over here for new lines personally I like to have the currently brackets on the same line but if you want you can also change it and put it on the second leg I think that's pretty much the only difference that I did everything else should be exactly the same as defaults so that's the code sound settings and speaking of that the next lecture is very important we're going to talk a bit about naming rules although just before we go let's just clean up our testing script so let's close this one click on the X then back into Unity we don't need the script so let's just delete it okay so with that we have Visual Studio setup and ready to go now let's continue in the next lecture to learn about some naming rules hello and welcome I'm your code monkey in this lecture we're going to learn something extremely important let's learn about naming world this one is a very important lecture that you should definitely refer back to whenever you have some questions so first what exactly are naming rules these are really just rules you follow when writing your code it is extremely important that you are consistent in applying your own rules you don't want one class in your game to be written a certain way and then a different class using a completely different style that would create tons of confusion so naming rules and writing the code correctly is very very important one mistake that I see a lot of beginners do is they send me some code and ask why it's not working then I take a quick look and I see that all of the code is written in a very messy way some functions are on lowercase others using snake case some films are in personal case some in camel case and so on remember that code is case sensitive so it is extremely important that you write the code correctly if you change a character from lowercase to uppercase then you are suddenly referring to something completely different if you're a beginner keep that always in your mind code is case sensitive so don't just write code semirandomly write it properly as if you were doing an English literature test now with that said when it comes to naming roles you can use whatever name neurons you want different people like different rules for example you can use a prefix in your variables you can use a postpick you can use capitals for consonants chemical case for properties snake case for Fields by the way here are the definitions of what those terms actually mean Pascal K starts with a capital and every word is capitalized camel case starts lowercase and then uppercase for the first selector of every other word kind of like a camel hump in the middle and snake Haze is where you add an underscore in between the words I send every rule can be valid the important thing is that you are consistent in always following through with your rules as you might know Unity mono behaviors have some deformed functions you can Implement things like start and update which are written using pastel case since you can't really change in these rules at least on function names I would say you should base your rules off of theirs so for functions you should probably be using Pascal case for the rules like I said choose whatever makes sense to you here are some of my own personal rooms that have developed jumped over the last 10 years and the code sound that I won't be following in this course for functions I use Pascal case just like unity and just like the csharp standard for function parameters I use camel case for Fields also camel case properties are in personal case constants are in uppercase snake case then another rule is that I like to add the top of the variable as a postfix so if it's a list type in the list if it's an array open array and now you might be thinking with this wouldn't it be an issue if we change the type then the name is suddenly wrong and the simple solution for that is that if I change the type then I just use Visual Studio to quickly change the name that's it then for the currently brackets like I mentioned in previous lecture I like them on the same line some people have some very strong opinions about this really it's just a visual style and this is the one that I personally prefer if you like new online then go ahead and use that it doesn't change how the code Works in any way in a final rule spend some time deciding on a proper name and don't be afraid to rename things you will note how all the code that we're going to write in this course has proper names for everything you should never use a variable with a single letter like X X or k the exception of course would be iterated in a for Loop also don't use acronyms or abbreviations those might seem player right now but in a few weeks you might not remember what they mean remember you don't get bonus points for writing extremely compact code so prioritize making your code readable and understandable even if it requires variables and functions with long names so these are my general rules and the code style that I personally follow figure out what works for you and follow your own naming rules but naturally in this course I will be using my own code cell so if when following the course you are not sure how to write some type of code you can refer back to this lecture and watch it again like I've mentioned many times the code that I won't teach you how to write in this course is on the exact same level of quality as my paid courses and my Steam games so as such because that this lecture these naming rules are all extremely important okay so with this very important lecture out of the way now let's start playing with some visuals by importing some Assets in the next lecture hello and welcome I'm your code monkey in this lecture we're going to import the project files with all the assets that we're going to use by the way remember that if you have any questions go ahead and post them in the comments I go through those every day and I'll do my best to help okay so with the project created the next thing we want is to import the assets that we're going to use to make this game you can download all of the assets with the link in the description which by the way like I mentioned a while ago that link contains a Unity package that contains both the assets and the final game so when you download that you get ENT package just go ahead and double click or click and drag and drop it on the projects window here is the asset import window just make sure you select all and let's import okay so here it is let's import the assets folder and inside comes all of the assets meshes textures and so on so everything we're going to need and then it also imported inside of it another ENT package so if you want to import the final project with all of the code already written it's also here if you extract this one you're going to get the complete project files now of course don't do that if you want to follow along with the course and be aware that if you're following along and you accidentally end unpack this one it will override all of your own files so if you want to inspect the final project files go ahead and do that but do that in a separate project in order to make sure that we have no accidents I'm going to delete this one from the current project so just go ahead and delete okay so that's it and over here we've got all of our really nice visuals we can look in the prefabs visuals and over here we've got a visual for a container Sergo that's a container counter then we have a cutting counter we've got a trash bin then on the kitchen object visuals we've got all the visuals so a block of cheese we've got some burned meat we've got a plate and so on these are all the nice 3D models that we're going to use in our game and then over here on the textures folder we also got a bunch of General icons as well as actual icons for all of the various parts okay so all of the assets have been important now let's continue on to the next lecture hello and welcome I'm your code monkey in this lecture we're going to set up post processing now here let me make a quick note usually when making your games you probably don't want to hand on postprocessing right way you should first get an ugly prototype up and working before worrying about any visuals so normally I would only add postprocessing much later on in the dev process but since this is a course in video format in order for the video to look a bit more appealing let's set a post processing right away now we already have the project set up to use urp so adding postprocessing is actually super simple it's actually already added by default first before we do that let's rename our scene with a proper name so inside the scenes folder it starts off with sample scene this will be our main game scene so let's just rename this to game scene okay and now here on the hierarchy we can see by default this scene already contains a global volume game object this is how you actually add postprocessing and by default you can see that it also already has a sample and profile attached this is how you add all of the various effects you can click on this link and it will show it over here on the project window now let's film this from scratch instead of starting from this one so let's go into that file into that asset and just delete it okay so now we have no value profile now let's go ahead and click on new to create a brand new one okay so now here we can add overrides add all of the effects that we want let's drag some visual meshes that we imported in the last lecture to get a better look at all these effects and what they do so first let's make some kind of more so let's make a 3D object let's make it a plane let's name this D4 also one extremely important thing whenever you create a brand new object always check the object's transform position by default when you create an object it appears in front of the scene camera which will probably not be on zero zero zero you always want to be very careful with the position of your actual objects so for a plane we do want this to be on the origin so on zero zero zero so make sure you always do that then let's scale it up a bit so on the scale let's put it on 555 which by the way you've got this nice little icon this was added in a recent Indie version basically if you enable this and matches all of these values so if you just change one of them it changes all of them so let's put this on Five okay great now for the visual let's go ahead into the mesh render on the materials and let's select the brand new material so let's click on the circle icon and over here let's find the floor material so here it is it's the one included in the assets there you go we've got a nice basic form material now let's also drag the player visual so let's go inside the assets folder and over here let's go inside the prefabs visuals and down here we find the player visual so let's just go ahead and drag this one so there it is a nice player visual let's also drag a counter so let's find let's say the Clear counter let's drag this one let's rotate it to face the camera something like this and let's also put a cutting counter again we're just placing some visuals just so we can see what the post processing will do and let's also place a bunch more things so let's say a tomato let's place a tomato over there and maybe cabbage all the way over here okay so we've got a handful of nice visual elements so we can test out our post pressing by the way here's a quick empty tip on scene controls whenever you are on the scene view which make sure you're on scene View and not game view those are different so on the scene view you can move the camera with a mouse you can pan with mouse 3 so the middle Mouse button so hold that and pan around we can rotate with the right Mouse button you can rotate around Point by holding down left alt and left click and just drag it around to rotate around an object you can select an object like for example player visual then you can press on F to select that object and now if you hold alt and click it will rotate around that object also another method is you can hold the right Mouse button to move it around and then you can use was to move so d a and so on then you can even press shift to move in faster and you can use the scroll wheel while holding down the right Mouse button or to modify the speed at which you move so there are plenty of camera controls to really get you seeing exactly what you want to see now for another quick empty tip you can move the scene camera to where you want the game camera to be so let's say I want the game camera to see things from about this angle so you just position the scene camera then on the hierarchy select the camera game object so the main camera right here and with that object selected you press Ctrl shift and F and if there you go you can see over here on the camera preview let it position the main camera looking on the exact same position at the exact same direction as the scene camera set the shortcut Ctrl shift F or alternatively go up into game object and over here on line with view now if you look here is the scene View and over here we've got a nice camera view so just position the camera somewhere where we can view all of the Assets Now with this let's add some post processing effects so first let's select the global volume game object and over here we can add all of our effect overrides first up let's begin by adding tone mapping so there you go we've got the effect and over here we've got a nice little checkbox so you can enable it in order to enable this effect and set one of the options now for this one I'm not too familiar with color correction but I find that usually adding a neutral tone map usually that helps also make sure you're looking at the game View and not the scene view if you're looking in the game View and you enable and disable this effect you should see a difference whereas on the scene view if you enable and disable it doesn't actually show that even if you're on the scene view over here you have all the effects enabled even with that some effects for some reason don't show up on the scene view so when playing around these effects almost make sure you're unlocking through the game view so like I said you should be able to toggle this and see a visual difference on the game view if you don't then make sure the camera has post processing enabled so let's select the main camera game object and down here there's a tongue for post Crossing make sure this one is enabled and then also on the render pipeline assets so let's find that one on the project window over here we've got the settings and we've got the urp High Fidelity this one should be using a renderer so if you click on the renderer over here you should have postrossing enabled again all of this should already be correctly set up by default so if you're going to take a global volume enable our disabled you should see a visual difference okay so next Effect one that I always like to add is a bit of saturation so let's add an override post processing and let's add a brand new here it is color adjustments then over here you've got plenty of things to play around with for me I like to add a bit of saturation so just lift it up a little bit let's say just about 20 and I also like to add a little bit of contrast over here and let's also add 20. and there you go it makes the colors pop a little bit more so personally I don't like this effect then later on we're going to have some glowing objects for example the stove let's actually try dragging that into the scene so let's go into scene View and in the assets let's find the stove counter so here it is and inside the stove counter there are some things so here it is the stove on visual this one is disabled by default also on the inspector let's just enable on this game object to make it visible again don't worry about the positioning of the objects on the scene view right now we're only positioning them just to set up the post pressing we're going to delete them all at the end of this lecture okay so now in enable let's go into the game View and over here we see the stove enabled so now let's go into the local volume let's add an override go into post pressing let's add a volume effect so right now notice how that one is not glowing red hot for that work we need to have Bloom and we need to enable the threshold and the intensity if we raise the intensity we do see yep there we go a really nice low there by the way here's a quick visual attempt if you want to make your game feel a bit more ethereal and magical one good way is to put the threshold that on low value below one so something like 0.5 and then put the intensity as a little bit and with this notice how everything has a slight low even colors that don't have any extra intensity so the floor is glowing the character is going so everything looks quite a bit ethereum this is a bit extreme but it is an interesting effect also another quick note here in case you're not seeing anything change make sure you go into the render prop online assets so the urp High Fidelity and over here make sure AGR is enabled you can look at so low if I disable it yep that one stops glowing and with that enabled it does start glowing AGR stands for high dynamic range so that is how you can have a color go with an intensity above one which actually makes it low when you have the balloon post pressing if even with that you're still seeing issues then make sure you go into the renderer and over here for the post processing sometimes Unity has a weird bug and doesn't generate this postprocess data file so if that does happen just go ahead untoggle and toggle this and it should work and finally like I said on the camera make sure you have post Crossing in Arrow so with all that you should be able to see the game view glow okay back into our effects with our balloon working like I said you can lower this below one to get a nice ethereum look but this is a bit too intensive on what we want so let's make it a bit more subtle so on the threshold let's put it at 0.95 so there's a slight low on the white Parts but nothing too intense and for intensity let's put it at a wrong number one okay so I think that's a nice amount of Bloom all the colors glow a little bit and we can see over there the stove it is indeed glowing okay great now if you ever forget all these steps and you can get your project to Glow I made a nice video with a nice checklist of everything needed for you low definitely go ahead and watch that video whenever you have issues then for another fun effect we have yet so let's go into ad override post Crossing and let's find the vignette what this one does is adds a bit of Darkness to the colors so if we enable the intensity and we increase it you can see what it does so it adds Darkness around the corners there personally I find this one looks good when it's quite a bit subtle so let's put the intensity at some like 0.25 and then for the smoothness let's also put it on 0.4 so just like that just a slight Darkness on the edges so personally I think it looks pretty good and that's pretty much it for the Post Crossing on the volume component I like how this looks you can see difference with the volume enabled or disabled quite a big difference looks pretty nice but again these are just visuals so feel free to play around maybe add some more effects using different settings these are just visuals they don't impact the game logic at all so feel free to make it work exactly as you wanted then yet another thing related to post processing but not in this component it's some antialiasing for that one place where you can change it is on the main camera over here you see a film for post Crossing and you have a bunch of types so fxa a or smaa or if you want some more higher end post processing you can go into the render prop online Essence so urp and hyphenoly and over here we see antianalyzing msai this one is a bit more expensive but looks a bit better if you want to see difference you can go over here into the aim View and on the slider up top on the scale you can increase this quite a bit so with this we can now see the pixelation and you can see over here if I switch at the only thing from 4X back into the table you can see lots of jagged edges and if I put it on 2x Yep looks a bit more smooth 4X a bit more smooth and 8x even more smooth so with that you can see difference on all the edges on the things by default this renderer has on 4X and nothing on the camera this already unlocks pretty good but to make the video look even better I'm going to put it on 8X and on the main camera I'm also going to leave it with no antialency you can combine them but if you do then everything looks a bit too wiry so I don't quite like that effect so put this one on none and the other one on 8X although again this is just a visual so if you have a low end PC feel free to go into the urp and over here disable antializing so the game looks a bit worse but it won't run much better okay let's drag the scale back down okay now one final thing we can add is some really nice screen space ambient conclusion for that let's go into the render so not the render pipeline asset the renderer and over here by default it already added screen space ambient Collision if it didn't add you can click on ADD render feature and over here you won't be able to see it I don't see it because I already have it okay so here it is basically what this effect does is it adds some tiny Shadows where geometry intersect if we enable and disable it quickly we can see the effect over there on the counters so you can see with default effects it already Works quite nicely for example look there on the player we can barely see the difference between the head and body but if we enable this it has that nice little Shadow I think it looks really nice but then we've got a bunch of settings we can play around increase the intensity the radius and so on Now One important thing when setting all these effects is to remember the point of view of the camera in this case we're making a topdown game so before we play around these settings let's actually position the camera in a correct position so let's go ahead select the main camera and let's position it above pointing down so let's put it on an X of 0 on a y of 21.5 on his head of minus 21.3 then for the rotation on the X 46 then 0 and 0. and finally on the camera over here on the field of view instead of 16 that's really wine for this game let's go with 20. okay so this is the view that we're going to use for our game let me just rotate the object so they actually face the camera so on the hierarchy let's just select all the objects let's rotate them all around and just position them again we're only using these just to see what they look like we're going to delete all of these objects in a bit okay so yep that's the game view now that we have the camera set up let's work on the settings for the eminent conclusion so let's go down select the renderer and over here for the settings for the intensity and let's put it on four for the radiance let's put it at 0.3 and direct lighting strength let's put it all the way up to one okay so you can toggle this enable and disable to see difference and yep I do think these settings look pretty good finally the last thing we need to check is in lightning window so let's go into window then down into rendering and let's go into lighting how it pops up the unlighting window personally I like to Anchor it over there next thing inspector and over here we're really going to leave everything on defaults so you can leave it as the lighting settings assets and nothing assigned and then on the environment tab over here again all of the defaults I didn't touch any of these so we've got environment lighting from the Skybox and then some multiplier of one so everything pretty much on defaults although again like I said most of these visual effects are very much personal preference so if you want to make your game look a bit different than mine then go ahead you can play around with lighting over here you can change Skybox gradient color and so on if you want you can use some bake lighting then if you want you can add all kinds of extra effects and also by the way remember that the effects are stored on this profile over here so for example you can click over here on the Clone button and it will include the effects and let's click on it to find it yep there you go so that's the one that I've built and here's a clone one so if you want you can make a clone one and then make it look very different for example let's go into chromatic aberration make it really intense and for example let's go into the counter curves and over here for some reason let's drag the green up and so on so there you go completely different visual so if you want to play around make some weird effects and if you want to go back to just revert back into the original profile personally I'm quite happy with how this looks so I'm going to be using this one okay again you can enable and disable the volume game object to see quite the big difference that postprocessing makes if you ever want to make your game look quite a lot better always make sure that some post processing alright so like I said this looks really good I like it now before we go to the next lecture let's just clean this up so let's get rid of all of these objects so the counter cabbage tomato and so on let's get rid of all of them except the four so let's leave the four and get rid of all these alright so here we have our nice empty scene let's just save our scene and let's get ready for the next lecture hi there this is a quick intermission so how are you doing are you enjoying the course so far are you having any trouble with anything is there something you didn't understand if so remember I'm always active in the comments answering all the questions so if there's anything you need some extra clarification go ahead and ask and I'll do my best to help also remember to check out the pin comment YouTube videos cannot be updated so for any notes or comments I'll put them in the pin comment and definitely check out the website page for this course as people ask more and more questions I will keep that page updated with any frequently asked questions for every single lecture so that way you can see what others have asked and learn from them and you can also download the project files for each lecture so keep that page open on a second Tab and check it every time you start watching a new lecture I really hope you're enjoying the course and I hope you've already learned quite a few things go ahead and hit the like button and subscribe to the channel if you haven't already okay so let's go to the next lecture hello and welcome I'm your kudmaki in this lecture we're going to begin creating our character let's make a nice character controller so we can move our character in the world okay so first let's begin by creating the character game object and now usually most beginner tutorials will tell you to just right click go into 3D object and create something like a capsule that way you would have the game object with the visual included however for a good project structure and good organization you should only separate the visuals from the logic for example here in let's say that I don't want my capsule exam like this let's say that I want my player to be a little bit more skinny to do that I would have to modify on the scale on this game object so put it maybe on 0.7.7 so something like this basically by doing that by modifying the visual I also modified the scale on the actual player game object having a nonuniform scale on a logic game object that can cause all kind of problems with any kind of logic component also I would prefer to have my character on the floor but if I put it on yf0 notice how the character is half underneath the floor so if I were to use this method I would have to apply some kind of offset in order to make the visual above the floor so that would require rearranging all the logic to work with an offset on the Y position so because of those reasons and many more you should not Place both the logic and the visual on the same game object instead you should separate them so let's get rid of this and instead let's create an empty game object let's name this the player let's put it on zero zero zero okay and now inside of it now inside let's create let's say a capsule now in this one we can easily scale this to get any size and shape you want so for example 0.7.7 then since the visual is a child of the game object we can also easily offset this so let's say you put it up by about one unit so with this we can position the visual so that basically the player game object is over here on zero zero and the character is above the floor so we don't have any weird offsets this will make all of our logic much more simplified and on this empty Parent Game object we can attach all of the logic components we want and then in the child visual we can either replace whatever visuals we want so as a general rule you should always try to do this only separate the logic from the Visions in your game objects okay so with that we have the player game object now let's make our character controller script and before we do let's keep things once again organized so before we do let's create a brand new folder so let's right click on the assets create a brand new folder call it scripts and now inside let's right click and create new csharp script called the player wait for the code to compound then select the player game object and attach the script again remember logic components go on the parent game object not the channel vision so the challenge visual this one only has visual components and the player this is the one that actually has the logic components so let's open up this script okay so here's our first csharp script like I said I'm going to assume you know the absolute Basics go watch the csharp basics video If you haven't seen it yet so I won't assume that you know what is a function what is a variable what is start and update so pretty much the absolute basics for a character controller we first need some input from the player and for that EMT actually has two methods you have the Legacy input manager and the new input system basically the Legacy input manager is super simple and very easy to use so this one is perfect for quickly prototyping and the new input system is extremely capable with tons of features but it's also a bit more complex so what I do is while I'm doing a simple demo or testing out a new prototype by just using Legacy input manager but when making a more complex project like for example my sim game then at a certain point I refactor my code to use the new input system so here I'm going to teach you both as well as teaching you how to refactor code which is an extremely useful skill so let's first begin by using the Simpson Legacy input manager we want some basic was movement to move our character and we're going to need to run that logic on every single frame so let's do it on update and let's actually get rid of the code that Unity writes by default let's start coming from scratch and let's get rid of this just close okay so here let's start by writing private void update and now here very important if you're a beginner make sure that update is written exactly like this if you write update with lowercase if you do this then it won't work the function will not be calmed automatically I'm pointing this out because I have seen a bunch of comments from beginners wondering why their code doesn't work and it's as simple as this with a lowercase Unity will not call this automatically it needs to be exactly perfect so again if you're a beginner make sure you write the code exactly the code is case sensitive so this is very important also another note you saw that the code that Unity wrote by default when we made a new script it just had void update it did not have the private keyword private is what is called an accessor you have private then you have public and then there are some more advanced ones secondly you can omit the accessor and in most cases it will default to private however in writing good clean code you should be as explicit as possible there should be no room for misunderstandings so while technically you could emit the private you should always include it to make your code easy to read and easy to understand this one is the first of many clean code rules that I will teach you during this course like I said all of the code that I'm writing here is on the same level of quality that I use in my own professional games I'm not going to teach you bad practices like so many beginner tutorials do so always be explicit always include the accessor okay so we have our update Running code on every single frame then to test if a key is being pressed we just go inside input then over here we've got two functions so we have get key and get key down both these functions were turning Boeing so that's how the true or false the difference between them is that get key down this one only returns true for a single frame when the key is pressed whereas get key this one stays true for as long as the key is held down for example for an action like jumping you just want to know when the player presses the button so for that one you would use get key down however in our case for a character controller we want to know if the key is being held down we don't want just one frame but always so for movement let's make sure we go with get game then requires a key so let's write our key code and then choose the key let's say we want w and then let's just put this inside and if just like this okay so here we have code we want to run while holding down the down key let's do a quick test just to verify everything is working perfectly and for testing we can use a super useful debug.log this one lets us print a message in the console someone said One log here just say something like pressing and then let's also do an else and if else let's do a debug.log and just do a dash okay so here is our very basic script let's make sure to save it so Ctrl s then back in unity over here make sure you have the script attached to the player game object and now we can test and now down here on the console we can already see dashes so I'm not pressing anything also like I mentioned in the setup lecture if you're seeing just one message then maybe that means you have over here the collapse Target if you talk on it and look how it only shows one message but then over here on the right side it says the number of messages personally I prefer to always keep it untoggle so I can see every single message also over here on the right make sure you have info messages visible if you untangle this and you don't see it so make sure this one and actually both of them make sure all of them are enabled okay so we're seeing a whole bunch of dashes and one more note if over here these chromebars stop scrolling so right now you can see it's stuck up instead of being down there so if that happens one is easy way to reset that is just click over here on clear and it goes back into AutoZone okay so we have the dashes I am not pressing anything now as I press yep there you go there's a message if you don't see it make sure the game window is in focus so selective game View and click right here on the middle to make this one the focused window then if you press the down key you should see the message and if I Let Go yep there it is and I stash okay great so all the basic logic is working back in the code here now that logic is working let's get rid of the else here and let's set this for all the other keys so let's copy paste this so we're going to need w a s and D so let's make all of these okay so we have our inputs let's also get rid of the logs we don't need this all right so we have all of our key presses now let's construct a vector with our inputs and since we're just going to have two axes the double s that is forward and backwards and this one is left and right so just two axis so because we have just two let's use a vector two and let's call it the input vector let's construct it so we'll do a new one and start off at zero zero okay then over here the logic is pretty simple so when we press W then let's go into the input vector and set the Y to pause one then when we have an S we want to go backwards so put the Y on 1 for the a we want to go left so that's an x on the minus one and finally for the D that is an x on plus one okay so with this we have our correct input Vector let's do a quick log just to test so debug down log on the input vector okay so let's test all right so we can see in log zero zero okay makes sense now if I press W yep we've got an 1 on the Y if I press a we got minus one in the X press D plus one press s and minus one okay great so everything works except we also need to be careful about one other thing if I press both W and D with this look at that the vector is 1 1 which is correct that's exactly what it is then except the factor one one actually has a bigger magnitude than just one vector if we leave it like this then the character will move faster when moving diagonally versus when moving in just one direction for our input Vector we really want it to be normalized meaning we wanted to have the same size regardless of the combination of keys that we're pressing so back in the code here after calculating the input vector and let's simply normalize it so we go into the input vector and we set it equals to input Vector Dot normalized so this will normalize our input Vector let's see and over here if I press doubly you've got one press s minus one okay so all those work now if I press both W and D if there go now it says 0.71 when you combine both these I need the math these do end up with a magnitude of one so with this our character will move at the same speed on both diagonals and straights okay so we have the input Vector on correct now let's actually apply some movement for that there are many ways of making a character controller for example you can decide to use physics or not over here I want to keep the game simple so let's not use physics instead let's just move the player transform directly over here we have our input Vector okay great now we want to apply this to our character position so first we access the transform this one refers to the transform where this script is attached to this script was attached to the player so this is going to refer to the player transform then we want to modify the position so let's access the position and now for moving we don't want to just assign it if we do something like this like this the player would never leave the center of the world he would always be near zero zero so instead we don't want to just assign it but instead we want to add onto it now if you're a complete beginner and you don't know this syntax then this one is exactly the same as this so transform dot position equals transform dot position plus input vector so both these little lines are doing the exact same thing personally I prefer to use the shorthand I find that equally readable and more compact okay so we have this and we add our input Vector to the transform position except we can also see a really nice error basically it's telling us that we are mixing two types our input is a vector two where we only have an X and Y but transform that position is a vector 3 meaning it has an X Y and Z one simple solution is to cast our input Vector onto a vector three so we just convert this from one type into the other one and yep we don't have the error so let's test and now if I press W any of the character does move Let's ignore the massive speed for now so it does move it does seem slightly correct except you can obviously notice that it's not correct we are moving on the xaxis on left and right that is correct but then we are moving up and down instead of fourth and back basically we convert the effector 2 directly into a vector three so we are moving on the X and Y axes but in our 3D game we really don't want the characters to fly so instead we want to move on the XZ axis so back in code here instead of directly casting this down into a vector 3. let's construct a move to your vector similar to Vector three let's call it our move there for our move Direction and over here we construct a new vector3 and basically we're just going to assign the input y to the Zenon here so first of all for the X7 is correct so input vector.x then for the Y let's leave this one on zero and finally let's use the input vector.y as I said on the Move direction also now at this point you might be questioning if we're using a vector 3 here why don't we also use a vector 3 appear and then just assign the Z directly that's certainly a possibility and for making a super quick prototype I might even do that myself but the proper answer to that is once again all about writing good clean code the input logically only has two axes there's no zaxis on your keyboard so logically it makes no sense for the input to have three axes and beyond that you should keep the logic separate so you should first get the input and then actually move the object we're going to see the benefit of that separation when we refactor this code to work with the new input system doing that will in turn make enabling Gamepad joystick support super easy because we have the input Vector separated from the actual movement some of that to say and let's do things properly let's keep the input Vector separate from the movement Vector so we just translate the X Y onto X end and then we just apply this into our transform position okay so let's test so now if I press the right turn left and press W and S and there you go okay great so it is indeed moving Left Right forward and back okay great so it is working but as you can see it's moving insanely fast you might think the issue here is just applying some sort of movement speed multiplier except there's actually one sneaky issue here on the game view on the top right corner we've got a stats button and over here we can see a whole bunch of things specifically we can look at the frame rate we can see that it's running at 144 frames per second over here on the left side on this button I have vsync enabled this will cap the frame rate to the monitor's refresh rate so that is why I'm seeing 144 Hertz I can overhear disable vsync and the upload that goes all the way up to 700. basically now the game is running as fast as my computer can run it and if I press the movement keys and look at that now it's moving even faster now I've completely lost track of where my player is this is not what we want we don't want the player to move at different speeds depending on the frame rate we want it to always move at the same speed regardless of frame rate so when you do any kind of movement Logic on an update you always need to make sure to multiply by time dot Delta time what this variable contains is the number of seconds in Labs since the last frame for example let's unlock to this we no longer need the input Vector so let's unlock just the time that down to time okay so we can see there there's basically telling us how many seconds it is taking to render a single frame once again note how I have vsync enabled so I'm running at 144 frames per second and now if I disable it let's see what happens to that number so if I disable and you have a look at that that number is now much much smaller and the game is now running much much faster so by incorporating this value into our calculation we are going to be taking into account the frame rate thus making sure that movement is always frame rate independent right now with this frame rate if I move you can see I'm moving at this speed and now if I enable vsync change the frame rate and I move and I'm still moving at the exact same speed okay that's great except obviously it's not exactly great it's moving way too slow so let's also incorporate a movement speed now for this once again most beginner tutorials will teach you to go all the way up here and find a public float move speed maybe they found it to some villain like 7f something like that then you have this field and then down here you simply use it in the calculation so movement here move multiply it by move speed and by time dot time so this is what most tutorials will teach you by making it public up here what you're doing is you're enabling access from the editor so if you go over here in the editor over there on the player we can see the move speed variable we can see this exposed and we can modify it this makes it really easy for testing and for iterating upon the value even while the game is running so the game is playing I can move and I have this move speed now I can modify this and yep now I got a different move speed so I can use this to quickly to rate and find the perfect value so it's great to have this variable exposed in the editor and this feature is indeed the reason why most beginner tutorials will teach you to make it public it's so you can see it in the editor that is indeed a very valuable thing being able to easily iterate upon important values is always very useful however when you make something public when you do that you don't just expose the film to the editor you are exposing it to every other class in your entire code base so some other class could access this field and set the player's movement speed to something like zero and you would have no idea that was happening because the issue would not be on this code right here I have an entire video on this subject why you should not make everything public this is an extremely important topic to know about this one tiny change will massively improve the quality of your code definitely go ahead and watch that video to learn why such a bad thing and make sure you don't do it so to avoid all kinds of problems you should never make films public so very quickly the obvious alternative is make it private making it private means that only this class only the code in here only this can modify this film so you know for certain that no other class can ever modify this however making it private also means the editor cannot modify this film so we've lost our very useful iteration approach so what we can do to expose it just to the editor is to keep it private and then we add the attribute serialize field this way this field is still private meaning that it can only be modified by the code inside the player class but with this attribute over here in the editor yep we do have an editable field so only the code in that class in the editor can modify it nothing else can touch it nothing else can read or write which is exactly what we want one of the main rules in writing good clean code is minimizing complexity and one of the easier ways to minimize complexity is simply to minimize axis by making this feel private we are minimizing complexity because it doesn't matter how complex our game is maybe our code base is a thousand classes long it doesn't really matter because only this class can never touch this field so if we have a bug related movement speed we know for certain it has to be inside this code and nothing else so we minimize the things we need to keep in our head which is always a very good thing okay so with all that said we have our movement speed and down here we are incorporating it into our calculation just with this we have our character working with a variable movement speed and by using Delta time we have our movement correctly being frame rate independent so here's our character and using the keys I can walk around and yep the character moves in any direction so we have movement only working while using the Legacy input manager like I said we're going to learn how to refactor our code to use the new input system learning how to refactor is an extremely important skill to improve your own programming skills it is something that you should always do when necessary it will massively help you improve the quality of your code so we're going to do that but before we get to that let's actually do something a bit more fun and add some proper visuals and animations to our player in the next lecture hello and welcome I'm your code monkey in this lecture we're going to replace our boring capsule visual with a nice proper character mesh okay so in the included assets project files over here if we go inside the prefab visuals we see a nice player visual let's position it inside the player game object so let's drag it inside again because we separate the logic and visuals this is going to be pretty easy we don't need to modify the parent game object at all we just dropped the visualize this channel that's it also again very important make sure the visual is over here on low composition zero zero zero only the parent game object should move the visual itself should never move if you notice some weird positions as your player moves and rotates always check to make sure that the channel visual is on zero zero zero okay so with this let's delete the old capsule delete it okay so here we have a pretty simple but really nice character visual it's really just two spheres stacked on top of one another with a bunch of eyes very simple for the visual itself the material is using just a solid color so here it is inside the assets material you can see a bunch of player bodies with different color these different colors they won't be used in the upcoming multiplayer video basically each player will have a different color also by the way if you're a complete beginner here's a quick lecture on materials these are materials and if we call it select we can see a bunch of sets related to that material basically the materials have a Shader and then a bunch of properties now the Shader is the actual code that runs on the graphics card that says how an object should be rendered by default you have a whole bunch of included shaders we're using the universal render pipeline so you should mostly be using the ones inside the urp and by default you probably want to be using the standard light Shader then of course you can also build your own custom shaders one excellent tool for doing that is shade graph which I have covered in detail in a previous video it's a fully visual tool that you can use to make shaders without having to write any shutter code it's a great tool I've also made a bunch of tutorials on all kinds of effects you can make although right now we're not going to be using custom shaders we're going to do that later on the course but for now we're going to stick with default light Shader so materials have a combination of shaders and the properties on that Shader for example over here for the phone light sharing you can see that it has over here based map that has a counter field this is what you can change to apply a different color to your player also as to how you apply a material to an object over here on the player visual you can see the objects are made up of a sphere so this is the mesh and then the mesh render this is the one that has the material so both these are what stores the shape as well as the visual for the object the mesh is just a 3D shape but just by some of the mesh filter doesn't actually render anything so it needs a mesh render which needs a material attached to it so for example over here on the hierarching let's right click on empty space and let's create a brand new Cube just to see it so if there you go it does create an object and as you can see it has a mesh filter and a mesh render now to apply a different material you can click on this little circle icon and it shows you all the materials in that project alternatively you can grab the material directly from the project window so for example the player body just grab it and drop it in there or you can also drop the material over here on scene view as you can see as I Mouse over different objects it applies that material to a different object although note that only works over here on scene view it does not work on game view so this basically sets the material over there on the object right now one more very important thing on materials if you have multiple meshes only using the exact same material and then you modify the material it won't change the vision while all meshes using that material so for example if I modify the color here put it on something different there you go all three instances all three objects that are all using the exact same material they all update to the new color if for example you wanted the head to be a different color from the rest then you would just create new material so you can right click on the project window let's create a new material then you can give it a name give it colors use a different shade or whatever and then use this one for something different so that's pretty much the basics for materials and by the way if you're a complete beginner and you have questions remember to post them in the comments and I'll do my best to help like I said I want to keep this video moving I'm trying to teach as much as possible while still keeping the video reasonable length so if you need any further clarification on anything specific just go ahead and ask in the comments okay so when materials are out of the way here we have our player with visual let's just get rid of our Cube okay and just with this if we test and yep over here we already have a nice player visual walking around okay great except the player isn't actually rotating ideally the visual should be facing the walking direction so if I walk down it should be rotated to face down so let's have that doing that is actually going to be pretty simple let's go into our script here we are on the player script and over here we already have the movement Direction so we're going to use this in order to make sure to rotate the game object to face this move Direction and for rotating and transform there are many many ways to do it one obvious one is to modify the transform dot rotation however this one as you can see works with quaternions for me even though I've been doing Game Dev for over 10 years I still find quaternions quite a bit confusing so I normally don't use this method another method is to modify the transform dot Euler angles this one is much more intuitive and makes more sense to me it works with regular Euler angles which is much easier to understand if you don't know that name it really just means the angles that go from 0 to 360. then for another method you can also use the function transform Dot and look at this one makes a transform look at a certain point so it can be a transform Target can be a vector three for one position and anything like that so this is a very useful function we could calculate a point right in front of our move Direction and look at it or finally the method that I personally like to use for this specific purpose which is just modify the transform dot forward this one has the normalized vector representing the foreign axes and importantly you can get it and you can also set it so you have both read and write you can read it to get the current transform for it but you can also write to it to essentially rotate the transform so we can just assign this to our forward Vector also by the way you also have transform dot up and transform dot right both these work exactly the same way for example transforms are right this one is extremely useful for 2D games but over here we're working in 3D so we want to transform that forward and all we need is the forward Vector which is really just in move Direction so let's set this one equal Z move there okay so just like this it shouldn't really work let's also just clean up the log we already need to see the Delta time okay so let's see like this okay here we are and as I move and you better go and look at that the player object does indeed rotate to face the move Direction okay so it's already looking great all right awesome however it also looks a bit odd with how it's instant so I move left and right look at that it instantly rotates so there's no smoothing nothing it's way too janky so let's add some nice simple smoothing and for that let's use a really awesome really useful math function called lerp it helps you interpolate between two values I made a quick video showcasing a bunch of uses for it you can alert floats Vector 3s quaternions or just about anything it's really perfect for making some smooth movement or smooth rotation so for that we can access the function inside the vector 3 class so we can find an alert then here we actually have two options we've got learn this one interpolates and we've got slurp this one interpolates but with a spherical interpolation basically if you're dealing with rotations like what we have here then we want to be using slurp whereas if you're dealing with just positions and you want to use so here let's use slurp this one as you can see takes an a a b and a t like I said this interpolates between A and B based on T so for example if T is zero then it won't return the value a if T is one then it won't return to Value B if C is 0.5 then it won't return the point in between A and B if you want to learn some more about interpolation and the math behind this then I highly recommend you look at my video on splines splines are basically just a whole bunch of merps put together so anyways over here we can add some smoothing to our Rotation by just using the current transform.ford as our a then for the B this one is our Target so let's use the move there and finally 14 let's use time dot Delta time meaning that with this over time the character won't rotate towards our Target movement Direction so just with this let's test so here if I move to the right and you have a look at that it is indeed rotating it's way too slow but yep it is rotating smoothly all right so let's just add a bit more speed so over here let's just find a float for the rotate spin let's put it at some like 10f then we just multiply it to times that down time multiplied by our speed let's see and move any up there you go look at that much much better okay great so as you can see everything works as I move the character does rotate to face the move Direction all right great so here we have our character with a nice visual all rotating to face the move Direction now next step is we want to add some nice animation so let's do that in the next lecture hello and welcome I'm your code monkey in this lecture we're going to add some animations to our player character now I have already included some premade animations with a premade animator over here inside the Asus folder but let's first do it from scratch so you'll learn how to do it first to animate we're going to need the animator component if we go inside the player visual game object once again remember all the visuals go on the visual game object so for adding the animator component we want it on the visual and not on the logic component so anyways over here as you can see by default I already attach it with the assets included but let's do it from scratch so let's remove this by default now let's add a new component let's go on an animator also one very very important thing here it's the animator component not the animation component these QR can only difference the animation component this one is actually related to unity's Legacy animation system from a very long time ago it's only here pretty much for a backwards compatibility and for super simple use cases so most of the time make sure you're using the anime tour component okay so to drive this animator component we need an NM troller let's go into our project files and let's create and create a brand new animated control let's call this my player animator then let's select the player Visual and just drag the controller on there okay again if you have issues then you cannot drag the animator onto the film make sure you're using the animator and not the animation component okay so with this we have assigned our animator controller now let's double click on it to open the animated window and if you don't see it then go into window then go into animation and open up the animator window and also if you still don't see anything that maybe you might have some issues with your layout if that's the case then go on to the top right corner layout and go back into the default and then back into your own layout and finally if you still don't see anything on this window if you don't see defontes make sure you have the object selected in the hierarchy so with that you should be able to see these states so this is our animator controller now I have a really detailed overview of the animator and the animation windows in my ultimate unity overview course so you can go watch those lectures for some really indepth explanations about everything this does basically the animator is a state machine so you have various States and you can create transitions between each state by default you have these three special States there's the entry State exit and any state these are used for making transitions but we don't really need to worry about them just for now first let's just make a basic new animation and for that the easy way to do it is to open up the animation window so let's go up top into window go into animation and open up the animation window so here it is again that's a different window that's animation not anywhere and for me for this window I like to dock it down here so there's a nice timeline so I think this is good okay and now if we select the object in the hierarchy that has our animator then we can see the text here so to begin animating we've got a nice button to create an animation so let's go ahead and click on this and now let's give it a name for now let's first make the iPhone animation so let's just call this Idol and name just like that we have created an animation you can see the animation window down here has changed we now see a nice timeline showing the time and also on the animated controller you can see the new animation was added as a brand new state so a new state was created and if you click to select it on the right side in the inspector you see the motion so the actual animation selected and you can also see that there's an arrow pointing from the entry onto the unknown state so that means this one is going to be the default State when the animated controller starts it won't start playing right on this state let me just point out one more thing related to animations so on the project window we can see yep here is our animation that we just created and you can see the inspector unlocks just like this now if your inspector looks differently that might be because you accidentally created the Legacy animation that has to do with the previous animation system that I talked about the one that is Legacy that should really no longer be used so if you see a different inspector then a quick way to fix it is to click on these three dots on the inspector these three dots then you change the inspector into debug inspector and over here you see a toggle on foreign legacy so for the animations that we want to use right now we do not want to be using Legacy animations so make sure this one is untoggled if in our case is toggle just untoggle it then go back into the normal inspector and now yep it shouldn't look just like this okay so we have our animation and now it's on our animator controller now it's actually make an animation so let's select the animation window though and again let's make sure to select the objects and let's select the player visual game object so here on the animation window we see this nice little red button this one enables or disables recording so if you click on it you can see yep the timeline is now red meaning that we are now recording and now we can do anything to any channel objects and it won't record any changes we make now note what I said that's very important it needs to be challenged objects if you select for example the apparent game object then all of a sudden it stops recording so you can only animate child objects so let's select the player visual let's enable recording then let's expand the player visual let's make sure that our timeline is on zero so drag it all the way to the left and now for example let's grab the head object and let's move it just a tiny tiny bit basically just move it enough in order to make sure that the position over here is in red meaning that we have recorded a keyframe then let's drag the timeline by a little bit let's go over here to frame 30. this one is actually going to be half a second and soon to be that because over here on the samples this is the frame rate for the animation so at 6C that means we have 60 frames this makes one second so 30 frames would be half a second you can also zoom out by scrolling over here or dragging the handles down here so let's go into 30 half a second and on this one let's move the head by a little bit something like this as you can see down there we can note that I record the new keyframe and now if we hit on the play button we can preview the animation any upon like that that does do exactly that so it starts off down and then moves up okay so that's great but we don't want to snap back so let's actually add another keyframe right at the end so let's stop playing the animation and to make sure we have a perfect Loop let's just click to select the keyframe let's press Ctrl C then let's go down into the one second Mark let's press Ctrl V and there you go there's the exact same keyframe so now if we hit on play the other go we have our nice seamless Loop so the head goes up and down and repeats forever alright awesome okay so that's great now let's also do one thing let's also record a keyframe on the body however we don't want it to move at least not in this idle animation we just want to have a static keyframe so let's select the body and let me actually move it a bit to the side just to make sure to record and now manually we can modify things over here here to modify the actual keyframe data so on this one I don't want it to move so let's put it all the way back at zero just make sure we have a nice keyframe recording now the reason why we are recording the body position even without moving it is because the wonk animation will indeed move the body but when we get back to idle we want the body to go back to this exact position so that is why we need the keyframe here okay so that's done so we can stop recording so let's click on the red button again okay great by the way one more note to make sure that the animation Loops go into the project window and over here select the animation and make sure on Loop time is enabled it should be there by default okay so the animation is set up and if we unlock in the animator it's already the default set so if we hit point we should be able to see the anal animation playing nonstop so let's hit play and if there it is the anal animation with the head moving up and down everything works perfectly alright awesome okay so next up let's make a wonk animation now for me when making an animation that is based on another one I like to actually duplicate it instead of starting from scratch so over here on the project window let's select the anal animation and let's duplicate it so Ctrl D let's learn name this one to the wonk animation and now if we select the player Visual and then we go into the animation window over here we see a nice little drop down menu for all of the animations except right now we don't see the wonk animation we only see the idle animation that is because this menu only shows animations that are attached to the animator so first we need to add the animation onto the animator component and how we do that is actually super simple let's just open up the project window and just write the wonk animation and drop it here that's it so with this we have attached a new state to the animated controller and now if once again we select the object in the hierarchy go into the animation click the drop down menu any up now we do see the wonk animation so let's click to select this one and now for this one let's make the animation so let's look in scene View and make it bounce just up and down so I'm going to enable record go back here and for the body this one already has a keyframe so let's go up here move it a little bit and then copy the keyframe put it the same one at the end something like this so there you go just goes up and down once actually input it offsets it looks a bit better so something like this by the way in a bit we're going to replace these animations with the ones that I made previously so don't worry about making the animations perfect unless you want to do that okay so there you go that's the animation although for walking should be much faster so here's a quick animated tip this top bar here lets you select all of the keyframes within a certain time so if I click the select note how it selects both those keyframes and also if you click and drag once on top of here you can select multiple keyframes so for example to select everything just click and drag to select all of them and now you see these nice little vertical bars so if you click on those and then you drag them you can basically modify the time of all the animations and everything matches up so for example let's make this one super fast let's put it just 20 frames there you go now it's a much faster walking Mission okay great let's click on the right to stop recording all right and back in the animator so over here we have both animations and now what we need is to make a transition going from idle into wonk otherwise the wonk animation will never play so how we make a transition is also super simple let's right click on the I don't say let's make a transition then now we have a nice little arrow under the mouse and now if we go into the wonk and click on it there you go we have a nice transition now we can click on the transition itself to select it and over here in the inspector we see a bunch of transition options so let's expand the settings yep there you go everything now like I said I covered all of these options in a lot of detail in my ultimate TNT of recourse so if you want to learn more go watch that here on let's just learn the basics for how to achieve our goal and making a simple player animator the important one is over here the exit time basically if this one is toggled then this transition won't be triggered automatically meaning it won't play the outline Mission and immediately transition into the walk animation so for example if we hit play and look at it quickly if there go there's the idle any of transitions into wonk and now it stays there forever okay so that's good but not exactly what we want we want the Wonka mission to only play When the character is walking and when it stops we want to go back into the idle animation now for that we need to use animator parameters so back in our animator on the top left corner we see something called layers we don't need to worry about that for now and then next week we see parameters then we can click on the plus button or to create the brand new parameter and you can see all the various types that we can create now for wonky we want something that we can set to either true or false so let's go with a nice bullion and for name let's go with is wonky again pay very close attention to the capitalization this is extremely important just like code is walking is different from is walking so make sure the capitalization is perfect okay so with that we have our nice parameter now let's click on transition going from idling to wonk and now let's untick exit time we don't want this transition to trigger automatically and as soon as we do we see this nice little warning basically it's telling us that this transition will never happen so over here we have the nice conditions if we click on the plus icon we can add some conditions and for this one we want this transition to happen from idling to walk when the parameter is walking is set to true so that's it this is our transition now let you see the reverse so let's right click on the wall make Transition go back into Idol let's click the select transition get rid of the exit time and conditions when is Walking is set to false okay so just like this our basic animation logic should be working so let's test so here we are and the character is playing the online Mission by the way you can look at the end better while the game is running so let me just drag the animator window just drag it and put it on the side of the game view so we can see both at the same time okay great and right now note how it's not updating so there's nothing moving over here on the animated component that is because like I said you must select the object so on the hierarchy make sure you select the player Visual and you have there go now you do see that updating so make sure the object is selected in the hierarchy and over here we see a nice little progress bar showing the Adeline Mission constantly playing in looping okay great another important thing is over here the parameters you can manually change the state of these while the game is running so for example if I click it's going to trigger the is walking parameter which should trigger this transition and should go into one so if I click and if there go transitions into the wonk animation and now yep it is playing The Walking animation and if I click to untick it look at over there what happens untake and there you go transitions back into idle alright awesome so as you can see we have overall logic working we have the animator with both of our states and by changing this parameter we can change which animation is playing now of course the goal is not to trigger this manually by clicking on it but rather doing it through code but at least for now we know that our animator is fully set up again if you want more detail on the animator and animation windows and everything related to animations then check out those lectures in my ultimate TNT overview course and also later on for more advanced use cases I have video on the animation rigging package this one is for more advanced use cases for making Dynamic procedural animations it's really fun so definitely check it out but only after finishing this course that one is a much more advanced duel for now let's continue here so we want to trigger our parameter but do it through code and again here we have yet another clean code question technically we could add that code directly over here on the player script we could just grab the animator component and change the parameter and in this case for this very simple game that would actually not necessarily be a very bad approach since the game is so simple with so few animations but like I said I want to teach you proper good practices so let's make it properly and actually separate the animations from the logic for then let's go into our project right click in our scripts folder create a new csharp script let's come with the player animator let's select the player visual game object and attach the component okay so now here first let's grab the animator now one approach is like we've seen we could just make a serialized film and and drag the reference in the editor that's one approach or alternatively since the animator is attached to the same game object as this script then we can just do a get component both approaches are really valid so here let's use get component just to see a different approach so we just have a field for our animator so animator and then we just do a private void awake and then awake lets you get component of type animator and we set our animator variable again like I mentioned very important make sure you don't mix animator and animation these are two different components we want the animator okay so with this we have a reference to our end meta component and now how we modify the parameter is actually very simple we just access the animator and then we have a bunch of set functions you can see we have one for each type so we've got a set bone set float then down here a set trigger set Vector so function to set any parameter type now we made the Boolean so let's use the set bone and this one as you can see takes the name for the animator parameter by the way strings are a horrible horrible way of identifying things but suddenly this system really does require strings to identify the parameter we want to change change if you're wondering why strings are bad for identifying things the reason is because it's very easy to make a mistake for example if you use is walking here then this won't work however if you instead right is walking then all of a sudden does not work if your right is walking like this doesn't work like this doesn't work and even though it doesn't work it will also not throw any compiler errors that is because for the compiler a string is a string it's always valid but then when the code runs this one is going to be different than our parameter which is named exam like this always remember that strings are case sensitive so that's one reason why you should never use strings to identify things it's very very easy to make tons of mistakes that are then very difficult to find out but like I said in this animator system we have to use strings there's no other way in order to minimize our usage of strings one thing we can do is for example let's define a constant up here so let's make a private make it cons for a constant meaning this will never change make enough type string and conlet is wonky again refer back into the naming wrong section for constants we always use uppercase snake case so is walking and let's set it with is wonky again make sure you don't make a mistake here make sure you type it exam like you did on the animator then down here let's use is one and now if you do make a mistake so if we accidentally use something different now we do get a compound error so at least we have a little bit of protection okay so this one takes a string for the name and then a simple Boolean for the value so this is going to be the value that we want to set to our parameter now for this one we want to set to True when the player is walking and false when it's not so for that we need to ask the player what it's doing so let's go over here into our player class and let's make a function to return just that so let's make it public because we're going to access it from another script we're going to return a boom and call it is wonky now over here we just need to return if the player is walking so let's make a local field to store that saved so over here private bone is walking again note the capitalization for films we start with camel case whereas for functions we have Pascal case so these are different okay so basically in order to Define if we are working that's very simple it's just down here we have the movement Direction so we are walking if the move direction is different from Vector 3.0 which by the way Vector 3.0 is just a shorthand for writing zero zero zero so if the movement direction is different from zero then we are indeed walking so we Define that we update that film on every update and then over here we just return it okay just like this and now back in our player animated component over here first we need a reference to the player so let's add it here let's add a serialized film of type player and we need to compound this in order to drag the reference so let's just come without this line just make sure the code compounds now here with the code compound let's write the reference of our player okay that's it and then over here for the animator set is wonking let's go into the player and let's ask is walking and of course we don't want to do this just on awake we want to do it on every single frame so let's do a private void update and on update let's do this alright that's it so this should be working let's test so here we are starting off as Idle and as I move yep there you go it is playing The Walking animation and now if I stop and if there go back into idle alright Awesome everything does work perfectly okay great we can can even look at the animator to see the state change so here with both side aside and with the objects selected in the hierarchy right now you can see he's walking his phone so it's on idle and as I move that one stays true that one goes into wonk and now if I don't let go if there and go back into falls back into idle all right awesome so with this everything is working perfectly if you're having issues make sure you pay attention to the capitalization so make sure the name you wrote here is exactly the same one that you wrote here and it's exactly the same that you're using here alright so all of our animations are working perfectly now if you want you can go ahead and make your own animations or you can use the ones that I prebumped so in the included project files inside the assets here we've got the animations and we've got the player with the idol and the wonk animations if we double click on this don't look at it you can see yep it looks exactly the same so there's a parameter called is walking in our transition so everything is exactly the same just over here let's select the employer Visual and on the prefab like we saw we already have the animated component we just removed that one from the prefab in order to build it on from scratch but if you want to use my image then we can just go ahead remove the animator that we added and then right click on this one on the remove component let's revert back to changes and there you go here we have our animator with the player controller so that's the one in the animations and just like this if we had on play and actually over here I found an issue although in your case there shouldn't be any issue because I've updated the assets but this is a good time to teach you about any issues with animations so if you select the animation and you select the animation and over here you might see some of them in yellow saying missing basically the way that animations work is based on the actual name of the object if it cannot find an object with the exact same name then it cannot load the same animation so my problem is that when I initially made the assets package I made this animation and the object was previously named face and then I renamed it the head so now it normally loads so if you ever have problems with loading animations just make sure the name is perfectly matched so in my case I can just click in here in order to rename this keyframe on the animation and I'm just going to use the name that I renamed it so head and just like this yep the animation does play correctly so it's just a nice quick tip if you ever have problems with and missions always remember that the stored keyframes their own stored based on name so if you rename the thing in here or over here on the game object if you're in a name you're going to have missing animations but if you make sure the names match and the animation shouldn't work perfectly so let's hit on play and if there go there's the anal animation and if I move yep there's the nice wonk animation so everything still works perfectly because it's only using the exact same parameter alright awesome so like I said if you want film free to make your own animations or use the ones that I've included for me I'm going to be using these ones so the ones that we made just for learning which I created down here so the multiplier animator and these animations I'm just going to delete these just to keep the project clean so just delete and just like that okay so now there we have our character fully working let's quickly handle our camera hello and welcome I'm your code monkey in this lecture we're going to quickly install cinemachine this is a Unity tool that makes handling cameras super easy our game isn't really going to have a moving camera so this part isn't strictly necessary but same machine is a super useful tool so I definitely want you to learn about okay so let's begin by installing the package let's go into window open up the package manager then up top let's make sure we are in the UNT registry make sure you're on the all Tab and now just scroll down until you find yep there it is send machine okay so let's go ahead and install this all right Sunstone so let's close this and now the way that send machine works is by creating what is called a send machine virtual camera so let's go up top into the game object menu then scroll down into cinemachine and over here you can see that we can create a multitude of virtual camera types now just by the names you can see how this tool is insanely useful for example making a free download camera doing that from scratch is a bit tricky but with same machine it is super easy for our case like I said we want the absolute most basic thing possible so let's just create an empty virtual camera okay that's it this creates a virtual camera over here in the hierarchy and turn this object has the send machine virtual camera component and also importantly when we added this it also added over here on the main camera if we scroll down we can see it has a sin machine brain component basically the way send machine works is it works on top of the main camera so it doesn't replace it it works on top of it and drives the main camera so now that we're using send machine if we try modifying the main camera game object so there's one over here if I try to drag the field of view nope does not work I cannot move it if I try to move the position nope can't do it it if I try to rotate it nope that does not work like I said when working with cinemachine the sin machine brain is what drives the main camera so rather than modifying the things over here on the camera itself what we need to do is change them on the virtual camera so over here we have pretty much the exact same options that we have on the main camera for example modifying the fov over here we've got the lens so we can modify the fov and if we look in the game scene as we modify this one yep it does modify the actual properties on the actual main camera now this has tons and tons of options related to everything the most important ones are all kinds of options down here for the body and the aim so this is where the camera is positioned and where it's looking at using this you can make a funnel camera in five seconds it really is insanely useful if you want to learn about Sim machine in more detail I have a dedicated video on it I go through what all of these options do then I also have another super detailed video on how to make a camera system with pan Zoom scroll in both 2D and 3D and a bunch more features again all of it using send machine but in our case we really want to keep it simple so let's just position our virtual camera on the same settings that we had previously so for first let's set the film review so for a game we want something narrow so let's go with just 20. then for the position let's put it above so zero on the X then 21.5 on the Y and minus 21.3 on the Zen then for the rotation 46 on the X and then 0 on the others okay so our camera is positioned in the exact same position and if we head on 20 yep everything still works the same the camera is going from the same point of view and the character still works everything's still exactly the same now since we're using cinemachine we can easily add some things on top of this like for example we can add some noise to our scene machine camera to make it smoothly move a little bit this one is a fun simple effect that can make our game feel a bit more Dynamic especially in games like this where we have a fixed overhead view how we do that is over here on the scene Mission virtual camera we've got a film for noise so let's click and let's select basic multichannel purlin and then over here we've got the noise profile so we can choose one of the included ones or we can create our own profile so for example let's go with handheld normal mild and by the way you can actually modify these settings while the game is playing so here it is the game playing and you can see what this effect does it adds a nice little wobble to the camera and then over here at my student frequency so we can play around these so you can make it really intense so something like this that is way too intense so there you go quite a lot so for something more subtle maybe put 0.5 and 0.5 there you go just a slight little movement in the camera so this would help make the game a little bit more Dynamic so this could be a fun effect although actually in my case in order to make sure that the video doesn't get way too compressed I'm actually going to disable this on my end so just set the channel noise to none but you can see how easy it is to add complex camera features when using send machine and of course when using cinemachine if you want you can use it to make your game a lot more unique now for me I want to design here where the camera is fixed but let's say for example you wanted the camera to actually follow the player like I said you'll watch that dedicated video tool and learn all about cinemachine but over here very quickly let me just show you how to do that but at the same time don't bother following this part it's just to show what scene machine can do that I'm going to revert back to this state so first of all for testing one great thing about scene machine is you can have multiple virtual cameras you can have as many as you want and then the priority and the game object enabled state is what defines which camera is actually being used so for example on this second one let's make it follow the camera and put the priority on 20 so that it's above then over here for the body I'm going to select transposer let's put it with World space it requires a funnel Target so let me drag the player as the final Target and put it as slightly above and behind Okay so it's pretty similar as before then for the aim let me also drag the aim player Target and just with this it should already work so if I head on play if they're going to look at that the camera is now moving and following the player so I can move the player anywhere and yep the camera follows along so as you can see it's this simple to really make some complex camera movement doing some complex camera logic just like this would require a ton of work manually but with thin machine it is super easy then you can even play around with either priority or enable and disable and there you go see the machine even transitions between the state of only your virtual cameras so as you can see in lots and lots of things you can make with your camera very easily all thanks to cinemachine like I said in my case I just want the fix overhead camera so I'm just going to delete this secondary virtual camera and there you go just this one on top looking at the player and looking down with a low fov and Yep this is the exactly the kind of camera that I want for my game okay so that's in machine it's a really awesome tool for making camera handling much much easier so this was a quick lecture all about learning about Sin machine now let's handle the tests that was actually left and done quite a while ago let's finally learn how to refactor code and implement the new input system so let's do that in the next lecture hello and welcome I'm your code monkey in this lecture we're going to refactor our code from the Legacy input manager onto the new input system so the simpleton character controller that we made is working perfectly fine within Legacy input manager like I said this one is excellent for making quick prototypes and demos as you can see it's super easy to use but now let's quickly refactor this code to use the new input system instead also like I said in the beginning of this course here I'm going to be focused primarily on building this game so for example for any Unity tools that I use like the new input system I'm going to cover enough to be able to use a tool and Achieve our goals in building this game of course every tool does a lot more than just what we're going to use so definitely make sure to watch the dedicated videos Link in the description for example the input system tutorial is 40 minutes long covering everything you need to know about system whereas here we're just going to learn enough to know how to use it so let's refactor this code to make it work with new input system except before we work with new input system let's just refactor this code so we can completely decoup on the input from the player class again we want to focus on writing good clean code so we should keep all of our input logic in its own class that other scripts can access remember the goal with clean code is to minimize and manage complexity so every class should do one thing and just one thing meaning that the player class should only handle the player and then the input list should only handle the input the only reason why I put this over here in the beginning is exactly to teach you about refactoring and how it's a very common thing that you should be doing all the time this is exactly how I build my own games I start by making a prototype and I write the input directly inside the player class then at some point I refactor the code to split them up so don't be afraid to refactor code it's a Perfectly Natural part of the Game Dev process and actually a very very good thing okay so let's make a script just to manage our inputs let's make a new csharp script call this game input let's create an empty game object give it the same name input as always keep things lean so put it on zero zero zero let's attach the script and open okay so here's our script and let's get everything related to the inputs on the player for the input we are calculating the input Vector then getting the actual inputs from the keyboard and returning the input vector so let's put this on the other script so over here let's make a new function let's make it public since we want to access it from the player we're going to return a vector 2 and let's call it get movement vector now here let's really just copy paste the exact same code that we have on player so let's copy paste all of this let's go and paste it here okay so we get the input Vector we get the inputs we normalize it and then return the input vector okay so that's it super simple also by the way here we have an interesting question which is do we normalize the input over here or do we do it over here on the player both options can be valid you can make it so that the game unplug glass returns a regular input or you can make it return a normalized vector you can use either option but whatever you do make sure you are explicit so over here I am going to normalize input inside the game input class however I'm also going to make sure to rename this function so instead of get movement Vector get movement Vector normalize that way it is 100 clear this returns a movement Vector as a normalized vector okay great so now let's use this in our player over here in our player class we need some reference to our input class now later on in this course I'm going to teach you about the Singleton pattern but for now let's just do a simple direct reference again remember don't make it public make it a serialized film private so over here let's make a serialized film private of type game input and let's call it just game input okay so we have this we're going to drag it in the editor then over here we simply grab the vector 2 for the input Vector we simply go into this one and we get the movement vector normalized and okay that's it no more errors let's just make sure to save all of our scripts and back in the editor let's go into the player and just drag the reference for the game input okay so just like this everything should still work everything should work exactly the same as previously Let's test and make sure so here we are moving and yep everything still works I can move in any direction okay so far so good and what we have done here is essentially we have refactor our code and conveniently separate the input from the player class this is an excellent thing so again don't be afraid to refactor code also what we did here of putting the code in a separate class and then doing a quick test to make sure that everything soon works the same as previously this is exactly what you should do whenever you do some kind of reorganizational refactoring in the end you want to end up with the exact same behaviors previously just with the code organized in a different way okay so now that we have this separate game input class now we can very easily refactor the Legacy input manager onto the new input system so the first thing we need is to install the package so let's open up the package manager let's make sure up here we are in the ENT registry make sure we are in all and let's scroll down to find the input system so here it is let's go ahead and install okay the package is installed and right away we see this message basically it's asking us if we want to enable the new input system now you could click on yes but let's actually go ahead and click on no we're going to enable it manually so click on no then let's close this window and now let's go up here into edit then let's go into project settings then on the left side let's go into player and now let's scroll down expand over here the other settings tab and keep scrolling down until we see yep here it is the active input Henley this is where you can select which input system you're using basically if you click yes on that window it would automatically set this option to use the new input system so it would only enable that one and can only disable the unless input manager but like I said the lace input manager is still pretty useful so normally for me I prefer to enable both of them so let's go ahead click on both and this will restart the editor so okay let's go alright the editor has restarted so now the new input system is now enabled okay so the way that this system works is by creating something called an input actions asset so on the project files let's click on the plus icon let's create something and let's find the input actions so we need to scroll down here so click on the little arrow to go down and find the input actions creates this file let's call this the player input actions okay now let's go ahead and double click on it and yep there you go out pops out the input system window basically this one is where we're going to manage all of the settings for all of our inputs also by the way and like I've mentioned if you're watching this in the future and for some reason the input system got a new update and changed this window if so make sure you check the pinned comment I'll keep it updated with any changes on anything in this course so over here we've got the action Maps then we've got the actions and then we've got properties now action maps are how you can have different maps for example one action map would be for the player whilst walking normally and you could have another one whilst driving a vehicle then for the individual actions in each action map and finally the properties for each action again if you want to learn about the entire input system itself in more detail go ahead and watch my dedicated video on it in order for this course to not be 20 hours long I'm really only going to use enough to make sure that we can achieve our goal so over here we just need one action map so let's click on the plus icon let's name this the player and now for the actions right away we have a new action so let's just rename this one let's call this action move then with the section selected over here on the Action Properties we can select the action type again in the dedicated video I cover what all of these mean for movement we do not want a button we want movement in multiple directions so let's go with value then over here for the control type for this one let's go with the vector 2 and then let's expand our action over here we can see our bindings however we don't want this default binding so let's actually delete this one instead let's click on the plus icon and over here for the type first for the keyboard and let's go with this one up down left right composite so this one adds essentially four bindings let's go ahead and name this was then for the up let's select the bindings over here on the path let's click on it then we can either find it manually over here or click on the listen and I'll press the W button yep there you go W then for down let's go ahead and listen s then for the unless listen a and for the right let's listen d okay great so with this our input as it is correctly set up one thing you must never forget is up here make sure to save the asset you can see this little asterisk here that means we have unsafe changes also alternatively there's an auto save there but for now let's just manually save the acid okay great so now let's see how to actually use this in our code there are many ways we can use the input system one way is by using the builtin player input component so for example on the player we would add the player input so you could add this one attach and input actions asset so this is our player input actions then over here we have various behaviors in order to be able to trigger our actions but in this course like I said I'm going to be using the exact same code quality that I used in my own Steam games so I will not be using this component so let's remove this instead I won't be using the native csharp method so what's like the player input actions and over here on the inspector we see this nice toggle to generate a csharp class let's go ahead enable it and for these films we can leave them all on defense that's okay let's just go ahead click on apply and now it's going to generate those scripts and compound them okay great basically what this is doing is auto generating some csharp code and on the employer input actions we can see over here yep we've got the generate script if you want you can even open this to see all of the source code now all this like it says here this was all auto generated so don't make any modifications here if you change anything any manual changes won't be lost when you save some changes in the input asset so if you want go ahead and read through in order to see how all this works but in order to use it sectionally super simple you don't need to worry about this script first thing we need is to construct our script class that was Auto General so let's do it over here in our game input let's make a product void awake and on awake let's construct it so let's do a new player input actions so we construct an object of this time so we have this although just like this it won't be active so we need to manually activate whatever action map we want so let's go inside and let's go inside the player so this is the action map that we created and let's call enable one okay so just like this it's really already working all we need to do is modify our code over here on the yet movement Vector so for that we're going to need to access this so let's actually make this a member variable so private let's store it up here instead of making a local variable in here okay so we have this one and then down here on the input vector let's go inside the player input actions inside the player action map and then we called it move so we've got this one and then we defined it as a vector two so over here we can call read value and this one takes in the type of the value now we Define it as a vector two so let's read it as a vector two and just like this this returns a vector 2 which is really going to be our input Vector so let's put it exactly like this and we can now get rid of the rest of it all right so that's it and just like this we should already have everything working exactly the same as previously so let's just do a debug download just to make sure so let's test so here we are and the output is zero zero now I press W there you go plus one minus one left right and all of the ones in between all right awesome so we have the new input system all of it working flawlessly also by the way over here we can normalize the input just like we were doing previously so we do it over here through code or alternatively we can also go into the player input actions and over here there's something called a processor so you can go into this action add a processor and make it normalized so these processes here can be quite useful I cover the modeling detail in the other dedicated video but over here let's stick with making it through code that works just as well okay so that's our refactoring done with that simple change we are now using the new input system so you can see how by refactoring our code to make sure to use the game input less when we change from the input manager onto the new input system when we made that change we did not have to touch a player class at all the player class just has the game input to get the movement vector and does not care what system he uses to get them so here we have a very practical very excellent example of the power of writing good clean code because we separated things correctly we managed to change something completely and not have to make any changes on any other class so now that we're using the new input system let's just quickly see one of the main benefits of this system which is easily supporting gamepads and more keys for example a lot of people like using ones but some people also like to use the arrow keys with this system that is super easy to add so let's go into the move what's another one let's add another one up down left right composite let's call it arrow keys then let's just put them so let's listen on the up Arrow then over here we've got the down arrow then we have the left arrow and finally we have the right arrow alright so we've got all the arrows and now we don't even need to touch any code at all let's just make sure to save the ascent which again in turn that is going to Auto generate the csharp class and go into compound okay so we don't need to touch any code at all let's just hit on play and now if I move we're using the ones Keys yep still works and if I go into the arrow keys yep also still works alright great now for another one let's make it for a Gamepad so I just connected an Xbox controller and we can see over here on the log yep the game did identify it so this is the new input system in action let's once again open up the input actions and over here on the Move let's add another one and this time let's just make it a regular binding and over here on the path once again if we want we can go down here and specifically find some joysticks so you can find any of them or once again let's just use in listen now I'm just going to move the thumbstick on the controller yep there it is I know if you wanted you could go specific and make it just work with Xbox controllers or you can just use the generic left stick this will make it work with an Xbox controller or a PlayStation or really anything so let's go with this one and that's it nothing else we need to do let's just save the asset and that's it we don't need to touch any of our code to make our game playable with a controller so let's go ahead and test so here we are and first of all if I move the keys yep song Works move the arrow keys yep both of them works and now if I use my Gamepad any up there you go everything works perfectly alright awesome so as you can see this is one of the main benefits of the new input system it makes handling different inputs really super easily as you saw we didn't have to touch our code at all we just had new bindings and just like that our game is playable with all kinds of inputs so here you can really see just how powerful new input system is okay so with this our basic character movement is working great we can walk around everything looks great now in the next lecture let's apply some collisions to our player hey again here's another quick intermission I hope you've already learned a ton from the course have you seen the benefits of writing good clean code has the course already helped you understand some more advanced concepts I really hope the answer is yes to both those remember to follow the website page as you follow along I won't be adding frequently asked questions to every lecture if you ever get stuck you can just download the project files for a lecture and compare with your own and definitely check out the related videos when I reference them this course is focused on making this game but you should definitely learn more about some of these Concepts in more detail and you can learn that in the videos that I mentioned by the way if you're watching this right now this is the secret con loud so go ahead post the time step in the comments with a nice monk Emoji I want to see how many people make it this far okay so that's it for now let's go to the next lecture hello and welcome I'm your code monkey in this lecture we're going to apply some collisions to our player movement okay so here we have our game so far we have our player walking around and everything looks pretty good however now let's create over here in the hurricane let's right click create a brand new Cube so there you go let's place it over here and push it down okay there's the cube make it just a little bit bigger so there's the cube and by default it has a boxcon leather component so it has physics and the player if I move and nope there's our issue the player is going right through the object now the player is not meant to be a ghost so let's fix this over here in our player script we are hearing the input Vector calculating the move Direction and then just moving the transform so right now we're moving it no matter what now before we do that let's first do a test to see if any object is in the way and how we're going to do that is by firing a raycast this one is a physics operation that basically fires on laser from a certain point towards a certain direction and then tells you if it hits something how we do that is let's go inside the physics class and let's call the raycast function this one as you can see has many many versions of this function with all kinds of parameters let's use this one option number seven which takes a vector 3 for the origin a direction and a max distance so first for the origin that is from where we want to fire our recast let's put the player object in so that's transform dot position then for the direction this is going to be our move Direction so let's use our move there and finally for distance let's use some kind of player size player width something like that some lights to find up here a float for the player size and put that 0.7 units let's try out with the size just like this okay so basically this returns a Boolean it's going to return true if it hits something and funks if nothing is in the way so let's just do a bone call it can move and basically we can move if this raycast doesn't hit anything so we can move if this one is false so if the raycast is false then can move is going to be true that's very simple so if we can move then we move the transform position otherwise we don't okay that's it super simple Let's test so here we are I can move around and if I go towards the cube and nope no longer works so I can no longer go inside that Cube okay great now in your case if it's not working first of all make sure that the cube make sure it is touching the floor we use the transform position as the origin which is right on the floor so if the box is raised up then you won't be able to go through so make sure the cube is touching the form also make sure the cube has a box on leather component it can be any type of calendar but you if you made a cube then it should have a box layer by default and it should have the same shape as the visual and also remember that the 2D and the 3D physics systems those are completely separate they are completely different worlds so make sure you're using 3D components and not the 2D ones so for example if I add boxing weather 2D if I add this one then it will not work so make sure you're using the 3D and not the 2D components same thing over here on the script make sure you're using physics and not physics 2D also finally if you're still having issues make sure you check the player position again the player should be on a y of zero the only thing that might have an offset is the player Vision although if you're using the same acid me then this one should also be on a y of zero so all of these on y of zero and then you can also check the four by default this one has a mesh calendar but if it is exactly on yf0 with no rotation then it shouldn't cause any issues alternatively you can also just disable or remove the mesh con leather from before since we're not going to need that so with all that yep everything works I can move the player but I cannot go through solid objects alright awesome so it is working but for this particular use case a recast isn't necessarily the best method we should use basically Rick asses like I said kind of like a super thin laser but as you can see the player visually has an actual body shape so the visual and logic are using can only in different shapes if I go ahead and push towards the box you can see it works just fine however if the player is a bit more off to the side and the center of the player right in front of it is not the box and I move and yep there you go now I am going through the box the reason is because the erase accounts being fired from the center of the player and like I said it's kind of like an infinitely thin laser so it has no shape so as long as the center of the player is not hitting the box and it can go through it whereas what we really want is for the visual and logic to have pretty much the same shape so let's not use a raycast over here on the code instead of a recast we can use a physics query with an actual shape there are all kinds of casts you can use as you can see all of them with different shapes you've got a box cast if you want to have a box a capsule if you want the capsule or a sphere cast all of these were pretty much the exact same way except instead of a raycast which fires an infinitely thin laser these are going to have an actual shape and for player controllers for the most part you really want to be using a capsule cast that's usually the generally accepted player shape although alternatively a boxcast also can work very well in our case let's just go with a simple capsule cast this one to define a capsule has a 0.1 and a 0.2 by the way if you have no idea what is a capsule then we can go over here in the hurricane let's right click create a 3D object let's make it a capsule and there you go this is the capsule it's kind of like a stretch sphere so it has around the top round bottom and then over here in the middle it's just a cylinder and over here for the raycast takes a 0.1 and a 0.2 so that is going to be the bottom of the capsule and the top of the capsule basically with those two points we can Define the height of the actual capsule okay so let's just get rid of this capsule let's just lean it and over in the code let's put those now 4.1 it is indeed going to be the transformed opposition since that is the point at the bottom and for the second point for this one it's essentially going to be the player head so we can take the transform dot position so this is the bottom and we can essentially just lift it up so let's add a vector 3 dot up and multiply by some kind of player height let's define up here a float for the player height and I tested it in the editor and the player is about T and Stone so over here let's go ahead and move it up by that much okay so next we want the radius so this is pretty much the player size that we defined previously so let's use the same thing but as always let's make sure to write good clean code since now we are referring to a radius let's actually rename this to be a bit more clear and by the way here's a quick Visual Studio tip you can right click on a symbol and then you can click on the rename option alternatively use a shortcut Ctrl R control R if you do that then now you can change the name so for example on player radius and note how it changes every single instance of that variable so this renaming feature is extremely useful always make sure to rename something if you find the name that works best Okay so let's rename this to play radius then we have Direction so that is as usual going to be our move Direction and then finally we have the move distance for that we can use the actual move distance so that is going to be the movement speed multiplied by time dot all the time so I just find here a fluid for the move distance and you should see that just move speed time dot Delta time we have the move distance and we use it both in here as well as down here okay so here we have our cancel cast the rest logic is exactly the same so if this one is false that means it didn't hit anything so if it didn't hit anything then we can move and then we move the transform okay let's test and over here now if I go towards the box and the Epson works is only the same as previously that's great and now if I go towards the end and make sure that the center is not hitting the box and I try to move forward and nope now we no longer go inside the cube so even on the edges everything still works perfectly alright awesome so it works it looks good but it also is a little bit janky for example let's stretch this cube out a little bit so let's put it just on One Direction so stretches like this let's see now if I move towards it then nope I cannot go through it so that is correct and if I move left and right yep that's also correct that works however if I now press W and D at the same time in order to move diagonally and nope right now it does not move the reason is because the diagonal Vector that one is indeed hitting the collider but usually in games when you move diagonally and you cannot move in when Direction then it tries to essentially hug the wall and move around it so if I press wnd it should essentially be moving straight to the right so let's solve that so here in our code we're making our Capstone cast okay that's great then we need to test if we cannot move so let's see if we cannot move so it can move is false if so then that means we cannot move towards this direction and if we can then essentially we basically want to split the movement Direction and just move on the X or just on the Z so first let's attempt just the X movement so attempt only X movement let's create a new vector 3. let's call it move the year X and we make a new Vector three let's take in the move there dot X then zero on all the other so we only want the test moving in the X Direction and then let's do literally the same thing so let's get our can move try to move under this direction so let's go inside a move there move there on the X so we do that capsule cast and if we can move then that means we can move only on the xaxis so can move only on the X and if so let's set the move there equals the move there X so if we can move them down here when we use the move there we're going to move only on the X and if we cannot move then that means we cannot move only on the X and if so then let's attempt only Zed movement so over here again let's do the exact same thing so let's copy this let's just change this one so instead of move to your X we've got moved here on the Zen so over here we use 0 on the X 0 and Y and axis we moved here and get the Zen then let's use this movement Direction over there and finally the same thing so if we can move then that means we can move only on the Zen and let's set the move there equals the move there Z and if not then we cannot move in any direction okay so that's it now this might seem a bit confusing but it becomes a lot more clear When You See It In Action again remember the scenario we're trying to solve which is when moving diagonally so for example when we're moving forwards into the right if we do that then let's say this one is going to hit something so we cannot move so if we are trying to move both forwards and to the right then we're going to only attempt the X movement so we're only going to try moving to the right and then we're going to see yep going to the right that does work so we can move and we're going to move just to the right all right so let's test and see if all of this is working all right so here we are and if I move straight to the wall and nope there is 11 so I cannot move anymore okay great now if I move just left and just right and it does work now if I press W and then D and if there you go now it does hug the wall and continues to move same thing if I go on the left over here if I press D no I cannot go through it now if I press D and S at the same time and there you go it hugs the wall and moves around so now our controller is much more easy much more understandable okay so this is great now this is one of those tiny things that makes your character controller feel much more responsive so that's great however we also do see one more issue right now you can see that I'm right next to the wall and if I press A and D then look at that I'm moving with this spin however now if I press wnd look at that now I'm moving diagonally and it's actually moving slower basically this is the same issue that we saw previously where we had to normalize the input so we didn't go faster in diagonals basically now we have the opposite problem since we are normalizing the vector we are cutting down on the left right vector and with that basically if we are moving diagonally then we are essentially going slower whereas if I stop moving diagonal and just move left right it moves at a different speed that solution for this is really super simple over here in our code when we are constructing the move to your X and move the ears in when we do this very simple let's just normalize it so if this one is less than one then it won't be going into one so let's normalize that one and down okay that's it let's test and now from here move forward and hug the wall on left right yep does work and if I stop moving diagonally just going left right yep all still works with the exact same speed all right awesome okay so that's really it as you can see it's super simple to add Collision detection to your movement scripts you just do a physics query to testify our character should move and just move it by the way if you want to learn more about collisions and physics queries there's a bunch of interesting videos that you can watch for example one is on various methods of finding a Target then another one is on various methods of handling projectiles and finally another one is a very quick checklist on why collisions are not working basically there's lots of really interesting things you can do with physics so make sure you understand these functions okay so now that we have all of this working let's first just clean up our scene so over here our default Cube we don't want this so let's just get rid of this and with this we are ready to build our first kitchen counter and let's do that in the next lecture hello and welcome I'm your code monkey in this lecture we're going to begin building one of our main game mechanics we're going to make a kitchen counter and handle the logic for the player to be able to interact with that counter okay so let's begin by making our kitchen counter and just like we did when we made the player let's first make an empty game object and place the visual inside of it so let's right click on the hierarchy and create an empty game object call this the clear counter so it's going to be clear on top so we can place and pick up objects let's make sure to reset our transform so let's put it on zero zero zero let's move it just a little bit just so it's not exactly on top of the player okay now inside let's add the visual so let's go inside the assets folder and then over here we've got the prefabs visuals and inside we've got the counters visuals and over here let's find the clear counter Vision so let's go ahead and drag it inside the game object again make sure the challenge visual is on zero zero zero the unlockable position okay great now just like we did in the online lecture where we added Collision detection that shouldn't already be working by default but in order for it to work it needs a physics line either however note how the vision over here there's no collider and inside there's no collider there's only visuals again this is the same thing that relates to separating logic and visuals basically the visual prefab this one only has visual components so only meshes animations and that sort of thing and the main Parent Game object this is the one that is going to have all of the logic components set means any kind of scripts Behavior as well as any colliders so over here on the parent game object let's add new component let's find a box Collider again make sure you add a box of leather not a boxing leather 2D and I chose a boxing Ledges because this is the shape that makes most sense for our counter and now let's scale the boxing leather again that's the boxing ladder not the transform so leave that one with a scale of one one that's good and over here on the box leather for the size let's put it up with a size that fits the visual so 1.5 1.5 1.5 and finally we just need to lift it up a bit over here on the scene view you can see those little green tiny lines these refer to the boxing leather shape so let's lift it up by a little bit in order to make it perfect let's put it up by 0.5 on the Y alright so there you go that one does have the perfect shape if we test just like this it should already be working it's okay so here's my player and if I move towards it and yep there you go it does work so it is a solid object I cannot go through it okay great let's just visually rotate the calendar so let's do that and again for rotation let's make sure we rotate the apparent game object and not the visual we want the visual to be on rotation zero zero zero okay great so on the parent game object let's just rotate it around by the way here's a quick empty tap if you want to rotate hold down control and then click to rotate and now instead of rotating on every angle it goes on a 15 angle increment so just hold down this way you can easily get it to 180 degrees so it's just for fun just make it face the player okay great so now let's interact with this counter and doing this is actually super simple we already learned how to do a raycast to handle collisions and for interactions that's exactly the same thing so let's go into our player script and we're going to do a recast to handle that but before we do let's organize our code here let's make a proper function to handle our movement so let's make it private since this is going to be in local function return void and call it handle movement and then inside let's put all of this code so let's copy all this put it in there and then on update we simply call this function okay great and now let's make another function so private void let's call it handle interactions and we just call this function on our update okay great everything is much more organized so now here let's do a raycast so once again go inside physics do a raycast for the origin let's start on transform.position for this obviously we want the move Direction so an approach would be to make this a film variable sorted up here so that way we can access it in both functions however if you remember how we handled the whole issue with the diagonals basically we're modifying the move Direction so for moving diagonally then this one modifies to only move left or right we don't want that for the interaction we want pretty much the exact same one even if it's pointing towards a solid object so let's not make the same member variable only reuse it instead let's just grab it again create it again over here so we get it and we want this one even if it's pointing towards a solid object so let's use this as our move Direction and now for the distance let's define a fixed distance so something like two units would work and also here's another very important lesson with regards to writing good clean code so you would think to write code like this so let's put the two right in here that would work everything would work perfectly but then let's say you get back to this code after one week would you remember what this 2f means the answer is probably not you would probably very easily forget exactly what this means so because of that you should never use numbers directly in the code like this instead you can either make a field appear if you want to make it customizable or much simpler is actually what we already did previously so let's define a local variable with a proper name so let's define a float and this one is going to represent our interact distance so let's call it exactly that interact with the distance and let's put 2f and over here instead of using a number let's just use that variable now if we were to get back to this code after a long time it would be extremely clear what this parameter represents the technical term for what we did here is called Magic numbers and I've also covered them in detail in another quick video but as I always remember very simply never use magic numbers okay so with this we have our recast it's pointing forwards for this distance but this is actually not very useful because the rickhouse this one only returns a bullion so all this tells us is if there's something in front or not it does not actually get as the actual object reference so for that let's use a different version of the raycast function so as you can see we've got all kinds of versions in order to get the object reference let's use this version right here this one which has an out parameter for a raycast hit note the out keyword here this is important this means that this is an output parameter whereas the other parameters those are all essentially inputs that you give to the function whereas this output this is basically a value that the function outputs so let's use this so we've got the origin we've got Direction then we've got the rake asset in order to use it we need to make sure to write the out keyword here and then also very important we need to write the type so let's call it break asset and then the name so let's call it break asset basically what we're doing here is essentially defining a variable of this type with this name we're defining it and giving it to the function immediately so we can use it afterwards if you don't include the type if you just include the name then you get an error because this name Rick has said this was never defined alternatively you can Define it before you pass it in so over here you can do recast it recast it and just like this it works because you are defining it here and using it here but in order to make the code a bit more compact you can just Define it here in the same place where you get it okay so let's use this and with this the function still returns just a Boolean so just hit something or not but then we've got the rake asset output this will be filmed with data from the Collision if we do hit something we can inspect this to see what that it contains so you can right click on top of the type and then go to definition and up here we do see the definition for the rake acid struct you can see this is a structure to get information back from a raycast you can inspect this to see all of the kinds of things that this one returns for example you have a vector 3 point for the impact point in workspace where the ray actually had a collider it can get the normal of the surface and so on so you can get all kinds of things for a use case what we want is to identify the object that we hit and for that we can use the transform so it's going to be the transform of the rigid body or the collider that was hit so let's just do a quick test if we hit something lets you unlock on that object so let's do an if so if this one is true then that means we hit something so if so let's do a debug unlock go inside the rake asset and log the transform okay so like this we should be able to see on the console if we do hit something let's also do an ounce just to be able to easily see when we hit something so on else let's just log an empty Dash and in our game in order to make sure that our Collision is working that we are correctly detecting it let's just duplicate this object but before we do let's make this a proper prefab if you have an object of a certain tab that you want to create multiple instances of it you should be using a prefab rather than just duplicate an object that way with the prefab if you make any changes to that prefab it applies to all of the copies of that prefab so let's first make this one a prefab and again since this is our first prefab let's first make a nice folder to keep things organized so folder for our prefabs and to make game module prefab is super simple you just click and drag directly from the hierarchy and drop it inside the folder there you go there's our prefront and now let's just duplicate this make sure it has a different name so it has one so that's enough with this we should be able to see it just for testing let's put it just off to the side okay so let's see so here we are in the console we see a dash so by default we are not hitting anything okay so that makes sense now if I move towards this object and if there you go it does I didn't find that object and if I stop moving it stops identifying okay great now if I move towards this one and if there we go this is the one with the name of one and this is the one with the name of none all right awesome so just like this we are correctly identifying what object is in front except we also have an issue so if I move towards the object then yep it does work but if I stop moving once I'm still facing that object right now it's returning none now the reason for that is because of the move data that we're using here if we're not moving in any direction then basically this Vector won't be zero zero zero so we're going to be firing a raycast towards no direction at all so obviously it's not going to hit anything the solution to that is super simple we just need to keep track of the last interact move Direction so let's go up here to find a film for that so let's make a private let's make a vector 3 and call it the last interact Direction and then down here when we have our handle interaction so we get the movement here okay that's great so then we just check if the move direction is different from Vector 3.0 by the way this is a constant a shorthand for zero zero zero so if it is not zero then that means we are moving in some Direction so so let's set the unless in direct direction to this move Direction and basically if it is not if move there is zero then we are not going to modify this so this one is only going to contain the unless interact Direction and then down here instead of using the move Direction Let's just use this one so that way even when we stop moving we are still going to be using the last indirect Direction okay so with this let's test so here we are and if I move towards it yep it works and if I stop moving and yep it still works alright great so we can move towards it Point towards a certain object and then yep it still works okay great now let's actually interact with this counter and to do that let's make a class for the counters itself so let's make a new script in the UC sharp script let's come with the same name so clear counter okay there's our script now very importantly for attaching the script remember that we have two instances of our prefab if you just select it in the heart key and you just drag it on there if you do that then you're not actually adding this script to the prefab itself you're only adding it to this specific instance of that prefab so if you look at this one yep it has a script but this other one which is a copy of the same prefab this one does not have it also over here on the inspector you can see the little script icon has a nice little plus that means it is something that you are adding on top of the prefab so that means this script is not present on the base prefab basically this is not what we want we don't want just this object to have this script we want all instances of this prefab to have this script so instead let's get rid of this one from here we want to modify the prefab itself so one way to do that is to select the prefab on the project window so here it is the actual prefab and now we can drag the script on there so that works or another alternative is something like the prefab in the hierarchy and on the inspector over here we see a nice button to open the prefab and if we actually go into scene view then we can see what that does so with the object selected so this is an instance of that prefab but if we click on open then essentially we are opening and we are working inside the prefab so now if we make sure to add our script and let's go back outside this prefab so on the top left corner over here we can see where we are so we were inside our scene and then we are inside the clear counter prefab so if we click on the scenes we can go back now it tells us that we made some changes to the prefab so let's save them and if we add that script and we can see both instances of the prefab they both have the same script and we can see on there on the icon that this is not an override this is an actual script at on the base prefab so whenever working with prefabs always make very sure that you are adding it on the right place if you want something on the base prefab make sure you either add it on the prefab itself or go inside the prefab by double clicking on it or select an instance in there and open to go inside the prefab so always keep in mind different switches between a prefab and an instance of a prefab okay so we have our script let's open it and over here let's just make one super simple function so let's make it public because we want to call this from our player class let's return void and just call it interact okay that's it super simple for now let's just do a debug.log and just say interact okay so that's it and now over here on the player when we have our handle interactions function so interact we do our raycast and we find out if we hit something so when we do the first thing that we should do is identify what this transform is so is this something just like a dumb Cube or is it an actual counter now when it comes to identifying things this is another place where a lot of beginner tutorials will teach you to use the unity attack system so that's over here in the editor when you select any object over here in the inspector you can see a tag so you can see untagged and you can add all kinds of tags this is something that a lot of beginner tutorials teach but Unity tags are horrible you should never never use them I covered in more detail why that is in the advanced concepts video the main reason is because of well pretty much the same thing that I mentioned a while ago when we were handling animator parameters so you were doing this and I talked about how this one takes a string and how strings are horrible way for identifying objects they are very brittle very error prone it's very easy to make mistakes and tags have the exact same problems because tags are strings so we do not want to use tags to identify objects instead over here on the player script let's use a different method for identifying objects and the best way to do that is to Simply get our counter component so we have our transform and then from inside that transform we can call the function try get component this one then takes the type of component and again note how this is an out parameter so let's put out and we want to test if this is a type clear counter so clear counter and call it clear counter and this one basically does the same thing as a recast so it returns a Boolean so either true or false so if this one is true then that means that object has that component so over here we know has clear counter by the way if you're not familiar with tryget component this is pretty much the same thing as the regular get component except it automatically handles the null check for you so if we just did this it's exactly the same thing as this so you do an if recast it what's X is a transform get component component of type clear counter naturally this one is not inside now but let's store this well your counter equals this then you do if this one is not known then we know has a clear counter so basically what we have up here is the exact same thing that we have down here so just using trigate component it's just a bit more Compact and I find much easier to read than to always get component and test if it is not null over here we just have one function with a nice out parameter and everything works perfectly so that's the try get component I much prefer that method so let's use that by the way on the trackit component over here you can see it has a type inside some angle brackets basically these are called csharp generics these are an extremely powerful csharp tool I have a dedicated video on them and I've used them in tons of videos definitely go ahead and learn about them basically this lets you write code that works with many classes not just one specific type in this case the target component can work with any type of component so it can be Unity builtin components or it can be components that you made yourself then if it finds a type it returns true so for right now it's not strictly necessary to know the specifics about how csharp generics work but definitely make sure you add that video to your queue and watch it afterwards csharp generics are an extremely useful csharp feature okay so we do this and basically if we are inside of here then we know this object has a clear counter and we have our clear counter reference so over here it's super simple let's just call the interact function alright so that's really it let's just get ready else we no longer want that log so we should be able to see unlock whenever we call our interact in a counter alright so here we are and if I move around okay that's good over here the console is empty all right now if I move towards the counter if there you go I'm interacting with it and if I move towards this one if there you go interacting all right great so with this we are correctly identifying the object and interacting with it now let's just do one final thing over here we are doing a recast to find the counter and right now we are doing a raycast towards any object that has any kind of physics calendar so maybe that's our counter or maybe just a random wall for example if we had an invisible wall in front of our counter then this code would not work that's because this raycast and this raycast set it only Returns the very first object that it does hit so if the counter was behind the wall then the brake acid object here would be a reference to that long object perhaps that's what you want or perhaps not in that scenario one thing you can do is instead of using recast you can use the function raycast all and difference for this one is instead of returning just a Boeing just true or false instead it returns an array of all of the objects that it hit with that raycast then you could cycle through them and identify the object so that's one approach or another option is over here on the recast if we look at these function versions We can see that some of them has what it's called a layer mask basically you can set a certain game object to a specific layer and then if you're using layer mask then you can make sure this recast will only hit objects within that layer anything not on that layer will be ignored for that recast this is super useful so let's learn how it works for layer mask we can go up here and Define a type of layer mask so let's make another serialized field private let's make it of type layer mask let's call it the counters layer mask okay so we have this and then down here when we have our recast let's use it so let's find the function that matches up these parameters with the layer mask so here it is we have the origin then we have Direction Drake acid the max distance and then finally we have our layer mask and let's use our counters layer mask okay great now back in the editor let's select our player game object and yep there we see our field of type layer mask and you can see how we can select all kinds of layers and how we set these layers to an object is let's just select our clear counter although again we want to make sure that this change applies to all encounters not just this one specific instance so let's go inside the prefab and over here we've got a Film Forum layer and you can see we've got a bunch of default layers and then we can add some more so let's add some layers and over here let's go to the first empty one and let's call it counters okay we've added the layers so let's go back select our object and now on the layer let's put it on the counters now it asks you if you want to modify the layer for all Channel objects now since we made sure to keep the Dean logic and physics components only on the parent object let's just modify this one and leave the other ones on the default so let's just modify this object only okay so with that our counter is now on the counters layer let's leave the prefab make sure to save it okay great and now if we go back into the player and over here on the counters layer mask yep we do see the counters layer so let's just click the selected by the way this drop down menu can actually select multiple so you can select all kinds of layers so this is multiselect but we only want to counter so only like this and just like this if we do test and if I move towards it and if there you go get the nice interact on both them so everything still works is only the same but now if we had another physics on leather in front of it it would still work because we're using a layer mask to only recast against counter objects alright great now I should point out another way to work with layers is with something called a bit mask that's a bit more advanced usually the layer mask is much easier to follow but if you want to learn about bitmask go ahead and watch that video and also another quick note in this game we're only going to interact with one single object type it's only going to be a counter even though we're going to have multiple types of counters but for games where you want to interact with multiple objects like for example having an interact action to talk with an NPC another one to open a door or push a button for those kinds of multiple interactions to build the system like that make sure you look into my how to interact with objects video it covers how to do all of that how to interact with all kinds of objects it's all based on csharp interfaces which we're actually going to use in a few lectures and also have a dedicated video on that topic so keep following this course but then make sure to watch those videos add them to your watch list and make sure you do watch them watch out how to interact video it is something that is necessary in so many games and most tutorials don't actually teach you the correct way of doing it anyway so back in our game we are correctly identifying and interacting with each counter but obviously we don't want to interact automatically just like this instead we want to press a nice button to interact so that means we're going to need to create an interact input action so let's do all of that in the next lecture hello and welcome I'm your code monkey in this lecture we're going to create a proper interact input action and in doing so we're also going to learn about a very powerful and csharp feature called events okay so here we have our game so we have the player and if we move towards the counter yep we are correctly identifying it and interacting with it except of course we don't want the interaction to happen automatically it should be on a player input so let's make our interact action let's go inside our player input action so let's double click on it and let's make a brand new action so we've got to move and now we're going to have another one so let's click on the plus icon for this one let's call it interact and for this one action type we do want it to be a button okay great then on the default binding let's go into path let's listen and by default let's bind it to the E key just like so many games so let's go ahead select this one and once again let's make sure to save the asset and let the C sharp OS be generated okay and over here in our game input script in order to listen that is very simple so we go inside the player input actions then inside the player action map and then we can find the interact action and then over here we can see a whole bunch of events that we can interact with we've got these three cancel performed and started these are the three phases of every input again I cover these stages in detail in the input system video the important thing is that these are csharp events which I also covered in another dedicated video essentially they are a way for how you can write code to then get notified when something happens rather than running code on every single update constantly testing something for example over here on the movement movement is a preconstant action so it does make sense to ask the input on every single update if any movement is pressed but for an action like the interact the player is only going to press that say once every five seconds so it makes no sense to constantly check for that action on every single update instead we just want to be notified when that action is triggered and that is exactly what an event does again watch the dedicated video to learn all about csharp events in detail they are insanely powerful and we won't be using them more and more as we go through this course for now here are the absolute Basics events have Publishers and subscribers the publisher creates and fires the event when something happens and the subscriber listens that event and gets the enlisting function called when the event is fired now on the generated csharp class we've got these three events the one that we want for this case is the performed event so let's go into this one and basically we want to add a listener to that event and we can subscribe to that by doing plus equals so this assigns a listener to that event and now Visual Studio has a nice shortcut so if we press on Tab if there go it automatically creates a function now if you're not using visual studio you can just manually write this function the only thing you need to make sure is that the function signature personally matches the event signature as usual we can inspect the event so we can right click on it and go to the definition and up here is the definition and you can see that this is an event of type action with a combat context action is what is called a dungit I also have a video on delegates if you want to learn more about them in detail for now we don't really need to worry about what is delegate we just need to use it so in order to subscribe to the event we need to make sure that this one returns voyne because an action returns void and needs to have a parameter of this type combat context if I erase this parameter if there go now we have an error because the function signature does not match so it always needs to match the exact same signature okay and also one more note over here when subscribing to the event make sure you only add the function name meaning you do not add parentheses we do not want to count function we just want to pass in the function itself as a reference okay so now when the player presses the interact action it's going to fire off this event which in turn will call this function so over here let's do a debug download just see what this contains for example let's print out the compact context okay so let's see so here we are and if I press on E if there you go I've got a nice event okay great so with this we know when the player presses the key now the next step is how do we get the player class how do we get this one to know when this is performed and the answer is we're going to do the exact same thing we're going to make an event over here on the game input class and the player won't listen to that which in turn the game input grabs from the input system again the home point is separating our concerns so the player does not care about the input system does not care about the interact action it only wants to know when something related to interact happens so over here let's make that nice event first of all let's make it public because we want the player to access it then we need to add the event keyword next we add the donkey type like I said you can learn more about delegates in my dedicated video you can create your own custom Delegate for your event or you can just follow the csharp standard and just use the standard event handler and this one exists inside system so let's make sure to go up here and add using system and this one has the event handler class this one is pretty much easy sharp standard for events as you can see it returns void it has an object for the sender and an event RX parameter like I mentioned in the events video you are not forced to use this target you can use whatever delegate you want like for example you saw that the performed uses an action delegate so you can use anything you want to choose that the event handler is the csharp standard so it's easier to follow unless you have a specific reason to deviate from the standard you should probably use this one so let's use this and then finally for the name usually you start the name with on and then whatever happened so in our case let's go with on interact action okay so we have defined our event and now for firing it let's go down here into when we have the interact performed and let's go into the event and for finding it it's pretty much exactly the same thing as calling a regular function so we just call it with parentheses then usually for the object sender this is a reference to whoever is sending this event so usually the this keyword and then for the event RX this is in case you want to send some arguments with the event in our case we don't really need to send any extra data for this one just firing the event is going to be enough so for that we can use the constant event RX dot empty okay so that's it with this we are firing an event except just like this we're actually going to have one potential error if we have no subscribers no listeners to this event then essentially this field won't be known so this one over here is going to trigger a nonreference exception let's do a quick test just to see this happening so here if I press on E if there go we have a null reference exception so when working with events you need to first test if there are any listeners and only then do you actually trigger the event so you do if this one is not null if it is not known that means there are some subscribers so we can fire the event so like this it won't work but there's an even more compact way to do this which is perfect for events so instead of this we've got our on interact action then we can add a question mark this is called the nonconditional operator basically the code is going to execute from left to right and then when it gets to this question mark it's going to evaluate the left side and if it is null then the execution won't stop right here on the question mark and will not throw any errors whereas if this one is not null then it continues executing to the right except with this syntax we have an error We cannot put parentheses directly after the question mark but what we can do is simply just call invoke and that does the exact same thing that console function so what we have here is exactly the same thing that we had previously so what we have over here and over here these are the exact same thing it's just this one is much nice much more Compact and especially for events this one is super useful okay so with this we are correctly firing for our event now let's actually listen to it so let's go over here into the player class and let's listen to our event let's do it on a private void start make it on start not an awake this is a very important rule which I'm actually going to cover in detail in the next lecture but for now just make sure to listen on start and not on awake so over here we access the game input then let's access the on interact action event and as usual let's listen to it so let's use press tab to listen to it so it is exactly over here that we want to run our interact code so let's go down into the handle interaction code that we had previously so this one so let's copy paste all this code put it up here so we get the interaction going to the object and Trigger the interact now obviously code duplication is a big NoNo so we're only duplicating our code just for a quick test just make sure it works once again refactoring is super useful so we're going to refactor this code to get rid of code duplication in the next lecture but for now we just want to test to make sure that this does work so let's just remove the interact over here from the handle interactions so the only interact function being called is over here when we have our actual input so let's test and see if we can press to interact with the counter alright so here we are and as I move around if I approach a counter yep there you go we no longer have the automated interaction and now if I'm facing the counter and I press the enter I key if there go here we have our nice interaction all right awesome so I can approach I can interact and do whatever I want alright so here we learned about csharp events these are super powerful so if this is the first time you're hearing about them then you've just had an awesome new tool to your tone box definitely make sure you watch my dedicated video to learn about them in more detail events are super useful the next thing we're going to need is just a visual to highlight the current selected counter so let's do that in the next lecture hello and welcome I'm your code monkey in this lecture we're going to add a visual to our selected counter and in doing so we're also going to learn about the very useful Singleton pattern okay so over here we already have the logic to identify the counter in front of the player and we can interact with it however once the logic works there is no visual indicator at all so let's add that now as usual the super quick and dirty way of doing it would be pretty simple over here on the player script we could just directly enable a visual mesh on the target counter so down here on the handle interaction when we have this over here we can tell the clear counter to enable some kind of visual technically that would work but that would be some pretty dirty code we would basically be making the player responsible for enabling some kind of visual which would mean that we were mixing logic with visuals again we always want to try separating the logic from the visuals as much as possible to keep our code nice and organized so instead of doing the quick and dirty route let's do it properly back in the editor let's create a brand new csharp script call this the selected counter visual and now let's go into the prefab again let's go inside it so let's select the clear counter on the hierarchy then on the inspector let's open up go inside the prefab and now let's select the visual inside it and let's duplicate this so you can press Ctrl D to duplicate it let's name this when it's selected and then inside there's a visual with a mesh filter and a mesh render so over here let's swap out the material so let's click on the circle icon and now included in the assets is this material counter selected so it's all the way yep up here the counter selected basically it's just a solid white color within low Alpha so on the kitchen counter inside the sunlight game object let's make sure to use this one with this we have kind of like a ghost visual so if we enable and disable this game object we can see the difference Also let's do one tiny thing which is right now we duplicated the actual visual meaning that these objects are exactly the same they have the exact same size and when that happens you might end up with some rendering bugs if two meshes are on the exact same position you might sometimes see the colors constantly flip back and forth so in order to make sure that doesn't happen let's make this one deselected a tiny tiny bit bigger so over here with the selected game object selected on the inspector over here we've got the scale and also we've got this nice little button here if it's like this then we can modify each proportion differently from one another whereas if we click now these are all linked so now I'm modifying one will modify all of them so let's put this on 1.01 meaning this one is going to be literally just one percent bigger so that's enough of a difference to make sure we don't have any rendering bugs and by default let's also start with the visual hidden so let's do that not on the parent select game object but rather on the kitchen counter inside of it let's make sure to disable this game object by the way the quick shortcut is shift alt and a you can enable or disable the object very useful so let's start with this one disabled so that it's hidden and basically the goal is that when this counter is selected we're going to enable it and show this Visual and when it's not selected we're going to disable it okay so over here on the selected let's add the script that we made so these selected comes revision all right so let's open it now here first thing we need to know is know which counter is selected meaning we need to know which counter the player is currently looking at so let's go over here onto the player script and let's basically just do some simple logic to keep track of the selected counter so over here let's make a field so a private let's make it a type clear counter and just come with the selected counter then down here we have our handle interactions logic okay so we do all of this we try to find the counter in front and if we do find it then we have it here so here on let's just check if it's different so if this clear counter if the one in front is different from the current selected then let's set the selected to this one and let's also make sure to essentially unselect so we want to make sure to set this one to know when there's nothing in front of the player so if the raycast does not hit anything then there is nothing in front of the player so let's set this like the counter back into null and also if there is something but that something does not have the clear counter script then it's also not a counter so over here let's also do an else selected counter equals no so basically if there's a counter in from the player then it's going to set it if not then it's going to be no let's just do a simple debug download to check on the selected counter okay and also just briefly now that we've made this selected counter logic actually up here when we have our interact action like we saw we were previously copying some duplicated code but now we no longer need this since we already know the selected counter so over here when we've got the interact action let's just check if we do have a selected counter so if it is not null if so then we go there and we call the interact function so that's it we no longer need all of this logic okay that's great so let's test back in the editor and let's go back into scenes let's make sure to save the prefab make sure the script was attached save it and let's hit on play and right now if I'm down here yep there you go we've got null and as I approach if there go that one is a clear counter and if I move towards this one yep it's that one okay so basically we are keeping track of the kernel selected counter now basically we just need to notify the visual whenever this one changes so when this one is pointing at that one or pointing at no or pointing at that one we need to know when that happens and for that we basically have two options now one option is pretty much what I mentioned a while ago which is over here we have the selected counter so we can run some kind of logic on the sunlight counter we can do that over here on the player then perhaps over here the counter would fire off some kind of event saying it has been selected and then the counter visual would listen to that event and update itself now that approach would be useful if we wanted to add some kind of logic on the clear counter while selected and that approach would also have the benefit where the visual encounter would only listen to events on its own counter so that's one approach pretty much a very direct approach but another one is very simple the player would simply fire off an event whenever the selected counter changes and then all of the counter visuals would listen to that event then they would identify if the event relates to that counter and if so update their state now the benefit of this approach is that the logic doesn't get bothered with any selection logic so over here the clear counter script never really knows if it's light or not and that's a good thing because it doesn't need to know although the potential con with that approach is that all of these selected countervisions are only going to listen to the same event so both approaches have pros and cons here on let's go with the second approach where all the counters listen to a player event the potential performance con doesn't really matter on a game of this scale we're only going to have about a dozen counters so even if 11 of them are just wasting on listening to the event it's really not going to matter and going in with this approach will actually help us learn about the Singleton pattern which is extremely useful so first let's go over here onto the player class and let's make the event that we're going to fire so as usual let's make it public so we can access it let's make it an event and as usual let's also use the standard event handler let's make sure to add using system so here Visual Studio adds it automatically okay then let's call this on selected counter changed also this is a great moment to learn about the event arcs this is how you can extend a csharp event in order to pass in some more data so how you do it by following the csharp standard is very simple we just create a class so over here let's make a public class then for name usually you include the name of the event with eventars at the end so in this case on selected counter changed and then event arcs then on this class we make it extend event arcs and finally inside the class we add whatever that we want like for example we want the current selected counter so let's make a public clear counter and put the selected counter okay so we have this nice event arcs with a bunch of extra data and then over here on the event handler we use the version that takes a generic and we pass in our event arcs again I covered the generics in more detail in a separate video definitely go watch that one if you haven't seen it yet csharp generics are one of csharp's most powerful features okay great so we now have our nice event now let's fire it off so let's go down here to when we're modifying the selected counter so here it is we've got all of these ones so when we modify let's fire off the event so we go into this event and as usual let's use the question mark and then call invoke then for the object sender it's going to be this so pretty much is centered and then for our custom eventarics let's construct an object of that type so construct a new object and then inside we pass in the selected counter and we set it to this selected counter now don't be confused by the fact that we're using the exact same name if you actually Mouse over the cursor Visual Studio actually helps you by telling you which object refers to this so with the cursor here note how all of these are highlighted but this one is not highlighted that's because this field this is the film inside the unselected counter change event RX whereas this one out here is the object that we're referencing in here so even though these two have the exact same name here we're accessing the film inside of that and we're assigning it to the reference that we have down here okay so that's really it we're firing off the event when the selected changes and we're passing it in and let's also make sure to do it over here so let's copy and paste some code and there you go just like this except of course we can already see a bunch of code duplication usually that means it's time to refactor so let's do that pretty quickly let's go down and make a brand new function so let's make a private Droid let's call it set selected counter and we're going to receive a clear counter for the selected counter then over here we just set this dot selected counter so we're modifying the member variable with the one that we receive on the parameter and then let's also fire off the event so let's copy paste the event just like this the exact same thing okay so that's it and now up there instead of code duplication we just do this so over here we set the clear counter just call the function pass in that one and get rid of this and on that one just pass a null just like this get rid of all this and here the same thing just pass in no alright so with this our code is much cleaner and everything still works is all the same so here we have everything done on the player side let's just get rid of unlock we know we need this so we're still handling the selected counter logic and then down here we're firing off the event now we need to do is go over here into the selected counter visual script and here what we want to do is to listen to that event in order to do that we need a reference to the player object now so far when we've been listening to events like for example any player class up here we were listening to some events on the game input so there you go the uninteract action so for the game input reference we just added as a serialized field we did this and then we drag the reference directly and technically we could do the same thing over here on the sound like the counter visual but we're going to have like a dozen counters in our map so it would be pretty tedious to drag and drop the play reference to every single one of them so instead of using a serialized field another approach is to use the Singleton pattern this one is an extremely useful programming pattern it's very useful for things where you only have one instance of something in this case we're making this game single players so we're only ever going to have a single player by the way here's one obvious quick note like I mentioned in the beginning of this course after this video there's going to be another one converting this game into multiplayer and in that case we will have multiple player instances but this is also an excellent reminder of how refactoring code is perfectly fine for right now for this game it is intended as single player so for now we're going to use the Singleton pattern then in the future when we convert this to multiplayer we won't simply refactor that logic again don't be afraid of refactoring code it's a Perfectly Natural part of programming and game development okay so let's implement the single note pattern this is actually super simple the name sounds intimidating but it really is very simple over here on the player script let's make a public field this one let's make it static if you don't know static basically it means that this film belongs to the player class itself and not to any instance of a player so for example if you had a hundred players you would have a hundred instances of moose mean you would have one for each player but there would only be a single static film because this static film belongs to the class itself and not to any instance so let's make a field of Thai player and then for the name the convention is to call it instance and the reason why I'm using Pascal case here so capitalized in the beginning the reason for that is because this is actually not going to be a film but instead it's going to be a property remember the naming rooms that we covered in the beginning of this course it's very important you follow your naming rules always be consistent so your code is easier to understand so with that said since this is the first time we're using a property let me quickly explain what it is basically it's the exact same thing as a regular variable except you can add some logic when getting and setting that field so here let me write some quick code just to show difference between a property and a regular field so for a regular field you would call this maybe instance field something like this so this is a regular field then you would have some kind of public static return the player and call it get instance field then over here you would return the instance field and then maybe another public static void set instance field where you receive a player for the instance field and you would set the player that instance film into this instance field so this is how you do this logic with fields and now with properties you would do public static Flair then call it instance then on the property itself you open up the currently brackets inside the property you put a get then you return something so for that something usually a property has a field underneath it so you'd have a private static player for the instance that's a different name from this one on the get you would return that and on the set you would set the instance equals z value if you're confused here don't worry basically I'm just repeating just so you can see difference here we have a field with a get and a set function so regular functions and up here we have a property and inside the property the property itself has a get and set functions which can also do some logic so you can do some logic in between or you can just return the underlying value so basically using your property is pretty much the exact same thing as using a separate get and set function also one more bonus thing which is that csharp is smart enough to automatically create the underlying film for a certain property so if you just want to do a get and a set then you don't need to Define all this you can just Define a property and then inside you can just do get and set and there you go this code here works the exact same thing as we had previously which in turn is the exact same thing as all the code we have here with the getter and a Setter function so here it is a valid functional csharp property now I have to say that personally I very very rarely use properties in fact the only place where I use them is over here on the Singleton pattern for everything else I normally use regular films with get and set functions personally that's just the way that I like to code but that's really just personal preference so if you don't like to use properties then go ahead and use them anyway so the reason why I like using a property specifically for the single pattern is because the implicit implementation allows you to do something really nice again remember to go on with clean code we want to minimize complexity and the best way to do that is minimize access here if we set this property and we set it as public then that means that any other class can both get and set so anyone else can have both read and write access so we have the exact same problems that I warned you about when I spoke about why you should not make everything public and of course if we make this private then at that point we kind of lose the purpose of our Singleton since no one else will be able to access this basically we want to be able to access this reference from classes outside of this one we just don't want those classes to also have right access now thankfully properties have an excellent thing which is you can Define accessors for here both the get and the set so we can make the property itself public which means by default both of these won't be public but then we can also add the accessor over here private which in turn means that the get won't be public so any other class can get this but private means that only this class can set it this way we have the exact level of accessibility that we want this is the reason why for this specific use case properties are very useful with just this one line of code we already have our instance with the perfect level of accessibility so now that we have this field to set it let's make a simple awake so let's go over here private void awake and on awake we just set instance equals this however remember that a key point of the Singleton pattern is you only have a single instance of something so in this case we should never have more than one player if we do then something went wrong so we can add a nice safety feature here let's just check if instance if it is not known meaning it has already been set to something if so then that's an error something bad happened similar to a debug.log error because this should never happen so let's say there is more than one player instance this way we have a nice safety check just in case something goes wrong alright so that's really it for the Singleton pattern we just defined a property with a public yet in a private set and on the Wake we just set the instance that's it as you can see it's super simple and now for the really useful part over here on the selected counter visual now we can access the Singleton instance in a super easy way let's make a private void start and on start we just access the player class and from the class we can access the static instance so we can access the Singleton and now we can listen to The unselected Counter event and over here by default Visual Studio gives this function the name of the event and also the property this is in the very descriptive name so I like to rename this so control RR and just rename the instance here instead of instance let's rename it to player okay great so over here we can listen to this event however here is yet another extremely important thing note how I made this on start that is very important if you do this over here on a week instead of start and over here on the player you're also setting the instance on awake if you do that basically there is a chance that this code won't run before this code and if that happens well then this one the player instance has not been set yet so this will be null and don't throw a known reference exception now whether this happens or not it's actually somewhat random it depends on the order in which Unity decides to run both these scripts if Unity decides to run the player first and this one second if that happens then there's no problem but if Unity decides to run this first and then this one then we have a problem let me do a quick test and see if in my case it triggers that error any up in my case it did trigger that error so here we have a no reference exception any app it is being fired on this line now one solution to this problem is you can tell Unity specifically which order the script should run in so you can go up here into edit then go into the project settings then on the left side you've got something called The Script execution order and basically over here you can set the order in which all of these scripts run so if you were to make the player script run before the default time that would make sure that even though both these scripts aren't awake this one would run before this one so that would fix that problem however you should really only use this approach in the last case possible where there really is no other way in this case we do have another better Wing personally I have a very simple room that I like to follow that helps solve this issue as you know Unity has both an awake and a start and all of the awakes on all the objects will all run before all these starts so the simple rule that I follow is that I use a wake for the initialization of that script and for any external reference for that I use it on start so in this case for initializing the player and setting the instance that will lead to the initialization of the player so let's do it on the Wake whereas over here on the visual since here we're going to access the player which is an external reference for this one instead of doing it on Wake let's do it on start this way we are guaranteed to make sure that this instance has been set okay so with all of that here we have our instance so that works great and we have our events so that's great then here we have our event and inside we've got our event arcs so we can go inside the event arcs object and inside we have our selected counter so we need to do is just compare which counter this Vision belongs to so let's actually make a film up here so as usual let's make a serialized film of type clear counter so we have this one and before we go into the editor just make sure it compiles and let's comment this out so now let's go back into the editor and over here let's drag the reference but again remember we're working with a prefab so let's click on open to go inside the prefab and now once inside it let's select the selected game object and just drag the clear counter reference okay great let's go back outside and save the changes all right so now here in the code it's actually very simple so we just do an if if the selected counter matches this clear counter if so then we want to show this visual if not we want to hide it so let's also add a reference for that visual so let's add another serialized field of type game object for the visual game object then back in the editor again let's go inside the prefab and on the select let's drag the channel kitchen counter so drag down that is the visual game object okay let's go back save and back in the code here let's make some simple show and hide functions so private void show and a private void hides and now on the show just going to visual game object and call set active so this enables or disables the game object so for sure let's set it to true and for hiding let's set it back into fonts okay so now it's super simple if the selected counter is this counter then let's show the visual if it is not then let's hide the visual alright that's it super simple let's test so here we are and if I approach that counter yep there you go look at that nice selected Visual and if I get into this one yep there you go I can see it all right great so here we had a really nice visual to our selected counter and more importantly we'll learn about the super useful Singleton pattern as well as learning about csharp properties and a very helpful room for how to avoid code timing issues so this was a really detailed really important lecture if you're feeling confused about anything go ahead watch it again or just post a question in the comments and I'll do my best to help so with all of this this is all great we have these unlike the counter and we can see which one is actually being selected then by pressing a button we can actually interact with it so I can move and interact with any of these counters but right now just interacting with them doesn't really do anything so the next thing we need is to create some proper objects for all of our ingredients so we can later pick them up and drop them on counters so let's begin doing that in the next lecture hey again quick intermission your pass C15 lecture marks so congratulations looking at my regular core stats it seems about 80 of people give up by this point so great job with sticking with it the difficulty in complexity is increasing over the lectures so I just want to check in to make sure you're understanding everything remember to post in the comments if you need extra clarification on anything and I'll do my best to answer also check the website to see what questions others have asked and of course remember this is your Learning Journey you're not competing with anyone but yourself so take your time rewatch some lectures if you need to just focus on learning okay let's go to the next lecture hello and welcome I'm your code monkey in this lecture we're going to learn how to create the kitchen objects like the various ingredients okay so far we have our player we can walk around I can approach each of these counters and I can interact with now the next one is to create objects the player can pick up and drop when interacting with a clear counter so let's begin by making the actual objects so let's create a new empty game object call this one the Tomato then again as usual let's separate the visual so in the included assets let's go inside of it then we've got the prefab visuals and we've got the kitchen objects visuals and inside we've got all of the ingredients so let's just find the Tomato Visual and drag it as a child of the tomato and again as usual make sure to put on position low composition zero zero zero and for the main one let's put it on a y of zero and just push it a little bit off to the side just so we can see okay great now this one is obviously not going to exist over here in our world instead we're going to spawn it so let's make it a prefab let's just drag it over here into our prefabs okay there it is let's delete it from our scene and actually on our prefabs let's make a nice folder to keep things nicely separated so inside the prefabs let's make a subfolder currently the kitchen objects let's put the tomato inside of it and let's also make another folder for the counters and let's put the clear counter inside of it okay so everything is nicely organized all right now that we have this let's go inside our clear counter script and over here let's add a simple reference to our prefab so let's make a type transform called the Tomato prefab by the way here you could make this prefab reference of type game object which type you use in this scenario is pretty interchangeable I talked about those differences in another video so when using prefabs using them as transforms or game objects that's pretty much personal preference and personally I just prefer to use them as transforms okay so we have this let's just make this a serialized field so we can set it in the editor and over here in the editor let's open up go inside the counter prefab and just drag the Tomato reference okay great let's go back outside save now back in the code here when the player interacts with it let's just spawn it so let's call instantiate pass in the Tomato prefab and now here is a good question which is where exactly do we spawn this we don't want to spawn on this counter's origin remember that the counter the way we set it up the origin on the actual object is over there on the bottom we don't want to spawn the tomato inside the mesh that would not make sense instead what we want is to spawn up here so the next question is okay so how do we get this point on top of the counter one approach would be to use a vector 3 directly in the code that would work but not very usable so a more designer friendly method is to Simply use an empty game object as a Target so on the counter let's first go inside our prefab and over here let's create an empty game object inside of it let's call this the counter top point let's make sure to leave this one as empty so no components just a transform and now let's just position it so let's lift it up by just about enough so let's make sure we see so there you go just about that so let's put it on position a y of 1.3 all right so this point is going to be our spawn point let's make sure to save the prefab then back in the code here let's add a reference to our point and for reference let's also use a transform reference currently the countertop point okay now let's just come this line just so the code compiles so we can drag the reference back in the editor inside the prefab let's just write the countertop Point reference okay great so now here when we call instantiate let's instantiate it inside the countertop point so this one's found the object so let's say the transform for the Tomato transform and then we go inside this one and let's just make sure we position it correctly so let's put it on in local position of vector 3.0 so this one put the object exactly on top of our countertop point also here very important don't make a mistake make sure you're modifying the low composition and not the global position okay so with this let's test over here in the editor let's go back save our prefab and hit on play so here we are let's approach a counter and interact with it and if there you go it does work the Tomato was indeed spawned all right awesome okay so with this we have pretty much our Basics working we can move up to a counter we can interact with it and spawn an object but now let's say that we want to spawn a different object so let's say now we want to spawn some genes first of all let's make the actual object so on the Tomato let's press Ctrl D to duplicate this one let's rename this to the cheese block and let's go inside of it now in here instead of the Tomato visual let's drag here it is the cheeseboard visual so let's use this one instead okay there's our nice visual let's make sure to save the prefab and go back out and now let's say that we want this one to spawn a tomato and this one on the left to spawn some cheese so let's override the prefab and over here drag the cheese block and now if we hit on play can go up to this one yep there's a tomato go this one any up there's some cheese okay so it all looks great but now let's say we want to know what object we just spawned like what object is on top of this spawn transform just like this in the code all we have is a transform reference so with this the only way to know what type we spawned would be if we had different prefabs for every single object then we could compare them one by one and see which one this matches but then let's say what if we wanted an actual string for the object well then we would need to add tons of fields for all these strings for all of the objects then what about an icon for each type once again we would need tons of fields each one for each icon but if we did it just like that with a bunch of lists then they would be separate that's not very good we should have a proper way of defining our object types and all the data related to them so this is exactly where scriptable objects come in these are objects you can create in your project funnels which are perfect for anything where you have multiple instances of a type like for example multiple weapons multiple armors multiple recipes or maybe multiple ingredients as usual I have a dedicated video on script along objects they are super useful definitely watch out for more detail over here on let's just use them so the first thing we're going to need is to actually Define the type and we do that in a csharp script so in our scripts folder let's create new csharp script call this the kitchen object so now personally so is just what I like to open to my scriptable object definitions just to make it very clear that it's a script mode object however this is not a requirement it's just a naming room that I like to follow and we're calling this kitchen object because we're going to use this to Define any kitchen object we want to interact with so that's going to be our ingredients like for example the tomato and cheese but also things like a plate and then potentially you could Implement things like a frying pan or framing signature or anything like that so it's going to represent any kind of kitchen object the player can interact with Okay so let's make the script and now let's open it and over here okay first things first is this is not a monobehavior instead let's extend scriptable object and then technically you can have functions inside a straight ball object but for now let's just get rid of this so just an empty class and over here on let's just Place whatever fields we need to store whatever that we want so like I said first we want a prefab so let's make a public transform for our prefab by the way here note how I am indeed using public this is pretty much the one exception to the room I only use scripting objects as readonly data containers I never write to them so since I found that rule I usually make the fields in the description object public that way I can access them directly without having to make a public getter but if you want to feel free to keep following the general rule of not making anything public you could definitely make this just a regular serialized film then exposed with a get function that would work personally I just find it simpler to make it public since I know that as a personal rule I will never write to a script mode object field okay so we have a transform for our prefab let's also add a Sprite for the icon Sprite and finally let's just add a simple string for the object name all right so we have our scribble object definition we have all of the fields for all of the data we want to store now how do we actually create a scribble object for that let's go up here before the class name and we're going to add the attribute so let's add the square brackets and the attribute is the create asset menu this takes some optional parameters again I cover them in detail in the dedicated script and objects video for now let's just leave all the parameters as empty just use defaults and close the attribute okay so that's it let's save this and go back into the editor and over here if we go into the project window click on the plus icon and right up top yep we do see a kitchen object so so if we selected if there you go it creates a brand new object inside of our project files let's name this one tomato and obviously let's keep our project nice and organized so we don't want this inside the scripts folder instead let's make a proper folder so create a new folder come with our scriptable objects and then inside let's put a different folder for each type so let's make another subfolder call it the kitchen object so and let's place the tomato inside of it okay now with the Tomato selected we can look in the inspector and you can see yup it does have all of the fields that we Define okay great so now we can just assign them so this is the tomatoes let's drag the Tomato prefab for the icon Sprite let's find it so there are Sprites included in the regular assets so here is the Tomato Sprite so it's inside the acids then inside textures icons and we have all the icons and finally for the readable name let's just call it tomato alright so that's it here we have a really nice scribble object containing all the data required for our tomato okay awesome with that then we can now go back into our clear counter script and here instead of having a field for our tomato prefab instead of this let's sort of reference of type kitchen object so and let's go on with kitchen object so and then when spawning let's go inside our scriptball object and just spawn the prefab reference so this is going to be the kitchen object transform then over here in the editor let's go inside the clear counter and let's assign the Tomato Kitchen object okay so let's save it and test so here we are on let's approach hit any up there you go it still spawns eat tomato okay great now let's make another type for our cheese block so let's create a brand new kitchen object so called the cheese block and again let's assign first of all the prefab there it is then for the Sprite of the cheese walk and finally this is the cheese well okay so now for example let's go into the second one and on the second counter let's override and say this one spawn a cheese block so let's test so here we are approach this one yep there's tomato this one any of there's some cheese okay great so everything is working so far however the original problem that we're trying to solve identifying the spawn prefab we still don't have a solution for that basically when we spawn a prefab we need to know from which script No Object this prefab came from so essentially what I like to do is just attach some reference to the scripting object in our prefab however again remember that scripting objects are not mono behaviors so if I select the prefab and I try dragging the description object nope it does not work so what we can do is just create a new script so let's make a brand new csharp script let's call it kitchen object let's attach this to both prefab so both the cheese and the block attach the same one to both of them and let's open and over here very simple let's just add a serialized film for our kitchen object so a serialized film of type kitchen object so for the kitchen object the cell then let's also make a quick function to expose it so we're going to return kitchen object as so get kitchen object so and we just return the kitchen object as well yep just like this so now here in the editor for the Tomato yep we've got the film so let's say this one is a tomato and the cheese block this one is a cheese block now here obviously we need to make very very sure to drag the correct reference to the right scriven object if you drag the wrong one like for example over here on cheese you would say this one is a tomato if you did that then obviously you would get some very weird results so make sure to check and double check that you drag the right preferences both over here on the prefabs make sure they are referencing the correct Circle object and on the script module itself make sure they are referencing the correct prefont okay so now if you go here on the clear counter we spawn our object okay great then on this object we can do get component of type kitchen object and then we can just ask it to give us the kitchen object as well so for example let's do a debug download on this one so inside you get the kitchen object to sew and then let's print out the object name all right so here we are let's interact with this one and if there you go interacted and spawn the tomato and on this one yep interacted and spawned a cheese block okay awesome we spawned a transform prefab and we identify the spawn object is indeed this type of object all right so here we'll learn about one of the most powerful ENT features scribble objects these are extremely useful for defining a type and then creating multiple instances of that type with whatever that we want so there can be some ingredients like we have here or it could be some weapons could even be some NPC data maybe some Quest data and so on it really is an insanely very useful feature definitely go ahead and watch a dedicated video on script on objects then if you want you can also watch some more videos where I've used scriven objects for example in the Minecraft crafting system using scripting objects or the hydrogenated crafting system which again also uses scribdon objects okay so this is done it's working great now let's continue to the next lecture where we're going to help the kitchen object know where it belongs and help each counter know what kitchen object is on top of it hello and welcome I'm your code monkey in this lecture we're going to create a kitchen object parent meaning that the kitchen object will know where it is and the counter will know if something is on it this is important so that later on we can pick up a kitchen object from one place and drop it in another okay so here we have our player I can move towards this counter interact with it and yep spawn a tomato then on this one's want some cheese okay great but I cannot do anything else in fact if I interact a bunch more times really all I did was just spawn a whole bunch more cheese so instead I want to be able to spawn some cheese and then pick it up so let's think about exactly what that means we want a kitchen object to essentially be placed on a specific Place based on the design that we're trying to implement we're never going to have a kitchen object just randomly thrown around the world we're not going to have tomatoes all over the floor instead the objects will always need to be placed somewhere and that somewhere can be either a counter or it can be being held by the player so essentially that means that each kitchen object is going to have some kind of parent that it's attached to we're going to make sure the counter knows if there is a kitchen object placed on top of it and we're also going to make sure the kitchen object itself knows where it is so first let's do that logic over here on the counter so on the clear counter script let's keep a field for a kitchen object so just a simple private of type kitchen object kitchen object then when the player interacts with it by the way we can get rid of these debug transforms debug logs in all you need them okay so when the plane interacts so if the kitchen object is known if so then we're going to spawn it then when we spawn it let's assign it so this one equals the kitchen object get component of type kitchen object okay so if that one is no we spawn it and we assign it and just with this we should have fixed the issue where we can spawn infinite objects so over here I can interact and now I've interact a bunch more times and now look in the hierarchy inside the clear counter and I go inside the counter top Point nope there's only one tomato okay great so with this basically we made the clear counter know if there's something on top of it now let's do the other side so let's go into the kitchen object and make sure that it knows where it is so over here on the kitchen object script let's add a simple field for a counter so private of type clear counter for the clear counter and now let's just basically make two functions one to set it and one to get it so a public void set clear counter and we're going to receive a parameter of type clear counter okay great and then we're going to have a public return a clear counter for the get clear counter and we're just going to return our clear counter and on this one just set this dark layer counter equals this layer counter all right so on this function we're assigning this field and on this function we're returning this field so now back on the counter script we get the kitchen object reference so on this one let's call set clear counter and pass it in this one and if it is not known so if there's something on top of this let's just do a debug.log let's go on to the kitchen object and get the clear counter so we should be able to click once and spawn an object and click twice and the second time we should be able to see the name of this layer counter all right so over here let's approach and click and yep it's spawn now click again and if we've got the message this one is on the planet counter okay great so far so good so the counter knows if there's a kitchen object on top of it and the kitchen object itself knows where it is now let's add some logic to be able to change a parent counter it's over here on the clear counter script we basically just need to call the set layer counter function with a different counter reference so just for testing let's add a serialized film for the second counter so clear counter for the second clear counter now we're doing this just for testing just make sure the logic Works before we come up with a more General system so just for testing let's come up with some input and again for testing using the lazy input manager to get something quickly up and running is a great thing so let's quickly get a button input on the counter so let's make a private void update and for testing we only want the testing to work on one counter so let's also add up here just a ball testing and then on update if we are testing and we have the input.getkeydown on let's say the T key so if you have that then we can run some kind of testing code so let's say for example if the kitchen object does not know so if we have something on top of this kitchen counter let's go into the kitchen object and call set counter and let's pass in the second clear counter so basically with this we should be able to interact to spawn an object and then press the T key and we should be able to see that object be set to a different parent so here in the after I'll let you set down let's say this one is our main counter so let's drag a reference to the second one the second higher counter drag it and make this one the testing script and also just to verify that it worked over here and lets you a get on the clear counter all right so let's test and see okay so here we are let's approach this one interact and there you go spawn tomato and now if I interact again yep it says the tomato is on the similar counter now if I press the testing key if there go the Tomato was moved onto the other counter okay so the parent change the logic worked however obviously we have two big issues the first one is just a visual you can see the object is still placed on top of this counter even though technically now it belongs to this one and the second issue is that this counter still thinks that it owns this kitchen object and this other counter does not know that it now owns this object so we need to sort all of that first for the visual it's actually very simple here when spawning we are spawning it inside the counter top point and then setting the alarm position to zero so whenever we move to a different second parent when we do that we can just ask that second parent to return the countertop point and move it there so for that let's make a function to return that so public we're going to return transform so get the kitchen object follow transform so it's going to be our countertop point so let's return the counter top point then let's go into the function on the kitchen object when we set the clear counter so over here on the kitchen object on this function so we set the color counter then let's modify this transform.parent go into the nuclear counter in order to get the kitchen object funnel transform and again let's make sure to set the low composition back into Vector 3.0 okay so with this when we set the clear counter to a different one it should automatically teleport to the other counter so let's test so here we are in first let's interact with this one there you go it's Pawn now if I press C testing key and if there go it does move visually okay great so far so good however the counters still have the wrong data by the way here's a quick empty tub on the inspector you already know that you can only see the public and the serialized Fields however there is actually a way to look at private fields on the inspector on the top right there's these three dots and if you click on it over here you can modify it into a debug inspector and when you go into this one Yep this one does show all the private fields so you can see for example on the clear counter so that's the right one this one over here the kitchen object is indeed assigned and we can go into the other one and we can see this one has it as null so debug inspector is really useful in these kinds of cases if you want to inspect any kind of private Fields you can go to this and see it now let's swap back into the regular inspector and let's fix that issue by notifying the counters that the object has changed so over here basically we have two options over here on the calendar counter when we modify the parent when we tell the kitchen object to go to a new parent when we do that we can make the new parent responsible to updating itself or we can just make the kitchen object itself be the one responsible for notifying the new parent both approaches can work personally I think it makes more sense for the kitchen object to handle itself so we just call this function to set the new parent and when this happens basically this kitchen object needs to tell the old parent that it is no longer there and needs to tell the new parent that it is on there so on the counter let's make some function to set and get a kitchen object so over here on the calendar counter script let's go down let's make first one to set so public void set kitchen object and receive a kitchen object and just do this dot kitchen object equals this kitchen object okay great then let's make a getter so public return a kitchen object get the kitchen object and just return this kitchen object okay then let's also make one just to clear it so probably avoid clear kitchen object and this one just sets the kitchen object into null and finally just a nice sample function to test if this counter has anything on top so just a public Bowl has kitchen object and over here we just return if the kitchen object is not known okay so some four very simple functions now if we go into our kitchen of the script over here when we tell it to change the parent let's first go into the current parent and clear it so let's first of all do a quick test for null so if this documentary counter which is the current parent so if this one is not null then we go into the current parent so the clear counter and we tell it to clear the kitchen object and then we go into the new parent and we tell new parent to set the kitchen object and the kitchen object is this one now here will be very very important don't make the mistake of clearing the wrong counter keep in mind that over here this documentary counter this refers to the previous player counter whereas the one in the parameter this is the one this is the new one so make sure you clear the kitchen object from the previous clear counter before you assign it and then you set it on the new clear counter so be very very careful here make sure you don't make mistakes between the quote unquote old color counter and the nuclear counter okay so that's it basically we have this function to set the nuclear counter so set the new parent we clear the kitchen object from the old player counter we added a new one and we update the visual now we can also add some nice safety checks here just to make sure we never make a mistake the kitchen object should never be set to a parent that is already holding something so before we set the kitchen object before we do that let's make sure that one is empty so over here just do an if if the clear counter so that's a new one if this one has a kitchen object then it already has something on there this should never ever happen so let's see what debug.log error and say counter already has a kitchen object we're going to eventually add tests to make sure that this never ever happens but having the air here won't be helpful just in case we missed something so far as the kitchen object we're going to fire an error but this should never happen so we just set the error update to visual and so on okay so finally let's just go over here into the clear counter script and down here we have the interact action so we instantiate the kitchen object we're currently repositioning it and then we're setting this field assigning it to this one now we made the kitchen object responsible for doing all that for modifying the position and for setting the field so we don't need to do this instead we really just need to go and get the component of that and just pass in set for your counter and pass in as this one so we no longer need all this now our code is much more simple also importantly up here we were previously setting the color counter and then doing a debug.log but when we set it a new one that is actually going to clear this field so if we leave this then this is going to throw a null reference exception so let's just get rid of the slog here we normally need it okay so let's test and see if all of our logic is working all right so here we are let's go to this one interactive spawn it okay great and once again we can look in the debug inspector so let's put it on debug look at this layer counter so that's the right one and yep there you go it does have the kitchen object and if I'm looking the other one Yep this one has no okay great now if I press the testing key yep visually it did change and if you look at the counter so if you look at the old ones that's the right one this one is at no okay that's great correct and if you look at the new one Yep this one does have the reference all right awesome so now that we are correctly changing the kitchen object parent for example we can now interact again with this one and yep it does spawn a brand new one and of course if we try moving it to the other one then we should have our error as intended this one is currently already occupied the kitchen object so we should not be able to drop something on there but if I press the testing key if there go nicer okay so that's great we're basically going to fix this error later on when we check to make sure the object can only be spawned when it can be spawned but for now all of our basic logic is working we can spawn an object and change a parent alright so with that here we have added a really important feature to our game that is the ability to know where a kitchen object is now the next step is to enable the player to be able to pick it up and drop it somewhere so let's do that in the next lecture hello and welcome I'm your code monkey in this lecture we're going to enable the player to pick up a kitchen object and in doing so we're going to learn about another awesome csharp feature called interfaces okay so right now with our game I can already move the player I can approach a counter and try to spawn an object and with the testing key I can move it to a different parent so all of that logic is working now let's make it work actually with the player let's say when we interact once we want to spawn it and if there's an object already on top of it and I interact again then I want to give it to the player okay so here on the clear counter script we've got our interact function in order to make that work we need to have a reference to the player so I just passed it in over here as an argument for our interaction so just pass in the player reference now over here let's do the logic that I send so if the kitchen object is known so if there's nothing here then let's spawn it okay great but if there is something then let's give the object to the player so how we change the object parent is just like what we did up here so let's go into that one set the clear counter and pass in deploy a reference except of course this obviously does not work the parameter on this function is supposed to be of clear counter it does not work with the type of player recently on the logic that we built for setting the parent and change the parent this whole thing only works with the counter so it does not work with any other type so we cannot set the player as a parent now to solve this problem is exactly where csharp interfaces come in again I have a video going through them in detail definitely watch it and learn everything about interfaces basically what it is is a contract you define some functions in the interface and then any type can Implement that interface and you can write some code that works with the interface which in turn means that the code won't work with any type as long as it implements that interface so in this specific example we're going to make an interface to represent a kitchen object parent then we're going to implement that interface on both the counter and the player and that way both of them won't be able to be parents of a kitchen object so let's do exactly that now the first thing we do to Define an interface is Let's Make a csharp script so let's right click create new csharp script and now the standard is to start interface names with the capital I and then the name so in this case let's name it I kitchen object parents and let's open it okay so now to make an interface first of all this does not extend mono Behavior nope and secondly this is not a class instead this is an interface now like I said an interface is essentially a contract where each class that implements that interface must follow that contract what that really means is you can define a bunch of functions here by the way quick note you can also define properties but not Fields I cover all of that in the dedicated interface video but for now here we just want some functions like for example let's just put all of the parent functions that we made previously on the counter so over here on the corner counter a while ago we made all these functions that we needed to make it work as a kitchen object parent so we got the transform set kitchen object get it clear it then has it so let's just copy all this and paste it over here on the interface however one important note is on the interfaces you don't actually include any function implementation the implementation is up to the class that implements this interface although again I should also point out another quick note as of csharp 7 you can include a default implementation but that's for more advanced use cases so for here let's just use the basic and not apply any default implementation right here so we just defined the function and put a semicolon so just like this just the function definition with the exact signature so just like this okay so now that we have defined our interface and all the functions that we want to have with this now let's go on to the counter script so over here on the clear counter script over here let's implement the interface and the way we do that is pretty much exactly the same as by extending a class so over here we are already extending Model Behavior then let's set a comment and let's say we are also implementing the ikitchen object parent interface so right now you might be wondering so this is pretty much the same thing as extending a base class and kind of except for one huge difference when extending a base class you can only have a single Base Class like for example over here we have monobehavior you cannot extend multiple base classes there can only be one however when it comes to interfaces you can Implement as many interfaces as you want so over here we have defined our interface and right now we don't even have any errors that's because we already implemented pretty much all the exact functions also Visual Studio has a really nice software icon over here on the left side it is basically saying that this function this implementation is based on the interface but let's see what happens if I decide to comment out these functions so if I comment out all of this and if there we go over here we have an error it is telling us that this class does not implement the members for the interface like I said an interface is like a contract so you must write all of the functions included in the interface so we must Implement these so let's get rid of the comments okay with this our interface is perfectly working over here on the calendar counter now let's just go into the kitchen object over here on this script for now we're still working with the type clear counter so let's just refactor this to instead of working with a clear counter let's make it work with a kitchen object parent so let's just change this from type that to Kitchen object parent let's also rename this so let's use Ctrl RR for the kitchen object parent then we've got a function to return the kitchen object okay that's good for this one instead of setting your counter and let's once again rename this to set kitchen object parent and inside again we receive of type I kitchen object parent then let's also rename the parameter to Kitchen object parents okay so all the names here I have changed okay they're all correct we set it we assign it over here instead of counter let's say kitchen object parent already has that so just like this and finally down here let's return I kitchen object parent and rename this to get kitchen object parent and we return that all right so we have changed everything I can even do control F to search for counter and nope there's no instance of any counter so all this code has now been Rewritten to work with a kitchen object parent something like this everything should be working it's only the same as previously we have no errors here and over here on the clear counter we just have this error on the player and let's fix this in a little bit for now let's just comment it let's just test it out to see if everything still works exactly the same as previously also one final thing since we modified the interact function over here on the player class when we have the interact we just need to pass in this reference okay so let's test all right so here we are let's approach this one interact yep there it is now let me press the testing key and if there go it does move okay so everything is still working exactly the same as previously once again another successful refactoring now here comes the magical moment so right now again everything is still working exactly the same as previously so we can only have counters as parents but now let's go over here onto the player script and over here let's also implement the same interface so let's implement the eye kitchen object parent and again as usual we have our error so we need to implement this also again Visual Studio is very helpful so we can click on the light bulb icon and let's say implement the interface and if we scroll down here it will automatically create all these functions so let's just actually Implement them so for implementing this interface the code is really going to be exactly the same so let's go up here into the clear counter let's go down find all of these functions let's copy them and on the player let's paste them down here at the bottom so we just need to also pick up the kitchen object as well as a reference to the top point so over here on the clear counter and let's just grab both those so let's just grab the kitchen object so go into the player and over here let's add a film for the kitchen object and finally let's add another one for the counter top point so over here a serialized film for the counter top point except obviously the player is not a counter so this name makes no sense on the player so let's just quickly rename this and set call it kitchen object home point okay here we have our new name we've got the kitchen object and down here all of our functions they're all working no errors all right now let's just assign this in the editor so over here let's just go into our player there's a player script and requires a reference to the kitchen object home point so for that let's do it just like we did for the Counterpoint so inside the player let's create an empty game object currently the kitchen object hold points and I always just position it just slightly in front of the player so let's put it on a x of 0 on a y of 1.3 and on a set of one so there you go just ahead that's where the player is going to be holding the objects finally over here on the player let's just drag that reference okay so far so good also one note here like I mentioned previously in order to implement the interface it requires you to write the function code basically what this means is that different objects can implement the exact same interface whilst having different implementations so for example over here on the player when setting the kitchen object perhaps over here you could play some kind of item grab animation or maybe when clearing a kitchen object you could do some kind of logging the only thing that needs to match perfectly is just the function signature and the function signature that means the return type as well as the name and any parameters the implementation itself that is up to the class that wants to implement that interface but in this case we wanted to behave pretty much exam the same way so like this it should be working so we can now go back here onto the clear counter script and okay we have our interaction all right great so if there's nothing we're going to spawn it and if there is something on top of it we want to give it to the player so now let's go into the kitchen object and call the function set kitchen object parent and pass in the play reference and that's it no errors because again this takes a parameter of type kitchen object parent and the player does implement that interface so that's all valid now with this let's says and see if our code is working alright so here we are and let's interact with this counter and there you go the object has been spawned and now if I interact again if they're going to look that the player picked up the object and since our logic is using a transform home Point as the parent the player is automatically carrying this tomato alright awesome so this is really great now over here on the counter we no longer need all of this testing code we now have the ability to actually pick up objects from the player so let's get rid of all this so we don't need this testing code don't need a reference to the second color counter or the testing okay great so here you can see the power of interfaces by just implementing the interface we can now place an item anywhere we want and importantly on any type we want so the counter can hold a kitchen object the player can also hold it we could make a dog character and make it hold a kitchen object we could make a vehicle hold it or anything again interfaces are really really awesome one of the best C sharp features definitely go ahead pause this course for now and watch a dedicated video on them you should be very very familiar with interfaces they will help you in making all kinds of systems and games if you want to see a clear example of the power of interface you can go watch my how to interact with NPC's video that video takes advantage of interface to make sure that the player can interact with any kind of object alright so thanks to interface we can now change the parent of the kitchen object and put it on either a counter or the player now in the next lecture let's make a proper different counter type hello and welcome I'm your code monkey in this lecture we're going to create a different counter type from where we can grab some ingredients okay so far here we have our character working and we have an empty counter and by interacting with it we can spawn an object but obviously that's not the behavior we want in the final game we want different counter types that do different things the cleaner counter should only be used as a place for putting down and grabbing objects it should not spawn anything so let's build a new counter type and for that one option is to make a brand new prefab and build it on from scratch another option is we can duplicate this counter and change a bunch of things or there's a third option that was added in recent TNT versions you can now have what is called prefab variants meaning that we can have a base counter and then we can make variants for all the types so let's do exactly that to learn about prefab variants now first let's duplicate this one just so we don't lose any changes let's rename this prefab to underscore base counter no I'd like to add an underscore just so that the bass prefab is on top since this window is sorted alphabetically now let's go inside the base counter let's go into the scene view so here it is and recently over here we only want to have all of the things that all of the counters will have so all the counters will have a boxing ladder only the same shape so that's good they will also all have a counter top point however for the visual different counters will have different Visions so let's get rid of this same thing for the selected let's get rid of this and on the actual object different encounters will have different Scripts so let's also get rid of this okay so that's it this is the base counter it only has all the things that every single encounter will have so let's go ahead save this prefab go back outside and now let's right click on the base counter and go into create and over here let's scroll down and find the prefab variant now let's name this the clear counter except obviously we can't have two different names so let's put this one into backup we're going to get rid of this one in a little bit so on the very end let's name it clear counter let's open up this variant and now here let's add everything just like we had on the own player counter so since it's going to be exactly let's actually go inside the backup one so here let's just copy the visual in the selected so let's copy this go back inside the clear counter variant and over here only let's paste it so Ctrl V see if there it is he selected any visual finally just scripts over here let's add the clear counter script and now let's just write the references so the kitchen object we're actually going to remove this in a little bit but for now let's assign it the counter top Point Let's drag it and on the selected we also need to drag the kitchen counter reference okay so here is our clear counter as a variant of the base counter so let's go ahead save this and go back outside and now we can finally delete the owned prefab of the clear counter so let's go ahead and delete this and of course over here on the scene we've got some broken prefabs so let's get rid of both these and let's drop the clear counter variant so let's drop it place it over here so let's put it on X of 0 y of zero and Z of 3.5 okay so that's the clear counter and let's just put another one to the side and perfectly on the side so on an X of minus 1.5 okay now we can begin making our container counter so for that once again let's make a variant so right click on the base counter and go into create and let's create a prefab variant call this the container counter and let's go inside of it now here first thing we need is the visual so let's go inside our assets we've got the prefab visuals inside we have the counters visuals and let's find the container counter so let's drag it inside again for the low composition make sure it's on zero zero zero okay great then we need to make the selected so let's duplicate this visual let's rename this to selecton let's go inside on all of these then let's modify the material for the selected material so let's click on the circle icon and select the counter select material okay we've got our nice little ghost icon and just like we did previously let's start with these disabled so all these game options disabled so they are hidden and on the selected let's make sure the scale is one percent bigger so 1.01 also in the selected this one does not need an animator so let's get rid of this now let's add the selected counter visual and obviously for this one we're eventually going to need to refactor it to support multiple visual objects as you can see this selected has multiple but for now just make sure that it works let's just drag just the first one okay great so our container counter has been built the only thing that we need is the main logic script so let's do that let's go into our scripts folder let's create a brand new csharp script name it the container counter and let's select the main game object attach a script and let's open it alright so now here let's first think what we want for this counter we want the player to interact with it and when it does we want to spawn an ingredient and give it to the player so that means that we're going to want pretty much the exact same behavior that we made over here on the clear counter so when the player interacts we spawn and we give it to the player so let's actually copy all of this code let's go into the Container counter and over here let's face this we just need to grab the references to the kitchen object and the kitchen object as so so again just like we did on the container counter let's copy all these references and over here let's paste all of them and of course here we have an error in order for this work this needs to implement our interface and let's do exactly that so let's implement the eye kitchen object parent and back in the clear counter let's just copy the exact same code so all of these functions let's just copy them and on the container counter just paste them okay great so we don't have any more errors here so everything should work we should be able to interact with the container counter and we should be able to see an object being spawned on top of it over here in the editor let's just make sure to assign it so let's assign a default kitchen object so let's say tomato and the counter top Point Let's drag the reference and okay everything else should be working so over here on the selected we've got the visual game object on the container counter we've got this okay great so let's go outside into scene View and over here let's just Place some container counters so let's drag one up there let's place it on an X of 1.5 on a y of 0 and Z of 3.5 and let's also Place another one down here so let's rotate it to face it upwards okay so on position zero zero minus five okay great and let's make them spawn different things so on this one up here let's actually spawn a cheese block and on this one down here let's one tomato so let's also modify the icon here so from cheese block and let's put a tomato icon so here it is okay we've got two counters and two clear counters so let's test so here we are and if I approach a container counter and I press the interact button and nope nothing happened we cannot interact with that at all even the selection visual even that one is broken so as I approach note the visual is not showing up now the reason for this is actually pretty obvious if we go over here on the player script down here when we're handling our interactions so let's go into the handle interactions function over here we are doing a recast and we are trying to get component of type clear counter so basically we're not doing anything if that object has a container counter instead of a clear counter so again we have a similar issue to the one that we had in the object parent logic basically we have two types a clear counter and a container counter and we want the player to be able to interact with both them so as a solution for this exact same problem we could also Implement an interface just like we did that would work that would enable the player to interact with multiple counters but in this case since the counters are all very similar very related objects they're all going to be kitchen counters as opposed to object parents where the player and encounter are completely different in this case since they are all very similar a better approach is actually to use inheritance now here I should point out that inheritance is one of those things that is simultaneously very powerful but also very dangerous usually beginners get really excited when they first hear about inheritance but after gaining some experience they start to see the massive downsides one funny joke about it is let's say you want to write some code that all it needs is a Banana class but because of messy inheritance you end up with a monkey and the entire jungle behind it basically the banana extends a monkey which extends a tree which extends the jungle and so on so you just want a small thing but because of a complex inheritance you end up picking up a huge object some of that to say inheritance is something you must use very very carefully it's a powerful tool definitely but you need to make sure that you absolutely use it in the right approach for the problem you're trying to solve now in this case like I said since all of the counters are going to be very closely related in this case it does make sense and of course in the future if that does change we can always refactor if you're a beginner definitely go ahead and research a bit more on csharp inheritance the pros and cons I don't have any dedicated video on that topic myself but if you search I'm sure you'll find tons of content again it's a very powerful but also very dangerous tool so definitely use it wisely over here let's make sure we rise so let's use it first thing we need to do is to find the base counter class so let's create a new csharp script let's call it the base counter so over here on the script let's get rid of the functions we don't want any default functions and let's also make sure that we do extend mono Behavior we do want that we still want to use this as a component so let's leave the script just like this let's save it then let's go over here into the clear counter script and on this one instead of extending Model Behavior let's extend the base counter okay that's it that's the only change and now let's go into the Container counter and over here same thing let's extend the base counter inside of Model Behavior so now both these counters extend the exact same base counter script so now if we go into the player score so here we are on the player script and on the handle interactions function over here instead of trying to get a component of type player counter let's try to get component of type base counter so let's also rename the so control RR to rename rename this to base counter and of course we need to rename all these references that expect a clear counter instead of the base counter so over here for the selected counter let's modify the type to base counter then also up here when we've got the event RX let's modify the type okay so over here we have the interactor let's leave this for a bit let's go down and let's fix this issue so let's go down into that function to set the selected counter instead of this time let's receive a base counter okay so all of these errors have been solved there's only one left and it's this one the interact we see this error because obviously the base less does not have any kind of interact method so let's add that now for adding methods to a base layer it's sectionally very simple it's really just like any other method so first the accessor for the interact we want the player to be able to access it so let's make it public and also since we're talking about inheritance I should probably mention the other accessor now you already know about public and you also already know about private but there's another one you might not know which is called protected basically this one means that whatever function we defined with this successor it is going to be accessible to this class and any class that extends it so for example if we had a function that was protected the clear counter could count this function because it does extend this Base Class however the player would not be able to call this because it is protected now in our case for the interact action we do want to play the comet so let's make it public just like we had previously then another keyword for every function that we want the chunk lesses to be able to implement in their own way we can Define it as virtual and finally the function signature as normal so for the interact we made a return void call it interact and we received a player argument okay so that's it that's our basic signature for the implementation let's leave it empty over here on the base counter so by default it's not going to do anything in the game design that we're building we're never actually going to end up with anything like this so if you want for safety we can just add a debug.log error to say just base counter.interact because this should never be triggered also I shouldn't point out for a more advanced method instead of making it virtual you could make it abstract and basically what that does is that forces all the classes to implement their own implementation so you would make this extract and just put it just like this as if this were an interface but in doing so you would also need to define a base counter as abstract and so on so basically this is a more advanced method so don't worry about it for now let's keep it a bit more simple so let's make it just virtual void interact okay great so we have this let's save this and now if we go on the calendar counter over here on the interact notice how we have a green screen line basically this is a warning it's telling us that we are hiding the base function now in reality we don't want to hide it instead we want to override it so before the void before the return type we just have the keyword override and Yep this will now override the base function so when the player interacts with an object of type based counter and that object is actually a clear counter when the player calls the interact function instead of running this code it's actually going to run this code now let's do the same thing on the container counter so over here let's also add the keyword override to override the base function okay great so we have no errors here and on the player we also don't have any more errors since that one does now implement the interact function so with this one it says and everything should still be working so over here let's approach the entire counter and let's interact with it any up it does work it spawn some cheese and down here yep it's on the tomato and then if we go on to the empty counter and interact and yep it still works okay so here we added the ability to interact with two different counter types alright great now knows how the selected logic isn't really working well you can see the container counters they are both selected even though the player is not looking at them and actually if I approach it then it actually becomes deselected basically the reason for that is because these selected square of that one is still referencing the clear counter inside of the base counter so right now it's only being selected when the sunlight the counter is known so that is why as I approach it actually hides itself so let's fix this let's go inside the container counter prefab and inside we've got the selected any up over there we have a reference to that so let's open up this script and over here all we need to do is just modify this time so let's make it a type base counter and let's rename this to base counter okay that's the only change we need and by the way since we're here let's also fix the other issue the issue we had where we need to support more than one visual game object so instead of having a field of type just game object let's receive a game object ring so let's modify this to game object array and then down here on the show hide is actually very simple so let's just do a four inch game object for the visual game object in the visual game object ring we go inside set it to true and on this one we set it to false okay that's it super simple now let's just update the prefabs so first over here on the container counter let's write the container counter reference as the base counter okay great and for divisions let's just drag all of them so let's write the counters only drag it on top then the counter hole drag it on top then the single door drag it and the black drag it and also by the way over here on this counter this one actually has an objects right this is the actual Sprite in there but for the selected we really don't want that so if I enable this game object here we've got the object Sprite let's actually delete this we don't need the actual icon Sprite to be highlighted so let's leave it just like this so we only have these four objects and all four of them are on the list okay that's right so all the references in here they're all working perfectly so let's go back outside let's save the prefab let's go inside the empty clear counter and on this one same thing on the selected let's Drag The Insider reference and for the base counter let's also drag that reference okay so let's go outside save it and let's test and now let's see if the selected Works once I approach this one yep it works yep it works and on this one yep it works and down here yep it works all right awesome so we can interact and we can highlight our selection okay everything is working great so now that all the code is working we can inspect the code to see if we can refactor anything we can see for example if there's any kind of common logic that all of the counters share that we should probably write in the base counter and you can see right away that both the clear counter and the container counter both of them implement the kitchen object parent interface that behavior is something that all of the encounters will share so instead of defining it on each counter itself let's actually do it on the base class instead so let's get rid of the interface implementation here and also on the container counter let's get rid of that and set on base counter and let's Implement that one so I catch an object parent and for the functions let's do the same thing so let's cut this one from here and let's paste it on the base counter it's okay now we need these two points so let's go ahead copy all of this let's go into the base counter and paste in except for the base one doesn't need a kitchen object so so just the counter top point and the kitchen object okay so there are no errors on this one let's go into the container let's get rid of the kitchen object and the counter top Point okay great now we see an error but before we worry about that let's actually go into the clear counter and let's do the same thing so let's get rid of this get rid of this and down here get rid of all these functions okay so now the counter scripts are much much more simple all of the common code is now written directly on the base counter now for solving this the container counter needs to know if there's a kitchen object on top of it so now here we have an interesting question with two possible approaches basically we need access to this object so one approach would be to make this protected like I said protected means that any classes that extend this base counter class any of those classes can then modify that field something like this yep there is no more errors that's one approach and the other approach is to instead keep this one as private and whenever we want to interact with it we simply interact through these functions both approaches can work and when in doubt as usual you should probably go with the more limited option so let's leave it as private and work with these functions and send over here on the container counter instead of testing if the kitchen object is no let's just test has kitchen object so if it does not have a kitchen object then we're going to spawn it and for spawning over here we could grab the actual transform funnel so this one up here we could call this function to get it or since that is actually going to be handled automatically when we call this function to set the parent then let's actually not use this at all so we just spawn it and set the kitchen object parent okay great so now let's just look at the clear counter for this one like I said it's not really meant to spawn anything solid sectionally remove all of this code this one is only going to serve to pick up and drop items we're going to handle that in the next lecture but for now let's just go back into the Container counter and let's do the proper logic that I mentioned in the beginning basically on this one we want to spawn the object and we want to immediately give it to the player so when we call set kitchen object parent instead of passing in this let's pass in the player reference and that's really it for the container counter this is all we're going to do so the player interacts and it spawns an object and gives it to the player okay so that's it with this as you can see the code for all of our counters is much much more simplified so basically it only handles the logic related to that specific counter everything else is on the base counter so let's test this so here we are and if I approach the counter interact any of their go spawn some cheese and gave it to the player okay great now just for fun when I made these assets I shall include a nice animation so if you go inside the container counter over here on the visual note how this already has an animator with an animator control and attached to it you can double click to open it up and over here you can see it's very simple basically just has two animations one is the container close and one is container opening and closing these transitions are basically triggered by this parameter this is a trigger parameter so when triggers goes into the open close and when this one ends goes back into closed so let's just quickly add these nice animations however again as usual let's make sure to write some good clean code so let's not add the visual over here on the logic script instead let's make a proper new script over here let's create a new csharp script call this the container counter visual okay now we want to attach this only to the visual game object so only this one let's attach okay and over here the first thing we need is to get the animator so let's sort of film for the animator and since it's on the exact same object we can just make an awake and get component of type animator and we just assigned this field okay so with this we have the animator now we just need to know when we should play the animation so let's go over here on the container counter script and basically let's make an event that we're going to fire when the player grabs an object so let's make a public event of time let's stick with the standard so let's use event handler inside using system okay let's name this on player grabbed object then down here when the player interacts and gets an object let's fire off this event so invoke let's invoke with this and event RX dot empty okay so we are firing off this event and over here on the visual first we need the film for the container counter so let's set it up here let's add a serialized field of tribe container counter okay we have this build now let's listen to the event but again we're accessing an external reference so let's make sure to do it on start and not on awake so let's go into this one and listen to the on player grabbed object event okay so here we have the event and it's over here that we want to access the animator and call set trigger in order to play the animation again when working with animator parameters suddenly we do need to use strings there's no way around that but at least we can make it a bit more clean by defining a constant so here a private con string call it open close and let's make sure to use the exact same parameter name so open close and then down here on the set trigger let's call this trigger okay so that said some very simple visual logic and now over here inside the prefab all we need is to drag the container counter reference so let's drag it also make sure that it has the animator and the animated controller so with that everything should already be set up so let's go back into the scenes save the changes and let's hit on play so here we are and if I go towards the tomato and interact any of that I go it plays a nice little animation alright awesome okay so here we created a brand new counter type and we refactored our interact code to be able to interact with any counter type the player can interact with the container counter to pick up an object now the next obvious thing that we need is to enable the player to drop an object on the clear counter so let's do that in the next lecture hello and welcome I'm your code monkey in this lecture we're going to enable the player to pick up and drop objects okay so we already have the player working I can approach this container counter interact with it and yep the player picks up something now that's left is being able to put our shade clear counter and being able to drop this object so let's do that let's go over here on the clear counter script and when we interact with it we're going to do a bit of logic first let's just check if this counter is empty meaning if there is no kitchen object on it so let's test if has kitchen object or if not so let's say if we don't have a kitchen object then there is no kitchen object here and if not then there is a kitchen object here okay these are the two valid options so if there is nothing here then let's check the player itself so we go into the player and we can ask the same question so it has kitchen object so if the player is carrying something so over here the player is carrying something if so then basically we just want to drop that object from the player and drop it in here so that's very simple we just go into the player we get the kitchen object that the player is holding and we just modify the kitchen object parent onto this object all right so that's it just with this it should already be working let's do a quick test before we handle the rest of the interactions okay so here moving the player and if I just interact with a clear counter and nope nothing happens okay great since the player is not carrying anything nope nothing happens all right great now let's pick up something from the container counter okay so now the player is carrying a tomato approaching clear counter press a button and yep there you go there it is alright Awesome everything worked now this is an excellent point to know just how easy this was to implement and the reason why it was so easy was because we focus hard on running some good clean code for how the object and the appearance system works because we took some time to think about that it was now very easy to implement this brand new action so this is a very very clear example of the power of writing good clean code okay so with that now let's implement the rest so over here there's no kitchen object here and the player is carrying something but if not we've got the L so player has nothing so if the player doesn't have anything so let's not do anything so player not carrying anything so those are all the possible States up there and then down here if there is a kitchen object on this layer counter if so then let's check if the player has a kitchen object so in this deep layer is carrying something and if not then the player is not carrying anything so basically if there is a kitchen object here and the player is carrying something if so then we don't want to do anything since we can't give the player two items however if there is a kitchen object here and the player is not carrying anything then we want to give it to the player so let's just get the kitchen object the one that is on this clear counter and let's do the exact same thing so set the parent and set the parent onto the player okay so that's it as you can see some very simple logic so let's test okay here we are and if we interact nope nothing happens okay great now pick up a tomato go there drop it yep there it is now if I interact again yeah there you go I picked it up again so I can go somewhere pick it up drop it and everything works perfectly all right awesome now the last thing that we need to fix is the container counter right now it's giving out an object every time even if the player has something so if I pick up the other works now if I pick up again there you go we've got our nice helpful error this should never happen so let's add some nice checks so over here on the container counter okay we have our interaction and before we spawn anything let's just see if the player can pick up something so once again very simple let's just go into the player and we check does the player have a kitchen object if so we're not going to give it anything but if the pointer does not have a kitchen object then yep the player picks it up and we give it the object okay so that's it it's this simple Let's test so here we are let's pick up some cheese okay great now pick up another one and nope nothing happens okay great we're already carrying something so we cannot drop anything now drop it in there now pick up a tomato any of it works I can pick it up drop it and yep everything works okay great let you see one more thing over here the container counter is spawning the object and the object is the one that we assigned so over here in scene view we've got the container counter this one is placed on the scene and we made an override to spawn a cheese block technically we could keep doing this pretty much just duplicate objects modify the Sprite modify over here the kitchen object that would work but another better approach would be to Simply make some prefab variants and yep that does work you can make a variant of a variant so let's do examine that over here on the container counter let's right click going to create and let's create another prefab variant and let's say container counter this one will be the Tomato now let's go inside the prefab and over here make sure it has the kitchen object for the Tomato okay great and over there on the Sprite so let's find the object Sprite and choose the Tomato Sprite so there you go this one okay let's exit and Save all right now once again let's right click on the container and let's make it another one this is going to be the one for the cheese block so let's go inside of it and over here modify it for the cheese block and inside the actual visual let's modify the Sprite and sectionally down so the cheese block okay great let's go back outside and since we're here doing this let's make all of the other grab my objects from the containers so let's first make the kitchen object a so so let's go over here we can right click go into create create new kitchen object so let's make one for the brand then let's see if we get this one we're going to have a cabbage and finally we're going to have the meat Patty uncooked all right so now let's make sure to assign all the data for all these script along objects first we need to make the actual kitchen object so let's duplicate tomato name this one bread let's go inside of it and first for the kitchen object the song Let's make sure to drag the correct one okay there's the bread and for the visual this one is not a tomato so let's go inside our visual acids inside the prefab visuals let's pick up the bread visual okay there it is that's all we need so let's go outside save the changes and then select the bread scripting object drag the prefab reference okay for the Sprite this is the bread and finally just call it bread okay let's do the same thing for the other one so next up for the Cabbage let's do the Cabbage drag the Cabbage script object let's go inside and modify the visual so the Cabbage visual okay that's it then on the Cabbage scorpion object drag the reference for the prefab let's assign the Sprite and finally give it a name cabbage and finally the meat Patty and cooked so let's do that one so let's duplicate it name it meet Patty uncooked let's go inside modify the kitchen object so for this one and for the visual let's select here it is the meat Patty uncooked okay let's go back outside and on the escort mode object let's just drag the prefab assign the Sprites so this one is the uncooked so it's this one and finally meet Patty uncooked okay great so we added all of these squared more objects we also have the prefiles with the visuals and the electric scripts now let's just make the container counter so once again let's create another variant so prefab variant this one is for let's say for the brand then let's make all the other ones already so let's go make another prefab variant this one is going to be for the meat Patty uncooked and finally another variant also here make sure you're creating a variant of the container counter don't make an accident of creating a variant of something else let's make another variant one final one and this one is going to be for the cabbage okay we have all the variants now let's just sign them so let's go inside the bread and over there modify the description object for the brand and for the icon modify for the bread icon okay let's go to the Cabbage save the changes modify that one for the cabbage go into the icon and modify the icon and finally the meat Patty uncooked let's go ahead modify this one for that one and the icon put it on that one all right everything is working now let's just place them over here in our scene so let's get rid of the ones that we made some overrides so let's get rid of that container counter and set for that one let's drag the cheese block put it right in there let's put it on X 1.5 y of 0 Z of 3.5 okay then down here for this one let's put the Cabbage next to it let's rotate it to face upwards so like that let's put it on next of minus 1.5 y of 0 and 5 on the Zen then for tomato let's get rid of this one and use the proper tomato one so let's rotate it put it on an X of 0 y 0 and 5 okay next we want some bread so let's put the bread up here on the left side let's put it on X of minus three zero on the Y and 3.5 on the Zen and finally the meat Patty and Coke let's put it over here a bit more on the side let's put it over here on X of 7.50 and 3.5 alright so we have positioned all of them let's just make some more clear counters so we can actually place the objects so let's put this one over here on minus 4.5 this one over there let's also put some counters let's say one on the right side and a bunch more down here let's rotate them upwards let's put this one on 1.5 minus 5. and one more over here on the side okay great so we have all of our container counters as well as a bunch of clear counters so let's test and make sure that everything works okay so here we are let's go down pick up a tomato yep there's tomato now a cabbage yep there's a cabbage now some bread there's some bread and some cheese there's some cheese and some meat and yep there's some meat all right Awesome everything works so with this over here we added the ability to pick up and drop objects on an empty container and spawn them from all kinds of container counters now in the next lecture let's build the counter we can interact with in a very interesting way hello and welcome I'm your code monkey in this lecture we're going to create a cutting counter so this is going to be a counter where we can place an object like for example tomato and after doing a secondary interaction we can slice it however before we do that let's just fix one slightly annoying issue so right now the player is walking around okay that's great I can approach a counter and interact with it that's great however if I approach account from the sign look how the player is pointing towards the right and if I press the double key I can indeed select it but the player does not rotate to face the counter so that's just a minor visual issue but still I'd like to fix it so let's do that very quickly basically the issue is over here on our player script so we scroll down and find our handle movement function okay so here we were doing a bunch of Capstone cans in order to fix the problem with the diagonal movement so you try to move in One Direction if not try to move in just one of those and if we can move then we assign a move Direction and then move it basically the problem that we have here is that if I press W to face towards the counter then over here when we do this logic so it's going to first attempt the X movement only and the x is going to be zero so the move there X is going to be zero zero zero so it won't actually move anywhere which means it won't be able to move so this one becomes true which then sets the move direction to zero zero zero which then down here when we have our rotation it's not actually going to rotate to anything so we want the player to still not go through any objects but we only want to modify the move there over here if we actually move in any of these directions so the solution is actually super simple it's over here for the can move we can move if there's nothing on there and if the move direction.x is not zero so that's really it if we are attempting to move in the X at all and if there is nothing on there then we can move which means we then assign the move direction if not then we don't touch this and same thing down here so we can move if there's nothing on it and if the move there dot Zed is not zero so that's it just this one simple change and now the player should be able to rotate so here we are and if I look over there and the player is currently unlocking to the left and if I press W to point towards the container counter and if there you go the player does rotate a little bit so that feels a bit more natural all right so that's just a tiny visual thing that I wanted to fix okay so let's keep going now let's handle the actual cutting counter so first of all as usual let's make a counter variant so let's right click on the base counter create a new prefab variant call it the cutting counter let's go inside of it and over here first thing we need is the visual so let's pick up from the assets The Cutting countervision so here it is then we need the selected so let's duplicate this one let's rename this one to seal lectin and on the animator let's get rid of it and instead at the component the selected counter visual okay great now let's write divisions for the visual game object array and by the way here's a quick tip on the right side on the inspector you can see this nice little lock icon so if you click on it then that means this inspector will not change as you select other objects so I can click on and select something different and this one does not change it is still showing the selected object now this is this one when you want for example to drag multiple things so you can unlock the inspector then the hierarchy you can use shift click to select multiple objects and then just drag them all directly inside the array that's it just a nice quick tip so everything is done let's unlock it there it is okay so that said let's just assign the selected material so the counter select material let's make it just one percent bigger so let's select them all 1.01 okay and let's start with all of them disabled okay so the basic setup is done now let's make our script to run this so let's go down let's create a brand new csharp script for The Cutting counter let's select the apparent game object and attach a cutting counter and let's open now here as usual instead of all this let's start off by extending the base counter okay once again thanks to how we set things up using such clean code this is pretty much all we need to make a counter with this the counter already works as a counter then next thing we need is to customize any logic specific to this counter by just overriding the interact function so that's it now over here we can put whatever logic we want just for the cutting counter and for this one for star is actually going to be just like the empty counter meaning we're going to be able to drop objects on this so let's just go directly into the clear counter so here it is and let's just copy all of this code go into the cutting counter in Payson okay so the exact same logic so checks if there is a kitchen object or not checks if the employer's carrying something or not and picks up or drops in with this let's do a quick test just to make sure this one is working exactly like the clear counter so over here let's just make sure to drag in less references so on The Cutting counter let's make sure to drag the countertop point so drag that reference and then on the selected Drag The Cutting counter reference okay everything is good let's exit this prefab make sure to save all the changes and over here in the scene view let's Place one of our cutting counter so let's Basin right in there let's put it on X of 4.5 0 and 3.5 okay so let's test all right so here we are now if I approach and I interact nope nothing happens okay great pick up some cheese and drop it on there any of there it is I can pick it up I can pick up some bread drop it and yep everything works okay so far so good now the next goal is to use the knife and actually slice the object that is on there and for that the first thing that we need is we're going to need a different input right now we only have the movement and the interaction so let's add another alt interaction for that let's go into our input action so let's open it up let's make another action so create a new action call it interact alternate and for The Binding let's put it on another key so let's listen and I think on F makes sense so let's go ahead select this one then as usual let's make sure to save the asset which in turn is going to generate C sharp plus and compound the code okay great now we can go here into our game input class and let's do the exact same thing with it for the interact action so first of all let's listen to it so let's go inside the player input actions inside the player action map so this one is the interact alternate and let's listen to the performed event okay and when we have that let's fire off an event pretty much the same thing so interact alternate action and down here let's just fire off this event so let's invoke using this and even RX dot empty okay so we have the input for the interact alternate now let's go on the player to listen the same way we're listening to the regular interact action so over here on the player script let's see how we're doing things so we go into game input and listen to that so it's the same thing game input and on interact alternate action let's listen to this one and when this one happens lets you pretty much exactly the same thing except we're just going to call a different function so instead of interacting let's call interact Alternate which in turn obviously means we need to Define this function so let's go into our base counter so here we are on the base counter we've got the interact and let's make another one exactly the same just different name interact alternate okay that's it and now we are only going to implement this in the ones that need implementation so for example on The Cutting counter over here let's write down so public override and let's override the interact alternate and now here let's check check if there's something placed on here so if there's a kitchen object placed on this counter if so then let's basically cut it and for cutting it the simplest way is really to destroy whatever object is on there and just spawn the slice object so let's handle destroying a kitchen object for handling that let's go over here on the kitchen object script and let's make a simple function for this object to destroy itself so let's go up here make it public return void and for name I like to use the name destroy itself to make it destroy this object and really all we need to do is just destroy and call destroy on this game object however before we do let's make sure to clear the parent so let's go into the kitchen object parent clear it and then destroy the game object okay that's great it's really this simple and then on the cutting counter let's get the kitchen object that is on here and tell it to destroy itself okay so let's raise the object and after we do let's just spawn the slices object so for now just keep things simple let's make a direct reference up here let's make a serialized film let's make it a type kitchen object so and for the cut kitchen object the cell okay so we have this then here in the editor and let's make sure to drag the reference so let's go inside the cutting counter and let's open up the prefab and inside let's assign this one that means we need to create the object so let's actually do that first so let's create a brand new kitchen object to sell let's come out for the tomato slices then if we do this we need to create the prefab so let's once again do the same thing tomato slices make the prefab let's go inside this prefab let's modify the visual so use the tomato slices visual okay and drag the reference for the other kitchen object for the tomato slices okay so the visual prefab is good and let's just go into the kitchen object let's just make sure to drag the prefab reference then let's assign the tomato slices icon and just come with tomato slices okay so we have the kitchen object so now we can go into the kitchen counting counter and over here let's open up and set this one to the tomato slices okay so we have all the references let's go back outside save it and back over here in our code so we have this now we just need to spawn this object so we're really just going to spawn it pretty much exactly like we did over here on the container so we just go into the description object spawn the prefab and set the appearance so let's do exactly that over here we destroy the object then we instantiate the cut kitchen object and instead of getting into the player let's put it on this okay so that's it we should be able to place a tomato directly on top of the cutting counter and it should be able to transform from a tomato into a tomato slices okay so here we are let me pick up a tomato go up there drop it and okay that works now if I press the onton track key press it and if there go it did work the Tomato was destroyed and the tomato slices were spawn and I can pick them up place them anywhere and yep everything works alright awesome so with this the basics are fully working let's just briefly clean up this code we already saw a little bit of code duplication so the cutting counter is going to spawn an object and the container counter is also spawning an object so we're copy pasting these two lines of code in multiple places so instead of doing that let's put it in just one place and actually a good place to put this is on the kitchen object list itself so it makes sense that this one is responsible for spawning more objects so let's put it over here however let us not make it a regular function instead let us make it a static function again just like we saw for The Singletons by making it static it means that the function is going to belong to the class itself as opposed to any instance so let's go all the way down to the bottom of the file personally I like to put settings at the end and over here let's make public make it static we're going to return a kitchen object and let's call it just spawn kitchen object and for our parameters let's receive the kitchen object that so and let's also receive the kitchen object parent okay so that's it and we're going to do the exact same thing so let's go into the cutting counter and copy the code that we're using and over here just paste it in there so we go inside here spawn the prefab and set it on this parent and finally let's return it so let's return the kitchen object over here let's pick it up so the kitchen object we get it and then we do kitchen object set the parent and finally we return the kitchen object all right so that's it here we have a super simple function that we can call very easily it won't automatically spawn an object and set to parents so now let's just call this from somewhere so over here on the cutting counter instead of doing all this let's just go into the kitchen object again remember let's go through the class name itself and not any instance and over here let's call the function pass in the cut kitchen object the cell and for the parent it's going to be this all right so that is now much much simpler and let's do the same thing over here on the container counter so if the player is not carrying anything let's give the player this object and give it to the player just like this as usual when we do some kind of refactoring let's do a quick test make sure everything still works exactly the same okay so here we are and if I go to the counter and pick it up yep it does work to spawn the object now I can drop it in there I can cut it and yep there you go everything does work all right so far so good so with all this basically we have created a brand new counter where we can cut objects however right now there's obviously one huge layering funnel if I now pick up a cabbage and I drop it on the cutting counter and I interact with it that cabbage has suddenly magically turned into tomato slices now that is obviously not intended so for that let's define a proper cutting recipe and let's do that in the next lecture hello and welcome I'm your code monkey in this lecture we're going to create another scriptable object type this one is going to be for handling our cutting recipes so here's our game I can pick up a tomato drop it on the cutting counter cut it there you go slice Tomatoes however if I could pick up a cabbage go there cut it and there you go cabbage turns into tomatoes so we have an obvious issue The Cutting object is currently hardcoded instead of being based on the object we put on top of it so to solve that let's make another scribble object type like I mentioned scribble objects are excellent for storing and organizing data so it's perfect for this use case basically we want a script mode object to hold a reference to the regular object and the cut object so we can then identify the input in order to spawn the output okay so let's build that let's create a brand new csharp script call it the cutting recipe so and let's open it okay so now here on let's do exactly that so something extremely simple so instead of modern behavior this one is a script mode object let's add the create asset menu and finally for the fields let's do just an input and output so we've got of type kitchen object so let's go for the input and another one for the output okay so that's really it super simple now here in the editor before we create and let's keep things organized so let's make another folder let's make it for the cutting recipe so and inside let's frequently create a new cutting recipe let's call it tomato two tomato slices and over here let's select the reference so the input is going to be our tomato and the output the tomato slices okay so this is how we're going to handle things so let's go ahead and make actually the final kitchen object that sews so let's make yet another one a kitchen object to sell let's make it for the Cabbage slices and then let's have another one for the cheese slices okay so now let's make these so as usual let's if we get tomato make the cheese slices and another one for the Cabbage slices let's go inside of it and first of all drag the kitchen object as so so this one is the Cabbage slices and let's go modify the visual so instead of this one the Cabbage slices okay so we have this let's save the prefab go outside then the other one we made the cheese slices so let's swap this out let's find the cheese slices and modify the kitchen object as well okay so finally just assign the references so on the cheese slices drag the cheese slices prefab let's assign the icon and call it cheese slices okay so finally on the Cabbage slices so these are the Cabbage slices let's pick up the icon and let's drag the prefab reference okay so far so good we have created our new icons and over here let's just make all of the other cutting recipes so we've got two more so one is going to be the cheese block onto cheese slices and the other one is going to be cabbage onto cabbage slices so we need is just to drag drop the scriptable objects so for this one cabbage let's drop the cabbage on the input cabbage slices on the output for cheese mug that's the cheese Wok on the input and the cheese slices on the output okay great all of our data is now stored in some really nice script mode objects so now let's go here into our cutting counter instead of having a hardcoded kitchen object let's receive a field of type cutting rest BSO except we're going to have multiple so let's actually make an array of this call it the cutting recipe so array now for the interaction this is picking up and dropping things so let's leave that the same for now and over here on the alternate basically we need to find out which recipe we should apply to this so how I didn't find that is pretty simple so we've got the kitchen object that is placed on this object and we've got a list of cutting recipes which in turn has the input so we just need to cycle through all the recipes in order to find the one where the input matches okay so let's go down here make a function to do just that let's make it private we're going to return a kitchen object as so let's come with get output for input so we give it a certain input and Returns the one that matches that one so it turns a kitchen object as so for the input kitchen object as well here on let's cycle so do a for each cutting recipe so in the cutting recipe so right so let's cycle through all these and just check if the cutting recipe so if this one dot input matches the input that we received if so then this is the one we want so let's return the cutting recipe so.output and to make sure that the function Works down here let's return no okay so that's it we give it an input and we get back the output so now here we just need to make sure to do it before we destroy the current kitchen object so let's store a kitchen object as so for the output kitchen object SL and we just get the output from the input and for the input pass in the get kitchen object so that's the one inside of this cutting counter and let's get the kitchen object this out so that gives us the output and then we just spawn that output okay so that's it let's test finally back in the scene let's just go inside the prefab and over here on cutting counter we need to make sure to add all the recipes so let's add so the cabbage then a second one for cheese Mock and finally for the Tomato okay so there are of our recipes let's go outside save the changes and let's test okay so over here let's pick up a tomato go up there slice it there you go got some tomato slices now pick up some cheese go here slice it and there you go got some cheese slices and finally the Cabbage go up there slice it and there you go some cabbage slices all right awesome so everything is working perfectly however now let's say that I want to pick up some bread and bread should not really be able to be cut so if I go ahead and I cut it and there you go there's our air we have no recipe that takes bread as an input So that obviously leads to a known reference exception now here we have two options for solving this problem one option is simply over here when we do the interact alternate we get the output for the input and if this one returns null then we just don't cut it so we don't destroy it and we don't spawn it or alternatively we can actually add some Foundation over here when dropping objects so we can make sure that we only drop valid cutable objects now both approaches are valid and actually we do need to implement both them we'll see why in a bit so let's do both starting off with the validating the drop so first we check if there is no kitchen object on this cutting counter then we check if the player is carrying something and then we drop it from the player on this so over here let's just check if there's any recipe that has whatever the player has as an input so let's go down here make a function to do that private let's return a bone and call it has recipe with input and we're going to receive a kitchen object episode for the input kitchen object lesson and over here lets you pretty much literally the same logic so we have this and if we find a match then let's return true so there is a recipe with that input if not return false so now up here when the player is carrying something let's check if has recipe with input and give it the player get the kitchen object the player is holding and get the kitchen object as so so if there's any recipe that takes whatever the player is carrying as an input if so then we drop it okay so like this let's test and see if we can drop the bread okay so let's pick up some bread go ahead drop it and nope does not work pick up some cheese and yep that one does work however now we actually also need the other validation that I mentioned the reason is because if we place a valid option like for example the cheese there so that works and I can cut it and yep that does work however Now the recipe the cheese moth became cheese slices and now cheese slice is no longer an input to any cutting recipe so now if I try cutting again I've got another no reference exception so we need to validate putting objects on top of it and also actually cutting them Technologic is also pretty simple so let's go down to the interact alternate so we just check if there's a kitchen object on The Cutting counter and has recipe input and let's get this kitchen object get kitchen object as so just like this so we're only going to cut if there is a kitchen object here and it can be cut okay so let's test so first of all the other one let's pick up bread and nope cannot travel okay great now pick up some cheese and I can drop now interact cut now cut again and yep there you go no more errors all right awesome okay so here we have everything working perfectly I can pick up a cabbage go up there cut it into slices I can slice some cheese and I can even slice some Tomatoes everything works perfectly now the one thing missing from our design is we don't actually want this action to be instant we don't want to just press a button everything slices instantly instead we want to have the player press the button a few times in order to actually cut so let's do all that in the next lecture hello and welcome I'm your code monkey in this lecture we're going to add the mechanic for the player to be able to cut multiple times in order to actually cut an object okay so we have our cutting counter I can drop a tomato and press button there you go it cuts it straight away now we want the exact same logic but we want it to take a few Cuts before the cut object is spawned so let's start off by going here onto the cutting counter and basically let's keep track of some kind of progress basically the way we do that is pretty arbitrary it's up to you to decide for example you could use a normalized float however for cutting since this is going to be a discrete action let's actually count the numbers with an end so let's store a private end just call it cutting progress okay so now let's begin by actually initializing this progress so when the player drops something on there let's set this one to zero and then down here when we have the interact alternate we do our logic and when we do let's just increase this by one and now we need to know if the object has been cut so we need somewhere to Define some kind of maximum and for that we can actually do it directly on the recipe so so inside the cutting rest PSO over here we've got the input we've got the output and let's also Define an end for The Cutting progress Max okay that's it and back here in the editor let's go into the Tomato to tomato slices let's say this one takes just three Cuts then for the cheese let's also take three cuts and for the Cabbage let's say it's a bit thicker so let's say it takes five cuts okay so back in the cutting counter here down here we are adding to our cutting progress so then we just need the recipe so in order to grab the maximum so on sectionally go down here and actually make a different function so this one just returns a Boolean this one a kitchen object or so let's make another one this one is going to return a cutting recipe so so get the cutting recipe so with input and we're going to receive as usual the kitchen objects so for the input I'm really going to do the exact same thing that we did up here next time instead of returning the output let's return the recipe itself okay so now that we have this more logical one we can actually get rid of all this copy paste code so over here we just get the cutting recipe so and we just get it and pass in the input so we have this one over here if this one is not no then we're going to return this on the output and if not we're just going to return null okay so we're doing the exact same logic just a bit similar okay and up here pretty much the same thing so has recipe with input let's get the cutting recipe a cell and basically just return if this one is not known okay so we have our three nice sample functions so let's just use this one to get the cutting rest BSO so let's actually copy this and go up here so we do the cutting progress then let's pick it up the one for this input so the input is going to be this one the object currently on the cutting counter and over here we already know that there's going to be a recipe with this input since we've gone through this if so then we can just check if the cutting progress is bigger or equal to The Cutting recipe so and let's grab the maximum if so then yep we do spawn it okay so that's it some very simple logic Let's test so here we are let's pick up a tomato go up there and okay now I'm going to press enter direct okay press once and yep okay so far so good nothing now two times and Alpha press a third time boom any up there you go got the nice slices now for cheese same thing one two three yep it works and finally for the Cambridge this one should be five so one two three four and five any up there you go everything does work perfectly all right awesome so with this we now have progress in our cutting logic although of course just like this it's not very good for the player the player has no way of knowing what exactly is going on so we need some kind of visual feedback so for that let's add a really nice visual progress bar and for doing this we're also going to learn about a really awesome Unity feature these are World canvases so before we make the world canvas on The Cutting counter let's actually set something up over here on the scene itself let's first create a regular canvas we're only going to use this in a couple of lectures but let's first do that one just for now so let's go on the plus button go into UI and let's create a brand new canvas okay so there you go that creates a canvas and an event system like I said we're only going to worry about this in a little bit but for now let's just leave those as is and also since we're here creating some objects let's also take some time to organize our hurricane Unity suddenly doesn't really have any folder objects so you can't organize the hierarchy in any folders however you can use empty game objects essentially as folders so let's make a brand new empty game object let's call it counters and now very importantly for empty folder objects make sure you put them on zero zero zero so nothing breaks so make sure you put it on there before you drag the counters and now let's just drag on the counters inside so all the clear counters put them outside this one also drag it inside and all of these counters put them all inside so there you go now hierarchy is quite a bit more clean okay so now let's make the cutting progress so let's click on the cutting counter and let's go inside our prefab so let's go inside of it now over here let's right click on the hierarchy and we're going to create a UI let's create another canvas now for this one let's give it a name let's name it the progress bar UI and for this one over here on the inspector for the settings instead of being screen space overlay let's make this one a world space canvas basically screen space means that it would occupy the entire screen whereas World space means that this exists in the world in whatever position it is so let's make it World space and over here the fields actually unlock so let's put the positions on zero and for the width and height let's also put it on zero so basically the canvas is going to be exactly over here by the way the shortcut that I just used was the F in order to focus on the object so this useful if you're zoomed out or zoomed in way too much okay so we have this and we want the bar to be a little bit above so let's actually lift it up on the Y by a little bit so over here let's put it on y of 2.5 okay now I said the going with this is to make a progress bar so inside the progress bar UI let's create a new UI image let's name this one our bar let's put it with a width of one and a height maybe of 0.2 so there you go just a really thin bar and for the color you can play round tinted with any color you want now for progress I think maybe a blue or a yellow something like that makes sense so let's go with the yellow kind of like this okay so there's our really nice progress bar and for this let's actually use one really nice trick for making a super easy progress bar the image component has a really easy way of making a slider image however it only actually works if you assign an image over here so let's assign one in order to be able to see those options and for that in the project files there's a texture white one by one this is literally just a one by one white pixel so here it is just a one by one image if only white and as soon as we assign it we do see over here the image type so we see a bunch more options and the one that we want is to set the Sprite as filled this one lets you do some really cool really easy effects for example you can make it radial and look at what happens in there as I modify over here on the film Mount so as I go down look at that it's radiantly filling so for some kind of circular progress bar this would be excellent but in our case what we really want is just a horizontal bar so we're here for the film method instead of Radion let's go with horizontal and if there you go now by playing around this we have a really nice progress bar then if you want you can modify on left to right right and left but yep like this it looks great now in order to modify this visual really only we're going to need is modify over here the film Mount this one is a normalized value so between 0 and 1 so 0 is commonly empty one is commonly full however one issue with this is when the bar is empty then we can pretty much not see so we can see the actual size of the bar we can see what size it should be so with this it's pretty difficult to see how far along we are but something that is pretty simple we can really just add some kind of background so let's duplicate the bar let's name this one the background for this one for the image type we don't want anything so let's leave it on SIMPLE and for the color let's put it on kind of a dark gray okay great and now here's one very very important thing is over here on the hierarchy let's click and drag and place it above the bar the reason why that is super important is because the Sorting order and how it works in unity basically when it comes to UI elements inside a canvas the Sorting order is based on The Horde in the hierarchy basically it renders from top to bottom so the bar on top the background this is going to render first and then the one below it the bar is going to render afterwards which means it's going to render on top so for the background we want to be behind so place it above on the hierarchy and that way it renders the background and then renders the bar also by the way for 2D Sprites Unity has another different sorting method it's all based on sorting layers and sorting orders I have video on that topic if you're interested in 2D games okay so with this we have the background and then we have our film bar this way we can see if the progress is being filmed or not also one more tiny thing that I like to add is Unity has some really nice really easy to add effects so you can go into that component and let's search for a shadow this one does exactly what you expected as a nice drop shadow over here on the effect distance let's put it on 0.1.1 in order to see next one let's not do it on this one we'll do it on the background so let's get rid of this instead of going to the background over here let's add the same shadow so if you put it on point one and minus point one you better go a nice simple and drop shadow or the other one that I prefer so instead of the Shadow let's add a really nice outline once again for the effect distance 0.1.1 or maybe actually 0.05 just to be just a tiny bit and let's raise it on the alpha so there you go nice little outline tour bar this is just a visual thing so you don't have to add this but personally I find that it looks pretty good so with all of this we have our Visual and perfectly set up we've got our nice bar all we need to do is play around the filament in order to fill it so now all we need to do is to connect this to the logic but as usual let's make sure to write some good clean code so we do not want the cutting counter to directly touch on this image instead let's make a script to handle on that so let's right click create a new csharp script call it the progress bar UI and just personally as a rule I like to open the UI to any UI script you don't have to do that it's just a rule that I personally find helpful to follow that way just by looking at these scripts I can immediately see this one is a UI this one is script and logic and so on so on the progress bar UI on the main game object let's attach the script and let's open it okay so now here we're going to need a reference to our image so let's add a serialized field private and we're going to need the image type and importantly this is inside using Unity engine.ui so let's go up here using Unity engine dot UI so we have our image component okay great let's call it the bar image so we have a reference and now with this obviously we need to have some kind of reference to the counter so we know when the progress changes so it's really the same thing that we've already done so many times throughout this course so let's set a film up here serialize film private cutting counter for our cutting counter then over here in the editor let's write new references so drag the reference to The Cutting counter and another one to the bar image okay great now we just need some kind of event to update the bar image so let's go over here into our cutting count script let's make an event to spawn that so public event let's use the event handler the default standard let's go with on progress change and let's also make a nice event artist to be able to send the current progress amount so let's make a public class on progress changed event arcs and let's extend event arcs and then inside and let's put the current progress however let's also pass in the progress as normalized since that's the what the bar will use so public Cloud progress normalized and we're going to make this event of this type okay great so we have our event now whenever we modify the progress we just need to fire this event so over here when resetting the progress let's fire it so let's invoke pass in this instantiate our event args and pass in the progress normalized and to get the normalized progress sectionally very simple basically we just need to divide the current progress by the maximum so cutting progress divided by cutting progress Max which is actually inside the rest BSO so we need to pick that one up so let's go down there to pick up the cutting progress recipe so we picked this one up and we go in there and get the maximum however over here we also need to be very careful because there is one sneaky issue here this has to do with how csharp works and how instar divided with other ends for example if we had a cutting progress of one and cutting progress Max of five you would think one divided by 5 would equal 0.2 however if we actually did that over here we would actually get a zero and the reason for that is because we are dividing two ends cutting progress is an end cutting progress Max is also an INT and if you divide an end by an end then the end result will also be an end since you cannot Define 0.2 in an end the decimal gets cut down and you end up with just zero so that would not be correct in order to get the right value from this calculation we need to make sure to convert one of these values onto a float so that's really simple we just cast one of them so just cast this one to the float just like that basically now this one will first be cast to a float and then we're going to have a float divided by an end and the end result won't be afloat so if you ever do some math and you get some weird results always make sure to check the type of your numbers okay so here we are correctly firing the event and then down here when adding our progress let's do the same thing let's also fire on the event so now we can go back into our progress bar UI and over here let's listen to the event and again remember that if we're accessing an external reference let's do that around start and not an awake so cutting counter listen to the on progress changed event when that happens let's just go bar image and set the fill amount to what we received from the event so the progress normalized okay so that's really it and also appear on start let's initialize it as 0f so the bar is nice and empty okay so let's test back in the editor let's just go back into the scenes make sure the prefab has been saved and let's head on play and right away yep we do see the bar yep it is empty now pick up some cheese drop it and if I cut and if there go add a little bit of progress now a bit more and there you go there's our cheese okay great everything does work now let's add just one more tiny bonus thing we can add some extra logic in order to hide this visual if the bar is either completely empty or completely full that is actually pretty simple over here on the progress bar UI script let's just make some basic show and height functions so private void show and then we're going to have a private void Hind on these one just game objects that active this one set it to true and this one set it to false now on start we subscribe to the event and then let's hide it okay also here it's very important make sure you hide it after you listen to the event if for example You Can't Hide on awake that would disable the game object and the start would never run so it would never listen to the event so if you have reset the game object as inactive make sure you do it only after you're listening to whatever events you want so we have this that's great and then when the progress changes let's just do a basic test so if e dot progress normalized equals zero f or if the progress normalized equals one F so if the bar is similarly empty or completely full if so then let's hide it and if not then let's show it okay that's it let's test okay and yep by default starts off hidden let's pick up the Tomato go up there and yep still hidden now I cut and there you go there it is cut again and yep there you go it hides itself okay great so we've got a nice little visual let's do just one more final thing let's add a really nice animation if we go inside the cutting counter and we'll look at the cutting counter visual over here note how it already has an animator just like we did for the container counter it's all very simple so basically just has a cut parameter when that happens it just cuts the counter so just plays a simple animation since it's going to be pretty much exactly like the container counter and let's actually duplicate that script so let's go down find that script so the container comes to visual let's duplicate this so Ctrl d let's rename this to The Cutting counter visual okay let's open and over here let's rename the script so the cutting countervision okay great then for the parameter let's rename this instead of open close is going to be called cut and for the string it's cut again make sure you write it case sensitive make sure it's all correct then instead of having a container come through we've got a cutting counter and a cutting counter and finally we just need to listen to the correct event so technically we couldn't listen to the unprogressed changed however that one also gets fired over here when the cutting progress is zero we don't want the current mission to play when this happens so let's just make another simple event so a public event event handler let's call this just on cut okay and then down here when we have our cutting progress so we cut and let's just invoke this event okay that's it super simple so now on The Cutting counter visual let's go into the cutting counter and into the uncut event let's listen to this and we're going to set the trigger example like this so get rid of the container counter like this okay there you go a very simple script so now here back in the scene view inside the container counter prefab let's just go inside the visual let's attach The Cutting counter visual just need to drag The Cutting counter reference and that's it let's exit the prefab save it and let's play okay so now let's pick up a cabbage go up there drop it and aren't interact and if there you go we've got a nice little animation all right awesome so I can drop things I can cut them and everything works perfectly all right so here we added a cutting progress to our cutting counter and we also learned about yet another very useful ENT feature called World canvases and at the same time you might have also noticed that the canvas is looking at the camera in kind of a weird way basically just pointing straight forward this can sometimes make it difficult to see so let's work on that in the next lecture hello and welcome I'm your code monkey in this lecture we're going to build a very simple but very useful script to make an object look straight at the camera with various options okay so we previously made the cutting counter and when I placed something yep there's a nice progress bar so now that this is working let's do one more thing right now look at how the bar is oriented it's looking quite a bit slanted that's because we have a perspective camera and it's looking from top down now this is one of those things that is kind of personal preference so maybe you don't like it just like this but a lot of the times you want these World UI elements to face the camera just like a regular UI one example of this problem is for example let me pick up the cutting counter duplicated and let's put one down here so rotate it upwards okay let's put it on 4.50 and minus 5. now if I place something on there and I cut it yep like that the bar is Now inverted so let's make a simple script to solve this problem let's go into our scripts create a new csharp script call it look at camera let's go on to The Cutting counter prefab let's open it up go inside on the progress bar let's attach the script so the unlocked camera okay now let's open so from here let's use an interesting function so let's use a private void late update so not update we have the late update so if this is the first time you're hearing about this like the name flies this one is going to run after the regular update so every single update and all the objects is going to run and then on the late updates so kind of like you've got awake and start you have update and late update why this is useful specifically for this script is because for this element you really want us to run the orienting logic you want that to be done after whatever that object does in the update in this case this object will never move so it's not really an issue but for example if you had some kind of moving vehicle with a warm cameras on top if you have that you would want to set the Warren canvas and location to unlock the camera after the vehicle had moved otherwise the canvas would not look perfect so anyways because that here we're doing on late update and now we can just look straight the camera so we can just do transform dot lookup and for the Target passing the camera Dot main.transform this function makes this transform look at another transform or another point so this will make it look straight at the camera also by the way one quick note here in some other tutorials you might see people telling you not to use camera.main the reason for that is because this field did not used to be cached so every time you use this it would cycle through every single game object in the scene until it found the main camera so that was obviously really bad for performance but nowadays this field is now cached by default on the ENT backend so you no longer need to Cache it yourself accessing it directly just like this is now fine okay so with this let's test just make sure to save the prefab and let's hit on play let's go ahead pick up a cabbage put it up there and if they're young look at that how it's looking straight at the camera and for this one down here same thing cut it any up there you go both of them are looking straight at the camera okay so that's great you can also see exactly what it's doing if we try to move the camera again we're using cinemachine so let's move the virtual camera so over here if I just play around with the position.x look at that look how as I move the camera yep the objects are perfectly looking straight at the camera so that's great that's what we want but also you might notice one thing notice under the bars are actually inverted instead of going left to right they're actually going right and left basically this has to do with how the canvas by default assumes you are essentially going to look at it from behind instead of looking forward so that is why when this game object is pointing straight at the camera it's essentially inverted so to sum this is actually quite simple we basically just need to look in the exact opposite direction but at the same time sometimes we might want this exact Behavior having something looks right at the camera maybe we do want it to be inverted sometimes so for that let's make a nice complete script with all of our possible options and for the finding options it's also an excellent way to learn about one more thing which are csharp enums enums are an enumeration meaning a fixed set of options that you can have of something so these are really useful when you have a fixed set of something like for example maybe a fixed number of options so for example up here let's make it private make it an enum and let's call it mode and then inside we can Define all of our options so let's say we have the regular look at it and then look at inverted okay so we have these two options in our enum now let's do a field of this type and expose it in the editor so let's make a serialized film private of type mode and call it mode okay let's save this and look what this looks like in the editor and if we go inside the cutting counter and we'll look at the progress bar even look at that the mode shows up and it shows up as a really nice drop down menu so since we have a limited number of options we've got a really nice menu where we can choose each round if you want so that's really awesome that's one of the benefits of enums they are really easy to use over here in the editor now back in the code here and let's decide which one to use so on The Late update let me just do a switch on our mode in case we are on the regular look at mode then let's see exactly this let's simply look in in case we are on the look at invertent for this we just want to look at the inverse position so that's actually pretty easy we just calculate the direction Vector from the camera to this object so a vector 3 call it deer from camera and to get direction from the camera we start from this object so this transformed that position subtract the camera dot main transform position so this gives us the direction pointing from the camera and then just to transform down look at and instead of looking at the camera let's look at the opposite position so let's look at transform that position so our current position points the direction from the camera so we're going to be looking at the exact opposite point okay so that's it let's test and right now by default we have the regular look at so let's just see it let's just play some objects okay so right now it's still inverting and something real nice is you can play around the enums even as the game is running so let's go inside the cutting counter on the progress bar UI for this one let's swap from Lookout to unlock inverten anything like that that one is now looking perfectly so this one is using Lookout and this one using look at inverted okay great it's all working however yet another thing that is all about personal preference note how the visual has a slight slant this is due to how the visual section looking directly at the center of the camera so you can really see it if I move the camera left and right how it Slants going left or going right again the Zone personal preference it's just a visual so maybe you do want this look but let's see another method so over here in our modes let's add two more let's add camera forward and Camera forward inverted and then down here on our late update let's add those so the camera forward and then we have the camera forward inversion so for this one for the camera forward super simple let's just take this transform use the forward which again you can get or you can set it and let's set it to the exact same one as the camera Dot main.transform.4 and for the inverting example the same thing X7 set of four do we do minus four okay so let's see what this looks like okay so here's the game with both counters they're both currently using the unlockit mode now if we put a look at inverting yep that one goes left to right okay great now if I put camera 4 in give a look at that now that one is perfectly straight so even as I move the virtual camera on left and right look how that one is always perfectly facing the camera as if it was a regular UI owned and for the inverter does the exact same thing but invert and so just like that so that's it these are the four modes again these are all just visual elements so pick whatever you prefer for me I'm going to be using this one the camera.4 so that everything is perfectly horizontal so I'm just going to make sure to go inside the prefab and on the prefab itself modified and set it as camera.4 and now if I add the cheese there yep looks great and if I had a cabbage here and yep it also looks right all right so here we created a really nice useful generic script to make an object look straight at the camera in various ways note how this one has nothing to do with canvas or a progress bar or anything it's really a generic script to look at the camera so you can apply this to anything where you want it to look at the camera okay so with that the cutting counter is fully done now let's handle the trash counter in the next lecture hello and welcome I'm your code monkey in this lecture let's create the trash counter this one is actually pretty simple it's how we're going to drop something and just destroy it okay so making the trash counter is going to be super super easy once again going to be another great practical example of the power of writing good clean code and having good organization in your project so let's do the same thing that we've already done a bunch of times so first of all let's make the prefab variant so let's right click on the base counter and create a brand new prefab variant come with the trash counter okay let's go inside and first of all let's drag the visual so find the visual prefab on the trash counter okay then let's duplicate it to make the selecting so let's rename this to selected let's add the selected counter visual let's add the visual inside of it and on the visual let's select the other material so the counter selected and finally on the selected put it one percent bigger 1.01 and start off with visual disabled okay so that's the basics just like we've already done so many times now let's make this script to run this so let's frequently create a new csharp script call it the trash counter and by the way here we're already starting to have quite a bunch of scripts so we should probably organize the scripts folder so let's make a new folder let's come with counters and let's make another one and call it scriptable objects so on the counters let's drag the base counter clear counter the container the container visual The Cutting The Cutting visual then down here the trash counter okay let's drag them all onto the counters folder and on these critical objects let's put the cutting recipe and the kitchen object as so okay now our phone there is a bit more organized so let's open up the trash counter and over here as usual let's begin by extending the base counter okay great then let's implement the regular interaction so override the interact and on this one again it's going to be super simple we just check if the player is holding something and if so we destroy it so just check if player that has kitchen object so if the player is holding something go into the player get the kitchen object the player is holding and simply call destroy itself and that's it it's this simple back in the editorial let's just attach a script let's make sure to drag the countertop Point reference and on the selected drag the base counter reference okay with this it should be working so let's exit the scene let's save the prefab and let's drag it over here onto our scene so let's drag the trash counter and put it maybe somewhere over here on the corner so let's put it here on an X of 7 y 0 and 3.5 then let's also fill out these spots down here so let's duplicate the clear counter put one in there put another one in there let's put another one on the side and for the crash counter and let's align it so let's put it a bit more to the side so on 7.5 okay great and let's put it inside the counters and now we can test okay so let's see if we can interact with it and yep as I approach yep I do see it highlighted okay great and if I interact obviously nothing happens since the player isn't holding anything now if I pick something up let's say a tomato and I don't want this tomato so I want to trash it and if there you go it does get trashed all right awesome so this is literally it like I said this is once again another excellent example of the power of writing good clean code this was super simple to implement because we have a really nice structure for how all of our Counters work also because our interaction system is very well built also because the kitchen object system is very well made it's because of all of that great very clean code that we were able to implement a brand new counter in literally about 60 seconds so once again I hope that by following this course you know understand why I'm always talking about the importance of writing good clean code it's exactly because this if you write your code correctly it makes developing the game so much easier at first it might seem like the quick and dirty approach is faster and usually in the beginning it is faster but as soon as you add some complexity the quick and dirty approach suddenly won't scale whereas the wellbuilt clean code approach this one will continue scaling very well so here we have a fully functional trash bin so we can dispose of unwanted objects next let's build a much much more complex Hunter let's build a stove counter which also requires building a really nice State machine so let's do that in the next lecture hey again another quick intermission you're past the halfway point so congrats again by now I really hope you've already learned a ton from the course we've already covered lots of topics and built a ton of systems I hope you've been following the website as you go through the lectures and I hope reading the frequently asked questions that I sent you in some way let me know in the comments how you've used the course website did you just read the FAQ or did you also download some project files let me know I'm curious to know if you enjoy my teaching song also look at my other courses after finishing this one especially the turnbased strategy course that one is an excellent followup for this one okay there's still quite a bit more for us to build and learn so let's continue in the next lecture hello and welcome I'm your code monkey in this lecture we're going to build the stove counter so we want to place some uncooked meat then we wait for a bit for it to be cooked however if we weigh too much it's going to get burnt so let's Implement that alright so as usual let's first begin by making our counter so let's go inside the prefabs the counters let's right click on the base counter and create new prefab variant call this the stove counter and as usual let's go inside of it let's find the visual so inside the prefab visuals it counters visuals here is the stove counter so let's drag it then let's duplicate this rename this one the selecton let's set the component the selected counter visual then let's go inside on all of these and by the way this visual actually has some nice visuals that we're going to implement in a little bit but for the selected we really just want the static objects so let's pick up all of these and let's select the counter slide visual okay nice and white then let's lock over here the parents so I can select all of these and drag all of them okay great and start off with all of them disabled okay so that's the basic setup as usual just for the Counterpoint since this one has a nice little sub on top let's lift it up by a little bit so put it on a y of 1.456 okay that looks pretty good just move it a little bit to the center okay great so now let's make our script so let's go inside our scripts folder we've got our counters so in here let's create the brand new csharp script for the stove counter let's wait for it to compile let's attach the script and open okay so here as usual let's extend the base counter now like I said the going for this one is to be able to cook our meat and for that it's going to be based on a timer and to actually cook the meat we're going to need to know which one is the uncooked meat type and which one is the cook me type so for that we really want the exact same logic that we did for the cutting action we want some kind of place where we can store an input and output as well as a cook timer so for that let's actually just duplicate so let's go inside our scribble objects for The Cutting recipe and let's duplicate this one so Ctrl D and let's name this one the frying recipe so okay let's go inside and over here let's rename the object then we have an input we have an output and then a set of progress let's have the frying timer Max and since this one is a timer instead of an in let's make it a float okay so that's it pretty simple then back here in the editor let's create our script mode object so let's go inside let's make a nice folder so a folder for the frying recipe so and inside let's create one so let's create a brand new frying recipe so for this one let's call it meat Patty uncooked into meat Patty cooked then for the inputs let's choose the meat Patty uncooked now we have to make the other one so let's go ahead and make that one let's duplicate this one rename it to the meat Patty cooked and the object name meat Patty cooked let's select the different Sprites so this one is going to be the meat Patty cooked okay and finally for the prefab let's also make it so for the meat Patty cooked let's go inside of it and also make sure to save changes on our stove counter it's okay now in here let's get rid of this Visual and use the other visual so we want to meet Patty cooked and let's make sure to drag the script monk object okay so it's all good here and let's go back outside save it and finally over here on meat Patty cooked let's just grab the prefab reference so there you go that one okay so this one is working and since we're here and let's actually make the other one right away so let's make the meat Patty burned so the prefab and let's also duplicate this to make the meat Patty burned then on the text let's rename this to Burnt let's choose the burn icon and for the prefab let's go into our meat Patty burned and swap it out for the burned one so there you go nice and charred and over here swap it for the meat Patty burned okay let's save it and finally down here just make sure everything is correct object the transform prefab just like that okay so all of our burn references over here all of our cooked and over here all of our uncut and again when going through this process always make sure that you match all the references on the certain objects and also over here on the kitchen objects so meet Patty burn yep meet Patty burn for the uncooked the uncooked and for the coke there it is okay everything is good great so now we can go back over here into our frying recipe so and for the output let's output the meat Patty cooked and for the frying timer let's put it on three seconds okay so that's it great now back in the code here on the stove counter let's add an array of our frying recipes so a serialized field private it's going to be an array of frying recipe so frying recipe so array make omelette frying recipe so a ring okay great then back here in the editor let's go inside the stove counter let's make sure to drag that so let's drag the mid Patty from uncooked into cut okay let's also drag the counter top point and finally since we already made the script over here on the selected we can also drag the selector okay so our stove prefab should be working okay let's go outside make sure to save the prefab okay now let's continue with the rest of the script so let's make our override so override the interact action and when we interact with it let's validate dropping the object just like we did on the cutting counter so let's go over here into our cutting count script and let's just copy pretty much the exact same thing so let's copy all of this interact code let's go over here in the stove counter and just paste it now we also need to copy in our recipe so over here on the cutting counter let's copy paste those functions so these functions go into the cell counter and over here on let's face them they're going to work pretty much the same thing so we get an input except instead of being a cutting recipe so we're going to have a frying recipe so so let's replace all the cutting recipe references with frying recipe reference then for the array this one is the frying rasps array and obviously let's rename these so Ctrl R to rename all of them into frying recipe so let's also rename the function instead of get cutting rest BSO it's the frying recipe so okay so there's no more mentions of cutting over here so let's use this function up here and up here and just make sure to rename these the frying recipe as so and down here on same thing so the frying recipe so okay so down here we have no more mentions of any cutting let's just go up here and solve all these problems so first we check if there's no kitchen object here and if the player is carrying something then we see if what the pointer is carrying matches any kind of frying recipe if so then the player is carrying something that can be primed then we set the parent and for now let's not worry about the progress so let's just get rid of all this just like this okay so with this we should be able to drop but only in uncooked meat so back in the afternoon let's just set up our scene so let's drag a stove counter onto our scene let's put over there on X of 6 y of 0 and 3.5 alright so let's test okay so now if I pick up some cheese I go up there and I drop it and nope doesn't work okay great but if I pick up some uncooked meat and I go and I drop it and yep that does work okay great so it works and I can only drop the actual objects and matchy recipe now unlike the cutting counter this one will not be based on a player alt interaction and actually over here and let's fix this minor issue basically we added this debug.log error to the base interact because pretty much every single counter is going to implement this interact function but not all encounters are going to have the interact alternate action so this one lets us do nothing let's not spawn error okay just a quick fix so like I said the stove counter this one is going to be based on a simple timer and for making some time based logic basically we have two approaches one approach is to use a simple foil timer or you can also use a coroutine now a lot of tutorials will teach you how to use a coroutine and that's not necessarily a bad practice it does work it does achieve desired result so to do that you would just make a function like Freight timer so you'd make a private you have to return I in numerator then call it something like handle fry timer then inside you can do a yield return and return a new weight for seconds and to start this coroutine you would do maybe on start you would call start Co routine and start the handle for right hammer so this one approach this is definitely perfectly foundly timer code however personally I am not a fan of coroutines it's not because of performance or anything it's simply because I don't like the pattern that they force you to use I don't like being forced to make a function that returns I numerator I don't like using yield return I don't like having to use the start core routine function I don't like being forced to use this on a monobehavior object those are all requirements for making a CO routine work and personally I find those are way too many requirements that create a very strange pattern that I really don't like so that's really the only reason I don't like Co routines because I find this pattern to be quite a lot convoluted so instead of core routines what I like to use are simple basic flow timers so just make a simple and private void update then we just need to keep track of a certain timer so for example a simple private float frying timer then on the update let's first check that we have an object so it has a kitchen object if we have a kitchen object then let's increase the timer by time dot of time by the way here when working with a timer you can increase or decrease it's pretty arbitrary both ways work the obvious difference is only if you test if it's above the max or if it's under zero in here for frying it does make sense to start at zero and then the defraying timer Max so either that and if the frying timer if it is bigger than the maximum so let's get the frying rest PSO frying recipe so let's get the frying recipe so with input so let's get this kitchen object and get the kitchen object itself okay so we go into the frying rest BSO and we get the frying timer Max okay so if it's above the max then this one has been fried so here I'll let you see what we did on the cutting counter so let's get this kitchen object and tunnel to destroy itself and then let's go into the kitchen object class in order to spawn another kitchen object let's go into the frying recipe and spawn the output and we're going to spawn it inside of this counter right so that's it this should already be working we don't have a visual yet so let's add a debug log so here just say debug.log on the frying timer and up here let's also just reset the timer so frying time now let's put it on zero f and let's also do a debug.log and say fried however like this you might already be guessing that we're going to have a bunch of bugs but still let's just test it just like this okay so over here I can move around I can pick up some uncooked meat I can drop it there and after a little bit there you go there's the timers and if there you go it did work you can see the timer increase until three then it was fried then it was reset and then we've got a known reference exception basically this is the exact same problem that we had on the cutting counter where first we put an object like tomato and that is indeed an input for a recipe so we cut tomato into slices but then the slices are not an input for any recipe so over here we put some uncooked meat so that's great we frying which means we destroy the uncooked meat and we spawn the cooked meat but then next time the cooked meat is not an input for anything so obviously this one is going to return no one thing we can do to sort of solve this problem which is also going to be beneficial in terms of performance is simply caching this field so let's go here to find a frying recipe a cell frying recipe so instead of constantly getting it on every single update which might be a bit costly in terms of performance instead of this let's just get it over here when the player drops something so the player drops something and we assign the Frank rest BSO so we sign it cache the value and then do this okay that should have fixed the nonreference problem but we still have a bunch more problems but still let's test it out okay so here let's pick up some meat put it there and let's look at the timer and if there you go everything is cooking great any of their yo it finished it cooked and the time was reset and now it's finishing it's cooking and so on so this is obviously another pretty serious problem basically it's constantly frying the meat and spawning more and more objects instead of constantly spawning from the same recipe what we want is for the stove to First fry the object but then if the object is fried then we want to burn it so really that means that we want the stove to have multiple States meaning that we're going to need to make a simple State machine so let's do just that now if you're a beginner the concept of a state machine might seem daunting at first but it's actually extremely simple at least to make a very basic one all we need is really just a bunch of saints so to define those States let's go up here and make a simple enum so let's make a private enum call it state and now let's put all the states for our state machine now for the server let's say we have idle when there's nothing on top then let's say we have a frying state for when the ingredient is actually being fried then we have fried for when the ingredient has already been cooked but it's still getting some heat and finally if we leave it too long in that state then everything ends up burned okay so these are all of our states for our state machine and how to make the actual stick machine it's actually quite simple first of all we just need to store the current state so here make a private of type State and sort the current state and then on update let's just do a switch on the current state okay now here basically we're going to do different logic depending on the state that we're at so let's say if we're I don't we do something then if we are frying we're going to do something else then if we are on the front also something else and finally if we are on Burn do something else so here are all of our states and the logic that we did down here this is the frame logic so let's actually just copy on this and let's face it inside the frying logic and for the seed machine we're only going to run any of these states if there's a kitchen object inside of it so it's actually put that switch in there just like this okay so that's it so when I don't we're not doing anything and when frying we're going to run our frying timer we're going to fry the object let's also get rid of the low we no longer need this then we destroy the current object and we spawn a brand new object now what we need is to handle over here the State field we need to modify this winching in Saints so first of all let's handle the start so let's make a private void start and on start let's begin with the state on state DOT Idol okay great then down here when we interact when the player drops something when the player drops something that can be fried over here on let's set the state and put it on state DOT frame and over here we should also probably reset the timer so let's set the frying timer back into zero f okay we set the timer and we reset the state finally up here let's not reset the timer since we're resetting the timer down there since it makes more sense down there so we do the frying the frying timer we end the frying and then obviously we need to modify the state so modify State and put it on state DOT fright okay so that's the basics of our state machine with this everything should be working just the same as previously except we're only going to fry once so let's actually just put them out here debug the hog object Pride and let's put one down here outside of the save machine just do a debug.log on the state okay like this let's test okay so here we are let's pick up some meat and drop it on there and there you go it goes from idle directly into frying and then it's fried and after you go now it stays on fried so it no longer goes on frying and it's no longer spawning any more objects it went from frying into fried and yep everything worked alright awesome so we have the Frank State working perfectly now let's handle the burning in terms of logic it's really going to be the exact same thing we're going to have a frying timer so let's copy this code and paste it down here now technically we could reuse the exact same float timer but that would be a bit confusing so let's keep our code as clear as possible and really just make a different timer with a more descriptive name so pure a private float called The Burning timer then let's initialize this timer so when we go into the fried State let's set the timer the burning timer into zero then down here let's use this Burning timer okay great when timers and lapse and the object is spawn let's go into the Burnside and obviously we need another recipe so let's make another scriptable object back in the editor let's find the frying recipe so let's duplicate this call it the burning recipe so then over here let's modify the name instead of frying timer Max let's call it burning timer Max okay great so now over here on the stove let's use pretty much the exact same thing and let's make over here private of burning recipe so the burning recipe so then down here we just need a function to get the burning recipe so so let's copy this and paste it over here this one's going to return a burning rest BSO so let's replace this and this rename this into burning recipe so we're going to need an array and over here let's just change the name instead of frying recipe so the burning recipe so let's just find a new array so let's go all the way up here make another array an array of burning recipe so and this is the burning recipe SL ring and finally if we go down here let's use this array okay that's it so now let's use this function to set our burning rest BSL so when we set it to find let's set the burning recipe so and let's get it with the input and the input is going to be the object that is on here so the kitchen object dot get the kitchen object.so okay so we're initializing our fright State and setting up the burning recipe so and over here we use that one dot Max and we get into that one and use the output so over there object frying over here object burned all right so that's pretty much it we modified everything to say burning timer over here we are correctly initializing so we go through the burning timer through the burning rest PSO which we are grabbing up here then we spawn the output on the burning rest BSO and we go into state.burn okay so all that's left is just filling in this array so back in the editor over here on let's make the object so let's make a brand new folder for the burning recipe and so and now inside let's create a new Burning recipe so call this one the meat Patty cooked into meat Patty burned and over here let's set the input so the meat Patty cooked onto the meat Patty burned and for timer let's make it take a bit longer to burn so let's say five seconds okay that's great let's just drag the reference so let's go into the stove counter and let's make sure to open up and go inside the prefab and over here on the prefab just write the burning recipe okay that's great let's go outside save the prefab and let's test alright so here we are let's pick up some meat drop it on there and look over there it's frying and after a bit yep it's right there you would spawn that one and now if we wait for five seconds it should go from frying to burn any up there you go that one is charred everything is burned everything is great all right awesome so everything worked as intended with this song of our logic is working now let's handle on picking up objects from the stove now technically it's already working so I can approach yourself and pick it up the object and there you go drop it in there so that does work however if we look over here in the log the state machine is now in the wrong state so over here let's do a quick fix let's go down into the interact action okay so here it is so if there's no kitchen object then the player places it okay that's good but if there is a kitchen object so if there's something on the stove counter when the player picks it up let's also manually set the state and put the state back into idle just like this okay that's it so let's test okay so over here let's pick up some meat put it in there it's cooking and let's wait until it gets finished yep there you go it's done pick it up and there you go out now if I want I can put another one and if there you go the logic is reset and everything is back to normal okay great so often logic is working perfectly now let's just get rid of our logs so we don't need this so let's get rid of that debugging log this one and this one okay great everything is nice and clean and now let's add some nice fun visuals so if we go inside the stove counter and over here is the visual and I include these two prefabs inside the visual so one of them this one the stove on visual this one is just a glowing red square now again there's a weird bug on this specific empty version so post processing isn't showing over here on scene view but if I leave it enabled and I go back outside and now from work in the game view if there you go there's a nice glowing red square if you don't see glowing make sure you add the balloon post Crossing effect so if you missed something you can go back into the postprocessing lecture and make sure everything is set up correctly so there's a nice glowing red square and there's also a bunch of particles so you can name on this one press on restart and there you go just some nice particles just jumping up this was made with the unity particle system so for example on the hierarchy you can right click go up here into effects and you can create a particle system so that's what this is it has a particle system over here you can see all of the various settings for these particles they just jump up and fall down so for jumping up that is the emission you can actually see a visual over there of the cone that is the spawning cone which you can find over here on the shape so in the shape it has the shape of a cone then you can see the radius radius thickness and so on so that is from where the objects are being spawned then up here you can see the lifetime of each object so each particle is going to last for 0.7 seconds you can all see the speed so that's speed at which they come from there the start size that's how big they are on start and note how the particles are spawning jumping up and falling down so that Falling Down is over here the gravity modifier if you put it at zero then they just keep going up and if you put a two yep they go up and they fall down next down here on the emission this is how many are being spawned so if I put this on 200 there you go tons and tons of particles next is over here the size of our lifetime so this one has just a basic curve so they started off on font size and over the xaxis this one is in a lifetime so as the particle goes from the beginning until the end their life they basically go down on size so that is why they become quite a bit smaller also by the way this one down here this one is called an animation curve this is another really useful ENT feature I have a dedicated video on animation curves and finally down here just have the renderer so it's just using some basic particles so we can inspect the material simple in the assets and there you go we're just using the default particle material just with the alpha on half and that's pretty much it so as you can see just a very basic very simple particle system now all we really want to do is just for both of these we want to enable or disable them depending on if the stove is on or not so let's make a script to handle the visuals so let's go down and create a brand new csharp script let's go with the stove counter visual then let's go into the stove counter Visual and let's attach the script so here it is attach it and open right so now here we just need references to those two objects so as usual let's make a basic serialized film let's make it of type game object for the stove on game object and the other one is the particles game object okay let's save and back here in the editor let's drag the references so the stove on Visual and the sizzling particles okay great so now all we really need to know is know when to turn these on or off and for that is really going to be based on the state over here on the stove counter so if it is on the state frying or fried then we want to show them if it is on idle or burned we want to hide them but as usual we don't want to mix the logic and Visions directly so let's do that through a really nice event let's make a public event let's use a standard event handler let's call it on stay changed and let's also include the state on the event Arc so let's make a public class call it on state change event args and let's expand event arcs and then in here let's just put a public state for our state however here we also have a really nice error so this one is telling you there's inconsistent accessibility basically that's because we made this one public so any class link for his Mr visual class can indeed see this class however from outside that class cannot see the private state so that is why we have inconsistent accessibility we cannot have something public which inside has something of a specific type which is private so in order to make this work we need to modify this state and make it public so that the other classes can see it okay so that's great now let's just fire this event whenever the state changes so over here when you go into the frying State let's go and invoke and as usual just this and I actually forgot to add that so let's go up here let's use the one with generics so the on state change event arcs okay great so then down here we invoke the event let's create of this time and inside passing the state equals this state okay so this one we need so then down here go into the burn State let's fire the event and down here frying fire the vent and on idle fried event alright that's it so we have all of our state logic and over here on the stove counter visual obviously we need a reference to the counter so let's add that so a serialized field private maker of type stove counter for the stove counter and then we can do an as usual for accessing external references let's do it on start go into the stove counter and let's listen to the on say change event and over here it's going to be very simple we just want to show if it's on the state frying or fried and if not we don't want to show so let's define a bone called show visual and this one is going to true if the E dot State equals the state DOT frying or E dot State equals the state DOT fried so if it's either of these then this is going to be true if not it's going to be false so then let's just go into the stove on game object and constant active and pass in this and same thing for the other for the particles game object okay that's it super simple let's just drag this reference so over here inside the prefab just drag the reference let's leave the prefab save the changes and let's hit on play and all right so it starts off disabled okay so there's no visuals now if I pick it up and I drop it and there you go a nice visual so the glowing red hot and the particles and now it's running and if I leave it until it burns when it burns and it's going to turn it off and if there go turns off all right awesome so now if I pick it up wait until it gets cooked so let's go pick it up and the other you go turns it off all right awesome we've got a really nice visual all that's left is to have a proper visual progress bar and with this we actually have another interesting clean code question right now the progress bar that we made over here on the cutting counter that one is great so we would like to reuse that however if we look over here on the progress bar UI we can see this is only working with the specific type cutting counter so by default this will not work with a stealth counter so as usual we have multiple approaches to solving this problem one option would be to Simply commonly duplicate the script then we would make a completely different progress bar UI class that would work only with the stealth counter so that's one approach that would work and that approach might be good if you want the progress bar to behave very very differently but over here I want both of them to behave exactly the same so instead of having some code application we can write some good clean code but doing exactly what we did with regards to the kitchen object parent meaning we can use a nice interface we can then Implement on anything that has some kind of progress so let's do exactly that first of all let's actually go inside the cutting counter so let's go inside the prefab then over here we've got the progress bar and this one is just a regular game object but since we're going to reuse this let's make this a proper prefab so let's find over here all of our prefabs and just drag the progress bar UI inside the prefabs folder okay great so this is now a proper prefab now let's define our interface so let's create a brand new csharp script as usual interface start with I so let's go on I and for this one we wanted to represent anything that has progress so let's just call it literally has progress personally I like to use the word has to indicate that a certain object has certain Behavior so in this case objects that implement this interface will have some kind of progress Behavior so now over here for the interface let's first make it so this one does not extend amount of behavior instead of a quest this one is an interface okay great so now for the functions that we're going to need if we look in the progress bar and we'll look at the cutting counter references we can see the only one is literally just this so we just have to listen to the event and then the rest of progress bar Works inside of it so real and interface is the only thing we need to Define so let's actually go inside the cutting counter so here we have the unprogress change event and then we have this so we can literally just copy this go into the I has progress and let's put exactly this okay that's it that is literally all we need now if we wanted we can also make a function to expose the progress amount but since we included over here on the event then we really don't need it just this is enough now let's go over here on the progress bar UI script instead of working with the type cutting counter instead let's work with a type that has I has progress so let's rename this Q has progress and it's going to have the exact same event the only difference is over here instead of the event RX being the one inside the cutting counter is the one inside the eye has progress so let's make sure to change this I has progress okay so the signature matches let's just obviously rename this so let's rename instead of cutting counter let's rename has progress on progress change and that's pretty much it we don't have any more errors so everything over here is now working nicely with our interface and back here in the editor once we're still inside the cutting counter suddenly interfaces do have one downside when it comes to Unity if we look in the progress bar UI down there we can see the progress bar UI and previously we had the counter field exposed in the editor however now by changing into an interface there we have the issue the film does not show up here interfaces do not show up in the editor because Unity basically has no way of knowing that the interface won't be implemented by some kind of game object so sadly this is the one thing that doesn't work very well with unity the solution that I normally do is actually pretty simple instead of exposing the interface which does not work and said let's just make this a regular private field and then let's make a serialized film and for this one let's make it a type game object and let's call it has progress game object okay so like this we have a regular serialized field with a regular game object so if you look here yep we do have that field so now we can indeed Drag The Cutting counter reference and then over here in the code in order to get the has progress that is super simple has progress we just go into the hash progress game object and get component of type I has progress okay so that's it now our code does work however of course one big potential issue with this is that over here we have a field of type game object meaning that we have no guarantee that this field does have a component that implements the interface so we cannot make sure that we drag the correct reference we can drag any reference doesn't have to have our progress interface so in order to keep our sound safe let's add a nice safety warning so over here if has progress equals no so if this one is known that means that that game object does not have any progress interface if so let's do a debug download error and let's say the game object and let's pass in this game object does not have a component that implements I has progress so this way if we make a mistake we won't have a nice error message basically this is the one workaround that you need to use since Unity does not support dragging references in the editor if they are interface references okay so with that everything is good so all of our progress bar UI this should all be working perfectly we just need to go over here into our cutting count script and let's make it so that we Implement our interface so I has progress and we got an error just because even though we did Define that interface remember the on progress change again keep in mind that the types depend on not just their name but where they're at so this type that we have here is the one that we Define here which is not the same one that we have here so even though they have the exact same name because they are in different places they are actually different types so we need to make sure to use the type in the interface over here let's just go into the I has progress and use that exact type and get rid of this one okay so that's it that's the change we need and down here when firing let's just fire with that type and down here the same thing with that type okay great so like the this The Cutting counter should still be working exactly the same as previously again when refactoring any code always do a quick test and let's do that let's make sure to save our counter save the prefab go back outside head on play now let's pick up some cheese put it there cut and there you go the progress bar still does work okay great now let's apply it to the stove and that is actually going to be very simple first let's go inside the stove so let's find the stove counter let's open it up go inside the prefab and over here let's drag the progress bar UI prefab so let's drag that then down here we already have the has progress game object so let's drag the stove counter and that's it there's nothing else we need to touch here we just need to go over here into the stove counter and as usual let's implement the interface so the eye has progress and now let's implement it pretty much just like we did on the cutting counter so we can actually just copy this so we just need to implement the event so that's it and now for firing the event let's go down and see where we are modifying all of our timers so let's go down to when the player drops something so we do the on say change and now let's invoke this event so this and for the progress bar for the progress normalize this one is very simple so just frying timer divided by the frying recipe so dot frying timer Max okay that's it we are modifying the progress now let's go up here when we are in the Frank State and when we do let's fire off the on progress change event okay great and finally down here when we have defined over here let's also fire except obviously we have the burning timer and the burning timer Max and then just to make sure that the bar actually hides itself when we go into burned let's also find an event this one doesn't have a timer so let's just put it on xeraf okay that's really it we don't need to touch the progress bar UI at all Let's test this just make sure to save the prefab let's go back outside and hit on point and right away yep the bar is indeed hidden now if I pick up some meat and I drop it and there you go got a really nice bar going up any up going up on the burning site and let's get to the end let's see if the bar hides so it gets to the end and you have to go the bar that's high all right awesome and if I pick up something actually this was the one event that we forgot so let's fix that so let's just copy the one where we set the progress normalized to zero and over here if the player picks up something let's add the progress back into zero so here we are let's pick up some meat drop it on there okay let's wait for it to be cooked okay it's cooked now before it burns pick it up and there you go the bar is gone all right awesome okay so here we have again another example of the power of writing good clean code we made a nice generic progress bar and we very easily made it work with a completely different counter which of course would also work with literally anything that implements that interface doesn't have to be a counter now let me make one note here basically I showed you how to make a generic progress bar and reuse it but let's say you want to do something specific just for the solve well one approach like I mentioned is to duplicate the code and make a progress bar that works only with the solve but another approach is to Simply add more elements on top for example during the Polish stage we're going to do exactly that we're going to add an extra UI element that won't show up to one of the player when the food is about to burn so I just want to point out how you can mix and match both them you can have both generic components coupled with specific components but for now our progress bar everything is looking pretty good so let's leave that burn warning just for the police age now the next very important thing we need is some points so let's do that in the next lecture hello and welcome I'm your kudmaki in this lecture we're going to create the plates counter this one is just going to spawn some points which we can then pick up to grab some objects okay so let's begin making the counter as usual so let's go inside our prefabs inside our counters right click the base counter make a new prefab variant called the plates counter let's go inside and let's drag the visual for the plates counter let's go into scene view so we can see it okay let's duplicate this make this the selected let's go inside and we can actually hide the Eternal Sprite we only need this one so on this one let's modify it for the counter selected on the selected let's make it just one percent bigger and let's add the selected counter Vision okay then inside obviously drag the reference for the kitchen counter okay that's our basic setup now let's make our script to run this so let's create a brand new csharp script for the plates counter let's attach the scrub to the plates counter and open okay now here as usual let's extend our base counter and then first let's handle the spawn timer logic so basically we want to spawn some plates every once amount of time somewhat sorry simple float for the spawn plate timer then let's make a simple update on timer let's increase the spawn point timer by time dot of time and then just check if it's above a certain maximum so if it is above something in this case we're going to have a fixed value but still like I mentioned in the very beginning of this course let us not use magic numbers here you should never use magic numbers instead if you wanted to make it edible you could also make it up here as the serialized field but in my case for design that I'm going for I'm perfectly content with having a fixed value so just appear pretty simple the spawn complete timer Max and let's define it to 4f and let's use it over here okay great so this is what we want however for spawning it's actually going to be a bit tricky the plate is supposed to be a kitchen object the player should be able to carry the plate and right now for design that we Define is that each kitchen object can only have one parent and each parent can only have one object but over here we want to spawn multiple objects now let's quickly see what happens if we try spawning multiple as usual so let's just go into the kitchen object spawn a kitchen object which means we need the plate so so let's do it up here as usual a serialized film private kitchen object so for the Plate Kitchen object SL so we're going to need to make this and then we're just going to spawn this object on this okay so this is going to throw an error but so let's see let's first create the object over here let's go inside our objects our kitchen objects let's create a brand new kitchen object call it just the plate for the object name this one is a plate for the Sprite let's go with the plate Sprite and for the prefab let's make it so let's duplicate one of these called the plate let's go inside it and obviously make sure to change say the changes then over here let's drag the plate visual get rid of the tomato and on the plate let's make sure to assign the plate and finally let's exit this let's make sure to save it and on the plate let's drag the plate prefab okay so we have the kitchen object so now let's just go inside our plates counter and over here let's drag the reference so the reference to the play kitchen object let's also drag the reference to the counter top point then on the selected drag the reference to our base counter and finally start off with a selected disabled okay so this should be working let's just add a plate counter over here onto our scene so let's pick up a police counter and put it somewhere in here over there on the side so on an X of 7.5 then 0 and let's say on zero Maybe let's make sure we have space for one more counter over there so let's duplicate this empty counter and let's put it over there pointing to the side so this one is on 7.50 and 2 okay so now let's just make sure that they perfectly match so let's put this one on a set of minus 0.5 okay so let's test all right so here we are and look at that and after four seconds if there go it spawns the object and then it immediately tried to spawn another one and there you go we have the error kitchen object parent only has a kitchen object basically the way we designed our game and set up the code assumes that a single encounter will only hold a single kitchen object so we cannot have multiple plates on the same counter now when solution for this problem is actually quite simple when we spawn the plates instead let's not spawn a kitchen object instead we're just going to spawn a dumb visual then when the player interacts with the counter that is when we're going to spawn the proper kitchen object so let's do that although again let's keep the logic and division separate so over here let's first just handle the logic so we just need to keep track of how many points respond so for that let's start up here you private end for the plates spawn amount and let's also do another private end for the plates Pawn amount Max and let's say we can spawn at most four plates okay so over here instead of spawning the object let's first of all actually reset the timer so let's put it back to zero zero and on the plate spawn the mount let's check if this one is under the plate spawn Max and if so let's go into the plate spawn amount and increase it by one okay so that's logic super simple now let's send the visual so let's first make our script so let's create a brand new csharp script for the plates counter visual now let's make sure that the visual so let's go inside the prefab and over here we've got the visual let's attach it okay open now here basically the first thing we need is we need to know where to spawn the visuals so let's actually add a reference to our counter top point so let's add a serialized film for private transform for the counter top point then let's also add a reference for the prefab we're going to spawn so let's call it the plate visual prefab then here in the editor let's drag the references so the countertop Point Place it in there and for the plate vision prefab let's go a pair and find the visuals for the kitchen object so these are just the visuals and let's write the plate visual so the plate visual not the Plate Kitchen object okay now back in the code here we obviously need to know when I play this Bond so let's go into the plates counter and make a nice event so fun week event event handler as usual on plate spawned and down here let's just find the event so we just invoke with this and eventar is not empty okay that's it very simple and then on the other script over here let's just listen to it which also means that we need a reference to our counter so let's add up here the plates counter for the plates counter so we're going to need to drag the reference and then on start let's listen to the on plate spawned event and when that happens then let's spawn so let's call instantiate on the plate visual prefab let's put it inside the counter top point so this is the transform for the plate visual transform and that's pretty much it okay so unlike this it should be working when the plate is spawned we should be spawning a brand new visual back in the editor we just need to drag the plates counter reference like that let's exit save the prefab and let's test okay so here we are and if we wait for four seconds we should be able to see a play spawn yep there you go and if we wait for a little bit more we should also be able to see some more play Swing spawn except we can't really see them that's because we're spawning them on the exact same spot every time but if we pause the game and over here I'm looking the hierarchy and find the plate counter and inside the counter top Point yep we do have four visions and if we wait for longer then nope it's not going to spawn anymore it's only going to spawn four plates okay great so some of the visual let yourself set them by a tiny bit to know how much we shouldn't offset let's keep track of how many plates haven't spawned so let's store up here on the visual script in list of Game object call it the plate visual game object list let's also make sure that you initialize this so it lets you on awake let's initialize this list and then when we spawn them okay so here we have the object that we spawned now basically we just need to modify the low composition and let's put it on new Vector 3 on the X so let's put it on zero then on the Z we're also going to have zero and then over here on the one let's offset it by a certain amount and basically it's going to be based on how many plates have been spawned so let's define up here a float for the plate offset y let's put it at save 0.1 f and over here we're going to offset it by this much multiplied by how many plates have been spawned so we can go into our visual list account so you can delete this and then we just need to add it to the list so let's add this plate visual transform.game object okay so now each game object should respond at a different height so let's see so here we are and if we wait for four seconds we should be able to see a plate and there you go and now after four seconds we should be able to see another one placed slightly above and yep there it is okay great so everything is spawning perfectly both in the logic as well as the visual now let's actually pick up a plate so on the plates counter as usual let's implement the interact so let's do a public let's override the interact function and now for picking up let's first see if the player is actually emptyhanded so if and we check the player has kitchen object so if the player does not have a kitchen object then the player is emptyhanded okay great then let's see if we have a plate that we can give them so if the plate spawned the mount if it is bigger than zero then there's at least one plate here and if so let's give it to the player so how we do that is one over here for logic let's just increase it by one then let's actually spawn the object so on the kitchen object let's spawn the Plate Kitchen object so and spawn it on the player and finally we just need to update the visuals so let's make another event so up here on plane spawn and on plate removed okay we have this event and then down here on let's just whenever the player picks it up let's invoke this with this an event RX dot empty okay great so now the visual let's listen to this so we're here on start for the plates counter listen to this event and when this event happens we just want to destroy the very last plate so let's grab the game object for the played game object and recently just going to go into our list so the plate visual game object list and let's pick up the very last one so let's go into the list.count minus one so this is going to be the very last element of the list then let's remove this one from the list so Point dot remove this one that we just grabbed and then we simply call destroy on this one all right so that's it super simple so we're here on the plates counter we do all of our checks we cut it down by one we spawn the actual kitchen object then we fire the event and over here the event listens and updates a visual okay let's test so here we are let's wait for a play to be spawned and when this phone there it is I'm going to pick it up and if there go the player is now carrying a plate let's drop it here and there you go there's another one now let's wait for a bunch more to be spawned okay so the plates counter is full now if I pick up it should only eliminate the last visual pick it up any of there you go it'll eliminate that one now I can drop it in there any other ones one all right awesome okay so that's really it for the basics of the play counter it periodically spawns some points which the player can then pick up now in the next lecture we're going to add the ability for the player to be holding a plate and pick up another object onto the plate hello and welcome I'm your code monkey in this lecture we're going to add the ability for the player to be carrying a plate and pick up objects onto that plate okay so here we already have the plate counter working it has some basic logic after a bunch of time it spawns a plate it spawns up to a certain maximum and I can pick up a plate and if the player is carrying a plate so I can put it anywhere then I can for example pick up some Tomatoes slice them and pick them up however now I am not able to place the tomatoes on the plate so let's add that logic let's begin over here on the clear counter script first we're testing if there is no catch an object here and the player is carrying something that the player drops something in there but then we're testing if there is a kitchen object here and if the player is carrying something so it's over here that we want to check if there's something that the player is carrying if it is a plate now our plate is also going to have a bit of custom logic so to help both identify and hold that custom logic let's make a proper script to handle it so back in India let's create a brand new script currently the Plate Kitchen object and let's open this now over here on this one instead of extending Model Behavior we're going to extend kitchen object so the plate is really just a more specific type of a kitchen object again like I mentioned quite a while ago you want to be very careful with inheritance you need to have a very good reason to do it here we want the play to behave exactly like a kitchen object just with a tiny bit of extra logic so in this case it makes perfect sense let's just go ahead and save this and wait for ENT to compile and over here let's find our kitchen object with the plate so here it is the prefab as you can see we have a kitchen object now instead of having that one let's replace that with the play kitchen object and since we are extending kitchen object we have the same Fields so let's make sure to add the kitchen object as so and get rid of the other one okay great so now back here on the on your counter when there is a kitchen object here and the player is carrying something we can check if the player is holding a plate and for that we can check the type so if let's go into the player and let's get the kitchen object the player is holding and we test if this object is of type Plate Kitchen object if so then that means player is holding a plate and if that is the case then we basically want to give the player whatever object is over here we want to add it to the plate so let's go into the plate script to add that function so over here let's make a public Point let's call it add ingredient as a parameter we're going to receive a kitchen object as so we really only care about the type we're going to destroy the actual kitchen object like we've been doing when creating different types so the plate is really just going to store in list of types so here let's store a list of kitchen object a cell for the kitchen object that sell list then when we add the ingredient let's just add it to the list so this kitchen object is so let's also make sure to initialize the list so let's see what I'm awake let's initialize our list and now from the other side we just need to call this so over here on the clear counter if the player is holding a plate let's first get the type of plate so play kitchen object or the Plate Kitchen object we go into the player to get the kitchen object and we cast this as a plate kitchen object okay so we have this and then over here let's call add ingredient and let's add whatever is currently on this counter so let's get the kitchen object and get the kitchen object itself okay so we're adding it to the plate and then let's destroy what is here so get kitchen object and destroy itself okay so that's it so if there is something here and if the player is holding something and that's something the player is holding as a plate if so we're going to add that ingredient to the plate and then destroy the object in here so let's test okay so here let's pick up a tomato let's slice it let's put it on a clear kitchen counter because that's the only one where we added logic so on this one let's pick up a plate and now whilst I'm carrying the plate and if I approach and I interact with it and if there you go it does work the object vanished from the counter and supposedly was added to the plate again we can use a really nice debug inspector to see it so let's pause the game Let's select the plate let's see the play kitchen object so here it is this one and let's change the inspector into debug mode and down here yep we do see the kitchen object that's on list and it does have some tomato slices okay awesome so with this here we have our basics we can have some ingredients and we can basically pick it up from a plate now one thing about our plate this is where we're basically going to carry the final recipe that we're going to deliver to the customers and based on the design that I defined I want something pretty simple meaning for the design that I'm going for there won't be any kind of double burgers or double cheese so each final recipe will only have at most one of each ingredient so let's add some basic logic just to prevent adding duplicates over here on the Plate Kitchen object when we add an ingredient since the function will now not necessarily succeed every time let's actually rename this and again use a very useful Visual Studio shortcut so you can press Ctrl RR or right click and let's rename since this function will no longer succeed we're just going to try to add an ingredient so try add ingredient and then let's also make it return a buoying basically for any function where you're not sure if it won't succeed I like to add try and make it return ball so this way it works pretty much exactly like the try again component that we've already seen so many times so it tries to do something and returns whether it succeeds or not so over here instead of always adding the ingredient let's see if this one is a duplicate so let's do an if and let's go into the list and check if the contains and if the list summary contains this kitchen object as well if though then already has this type so let's return false and if not then that means it's a brand new ingredient so let's add it and return true okay so that's it now let's go over here onto the clear counter so we try to add the ingredient but then we only want to destroy if this one succeeds so let's put this one inside an if so if we do manage to add the ingredients then yes let's destroy itself if not then we don't destroy anything okay so let's test so let's go ahead and slice two tomatoes so one slice it put it here then another one slice it and put it here now let's pick up a plate go up here try to pick up this one and yep it does work now for this one and I hope it doesn't work okay great now one more thing in our logic we only want to pick up certain things like I said only things that won't be used in the final recipe for example no customer is ever going to request a full entire tomato the recipes only have sliced tomatoes so we should not be able to drop a foam tomato directly on top of a plate so let's change that so over here on the plate script let's basically just create a list of our valid ingredients so let's make a serialized film private make it a list of kitchen object SL ope and call it the valid kitchen object SL list okay so we have this list and over here in the editor let's just write the ones that we want so let's first of all select the plate object okay here is the flight prefab and over here we've got all of our kitchen objects so let's just write the ones that we want to add to the point so the final recipes will have some bread yep but they will not have entire cabbages they will only have cabbage slices same thing no cheese only slices for the meat we're only going to be able to add meat cooked but also meat burned then we're not going to be able to add a plate onto a plate of course not and finally inside of a tomato just tomato slices okay that's our Vellum list and over here again it's very simple so we can just go if the evaluate kitchen object that's on list if this one contains the one that we want to add then we can add it but if not then let's return phones not a valid ingredient okay so let's test alright so let's pick up a tomato and also some tomato slices and now if I pick up a plate and I go into the Tomato nope doesn't work but the slices yep it does work okay great so here we have all of our basic plate rooms everything is working perfectly but it's only working over here with the clear counter so let's do a little bit of code cleanup and then let's add this logic to all the other counters so first to clean up this cone over here we are testing if this is a plain kitchen object then we cast to an object and then we count the function so let's simplify all this and let's do it just like yinty does with their try and get the component function so let's make a custom function that takes an output parameter the best place to put it is on the kitchen object so here we've got the kitchen object script okay great let's scroll down and make a nice function here so let's make it public we're going to return Boolean in case this succeeds or not let's currently try get plate and over here let's make an out parameter so don't forget the out keyword let's return of type Plate Kitchen object for the play kitchen object then over here we do examine what we did so we test if this object is a plate kitchen object if so then let's set the play kitchen object equals this as a play kitchen object and we return true but if not then this is not a plate so let's return false and one thing when working with output parameters you always need to make sure to set the output before you exit the function so over here that's the error that it's telling us we must assign it to something when we return so over here we don't have a play kitchen object so to solve this we just set this to no okay great now over here on the clear counter instead of doing all this basically let's ask the player if this is a kitchen object so let's try to get the plate out Plate Kitchen object for the Plate Kitchen object so you try to get it then we try to add the ingredient and so on now obviously we could further simplify things by making a function that would try to get the plate and try to add the ingredient that could work but since some counters are going to have a bit more custom logic I think keeping them separate like this makes more sense so first we try to get the plate then we try to add the ingredients so let's apply the same logic to The Cutting counter so over here on the cutting counter let's scroll down to where there is a kitchen object here and the point is carrying something so on the earlier counter we just want to copy all of this so let's go over here and we do the exact same thing okay that's it and the other counter from where we can pick up things is from the stove counter so here we are on the stove let's scroll down until we find the interaction okay there's something here The Player's carrying something so it's over here let's do that and do the exact same thing except on the stove again let's remember that this is using a save machine so when we pick up something let's do pretty much the same thing that we did here so let's make sure to reset the State Fire the events and so on okay so those are the only counters that we need to implement we cannot drop things on top of a container we cannot drop things on top of the plate counter or the trash so these are the only three types that we need to implement so with this let's test okay so let's begin with some meat so let's pick up some meat put it on the stove let's pick up a plate wait for it to cook pick it up any up there you go it does work now it says the cut encounters and let's pick up some cheese and let's slice it pick up some plate and go any up there you go it does work and again if we inspect we can make sure that it is indeed working so let's get into the plate and let's put this on debug inspector and if there we do see this one has a meat Patty cooked and some cheese slices okay great now the last piece of logic that we need is pretty much the opposite so right now it works if there's a sliced object on the plate and the player is holding a plate object but now we want the opposite so let's say there's a plate in here and we slice some cheese and now I want to drop the cheese on the plate so let's do that and basically for this one this one is only going to happen on the clear counter that's the only counter type that can have a plate on top of it so over here on the clear counter then we check if there is no object there but that's not what we want we want if there's a plate on the counter so if there is an object there and if the player is carrying something then we check if the player is holding a plate but if not so if the player is not holding a plate so player is not carrying plate but something else over here we need pretty much exact same logic except just testing for the object on this counter so let's do if let's get the kitchen object on this counter this one try to get the plate so out play kitchen objects for the Plate Kitchen object so if so if so there's a plate over here that means the counter is holding a plate so then let's go into this play kitchen object let's add the ingredient and we're going to try to add whatever the player is currently carrying so the player dot get kitchen object and get the kitchen object as so so we're going to try to add this and if we can add then we're just going to destroy whatever is on the player okay that's it and over here we've got a nice error just because we've defined it with the same name appear so up here we're already defining the variable and over here we're defining the same variable with the same name so we can either give this a different name or just not Define a brand new variable here so just it's a fine up here and we're using it here okay so while logic is working now here make very sure that you're not mixing references keep in mind when you're referencing the kitchen object on this counter and the one on the player those are two different things so over here if the player is not carrying a plate but something else then you check the kitchen counter so over here you're not checking the player but checking the counter then you go into that point and try to add the ingredient and you try to add the one that the player is carrying and then you destroy the one the player is carrying so again be very careful here make sure you don't mix references so with this it should work so let's make sure to save our script and let's test okay so here we are let's first pick up a nice plate let's drop the plate in there pick up some bread drop the bread any of there you go it does work alright so now we can do a bit more natural interactions so for example let's pick up some meat and put it on cooking and there you go the meat is fried so now I'm currently carrying just some meat so I place it there then I pick up some bread and put some bread on top of the meat and yep everything does work policy okay so here we created the plate and we created some custom logic to Define what the plate can and cannot account no that's left is actually being able to see what is on the plane so let's do that in the next lecture hello and welcome I'm your code monkey in this lecture we're going to add a nice visual to our plate okay so right now we can already pick up ingredients under the plate so if I pick up the plate and I pick up some cheese there you go there's some cheese on the plate but we cannot see it so let's solve that and we were going to do that it's actually in a very simple way if you look in the included assets inside the prefab visuals there's this nice plate complete visual that I built basically it's a foam burger that contains all the ingredients what we're going to do is actually very simple we're just going to enable or disable these game objects that's it so let's do example that let's make a new csharp script quality plate complete visual let's attach a script over here and let's also make sure to put this one inside the plate so let's save this prefab let's go inside the play prefab so inside the prefabs here the kitchen objects we've got the plate so inside of the point let's drag that let's drag the plate complete visual okay great so now let's open up this script over here on let's first have the reference to our Plate Kitchen object film private for the Plate Kitchen object for the Plate Kitchen object back in the editor let's drag the reference okay great so now here basically we need to update this visual whenever the plate gets any ingredient added to it so let's go over here into the point script and basically just need to fire off an event when that happens so let's make a public event event handler and let's call it on ingredient added okay and for this one let's also make an event RX to contain the data of what object we added so let's make a public class on ingredient added event args let's extend event args and inside let's make just a kitchen object a cell kitchen object as well okay great and let's make the event of this time all right so now let's just fire off this event so down here when we try to add an ingredient if we do add the ingredient let's fire off this event so let's invoke with this and let's create a brand new one passing the kitchen object as so as this kitchen I'll take this off okay so we have our event correctly being sent now we're here on the play complete visual let's listen to it again as always let's make sure to do it only on start so the play kitchen object on ingredient added let's listen to this event and over here we just need to either enable or disable the visuals that relate to the kitchen object inside over here the event arcs however of course the question is how exactly do we find them the point complete visual has all these game objects how do we know which one belongs to that kitchen object now technically one way would be to do a simple transform find and find the channel objects by name technically that would work but like I mentioned in the beginning of the course strings are a horrible way to identify things they are very air prone so let's not do that instead let's use a proper approach where we can Define some kind of link between a kitchen object a so and a game object and we can do this very easily by justifying a struct so here in our script let's do exactly that let's define a public make it a struct and name it kitchen object so underscore game object then inside it's very simple we just have a kitchen object so field and then also a game object field that's it super simple by the way if you don't know what is a struct basically it's very similar to a class except it's stored in different places in memory and behaves somewhat differently I have a very very important video on that subject what is the difference between value types and reference types classes are reference types so when you pass in a class into a parameter you are passing in a reference to that object whereas struts are value types so when you pass in a struct onto a parameter you are passing in a copy it's a bit of a tricky thing so definitely make sure you go watch that video for more details so you don't get confused in the future here I Define that as a struct simply as kind of a teaching moment but also because it just makes sense that if I just want to store some data without any logic then it should probably be a struct and not a class although in this case the class would work just as well anyway so here we have a struct inside the struct we have a field of type kitchen object so another one of type game object so now let's just make a list of this type that we can expose in the editor so here a serialized film private let's make it a list of kitchen objects so game object and call it kitchen object so game object list okay that's it super simple so let's save and make sure this compounds so actually let's just comment this out just make sure our code compounds okay and over here in the editor we see the tricky thing when it comes to using fields of custom types if we look in the inspector no we don't see anything so we cannot see our custom type in the inspector if you make a custom time like this front and you want to show it in the inspector then you need to add the attribute serializable which exists inside system so let's go up here using system and let's say the attribute serializable just like this okay so do this save and let's look and if there you go now we do see our custom struct so we've got a list then we can click on the pause icon and there you go we've got an element and it does have a film for a kitchen object so and one for a game object so that's great with this now we have a really nice place where we can link one object to another so let's just do exactly that so for example let's put the bread over there and let's assign the kitchen object as so for the one with bread let's do the same thing for all of the others so let's add a whole bunch more Okay so we've got the bread then we're going to have the meat Patty cooked then the tomato slices then we have the cheese slices the Cabbage sliced and finally the meat Patty burned so I've got number zero through five so you have six elements and over here yep we do got six so we have all of them we can get rid of these last two okay great and now let's assign the proper objects so this one for the meat Patty cooked then we've got the tomato slices then we have the cheese slices then the Cabbage slices and finally the meat Patty burned okay great so all of the references match now back in the code here so we have this List fully filmed out and when we have this really very simple we just cycle through the list to find the right game object it's similar to a 40 inch of type kitchen object so game object in our kitchen object so game object list and we check if this kitchen object is so dot kitchen object matches the one that we received in the event if they do match then go into this one grab the game object and set active into true okay so that's it some very simple logic and also we can start with them disable them by default in the editor or just over here just use something very simple just do a for each second through every single one of them and set every single one of them to false so that they are hidden okay so with this on the ingredients on the plate should be visible so here in the editor let's just make sure all the references have been set let's go back save the prefab and let's set on play okay so here we are and by default like that an empty plate and yep it is empty and now let's slice some cheese now let's Place some cheese on there and there you go we've got some cheese now let's pick up some bread drop some bread and there you go got some cheese and some bread then let's cook some meat so let's cook it and let's pick it up with a plate and as soon as I go boom there you go I've got a nice cheese butter all right awesome so wait a second I'll do a complete Burger so let's finish it let's just add some more tomatoes so slice them and add the tomatoes and finally some sliced cabbages slice them put them there and there you go here we have a fully complete Burger okay so that's great all of our vision logic is indeed working however this visual is a bit hard to see it's not very clear to the player so just looking at it from this distance does that have a tomato or not there's a tiny sliver of red in there but you can't really see it so we should probably add some nice clear icons on top to clearly indicate what exactly is on this plate so that's exactly what we're going to do in the next lecture hello and welcome I'm your code monkey in this lecture we're going to add some really nice icons on top of our plate so we can easily see what is on there okay so for the icons let's do the exact same thing that we did for the progress bar meaning let's use a warm space canvas so let's go inside our play kitchen after prefab and over here on let's right click let's create a brand new canvas let's name this the plate icons UI then for the settings let's make it World space put it on zero zero everything width and height also on zero then let's lift it up a little bit so put it on a y of one okay like that now inside let's define an icon so let's start by making an empty game object call this just the icon template let's put it with a size of 0.3.3 it's okay something like that then inside let's add a new UI image name this the background and make it stretch to film The appearance so put 0 on everything okay there's our background for the background image instead of a square and let's actually go with a circle for that Unity actually has a bunch of builtin Sprites that are tatted in the last versions however it's not actually over here by default in order to see those default Sprites we need to install the 2D Sprite package so let's quickly just go into window package manager let's make sure we are in the UNT registry make sure we aren't looking at all and over here let's find the 2D Sprite package okay so let's install this okay there's the package so now if we go into the background and we search for a Sprite and over here make sure you click to actually show the assets from the packages and now we see a bunch of default hexagons a bunch of isometric tiles the square so on and if we search for Circle yep here we've got a bunch of circle so let's use this one over here on this path so let's use it there you go we have a nice circle now let's duplicate this image and for the second one let's name it icon then for this one let's assign just a random Sprite so let's say the bread and again remember how the Sorting order on the UI this one is based on the ordering the hierarchy so make sure that the icon is underneath the background the hierarchy that way it shows up on top okay so we have our icon template that's great of course we're going to dynamically generate all of this through code we're going to have multiple icons and for positioning them Unity actually has some really useful components let's select the plate icons UI and over here now let's add a component now for example a builtin component is the grid layout group this basically helps you position all the charm objects so let's put the size of the canvas over here on 0.9.9 okay so there you go a nice Square window then over here on the settings for this for the cell size let's put it at 0.3.3 and if there you go already shows up over there on the corner and we can see what it will look like if we just duplicate this object so let's make a bunch more templates and if there you go that's what it looks like so as you can see this component is super useful for automatically positioning all of the challenge objects now if we want we can play around all of these we can add a little bit of spacing on the XR on the Y but let's actually leave both those with zero let's leave everything on defaults just over here on the channel alignment let's put it on middle Center okay so there you go that looks pretty nice so you can see how this builtin component is super useful there's actually two more so this one for the grid layout this is great when you want to put things horizontally and vertically but if you just want horizontally then there is the horizontal layout group and if you just want vertically there's the vertical layout group so all of these components are really awesome really useful okay so with this our objects are placed and note how I named this an icon template basically a template is just what I call something that is kind of like a prefab but not really a prefab through code we're going to duplicate this template and dynamically modify the icon so we're going to use it very much like a prefab we could actually make this into a proper prefab so I could just drag it over here onto the project files and make a regular prefab that could work and the only reason why I prefer this method of not using a prefab he's just because this object this template stays here on the object as opposed to cluttering over here your project files if you have tons of singleuse UI elements with tons of objects you need to spawn you can end up with tons and tons of prefabs and you might not even know where each of those is used whereas with this method the template says exactly where it's used and does not take an asset slot over here on the project files so personally this is just approach that I prefer for spawning UI elements but like I said prefabs work as well so if you prefer using prefabs go ahead and make it okay so let's make our script to run the plate icons UI so let's go into our scripts and on the scripts folder let's create a brand new csharp script for the plate icons UI over here let's attach a script and open it okay so now the first thing we need is a reference to our plate so let's begin by making a serialized film private for the played kitchen object for our play kitchen object okay let's save it and drag the reference so over here there's the point icons let's just drag the plate reference okay great now on the plate we already made this event when an ingredient is added so basically we just need to listen to this in order to add the new icon so over here on the UI let's do as usual private void start and on start let's go into the Plate Kitchen object and listen to that event and when that happens let's spawn an icon although here let's actually use a different method from the one we used on the plaint visual over here on the plate visual whenever we had the event we really just modified the object that was added so over here the equivalent would be to spawn a new icon whenever that one was added but instead of doing that right now let's listen to this event and when this happens let's update all the icons in this display basically this other method is useful when the contents can be added as well as removed now in this case they are never going to be removed so in this case both methods were fine but still I want to show you the second method just so you can use it when you need it so for that method we just need to know exactly what is on the plate so over here on the Plate Kitchen object we just need to expose the kitchen object as some list so let's do example that so fun week we're going to return a list of kitchen object SL let's go and look get the kitchen object the sewn list and we just return the kitchen object that's always okay very soon then over here on the planet icons UI let's just make a function to update the visuals so private Droid let's call it update visual and when we have the event let's call our update visual okay so now here let's basically just cycle through all the ingredients so let's do a 40 inch kitchen object so in the plate and get the kitchen object the sewn list okay so we're cycling through all the ingredients on the plate and then we want to duplicate our template so that means we need a reference up here so let's add a serialized film private type transform complete the icon template okay and let's save the code and over here in the editor let's drag the reference so let's drag the icon template by the way I'll have the others over here that's not a problem since these are going to be destroyed those we're going to see in a little bit the only one that matters is the first one okay so here we have the icon template so to spawn it we do it just like we do with any preform so we just call instantiate pass in the icon template and then transform parents so let's put it as a child of this object this part is important we need to make sure the object is spawned as a child of this object if over here you put something like no then the template won't be spawned as a mobile object so it won't be somewhere in the world so in order to make it positioned properly let's make sure to use transform to become a child of this object okay and then since we're using the other script the green layout group this is already going to be automatically positioned so just like this it should be spawning the icon and with the icon spawned all that's left is really just setting the image and now again the quick and dirty approach would be over here when we spawn let's say we pick up the item transform and over here we could go inside and do a find in order to find the image in order to get the component of Type image and so on so that is one approach that would be the quick and dairy approach but again we want to do things properly so let's do it the proper way instead so instead of this let's make a proper script that we're going to run on the icon template so let's create a new script so a new csharp script come with the plate icon single UI so this one represents just a single icon let's go ahead and attach it to the template so over here let's drag it and now when using this template method really the only one we need to worry about is this one the other duplicates we can just leave them they don't really matter but don't just avoiding confusion I'm actually going to delete them it's okay we just have one icon template okay and it has our script okay let's open now over here let's basically just make a function to set a kitchen object or so so public void let's go on set kitchen object so we receive parameter of type kitchen object that so okay great so then we need to set the image so let's just go into a serialized film private of Type image which is inside the unity engine.ui so for this one for the image we have a reference and then we set the image.sprite go into the kitchen object and grab the Sprites okay so we need to do is drag this reference so over here in our template let's drag the icon image okay great so now back here on the plate icon Ty so we spawn it that's great then let's we get component in order to get our script so the plate icon signal UI okay and then we just call set kitchen object so and pass in this okay that's great this is much better now again you might be thinking that this method is a lot more verbose than just setting the image Sprite here we had to create another completely new script we had to write this logic and over here get it and use it the quick and dirty approach would indeed be quicker but remember that while the equationary approach might be faster at first it will mess you up over time so just take a few extra seconds to do things properly this approach is much more scalable let's say for example on this function you want to change not just Sprite but also trigger some kind of Spawn effect or animation with this it's very simple we've got this function right here we receive the kitchen object of so and we can do whatever we want with it so like this we have this grip that is responsible for anything related to the single template and if you've got the general one which just spawns him and just gives them the kitchen object so so all of our logic is nicely separate okay so just like this it should already work however like this you might already be thinking want to spawn way too many icons and yep it will basically every time we add an ingredient we're updating the visual where we're cycling through every single one and spawning all of them so with this we're constantly going to spawn more and more items this is not what we want over here on the update visual we do want to update and spawn all of the icons but before we do that we actually need to clean it up we need to clean up the icons from the previous event so before we do that let's just cycle through all the children on this transform so that's pretty simple you can just do a for each transformed child in the transform so this way Cycles through all the children and then just call destroy on this channel that game object so that won't work that won't destroy all of the previous children however of course we also have one issue the icon template itself is also a child so if we do this we're going to destroy the icon template which then over here we're going to have an error because we're going to instantiate no so we want to destroy all the children except for the template so over here that's pretty simple we just check if the child equals the icon template if so then let's just skip it so we can just call continue and there you go it skips okay great so just one more final thing if we leave the template like this meaning the game object is enabled like this the template will always be visible plus whatever ingredients we have we don't really want the template to be visible this is just meant to be a template that we can instantiate so that's pretty simple to fix let's make a private void awake and on a week let's grab the icon template grab the game object set active into false okay so now the icon template won't be disabled so it won't be visible and then over here when we are instantiating the instantiated ones will also be disabled so let's make sure we go in there and enable these all right that should do it so all of our logic should be working there's only one more tiny thing we need to take care of this one is a world canvas so like we saw with the progress bar we need extra logic to make it look towards the camera and thankfully we already wrote an excellent generic script to do just that so let's go into the point icons UI and let's add a component and let's add our very nice look at camera something like this and let's set the mode the same that we use so let's put it camera.org okay so everything is great everything should be perfect so let's finally test let's leave the scene save the prefab and hit on play all right so let's go pick up a plate and there you go there are no icons visible okay that's great now I'm going to place a bread on top of the plate and there you go I've got a nice bright icon okay great now let's make some meat cook it and as soon as it's done going to pick it up and there you go I've got a bread and some meat now let's put some cheese slice it put it there and there you go now I can easily see that plate has some bread some meat and some cheese now let's just add the rest of the ingredients to make a foam Mega Burger so let's add some tomatoes and add some nice cabbage slices any of there you go it works perfectly so here we have a complete burger with everything and we can easily see on the icons everything this contains alright awesome okay so here you'll learn how to make yet another Super useful element that you can easily add to all of your games personally I use this kind of logica ton in all kinds of UI things for example in my upcoming steam game total warm Liberation the items in the inventory they're all added using this method so there's a template and I duplicate that template same thing for all of the action buttons all of those are based on having a template and duplicating it it's a really easy way to do this kind of thing with all that here we have a phone plate and we can easily see what is on there so with this the next obvious step is to actually deliver some orders so let's do that in the next lecture hello and welcome I'm your code monkey in this lecture we're going to build the delivery counter this is where we're going to drop some items that the customers have requested in order to complete the orders also just for fun we're going to learn how to use Shader graph to make a simple custom Shader okay so let's begin by making our counter so let's go into our base counter let's create a new prefab variant for the delivery counter let's go inside and now let's find the visual the visual for delivery counter let's duplicate it to make the selecting let's go inside modify the material then on the selected make it one percent bigger one zero one add the component the selected counter visual let's drag the kitchen counter like that okay that's our basic setup and also start with the kitchen count disable okay great now let's make a script to run this so let's go into our counters folder and let's create a brand new csharp script for the delivery counter let's attach it and open okay so now here as usual let's begin by extending our base counter class all right now let's override the interact function and for now let's actually do it it's not like the trash counter meaning let's just destroy the object so we just check if the player is holding something so if the player has a catch an object let's go into the player the kitchen object then let's destroy it however another room over here for an Oliver counter is this is only going to accept plates so let's see if the player is carrying a plate object so player get kitchen object and test try to get the plate so out played kitchen object for the Plate Kitchen object we try to get this and if it is a point then we destroy it okay that's it here in the editor let's just compound the script and drag the references so the countertop point and on the selected let's drag the counter reference and let's exit this save the prefab and let's drop it over here on the corner so let's find over here the delivery counter and let's put it over there hang on it on this side put it like this let's also just quickly reposition all of our counters since we already have all the types that we're going to use so on the lever counter let's put it over here on this corner so x 7.5 0 and Z of two then next to it let's put the plates counter so over there okay then next week let's put a clear counter after that let's put the trash counter and then let's also put another empty one there so let's duplicate this one move it up to about this and put it like that now we just need to move all of these down here so just select all of these counters and let's move them down by about this okay so on minus 5.5 like this okay so everything is nicely positioned just over there right now we cannot access that container so let's actually modify those as well which by the way over here there's the canvas in front so as I click I'm actually selecting the canvas in the hierarchy so here's a quick empty tab on the hierarchy on the left side you've got these two buttons so one of them hides the object and the other one simply makes it unselectable so if I click on this and I click through any of the click goes through the canvas so that makes it much easier to select over here on the items in our scene so let you select all of these okay all of these now just push them all to the side and make another empty one and put it over here okay that's a nice layout now let's just finish the rest so over here let's just duplicate our empty counters and place a bunch more let's put one more to the side and now these ones over here so let's put it over there and rotate it here and duplicate another one and another one and another one and just one more and get rid of this one okay great so here we have pretty much our complete map let's also just move the camera tiny tiny bit just make sure that it is nicely organized so put it over there just so everything is nice and centered okay so there's our map now let's get back to working on our delivery counter we already added this code so let's just quickly test so here we are and if I pick up something like for example some cheese go into the delivery counter and interact and nope nothing happens because that one only accepts plates now if I pick up a plate go there don't wait for any of there you go it does work okay great so this is the basic logic that we want for defining the actual recipe and logic we're actually only going to do that in the next lecture but for now let's add one more nice thing let's add a simple custom visual over here using Shader graph this is a great way for you to learn the pottery of Shader graph and just how easy it is to use this is a visual tool for making shaders it's really very easy personally I don't know how to write shaders with code but I can build some pretty nice things using Shadow graph as usual I have a dedicated video on it I also have an entire playlist showcasing how to make all kinds of interesting effects and even one special video covering some changes in recent shareware versions so over here let's learn the basics how to use it so first here in our project window let's create a brand new folder let's name it just shaders and now inside let's create one so let's create then go up here into sheet graph then we're using urp so let's go inside there and here we've got a bunch of options now don't worry about picking the quote unquote wrong option all this does is just create a template so for example if you accidentally create an unlit Shader you can then easily swap it out from it so right right now let's go with the English hitter and for the name let's name it moving visual okay there's our shade Rafael now now let's just double click to open it and up here we have the nice shade graph window by the way you can make this phone screen so you can either right click over there on the tab and maximize or alternatively you can just click on this window and then use the hotkey shift space and if there you go it does maximize okay great now by default we have this down the center this is called the master stack these are the actual properties that we're going to need to use then on the left side we have the properties Blackboard on the right side we've got the graph inspector and finally down here we've got the main preview all of these windows can be scaled and also if you don't see these windows or if you accidentally hide them they're all appear on these three buttons so the Blackboard that's on the left the graph inspector and the main preview okay so now here we've got a nice empty board so we can add whatever nodes we want so we can right click and go into create node and then we can write something or just click anywhere and press on space and there you go now we can cycle through and browse all of these menus to see all of the nodes that exist there's tons and tons of them or alternatively just go up here and use the search bar so for example let's find the sample texture 2D node so here it is this one okay we've got this node what this one does is it takes a texture and grabs the color from it so on the left side of the node are the inputs and on the right side are the outputs within the parentheses you can actually see the types so for the input texture this one is of type T2 so that means it's a textured 2D then on the output you can see there's a 4 meaning it contains four floats which in this case refers to the four colors so that's red green blue and Alpha so for an input we want a texture so let's set it over here as a property let's click on the plus icon and we've got a whole bunch of types for texture we want a textured 2D so let's go with that and then for the name now usually there are two standard names there's one called main text or base map main tags used to be the more common name but when working with urp for some reason they decided to name the main texture as base map so we're here let's stick within the urp standard and just call this basement okay there's our property and if we click the select it and on the right side we can see the graph inspector and we can see all the properties for this Actron property so we see a name reference and a bunch more things now the really important one is over here the reference this is the actual name that you're going to use if you want to interact with this Shader through code the name on the property this one is just a text ring so this can be whatever you want you can even have spaces and so on whereas the reference name this is the really important one and by default when you set up a name it should already accept the correct reference usually the standard is to name it just like the name both without any spaces and with an underscore in the beginning so just like this okay then we can give it a default texture so let's go ahead and select something for example over here the bread texture remember this is just the default this will not be hardcoded directly into the Shader we can then modify this okay so we we have our nice base map property definition now we can just drag it over here on the board and yep there it is and now we can just click on the server icon in order to drag a connection and let's connect it over here onto the sample textures to the input and yep right away we do see it does work so we are correctly sampling the texture however if you look on the main preview over here there's still nothing that's because we don't have this node connect to anything we need to connect it to the final Master sack in order to render something so again on the output over here we can see a four so these are all of our colors and actually one very useful node is the preview since so many things in Shader graph can be hard to visualize so we can move these nodes around and let's add the preview node and this does examine that so you can fit it an input and you can see down here what that input contains so for example let's drag just the red Channel and if they go over there we can see the red channel for this texture we can drag the green channel the blue Channel or look at the alpha Channel yep there you go it does work so this preview node is super useful for being able to see what your Shader is actually doing over here we have the colors so let's get rid of the preview right now in order to make it work we really just need to connect the rgba and go up here into the base color and right away it should work but you might not be able to see anything over here on the main preview I believe this is a rendering bug in the current Tech version so right now nothing is shown so if you still don't see anything it's actually pretty simple just go up here on the top left side and make sure to save the ascent okay save it great then let's exit from our maximize View and now let's close this tab let's click on play just to play the game now let's stop playing and now if we open the Shader again if there go now we do see the Shader compiling over there that color that is the Shader compilation and after a little bit it should work let's just maximize this see if there you go there we do see our texture okay great so again it's just a simple rendering plug on the current Tech version if you're watching this video in the future chances are you don't even have this box so there's no need to worry okay so right now we do see it working we can see our bread texture and it's currently being applied on a sphere for a use case we're working with 2D textures so this would be best to be seen on the Quan so we can right click over here on the preview in order to select the preview mesh so let's go with a simple quad and if there it is we have our Knight Squad okay great so over here we have our basic Shader all it does is just shows the texture that's it now it's actually use this and first let's always make sure to save the asset on the top left side on the moving visual if you see an asterisk here that means you have unsafe changes so always make sure to save them in my case I don't but still never hurts to save now over here in scene view let's go inside art only three counters and let's open it and now for the display for our Arrow let's make it a flat one so let's right click in the hierarchy and let's create a new 3D object and let's make it a quad let's call this the delivery Arrow let's place this on top of the counter so let's rotate it to face upwards by the way on the rotation make sure the collar is facing upwards most shaders by default they only render one face and not the other one so make sure you put the face with the collar upwards and not the other one okay so let's rotate this one upwards so there we go 90 over there and let's just put it just exactly on top of the counter so just enough so that it's visible okay great so now let's make a material for our Arrow so let's go inside the materials folder and over here let's create a brand new material let's call this the delivery Arrow let's make sure to use this material on the quad so let's just drag it over there on the mesh render okay so it's using our custom material and over here on this Shader graph drop down menu over here we can select what Shader we want to use so in our case let's go inside the founder Shader graphs and inside yep here we have our moving visual Shader so let's go ahead and use this and here right away we do see that it does work here we have our texture being drawn exactly on top of our material okay so far so good now again here remember one very very important thing that I said the texture that you define the Shader over here the default for the property this one is only the default the important one is the one that we have on the material I'm emphasizing this point because I've seen a bunch of people make this mistake if you modify default texture whilst inside the Shader like for example if I change here from bread let's say into the Cabbage slices if I modify that note how it does not modify any materials that were created we are only changing defaults so if you want to change the texture that is actually used make sure you change the one on the material that you created and not the defaults I changed the default but did not change this Shader however if I now were to make another material which by the way here's a quick tip you can recollect directly on the Shader file and going to create and create new material and it will automatically create the material using that Shader naturally here then update default just because I didn't save the Shader so I modified this one for the camera slices and now if I save the asset and now if I right click there and I create a brand new material and yep now that one does have the new default but again remember what you said over here is just the default what really matters is what is on the material after the material has been created modifying default here does nothing so always keep that in mind in most cases you want to be changing the property on the material itself not the default on the Shader okay let's just clean up both of these all right so let's continue now here we have our Sprite working okay except we don't want to show some bread so let's actually use the proper Arrow Sprite so let's select this one and yep it does work it is printing the Sprite however one obvious thing is that the arrow is not transparent like it should be so let's solve that back in our Shader graph in order to make this a transparent Shader we need to actually go into the graph settings so on the graph inspector go into graph settings and over here you see a bunch of settings that relate to the graph itself and not any selected property so let's go into graph settings for example like I mentioned a while ago you can modify between lit and lit and so on so this is where you would change that you can also appear at multiple targets so you can create a Shader in Shader graph and make it work with the Universe on random pipeline or the high definition render pipeline or the builtin render pipeline all of those are supported through Shader graph now for a goal in order to make this a transparent Shader let's just go over here onto service type instead of opaque and let's change to transparent and as soon as we do look what happens there and if there go it adds a brand new Alpha Channel if we just save the asset right now and open look at that it still doesn't work it's still not transparent basically we made this Shader transparent but now we need to fit in the transparent Channel over here onto the alpha this is the one thing that is different from a previous version of shadowgraph previously you could just feed the alpha Channel over here onto the base color and Shader graph would automatically apply it but in recent versions you need to add it over here separately so if you have any issues with transparency when following some older share graph tutorials always remember this change I covered that along with some other changes in a very useful video so if you're following along some other shade graph tutorials make sure you watch that video to learn what you need to do to update them to the latest version okay so here on the similar texture we already have the alpha channel so we just connect this onto the master Alpha and right there we already see it working let's just go ahead save our asset and here in scene view if there go now we do see our Arrow now one more small thing you might notice that from some angles it's not exactly transparent basically it actually is transparent but since we made this in literature sometimes the light might make the transparent Parts visible one option to solve that is over here on the graph settings instead of making it lit let's make it unlit that would work say up with the unload Shader the transparency is perfect but if you really want to keep it lit then the other thing you can do is just over here play around with these settings you've got smoothness AO and so on and over here you can even modify the workflow mode so for transparency instead of making it metallic let's go with a specular workflow and then over here set the smoothness to 1 and the ambient occlusion down to zero and now if we save this Shader look at that and yep now the transparent parts are indeed fully transparent finally over here on the right side on the mesh render if you want you might want to play around over here with the cast Shadows so maybe you don't want this one to cast Shadows maybe you don't want it to impact light probes and so on okay so with this we have our nice transparent Arrow let's make sure to save our delivery counter so let's go outside back into scenes and let's head on playing and if there you go we have our transparent counter with our nice Arrow now we want the arrow to actually move and doing that is actually super simple going back here in our shadow graph let's just modify default just so we can see the arrow that we want to see so let's select the arrow Sprite okay there's our Arrow now for moving over here on the simple texture we've got an input for the UV the UV is what defines what portion of the texture we're going to grab which by default just gets the whole texture so since this field represents where we're going to grab from texture by playing around with this we can grab different parts so to do that let's just add a standard UV node so here it is this is the standard UV channel so if we connect this then nothing changes everything still renders exactly the same but now we can modify this and to do that we're really just going to use some basic math remember that when working with shaders even though you do see colors everything is really just numbers so uv2 is just number the converges the number the alpha is just a number so visually everything might look like images might look like colors but really in the end it's all just numbers so for example how do we move this texture well it's actually pretty simple we just add a number onto it so we're here on the UVM let's just add an add node so this just adds two numbers together very basic so let's take the regular UV and let's add something on top of it for example we can make a vector two and let's put it on say 0.10 and let's add this one onto this one and now if we drag this one onto the input and look over there on the preview what happens and if they're going like that it moves slightly to the left so if I modify this one put it on zero there you go and that point one on that point two on that and so on so you can see that by modifying here I'm essentially offsetting the texture I'm offsetting on the X and over here I can also offset it on the y basically I'm offsetting the texture by ten percent the UV is a normalized value this is not pixels so that is why point one is ten percent regardless of how big the texture is and if we go way past one then texture essentially Loops back so this is really all we need for our moving Arrow we're going to have zero on the Y and on the X we're going to constantly either increase or decrease that's how we're going to have our moving Arrow so again the only issue here is that I'm modifying this manually we don't want a fixed amount on the Shader instead we want a nice animation so for that we have the very useful the time node this one has various timebased outputs the one that we want for this case is a time which is just the total time this one is constantly increasing since the start of the game by the number of seconds so if you use this over here directly on the end and they're gonna look that texture is constantly scrolling okay so that's great except obviously we have one issue we don't want it to scroll diagonally we only want to scroll in One Direction so for that we can essentially create a simple property to act as our spin so let's over here on the Blackboard let's create a new Vector two column Tower speed property and for the phone let's see if I want to say 0.1 on the x0 on the Y and now if I drag the speed over here onto our Blackboard okay great this is basically a multiplier so we just need to multiply the time by this so let's add a multiply node also by the way quick tip over here on each node you've got a nice little arrow so if you want to make it a bit more compact so if you don't actually need to see the preview so make that and in this case let's take our time multiply it by our speed and then for the output pass it into the end okay so like that now it is indeed moving in this direction and over here on the speed we can play around the values so if we put that 0.5 now it's moving faster and if I put it on the Y now it's moving diagonally put zero on the X and now it's only moving vertically okay so this is really what we want let's just go ahead save our Shader and now let's just select our delivery Arrow material and over here yep we've got the spin if you don't see it make sure they're on the speed property over here you have it exposed so we have the speed instead of moving on the Y let's move on the X and actually like this it's reverse going backwards so over here we can just put a negative value so let's put it on minus one and if there go now the arrow is moving perfectly also here let me make one important note just in case you're using this Shader with a custom texture instead of the one included in the course if you do that make sure that the texture that you use over here I'm using the arrow texture over here on the Arrow import settings down here under wrap mode make sure it is set to repeat if you set it as clamp you might get some weird visuals or nothing at all in order for the texture to constantly Loop and constantly repeat itself that one needs to be set to repeat okay so here it is in game and we have a really nice moving texture for that we created the simple but really nice useful custom Shader definitely go ahead and watch the various effects that I made in the shadow graph playlist this tool is super useful definitely make sure you know how to use it I've used it for making a building effect I've made some nice outlines a really nice wind Shader also a really interesting the sound of effect and even a cool transition Shader just like in the game Hades so this really is a super powerful tool make sure you watch that playlist to really learn how to use it alright so here we'll learn about share graph and created a really nice custom Shader however the delivery counter still only has a visual so let's create some proper Logic for generating and delivering the correct recipes in the next lecture hello and welcome I'm your code monkey in this lecture we're going to build a proper delivery manager that will generate recipes that customers are ordering and validate to see if the player made the right dishes alright so right now we have the player capable of making dishes so for example I can put some cheese cook some meat cut the cheese and then pick up both of them then let's say pick up some bread there you go got a nice cheeseburger and deliver it okay so that works but right now they just vanish on delivery counter so there's no recipe we need to follow no validation none of that so let's add both those things okay first of all let's make our script so let's create a brand new sharp script for the delivery manager let's make a new game object to run it so we need delivery manager attached to script let's make sure to keep things lean so reset the transform and also by the way since we're here let's go ahead and put the plates and delivery counter inside the counter so everything is nice and organized okay great so let's open up this script now here basically we need to Define some sort of list to store all the recipes that the customers are waiting for which of course begs the question what type is that going to be now technically one thing we could do since a recipe is around just a list of kitchen objects over here we could have a list of list of kitchen objects this would be our recipe list technically that would work but that really looks quite dirty instead of having a list of lists we should probably have a proper type for this so let's write some good clean code and Define a proper recipe Script Mod object back in unity let's go inside script knowledge's folder and create a brand new one let's call this the recipe so and over here let's make this a script Mall object so extend script on object make the create asset menu and over here for the films for that that we need well like I said a recipe is just a list of ingredients so just taking a list of kitchen object that sell for the kitchen object SM list okay that's it that's really all the data that we need to define a recipe just to be able to identify them for the player let's also add a public string for the recipe name so just a nice name String okay great now back in the editor let's define so let's go inside the certain objects and make a brand new one for our recipe so and now inside let's create a brand new recipe SL for this one let's call it just burger and over here first of all for the name just name it burger and then for the kitchen object list well to make a burger let's well first let's add some meat and we want some cooked meat we don't want to serve uncooked or burnt meat so only the cooked meat then for a simple Burger obviously we need some bread and that's about it so some bread some meat that's our very basic Burger now let's also make another one so let's duplicate this one and name this one the cheeseburger over here let's name it cheeseburger and lightning place has bread meat and obviously some nice cheese slices so there you go okay we have a cheeseburger now let's also make a mega Burger so something with everything so let's call this one the mega burger and over here for the string name for the Mega burger and for that we have meat bread cheese let's also have some nice cabbage slices and also some tomato slices alright that's our Mega burger with everything and finally let's also make just a nice simple salad so let's duplicate this for a salad let's name it salad and for the salad we don't have any meat we don't have any bread and also no cheese so just cabbage slice and tomato slice that's a simple salad okay so here we have all of our recipes so back here on the delivery manager script instead of making a list of lists of game objects let's just make a list of recipe recipe so and name it the recipe so list this is where we're going to probably see recipes that the customers are waiting for so it's actually rename this let's put it waiting recipe on list okay so the customers are waiting for whatever is inside this list and now we could make this a serialized field then set it in the editor but we don't want to have a fixed list we want to periodically spawn new recipes in order to spawn new recipes we also need to know which ones we can spawn so for that we could add a list of all of the recipes then we could pick a random one from the list and add it over here to the waiting list that would work that's one good approach but since we already did something similar to that various times in this course here don't let me teach you a different approach that sometimes might make more sense for that second approach we just need one thing we need a script more object to hold all of our recipes so let's do that let's do a brand new csharp script this is the recipe list scriptable object and then inside this one is going to be a scriptable object let's add the create asset menu and inside we're just going to have a list of recipe so for the recipe SLS so that's it super simple now let's just create one object of this type we can put it inside the recipe as soon as since we're only going to have one so let's make a recipe on Lister so namely the recipient list SL and then over here let's just drag our recipe so we've got a burger a cheeseburger we have a mega burger and finally a salad okay so basically we have a script ball object with all of our recipes and now just for safety since we only want to ever have a single one of these objects a recipe on SSO for this one we can go back here in the script and simply comment out the create asset menu so now back in the game over here we can no longer create another type of recipient list so so just say nice safety thing since we probably only need just one and let's also add an underscore just so it shows up at the topdown list okay great so we have this and over here on the recipe manager we can basically expose that in a serialization so let's make a serialized field make it private of type recipe so list recipe enlisted so for the recipient list so and now here in the editor we just drag that reference alright that's it so basically the difference that we did with this method is over here on delivery manager instead of having a list of all of our recipes we just have a reference to one object and then that object holds a list of all the recipes in this specific use case like I said this approach doesn't really have many benefits compared to just starting the last year but let's say we had another script that also needs a list of all of our recipes if we did that we would basically have duplicate references so this script would have a list of all the recipes then some other script would also have a list of all the recipes and then if you wanted to add a brand new recipe you'd need to add it to all the lists on all the scripts whereas like this any script that needs to know about all of the recipes just needs a reference to the recipe on SSO and whenever we want to add or remove a recipe we just need to update this one object and everything works perfectly that's one of the benefits of this approach where you have a script mode object to hold a list of all the objects of some type personally I find this pattern to be quite useful okay so on delivery manager we have a list of all of our recipes now let's just make a simple timer to spawn them like I mentioned previously in the spawn point logic you could just use Echo routine if you like that core routines can be useful for running timers but personally like I mentioned I do not like Co routines I don't like the pattern they force it to use so over here I'm just going to make a simple flow timer so a private fluid for the spawn recipe timer another one for the recipe timer Max and let's say 4 seconds then we just do a simple and private weight update on update let's count down the timer so time dot down for time and if the spawn timer is under 0f let's reset the timer and now let's basically spawn a recipe so for that let's grab a random one from the list so we go into the recipe list so and grab the recipe as a list then we're going to grab a random one so let's get a random index so random.range between 0 and the recipient list so dot recipes dot count so you get a random one this is going to be a recipe so for the waiting recipe so and then we simply go into the waiting rest PSL list and we add a brand new recipe okay that's it super simple let's just make sure to initialize the list so let's do here a simple awake for the waiting recipes and just initialize it okay so like this it should be working however we're also going to generate recipes nonstop we don't want that so let's define some kind of maximum so let's Define a simple end for the waiting recipes Max let's say we kind of have a maximum of four recipes waiting and then down here when camera lapses so if the waiting recipes only stock count if it is under the maximum then we generate and add it okay that's it pretty simple now for testing let's just set allow here to print the name so debug.log on the waiting recipe so that we generate so let's print out the recipe name okay so let's test so here we are in yep one will spawn right away so we have a solid and after four seconds Yep they're going out of salad and if we wait for four seconds we should have another one there you go a mega butter recipe and finally after four seconds we have yep we have another burger and now no matter how much time passes there should be no more since we're at the limit any uptime pass then no more okay all right awesome so we are correctly generating recipes that the customers are waiting for now it's a logic to try to fulfill these orders so over here on delivery manager let's make a function to deliver a recipe so let's make a public Point make it public since we're going to access this from the delivery counter currently deliver recipe and the recipes are going to be delivered whilst on a point so let's receive a parameter of type Plate Kitchen object and over here the logic is actually going to be pretty simple we just need to cycle through all of the recipes that the customers are waiting for and see if the ingredients on this plate matches the ones on any waiting recipe so over here let's cycle through all of our recipes so let's do before entire zero going through the entire recipe only star count I plus plus okay let's grab the recipe so for the waiting recipe so and we grab from The Waiting recipes on list on this index okay so we have that then first let's do a quick test just to check if the waiting recipe has the same number of ingredients as they are on the plate if not then we already know that it's not valid so over here let's do a quick test SO waiting recipe so let's check the kitchen object that's only it's not count if this one matches the play kitchen object let's get the kitchen object that's on the list and also check the count so over here we know that has the same number of ingredients so this is the first check then we need to cycle through all the ingredients on this recipe and all of the ingredients on the plate and basically see if both of them match so let's first cycle through the ingredients on the recipe so for each kitchen object as so let's call it the recipe kitchen object so in the waiting recipe so let's go into the waiting recipe and get the kitchen object list okay so here we are cycling through all ingredients in the recipe then we need to cycle through all the ingredients on the plate so let's do another cycle for the Plate Kitchen object SL and we're going to go inside the Plate Kitchen object get the kitchen object that's on the list like this so here we are cycling through all the ingredients on the plate okay so now here basically we need to see if this ingredient that we're cycling through if this one matches the ingredient on the recipe so here we check if the Plate Kitchen object does so if this one matches the recipe kitchen outlet if so then the ingredient does match so in order to keep track if it does match over here before we cycle through all the ones on the plane let's define a bone for found or ingredient found let's default it too false and over here if we have match then this one becomes true and by the way over here we can also break out of the cycle now if you're not familiar with break basically this is going to break out at the for each so let's say the plate has 10 ingredients and the second one matches when this cycle gets to the second one it triggers a break so it no longer goes through the remaining eight so basically it breaks out of the cycle so keeps writing some code right down here okay so we cycle through all of the ones on the aggressively then recycle through the plate and if we do find that ingredient on that plate then we have an ingredient found so over here if we have a not ingredient found then over here that means this recipe ingredient was not found on the plate so if that happens then essentially over here we have a phenocate so the ingredient that this recipe requires is not on the plate so let's go up here when we have the same number of ingredients let's define a Boolean called the plate contents matches recipe let's see found it to true and over here if we don't find at least one of them then the plate contents do not match the recipe and afterwards we can check this bowl again so if this one is true that means they all match if just one of them does not matches then this one won't be false so over here we know player delivered the correct recipe so over here on let's do a quick debug down log and print out a message and after we do let's also do a return so we stop the rest of the execution so basically if we find a waiting recipe that matches we don't want to keep going and also here if we do find it let's also remove it from the list so let's go into waiting queue remove at and remove at this index okay so we're going to remove this recipe but if this doesn't happen then it's going to be keep cycling and it's going to cycle through all the recipes so basically if it reaches the end this far then basically no match is found so the player did not deliver a correct recipe so let's do another debug in here okay so this is done for logic it looks a bit complex but I hope this was easy to follow when we see it in action It all becomes a bit more clear so all that's left is just calling this function from the delivery counter so let's do that over here on the delivery counter it accepts plates and destroys plates but before we destroy let's go into the delivery manager which means we need to access a reference so again we could add a serialized field or in this case it makes perfect sense to make this a Singleton so let's make it here public static of type delivering manager call it instance with a public get and a private set okay then over here on awake let's set instance equals this all right so now over here on the delivery counter we can go into the delivery manager access the instance and deliver our recipe and pass in the Plate Kitchen object okay that should do it let's test all right so let's look in the log to see what they are waiting for so there are two cheeseburgers waiting another Mega burger and a cheeseburger so let's make a cheeseburger to deliver so first of all let's cook some meat let's slice some cheese let's pick up the meat before it burns pick up the cheese and we just need the bread okay this is a valley cheeseburger so let's deliver it and if there go the players delivered the correct recipe okay great now let's deliver something that nobody asked for let's say just some meat actually let's burn it just for fun all right so there we have a bunch of charred meat so nobody really wants this but if we deliver if their yield player did not deliver a correct recipe alright awesome so over here everything worked we have a bunch of recipes being generated and then we have the logic so that when the player delivers something it checks if the players delivered something correct or incorrect so everything is great all that's missing is obviously some nice UI so let's do that in the next lecture hello and welcome I'm your code monkey in this lecture we're going to create a nice UI visual to display our waiting recipes okay so our delivery manager is already working we are randomly spawning some random recipes every once in a while now instead of looking at the console let's add a proper UI so for that over here in the editor let's go inside the canvas and by the way let's click on the button to unlock the canvas and this is actually the first time we're using the Ragnar canvas quite a while ago we just created it we didn't really set it up so let's quickly do that for the render mode this one is meant to be a regular UI so let's leave it on the screen space overlay then over here on the canvas scaler instead of constant pixel size let's go with scale with screen size then for the reference resolution I like to use 1920x1080 and finally unlike to fully match with the height basically this means that objects in the canvas will be scaled if the height changes for example let's add inside just a quick UI image just a test let's look in the game View so there you go there's the image let's just put on a different color okay so there's the image and note how if I modify the aspect ratio here so let's say I put it on 5x4 there go the horizontal side of the window change but note how the element was not scaled so I can put it even on free aspects so really wide and does not change the size whereas if I modify this if I modify the vertical size the image does indeed get Scaled up or down personally I like the setup because means that I only have to worry about positioning things horizontally if the vericon part gets changed everything gets automatically scaled okay so great so over here let's go back into 4G all right and let's get rid of the image all right back in the scene view let's quickly look at the canvas so we can select the canvas press the F in order to zoom out and also we can press the 2D button up here to go into 3D mode okay so here's our nice UI now inside the canvas let's create them to game object call it the delivery manager UI then in the inspector let's make it stretch to occupy the whole thing so let's put zero on everything okay so this window now occupies the entire screen now inside let's do just like we did a while ago for the plate icons meaning let's make a template that we can then clone but let's also put those templates inside of a container so first of all let's make the containers so a new empty game object of currently just the container the reason why I'm going with this approach is because I also want to have other objects outside of here if you remember how we did with the templates we can actually go there and see so let's go inside the prefabs inside the counters actually it's on the kitchen objects let's go inside the plate over here for the template basically we use the play tokens UI this main canvas as the container but if you remember how we did that in order to make sure we didn't end up with duplicate icons we always destroyed the previous one when we spawned a brand new one so every time we were cycling through the children of this object in order to destroy all of them except the template so over here we're going to use a container so that we can apply the logic only to the children of the container and that way we can have other objects outside of the container for example outside of here let's say we want some nice text just saying recipes and waiting so on delivery mansion let's make it a challenge down let's go into UI and let's make a text text mesh Pro and this is the first time that we're using text mesh Pro so this window pops out it's actually import mesh Pro Essentials okay just let it import okay that's it we don't need the examples are extras so let's just close this window and over here on this window let's name this the title text let's set the text to something like recipes waiting let's put it up there on the corner so let's anchor it on the top left corner also for the text I like to put it on a width and height of zero but of course that makes the text really vertical so then down here on the wrapping let's just disable it so there you go looks like that and let's put it over there on that corner now in scene view we are seeing things different so if you want to see what this looks like just go into the game View and over there yep we do see the recipes and let's just make it in bond so there you go just some nice text okay so that's our text and then for the container let's make inside the delivery template so let's create an empty game object let's go with the recipe template and for this one we're going to want to Anchor it to the top left corner so with the template selected over here in the inspector let's click and we want to click up here however we also want to set the pivot so let's make sure to hold down shift in order to set the pivot over there okay great that's exactly what we want so we want the template right on the corner then let's give it a size of say 250 by 100 okay now inside template we just need two things we want to name the recipe as well as the list of all the ingredients although before that let's actually make a nice visual for the background so a new UI image for the background let's make this one stretch to occupy the whole thing let's put everything on zero okay that's the background let's put it on a black we're just a little bit lower Alpha okay that's good then for name let's make a text field so inside the template let's create another text call it the recipe name text then over here let's put it a bit small so on the font size of maybe just 20 let's put it in bold and let's also again put the width and height of 0 and over here make sure to disable wrapping okay so that's the text so we've got it up there let's just anchor it to the top left corner okay great over here we can change the name to recipe and then what we need is the icons on here and for that we're going to do pretty much the exact same thing that we done on plate but before we do that logic let's just get this basic setup working so let's just position everything so first of all the container for all the templates let's anchor it on the top left corner and let's push it all the way over there and for positioning them let's use this time the vertical layout group so inside let's duplicate the template just to be able to see them okay so that's pretty much we want we can actually set the width and height both to zero and let's set the spacing to something like 30. okay so that's our basic UI now let's make the script to run this so over here in our scripts let's create a brand new C sharp script for the delivery manager UI let's go into the parent game object and let's attach your script let's open okay so now here first we need a field for the container another one for the template so let's do a serialized film private transform for the container and another one for the transform and this is going to be the recipe template then let's do pretty much same thing we did previously so first of all let's actually go on a way in order to hide the template so game objects set active into false okay so first we hide the template then let's make an update visual function so private void update visual and for updating we're going to do the exact same thing that we did so first let's cycle through the container and destroy everything except for the template so do a 40 inch transform child in the container and if the child is the template if so then we're going to continue and if not we're going to destroy the child game object okay so we have the cleanup now we need is the second through all of the waiting recipes so that means that over here on delivery manager we need to expose our waiting recipes on list so let's go down here make a function to do that probably going to return a list of recipes so get waiting recipe so list and we just return the waiting recipes on list okay great so now here on the UI we can now go into the delivery manager xsc static instance in order to get the waiting recipes on list so let's cycle through this so do a 40 inch for each recipe so recipe so in the waiting rest vsl list for each of them let's instantiate and let's spawn our recipe template spawn it inside the container and then we just need to set this to enabled so let's read the transform for the recipe transform we grab this one grab the game object and set active into true okay so like this the only thing missing is the text but that's okay for now let you see where we're going to call this function to update the visuals and as usual we want to be smart and write some good clean code so let's not do the dirty approach of just updating this on every single update instead let's only call this function when something actually changes so over here on the delivery manager let's just make some simple events so if I'm like event event handler let's go on recipes fund and another one call it on recipe completed and actually as soon as I add the event handler which also add the using system now here we have an interesting thing we've got a nice namespace Collision it's telling us that random is an ambiguous reference between Unity engine now random and system.r random that is because both these namespaces Unity engine and system both of them have a class named exactly random so the code here does not know which class we're trying to use to solve this component we really just need to be more specific in this case here we want to use the UNT engine version so let's just write the full name Unity engine.renom and yep that works okay so now let's fire off the events so first of all the own recipe spawns over here when we spawn a recipe let's invoke this event so this is ventar is not empty and let's also get rid of the log we know we need that okay now we could also add the wedding recipe on the event artist but in this case we don't need it just firing the event is enough and then down here when the players delivers something if the player delivers the correct recipe we remove it from the list and then let's fire off the event so on recipe completing let's invoke with this and event rx.mt okay so we have the event and down here we also don't need analog okay so that works and finally over here on the delivery man GUI let's just make a private void start on start going to the delivery manager access the static instance and listen to both these events so they spawned and let's also listen to the other ones the library manager instance on recipe completed when either of these work let's just go and update the visual so just like this let's also rename this because again instance doesn't sound like a very good name let's actually rename this to only remanager and same thing up here by the way I'm using the visual studio shortcut control RR in order to rename this to delivering manager and finally we also need to update the visual OnStar just make sure the previous ones do not show up okay that's it so like this it should be working we should be able to see no Visual and then as more our spawned we should be able to see each one being spawned until the maximum so let's see just over here in the UI let's make sure to drag the references so the container and the template and let's hit on play and okay right away actually it spawned one recipe it spawned instantly then after four seconds there you go a second one and after four seconds we should be able to see yep another one now four more seconds and we should see the final one and now no matter how long we wait it should no longer spawn anymore and yep that works alright awesome so the basic logic is working now let's handle the proper Logic on the template for that like I mentioned previously one approach would be over here you could go and do a transform.find the actual recipe name text then get the text mesh component and set it that would work but like I mentioned previously that would be very dirty not good at all we should avoid using find at any time and we should also avoid the individual logic from the total logic so let's do it properly and make a proper script to handle each spawn template so let's create a brand new csharp script call this delivery manager single UI single just because it refers to a single recipe and also right now we already have quite a few UI scripts so let's organize our project again so let's organize new folder for the UI and inside let's put all of our UI scripts so if we manage is single this one deployed icons white icons and the progress bar so let's put all of these nicely organized in the UI folder okay so with the script let's go into the recipe template and attach the script now let's open and over here let's begin by adding a film for our text so a serialized field and over here it's also very important for the text we are not using the text inside DNT engine.ui this is the in Legacy text it is not text mesh Pro so this is not what we were using instead we want to use text mesh Pro U going which is inside TM Pro so we need to go up here and add using TM Pro and now we can use this type and also make sure you're using text mesh Pro ugui and not text mesh Pro this one also exists but don't mix these two these are two very different types if we go over here in the editor and if outside the canvas if I just create and create new 3D object a new text object if I do that then if we look over here in the inspector we see this one as a type text mesh Pro whereas for the ones that we're using inside the canvas if we unlock this is text mesh Pro it's a UI text so these are the two different classes within text mesh Pro you have text mesh Pro and text mesh Pro ugly we're working on the UI so we want this one okay so we named this the recipe name text okay that's it over here in the editor let's drag our reference all right so now this group let's make a function to set the recipe so a public void and let's call it set recipe SL they're going to receive a recipe so recipe so then we just go into the recipe name text and we set the text to recipe so dot recipe name okay so that's pretty much it now over here on the Y script when we instantiate our recipe transform let's get component of type of our delivery manager single UI and call set recipe so and pass in the recipe so okay so let's see if the name shows up any operator wait does show up so we can see that we generate a cheeseburger recipe and right now a mega burger recipe okay great so all that's left are the icons on here so like I said that is going to be yet another usage of our template pattern so inside the recipe template let's create an empty game object currently the icon container and then inside that let's make the template and template is just going to be an image so we can just create an image to our way called the ingredient image let's scale it with a size of 40 and 40. let's put a image by default just like that and on the icon container let's put the width of zero height of zero and let's put a horizontal layout group put it over there on the left side and we can create a bunch more just to see how it looks okay so that's pretty much it now over here on the single script let's add a serialized field private transform for the icon container another one for the icon template then we do the same thing as usual so when we set the recipe so let's first of all clean up the container so let's do a 40 inch transform child in the icon container and if the channel is the template then we want to continue and ignore it if not we want to destroy the child.game object okay so that's the cleanup and then let's do a four inch kitchen object as so in the recipe so dot kitchen object.zone list second through all of this let's instantiate our icon template instantiate it inside the icon container so this is going to be the transform for the icon transform then as usual we need to go into the game object set active in order to enable it and also let's go up here make a private way to wake and on awake the icon template game object let's disable it okay we don't want the template to be visible okay so we instantiate the template we set it as active then since this one just has an image we can just do a get component of Type image that's image not image conversion so image so it's this one the one inside Unity engine.ui so let's get this image and let's modify the Sprites and set it to this kitchen object so that's right okay so that's it that should do it let's test over here in the editor let's just go into the template let's drag the container reference and the template reference and let's also rename this instead of ingredient image put icon template just to be a bit more clear and we can get rid of the other ones or leave them doesn't really matter okay great so let's hit on play and see and yep right away does work so we can see a burger is composed of a burger and a bun a satellite yep there you go some sliced cabbage and sliced tomatoes then cheeseburger same thing as the burger with some cheese and then another Burger let's just deliver until we see the mega Burger so let's deliver a cheeseburger let's cut it get this get some bread place it in there pick it up before it burns that's a cheeseburger so that one should vanish and if they're good does vanish let's see something else not cheeseburgers so let's keep doing until we get a Mega burger just see that everything works so let's deliver a regular burger okay now let's deliver a regular salad okay just pick up like that like that and drop it okay let's see any up there it is the Mega butter all right great so the visual logic is fully working and the delivery logic all of it is working so I can deliver the right recipes and get rid of them from the recipe waiting list and more are spawned every time here we can see the name of the recipe as well as all of the nice icons okay so with all this our game is really taking shape everything is very close to being done one massive thing we're still missing is an obvious one which is sound so let's do that in the next lecture hey again quick intermission you're almost at the end so once again congrats for making it this far this is the second secret call out go ahead Post in the comments a timestamp and a nice monk Emoji it won't be fun to see how many people make it to this point by now you already know about the website I hope it's been very useful to you and you already know to ask any questions in the comments if you need help with anything so that's life for me to say right now is thanks for watching the course so far and I really hope you've already learned a ton there's only a bunch more lectures until we get to the final polish game so let's continue on the next lecture hello and welcome I'm your code monkey in this lecture we're going to add some audio to our game starting with a really nice music track okay so our game is already looking pretty good but everything is still way too silent so let's begin by adding some music adding this is actually extremely new in the included assets over here inside the sounds we've got a really nice music track I hired a musician to make this it sounds really good it's a seamless Loop so to add to our game it's going to be super simple we just want a constant neverending Loop so let's begin by creating an empty game object call it the Music Manager let's reset transform keep things organized and let's add a component and we want the component an audio Source here it is this one like name implies this one acts like a source of audio you will note how by default on the main camera down here it already has an audio listener so the source plays some sound and The Listener listens to it now for here we just need to set these fields so for example on the autoclave let's make sure to drag the music audio okay great next over here and let's enable and play on a wink we wanted to start playing right wing and for this track we do want to enable looping okay great then for priority basically UNT has limited to how many sounds can be played at once if you play too many then some sounds won't play and which ones do you play is all based on priority we always want the music to play so let's put this one on Max priority then for the volume later on we're going to make a proper option screen to handle this but for now let's put it on something like 0.4 or 0.5 just make a nice background track then we have here the spatial blend for this music track we wanted to play the same regardless of where the camera is so let's make this all the way if only a 2d sound okay that's it we don't need to play around with any of the other settings and just like this if we are on play any up there's the music now if you're not hearing anything make sure that on the game view first of all that the game is actually selected make sure the scene is in Focus so over here I can move around so the game's in Focus then on game view we are on the top right corner make sure this sound icon is toggled if not then everything is muted and also again make sure like I mentioned on the main camera that it has the audio and listener component with all that yep you should be able to hear the music now this song is playing and it won't Loop forever just like we wanted personally I really like how it sounds I'm really happy with what the composer made it perfectly matches the E5 of the game so it really is this simple to add some music to the game let me just point out one thing also related to sound one of the things you can make is an audio mixer so for example on the project files let's create a brand new and let's find over here the audio mixer so there you go here is an audio mixer then you can double click to open up the audio mixer window and then over here you have the masternode and then you can create multiple groups so let's create a brand new groove for something else and then you can play around over here with the effects with the volume all kinds of things all kinds of effects everything then for each sound where you have the audio Source over here note how you have an output and for this output you can set it to play on the message so it plays on everything or set it on just one individual group so with this you could assign a group to one individual type of sound effect or the music or so on maybe you could even have your music split into multiple stems so there's a lot you can do but for me I'm not an audio engineer audio is probably the part of game development that I know least about I just stick with the absolute Basics but if you want to learn more definitely look into the audio mixer this is an extremely powerful tool but like I said for me I don't know how to work with it so I'm just going to stick with the basics so on the output let's revert back into none close the audio mixer and get rid of this and there it is music is playing and the wrong sounds really nice alright so here we very easily added some music to our game this lecture is actually super short because it is generally that simple now the next thing that we need is not going to be a little bit more complex and that is adding sound effects so let's do that in the next lecture hello and welcome I'm your code monkey in this lecture we're going to add some sound effects for our game okay so previously we already added some really nice music now let's add a whole bunch of sound effects in the project files if we go inside the assets over here we've got all kinds of sound effects recently I heard the really nice sound designer to make all of these and I think they all sound really great so let's add them to our game now when it comes to sound effects there are two main ways to play a sound one is just like we did for the music so we can create a game object at the audio Source component and play it that's one approach but that basically requires prepreparing the sound objects so there is another simpler way that just requires one line of code so let's begin by making a Sound Manager game object so a new empty game object for The Sound Manager let's reset the transform now let's make our script so let's go in the scripts folder create a brand new csharp script for The Sound Manager let's attach the script and open okay so now here let's make a function to play Simple sound so let's do a private void just call it play sound and over here the way we play sound through code is actually super simple we just go inside the audio Source class and in here there's a static function play clip at point this as you can see it takes an audio clip a vector 3 for the position and finally a volume so basically it won't play that sound on that position by default TNT already has 3D sound so if you play the sound on the left or the right side of the camera it won't play in the correct place also for the volume the further away it is from the camera the lower it will be and if we don't want the 3D sound we can just play it directly on top of the camera position okay so in this function let's receive our arguments so for the audio clip it's going to be our audio clip then let's receive the vector 340 position and let's also receive an optional one for the volume let's just default this to 1f okay so here we just pass this in into our function so the position and the volume okay great so now let's call this nice function and for example let's start with a simple one so let's start with the delivery sounds so over here on the delivery manager script down here we have the logic for delivering a recipe and over here we know when we completed a successful recipe or when we failed and the player delivered a wrong recipe so this is where we want to play some sounds and again here we have yet another very important clean code question we could definitely call the play sound function directly from here that would work but of course that would make this class tightly coupled with The Sound Manager for a simple game on this scale that approach can work just play sounds directly from the logic code however again to make things properly we should really separate the logic from the sound just like we separated in logic from the visuals so instead let's not call the sound directly from here instead let's make two more events so let's make one on recipe success another one on recipe failed okay so now let's fire off these events so over here we have the success so on recipe success and if we get down here then we have a fail so on recipe fail okay great we have two events now back here on The Sound Manager we can just listen to those so let's do a start go into the delivering manager access the instance and listen to the on success and on failed events let's listen to that one delivery manager instance on recipe film listen to both of these again let's write some good clean codes so let's rename this one instead of instance let's put it delivery manager and same thing on this one also name it correctly delivery menu okay great so now when you have this we want to call and play sound and now I want to pass in a reference to the recipe film sound so technically one approach would be appear to add a serialized film for an audio clip that would work but since we've already done that so many times in this course here let's use a different approach that I also like to use let's create a scriptable object to home the reference to all of our sounds so similar to how we Define the script object on all of our recipes let's just comment this out just make sure the code compounds okay great so back here in the editor let's make a new script more object type so let's create a brand new csharp script for the audio clip refs script long object now here let's make this a simple scriptable object with a create asset menu okay so now for the fields if we unlocking the S over here the audio design that I hired actually made several variations for each sound so we've got multiple chops multiple delivery fails and so on so back in the code here instead of storing a reference for a single audio clip let's store an array for all of them so we have the chop then we have on the other Solutions and all of the references so there's a job there's the delivery fail then we have delivery success then we have footsteps then the object drop then the object pickup then we have the stove Sizzle although this one is just one then we have the trash and finally we have the warning alright so these are all of the sound references we're going to use back in the editor let's just create the object so on the script mode objects let's create a brand new one let's make it of audio clip per episode just name it audio clip refs so and over here let's just write the references so let's use that quick ENT tip in order to unlock the inspector now I can select all the chops and drag them all the delivery fails drag them it's only resuccess drag it then for all of the footsteps after that are all of the object drops then the pickups then we have the sizzle which is just one finally we have the trash and the warning okay those are all the references so our script on object now has all of the data we need let's unlock the inspector okay and back in the code here on The Sound Manager let's make another version of this function so let's make one play sound except instead of receiving an audio clip it receives an array of audio clips then basically we just call the other function so we call the other place on function and pass in an audio clip from this array so let's actually rename this so audio clip array and let's pass in an audio clip from here so do a simple random.range between 0 and the array down length pressing the position and the volume okay so just like this now we need is a reference to our suitable object so it's generalized film private of the audio clip refs SL okay we have this then here in the editor and let's just assign the reference so the audio clip refs okay great and over here when we have the recipe failed let's go into the audio clip refs and let's pick up this one instant delivery fail and then the other one is going to be delivery success for the position let's just default to the camera dot main transform that position so like this it sounds like exactly on top of the camera okay so let's test and see if it all works okay so here we are and let's do a wrong delivery now quick warning if you're following along or if you're just watching the video this sound will probably be way too loud but let's test so if I just pick up the plate and I just deliver an empty plate yep there you go there's the sound and now if I deliver a correct one so someone wants a salad so let's cut a nice salad chop that chop this pick up the plate pick up that one and that one don't be the correct salad any of that I go with those were all right great so the sound effects work they played perfectly but they're a bit too loud basically that's because these sounds were designed to be played in the world rather than on top of the camera so when we play the sound let's actually play it on the position of the delivery counter here is the delivery counter script and based on our design we're only going to have a single military counter so we can just make this a Singleton so as usual public static of type on Livery counter call it instance where they probably get and a private set then on privatoid awake let's just set the instance equals this okay so over here on The Sound Manager we can just grab delivery counter delivery counter and we just go into Library counter and grab the static instance and then for the sound position we can just go into delivery counter access the transform that position okay so just like this on that one and on this one okay so it says now it shouldn't be as loud okay so here we are and let's do a wrong delivery any hope it does work now let's be successful delivery so let's make a nice cheeseburger so grab some cheese slice it grab plate just need some bread and delivered any of there you go it worked all right awesome okay so this is really it this is how we're going to play our simple sounds now there are some that are going to require more logic like the footstep sounds and the stove Sizzle but first let's begin by adding the simple ones so let's begin with the chop sounds this is super simple we just need to go over here onto the cutting counter and actually we already have the uncut event that we made previously this was used to spawn the visual so we can also use it to spawn these sounds however there's actually one difference we're going to have multiple cutting counters and this one as you can see this one is not a static event meaning each different counter is going to have each list of listeners and we really don't want to have to subscribe to every single one of the counters individually so what we can do is instead of making it a regular event that belongs to each instance of a cut encounter we can make a static event which won't belong to the entire class but we still want to leave this one just for the visual so let's do another one a public static event event handler and let's call it on any cut basically for any static events that belong to any object type I like to add the keyword any we're going to fire this event when any cutting counter is going to trigger a cut action so where we fire this event is exactly the same thing so over here we've got the uncut and let's do the exact same thing so on any cut with this an event R is not empty okay so we have our nice static event and over here on The Sound Manager let's listen to it so let's go into the cutting counter again we're going to access through the class name and let's listen to the on any cut event and over here let's just play the sound so let's play the sound let's go inside the audio play prefsl and let's grab the chop sound then for the position we want to know who fired this event and by following the csharp standard over here we already have the object sender so we know this was the object that fired this event and we know this is going to be of type cutting counter so we can just get cutting counter cutting counter and we just grab the sender as a cutting counter okay so we have this and then over here very simple access transform that position okay that's it great that won't play The Cutting sound on that position on that cutting counter okay great now let's handle the player picking up something and for that let's go over here onto the player class and the way we set up the kitchen object parent system is actually already perfect for this down here we have a function so if we scroll down Yep this function set kitchen object this one is called whenever the player receives a kitchen object which means really when the player picks up something so if this kitchen object is not known then that means the player picked up something so let's do that so up here and let's make the event so a public event event handler call it on pick something and then down here just to be test so if the kitchen object is not known so if the player did pick up something then let's just fire off this event so just view our usual invoke with this an event RX rmt okay so that's great then on the sound management let's just listen to it so let's go into the player Quest let's access these static instance and let's listen to the on picked up something event and again let's rename this to a proper name so player on pick something and over here let's just play the sound and for the sound go into the refs and grab in this case the object pickup and for the position let's just go player dot instance and gravity transform that position okay that's it next for item dropping now we can only drop items on a counter so over here we have the base counter class and again we have the same thing so we have the set kitchen object and again the same thing as with the cutting counter we don't want to be required to listen to every single counter we just want to listen to one event so let's make it up here so if I'm like static event of type event handler and let's name it on any object placed here and then down here when we have the set kitchen object we do the usual if kitchen object is not known if so then let's fire off this event okay great and on the song Imagine let's listen so go into the base counter on any object placed here when that happens play the sound then let's go into the other top prefs and this one is the object drop so that one and for the position let's do the same thing we did so we cast the base counter equals the sender as a base counter and then we go into the base counter and let's grab the transformed up position okay so we just need one more special counter type here we have the trash counter and this one it never really changes the parent it just destroys the object it's over here on the trash counter itself let's fire off an event but again let's make it static even though we're only going to have one trash but make it Saturday just to be able to support multiple so public static event Handler on any object trashed and then over here just fire off this event so invoke with this and eventar is not empty okay so now if we go into The Sound Manager and over here once again the trash counter on any not the on any object place but on any object trashed and on this one let's do pretty much exactly the same thing so let's copy this the sound is going to be the trash sound instead of a bass counter we could just cast it to a base counter but let's make it proper so let's make a trash counter as a trash counter and this is a trash counter okay great that's it so these are all of our basic simple sounds as you can see all the logic is super simple so let's test and see if it all works okay so first of all let's pick up an object so if I go into a container and I pick it up and if there you go there's the sound now if I drop it somewhere and if there's a sound now for the trash pick it up drop it on the trash anyhow there's the trash down okay great then also let's check out the cutting so if I pick up some cheese drop it there and cut and if there go got a really nice cutting sound okay so far so good now let's handle the more complex ones starting off with the stove for this one the sound is meant to be on looping but only when the sub is on so we don't want to just play once but play and stop playing depending on the state of the stove so for this one instead of spawning the sound through code let's actually spawn it on the object itself so let's go inside the stove object let's go on the stove counter and open up the prefab and inside this prefab let's create a brand new empty game object name it sound let's reset transform make sure it's on zero zero zero okay great now let's add an audio Source component and for the auto clip let's use the pan sizzle let's make sure to not talk on play on awake but we do want it to Loop and let's also make it a 3D sound okay so that's the basic setup Now to control this let's make a script so let's go into our scripts folder and let's create a brand new csharp script come with the stove counter sound let's attach the script over here and let's open it so now here first let's grab the audio Source component so we've got a private audio source for the audio source and just go on awake and audio Source sequence get component of type audio Source okay then we're also going to need a reference to the stove counter so let's uh appear a centralized film private of type stove counter for the stove counter then back in the editor let's drag that reference all right now on the stove counter over here we already have the states and we have the onsite change event again the same one that we use to modify the visual so on the sound lets you pretty much examine the same thing over here let's do a private void start and on certain let's go into the stove counter and listen to the on stay changed event and basically when this changes we want to check if it's frying or fried if so then we want to play the sound if no then we don't want to play it so let's define a ball call it play sound and we're going to play if the state equals we are frying or the state equals that it is currently fried and about to burn Okay then if we have a play sound then let's go into the audio source and comp play and if not then let's go into audio source and call pause all right so that's it pretty simple let's just make sure to save our prefab go back outside and let's start on play and okay four stars there's no sound playing now if I pick up some meat and I drop it on there and if there go there's a sizzling sound and continues going and now it is still sizzling but if it burns it should stop so if I go and if there go the sizzling soundstomp all right awesome so let's take this one out let's actually trash it now let's pick up another one let it cook and once let's go pick it up and there you go the sound of the Stomp all right awesome so we just have one more final sound remaining that's the footsteps by the way the warning sound is going to be added during the Polish lecture for the footsteps we want very much the same thing that we did on the stove so we're going to want a script to handle that logic but this time we don't need an audio Source on the player we're going to use the same play Method as the other ones let's just make a script to run the sounds so let's make a new csharp script for the player sounds let's go into the player game object and attach the sound okay so here let's first grab the player reference so private player player and on private way the way let's get the component of type player and assign it to the player okay then for the footsteps basically we want to play them every certain amount of time so let's do appear a private Cloud for the footstep timer another one for the footstep tower Max and let's say you want to play say 10 times per second then we do a basic update and on update footstep timer countdown by time.com time and if the footstep timer is under zero then let's reset it so set it to the maximum and it's in here that we're going to play the sound so now here we have two options we can fire an event here and we can listen to it on The Sound Manager so exactly the same thing that we've been doing previously or we can just trigger the sound directly from here doing that will mean that this class is tightly coupled with The Sound Manager usually we want to avoid tight couplings however in this case the player sounds class this one is really only meant to exist alongside the sound manager so in this case it's perfectly fine to totally coupon them so let's play the sound directly from here which means we need a reference to The Sound Manager we can make a serialized field or just make this a Singleton so let's do that so a public static type Sound Manager name it instance where they probably get any private set then on private void awake we just set the instance equals this okay so then over here we can just access it so just go into the sound manager access the instance and we call play sound which we actually need to make public however this function also takes a reference to the audio clip array so that means we need a reference to the audio clips so again we have multiple options we could add over here on the player sounds at a serialized film for the footstep sounds or we can just make a specialized function over here on The Sound Manager both options can work just fine let's go with the second one just to be different so just make here a public void play footstep sound we're just going to receive a vector 3 for the position and then we just call play sound let's go into the audio clip refs ASL and let's pick up the footsteps and play it on this position and let's also receive the volume just appear a fault for the volume okay so that's right now we just need to call this function it's over here on the player instead of calling play sound let's go on the other one play the footstep sound then for the position that's the player transformed that position and for the volume I just exposed the volume just in case you want to make the footsteps a bit more sound or not but for now let's begin with one F and then see if that's waiting around as usual instead of using magic numbers let's define a fluid for the volume put it at 1f and over here use the volume okay great however you might be noticing an obvious issue here right now this is going to play nonstop obviously we don't want to do that we only want to play footstep sounds if the player is actually moving so this presemble we just need to ask the player if it is moving and we already did that so player is walking so if the player is walking then you play The Sounds if not we don't okay that's it so let's test so here we are and if I'm standing still there's no footsteps okay that's great and as soon as I move yep there you go we got some nice WhatsApp sounds all right great so with all that we added all of our sounds now here note how we mostly use this method of going into the audio source and using the play clip at Point function this one is great because it is so simple but it does have limitations specifically with regards to all of the options if we look on the audio Source component here we have all these options so you can use an output use an audio mixer like we saw in the previous lecture we can play around priority play around the pitch make it 2D or 3D play around over here with how the sound falls off so tons and tons of options that you can't really access if you use that simple function so one approach if you need these options you could make each sound a prefab so make a prefab for each different audio clip and then instead of calling that function you would simply instantiate that prefab to spawn that audio so if you have lots of options depending on how complex you want your sound to be but for a simple game and for simple sounds this one line of code is super simple alright so here we have added sound effects to our game that component with the music that we had previously already makes everything sound so much more alive it's really starting to look like a proper game the one thing we still don't have is some kind of game start and game and scenario so let's have that in the next lecture hello and welcome I'm your code Maki in this lecture let's add a simple and beginning state to our game so right now we can play the game of the mechanics everything works perfectly and it's all been implemented however in the beginning of the game it just starts right away as it loads there's no start no countdown no time for the player to get ready someone sort that out with a simple countdown let's begin by making a general game manager script to handle all of our general game States so let's create a brand new csharp script and now here you could use the name game manager so you could use this name however for some reason yantian likes uh this custom icon when a script is named exactly game manager personally I don't like this I don't want it to be a different icon I want this script to look and behave just like any other one of my scripts so personally I don't like this but if it doesn't bother you then go ahead use it doesn't really change anything just a visual but in my case I prefer to give it a different name so sometimes I call it game Handler or other times just something related to this game like for example the kitchen game manager and just like that it won't have that custom icon just need to go inside and rename this to Kitchen game manager okay save the script and all right now let's make a game object to run it so a new game object with the same name let's attach the kitchen game manager and reset transform okay let's go now here we're going to Define all of the various game states that our game can be in so for that let's define an enum so a simple enum call it state and for the various States let's say we are first of all waiting to start then we are on countdown to start then the game is playing and then we have a game over okay so these are our states let's do a private void awake and on the waiting list of the state so we need to store a state for our state and on a week we set the state equals and let's begin on waiting to start by the way the point with this waiting to start say it will also be very important in the next video covering multiplayer basically we're going to wait until everyone is connected before we start the actual countdown but over here for now we're just going to wait a little bit on the waiting to start then we're going to trigger the countdown and then after some time trigger the game playing state so pretty much all of these states are going to be time based so let's make a simple timer so a private float for the waiting to start timer let's begin on something like 1f so we just wait for one second then let's make a private void update and let's make a state machine just like we've done previously so do a switch on our state in case we are on state DOT waiting to start if so then let's go into the waiting to start timer count it down by time dot Delta time then if the waiting to start timer if it is under zero if so then let's move into the state equal state DOT let's go into the countdown to start okay so that's it and the other states are going to be pretty much exactly the same so let's just copy this so we have the winning start and the countdown to start then we have the game playing and finally we have the game over and that one doesn't have anything so just like this like I said we could reuse the same timer but let's write our code nice and proper so let's make different timers for each so let's make three timers so we're going to have the countdown to start timer so countdown for this one let's see Fallen two three so we're going to wait three seconds before we start and then the game playing timer and for this one let's put it something short just for testing so let's put it just test and then down here let's just use them so on the countdown let's count down this timer on the game playing count down this timer when the countdown ends we go into game playing and when the game playing ends we go into game over alright so that's our super basic state machine just a bunch of timers super simple let's do a quick look just to see so over here just say debug.log and let's just print out the current state okay so just like this let's test and yep right away we are waiting to start after one second going to countdown then after three seconds go into game playing and now if we wait for 10 seconds after 10 seconds we should be able to see just a little bit and yep there you go we've got our game over okay great all the logic is working although we actually didn't change anything technically the game right now is on a game over but everything still works the same experience only so I can still play I can still do everything so let's sort them when we are in any state other than the game playing State we don't want the player to be able to interact with anything we want to leave it movement because that's usually nice and fun but we don't want it to be able to interact pickup objects or do anything so let's do that basically over here on the game manager let's just expose the function so public pool let's call this is game playing then over here pretty simple just return if the state equals state DOT gameplay that's it so now we can go into the player script so over here on the player script let's go down into the interaction function so over here we've got the interact alternate and the interact and on both of these basically let's just ask if the game is in the game playing state if so we want to interact but if not then we don't want to do anything so to access the game manager we could add a pure serialized field or as usual let's just make a nice Singleton so pure public static of type kitchen game manager the instance make a public get and a private set then down here on awake let's set the instance equals this okay so now over here on the player let's just go into the kitchen game manager access the instance and test is game playing and we're going to do an if if the game is not playing so if we are not playing we want to stop this so let's just return so if the game is not playing the code is going to stop executing here and same thing on the interaction so just like that we won't be able to interact with anything once we are not in the game playing State okay so here we are waiting to start nope I cannot pick up anything count down to start nope I can't and as soon as we go into game playing yep now I can't interact so I can cut a bunch of things and as soon as it goes into game overstate there you go currently in game over state so now if I try and interact nope can't do it okay awesome everything works perfectly so in terms of logic this is really it there's nothing else we need to do but of course right now the player would have no clue as to why sometimes they can grab and sometimes they can't so let's add a proper visual first let's add a visual to the starting countdown so let's do that as a canvas element so let's go inside our canvas create an empty game object name this the game start countdown UI let's press F to focus on the object press 2 to turn this into 2D okay so let's see and over here we really just need a text object so let's leave this one anchored on the center let's put the width and height both on zero we don't need that and then let's go inside create a new text object call this the countdown text and then inside let's just put a number so just a three let's put the width and height both on zero then down here let's put it in bond on a really big font size so let's say something like 250 okay really nice big number then let's also put it centered and down the middle okay that's right we've got our nice big countdown number also by the way when using text mesh Pro we can easily add a whole bunch of effects if we'll look down here we have the default text mesh Pro material and over here we can add an outline another line and so on so that's really great however there's one very very crucial thing when you want to add some effects always remember that the effects are being applied to the material meaning any text objects that are sharing this material all of them won't modify so for the most part usually you don't want to modify the default material if you do then everything using this default material will change like for example I want to add a nice thick outline to this one but over here I've got some regular text that is also using the default material so if I now add an upline and I increase the thickness and if there you go those also got an upline as well as this and if I wanted download make it quite a lot bigger there you go all of them modify because all of them are sharing the same material so usually you don't want to modify the default material if you want to add some kind of special effects always make sure to create a brand new material beforehand so over here let's remove the outline put it back on the dilation and let's go up here to create the brand new material first we need to find our phones over here on the font asset we can just click on it and we can see it over here highlighted on the project window so it's inside the text mesh profiler the resources phones and so on so here is the default font and inside this one is the font that we're using now in this font there's a nice little error icon and inside we can see the default material so let's duplicate this material although it's important make sure you duplicate the material and not the font so with this material selected I'm going to press Ctrl D and there you go it duplicates the material and over here let's give it some name so let's say this is material that I want to use for the start countdown so there you go just like this also one very very important thing the name of the material needs to include the font name otherwise it won't show up for example if I get rid of this the only version Sans SDF if I name the material just like this and now I'll look over here on the countdown text look on text mesh Pro here is the drop down menu for selecting material and over here note how that one does not show up so it is extremely important in order for it to show up in here it needs to have the same starting name so over here if I rename this material put Liberation sends SDF and then the name and now back in here now look and yep now I do see my material okay so that's great and over here we can add what kind of effects we want and it will only affect this one and not any others okay so for this one let's add a nice outline and let's make some nice thick numbers so over here on donation let's handle it by quite a little bit then for the outline color let's put it maybe on a blue something a bit like this okay let's push it back just a little bit okay I think that looks pretty good now if you want you could add even more effect to this I made another video covering how to use custom Textures in your font doing that you can just import the font directly into Photoshop and edit it with all kinds of effects for example in that method is example what I used in my game hypernite make the head counter look really nice I also have a tutorial specifically on that so if you want even more custom text definitely go ahead and watch those videos but anyways here we have our countdown text looking pretty nice now the number itself will be written through code so let's do that let's go into our scripts into our UI folder create a brand new csharp script for the game start countdown UI okay and let's select the parent object and attach the script now here first thing we need is a reference to that text object so let's add a serialized film private and again remember what I mentioned a couple of night years ago with regards to the types so we want xmesh Pro U GUI we want this one so it's going to be our countdown text and now for updating this text basically we just need to know the game state so we need to know when the countdown should show up and as usual let's use some nice events so over here on the kitchen game manager let's fire an event whenever the state changes so a public event event handler let's call it on stay changed okay just like this no need for the arguments so let's go down here whenever the state changes and let's just invoke this event so invoke this eventar is that empty so we change in there change in there and change down there okay that's it so now over here on the game start countdown let's see we've probably start and on start let's go into the kitchen game manager access the instance listen to the on say changed event as usual write some nice clean codes so let's rename this the kitchen game manager so when they say changes we basically want to show this if we are on the countdown to start so let's go here to the kitchen game manager and let's make another function so public boom is countdown to start active and we just return if the state equals the state DOT countdown to start okay so that's a nice simple function and on the UI script if the kitchen game manager if this one dot is countdown to start active if so then let's show if not then let's hide so else let's do a hide so let's make these functions so proud void show and a private void hide and on this let's just do the usual thing so game objects and active into true or over here set it into false and on start right after we subscribe to the event let's also hide it by default okay so that's the basic logic for showing or hiding it and now for the timer text technically over here once inside the countdown to start we could fire an event on every single update that would work but it would have some unnecessary overhead so instead another option is just make a function to expose it so let's go here make a public returning float get the countdown to start timer and we just return the countdown to start timer very simple so then over here on the UI script we can just make a regular proud void update and on update go into the countdown text in order to set the text and let's go into the kitchen game manager and let's get the countdown to start timer and just do A2 string okay so that's it super simple so on update we're going to constantly update the timer so let's see if this works back here in the editor let's just make sure to drag the countdown text reference and let's hit on play and okay waiting to start and after a bit yep there you go there's the number it's currently on countdown and now the game is playing so the show and high did work on the number seem quite a bit odd that's because over here on the settings we have wrapping enamel so now I just quickly disable this and let's test again sir we are waiting to start and there you go there's our countdown three two one zero and there you go gameplay okay so it did work now of course as it comes to the visuals it depends on what you want for example if you want to limit the decimals you can use over here the two string this one can include all kinds of string formats for example for displaying just two decimal places you can add the string format F2 let's see what this looks like waiting for the countdown and there you go now it does Show with two decimals okay so this is one approach alternatively another format you can use is number sign Point number number and let's see this one and yep there you go now it looks like this so as you can see there's lots of things you can play around with when it comes to the two string formats but in our case I don't really want any decimals I really just want to see whole numbers so for that let's just seal out this number so in mathf.cl let's see on this one out and then just do a two string okay let's see so wait a bit and we got three two and one and there you go the game is winning alright awesome so here we have our waiting to start and the countdown to start all of that logic is working perfectly now the next thing we need is to handle the game end so let's do that in the next lecture hello and welcome I'm your code monkey in this lecture we're going to handle the game over State now for the game over State this is obviously a game design question for example you can make it so that each recipe had a timer attached to it and the player had to create that recipe within time limit then if they failed enough recipes you could trigger some kind of game over or for something more simple let's just do exactly what we did for the game start let's just do a basic countdown timer after the game is over let's pop up a game over window and show how many recipes the players delivered so let's do that let's go into our canvas and inside make an empty game object call it the game over UI then over here let's stretch it to occupy the entire parent like this now inside let's begin by making a UI image this is going to be the background let's put it in black with just a little bit of transparency and let's also stretches to occupy the entire thing so just like this then let's make some text so let's make a new UI text click the game over text and let's say just game over let's set the width and height both at zero then down here disable wrapping put it centered let's put it pretty big so maybe 135 put it a little bit higher then for some more text let's duplicate this let's call this the enlay bone recipes delivered text and over here we just say recipes delivered let's put this one a bit lower and quite a bit smaller say on 50 okay and also on this one let's put it in bold then change the color a little bit okay next let's make yet another text this one is going to be for the final number so let's call this recipes don't deliver text and this one is just going to have whatever number of recipes we've delivered and let's put it over here and quite a bit bigger okay so this is the game over window that we want also a quick note like I mentioned previously the Sorting order over here on the UI is based on the ordering the hierarchy so for the game over we want this one to show up on top of everything else so make sure the game over it is the last one over here on the UI make sure it is the bottom most child on the canvas okay now let's make a game object to run this so let's create a brand new script game over UI let's go into the object wait for the compilation and let's drag the script okay now here the only reference that we need is just for the text so let's just make a serialized film of type text mesh Pro ugly for the recipes delivered text here in the editor let's just drag the reference okay now let's make some show and height functions and also show it just on the game over so really we're going to do the exact same thing that we did over here on the game start countdown so let's actually copy exactly this let's go into game over UI pass the exact same thing Okay so we've got the show and hide functions we test and then over here on the state change instead of showing this one on the countdown we want to show it on the game over so let's go over here and just make another function so public goal is game over and we just return if the state equals the state that game over okay that's a function so over here if we are is State game over if so then we show if not we hide okay the last thing we need is just for the text so this is going to be the recipes only vertex so we're going to set this to something which really means that we just need to keep track of all of the recipes that have been delivered so until here onto the delivery manager script and let's just keep track so just a simple end so a private end for the successful recipes amount and then whenever we have a recipe success so let's go here into our delivery recipe function whenever we have a success let's just increase this by one okay so that's it now we just need a function to expose this so we probably can't for the get the successful recipes amount and just return the successful recipes amount okay so finally back here on the game over UI let's just print it so go into the delivery manager xsc static instance and get the successful recipes amount and of course we need the string so to string except for this one this is never going to change after the game is already over so let's not do this on update that would be quite wasteful so let's just do it up here so as soon as we have the game over we show we print the recipes and that's it okay so let's test so here we are waiting for the timer and let's wait and just wait five seconds for it to finish and we should see a zero so let's just make sure that works so after a little bit of time yep there you go we've got recipes all over zero okay now back here again let's try and deliver some recipes now so let's try and make a cheeseburger try it only for that cut this one pick up this one pick it up put it in there and okay quickly all right good and there you go we've got a one all right Awesome everything worked perfectly let's just add one more final element right now we cannot see what is the time left in the game so let's add a nice lock element so over here on the canvas let's make another empty game object let's name this the game playing clock UI and let's also put it behind the game over UI so let's put it above on the hierarchy so that it shows up behind in order to be able to see what we're doing let's also just hide the game over UI but only here on scene view so let's click on the I icon okay so here we have our window let's just anchor it on the upper right corner so let's put it somewhere in there then inside let's create a new UI image come with the background for the Sprite let's go with these circles right so let's click on the eye icon to show all the default Sprites and let's use the one included with the circle so you have this one let's also add a nice little outline so let's put it on 2 2 with phone Alpha and let's also add a nice shadow just nice visual so on five minus five like that and for the color let's also put it some kind of dark gray okay so this is our background now let's duplicate this so Ctrl d and let's rename this one the timer image and for this one let's give it a different color so maybe something like a blue so something like this okay and now over here on the image type instead of simple let's go with filmed let's choose Radeon 360. okay great and now over here we can play around the film Mount and this will be our timer then you can set it up however you want for me I'm going to choose to start from the top so as it starts the time we're going to countdown Until the End okay so that's great now let's make the script to run this so let's create the brand new csharp script same thing the game playing clock UI and over here let's just attach a script so now all we need is reference to our image so let's make a serialized field private image let's make sure to use this one the image inside Unity engine.ui this is going to be our timer image okay like this back here in the editor let's drag the reference all right now that we have this we need to ask the game manager to get the timer normalized so let's go over here onto the kitchen game manager and let's make a function to return just that so a public float let's call it get plane timer normalized or game point timer actually just to match the state so get this one and up here we have the playing timer we just need to define a maximum in order to be able to calculate the normalized value so let's duplicate this call it the game timer Max and set this one to 10 and this one leave it like this and down here when we change the timer when we go into game pointing let's set this one equals this.mex that way we only Define the timer just up here okay so with that now down here we can do the compilation so we can return the game playing timer divided by the game playing timer Max except just like this going to be inverted because for the game playing timer we're counting down instead of counting up so all we need to do is our simple just reverses so just one minus just like this okay great so we have this function and then over here on the clock just go private void update and on update let's go into the kitchen game manager the instance let's get that and we're going to use that on the timer image.fillment okay that's it super simple let's see okay here we are on the waiting to start all right waiting and as soon as we start if there you go there's the timer going and we can see it constantly increasing so it's at the halfway point and just a little bit more and there you go yep we've got the time over and we have our game over all right awesome so over here we implemented a really nice game over Saint we have a playing timer with an icui element and when it ends we get a game over window showing you a bunch of stats now with this working the next task is to have some kind of main menu so we can play again after the game is done so let's do that in the next lecture hello and welcome I'm your code monkey in this lecture we're going to make a super simple main menu and downloading system okay so every game needs a main menu so let's build one let's begin by making the scene so let's go into our scenes and create a brand new scene call this the main menu scene and okay here's our default scene now over here for the most part you really just want some basic buttons so nothing too special so let's create a brand new UI canvas and let's set up as usual so screen space overlay yep then let's go with scale with screen size 1920 by 1080 and let's match with the height okay so there's our canvas now inside let's make an empty game object name this the main menu UI let's stretch it to occupy the entire thing so zero zero on everything okay now inside let's create a brand new UI button let's name this the play button then inside for the text let's say play Let's size the button to be quite a bit bigger so let's say 450 by 150 and on the text itself let's put it in bold only font size quite a bit bigger let's say 70 then let's also change the color let's put the text in White and the play button over here the normal color for the image let's put it on a dark gray then also over here on the button background let's add a nice outline let's put it on foam black say something like three three then let's make a Shadow and for this one five minus five okay so that's our basic button let's just anchor the button so choose the play button let's anchor it on the lower left corner and let's push it just a bit like this okay presymbal now let's duplicate this one push it a bit lower let's also make it just a tiny bit smaller so just 120 this is going to be our quit button so let's rename this to the quit button and inside for the text just say quit and put a bit more on the font size okay like this okay so we have the two basic buttons that we need now let's make this crypto random so let's make script with the same name so main menu UI so let's go into our script UI folder create new script for the main menu UI let's attach the script and open okay so now here let's begin by making serialized films for our buttons so it's always film private of type button inside Unity engine.ei this is the play button and then we have another one for the quit button okay back in the editor let's drag the references so that's the only button and the quit button okay now here in the code let's add some listeners to these buttons and let's do a private way to wake and on the way let's go into the play button and going to the on click event so the event when the player clicks on the button and let's add in listener and now we pass in The Listener now for here to do this we can add a function so we can make a private void Play Click we can define a function kind of like this and over here add it as The Listener so that's one approach or another alternative that personally I like to use is to use what is called a Lambda expression so instead of defining an external function down here we just go up here and directly with the finding Lambda so we open parameters to display the parameters for the function which in this case we have none so just open and close then we do a nice little arrow and then we have whatever we want to be our clear code so both the code that I have here and one that I have here both of these are exactly the same thing this one is called the unlimited expression which is also a type of delegate definitely go ahead and watch my video on C sharp delicates in detail it's yet another extremely powerful csharp feature I find them especially useful especially over here to setting the click listeners there's no need to make another function just use a Lambda expression that's it so over here I'm going to use that instead of an external function Okay so we've got the play and then let's also listen to the equip so on the quit button the exact same thing okay now first on the equip button it's actually very simple we just go into application and we call the quit function this will quit the game that's it very similar although one note if we actually test it like this so here is the game playing and if I click on quit and nope nothing happens now the logic is actually working we can see visually that the button is changing state so we are indeed capturing clicks however when the game is running inside the editor calling that function the application.quit doesn't do anything but if this were a phone bill then clicking on that would indeed close their game okay so now for the play button for this one it's also very simple we just need to go inside the scene manager which is inside the unity engine.scene management we just need to go inside of this one and we call load scene this function will load with a certain scene and for loading we can either use the scene film index or we can use the scene name like I've mentioned several times string names are horrible although in this case the alternative using an INT is also not very good just a number is very hard to read the code and being able to know what scene this is loading so there's one better approach that I prefer to use but first over here let's just use the index just for testing so we're going to load the scene on index one so just like this and then here in the editor and let's go into file and build settings and over here we see the scenes in our build right now we just have the game scene so let's just add our scene so let's drag the main medicine and drag it on there and also let's make sure it's on the top of the list basically the first scene is the one that won't be unloaded as soon as the game starts so let's try it right up top just like that then over here on the right we see the index so by loading the scene on the next one we're going to be unloading the game scene okay so with the slits test so here we are and if I click on playing and if there you go it doesn't load the main scene okay great everything is working so this is the seamless way to do scene loading however this method does have one issue it's not super noticeable when a game of this scale because it loads pretty quickly but like this note how when we click on play there you go everything freezes for a little bit while the game is loading like I mentioned in this case the freeze is so small so not necessarily an issue but if the game was much more complex then the player would be staring at a frozen main menu for perhaps 30 seconds that would not be good one way to avoid that is actually very simple basically it's what I already covered in detail in the scene loading video that video was made quite a while ago but it's still very much up to date here we're going to do pretty much the same thing so we first create the scene just empty just saying loading and then from that scene we load the final scene that way the game stays Frozen on a scene that says loading which is much more clear to the player so let's do that first let's make our scene so inside our scenes folder let's create a brand new scene call this the unloading scene okay let's go inside and on this one we want this one to be fully black so let's go into the main camera and scroll down over here under environment and instead of rendering the Skybox for the background let's go with a solid color and let's go with phone black okay there's our black main camera now let's make a canvas so a new UI canvas let's set up as usual so scale with screen size 1920 by 1080 and match with the height okay then inside let's just make a simple text object so just say text then over here on let's say just loading let's put the text width and height on zero put it on Bold let's make sure to disable wrapping and push it over there on the side and maybe increase the font size down a little bit okay there you go we have our very basic loading screen now we're going to unload this scene and then once on this scene we're going to load the final scene although also one very important thing related to loading scenes is you need to remember the lifetime of the objects regular game objects only for example the ones that we see here in the hierarchy these get destroyed when you do a scene change so for the goal that we're trying to achieve we need to unload this loading scene but then also somehow transfer data so that the loading scene here knows which one is the final scene now you might think that over here on the main menu we could create a game object attach a script that would hone the reference to the final scene but like I said game objects get destroyed as soon as we unload the unloading scene so for transferring data between scenes we can't really use a regular script on a regular game object now one approach is to use the don't destroy on loan this is a Unity function that helps you stop a particular script or a game object from being destroyed that way the object won't process through scene changes so that's one option but another option that I prefer is very simple let's just make it another class so let's create a new csharp script call this loader and over here let's go ahead and make this class a static class and we are not going to extend Model Behavior so just like this basically by making it static it means that this one is not attached to any specific instance of an object this class cannot be attached to any object and cannot have any instances constructed then inside we can add static functions in fields like for example a static and for the Target scene index so now this field we could set this field from over here on the main menu UI and when we would load we would not be resetting this field also here I should point out one quick thing you can make field static without making the entire class itself static making the class static is just a good approach if the entire thing if everything in this class is also meant to be static if you don't make it static then you can have regular films here you can have both static and nonsanic whereas if you make this static then you're going to have an error because you cannot have nonstatic feelings so this is another clean code thing if it's only meant to contain static logic then make the class itself static okay so we have a static field for our Target scene but as usual we don't want this to be a public field we don't want the main menu to directly write to this field so let's make this class the only one responsible for anything related with scene loading since then let's make a function so a public static void call it load and for a printer let's receive a string for the Target scene name then over here we will load the actual scene so let's go into the scene manager and load the scene analyst best in the Target scene name okay that's it and then over here on the main menu UI instead of directly unloading a scene let's go into the loader and con load and pass in the scene name so that's the game scene okay so this is what we're going to do that's good except it's obviously not good over here we're using string names that's horrible we should never use this so let's avoid using strings as much as possible in one simple way is to just Define an enum for all of our scenes so let's go here on the other and let's define that so a public enum let's call it scene and for all of our scenes so we have the main menu scene then we have the game scene and the unloading scene okay so then down here on this function inside receiving a string we just receive a scene for the Target scene and we use the target scene although of course the NT API does not support unloading our custom enum it has to be an index or string so the simple approach is just to convert this one into a string that's it so the only thing you need to make sure is that the enum values over here match the actual name on the actual scenes perfectly so don't make any mistakes keep it case sensitive so don't do this make sure everything matches perfectly okay so just like this everything should already be working the same as previously so the main menu calls that let's actually just use that so let's use scene Dot Game scene so on the main menu we do this and unloader we load the scene okay let's test here is the main menu and if we click and wait a bit and after you go it didn't load the game scene okay great so everything still works the same as presently except now all of the unloading logic is inside of this class and over here let's open a loading scene in the middle basically when we have this function to load a final scene let's first off set this field so this one instead of being type in let's make it a type scene and this is going to be the target scene and let's make it private okay so when we have this function let's set that field although here remember how this is a static class so in order to access this field we need to exit through the class name because over here we also have a local variable with the exact same name so what sex is the unloader.target scene and set it to the Target scene so again don't be confused here you can even use visual studio and put the cursor on top to see what object represents what so you can see the unloader.target scene is referencing this field whereas this one over here is referencing the local field so we want to assign the member field to the one that we received as a parameter okay so we store that and then let's immediately unload the unloading scene so scene manager let's load the scene and we're going to load the scene dot loading scene dot to string okay so we're going to download that and now here comes the tricky part if we do this so if we load the unloading scene and then immediately unload the target scene if we didn't like this it won't actually show the loading scene we're calling these functions one right after the other so to unload the one and immediately the other basically we need to wait at least one frame to render so that the unloading scene is visible and then we can alert the final scene so let's make a script to do a very simple jump let's create a brand new csharp script for the unloader comeback and now let's go inside the unloading scene so this is important let's make this on the loading scene not the main menu or the game scene so over here let's create an empty game object for the unloader comeback let's reset transform just keep things nice and clean and let's attach a script so the only other comeback okay and on this script we want to basically just wait for the very first update so let's see private ball is first update and we started off as true actually so is the first update is true then we do a product void update so if it is the first update if so then let's set is first update to false we have the first update although technology I should point out that we don't really need this we're going to load right away so either way it will only run One update but still I like to add this just to make the logic perfectly clear basically if it is the first update then let's call a function on the unloader so on the loader over here let's make a function public static void call it below their comeback okay we have this function it's over here on the other convex let's just go into the unloader and call the unloader convex function all right so basically now here we have this function that is going to be triggered on the first update so we know for certain the unloading scene has been rendered so it's over here that we want to load the actual final scene okay that's it here we have a super simple loading system just make perfectly sure that the unloader come back with the script this one only exists on the loading scene it should not be on any of the other ones so let's test and for that let's go inside the main menu scene okay and now let's hit on play okay so here we are on main menu now if I click on play and actually here's the thing that I forgot so make sure you don't forget this we need to add the unloading scene to the builds in order to be able to load so let's go up here into the build settings let's go into the project drag the unloading scene like that okay so now let's test so here we are on the main menu let's hit on play and there's the loading scene after a bit yep here we have our game scene all right awesome so with that everything is working perfectly all of the logic is working great now the wrong words great let's just make a nice proper visual for our main menu so for that let's go inside the game scene and over here let's copy a few things so let's pick up the four object and let's also pick up the global volume with the post pressing so let's copy both of these let's go into the main menu scene and over here on let's paste both objects okay now let's also drag some player visuals so let's put this in 3D go back down into the floor and let's pick up some visuals so let's go inside our assets on the prefabs visuals let's find over here the player visual again make sure you drag the visual only we don't want any logic components and by the way this is yet another great benefit of separating the logic from the visuals right now it's super simple for us to play some players here because we have just the visuals commonly separated from the logic okay so on the visual let's just make it look at the camera let's position a bunch more players so let's duplicate this and put one to the side we're going to move the camera in a bit but now let's just place them and included assets there are a bunch of materials so over here we see the employer body then we've got a blue a green and a red like I said this first course is on making this game in single player but the goal is to then make a second course after this one on converting this game into multiplier so that's why I included multiple colors so let's just drag these let's go into this player Visual and on this one make it blue so on the head and on the body then on this one on the side here let's make this one green so green there and green on the head and for the one behind let's make this one the red one so put it in red and in red Okay so we've got our nice four players now let's also add a camera so we're going to have the camera kind of like this kind of from below and looking upwards I think that looks pretty good for that let's use cine machines and let's go into game object go into cinemachine and let's create a brand new version on camera okay unlike this let's just push it up a little bit okay so this is our nice composition now on the virtual camera let's just go ahead and add some noise so let's add basic multichannel purlin so let's do it just like we did when we first had the thin machine so let's use the handheld normal mild and now let's just play around these films which by the way you can do that while the game is playing so let's hit on play and over here you can play around down the fields although actually defaults already look pretty good but let's put the frequency maybe a little bit less and the amplitude maybe a little bit bigger so just some nice little Sway and by the way if you make any changes to the send machine virtual camera and now you stop playing it will actually lose those changes but over here on the virtual camera there's this nice toggle save during play so if you tick this and now you exit play mode and there you go those changes were saved okay great now let's just make sure to untick this so we don't accidentally modify okay so here we have the basic Vision that we want finally there's also a game logo in the included assets so let's just go into our canvas into our main menu let's create a brand new UI image let's assign the logo Sprite then let's just position it on that corner so let's move it all the way up there we can anchor it to the top left corner and let's make it a bit bigger and by the way I want something like this if you play around this it might get a bit scratched so if so over here on the options on the image you can download this one to preserve the aspect ratio so that way even if you stretch it won't actually be stretch it will always be perfect okay just like this okay so here we have our basic main menu it's a basic setup but it looks pretty good and with that we have built a nice main menu alongside with the unloading system so I can click on play it goes into the loading scene and then into the game scene so that's great the next thing that we need is some kind of pause button so let's do that in the next lecture hello and welcome I'm your code monkey in this lecture we're going to add a pause button with a pulse window that also has the ability to quit back to the main menu and in doing so we're also going to solve some sneaky issues with loading okay so here in the main menu we can click the play button in order to unload the game and yep everything works now I'm in the game but now let's say I want to pause the game for a bit or quit back to the main menu right now there's no way so let's do that let's go here onto the game scene and first let's send on the pause and for that we're actually going to need some input so let's first go inside our player input actions let's open this and then over here let's make a brand new action let's name it the pause for the action type let's go with button okay and for the bindings over here let's go with escape and actually if we use the same method that we've been using if we listen and press on Escape nope doesn't work because Escape just cancels it so instead we need to use a search bar here Search for escape keyboard just like this okay great now again as always let's make sure to save the asset and wait for the compilation to happen there it is so now here on the game input list let's listen to it and fire the event as usual so go into the player input actions the player action map let's go into the pause action and listen to the performed event and when this happens let's fire off an event so a public event event handler let's go on pause action and then down here we're simply going to invoke this event okay just like this now from listening to it here's the question where does that make more sense should we do it over here on the player script or perhaps over here on the kitchen game manager I think over here on the game manager makes more sense since a pause is more related to the game itself rather than a specific action by the player so let's add it over here let's first of all listen to the event so let's see what private void start and on start let's listen to it so let's go into the game input and we didn't actually make it a Singleton yet so let's do that over here let's make a public static game input for the instance with a public yet and a private set then down here on the Wake let's set instance equals this okay there's our Singleton so now back in the kitchen game manager what's going to be instance and listen to the on pause action event and again let's rename this to give it a proper name so the C game input on pause action okay so here we have it when we have this let's call some kind of pause game function so let's define this let's go to the end of the file here and over here let's make that function so a private void pause game and over here we're going to pause the game now for pausing doing this is actually surprisingly easy basically all of our logic is using time dot on time for example over here on the player script we have our movement speed yep then we get the inputs and over here on the handle movement function yep for the movement distance we have move speed multiplied by time.10 is done or another use case over here on the stove counter we've got a frying timer and how we count it down again is the same thing time dot double time well it turns out that behind the scenes time to time the time actually already has a multiplier when you access this it is after that multiplier calculation so over here on the pause game function we can just go into time and we can modify the time scale this one is the multiplier so if we just put this at 0f then that's it this is going to pause all of the other Delta times so let's test so here we are pay attention to that in the countdown timer and I press on escape and there you go everything pauses the countdown timer pauses over here the script pauses and I can no longer move nothing works everything is perfectly paused alright Awesome everything works except one problem obviously right now we cannot unpause if I press Escape it's not in pausing so let's do that over here on the kitchen game manager let's add a simple bone so a private bone let's come with is game paused and let's see found it to phones okay so is game paused and then down here on the pause game function let's simply flip this one so we set this one equals not this one so that is going to flip that Boolean and then we check if the game is paused if so set it to zero f and if not then we're going to set the time.time scale back into one F okay so now this should pause and unpause so essentially rename this function since this is no longer just going to pause let's rename this to toggle and pause game this is going to pause and unpause okay so let's test okay so here we are everything is running now I pause and there you go everything freeze I cannot move the arrow will stop the countdown to stop when I press again and there you go nice and redeemed all right great so all of the logic is working perfectly the only thing we need is we don't just see visual and as usual let's separate the logic from the visuals so let's go inside the canvas let's go into the scene View and inside the canvas let's create an empty game object call it the game pause UI then let's stretch to occupy the entire screen so zero on everything okay great now inside let's first of all add a background so a new image name this the background let's once again stretch to occupy everything and on the color let's put it in black with just a little bit of alpha okay just like that then let's add some text so let's create a brand new UI text let's name it pause text and in here let's just say paused let's just make it big so the width and height both on zero let's disable wrapping Put It Center down the middle and let's increase the font size by quite a bit and put it in bold and let's also change the color maybe a nice yellow something like this okay that looks pretty good let's just lift it up by a little bit now let's make a script to show this so on the UI folder let's create a brand new csharp script call this the game pause UI let's attach it then open now here let's do the usual thing so let's make two show and hide functions so private void show and then a private void hide so on the show game object set active into true and on the hides set it into false okay that's it pretty simple now we need to know when to show our hide these functions so we're here on the kitchen game manager let's make two events to do that so let's go up here make a public event event handler and let's name this on game pause another one for on game unpaused okay we have both events then down here on the toggle pause game if we have this one time scale 0 that means we have pause so let's invoke the on game pause this eventar is not empty okay and on this one let's trigger the other one so on game unpause okay we've got the two basic events now back here on the game pause UI let's listen to it and as usual let's do it on start so private start let's go into the kitchen game manager access the static instance and let's listen to the on game pause and I'm going to listen to the other one so the instance on game unpaused so listen to both of them and as usual let's write the clean codes and let's rename this so kitchen game manager and on this one the same thing so also the kitchen game manager okay we have both and when the game is unpaused then we want to hide the pause window and when the game is paused then we want to show the pause window and finally of course we want to hide it by defaults over here on sart after we add listeners let's just hide it okay so that's it that should work so let's test so here we are everything is running now press the pause and there you go got a nice pause window press again and there you go everything resumes okay great so the last thing that we want is just a button over here to go back to the main menu and let's also add a button to resume without having to press the hotkey so over here let's create a new UI let's make it a button this is going to be the main menu button now let's make it quite a bit bigger okay width and height of 30 and 80. let's put this one quite a bit down there and inside for the text this one is the main menu let's put the color in White and the background for the button let's put this one in a dark gray and let's also just for fun add a nice upline and let's also add a shadow for the outline let's put it on for Alpha and let's put it on about 3 3 and for the effect on the shadow 5 minus five okay so that's a nice outline and nice shadow and then for the text itself let's put it in bold and raise it by just a little bit okay just like that looks pretty good so this is the main menu button and then let's also make so duplicate this let's make this one rename it this is the resume button and inside on the text let's say resume okay we have our two basic buttons so let's handle them in the script so over here let's add as usual a serialized field private of type button so that's inside Unity engine.ui so it's for the resume button and then we're going to have the main menu button okay let's save the script and back in the editor let's drag those references so that's the main menu button and the resume button okay so now for these let's add the click action so let's do a private awake and on the way go into the resume button the on click and let's add a listener so this is going to be our listener and same thing for a main menu button so main menu now for the main menu this one is super simple let's just go into the loader and call the unload function and we're going to download the main menu scene okay that's the main menu very simple and for the resume this one is only going to be clickable when the game is paused so we can just trigger the same function on the kitchen game manager to toggle the pause so kitchen can manager the instance and toggle the pause game this one is actually private so let's go to it and let's make this public so we can count from there okay that's it super simple Let's test okay so here we are and let's pause the game and now if I click on resume if there go it does work everything resumes and now pause again and now let's go back to the main menu loading any up there you go back in the main menu alright awesome so everything works perfectly however there's one sneaky issue here you can already see the issue by seeing that all of these animations are still but let's click on play and notebook that issue everything is still frozen I cannot move the character and over there the Shader that one is completely Frozen so the times can only still set to zero basically we need to manually reset it and the simplest way to do this is really just in the main menu so we can go here on the main menu UI and we can just use this as our reset function so let's just go into time.time scale and let's set this one back into one F that's it that's the only change Let's test so here we are let's pause let's go back into the main menu and we can see the animations are indeed playing and if we go back into play and if there you go everything works perfectly we can pause and yep here we do see one of the other two sneaky issues left basically it has to do with scene loading and cleanup so the first one is on input over here on the game input class we are constructing our player input actions and we are listening to these events and technically this object the one where the game input is attached this object is going to be destroyed when the scene changes however this object that we're creating this instance of player input actions this one does not get destroyed automatically so that is why when I went into the pause menu again for the second time over here we've got a missing reference exception basically the player input actions of the previous game is trying to show the pause window also of the previous game which has since been destroyed so obviously we have a missing reference exception because that object no longer exists so in this case we have two options to solve this one option is we can just unsubscribe to these events Unity mono behaviors have a really nice combat called on destroying so over here private void on Destroy so this is the default one this one is called when the mono behavior is destroyed so we can go into this one and we can manually unsubscribe and the way that you unsubscribe is you just do minus equals so this would solve that problem because when this object is destroyed it's going to unsubscribe from those events so the next time it will no longer trigger so that would fix it however on the game input class we are still creating a new object of this type I'm not 100 sure how the input system works in the background so perhaps this object might say in memory which is not good so another approach we can do or perhaps in combination with this is we can unsubscribe and then we can properly dispose of this object how we do that is very simple let's just go into the player input actions and we just call the dispose function that's it this should clean up that object and free up any memory so let's test so here in the game view let's pause let's go back into the main menu now let's go back into the main game and now if I hit pause and if there you go we no longer have any errors okay so that's good however now we still have one more potential issue and this one has to do with Statics like I mentioned before Statics belong to the class and not any instance of that class so that means that static films will not be destroyed or reset when the scene changes in the case of our unloader here where we have a private static field this one the fact that this one doesn't reset automatically that was a good thing that's what allowed this to make the unloading system but in the case of maybe static events that might not be as good it might mean that we might be keeping some state from the previous game which might cause everything to break so basically we have a similar problem to what we had in the input where some logic from the previous game might be affecting the next game in all the code that we wrote the main place where we use Statics were in The Singletons and these are going to be cleared automatically when the underlying instance object when that one is destroying so these do not cause any problems however for example over here on the cutting counter we've got a static event when the scene changes this will not be cleared so this will still have the same number of listeners we can actually see how many listeners there are by printing it so let's go down here before we're invoking the event let's do a debug download let's go inside the on any cut event and over here we can get the invocation list this one is a list of all of the functions that are listening to this event and we can just print out the link to see how many listeners are listening to this event so let's see what this returns okay so over here let's pick up some cheese and slice it and if I'm working the log yep there you go one there's only one listener okay that's correct however now if I go back into the main menu and now I go back and I play again okay so let's play let's just wait for the countdown and once the countdown ends pick up some cheese go there slice it and there you go there's the problem now we have two listeners in this case doesn't really cause an error because the tune listeners they're just over here on The Sound Manager so we are subscribing to this event and we're doing the cut and playing the cut object however if here we do something with this transform like for example let's just do a debug download on this transform that position if we do this here let's go ahead on the first one let's slice and okay that works let's go back into the main menu now play again now wait for the timer pick up some cheese go there slice any of that I go there we have our air that is because we are now accessing The Sound Manager transform and that one has since been destroyed so if you do use static events like this one here if you do that always remember you need to manually reset that state it won't happen automatically on the scene load and one way that I normally do it is just make a class responsible for doing that so let's go ahead and let's create a brand new csharp class let's call this the reset static data manager and for this one we want this one to run only on the main menu That's only where we're going to reset things so let's go inside the main menu scene let's go there let's create a brand new empty game object for the reset static data manager let's reset transform just keep things clean and let's attach that script again it's very important that this object only exists on the main menu then over here we're basically just going to go into any script and reset any data so for that on all those scripts let's make a function so over here on the cutting counter let's make a public static function let's call this reset static data in order to reset any listeners let's just go into the on any cut and set it to null that will clear all the listeners so we just do this and then on this script Let's see we practically awake and on awake let's go into the cutting counter under the class so not any instance so we're going to access the static and we're going to reset the static data that will clear all the listeners on The Cutting counter all we need to do is make sure to do this on every single static event that we have so on The Sound Manager and by the way here we can get rid of the testing code here we can see all the static events that we're using so we've got the cutting counter then we've got the base counter and trash counter so let's go here on the base counter and paste the exact same thing and reset this event okay and now let's go into the trash counter so here on trash counter same thing reset this event set them all into null and by the way here we have a warning that's because trash counter extends base counter so basically this is telling us that we are hiding another function with the exact same name in this case we do want to hide it so what's actually make this new to make sure that this one is a different one just to avoid that warning and same thing over here on the cutting counter we also need to make a new okay so that's it and now we just need to go over here onto the reset static data manager let's go into the base counter and reset the static data go into the trash counter and reset the static data okay that should do it let's see so here we are in the game let's pick it up and slice it and yep we've got just one listener that's good let's go back outside back into the main menu let's play once more and over here let's pick it up again go there drop it and there you go still just one listener because we are now correctly eliminating all of the previous listeners so this is the one sneaky issue that you must be careful with when it comes to object Lifetime and Statics for static Fields you need to remember that they don't manually get cleaned up that's up to you so that's something you have to keep in mind but you can also see how easy it is to solve now that this is solved let's just go into the cutting counter and just get rid of our testing log alright so with all of that all of our scenes are working so we can start from here from the main menu and go straight into the game then here we are in the game playing normally we can pause the game at any point from the pause screen we cannot resume or we can go back into the main menu and from back into the main menu we can once again play the game from scratch and if there you go everything works alright awesome now the next thing that every game requires is some options so let's do that in the next lecture hello and welcome I'm your code monkey in this lecture we're going to create a simple options menu where we can modify the audio levels okay so here let's make the options menu so on our game scene let's go into the canvas and create a new empty game object let's make this the options UI let's stretch out this one to occupy the entire screen then inside let's make a UI image once again let's stretch out everything let's put this one in black in just almost full Alpha okay now let's make some texts so let's create a brand new UI text call it the options text then for text let's say just options let's put the width and height at zero let's disable wrapping Put It Center down the middle and put it quite a lot bigger okay that's the options now just move it slightly upwards all right now let's make some simple buttons to handle our audio controls we're going to make it super simple literally just a button we can click so inside the options UI let's create a brand new button call this the sound effects button then let's make the button a bit bigger something like this okay and inside for the text let's say sound effects and then we're going to have a number for the sound effects let's just quickly change the color so put the text in White and the button over here the button image let's put it in a dark ring okay let's also make it just a tiny bit thinner it's just like that okay so this is the sound effects button now let's duplicate this one this one is going to be the music button so let's name this the music button then inside for the text music and then a number and that's pretty much it so by clicking on either of these buttons we're going to increase and then Loop the volume so let's make a simple script to handle our options window so in our scripts inside the UI let's create a brand new csharp script for the options UI let's go ahead and attach a script and open so here as usual let's get some films for our buttons so a serialized film private of type button for the sound effects button and then there's another one for the music button okay both buttons now let's add the click event so on private awake let's go into the sound effects button and on the on click let's add a listener and we're going to do the same thing on the music button okay so now when we click we want to change the volume so let's go here onto The Sound Manager and make a function to modify the volume let's make a private void change volume and here we're going to increase the volume by 0.1 percent so constantly increase in 10 increments so that means we need to keep track of the volume so up here in order to find a SIM phone private float for the volume well it's default it to one F okay so now down here we take the volume and we increase it by 0.1 F and now let's Loop it back to zero now for looping usually you do it using the modular operator so here you could do volume equals volume module of 1.1 f that way when it gets to 1.1 f it would reset back to zero but here since we're working with floats which can have a bit of odd Precision with this let's just do a simple lift to make sure that always works so if the volume is above one f if so then let's just reset it to zero okay so here we modified volume and let's just make sure to use it over here when we actually call the audio source.playclip Point here we've got a volume but this is the one that we received as a parameter so let's actually receive this one rename this to volume multiplier and we're going to basically multiply the one that we receive in the parameter by the one that we actually store so this way on these functions when we play a certain sound we can still give an optional volume if we want to make it louder or quieter then the regular sound effects okay so we have our change volume function now we just need to call this from the options UI so that means this one actually needs to be public okay so now here on the options UI we go into the sound manager access the instance and call change volume okay so that is going to change the volume then we just need to update the values on the options UI so let's make a proud void update visual and this one we need to update the text so up here on let's add once again some more serialized Fields so text mesh Pro ugly one for the sound effects text and another one for the music text okay we have both these then here the sound effects text not text equals and we go into The Sound Manager the instance and then we need to get the volume so over here on the sound management let's make a function together so a public float return get volume and we just return the volume okay so then here let's get volume except volume is going to be a normalized value so rather than showing 0.1.2.3 on the UI let's just multiply the volume by 10f that way we show between 1 and 10 okay then let's just round out this number and then add the text so here's sound effects and then we have the bone okay so that's pretty much it and up here when we change the volume let's just update the visual and let's also make a private void start and on start let's also update the video okay that's it pretty simple now let's do the exact same thing on the music except on the Music Manager we named it music manager but over here we just have an audio Source there's no actual manager so let's actually make one let's create new csharp script for the Music Manager let's go into the Music Manager object let's attach a script and let's open so here we really just need pretty much exactly the same thing that we had so let's just go here into The Sound Manager and just copy these so on the Music Manager let's paste them we need a volume so a private mode for the volume just like this okay so that changes the volume except again the Music Manager this one the music is constantly going to be unlooping so after we modify the volume we need to update the actual audio source so let's begin by grabbing the audio source audio source and we just do a pro void awake and on a week let's grab the audio source get the component of time Body Source okay so we have this and when we change the volume let's go here and update this phone okay that's it and let's also default it to some like 0.3f okay good then in order to be able to call this from the option Cy we just need to make it a single turn so as usual public static Music Manager for the instance and we have a public get and a private set and then an awake just set instance equals this okay so then here on the options UI we can go into the Music Manager the instance and change the volume and afterwards let's update the visual and down here on the update visual lets you pretty much the same thing so on the music text modify the text to say music then we go into the music manager and get the volume all right that's it all this should be working let's just drag our references so back in the afternoon let's drag firstly button so the sound effects button that's this one then the music button that's this one then we have the music text that's this one and the sound effects that's like that okay let's test okay so here we are the music is playing and as I click the music is currently getting louder and louder and their game I'm using is at max volume and if I click again no the music is completely muted alright awesome any sound effects also work so like this they should be less leather than usual okay great so everything works perfectly except obviously we have one big issue the options window is on top of everything the goal is for the options window to be kind of a sub menu of the pause window we want to have an options button on the pause window that won't bring up the options window so let's do that let's first hide the options window let's go into the game pause UI and over here we have these buttons let's just make one more let's put it down the middle this is going to be the options button and inside let's modify the text to options okay now let's edit this script so we're going to have another button so this is the options button and down here we're going to have another click so the options button okay and when this happens we want to just show the options window so in order to access it let's make this a Singleton so public static for the options UI a static instance with a getting a private set and on weak as usual instance equals this so over here on the game POS UI we go into the options UI access the instance and then call a show function so we need to make this so here on the options UI let's make those so a public void show and this one as usual just game objects that active into true and then we have a private hide and this set active in two phones okay we have both these on the other side we show it and over here on start let's also hide it okay then let's also hide it manually so let's add a button to close the options UI so over here let's show the options UI and let's make another button let's put it on the bottom this one is the close button and over here let's just say close so then here on the options UI just make another button the close button and down here for the click event we go into the close button and we just call height okay so that won't hide the window however remember that the pause window can also be closed by just pressing escape if we resume with the hotkey it won't hide the pause window so let's also make sure this one hides on the same thing so we can do pretty much going to the kitchen game manager the instance and let's listen when the game is unpaused so when that happens let's hide this window so once again let's do things nice and clean let's rename this so the kitchen game manager and when this happens let's just hide okay this should work let's just drag on the references so first here on the options UI let's drag the close button and then on the game pause UI let's drag the options button okay so let's test and if right away the options window is not showing the trade and if I press in this game there you go there's the pause window and if I can click on options if there's the options window now if I can go and close back here back into resume okay works now if I pause options and now press on the Escape key and you better go closes everything all right great so everything is working fine however we have one slight issue the option does work so I can modify this to change the sound effects and Music volume so for example let's mute the music and put the sound effects on five so I put it like this but now if I stop playing and I hit play again and working the options and oh there's the issue basically that is back to the default obviously that is resetting since we didn't actually save anything so let's save it now in unity the easiest way to save some data is using player prefs so let's go over here on The Sound Manager and when we modify the volume over here when we do that let's access the Unity Player prefs and over here we've got a bunch of set functions so we can save a float an INT or a string this one as you can see it takes a string and a value so this is pretty much essentially just a dictionary now for the key as you can see it's a type string but again we should not be using strings directly so let's go up here in order to make a proper constant so a private con string let's go with Pro layer prefs sound effects volume and let's go sound effects volume okay we have our nice Center in content and down here when we set the float let's use this string and say the volume okay so that is going to set the float and now technically Unity is going to automatically save the player perhaps basically there are only problems if Unity somehow crashes in between when you can't set float and when it actually saves but if you want to prevent that from happening you can just go and tell it to save manually just like that that won't definitely save it and now we just need to handle loading so here on awake when we have this let's go into the play prefs and let's use get float let's pass in the same key so this one takes the key and default value so let's default it to one F basically the default value is used if there's no save data on display prefs on this key so the first time we run it's actually going to use this default and this one's going to return these saved value so let's just set it on the volume okay so that's it that's only takes to save some basic data now let's do the exact same thing on music so over here on the Music Manager let's first Define our private con string for the player pref's music volume and this is going to be the music volume okay we have our string and then down here when you change the volume layer press and let's set the float on this key and let's pass in the Music Volume okay and then what's going to player prefs and actually save it and now appear on the wake let's grab the volume and it's going to be going to the player prefs in order to get the float on this key and default value is 0.3f however over here on the music again we are not spawning the sound afterwards the sound starts playing right away so let's make sure to set the audio Source volume to the one we grab from there okay that's it so like this it should be working so let's test so here we are and the music is playing let's pause go into the options let's bring the music completely down so let's mute the music okay the music is gone and sound effects let's put a note 5. now let's stop playing and now play again and going to the menu options and if there you go the data was indeed saved and the music is indeed muted alright awesome so here we have some basic data being saved and also just quick note related to saving for this simple game decisions are pretty quick so I didn't include any kind of save system for the actual game data but if you want to know how to do that I also have video covering that topic okay so with that we have our options window working the volume sliders work perfectly the next thing we need to add to our options is some key rebinding so let's do that in the next lecture hello and welcome I'm your code monkey in this lecture we're going to add key rebinding to our options menu so here we already have this nice options menu we can modify the volume of the sound effects or the music next let's handle key rebinding okay so first let's build the elements over here on the UI so let's create a bunch more buttons but before that let's actually make some text on the side and buttons in the middle so let's create a brand new UI text call this move of text let's put it on the same size as the other one so these got a font of 24 so let's put it same thing font of 24 width and height let's put both of these on zero and down here anchor it to the left okay down the middle and with no wrapping okay so then over here this is going to be the move up action so we have move up then we have the move down move left move right then we have the interact the interact alternate and finally the pause so these are all of our actions so let's just make all of these so rename this so this one is the move down then this one over here is the move left this one is the move right this one is the interact text then the interact alternate text and finally the pause text now let's just modify the text on these so that's the pause that one is the indirect Alt then this one is the interact then we've got the move right then over here the move left and finally we have the move down okay so those are our labels for our controls now let's just make buttons over here on the right side so let's duplicate one of these buttons let's put it over here and put it on something like 50 by 50. so this is going to be the move up button and inside on the text this is going to be pretty much just a w okay so we have the move up then we're going to have the move down move left move right the interact the interact alternate and the pause so we just need a bit more space so let's move all of these up by quite a bit let's also move the music and the sound effects so move all of these like that okay let's just name all these buttons so this one is the second one so this may move down then over here the move left then the move right then the interact button the interact alternate button and finally the pause button okay those are on the buttons let's just position all of the labels exactly where they should be okay so here we have all of the options all of our bindings now in code let's grab references to all the buttons and all the text inside the buttons so here inside the options URL let's add all of those so first of all for the attacks we're going to have the move of text then the down left right and so on so let you see all of these so down then over here the left then the right then the interact text the interact alternate text and finally we have the pause text and for the buttons let's go up here make all the buttons so they move up button then they move down button then we have the move left button then the move right button then we have the interact button the interact alternate button and finally the pause button okay so we have all of these references over here in the editor let's just drag them so let's make sure we drag them on correctly so let's do it one by one so the move up this is the text and actually it's not that one so that's already a mistake right there we want the text from inside buttons so let's pick up all of these text objects so let's go into the options so text inside the move up let's grab that one then inside the move down let's grab that one and then left and so on so definitely make sure you grab the right ones okay that's on text now for the button so let's move up button then you move down then they move left the move right the interact interact alternate and finally the pause button okay great and just to verify that everything is working let's give proper names to these objects so the move up button text okay so I've renamed all the buttons so now over here it's much easier to verify that we have the correct references so the sound sound music music and so on so definitely make sure all of these are correct otherwise you might go crazy when things start to go a bit weird so make sure these are all correct all right now let's begin by updating the text inside over here so let's go into our update visual so we go into this set the text and now we need to get the binding text for this binding so for that let's make that function on the game input over here let's just comment this out then over here on the game input script let's make a function to get the bindings certainly we could make something just to grab this player input actions but again we don't want the options UI to know what input system we're using it should work regardless of what input system so we don't want the game input to return anything of this type instead we want to make a nice layer of abstraction so for that let's make an enum to Define all of our bindings so let's make a public since we're going to access it enum call it binding and over here let's add all the bindings so we've got the move up then we have the move down the move left the move right then we have the interact the interact alternate and finally the pause so these are all of the bindings now let's make a function to return the binding text so over here let's make a public we're going to return a string let's just name it get binding text and as a parameter let's receive a binding okay so now here let's just do a switch switch on this binding and basically just match up the enum to whatever action we have so for example let's begin with the interact since these are the simplest ones so for this one to get the bindings we first go inside the player input actions then let's go inside the player action map then for the action so in this case the interact and anything inside we've got the bindings this is an array of all of the bindings in our input map we defined all of the keyboard bindings on index 0. later on we're going to add Gamepad bindings but for now we're going to have the keyboard always on index 0. so over here going to bindings axis on zero and let's just do a two string okay so let's just return this and let's do a default to return always this one just like this okay so let's do a quick unlock to see what this returns so let's do it over here on the game input just a debug.log go into there get the binding tags for the interact okay so let's test and right away yep we do see it working so the interact and The Binding is on keyboard slash e but we don't want all of this text we really just want to see the E thankfully the input system has a really great function for just that so instead of calling the general to string let's call to display string let's see any of this one does return just easy okay great so this is the one that we want let's do the same thing for all of the other simple actions so we've got the interact then we have the interact alternate and we have the pause so these are all the super simple ones so just going to interact alternate grab the binding on zero and for the pause binding on zero okay so these are all super simple now the more complex one is the move it's more complex because you can see all the others just have one binding except for the move over here we have a composite binding so that's basically a binding which inside has four separate bindings basically the way that this works is that when you use a composed binding all of these are added to the array so this to the vector is going to be on binding 0 then the up is going to be on binding one two three four and so on then the arrow keys this one is going to be on five then we have six seven eight nine and ten let's do a log just to verify so here if we do one for the move up action for this one let's go into the move and let's print out just the binding zero let's do a regular two string let's see what this returns so up here let's just modify our log to say the move up okay so let's see any up index 0 does have the move to the vector and now if we print the one on binding of one yep now this one does have the move on the w so like I said we can see that all of these Composites these are technically inside that one but in terms of that array it's just a flat array so this one index 0 1 2 3 and 4. so that makes it super simple to add over here so they move up down left right and let's just do all these so we have all the bindings and over here just one two three and four and set a two string let's call the display string okay so the binding text this is all set up so let's go up here and get rid of our testing code we can now call this from the options UI so over here let's do exam with that so when we update the visual let's go into the game and put let's access the static instance let's get the binding text and this one is going to do the move up so that's it this one is going to return a string let's write all of them okay here are all of them so let's see and if there they are all perfect don't we SCD EF Escape okay great so the visual is working now let's end on the rebinding so let's add a click event let's go into the move up button let's go into the on click let's add in listener and for the enlistener over here let's make a function on the game input to rebind this binding so over here on the game input let's see public void rebind binding and we receive a binding now for rebinding I cover this in detail in the dedicated input system video first basically we need to disable the action map so let's go into the player input actions let's access the player and disable it so we need to do this first then we're going to need to find the action so player input actions and for now let's go into the player and let's just modify the move up action so we're going to call the function perform Interactive rebinding this one as you can see takes a binding index and if you remember up here we saw that in order to modify the move up it's on bindings index one so let's modify the one on index one okay so this is the function this returns an object of this type a rebinding operation this is a pretty complex object where you can modify all kinds of things add a bunch of limitations and so on like for example make a key not be able to be bound to the mouse or something so there's tons and tons of options you can play with over here for the simple thing let's just add an on complete listener so this one takes in a convex and this will be called whenever the interactive rebinding completes so over here on let's define and Lambda so we come back and inside we have this by the way over here this is the same line of the expression that we saw previously so exactly the same thing as this except when we have just one parenthesis we don't need to add them okay so like this so then on this convex we can see all kinds of things like for example we can see the action that we just rebound this is going to contain all the data on the rebind operation so for example let's print out the path so let's go into the action let's go into the bindings on index 1 and let's print out the path similar to a debug.log and there's actually another one so let's log the path and also the override path these are two different things let's see why in a bit we do this and after we log we also need to rename on the player action map so let's go into the player input actions deep layer and back enable this okay so we're only going to need these settings on the rewind action then we can just call start in order to start the rebinding process okay so this should work let's just call this from the options UI so over here we have the click let's go into game input instance and let's rebind The Binding and for this one is the move up okay with this let's test okay so here if I click on the button and I click on the T key and if there go it did work so you can see that it print out the regular path that is w and the override path which is C so now if I exit out of the options go back into the game if I press W nope it does not move but if I press T yep it does move upwards okay great so we have successfully rebound this one key now here just one thing in previous versions of the input system when doing a rebind operation you need to manually dispose of this comeback otherwise it would throw a memory error in the recent version that I'm using here there's no error so it seems perhaps it's no longer needed to dispose of the compact manually but still there's no harm doing it just in case over here combat dot dispose okay so with that the key rebinding is working except we have two issues the first one is that it's not very clear that it's listening for an input and the second one is that the text options also does not update so it's on both those first let's add a visual when waiting for a key press so inside the game options UI let's create an empty game object call this the press to rebind team let's stretch it out so put it on zero on everything okay then inside let's add a UI image let's put it in black and once again let's stretch it out okay now let's also add a simple text and for text let's say press a key to rebind as usual let's put the width and height on zero put it in bold Center down the middle with no wrapping and increase the size by quite a bit okay so that's our super basic window now in the code we just want to show and hide this so let's do that and let's actually begin with this hidden by default so let's disable this object so here on the options UI let's add another serialized film it's going to be a transform for the press to rebind key transform so you have this let's make two show and hide functions so we show press to rebind key we just go into that one game objects and active this one into true and another one where we set it to phones so just hide and set it to false okay pretty simple let's make sure to hide this over here on our start okay just like that and for showing let's show it when we actually rebind an action so right in here but since we're going to have tons of listeners to these events let's actually make a nice separate function to handle all of the rebinding logic so down here let's make a function rebind binding we receive a game input.binding then first we show the press rewind key and then let's go into game input access the instance and time to rebind binding and pass in the same binding okay so we have this and now up here on the button event let's just call in this function okay very simple so this will work for actually showing the window but now we need to know when to hide it and for that let's use something that we've used a few times in this course but never directly let's use a csharp donate as usual I have a dedicated video on them this is basically how you can define a field or a parameter of a type which can hold a function it's another Super useful CCR feature definitely watch that video to learn all about it let's go here on the game input and down here when we have our rewind binding over here let's receive a second parameter this one is going to be of type action this is one of the builtin dongates it takes no parameters and returns void so this one is perfect for a simple comeback just like this one let's go with on action rebound and we're going to trigger this right here after we achieve the convex so we get the comeback let's trigger this just like that and let's also get rid of these testing logs we no longer need them so just like this now back here on the options UI so we've got that and for the second parameter let's just pass in the function to hide that window so hi the press the rewind key that's it again remember we're passing in the function itself we're not calling it so there's no parentheses we're just passing in the function itself okay so with this let's test so here on the options let's rebind the move W and there you go it does show up to window and now if I press the key you better go down hides okay great so this is working but over here the text is still not updating so over here on the second comeback instead of just calling this function we need to call this and then also call the update visual function so as usual let's use a simple Lambda expression to do exactly both so let's open and close the parentheses and we do exactly this so we hide the price of rebind and then we update the visual okay that's it let's test so here we are let's rewind the move down we press on the T key and there you go we did rebind and it did update all right great now let's just apply this to all of the other bindings so first up here on the buttons let's set listeners to all the buttons so let's see move left actually be moved down then the move left move right the interact button the interact alternate button and finally the pause button and for the bindings this one is the fast binding the interact alternate then the interact then the move this one is the right again make sure you don't make mistakes here you call them the exact same one so they move down okay so all of it is correct here and over here on the player input let's do a switch on our binding so Keys move up we do something and now we could write this code directly up here and then make a move down and write a bunch more code that would work but that would be way too worthy so let's write our code in a nice clean way basically the only thing we need down here is we need to know the actual action we're going to rebind and we need to know the action index so let's just find up here exactly that so an input action for the input action and then an end for the binding index okay and then over here when we have the switch for all of our bindings we just set those so the input action in this case it's going to be the player input actions player and it's the move action and for The Binding index this one is on index one then we're going to have the other moves so they move down is going to be on index 2. then left and right these are on index 3 and 4. okay so we have all these and now for the other ones so for the interact this is the interact action on binding zero then we've got the interact alternate and the pause so interact alternate and the pause and this one is the pause action and the interact alternate action and all of them are on finding index of zero okay so that's good so over here we are assigning the input action and defining index and also one thing we need to make sure to always assign these values so let's make sure to add a default here just make sure it always works okay great so now down here instead of always accessing the move let's access whatever is stored in the input action and for The Binding whatever it is on The Binding index okay so now this will work with all of our bindings so here we are and let's try rebinding all of them so let's put them over here on the side so before it move up let's put on T down on G A on F then D on H for the interact on y interact jumped on J and for the Escape let's put it on E okay so all these Keys have been rebound let's just make sure they work so here I am moving with these keys and yep it does work go up here to interact and do the alt interact and now the pause and if there you go everything works perfectly alright awesome so everything worked perfectly although again we have the same issue as previously so all the keys have been rebound so it's not correct right however now if I stop playing and now if I play again and nope there's the issue the rebinding was lost so just like with the sound we also need to save the new state now thankfully the new input system has a function that makes that super easy let's go down to where we are rebinding things and when we finish rebinding let's just go into the player input actions and let's call this function the save bindings overrides as Json this one is going to return a Json string now if you don't know what is Json go watch my quick video on it basically it's a super easy to understand and widely used file format it's very easy to read and modify it's a format where it's stored as just text so let's look at what this says once we debug down log over here after rebinding something let's see so here if I rebind one of these and if there you go there we have our Json so the override Bindings that overload the move on this ID on this new path so basically we just need to sort this string somewhere and just like we did with the sound let's just store it in the player prefs so first let's define our constant so private constring for the player prefs bindings and let's call this the input bindings okay just like this so then down here after we rebind the king let's go into player prefs and let's set a string on the player prefs bindings and we're going to save the overrides as Json and after we do let's just make sure the player perhaps is correctly saved okay so that saves it then let's go on a way to unload it so over here on awake let's load that let's first do a quick test to see if there's a save so if the player prefs if it has a king and if it has this key if so then let's get it so the player prefs let's get the string on this key that returns this ring and we're going to use the string let's just go into the player input actions and let's call the function load binding overrides from Json just like this and also let's make sure we do this right after we construct the object and before we enable the action map okay so that's really it let's test so here we are let's rebind the move up to T okay hit rebound now stop playing now playing again and you appeared is still rebound to T alright awesome okay so here we created a really nice options menu where we can modify the volume and rebind keys the only issue that we still have is that we can only navigate the menus with the mouse so let's add support for many navigation with a controller in the next lecture hello and welcome I'm your code monkey in this lecture we're going to set up phone controller support for our game including regular actions and menu navigation okay so first let's just set up the controller input I have an Xbox impact controller connected so let's open up our player input actions and over here we have all of our actions and we already made the move one a long time ago so let's just add the bindings for the other ones for example over here on the interact let's add a brand new binding let's go into the path and listen and for interact I'm going to press the A Button and again here you can specify just the a button on Xbox controller or you can use the generic South button which will mean a on an Xbox or cross on a PlayStation or B on a switch or anything else so let's go with the generic one for the internal alternate let's add a binding and for this one I'm going to put it on the X on the Xbox so the button West and for the pause let's add let's listen and I'm going to press the menu which is the start button okay so these are the basic inputs let's make sure they work and thanks to this new input system we really don't need to modify any code let's just save this asset let's wait for the compilation and then we can do a test so here we are and yep I'm using my control to move now let's just wait for the countdown and go up there and pick up a cheese put it and slice some cheese yep I can do that pick up a plate and so on all right so everything works let's also pause and yep that also works okay great so everything works except there are two issues with the GamePad especially one with the movement that I only noticed just now the first issue that we have is the dead zone right now we don't have one so if I just lightly touch my Gamepad joystick there you go it starts moving automatically in Gamepad games you should always have some kind of dead zone to prevent any kind of joycon drift thankfully that is super easy to Zone let's just go into the player input action so let's go into the move find the left stick binding and over here for the processors let's add one and let's add a stick dead zone so that's it pretty simple this basically considers that inputs under this minimum to be zero and above this maximum to be one so if you have joystick drift where when the joystick is Idle it's always moving by say 0.1 and direction this helps solve that problem except in our case for a game we're only using normalized inputs so actually for our use case let's increase the minimum by quite a bit I did some testing in 0.5 Works quite great and the max that default that is just fine okay so that's it one problem solved let's just go ahead save this Ascent now the other bigger issue that we have is if I approach a counter and I try and look at it it's really difficult it tries moving left and right instead of actually facing the counter that's because the logic that we added in a long time ago that logic to help the character controller feel better when moving on diagonals against the counter that works great for keyboard because it's digital so it's either moving phone and left probably right or on the diagonals but it messes up the control which is analog on the player movement if we are not moving perfectly up or perfectly down then it's considered a diagonal and on a Gamepad it's really difficult to get a perfect just up or just down input we're always going to have a tiny bit of either left or right so that's the issue that we have here and thankfully the solution is actually pretty simple let's go over here on to our player script and let's scroll down into the handle movement function okay so we're doing a can move using the regular move Direction and if it doesn't work then it's over here that we are attempting only the X movement or only the Z movement and for doing that we made it so we can move if there is nothing only on the X and if we have any movement at all on the X so if it is different from zero basically the issue here is if the move dear.x is let's say 0.001 that is still different from zero so it is still going to trigger this logic so basically let's just widen this Gap instead of testing literally just different from zero let's test if they moved here.x if it is under say minus 0.5 F or if moved here dot X if it is bigger than plus 0.5 f so instead of being exactly just on zero we're only going to consider diagonals if we are at least moving 0.5 either left or right so we just did this and same thing over here except we just test for this n so we moved here.z and they move the other dot set okay so like this it should feel much better on the GamePad and still work exactly the same on the keyboard so let's test so here I am moving around and yep now it is much easier to just stay around and look straight at the counter okay so that's great so I can pick up and this is all much much easier and the character is no longer just sliding left and right NonStop okay that's great so now that this is working let's set support for rebinding our controller bindings so over here on the game input let's do it just like we did for the keyboard so let's add a bunch more bindings over here on the enum let's add the GamePad interact then the GamePad interact alternate and then the GamePad pause okay so we have our bindings then let's go down and add them to both our functions so of course the text and then the bindings so we're here on the text let's copy pretty much this we're going to have the GamePad interact then we're going to have the other two so the GamePad tracked alternate and the GamePad pause okay now for these bindings we're going to use the same actions so this one is the interact alternate and over here we have the interact and over here on the input actions we saw that we added for all of them on index 0 we have the keyboard and on the next one we have all the gamepads so over here that's literally don't change for the GamePad let's go into bindings and access the array on index one okay and then over here on the rebind binding it's going to be pretty much the exact same thing so let's copy all these change this to the GamePad interact then the GamePad interact alternate and then the GamePad pause some of these all we need to change is just by an index put them all on one okay so with that all of the code over here on the game input is working perfectly now let's go over here into our options UI so we've got all of our buttons so let's duplicate our buttons let's just go into the interactive pause and so on let's duplicate push them to the right side okay and just change the name so let's get into all of them so this one's the game pad interact button then the game pad interact alternate and finally the GamePad Parts okay also inside let's also rename these buttons just to make sure the text works great and let's also make sure that these show up behind the press the rebound key so let's drag them put them above okay so that's our setup over here on the options UI now let's go over here on the options UI script and let's add references to our buttons and to our text objects so let's copy all these the GamePad and add all these this is the pause the interact and the interact confident and then down here the exact same thing let's add all of these okay like this now over here let's drag all of our references so on the options UI let's make sure to always write the correct things so the GamePad interact text the interact alternate text and the pause button text and then the buttons themselves so the pause button interact alt and the interact button again make sure you always drag the correct references so check and double check make sure everything is correct okay then over here for our code let's first handle the text over here so the text for all these so the GamePad interact text then the GamePad interact alternate text and finally the GamePad pause text and we just go the game file pause the GamePad interact alternate and the GamePad interact finally over here on the buttons let's do the exact same thing so Gamepad interact interact alternate and the pause okay so we added everything let's do a test and see if everything is working so over here let's pause the game go into the options and for the interact let's modify this one instead of a and let's put it on B and yeah there you go it did go so let's close let's resume and now let's see so if I approach and I press a nothing happens Press B and there you go it does interact okay awesome so the rebinding is all working perfectly except we have another obvious issue I can pause with the GamePad however now with this pause I cannot click on any of those buttons and if I go back to the main menu over here I also cannot do anything with a controller so at some of that the first step is on the event system object look at how it shows us this warning basically if we're using the new input system we should be using a different input Handler here thankfully this is super easy we just need to click on this button and yep that's it it automatically sets it up now the way that this works is by preselecting buttons in order to better see which button is selected we should probably add a more visible color let's go into our pause window so for now let's hide over here the options UI show the pause window and we have these three buttons let's select all of them and over here on the right side on the button we can see one option for the selected color so instead of being white which is going to be really difficult to see let's put something really visible so let's say like a bright green okay like this let's do the same thing for all of the buttons on the options UI so let's show this one and find all the buttons so we've got all of these ones down here and these three ones up here and let's do the same thing so on the selected let's put it all on my screen okay so all the buttons have a nice selected color and just like this if we test and if I pause the game and right now nothing is selected so right now I cannot do anything with the controller however if I press over here with the mouse on this button and then let go once outside the button yep look at that now that button is selected so now as long as that one is selected now if I move with the mouse pad yep now I can navigate through this menu and if I press on a yep I can essentially click that button so that's great basically all we need is to make sure that we select the button as soon as the pause menu shows up so let's go over here on the game pause UI script and then over here let's go into the show function so when we show this window when we do let's go into the resume button and just call the select function this will make it selected so that's it and with this if we test and now here with the game playing if I pause whilst pressing the button on the GamePad and if they go down and selected and now I can select any option okay that's great so now it works fully with just the GamePad except now if I go into options yep now you can see that the button that is selected is on the options one over there on the background so let's also make sure to select a button on the options as soon as the options window shows up so over here on the options UI let's go into our show function and let's just select the sound effects button and just console it okay let's test so here let's pause go into options select any of the Lego that did work okay great except we have another issue as I move up or down over here on these buttons you have a look at that some of them are a bit strange like for example over here on a I'm moving up and look at that it actually selected the resume button behind it so as we are moving up or down we are actually selecting buttons on both menus that's very strange basically what is going on is that since both windows are visible the game is trying to guess which button we want to select basically what is happening is Unity is trying to use automatic navigation if we select the button so let's go for example let's hide the options and show just the game pause okay let's select one of these buttons and over there on the button component we can see navigation is set to automatic and we have a button to visualize and if we click on that yep over here we can see all kinds of arrows for example we we can see one over here on the options that seems to be going to some button in there that is going to be the button that is showing over there so if we move down from the options we're going to end up over here on the interact alt button now usually the automatic navigation actually works very well the only reason why we're having problems is because we have both windows active at once one solution to this is to make the navigation explicit so let's hide the options here and over here on the resume on the navigation instead of automatic let's put none and then let's select explicit and if now we have our own four Fields so we can decide which object gets selected when we are here and we move up down left or right so for example here we would drag for the up going up we could go into the main menu so we will drag that button and going down we could drag the options button so that's one solution just add the explicit navigation to every single button or another simpler solution is let's leave this one on automatic and it said we're just going to hide the pause window once we are in the options window so over here on the game pause UI let's see over here we are showing the options you Ai and when we do let's just call hide on this so we are going to hide this window when we show the options and then on the options we want to know when the options closes so that we can show this one again so over here on the show function let's receive an action this is what we're going to do when we close the options let's call it on close button action and let's store it up here so let's store a simple and private action for this okay so we have this and then down here when we have our show function when we have let's set this equals this we store this and then we're just going to run this action whenever we click on the close button so let's go over here the close button we've got that one let's hide the options window and Trigger this action so now we need is over here on the game plus UI let's pass in and basically when we close the options UI we want to show the POS UI okay so let's test so here we are let's pause the game okay let's go into options and open it and if there go it only shows the options and over here moving up or down works perfectly and moving left and right also works perfectly and now if I want to go back let's go into close press it and there you go back into the pause menu all right awesome so everything is working perfectly now the last thing we need is over here on the main menu so let's do the same thing first let's open up the main menu scene let's save the changes okay and over here let's begin by doing the same thing on the event system so let's replace it okay great then let's go inside our canvas inside main menu y let's select our buttons and once again let's modify the select color put it on my screen all right and since over here we only have one menu we could set a test selected over here on the main menu UI script that's one option or we can just go into the event system and over here on the event system there's a film for the first selected so you can just drag the play button and that will automatically make it the selected one so it says and yep the play button starts off as selected and I can move up or down and if I press a button yep there you go here I am playing the game I can pause I can resume go back to the main menu and so on all right awesome so here we have the final thing we needed to make our game fully playable with the GamePad thanks to how the input system works and the menu automatic navigation this was a pretty simple task for this our game is pretty much completely done however the next lecture is also one of the most important lectures it's all about publish so let's do that in the next lecture hello and welcome I'm your code monkey in this lecture we're going to add all kinds of small things to polish our power game if you are regular on this channel then you've certainly heard me say that polish is what separates good games from great games so as you build your own games make sure you don't neglect polish here let's add a bunch of small tiny things that will make a big difference in the final game let's begin with a very simple very visual one let's just add some ones to our map and first let's just hide our canvas so that it's not blocking our view so again over here we can use the buttons on the hierarchy to hide it okay great so let's add some walls and for that let's create a brand new 3D cube let's name this a wall let's put it quite a bit thin so over here on the scale for the X so let's put it 0.25 then on the one let's put three so something like this then we modified Z so let's put it over here on the side right next to the counters okay so that's the wall let's just stretch it out One Direction and the other one okay so that's our basic one now when you included project files there's a nice one material so let's go over here into assets under materials and you appeared as you want material so let's just drag it and use this one and if there you go it's just a nice simple gradient this is also an example of how you can take something simple and make it a bit more interesting if you look at this material the base texture is really just this it is literally just a simple vertical gradient texture and then with the color point to it and looks pretty good okay so this dual let's put the wall on on three sides so let's supplicate this so just select and press Ctrl D 2.8 let's put one on the other side so right there right next to the counters okay and finally the one there so Ctrl D to duplicate it let's push it over there on the side and rotate it 90 degrees and let's put it just like that let's just scale it to get to that end and to get to that end okay so we have our nice walls but over here if we're playing the game we can still see the floor on the outside that looks a bit ugly so let's fix that let's create another object and let's create a 3D object another Cube and for this Cube let's put it over here on the side and this one let's use the black material so again in the included assets there's this nice black material there you go it's completely black nothing to it so let's just use this as kind of a Hider so let's just scale it quite a bit and lift it up okay so there it is a black material right next to the wall and let's put another one over here on the left side and just like that you can also put another one on the back there even though I don't think the camera can see that part but still let's put it so just put it like that and stretch it out okay that's good by the way over here on the outside it doesn't have to be perfect doesn't have to perfectly match the camera is never going to see that position so it doesn't matter it only matters what the camera can see and if we pull it like this and if they're yellow now that looks quite nice if we want over there we can get it together just a little bit and we can also move the camera forward a tiny bit so over here on this one let's push it just a little bit to the left okay and now in the virtual camera let's play the game and now here if we want we can push it up a little bit something like this so let's put it on this set so let's copy it stop playing the game and let's paste it just like that okay so here's our game and as you can see with just this one tiny chain just adding some walls and a nice black outside just with that it already looks so much better than having some counters in wide open space now for another simple one let's add some nice particles while the player is moving so in the included assets if we go inside the prefab visuals over here is a nice one for player moving particles this one as you can see is a particle system so let's drag it over here into the world see what it looks like and as you can see by default it's actually not spawning anything so I can make sure that this one is running and nope nothing is spawning so this is actually set up in a really interesting way is that instead of spawning particles all the time it only emits while moving so if I click to move this object there you go the particles start emitting and if I stop they stop so this one is definitely perfect for a player particle system the way this setup is over here on the emission on rate over time it is set to zero so it doesn't spawn anything automatically and it only has over here the rate over distance so as it moves it's going to spawn that number of particles then the other settings they're all pretty basic so there's some gravity so they fall down just like the stove counter particles simulation is over here on space so that as I move the particle stay behind this is important if I were to put that in local and I move it around look at that this is not what we want we want the particles to essentially stay behind instead of following this transform so that is why this change is super important if that one is set to whirl and as I move yep the particles stay behind okay great and the other property is around pretty basic for the shape it's a cone pointing upwards then for the size of our lifetime again just a basic curve constantly becoming smaller and smaller and down here on the renderer instead of rendering your quads actually rendering a mesh and it's rendering a sphere mesh so that's just so that it looks a little bit better I think than just having a Sprite particle okay so that's it so in order to make this work really all we need is just attach it to the player so let's find the player make this object a child of the player game object and again let's also make sure to set all of this to zero so the position on zero zero and zero and there you go just with this that's all we need if we test here we are stopping there are no particles and as I start moving if there you go some nice particles around the player okay great next let's add a pretty obvious one some kind of mini tutorial we want a window to show the controls and the goal of the game and wait for the player input before we start the countdown so for that let's go into our canvas so let's show our canvas and inside let's create an empty game object called the tutorial UI let's drag this one above the game pause window so that it shows up behind it let's double click to center it and let's press on the 2D button to go into 2D mode okay let's also hide those two windows so you can actually see what we're doing so outside all of these okay great now this one first of all let's stretch it to occupy everything so put zero on everything okay then inside let's make a UI image for our background once again let's stretch it put it like this and for this one instead of black like we've used for all of our Windows let's actually leave it on white put it on an alpha something like half so something like this just to be a bit different then on top of this let's make another image so let's make another UI image and for this one instead of stretching let's give it a size so let's put it on 1280 by 800 and for the image I created a nice image for the tutorial if we go inside the assets and then inside textures yup here is a really nice tutorial image so let's just go ahead and use it so on the image let's drag it all right there's our nice internal image so this has a prebased tutorial so the recipe is coming from the customers then the player has to prepare the correct recipes and deliver them on a plate on the delivery counter so just a very base tutorial and also over here it's very important for the player to know how to actually play the game so there are some labels for the controls and now we're going to dynamically add some keys on top so let's do that let's create an empty game object call this the king let's put it on a size of 40 by 40 okay now let's go inside and inside let's make an image let's name this the background and for the Sprite let's go with the included Circle so default Circle and for the size let's stretch it occupy everything put it on zero zero zero okay there's our nice key so we have the background and for the background let's actually make it just a little bit darker and let's also add just a nice shadow so maybe three minus three and let's also make a nice upline let's put it on two by two full Alpha so something like this just to be a nice one maybe one by one okay so that's just the visual and then on top of it let's add a text and this one's essentially going to be the king so let's put a key for the width and height let's stretch it to match the parent size okay then for the phone here let's go with maybe just say 20 let's put it Center down the middle and also let's put it on bond okay so that's our nice key indicator so this is our key and we're going to have the movement so the movement on the keyboard is going to have four keys so let's just implicate so one two three and four Keys okay then on the GamePad that one is actually not rebindable so let's put this one as static so let's just go inside inside the text and just say left stick and let's lower the font size so that it fits in there okay great then for some more keys we're going to have the interact action then the interact alternate and finally the pause action then let's just duplicate these to be on the other side okay so these are all of our keys now instead of having key one two three this is very difficult to understand so let's give it some proper names so this is the key move up then we have the key move down then the key moves left then the key move right then this one is going to be the key Gamepad move then we have the key interact the key interact alternates the key pause this one is the key Gamepad interact alternate this one is the key Gamepad interact and finally the key Gamepad pause okay all of these and since we're going to drag references to the text objects let's also give those a name so just copy drop it with text just like this okay so those are all the names so everything is nice and organized okay great now let's make the script to run this so our tutorial UI let's go down into our UI scripts create the brand new csharp script for the tutorial UI and let's attach the script okay so first let's drag references to all of our keys we only need the text so let's do a serialize field of type text mesh Pro U going again never make the mistake always use the ugly one if we're working the UI so the key move of text so let's add all of these okay these are all the references then over here let's drag on and make sure to drag the correct ones okay let's double check to make sure all the references are correct okay they don't seem correct all right great and then over here only to pretty much exactly the same thing that we did over here on the options so we need exactly this so let's copy this and over here and let's do just that let's see a private void update visual and on this one let's do pretty much this so the key move up text I know this one you get binding text to move up yep let's just do all the others okay so those are all the bindings that's great now let's go over here on a proud void start and on start let's update our visual all right and also let's make sure this updates just in case the player rebinds something from the pause menu once the tutorial is still visible so we just need to know when that happens so let's go over here onto the game input and make a nice event so public event even Handler let's call it on binding rebind okay we have this event and down here when we have our rebind binding function we do this we rebind and over here let's invoke this event okay just like this so then on TTR only y let's go into the game input the instance on binding rebind let's listen to this event and as always let's rename this so let's put a game input okay when this happens let's simply update the visual okay that's it pretty simple so let's test and see if the inputs are correct and if there it is we do see it correct so we've got ones we've got e to interact F and over there we've got the GamePad okay great so all the buttons are correct all that's left is the show and hide so over here let's make the usual two functions so product void show and a proud boy in Hind and for these game objects set active and this one is going to be into false and this one's going to be true okay so for show up here on start let's actually show it by default even though it's actually already going to be shown but still okay then for the hind this one we want to hide when we press the interaction however when that happens we don't want just this window to hide we want the kitchen game manager to change the state so we're here on the kitchen game manager we currently have the waiting to start and that one actually has a timer so we count down the timer and then we start whereas right now we want it to be based on player input so let's modify this to not be based on timer so let's just get rid of this timer and now let's see all these errors so I'm waiting to start we are not going to count down any timers instead let's listen to the game input so game input let's listen to the on interact action event and rename this to the game input okay so when we have this event when the player presses the interact action let's check if the state if this one is on waiting to start if so then let's modify the state so let's go into State and we're going to go into the countdown to start and let's trigger the on state changed event okay so that's it so we're only going to change it on the player input and nothing over here on the updates then for hiding the tutorial over here one approach would be to listen to the interact action and hide it but I think it makes more sense for this to only listen to the kitchen game manager state that way if we wanted we could also modify how this one changes the waiting to start so let's listen to distinct over here on tutorial we want let's go into the kitchen game manager the incense and let's listen when the state changes so here we are going to check if the kitchen game manager instance if it is on the countdown to start active so if the countdown is active then we're going to hide this okay so that should do it now let's just do one more small thing the delivery manager is currently spanning a recipe whilst we're still reading the tutorial that's not quite right so let's go over here on the delivery manager and right now this one starts off at 0f and starts counting it down right away instead of only doing it like this let's just make sure that we only spawn a recipe if the game is playing so that's super simple over here kitchen game manager instance is game playing if so then we are going to spawn a recipe and let's do the same thing on the points counter so let's go in the plates counter so here we are on the plates counter so we count on time responsive lights but let's also make sure we only spawn plates if the game swing okay so with all of this let's test and right away here we are we can see our nice tutorial teaching the player how to play okay great here we've got the controls everything and we're currently waiting for an interaction we can see over there plates are not being spawned and recipes are also not being spawned but as soon as I press the E key and if there go the countdown starts playing and we've got everything else any up there you go the game starts and after a while yep we've got plates and we've got recipes alright awesome so next let's publish the countdown visual right now it's pretty basic it's just a static number so let's add a nice animation to it let's go inside the canvas let's find the countdown UI so the game start countdown okay so here it is we just have some basic text now let's go into the main game object and let's add an animator component then let's create a brand new animated controller so let's create a new down here an animated controller for the countdown UI over there let's assign this controller okay now let's open up the animation window so window animation open up the animation window okay let's create an animation clip and over here on let's name this the countdown UI number popup okay that's great now for making the animation we want to basically make it shake and also make it fade away so one very useful component is the canvas group so over here once on the parent let's attach a canvas group component this one is a really useful component in this case the main benefit is it let's just easily animate the alpha so let's go ahead and turn on recording let's go into the frame just before one second so let's go into 60 frames because we are on 60 frames per second over here let's record the normal keyframe so let's modify the scale on the tiny bit just to record it and let's reset it back to one okay just to record the keyframe then for rotation let's rotate on Z then put it on zero again just record the keyframe okay great so now we can go back into the first frame and over here let's first make it smaller so for the size let's put it on 0.6 then let's rotate it to the left so let's put 17 over here on the set rotation okay like that now let's move up by just three frames so on frame three over here let's make it quite a lot bigger so let's put it on 1.3 and let's rotate it to the opposite position so 17 okay that's great that's a nice start now let's put it on frame 10 and over here let's set the rotation to zero and for the scale put it on 1.1 okay so now finally over here on frame 50 let's set the alpha onto one and then on one second let's put the alpha zero okay so let's preview and if they go a nice simple animation okay so that was great now we just need to play this when the countdown happens so let's stop recording let's go inside the animator controller so here it is we've got our number popup and we basically just want to play this animation whenever we want so let's put it and make a transition from the any state onto the number popup on this transition let's make sure we have no exit time and for the settings over here for the duration let's put it on zero so that it's instant okay great now obviously we need a condition so on the parameters let's create a brand new trigger call this the number popup let's select that one and Trigger it on this trigger okay great so now for handling this logic here we have the usual question so do we put this visual Logic on the same UI script or do we separate the animations from the UI for me I find that UI is usually part of the visual so sometimes I like to mix the two and sometimes I keep them separate it really depends on a casebycase basis this visual is so simple and so connected to the actual UI Logics over here let's put them together so let's open up the game start countdown script and over here let's first grab the animator so private animator for the animator and on private void awake let's just get the animator and just get the component of type animator okay so we have the animator now we basically just need to keep track down here where we're modifying the text we're doing this on every update but now we need to know when this number changes so let's basically just keep track of the current number and the previous number so first of all over here an end for the countdown number and we're going to get this so this is our countdown number and over here we set it to string okay and we just need to use a different function so instead of Cl lets you cl2n just to convert the output into an integer okay great so we have the countdown number now we just need to know if this one is different from the previous one so let's go up here let's define a private tint for the previous countdown number then when we go down here we've got the current countdown number okay then just check if it's different if it is different from the current countdown number if so then let's update it so the previous one becomes this one and now let's fire off the animation so let's go into the animator and set the trigger and again we don't want these strings so let's go up to the top of the file make a private cons string let's call this the number popup and number popup okay so we have this end down here we just set this trigger okay so that's it pretty simple and just for fun let's also add a nice sound effect so let's go over here onto The Sound Manager and let's make a function to play sound so just like we did over here for the play footstep sound let's make another one for this one let's go and play countdown sound and for this one let's not receive a volume or position and we just play let's say just the warning sound so just down on Vector 3.0 and with the current volume okay so we have this function and then down here just going to sound manager instance and play the countdown sound again we could refactor this code to separate the Yuan logic from the animation from the sound that is one approach and sectionally one thing that we're going to do in the next polish stage but this one is also a possible thing since the UI is only so directly connected to visuals okay so with this let's test so here in the options let's just make sure that we have our sound effects so let's make sure they are playing okay great now let's go ahead and play and there you go we have our nice countdown number and there you go it looks great so it looks great and sounds great alright awesome as you can see just by adding a simple animation and some simple sounds that already looks so much better now the next thing we want to publish is on the stove so let's go into our stove back into our counters back into 3D and zoom in over here okay let's also make sure that we hide the canvas just so we can play around this all right great so there's our stove and for this we want to add basically a warning icon on any nice sound when the meat is about to burn so let's go inside the stove counter prefab okay so now inside of this we already have a nice generic progress bar UI and like I mentioned if you want to get some more custom Behavior you can combine a generic bar like this one with some specific components so that's exactly what we're going to do right now so over here let's create a brand new canvas as usual let's make it a world space canvas for position let's put all of this on zero let's just lift it up by a bit so set it on a y of three okay great then let's add our super useful look at camera component and make it camera phone okay now inside let's go ahead create a new image let's put it on a size of 0.5 by 0.5 okay just a nice square and for the Sprite there's a nice warning image in the asset so it's this one here we have the warning okay great basically we want to show this when the meter is about to burn so let's make a screen to run this and on the canvas let's give it a proper name so let's call this the stove burn warning UI okay so let's make this crypto render so when you csharp script with the exact same name and over here let's attach a script okay great so now the first thing that we need is obviously a reference to the stove so let's make a serialized film private for the stove counter for the stove counter okay here in the editor let's drag the reference of the sub counter okay great so now we basically just need to know when the food is about to burn and for that we can actually listen to the on progress event so let's do a private void start and on start let's go into the stove counter and let's listen into the on progress change event okay so we have this one and recently we're going to want to show this element so let's find a bone show we're going to want to show this when the progress normalized is above a certain amount so let's define a float for the burn show progress amount and let's say 1.5 so on this one we show it except obviously we don't want it to be shown when the food is just cooking we only want it to show when it's about to burn so that means we also need to check the state on the stove counter so let's make a function to check if we are in the state that we want so we're here on the stove counter let's go down to the bottom and let's make a public bowl is fried and over here we just return if the state equals state DOT frame okay that's great so now here we're going to show if the progress is above 0.5 and the stove counter is on the Fright state all right so that's the logic that we want then we just want to show our height so let's make the original functions private show and a private void hide and just do game objects and active into either true or false and over here if show then let's call the show function and if not let's call the Hide function and of course on start let's start off as hidden okay that's it let's test just over here in the editor make sure the reference is right and let's save the prefab go outside and hit on point and yep right away there's no element okay great now I place it and it won't cooking there's no element and now once it's on the halfway point for burning and if there you go we've got a nice warning okay awesome so now that this is working let's just add a nice animation so once again let's go inside the stove counter and on the burn warning UI let's add an animator controller then let's actually create the animated controller so let's create a brand new animated controller for the stove burn warning UI then let's assign it okay and over here on the animation window let's create an animation let's put it on the same folder and call it for this one let's say flash we're going to make it Flash and then again for making it flash let's use the same component that we used a while ago so let's add a canvas group so here it is now we can play around the alpha so super useful although I should say that at this point since we just have a single image we could just record a change over here on the alpha for the image itself however one place where this component is super useful is if you have multiple images so if over here I duplicate this one and I put it off to the side if I change the alpha on one of them then obviously it only affects that one but if I go over here and I modify the canvas group that changes the amp for both of them so if you have a group of images then using the canvas group makes it super simple so anyway so here we have just our image let's go ahead and record and let's say we start off on Alpha zero then after 10 frames going to Alpha One and after 20 frames back into an alpha of zero okay so that's it a super simple very basic animation we don't even need analogic since we just want this animation to play NonStop so that's great that should be working now let's add some sound so for that we could make another script but already on the stove counter we already have a nice sound component so let's open up this grip the stove counter sound so this is basically where we're playing or stopping the sizzling sound so over here we can just add the warning sound we're going to play the sound just like we have over here for the burning UI so let's actually copy these same components and over here let's face it so for this one instead of show let's give it a proper name so play warning sound except it's not on say change so let's actually listen to the other one so still counter on progress change let's listen down and it's on that one that we use this Okay so we've got that one and then for playing the warning sound we're going to want to basically play it every certain amount of time so let's make over here a private void update and an update let's just Define a private float for the warning sound timer and so down here we just count down as usual time dot Delta time and if this one is under zero if so then let's reset it so Define a certain maximum let's say 10 times or maybe just five times per second that should be good so we have this but obviously we only want this to run if we should be playing the warning sound so let's actually save this one up here so probably won't for these play the warning sound and then we set it on this one and down here let's just go and we're only going to run this if play the warning sound then we're going to run our timer logic all right and then over here all we need is to play that warning sound so let's actually go into The Sound Manager and just like we added the countdown sound let's add another one so let's say the play warning sound and for this one let's receive a vector 3 for the position and we're going to play the warning sound on this position so now over here on the stove counter let's go into The Sound Manager the instance and let's play the warning sound and pass in the stove dot transform that position okay that should do it so we now should have a nice warning sound and over here we should have a nice animation on the burn warning UI so let's see both those okay so let's pick up some meat and drop it and right now it's cooking okay great and once it gets a halfway point if there go now we have a nice warning sound all right awesome let's just add one more tiny thing let's make the bar itself also flash red when we're about to burn so once again let's go inside the stove counter and on the progress bar UI let's add a nice animator and let's go ahead and make one so let's create a new animated controller for the stove burn flashing bar let's go ahead and assign it so it's the one on the progress bar let's add the stove burn flashing bar then on this one let's create new animation let's go inside the assets animations let's make one and just call it idle for this one we're going to want the exact same color as the normal color so let's go into the bar and set the color just save a keyframe over there okay so that's what we want now let's make another animation so let's stop recording and let's actually duplicate this one so duplicate it and for this one name it flash now of course we need to add it to the animated controller so let's go over here and drag it on top okay now for the animation let's select the Flash and for this one let's go ahead click on record let's start off on this one and after a few frames so let's say maybe after 10 frames let's Flash in red and after 20 frames let's copy paste the same frame okay so that's our nice flashing bar now let's just set it up so let's go into the animator and over here we're going to have a transition from that deformation form flashback now all we need of course is an animator to control this so let's make a new animator parameter let's make it a Boolean and call it is flashing and again make sure to be careful with cane sensitive okay so from idle into flash let's go ahead remove the exit time for the duration make it instant so zero and for the conditions when that one is true okay great and for going back once again same thing so instant and let's make the condition when it's false okay that's it super simple now let's make a script to run this so let's go ahead create a brainy sharp script for the stove burn flashing bar UI let's go ahead and add it to the bar so that's the flashing bar UI okay over here let's do pretty much the same thing that we did on the other one so let's go over here onto the stove burn warning UI I might actually copy exactly this so let's go on this one and paste this one then back here in the editor let's drag the reference to the self counter and over here the logic is going to be very very similar so the only difference is we have an animator so the animator and we're going to grab it on private wide awake and later get component of type animator so we have the animator then let's define the parameter so private con string for the is flashing and let's set it is flashing okay we have our parameter and now down here instead of showing and hiding we'll just go into the animator in order to set a ball and the bone will be the is flashing and let's set it based on show so either we show or hide and we actually don't need these functions and by default of course let's leave it on false okay so that's it super simple Let's test just make sure to save the prefab and hit on play okay let's go ahead and cook so let's pick it up and drop it alright so it's cooking let's wait for it to be burning and as soon as it gets there yeah there you go we've got a nice warning a nice flashing bar and a nice sound effect so all three warnings making ourselves much more polished alright awesome now just for balancing let's play around the timers so let's go into our script ball objects on the frying rest BSO let's make this one take five seconds then on the burning recipe for this one let's make it take six and finally let's also add another stove so let's take our self counter duplicate the prefab let's put it over here so rotate it to the side and let's get rid of this one and put this one right in there so on 7.5 0 and minus 1. all right so we now have two stoves I can put one cooking put another one and I can start cutting down some cheese start cutting and before they start to burn what's actually here there you go that one is about to burn so let's pick it up quickly and that one is actually gonna burn but I got it okay great all right awesome everything's working great now for one more polish element let's make a nice visual when we deliver either a correct or incorrect recipe I think it wouldn't look good as a warm canvas on top of the delivery counter so let's do that let's over here find the delivery counter let's go inside the prefab and now in here let's create a new UI canvas let's name this the delivery result UI and as usual let's make this a worm space canvas so put it on worst face and for the position let's actually lift it up and then we're going to make it look at the camera but just like this it might actually go inside the wall so let's put it over here to the side a little bit so let's put it on this position so on the X of minus 1.6 on a y of three and on a z of 1.2 okay that's the position so right there that is going to be unlocking at the camera now inside let's create a new UI image it's going to be our background and for the size the width and height let's put it on 2.2 by 0.9 okay that's our background for the Hunger let's tinted in a nice green so let's put it something like this then let's also add a nice outline let's put it on full Alpha and for the size let's put it on 0.1.1 then let's also add a nice shadow component for this one leave it on half Alpha and let's put it on 0.2 and minus 0.2 okay so that's a nice visual now on top of it let's create a new UI text let's call it the message text and for the message we're going to say something like delivery and then underneath success let's put it on a width and height of zero let's put it on a super tiny font so let's say just 0.25 let's put it in bold and put it down Center and get rid of wrapping okay that's it let's just push it a little bit on the left side so on minus 0.32 on the X okay and now next to it let's make another UI image for this one call it the icon image let's put it with a size of 0.5 by 0.5 and put it over to the right side so on an X of 0.7 okay and now for these Sprites including the assets are too nice sprites so there's a nice cross for when we get it wrong and there's a nice tick okay so that's the setup that we want now on the delivery result UI let's go ahead add our own look at the camera component and for this one let's go different so instead of the camera four let's go ahead with the unlock at inverting so there it is this is our setup now let's make the script run this so let's go ahead create the new UI new csharp script for the delivery result UI let's attach the script and open okay so now here on let's make serialized films for our elements so a serialized film first of all for the background image and this is actually going to be a Type image image inside in the engine.ui okay our background image then we're going to have another one for the icon image and we're going to have another one this one is a text mesh Pro e GUI for the message text okay let's save okay so let's drag the references to the background the message text and the icon image okay great and over here let's listen when a delivery is delivered so let's make a private start let's go into the delivery manager the instance and we have all of our next events so we've got a success and a field so let's listen into both them so both the success and on the recipe failed let's listen to all these and as always let's write good point code and rename this so the delivery manager on recipe success and for this one is the on recipe failed okay we have both of our events so over here it's actually going to be very simple we just want to play around the text the icon and the background color so for example when we fail let's go and we want to set the background image to about a red so for defining the column let's actually go here and Define a color for the success color and we're going to have another one for the failed color and then for the Sprites let's also have that so Sprite for the success Sprite and another one for the failed Sprite okay those are on the elements so we're here in the editor let's just set them so for the success column let's actually use the exact same color by the way here's a quick tip if you go up to film for example like this one on the color you can right click and copy and then go into delivery results and over here right click and paste there go the perfect color then for the final color let's go with the red maybe a bit darker and also importantly make sure you set the alpha to phone okay so we have a red nice and like that okay then the success Sprite this one is going to be the tech and for the fail this is going to be the cross okay those are all of our elements so over here when we fail let's go into the background image and set the color and let's put the fan color then for the icon image let's set the Sprite to the Fey on Sprite and for the message text let's set this one for delivery and then failed by the way this backward slash n this means a new line so we're going to let you set the text on this one so it essentially means that it won't write delivery then new line and then failed underneath just make sure you're using the Packer slash and not the forward slash so use the backwards one there you go there's a new line okay so that's the on recipe film and now on the recipe success let's use the success color the success Sprite and over here the delivery success okay so that's great that should be working now just one more visual thing let's add a nice animation so just like we did previously let's go over here over here and let's add an animator component let's create an animation for this one for delivery result UI so let's go up here create a brand new animated controller for this and let's go ahead and assign it so delivery result UI all right now let's make an animation so this delivery result UI let's call it just popup and for this one let's do just like we did for numbers so let's scale and rotate it however if we rotate that's actually not going to work that is because we have the unlocked camera and this one is already going to be setting the rotation so we would end up with this script finding the animator for the rotation so that would mess things up however one nice and simple solution to this basically we just put this inside another game object so let's create a new game object and let's put it inside what's an empty game object for the delivery result rewind then look at the camera so we have this one now the reason why I created it inside is that so over here we can set everything to zero and now with that one on zero we can go ahead and drag this outside of this object and there you go that one keeps the exact same settings and on this one we can add the unlocked camera component and set it up just like we had so then we'll look at inverting and on this one we're going to make a channel live down and there you go now everything is on zero exactly as it should be and on this one we can get rid of the unlocked camera and now we can indeed play around the rotation so for the animation let's just go ahead and set it so for this one let's go up to one second and let's record a keyframe on a scale of one and on a rotation of zero then let's go back into the beginning and for this one let's scale it backwards so maybe something like this maybe a 15 let's put it quite a bit smaller then let's go up by three frames let's put that one on 15 so rotation on the other side and put it quite a bit bigger and then on frame 10 put it on say 1.1 with a rotation of zero just like that so there you go there's a nice popup and for the alpha let's also go over here into the 50 and let's just add the canvas group let's set this one over here is on one and then we scroll it down to zero okay so that's our nice animation let's stop recording let's open up the animated controller and over here let's make our nice animations transition so transition from any state into that one let's make it based on a trigger let's call it just popup and for this one this says no exit time duration of zero and let's go when the condition when we have this trigger okay so that's it although one thing by default this animation is going to Loop so let's just go ahead we can select the animation and over here let's just untick Loop time so that way the animation will not Loop okay so that's great now let's go into the script and over here let's get our animator so private animator animator let's get the animator just get component of type animator and let's define over here the private constring for the popup so we have this and then when we have either fail or success let's just go into the animator and let's set the trigger for our popup both up here and over here now we just have obviously one issue which is that it starts off as visible we don't want that so over here we can just do game objects set active into false in order to hide it and when we get either of these let's set it both to true then afterwards the animation won't make it invisible so it will still be active but it won't be invisible so that's fine so just with this everything should be working as we want so let's test let's just make sure to save it and go back okay so here we are let's try delivering an incorrect plate and there you go Gotta delivery film okay great now let's try delivering a correct one so someone wants a cheeseburger so let's cook it slice some cheese let's get some bread so bread cheese and pick up the burger and deliver and there you go a nice delivery success all right awesome okay so with these handphone changes you can already see how we made quite a big difference in our game we didn't do anything to change any core mechanics we just made what was already there pop out we added a nice visual boundary to make the map look nice we added some nice particles when the character is moving then we added a nice tutorial and controls right as the game starts we also added a bunch of effects on the stove so it flashes has a warning and some sound and lastly we also added a nice popup when delivery is delivered whether correctly or incorrectly now of course we can always keep publishing the game until Infinity there's always more small things you can add to punish the game just a little bit more but at this point I'm very happy with what the game looks like so after all this work let's go into the next lecture where we're going to play our game from start to finish and see what we've done hello and welcome I'm your kudmaki in this lecture we're going to look at all the work that we've done and have some fun playing the final game okay so here we are in our nice starting main menu it's simple but it works I actually thinking looks pretty good so we have our main menu working and we also have the unloading system that we made so as soon as I click on Play There You Go loads in loading scene and here we are on the game scene so we start off with our really nice tutorial window and down here we have the controls of course some of these are dynamics so depending on if the player rebinds or something this one is going to update so we can look at this window for as long as we want the game is paused in the background so it's on a paused game state then whenever ready we can interact so again that's the game input class listening to the input and again all of the code in here is really nice and clean so when we press enter key the tutorial isn't directly listening to that but rather the general kitchen game manager that main State machine is the one listening to the input and this one is listening to that state so our logic is very well organized all of the elements only listen to the things that make sense to them so anyways here we have tutorial let's interact and there you go we've got our nice game start countdown some really nice animation really nice sound and yep here we are then we've got our clock showing the game time and on the left side we can see our recipes once again all of the elements they're all Dynamic they're all spawn randomly and the icons for all of the recipes they're also all Dynamic so over here we have the character control that we built we have the collisions that we implemented and of course we have the raycast testing for interaction so we can identify all the objects in front let's begin delivering some recipes so for example we need to cook some meat so let's go ahead put it on the stove so here is the really nice tape machine that we built so we've got all the various States we've got the visual completely separated from the logic so everything is really nice and of course here we have the nice burning elements that we added in the Polish lecture so that one is burned so let's go ahead and use the trash bin to get rid of that so let's go ahead cook another one and let's make a cheeseburger so let's put some cheese let's listen to the aunt interaction key and we can slice the cheese we can pick up the meat pick up the cheese then also pick up some bread and deliver the recipe and there you go our nice polish visual all right awesome so here you can already see everything that we've built the character the physics the logic the input all of the UI elements all of the worm UI elements of the various counters and how they are on prefab variants of the plates the separation between the visuals and logic separation between the sounds and logic of the Polish elements that we made over there the nice shadow graph that we made then of course some of the basic things that a lot of tutorials won't teach you like for example how to make a pause menu how to make the options how to modify the Sound and Music Volume how to rebind the Keys and so on so with all that here throughout this course we'll learn how to make a really nice game with lots of interesting interactions which you can now apply to any kind of game any kind of genre you want so like I mentioned in the very beginning you can take pretty much what we've made here which is really just a character controller and a bunch of interesting interactions you can take everything that you've learned here and make something on a SciFi space like for example make something like Among Us you can make something like FTL or perhaps make some kind of survival crafting game some of the interactions you would have like resource nodes in the world then you can interact together those resources so with that you could build something like rust or Minecraft or Don't Starve so hopefully in this course you'll learn a ton that you can now apply to your own custom original projects and if you've made it this far then congratulations let's go into the next lecture where I'll give you my closing thoughts hello and welcome I'm your code monkey and congratulations you have completed this course awesome seriously congrats looking at the stats on my courses very few people stick with it until the very end so if you're hearing this then that's excellent you're on the top 10 percent it means you are serious about learning game development and I generally hope this course has helped you on your own Game Dev Journey throughout this course you'll learn about the basics of unity and csharp you'll learn how to make a character controller how to do a physics raycast and use that for both Collision detection and identifying objects to interact with you'll learn about csharp interface and events two extremely useful csharp features you'll learn about script mode objects how to use the new input system should graph and tons tons more and the most important thing of all you'll learn how to build a relatively complex game while writing good clean code I really hope that's the main takeaway you'll learn from this course learning how to write better high quality code learning how to refactor how to keep the visuals and logic separate keep the UI the couple from logic learning all those things has now made you a 10 times better developer than when you started so I really hope you enjoyed learning all that let me know in the comments what was the most important thing you'll learn throughout this course I really hope this was very fun and very educational if you enjoyed my teaching style check out my other courses I really think the turnbased strategy course would be excellent for you right now it Dives even deeper into some Advanced topics and since you've watched this entire course all the way you now have all the knowledge needed to follow that course it will help you really simply the final knowledge you gained especially everything related to writing good high quality clean code and since you use Unity check out my ultimate DND overview course it covers lots of tools and features of the engine so you can really use all the tones at your disposal to make any game you can think of alternatively if you like visual scripting I have course on that or learn how to make a really nice Builder Defender game and definitely make sure that you wishlist my upcoming steam game total one Liberation I won't be posting devlogs and in those you will see how the code that I use in my own steam game is on the same level of quality as what you learned in this course okay so that's it for me this course was a ton of work so I generally hope it helped you a ton on your gamedev journey thank you so much for watching and I'll see you next time
