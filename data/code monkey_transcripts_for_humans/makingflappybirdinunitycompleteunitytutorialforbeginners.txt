With timestamps:

00:00 - in this video we're going to create
00:01 - flappy bird completely from scratch in
00:03 - unity this is a great game for beginners
00:05 - to start with it's a very simple design
00:07 - that still involves some interesting
00:09 - logic let's begin
00:13 - [Music]
00:17 - hello and welcome I'm your code monkey
00:20 - and this channel is all about helping
00:21 - you learn how to make your own games
00:23 - with nf2 torrents made by a professional
00:25 - indie game developer so if you find the
00:27 - video helpful consider subscribing okay
00:29 - so here is what we're going to create in
00:31 - this video we're going to start off
00:32 - completely from scratch and build the
00:34 - whole game we start off with everything
00:36 - stopped waiting for our input we can
00:38 - play the game with the keyboard the
00:39 - mouse or with touch input as soon as you
00:42 - press the button there you go the bird
00:44 - starts flying and the own level starts
00:46 - being generated the pipes start coming
00:48 - in with gaps in between them we have
00:50 - nice sound effects for the bird jump and
00:52 - every time the score increases as you
00:55 - can see as more pipes get spawned the
00:57 - game becomes more difficult as the gaps
00:59 - in between them become smaller and when
01:02 - we die there you go we have a nice game
01:05 - over window that pops up in here you can
01:08 - see that we are storing our current
01:09 - score and our high score then we have
01:12 - our two buttons to retry and back to the
01:14 - main menu now when we retry it's very
01:17 - quick it reloads the main scene and we
01:19 - can try again very easily and the other
01:21 - button for the main menu we can get and
01:25 - we go into a very simple main menu where
01:26 - we can go into playing the game or quit
01:29 - to the desktop so we hit play and here
01:31 - we are back again everything is built
01:34 - correctly so the game works on both
01:35 - desktop and mobile the game is also
01:38 - nicely polished as you can see with bird
01:40 - flapping its wings when I click you can
01:42 - see it nicely rotate with jump velocity
01:45 - there are clouds in the background being
01:47 - moved with a nice parallax effect along
01:49 - with our ground and the pipes and here
01:53 - on the GAMEOVER window as you can see it
01:55 - also has a nice polished animation so
01:58 - this is our final goal now let's go
01:59 - through an overview of how we're going
02:01 - to get there
02:04 - we're going to start off with a
02:05 - completely empty scene making a brand
02:07 - new unity project then we're going to
02:10 - begin with our initial setup first setup
02:12 - the main scene and camera as well as
02:14 - organizing our hierarchy and project
02:16 - folders then with the basic setup done
02:19 - we're going to start working on the bird
02:21 - make the game object and the script to
02:23 - control it listen to input and use unity
02:25 - physics in order to move it with burden
02:28 - we're going to handle the other
02:29 - essential component of the game the
02:31 - pipes first learn how each pipe is setup
02:34 - with a body and head sprite as well as
02:36 - handle collisions between the bird and
02:38 - the pipes then we're going to start
02:40 - working on a level script which won't be
02:42 - responsible for spawning our pipes start
02:45 - off with a simple function to create a
02:46 - pipe with the correct size and position
02:48 - then expand the Panda to make a function
02:51 - to create both a bottom and a top pipe
02:52 - with a certain gap between them
02:54 - with the pipes being correctly spawned
02:56 - we're going to handle their movement as
02:58 - well as correct spawning and cleanup
03:00 - we're going to implement increasing
03:02 - difficulty based on the number of pipes
03:03 - spawned so as the player goes along the
03:06 - pipes become more frequent and with
03:07 - smaller gaps then we're going to get to
03:10 - work on making the UI first deal with
03:12 - the setup and then add a simple window
03:14 - to display the current score with the
03:17 - score working we're going to handle our
03:19 - game over state so make another window
03:21 - in the UI that pops up when the game
03:23 - ends which is when the bird hits a pipe
03:25 - the window shows the score and has a
03:27 - very quick retry button then we're going
03:30 - to make a proper loader class to handle
03:32 - all of our loading and with that it's
03:35 - time to make a simple main menu just
03:37 - another scene containing a button to
03:39 - play another to quit without that the
03:42 - game won't be almost fully working so
03:44 - it's time to finally add some sounds
03:45 - we're going to make a nice class that
03:47 - will be responsible for playing every
03:49 - sound and then after that we're going to
03:52 - handle our score detect when we have a
03:54 - high score and save it when we beat it
03:56 - as well as a nice message in the game
03:58 - over window so at that point the game
04:01 - won't pretty much be done and with
04:03 - everything done it won't be time to work
04:05 - on punch so we're going to add all the
04:07 - tiny little things that greatly improve
04:08 - presentation like the ground and claps
04:10 - per rotation when jumping as well as a
04:13 - nice animation on the game over window
04:15 - alright so again here is
04:18 - final game after all of that we have our
04:20 - bird jumping and going through the pipes
04:22 - these score increases and we have some
04:25 - nice sound effects everything is nice
04:27 - and polished and the game is very nice
04:29 - and playable all right so this is our
04:32 - goal let's get started
04:37 - so here we are in the unity main window
04:40 - let's name our new project flappy bird
04:43 - we're going to use the 2d template and
04:46 - let's it create alright here's our
04:49 - completely empty scene well let's first
04:51 - rename the scene in order to have a more
04:53 - appropriate name so this will be the
04:55 - game scene this will be the main scene
04:58 - where our game is we won't later have a
05:00 - different scene for the main menu and
05:02 - anything else we need so in here let's
05:04 - set up our camera since we selected 2d
05:07 - our camera is already in orthographic
05:09 - mode let's just change the size so we
05:12 - can use a larger unit size in our game
05:14 - and here the size is the orthographic
05:16 - size which represents half the vertical
05:19 - space shown in the camera so in here and
05:21 - let's set to 15 and now here on the
05:24 - scene view we can see that our camera is
05:27 - now displaying right here from minus 50
05:30 - all the way up to plus 50 so we have a
05:32 - hundred units being displayed all right
05:34 - now let's make our main starting object
05:37 - so we make a new game object let's put
05:40 - it on zero zero zero now this won't
05:42 - contain the main script that handles our
05:44 - game so let's name it our game hemily it
05:49 - will also be the main container for our
05:50 - preset scene objects the better you keep
05:53 - your objects organized in your hierarchy
05:55 - these are it is to find what you're
05:56 - looking for so here let's drag our
05:58 - camera in order to be a child of the
06:01 - game hello okay now let's make a game
06:03 - handler script in order to handle our
06:05 - game this will be the entry point for
06:07 - most of the game so in here first let's
06:10 - make a new folder this will be our
06:12 - scripts folder and inside we create a
06:15 - new C sharp script and this will be our
06:17 - game helmet okay let's open the script
06:21 - and in here and let's just do a debug
06:23 - download on the start
06:30 - okay very similar script just so we can
06:32 - make sure that our script is running so
06:34 - now back in the editor let's select our
06:37 - game object and drag the script onto it
06:40 - okay let's test any of their lives on
06:42 - the console game hell more dots are okay
06:44 - great everything is looking good so far
06:45 - now let's set up some visuals so first
06:49 - we make a new folder this won't be our
06:51 - textures folder all right I have copied
06:55 - some textures onto this folder as always
06:57 - you can download the project files from
06:58 - the website so in here we have a simple
07:01 - background texture a bird a ground a
07:04 - pipe body and a pipe head here is also a
07:08 - white pixel texture it's literally just
07:11 - a one by one white texture this is great
07:13 - whenever we want to display a colored
07:15 - rectangle so let's begin by setting up
07:17 - the import options for this texture it's
07:20 - one by one so we set the pixels per unit
07:22 - to one so when we add this texture to a
07:25 - sprite renderer it won't occupy exactly
07:27 - one unit now for the other textures it's
07:29 - going to depend so let's start making
07:32 - our objects and then we'll hand all the
07:33 - pixels per sprite so first of all make a
07:36 - game I'll check this will be our
07:37 - background we add a sprite renderer
07:40 - component and drag the background sprite
07:44 - so here's our background sprite
07:46 - occupying the entirely of our camera
07:48 - view okay now that we have our
07:50 - background let's make our bird so a new
07:52 - sprite this will be our bird and let's
07:56 - drag the bird sprite okay this seems
07:58 - like a good science here it is in the
08:01 - game view and now that we have multiple
08:03 - sprites let's handle our sorting layers
08:06 - so we can simply go from the spread
08:08 - rendering here at a sorting layer now we
08:10 - have the default let's make a background
08:13 - layer and also a over layer so we have
08:22 - the background then on top of the
08:23 - background we have the default and on
08:25 - top the font we have another layer this
08:28 - one is just in case we need it later so
08:30 - here in our background we put it on the
08:32 - background and the bird let's leave it
08:34 - on the default okay so that's our basic
08:37 - setup for the main sprites we're going
08:39 - to need we have our hierarchy organized
08:41 - we
08:42 - our main camera our main object the bird
08:44 - and the background the project files are
08:47 - also nicely organized into folders so we
08:49 - have the scenes scripts and textures and
08:52 - now in order to help us develop the game
08:54 - faster we're going to use some very
08:56 - helpful classes from decode monkey
08:58 - utilities this is just an optional step
09:00 - you don't absolutely need to have them
09:02 - but it will help us in iterating and
09:04 - debugging our game in many ways the
09:06 - scale of a game the vampers based on the
09:08 - tools at our disposal so you can go to
09:10 - the website unity code market account
09:12 - download utilities for free and then you
09:14 - get a unity package file when you open
09:17 - that file you won't see this window so
09:20 - in here let's simply import everything
09:22 - and there you go here in our project
09:24 - files you can now see a new folder and
09:26 - in here it contains all of the utilities
09:28 - as you can see it also contains all
09:30 - these source files so feel free to go
09:32 - through all of these in order to see how
09:34 - all work now to make sure everything is
09:37 - set up correctly let's go back into our
09:38 - code into our game hammer and in here
09:41 - and let's spawn some testing pop-ups so
09:43 - first we go here using code monkey and
09:48 - using code monkey utils and here let's
09:53 - spawned some pop-ups every once in a
09:55 - while so for that we can use the
09:57 - function periodic this lets us
09:59 - automatically call a function every
10:00 - certain amount of time so this is the
10:04 - function we won't call inside we just do
10:10 - a text pop up on your mouse position
10:22 - okay so here it is very simple we are
10:24 - simply going to execute this function
10:26 - every 300 milliseconds so we should be
10:29 - able to see a nice text pop up just see
10:31 - if our utilities have been correctly set
10:33 - up let's see any app as you can see
10:36 - there are the messages so we have all of
10:37 - our utilities correctly worth this will
10:39 - be very useful as we go on so we have
10:42 - our complete set up almost done let's
10:44 - add just one more very useful thing
10:46 - let's make a class that we can use to
10:48 - easily reference assets from code so for
10:50 - example let's say here in the game ham
10:52 - where I want to spawn a pipe so what I
10:55 - would do would be create a new game
10:57 - object so here for example I'm creating
11:05 - a new game object with a sprite render
11:07 - and I mean here I need a reference for
11:09 - this part that I want to use so this is
11:11 - where it's really helpful to have a
11:12 - class that contains all of our asset
11:14 - references so let's do that here let's
11:18 - make a new c-sharp script this will be
11:20 - our game assets and now let's also make
11:23 - a game assets game object again keep it
11:29 - organized so drag it in there and drag
11:31 - our script onto it okay now this won't
11:34 - be a very simple class now for starters
11:36 - one thing we need is to be able to
11:38 - access our fields from everywhere else
11:40 - in our code so let's make a static
11:42 - accessor
11:48 - so we have a private static instance and
11:51 - the public function to get the instance
11:53 - then we just set the instance on our
11:55 - private Roy away okay so now everywhere
12:00 - else in our code we can access this in
12:02 - order to get this instance being static
12:04 - means that this can be accessed from
12:06 - everywhere else in our code so now all
12:09 - we need to do is add public fields for
12:10 - whatever assets we need and we won't be
12:12 - able to reference them through code so
12:15 - here just for testing let's do our
12:17 - public sprite for the pipe head sprite
12:22 - and now we can go back into our editor
12:25 - and there's our script as you can see
12:27 - there is the field now we can drag our
12:29 - pipe head okay so we have our asset
12:32 - reference right there so now we can go
12:33 - back into the game Handler and in here
12:36 - we can finally access that so we're
12:38 - going to became assets we get the
12:40 - instance and then we access the pipe
12:42 - heads Frank alright so let's see and if
12:45 - there is our created game object with
12:47 - the correct pipe head sprite so as you
12:49 - can see we're able to reference this
12:51 - asset through code now just one last
12:53 - thing and here we need to make sure that
12:55 - our awake runs before anyone else tries
12:57 - to access it so for that we can go into
13:00 - edit project settings now in here we
13:03 - have the script execution order and we
13:05 - can simply drag the game assets and drag
13:07 - it onto the top that will make sure that
13:09 - this script gets executed before any
13:11 - others test it again and yep everything
13:14 - is working perfectly fine ok great so
13:17 - here we have made all of our initial
13:19 - setup and we are finally ready to begin
13:21 - creating our game we setup the main
13:24 - camera as well as our main game object
13:26 - that won't be the entry point for our
13:27 - game we also import the code monkey
13:30 - utilities which won't be extremely
13:31 - useful for helping us make our games
13:33 - faster and we made the game assets class
13:36 - which also be very useful for grabbing
13:38 - asset references through code okay with
13:41 - all that done let's begin making some
13:43 - basic control for our bird we want the
13:46 - bird to be controlled on by either
13:48 - pressing the spacebar or clicking on the
13:50 - mouse so let's make a script to handle
13:53 - our bird so a new c-sharp script don't
13:55 - let's simply call this bird and let's
13:58 - drag it onto our bird game object
14:00 - okay now in here let's first make a
14:03 - private Lloyd update then our update
14:08 - let's capture the space key so we do if
14:10 - input dot get key down key code out
14:14 - space so this one the space is pressed
14:19 - now when we hit space we want the bird
14:21 - to jump so we're going to make a
14:22 - function to do that so jump and now in
14:28 - order to do the movement and later test
14:30 - for collisions we're going to use the
14:31 - Unity physics system so let's go to the
14:33 - editor to set that up okay here we are
14:36 - on the bird game object and in here
14:38 - let's add a circle Collider 2d and let's
14:42 - look at the size so here on let's make
14:45 - it slightly smaller than the sprite so
14:47 - the game is a bit more forgiving and
14:48 - exciting okay now this is just a
14:51 - Collider so right now it doesn't do
14:53 - anything in order to handle gravity
14:55 - let's add a rigidbody 2d and here for
14:59 - the constraints let's freeze the
15:01 - movement on the X it's a bird long ago
15:03 - up and down alright so that's pretty
15:05 - much it for the physics setup so we can
15:07 - test out this code and see any of their
15:10 - is the bird is already being affected by
15:12 - gravity okay
15:13 - so far so good now all we need to do is
15:15 - tweak these values to make sure they
15:16 - feel just right so in order to test our
15:18 - values let's first teste jumping so here
15:21 - on the private void awake let's grab a
15:24 - reference to our rigidbody
15:34 - okay we have the reference to our rigid
15:36 - body and now in here on our jump we want
15:39 - to jump to be repeatable and consistent
15:41 - so the bird is meant to jump the exact
15:43 - same amount every single time that's how
15:46 - we're going to make sure that the game
15:47 - is fair now to achieve that we're going
15:49 - to modify the rigid body don't laissez
15:52 - that won't give it an instant jump as
15:54 - soon as we press so in here we use
15:57 - vector to data to move around and then
16:00 - we need a certain jump amount so let's
16:03 - go up here to define a constant for the
16:06 - jump amount so a private constant load
16:09 - for the jump amount and here we multiply
16:21 - a vector sodaro by our jump or not okay
16:24 - well let's see if when we press space we
16:25 - can see our bird jumping there's a bird
16:28 - press space and if there you go he
16:30 - started going up okay great
16:31 - now let's tweak these valleys okay so
16:37 - these values seem just about right so
16:39 - when I press give there yo he has a nice
16:42 - and repeatable jump so if I price
16:43 - exactly at the same time you can see
16:45 - that everything is repeatable so it's
16:47 - very much based on player skill okay
16:49 - great so the valleys we have 35 on the
16:52 - gravity scale and here we have a hundred
16:55 - on the jump amount so just like that
16:57 - here's our basic bird jumping up in
16:59 - there okay awesome now let's make the
17:02 - jump also based on the mouse click so we
17:04 - can play either with the mouse or the
17:05 - keyboard so here we're testing for gate
17:08 - key down on space and let's also test or
17:10 - input not yet mouse button down on the
17:13 - in left mouse button so mouse button
17:15 - zero let's see okay here we are space
17:19 - stone works and click yep there you go
17:21 - clicking some words okay awesome so we
17:23 - now have two different input methods and
17:25 - our game works perfectly fine now with
17:27 - this it would also be very simple to
17:28 - make it work with touch input since it's
17:30 - pretty much the same as the mouse so
17:33 - here we have our basic jump working now
17:36 - that we have the basic jump let's work
17:38 - on our pipes so over here as you can see
17:41 - there are two pipe sprites
17:42 - there's the pipe head and the pipe body
17:45 - so to see how they're meant to be set up
17:47 - let's make one in the editor so just
17:50 - drag the pipe body and drag the pipe
17:52 - head so essentially we're going to have
17:54 - our pipe body then don't be stretched
17:58 - based on a certain height and then we
18:00 - have the pipe head on top of the body so
18:03 - this is how we're going to create our
18:04 - pipe now how we're going to handle
18:06 - collisions is again using the physics
18:08 - system so let's move the pipe right next
18:11 - to the burn okay like that and here on
18:14 - the pipe body and let's make sure it
18:15 - reaches just the top of the head and in
18:18 - here we add a box Collider this is how
18:21 - we're going to test for collisions let's
18:24 - make this a is trigger and everything
18:26 - else leave the same now back in our Bert
18:29 - code in here let's make a private void
18:32 - on trigger enter to D so this function
18:39 - gets called whenever this collider hits
18:41 - another Collider so in this case and
18:43 - let's just do a pop up so again let's go
18:46 - up here using the code monkey Stoney's
18:49 - so you can go into the CM debug class to
18:52 - just do a text pop up on the mouse
18:54 - position okay let's see if our
18:58 - collisions are working okay here we are
19:01 - now let's fall and touch the pipe any of
19:03 - their Dean that pop up and yep just like
19:06 - that okay so we are correctly and
19:08 - successfully identifying collisions
19:09 - between the bird and the pipes okay
19:12 - great
19:12 - so we now have the basic collisions
19:14 - working and also we know what we need in
19:17 - order to create a working pipe now let's
19:19 - make a script which will handle our
19:21 - level by creating and moving our pipes
19:23 - so we make a new c-sharp script let's
19:26 - call this our level let's make a new
19:29 - game object for our level and drag the
19:31 - script onto it
19:32 - and again keep things organized so drag
19:35 - it on there okay and I'm here in our
19:37 - level class let's begin by creating just
19:40 - a simple pipe so let's make a function a
19:43 - private boy create pipe
19:47 - here for the parameters let's receive a
19:50 - float for the height of the pipe and
19:53 - also a float for the exposition now
19:56 - let's create a pipe like the one we
19:58 - created here in the editor so we have a
20:00 - body and a head now here we can use
20:03 - prefabs in order to insensate our pipe
20:05 - so let's go here make a new folder for
20:08 - our prefabs and let's drag the pipe body
20:12 - and the pipe head let's name this TPF
20:16 - pipe body and pipette okay so here are
20:22 - both of our prefabs now in here we
20:25 - instantiate and now we need a reference
20:27 - to our pipe so we can go into our game
20:29 - assets in here at a public transform so
20:38 - we have our two fields for the head in
20:39 - the body let's drag them here's the game
20:42 - assets drag the pipe body and the pipe
20:44 - head okay we have our references and
20:47 - then we can go back into our level we
20:49 - instantiate go into the game assets
20:51 - class you get the instance and access
20:54 - the PF pipe head okay so we have the
21:01 - pipette being instantiated and also the
21:03 - pipe body and just like that we have
21:07 - both them being instantiated now let's
21:09 - test this out so in here make our
21:12 - private voice start we're going to
21:15 - create a pipe and for now the parameters
21:18 - don't matter so much is passed zero just
21:20 - so we can test okay here we are in yep
21:23 - we have correctly in Senshi in our
21:25 - prefabs here are both of our codes okay
21:26 - great now that we can create them let's
21:29 - position them so let's modify the pipe
21:32 - head position for the X we pass in our
21:37 - exposition and the Y will be based on
21:40 - the height but for now let's leave it
21:41 - just at zero and also please leave pipe
21:43 - body on the x position so let's test
21:49 - finding two pipes so the first one on
21:50 - zero and the second one on 20 okay let's
21:54 - see if we have two pipes being
21:55 - accentuated any of there it is we have a
21:57 - pipe here and one in there okay great
21:59 - now
22:00 - with positioning them based on the
22:02 - height let's start off by making a pipe
22:04 - that occupies half of the screen so over
22:07 - here in the main camera we set the
22:09 - orthographic size as 15 so that means we
22:12 - can see a hundred units so this one goes
22:14 - from minus 52 plus 50 so if you place
22:17 - them down here and put a height of 50 it
22:18 - should occupy half of the screen and now
22:21 - here on our prefabs there are some
22:22 - things we need to change over here on
22:25 - the pipe body so far we just changed it
22:28 - on the scale however right now we're
22:30 - going to do it differently here on the
22:32 - sprite instead of simple draw mode and
22:34 - let's choose sliced so we can now reset
22:37 - the scale and now instead we move based
22:39 - on the height let's fix this warning so
22:42 - go into our pipe body make this foam
22:45 - rect so here is our updated sprite
22:47 - instead of modifying the unloadin scale
22:50 - we're going to modify the draw mode
22:51 - width and height so here it goes up and
22:54 - down okay and one more thing go here
22:57 - onto our sprite and we're going to set a
22:59 - pivot on the bottom so now we can modify
23:02 - the height in units and place it right
23:05 - on the bottom so we're going to place
23:06 - our sprite on minus 50 and we want to
23:09 - add at a height of 50 and just like that
23:12 - the fight will reach exactly the middle
23:13 - of the screen
23:14 - okay now let's position this through our
23:17 - code also one thing we need to see is
23:19 - the width of our pipe so for example you
23:22 - could decide to have a variable wind
23:23 - but in our case not to keep things
23:25 - simple we're going to always keep the
23:27 - same width so let's sort this as our
23:29 - constant so here on the level let's make
23:33 - a private Const code for the pipe width
23:37 - and put that back and now we can go here
23:41 - into our pipe body
23:48 - so we access our sprite render and
23:51 - modify the size so for the size we pass
23:55 - in a new vector2 first with the fight
23:57 - width and then for the height we want so
23:59 - in this case our height so if we go in
24:02 - here and we pass in 50 which now be able
24:06 - to see our pipe body having 50 height
24:08 - let's see and he appears both our pipes
24:11 - let's see if they are indeed and yep
24:13 - there you go
24:13 - they are on the Y of zero new in a
24:15 - height of 50 okay so the height is
24:17 - indeed working however now we need the
24:19 - head to be on top of the pipe since this
24:22 - one is meant to be going bottom-up so
24:24 - that means that we need to take the head
24:26 - and move around the way up there to the
24:28 - height except if we place it on the
24:30 - height it would be placed in here which
24:32 - would go past our desired height so we
24:34 - need to put it on the height minus half
24:36 - of the height of the head so let's do
24:38 - that through code so you position the
24:40 - pipe body make it the correct size and
24:43 - now for the pipe head it won't be placed
24:46 - on the height minus half of the head
24:49 - height so let's see how much is half of
24:51 - that height and here we can make also
24:53 - the head based on slice so we can easily
24:55 - see our width and height so here's our
24:58 - values essentially we wanted to put it
25:01 - up there minus half of that so minus 1.8
25:04 - and it would be just in there
25:06 - now obviously you can also see that the
25:08 - head is behind the body that is not
25:09 - meant to happen so we can also just set
25:11 - the order in layer leave it on default
25:13 - and put it on 10 okay that should do it
25:16 - so let's put this value in our code so
25:21 - another predacons float for the pipe
25:24 - head height
25:29 - so in here we position the pipe in on
25:32 - the height minus half of the head height
25:35 - okay let you do it let's see and here we
25:39 - are and yep there's our pipe correctly
25:41 - positioned the pipe starts on zero goes
25:44 - all the way up to 50 so to the top of
25:47 - the screen and the head isn't it placed
25:49 - exactly on top so here we have a perfect
25:51 - pipe with a height of 50 okay so far so
25:55 - good now one thing we need is obviously
25:57 - to update the valleys on the box on
25:59 - either as you can see it's only down
26:01 - here so let's set the Buckskin letter
26:03 - size to match the size of the sprite so
26:06 - the box weather is here on the pipe body
26:19 - so we just take the Buckskin weather and
26:22 - modify the size going to give the same
26:26 - pipe with an hour height okay now let's
26:31 - see okay here we are the pipes are
26:34 - correct let's look at the buxom weather
26:36 - and there you go the height is correct
26:38 - however it is still on that origin
26:40 - whereas the sprite has an origin on the
26:43 - bottom that is because we set the pivot
26:45 - on the sprite to be on the bottom so we
26:48 - need to do is shift our box Collider up
26:50 - by half of its height let's do that here
26:54 - we take the size then we also modify the
26:56 - offset
26:57 - now the offset on the X is zero it's
26:59 - correctly centered and here its height x
27:02 - 0.5 any of there it is it's perfectly
27:06 - correct as you can see there to the box
27:07 - wire and yep it goes perfectly all the
27:09 - way to the top okay great now let's fix
27:12 - the issue of the pipes being spawned
27:13 - right here from the zero we want to
27:15 - spawn them obviously right here from the
27:17 - bottom so that means we need to know the
27:19 - camera orthographic size so let's make
27:22 - that over here and now that our private
27:25 - conflict for the camera ortho size which
27:30 - in this case we're using 50
27:33 - in here in order to position them all we
27:36 - do is put them on - or through size then
27:40 - add all the rest okay let's see if the
27:44 - body in the head are now starting from
27:45 - the bottom any of their it is we now
27:48 - have our pipe spawning right from the
27:49 - bottom okay great so we have pretty much
27:52 - our create pipe function working what's
27:54 - responding different heights so when
28:01 - we'd 1543 and Twain any of there's our
28:06 - pipes all of them with the correct
28:07 - Heights okay great
28:09 - so everything is working great however
28:11 - in the game you don't just have pipes on
28:13 - the bottom but also on the top so let's
28:16 - do that or here are not create pipe
28:20 - function let's add another parameter
28:22 - let's receive a bowl and this will be
28:25 - create on bottom so if this one is true
28:29 - we create a pipe on the bottom if it's
28:31 - false we create it on the top so in here
28:33 - essentially for our positions we just
28:35 - have to reverse it so here let's define
28:42 - a pipe head Y position so by default on
28:45 - the bottom we do what we were doing
28:46 - previously then we have an else if we
28:53 - were not from the bottom then we want to
28:54 - create from top so it will start on plus
28:58 - camera ortho size minus the height and
29:02 - plus the pipe head height times point
29:05 - five and that's what we use in here okay
29:09 - so that's the head correctly placed now
29:10 - for the body
29:19 - so the body is very simple if we are on
29:22 - the bottom we start on - cameras or
29:24 - through size and on plus cameras I see
29:27 - from the top however the one thing is if
29:29 - we do it like this essentially we spawn
29:31 - around top and it won't start at top the
29:33 - screen and then go past outside of the
29:35 - screen since we set the pivot on the
29:37 - bottom so we can fix that by setting the
29:42 - high body dot local scale keeping it 1
29:47 - on the X and invert it on the Y ok so
29:50 - this should be working so let's test it
29:53 - out in here so we should be able to see
30:00 - a pipe on the bottom and one on the top
30:03 - post them with 40 of height let's see
30:05 - and if there is we have correctly set up
30:08 - our pipes so we have a pipe right here
30:10 - on the bottom and when right there on
30:11 - the top we can all get the scene view
30:13 - and yep everything is perfectly start
30:15 - exactly in there they go exactly for 40
30:17 - ok great so everything is perfect here
30:22 - testing with a height at 50 and yep they
30:25 - meet exactly in the middle all right
30:28 - great
30:29 - so we cannot spawn pipes both on the top
30:31 - and the bottom they are dynamic so we
30:33 - can spawn any size that we want now that
30:36 - we have similar is working in the flappy
30:39 - bird game design we normally always have
30:41 - a pipe on the top and one on the bottom
30:42 - so let's make a function that takes a
30:45 - gap size and calculates the size of the
30:47 - top and bottom pipes so in here we have
30:50 - our nice create pipe function ok
30:52 - everything is working perfect and I mean
30:54 - here we make another a private boy
30:57 - create gap pipes
31:01 - now in here will receive a float for the
31:04 - gap line meaning the height of the gap
31:06 - also evolves for the gap size so how big
31:11 - is the gap and also our fault for the
31:13 - exposition so we want to create a gap at
31:17 - this Y at this height with this specific
31:21 - size and obviously placed on this x
31:23 - position so that means we need to come
31:25 - like the height for both the top pipe
31:27 - and the lower pipe so let's start with
31:29 - the bottom pipe which is a symbol so we
31:31 - just do a create a pipe now for the
31:34 - height on a bottom pipe it will be the
31:36 - gap Y minus half of our gap size so gasp
31:40 - size times 0.5 F so this is our bottom
31:46 - pipe and now for the top pipe we need to
31:49 - know the total size of our play area so
31:51 - that's our camera ortho size x 2 so our
31:54 - play harriet has a hundred so to create
31:57 - our other pipe the height of this pipe
32:00 - is the ortho size times 2 F so the total
32:03 - playable area - the gap wine and - half
32:09 - of the gap size so we spawn our top pipe
32:14 - first of all we spawn it with the total
32:17 - size of the total playable area so it
32:19 - starts on top and reaches the bottom
32:20 - then we take away the gap wine so it
32:22 - goes just past that and then we take
32:24 - away half of the abbé sieyès okay so
32:27 - this should do it now let's go up here
32:29 - to test making a pipe so we create the
32:33 - gap pipes for the gap wine let's start
32:37 - off right in the middle so on 50 and for
32:40 - the gap size and let's say a size of 20
32:46 - ok so we should be able to see two pipes
32:48 - that make up a gap with 20 of height and
32:51 - the app is right down the middle let's
32:53 - see and if there it is there's our pipes
32:55 - both of them being created by just one
32:57 - function and let's make sure that this
33:00 - is correctly working so let's create a
33:02 - game object just don't look at it any of
33:05 - there it is up here we have a Y of 10
33:07 - and down here if there you go minus 10
33:10 - so here we have a gap with size of 20
33:13 - okay so our code is working perfectly
33:15 - great we automatically calculated the
33:18 - top and bottom pipes based on a certain
33:20 - gap Y and gap size so now with this next
33:23 - function we can get to work on making me
33:25 - in level generator but before we do that
33:28 - the pipes are not meant to be static but
33:30 - rather move with a level so here we have
33:32 - two options we can move our bird across
33:35 - the level and keep the pipe static or we
33:38 - can keep the bird static and move the
33:39 - pipes
33:40 - let's move the pipes instead so we don't
33:42 - have to deal with moving the camera so
33:44 - over here in the level class we need to
33:46 - keep track of what pipes have been
33:48 - spawned so we can actually move them so
33:50 - up here let's make a list of pipes so a
33:54 - private list let's store transforms and
33:56 - call this deep pipe list on the private
34:01 - void awake we initialize our pipe list
34:06 - and over here when we create the pipes
34:09 - let's add them to the list both the head
34:11 - and the body so in here pipe list
34:14 - add the pipe head and here at the pipe
34:18 - body okay so we are populating our list
34:22 - with all of our pipes now let's go to
34:24 - our update and in here and let's make a
34:29 - function called handle pipe movement now
34:35 - in this function let's just cycle
34:37 - through all the pipes and in here all we
34:43 - need to do is modify the pipe transform
34:45 - that position and move them to the left
34:48 - now we need to know how much we move
34:50 - them so let's go up here in order to
34:52 - make another constant for the pipe move
34:57 - speed and then here we just move them to
35:00 - the left so a new vector3 with -1 on the
35:02 - x x our speed and by time.com time
35:07 - alright so that's it very simple we go
35:10 - through our pipe list and we move the
35:11 - mounted left so let's test and here it
35:14 - is we have our pipe moving to the left
35:16 - ok great so this is working however the
35:19 - code isn't looking quite bad over here
35:21 - we have a list of transforms and each
35:24 - pipe is composed of two differ
35:25 - transforms it would make more sense to
35:27 - have a list of actual pipes and then the
35:29 - pipe class would handle whatever it
35:31 - contains so let's do exactly that
35:34 - down here let's make a class called pipe
35:37 - and then we have a transform for the
35:42 - pipe head so we have a feel to sort the
35:55 - pipette in the pipe body transform and
35:57 - we receive both of them in the
35:58 - constructor all right now also a public
36:02 - void move function and in here we're
36:06 - going to move the head and body exactly
36:08 - as previously
36:09 - so over here we were doing this and now
36:12 - we go down here and do the same thing
36:14 - for both the head and the body okay so
36:21 - far so good
36:22 - so we now have this nice simple class
36:29 - and now in here when we create a pipe we
36:33 - create the pipe head in a pipe body then
36:36 - in here we create a national pipe object
36:46 - so we now have an instance of our nice
36:49 - pipe class and now in here in our pipe
36:51 - list instead of stirring transforms
36:53 - let's store pipes so fix all these
36:58 - errors and here on the pipe list we no
37:00 - longer to add the head or the body but
37:03 - rather down here we do item list and add
37:05 - our pipe okay so this is working now we
37:09 - have on list of pipes and now in here on
37:11 - our Hema movement we cycle through all
37:14 - the pipes and instead of moving it
37:18 - directly we just call might not move
37:21 - all right that you do it what says to
37:25 - see if it's still working any of here we
37:27 - are and the pipe is still moving exactly
37:29 - the same as previously now one issue we
37:32 - have is regarding the cleaner now if we
37:34 - go into our scene view over here is the
37:37 - camera and there's the pipe continuing
37:39 - to move to the left as you can see it's
37:41 - going to continue moving towards
37:42 - infinity what we really want to do is
37:45 - clean up and destroy the pipe once it
37:46 - gets to a certain point right here on
37:48 - the edge of our screen so when it gets
37:50 - passed we wanted to be destroyed so it
37:51 - doesn't keep eating memory so we're here
37:54 - in our hmmm pipe movement have to remove
37:56 - it let's test if the pipe position is
37:58 - under a certain value so to get the
38:01 - position let's go into the pipe so here
38:03 - we're going to have a public float let's
38:05 - go get exposition and in here both of
38:09 - them are gonna be placed on the same X
38:11 - so either one is fine so let's just
38:13 - return the pipet transform that position
38:15 - dot X so we have a function which
38:18 - returns the pipe x position and now over
38:21 - here have to remove them we just need to
38:24 - test if the pipe dot get X position if
38:27 - it is under a certain value so to define
38:30 - that valve let's go up here to make
38:31 - another constant so project cons float
38:35 - let's call this the pipe destroy x
38:37 - position to see the position let's go
38:42 - into the editor over here we have our
38:45 - camera so let's see where that is so
38:49 - here it is the edge is on minus 90 now
38:51 - the way we set up our camera is going to
38:53 - depend on horizontally so in here if we
38:56 - had five by four it would be smaller so
38:58 - we need to make
38:59 - sure that we pick the value at the
39:00 - widest possible resolution so the why
39:03 - this is sixteen by nine so let's put it
39:05 - a bit on the edge so let's say minus a
39:07 - hundred so very here the pipe destroy
39:09 - exposition is on - 100 M so we can now
39:12 - go down here test if the position is
39:14 - under the destroy exposition then we
39:18 - want to destroy D pipe so let's make a
39:21 - function in there to do that so we
39:24 - probably boy call of destroy self any
39:27 - here this is going to destroy the pipe
39:29 - so we need to do is run on destroy both
39:31 - transforms so we destroy the pipe head
39:37 - and the body transforms game objects and
39:42 - now in here that's one we need to come
39:44 - type dot destroy self ok the pipes have
39:48 - been destroyed now we need to remove
39:49 - them from the list so in here if we try
39:51 - to remove it directly whilst inside a
39:53 - for each we're going to have an error so
39:55 - instead of a for each let's do a simple
39:57 - for okay we have a symbol for instead so
40:05 - now in here after we destroyed the pipe
40:07 - we remove the pipe from the list and
40:10 - then since we are modifying the list we
40:14 - need to make sure we don't skip an index
40:15 - so we need to do I - - if we didn't then
40:19 - we would skip the index whenever we
40:20 - destroy a pipe alright so all this code
40:23 - should be working we're handling our
40:25 - movement same as previously going
40:27 - through every single pipe we moved them
40:28 - then we check the x position if it's
40:31 - past a certain value so if it's
40:32 - off-screen then we destroy the pipe and
40:34 - remove it from the list let's see ok
40:38 - here we are let's look at the scene view
40:40 - and if there's the pipe there's the
40:42 - camera and the destroyed position is
40:44 - somewhere in here so let's wait to see
40:46 - it go going to the left when it gets
40:49 - there yep there you go the pipe has been
40:51 - correctly destroyed right great
40:53 - so we have our pipes being correctly
40:55 - cleaned up alright so now that we have
40:57 - pipe movement and cleanup work it's
40:59 - finally time to handle level generation
41:01 - so to generate their own level what we
41:03 - need to do is constantly spawn pipes we
41:06 - want them to be generated but not come
41:08 - random we want a level to start off easy
41:10 - and become increasingly more difficult
41:12 - so that means fewer pipes that start
41:14 - with larger gaps and as it goes forward
41:17 - more pipes with smaller gaps we already
41:20 - have the pipes being automatically
41:21 - removed so all we really need to think
41:23 - about is how to spawn them so here in
41:25 - the code the first thing we're going to
41:27 - need is some timer between each pipe
41:29 - spawn so over here and let's define our
41:31 - timer so a private float let's call this
41:34 - the pipe spawn
41:35 - timer then we also need a maximum so a
41:38 - proud float for the pipe spawn time
41:41 - remarks now here on awaking let's set
41:44 - the timer max let's put it at 0.5 so
41:49 - spawn a pipe every half a second now on
41:52 - our update let's call another function
41:54 - to handle spawning okay we have a
42:05 - function tamil are spawning now in here
42:07 - the first thing we do is decrease the
42:08 - timer so the pipe spawn timer we
42:11 - decrease it by time dump time then we
42:15 - check if it's under zero it's in there
42:22 - zero then it's time to spawn another
42:23 - pipe so the first thing we do is reset
42:25 - the timer so we increase it by the max
42:28 - and in here let's spawn a pipe so we're
42:31 - going to use the same function to create
42:33 - gap pipes and I mean here we need the
42:36 - gap line in the gap size we'll deal with
42:38 - that later but more importantly we need
42:40 - the x position so we need to know where
42:42 - we're going to spawn it so for the X we
42:44 - can use pretty much the opposite of what
42:46 - we did to destroy so in here let's make
42:48 - another constant and the pipe spawn x
42:51 - position and set of minus 100 so beyond
42:53 - plus 100 okay so that I need here when
42:57 - you create the pipes we use that okay so
43:00 - here we are creating a pipe gap right on
43:03 - the edge on the right side so let's test
43:05 - and see if we have a pipe being spawned
43:07 - every half a second okay here we are
43:09 - and yep exactly pipes are being spawned
43:11 - every half a second obviously they are
43:13 - moving too slow and spawning too fast
43:15 - but yep the code is working every pipe
43:17 - is being spawned with the exact correct
43:19 - gap and
43:20 - moving to the left so let's look at the
43:23 - scene in order to make sure they're
43:26 - being destroyed there you go they're
43:27 - being spawned out there at the edge of
43:29 - the screen and yep they get destroyed in
43:30 - there okay great so our basic spawning
43:33 - is working now we just need to modify
43:34 - the valleys for the speed the spawn
43:36 - timer and also the only the gap height
43:38 - and Suns
43:39 - so first the speed and let's increase it
43:42 - and also increase the spawn time and
43:46 - okay that is looking quite a bit more
43:48 - appropriate we have the primes being
43:49 - spawned at a nice decent rate alright
43:51 - good so here we have our pipes being
43:54 - spawned now let's handle the height and
43:56 - the gap size now for the height we're
43:59 - going to essentially just randomize it
44:01 - and for the gap size we're going to
44:03 - tighten it over time so let's make a
44:06 - feel for that
44:07 - a private float for the gap size this is
44:10 - the gap size that we're going to use the
44:11 - spawn so let's start off at 50 so it's
44:19 - art it is extremely wide and now in here
44:22 - when we are spawning our pipe let's use
44:25 - that capsize and now we need to know
44:27 - what the height should be now in here we
44:30 - cannot randomize fix values since it's
44:32 - going to be dependent on the gap size so
44:36 - let's make a float for the mean height
44:38 - or D come elated and the min height
44:40 - won't be the gap size multiplied by 0.5
44:43 - so the minimum height that we can spawn
44:46 - is gonna be half the gap size so right
44:48 - at the bottom so in this case with a gap
44:50 - of 50 the absolute minimum height will
44:53 - be 25 however even with that the gap
44:56 - will essentially touch the floor so
44:57 - let's add a mandatory minimum so a float
45:01 - for the height edge limit and let's say
45:04 - 10 F so it's not right at the bottom and
45:07 - for the height to come like the height
45:09 - was this nice limit so this should be a
45:13 - good minimum and now for the maximum
45:17 - first we start off the maximum at the
45:19 - total height over here we have the
45:22 - camera orthographic size and we know
45:25 - that the height of the camera is double
45:26 - the orthographic so a float for the
45:28 - total height will be the orthographic
45:30 - size x Qi
45:33 - so for our max height we start off at a
45:36 - total height and then we take away half
45:39 - the gap size so gap size times 0.5 and
45:43 - we also take away the height edge limit
45:47 - all right let you do it so we now have a
45:50 - nice minimum and maximum so for the
45:53 - height we just do a random range between
45:59 - the min height and the max height all
46:05 - right that should do it
46:06 - so let's see if our pipes now have a gap
46:08 - of 50 at random Heights okay okay here
46:13 - we are in yep as you can see they are
46:15 - moving down moving up so the height is
46:17 - random and they are not touching exactly
46:20 - on the edges so right now you can see
46:22 - the game is already quite nicely
46:24 - playable all right so the pipes are
46:26 - being spawned correctly the height is
46:28 - correctly calculated now all that's left
46:31 - to do is actually calculate a tightening
46:33 - gap so first just test out to make sure
46:36 - the code works with a small gaps and
46:38 - let's say 20 any of there we go there's
46:40 - one there one there and yep the height
46:42 - is indeed changing and 20 is already
46:44 - quite a bit difficult as you see I died
46:46 - and you know 20 is already very tough
46:49 - right great so everything is being
46:51 - correctly generated nice so now that we
46:54 - have our nice gap filled we can easily
46:55 - use it to increase our difficulty over
46:57 - time so at STARTTLS we start off at 50
47:00 - nice and easy
47:01 - and now to increase our difficulty let's
47:04 - keep things nice and clean so define an
47:07 - informal T so in here if Tony Kanaan for
47:10 - need difficulty we're going to have easi
47:13 - then medium hard and finally impossible
47:17 - okay now down here let's make a function
47:20 - to get the current difficulty
47:26 - so we're going to return the difficulty
47:28 - now we need a way to keep track of when
47:31 - we should increase the difficulty so
47:33 - let's do it based on the number of pipes
47:36 - spawned so in here let's have a present
47:38 - for the pipes spawned and down here when
47:42 - we have the create gap pipes in here
47:46 - let's increase the pipe spawned and on
47:48 - the gap deferral let's just do some very
47:50 - simple ifs okay so you have a function
47:59 - that returns the current difficulty
48:00 - based on some preset values now let's
48:03 - make a function to actually set the
48:04 - difficulty values so a private void for
48:07 - our set difficulty this what is going to
48:10 - set all the various fields related to
48:12 - difficulty right now the only film we're
48:19 - using is for the gap size so uneasy we
48:23 - start off with the gap size of 50 okay
48:31 - so in here we are shrinking the gap size
48:33 - every time we increase our difficulty
48:35 - now over here on our awake instead of
48:38 - setting the gap size originally we call
48:40 - set difficulty and we start off at easy
48:42 - all right
48:44 - and then finally when we actually spawn
48:46 - our pipes so here we are we are
48:48 - increasing the file spawn and let's
48:50 - update our difficulty so set difficulty
48:52 - and get the different so whenever we
48:55 - spawn a pipe we update the difficulty
48:57 - right so that's pretty much it the more
49:00 - pipes respond the harder the difficulty
49:01 - and the smaller the gap so let's see if
49:04 - that happens every 10 pipes we are
49:06 - increasing let's see okay here we are
49:08 - and let's see and they're all starting
49:11 - off nice and small nice and easy and now
49:14 - when we get to number 10 the pipe gap
49:16 - should become smaller and there you go
49:18 - this one is quite a bit smaller than the
49:20 - previous one and now it keeps going and
49:23 - yep now it's definitely getting harder
49:25 - and yep
49:27 - all of them are quite a bit more
49:29 - difficulty quite a bit small gaps and
49:32 - there you go that one is already
49:33 - extremely small and in here I couldn't
49:35 - make it alright great so the difficulty
49:38 - is working based on the gaps
49:39 - but we can also modify the spawn timer
49:44 - so you could actually start spawning
49:46 - over here on the 50 okay so here we have
50:02 - our values and we need to do is tweak
50:04 - these values to get the game easier or
50:05 - harder so just like that we have our
50:08 - difficulty increasing over time so here
50:11 - is the game so far in yep it doesn't
50:13 - look quite nice however one issue is
50:15 - that all of that is just happening in
50:17 - the background
50:18 - right now there is no way to actually
50:19 - visualize any progress over here I have
50:22 - no idea how many times I have passed so
50:24 - we're going to deal with that by adding
50:26 - a simple UI element don't let us know
50:28 - how many pipes we have passed we're
50:30 - going to have a score window so let's
50:32 - begin by making it over here in the
50:34 - editor now in order to make a score
50:36 - window we need to setup the UI with a
50:38 - canvas so let's go here to our game
50:40 - handler game object in order to keep
50:42 - things nice and organized and in here
50:44 - let's make a new empty game object let's
50:46 - call this TTY now you can leave it in
50:49 - any position you want but personally I
50:51 - don't like to put it to the side so
50:56 - there it is so you have the main scene
50:58 - here and the UI in here just easier to
51:00 - keep track of things now inside the UI
51:02 - let's create a new canvas so we're here
51:05 - to UI a new canvas here is the canvas
51:08 - and as you can see it automatically
51:09 - create the event system let's keep
51:11 - things organized and drag it in there
51:13 - okay now inside the canvas let's create
51:15 - a UI images show we can see it there you
51:19 - go so here's our UI being displayed now
51:22 - let's set up our cannabis in here
51:25 - instead of overlay let's select camera
51:27 - this allows you to assign a camera that
51:29 - won't display the UI which is what we're
51:31 - going to do so in here we create a new
51:33 - camera let's call this the UI
51:35 - camera so this is the camera that is
51:37 - going to display our UI so here in the
51:39 - canvas just drag our camera onto it and
51:41 - just like that okay this is now our UI
51:43 - and as you can see in the game we can
51:45 - still see it okay so these are any
51:47 - camera settings very similar just don't
51:48 - clear orthographic and with the size of
51:50 - a hundred and here on the canvas for
51:53 - skill mode let's go with scale with
51:55 - screen size which resize UI elements to
51:58 - fit the screen and resolution and in
52:00 - here the reference resolution is the
52:02 - main resolution for your UI so if the
52:05 - current resolution is smaller don't be
52:06 - scaled down and bigger don't be scale up
52:08 - so this depends on your platform but for
52:10 - example for desktop games I'd like to
52:12 - put it in 720p so very simple 1280 by
52:15 - 720
52:16 - then let's fully match by height which
52:19 - means that elements won't be resized if
52:21 - the height of our resolution changes so
52:23 - here's the game window and as you can
52:24 - see the square has that size and if I
52:27 - shift it up so as you can see it scales
52:29 - with the vertical size however if I
52:32 - change resolution to change the
52:33 - horizontal size as you can see the
52:35 - square does not change so this is what
52:38 - it means to match only just with the
52:39 - height and the reference pixels leave it
52:42 - at a hundred all right so this is our
52:44 - very simple UI correctly setup now
52:46 - inside our canvas where we can put any
52:48 - UI objects so let's make a new game
52:51 - object this will be our score window
52:53 - let's anchor our score to the right side
52:56 - and inside let's put up a UI text for
53:02 - the current score called as the score
53:04 - text alright here's our nice text object
53:07 - to any of there you go there's in our
53:08 - screen on the court okay now let's do
53:11 - the script in order to update our text
53:13 - object so in here make a new script this
53:16 - won't be our score window drag it on to
53:19 - the game object now in here let's first
53:21 - go into our prayers Boyd awake in order
53:24 - to grab the reference to the text field
53:32 - so we have our reference and now we need
53:35 - to deal with the score now for the score
53:37 - let's go into our level and find a way
53:39 - to return the pipe spawned so we make a
53:43 - public int get pipes spawn and we simply
53:48 - return the pipe spawn however in order
53:52 - to access this function we need to
53:53 - access the in level instance so let's
53:56 - make a static function to return the
53:57 - instance so up here so we have a static
54:03 - instance and we set it on our awake and
54:07 - then we have a static function we return
54:13 - the instance and now we can go back in
54:15 - the score window make our private void
54:18 - update and in here we set the score text
54:22 - text go into the in level class get the
54:26 - instance and get the pipe spawn alright
54:33 - so that's it we now have our nice score
54:35 - window asking the level for how many
54:37 - pipes have been spawned so let's see
54:39 - this working any of there it is one
54:42 - pipes one two pipes three four and so on
54:44 - all right great
54:45 - so as you can see the counter is
54:47 - correctly increasing as it's so posted
54:49 - right now one obvious issue we have is
54:53 - that the score is meant to increase when
54:54 - the bird passes a pipe and not when the
54:56 - pipe is spun so let's do that let's go
54:59 - to where the pipes are being spawned
55:01 - over here in the unlevel now we don't
55:04 - want to use the pipe spawned count but
55:07 - rather we want the score to increase
55:08 - based on when the pipes move so when the
55:11 - pipe gets passed the bird now in this
55:13 - case we are moving the pipes and not the
55:14 - bird so we need to test if the pipe is
55:17 - to the right of the bird then we move
55:19 - the pipe and then we test if it's to the
55:21 - left of the bird so before we do our
55:23 - movement let's define a bowl for is to
55:28 - the right of burned and this won't be if
55:32 - the pipe dot get position if the
55:35 - position into the pipe is to the right
55:37 - of the bird position it's not for the
55:39 - burn let's do another
55:49 - the bird is on zero okay then here we
55:52 - are to write the bird if the pipe X is
55:55 - to the right of the vertex position then
55:58 - we move the pipe then we test if the
56:01 - bird was to the right and is no longer
56:04 - to the right so less than or equal to
56:09 - the x position so we're here the pipe
56:15 - was to the right of the bird and now it
56:17 - no longer is so it's in here that we
56:19 - have successfully passed me bird so we
56:21 - have the logic for detecting it now we
56:23 - just need to handle the score so let's
56:25 - go up here
56:26 - make a private end for the pipes pass
56:31 - count and all we do is increase it in
56:38 - here five pass the bird so we increase
56:40 - it all right now we need a function to
56:42 - return this value so the same thing we
56:44 - did previously so here we have a
56:51 - function to get that value and now in
56:52 - the score window instead of getting the
56:54 - previous one we get the pipes passed all
56:57 - right that should do it
56:57 - let's test okay so here we are sir off
57:00 - at zero and when we pass this and yep
57:02 - the score increased and it looks nice
57:04 - although as you can see we have a nice
57:06 - error it's increasing by two every
57:08 - single time so 12 14 16 and so on the
57:11 - reason is because we have two pipes so
57:14 - we are passing two pipes every time we
57:15 - pass one gap so we want to calculate the
57:18 - gaps and not necessarily the pipes let's
57:20 - sort that so this in here is that we
57:23 - have two pipes per gap so one way we can
57:25 - solve this is very similarly doing the
57:28 - score count on a specific type of pipe
57:30 - either the top pipe or the bottom pile
57:32 - so that means that we need the pipe to
57:34 - know if it's a top or a bottom so in
57:37 - here on the gray pipe function we create
57:39 - either on the bottom or on the top so
57:42 - when we create a pipe let's pass in the
57:44 - same ball create bottom
57:50 - so in here a private ball for the crepe
57:53 - bottom and we receive it okay so now we
57:57 - know if this pipe is a bottom or a top
58:00 - now here let's just make a ball to
58:02 - return that and let's rename this to a
58:06 - more appropriate name okay so now we can
58:14 - use this function in order to test our
58:15 - scoring logic so I'm doing here we test
58:19 - if it's the right amount and left and
58:22 - the pipe is a bottom pipe
58:25 - if it is then we test for the score if
58:27 - not then we ignore it right so now we
58:30 - should have fixed our problem of
58:32 - increasing the score by two let's see
58:34 - okay here we are let's pass this one and
58:36 - if there you go increased by one two
58:39 - three and so on okay great
58:41 - so our code is working and everything is
58:43 - increasing exactly as intended all right
58:46 - so our logic is working and the scoring
58:48 - is working it's not with the basic sword
58:51 - let's see on with making a game over
58:52 - scenario right now over here when the
58:55 - bird hits a pipe we get a nice pump up
58:57 - but nothing actually happens everything
58:59 - keeps moving and there's no game over
59:01 - screen I don't so we are detecting the
59:03 - hits but not doing anything
59:05 - first let's stop the bird when we detect
59:08 - bird death so let's go to our bird class
59:10 - so we are taking birth death over here
59:13 - on our trigger enter now the bird is
59:16 - being controlled using physics so we can
59:18 - simply stop them by just going into the
59:20 - bird rigidbody2d in order to set the
59:23 - body type to body type dot static so
59:28 - this means exactly what it says the bird
59:30 - won't be completely static so let's see
59:32 - okay here we are now let's hit a pipe
59:34 - and see any of there you go hit the pipe
59:36 - and the bird no longer moves the bird
59:38 - has come only static and I click and
59:39 - nothing happens okay great now obviously
59:42 - as you can see the pipes are still being
59:43 - spawned and moving so let's stop that
59:45 - now in order to stop it we need over
59:48 - here the unlevel class to know when the
59:49 - bird has died so in order to communicate
59:52 - that to the level class let's go into
59:54 - the bird to add an event
59:58 - so we're going to have a public event
60:00 - and call it Ondine so the burden on fire
60:04 - this event when he dies so let's go in
60:06 - here here we have the birth death so we
60:08 - simply trigger the event all right
60:14 - that's it for firing our event now in
60:17 - order to subscribe to the event as you
60:18 - can see this is not static so we need an
60:20 - instance of our birth class so let's
60:22 - make a static instance the same we did
60:24 - for the level so you have a static
60:33 - instance that we set on a week then we
60:34 - have a function to get a static instance
60:36 - and now we can go into our level class
60:38 - and over here on our start we can go
60:42 - into the bird get the instance and
60:44 - subscribe to the on bird died event so
60:54 - here we have the function to test when
60:55 - the burden has died now let's just make
60:57 - sure that this code is working so
60:59 - instead of putting the pop-up in here
61:01 - let's spawn the pop-up on the unlevel
61:03 - make sure that this code is running
61:09 - so let's see the pop up when we hit the
61:12 - pipe and if there you go there's a nice
61:14 - pop up in the bar top okay great
61:16 - so we have this event being correctly
61:19 - fired now that we have that that means
61:21 - we know in our level class when the bird
61:24 - has died so we can use that to stop
61:26 - moving and spawning the pipes so let's
61:29 - go up here and keep things nice and
61:31 - clean so we make a private in-home for
61:33 - the current state and the possible
61:37 - states are either plain or the bird is
61:40 - dead and also store the current state
61:46 - now if we're here on a way preset is the
61:49 - start so starting state lights are off
61:52 - as plain then here on our update we're
61:56 - only going to have a movement and
61:57 - spawning if the current state is state
62:00 - that plane so if it's not playing we do
62:04 - nothing and finally in here when we have
62:07 - the bird died we simply modify the state
62:10 - and set it to state that bird death
62:12 - alright that should do it so we're here
62:15 - on the bird class we are not looking for
62:17 - the physics so we capture the trigger
62:19 - enter when we hit a Collider when we do
62:22 - we fire this event that the unlevel
62:24 - class is listening on this event which
62:26 - fires this function which then modify
62:28 - the state and if the state is per dead
62:31 - then of this movement then spawning no
62:33 - longer runs so let's see if everything
62:35 - stops the second we hit a pipe okay here
62:38 - we are still moving let's hit that pipe
62:40 - any of there you go everything stopped
62:42 - the bird stopped and level stopped the
62:43 - pipe stopped everything started awesome
62:45 - so we have pretty much a fully
62:47 - functioning game over state the bird and
62:49 - the pipes all stop now one of the main
62:51 - features of flappy bird is a quick
62:53 - restart and the way we built our game
62:56 - actually makes that extremely simple all
62:57 - we need to do is reload this current
62:59 - scene and we can easily start over so
63:01 - we're here when the bird has died
63:03 - let's just restart automatically
63:09 - in order to restart with a small delay
63:11 - let's use the function timer from the
63:14 - code monkey Tony's this lets is easily
63:17 - trigger an action after some time so
63:20 - we're going to trigger an action after
63:23 - one second and that action is going to
63:30 - be extremely simple all we need to do is
63:32 - reload the current scene all right that
63:40 - should do it so when the bird dies this
63:43 - code runs which creates a function timer
63:45 - which won't trigger this action after
63:46 - one second which will reload the current
63:48 - scene so let's try it okay move forward
63:52 - now let's hit the top pipe and there you
63:54 - go everything's stopped and after one
63:55 - second there you go everything starts
63:57 - over so hit this one and yep we got a
63:59 - nice restart and let's increase the
64:01 - score count so now you got a score of 1
64:03 - to hit this one and they're going after
64:06 - one second reloads and everything is
64:07 - back to normal right awesome so far
64:10 - everything is working very nicely
64:12 - however when we start the game it's
64:14 - quite daring to start immediately now
64:16 - let's make it so that the game doesn't
64:18 - start until the player does a first jump
64:20 - that means we need to stop spawning
64:22 - pipes and moving the bird so first let's
64:25 - do it on a bird over here to stop the
64:28 - movement we can do the same thing that
64:29 - we did over here on the death so we set
64:32 - the rigidbody to be static so here on
64:35 - the weight that's what we said now let's
64:37 - also store a state in our bird the
64:42 - possible states are waiting to start
64:44 - then we have plain and dead okay now on
64:51 - our update we do a switch on the current
64:53 - state
64:59 - all right so case we are playing we do
65:01 - the same as previously and if we are
65:04 - waiting to start we also do the same
65:06 - thing so we listen to the same input we
65:08 - cause a jump and then we modify the
65:11 - state to be state at play
65:13 - and finally we change the rigidbody back
65:17 - into being dynamic okay so that you do
65:22 - it show the bird should start off as
65:24 - static then when we press spacebar for
65:27 - the first time we go into playing
65:28 - everything goes back to dynamic and
65:30 - everything continues so let's see if the
65:32 - bird waits for our input okay here we
65:34 - are and the bird is indeed stopped and
65:36 - when I press there you go everything
65:38 - starts and now everything's work
65:39 - normally gravity and so on okay right
65:42 - now as he saw the pipes were still
65:44 - moving while the bird was stopped so
65:45 - let's sort that over here on the eleven
65:47 - class let's add another state so first
65:50 - we count waiting to start now let's use
65:54 - the same pattern with it for the
65:56 - birth-death so on the bird we make an
65:58 - event let's call this on started playing
66:07 - and we fire the event in here
66:17 - okay so we have this event and now back
66:19 - into the unlevel over here and let's do
66:22 - the same thing go into the word get the
66:24 - instance and subscribe to the on star
66:26 - plane when we start playing only to do
66:32 - is set the current state to be state
66:35 - that plane and on awake instead of
66:39 - starting on playing we start on waiting
66:41 - to start and that's it
66:43 - let's test okay here we are and nothing
66:46 - is moving score zero birds not moving no
66:49 - pipes nothing awesome now I click and
66:51 - there you go and everything starts
66:53 - exactly as in tennis so the bird is now
66:55 - moving pipes are spawning moving and so
66:56 - on now let's hit a pipe and after one
66:59 - second reloads to start and again
67:00 - nothing's moving click and we can start
67:02 - playing all over again and yep awesome
67:05 - great now let's replace our automatic
67:08 - reset with a more appropriate game over
67:10 - window so for that here in the editor
67:13 - let's make a new game object this will
67:15 - be the game over window
67:50 - okay so we have a very simple game over
67:53 - window we just have a background some
68:00 - text and the score text now let's make a
68:02 - button to retry so for that first we
68:05 - make a game object let's call this the
68:08 - retry button then inside we make an
68:11 - image for the background and then also
68:16 - some text say we try okay so now in the
68:28 - button game object we can add the button
68:30 - UI component this is from the code
68:34 - monkey Tonys it save nice and simple
68:36 - component that makes button handling
68:37 - very easy so in here for example we can
68:40 - easily set the button to have a
68:41 - mouse-over color so when we pass the
68:44 - mouse over the button the color won't
68:45 - change right so that's it for the editor
68:48 - now let's make a script to handle it so
68:50 - a new c-sharp script this will be our
68:53 - game over window drag it onto the window
69:01 - now in here the same we did with the
69:03 - score we know let's grab a reference to
69:05 - our text object
69:14 - okay we have the text object now let's
69:17 - also set the button click action so here
69:28 - we have the action that happens when I
69:29 - click on the button let's do the same
69:31 - thing for reloading the scene so over
69:34 - here we have this code we are loading
69:35 - the current scene that some we're going
69:36 - to do and get rid of this from here and
69:39 - just put it in here alright that's it
69:43 - the button should be working now for the
69:46 - score text let's listen to the bird ID
69:49 - event so a private to its start and on
69:52 - cert we go into the bird get instance
69:54 - and subscribe to the on that event when
70:01 - the bird dies this function will be
70:02 - calmed so we have take a score text and
70:05 - text won't be the same thing that we did
70:07 - here on the open window so we get the
70:11 - instance get the fives past count all
70:14 - right that should be updating the text
70:15 - now one final thing is we only want this
70:18 - window to show when the bird actually
70:20 - dies so it's made two simple functions
70:26 - so we have a show and hide function the
70:29 - assembly set the game object to either
70:31 - active or inactive so that it's visible
70:33 - or invisible now on a wake we start off
70:36 - as hidden so we hide it and when we get
70:39 - the bird that we show it alright that
70:43 - should do it
70:43 - the window starts off hidden it shows
70:45 - when the bird dies it updates see text
70:47 - and only we try button we are reloading
70:49 - the current scene so let's see all of
70:51 - that in action okay so here we are and
70:54 - everything starts off stopped let's
70:55 - start jumping and if there you so far so
70:58 - good we have five swings pond and the
70:59 - bird moving now let's hit a pipe and if
71:03 - we're dead and there's the window
71:05 - popping up and indeed we have a score
71:07 - for score four and over here we have our
71:09 - nice button as you can see already has a
71:11 - very nice mouse over effect and when we
71:14 - click on it there you go we are back at
71:16 - the beginning and the scene reloads
71:18 - alright awesome okay so we have pretty
71:21 - much on the main design of our game
71:22 - working we start off with the bird and
71:24 - the
71:24 - completely stopped once we do our first
71:27 - jump everything starts the bird starts
71:28 - jumping the pipe starts bombing over
71:30 - time the pipes get harder as the gaps
71:33 - grow smaller and smaller and finally
71:36 - when I hit a pipe there you go we have a
71:38 - nice game over a window showing our
71:40 - score and having a we try button so we
71:42 - can click and start over okay so
71:45 - everything is great so far we have the
71:46 - basic design working now let's keep
71:48 - going
71:49 - first let's see only the unloading so
71:52 - right now everything works but in this
71:53 - slightly Genki way so when I hit and I
71:56 - click retry it immediately loads just
71:58 - the target seen since the seen loads pre
72:01 - fast this isn't really an issue but it
72:03 - would still be better to have a proper
72:05 - loading screen also our code in here on
72:07 - the game over window we are directly
72:09 - interfacing with the scene manager and
72:10 - using a string to load the target scene
72:13 - which is also not ideal so let's make a
72:15 - proper loading class so we're here in
72:17 - our project files let's make an easy
72:19 - sharp script
72:20 - this will be our loader let's make this
72:23 - a static class to make sure that we
72:25 - don't instantiate it right here let's
72:29 - start off with a public static void load
72:31 - function and now in here instead of
72:34 - receiving a string for the scene that we
72:36 - want load and let's make it nice and new
72:38 - so in here a public you noon call it
72:40 - scene and in here we can fill it up with
72:42 - all our scenes so right now we just have
72:44 - the game scene and on the load we
72:47 - receive a scene as a parameter now for
72:50 - the moment let's do the same thing we
72:51 - did in here
72:59 - so use the scene manager to load scene
73:01 - and instead of a string we use our scene
73:04 - in them okay great this code is now much
73:07 - more clean and now back in the game over
73:10 - window in here instead of that code
73:12 - interfacing directly with the scene
73:14 - manager we now go into the unloaded
73:15 - class in written load and then we pass
73:18 - in a target team okay so everything
73:22 - should still be working exactly the same
73:24 - but the code is now much cleaner let's
73:26 - see okay here we are
73:28 - let's move and die okay there's a game
73:31 - over window hit retry and there you go
73:33 - everything some words say that I'm home
73:34 - the same clean with trolley and
73:36 - everything loads back up okay awesome
73:39 - so now let's deal with the potential
73:41 - issue of our loading screen if they seem
73:44 - to have longer term load then we would
73:45 - essentially have a freeze frame while
73:47 - the scene gets loaded which would make
73:49 - the game unresponsive which is never a
73:51 - good thing so we should really have a
73:52 - simple loading scene so we're here on
73:55 - our scene so let's create a new scene
73:57 - this will be the unloading scene and
73:59 - then here extremely simple we just make
74:01 - a new UI canvas let's add a new UI text
74:06 - just saying loading a method we have an
74:17 - extremely simple loading team so what we
74:19 - want is to first move it into this scene
74:21 - and then we'll load our target scene
74:23 - that way the player knows that the game
74:25 - is loading instead of thinking it might
74:26 - have crashed since the screen is no
74:28 - longer frozen and in here since we made
74:30 - a proper unloader class we don't need to
74:32 - deal with anything over here on the
74:34 - email window we still count the unloader
74:36 - and now in here let's handle our loading
74:38 - scene so the first we have a scene into
74:41 - our enemy so we have the unloading scene
74:43 - and in here first we do see manager can
74:47 - load the scene when the loading scene
74:51 - and then we'll know the target scene
74:53 - however if we do it like this there
74:56 - won't be an issue so let's see it in
74:58 - order to load very scenes let's go into
75:00 - our build settings and in here make sure
75:02 - we have the unloading scene into our
75:04 - scenes in our bill so here we are again
75:06 - let's try dying and seeing now let's see
75:08 - if we see our moving scene and no
75:10 - we did not see it the issue in here is
75:12 - that we're unloading first the unloading
75:14 - scene and then the target scene exactly
75:16 - one segment after the other if there is
75:18 - no update between them then the screen
75:20 - won't actually refresh so we need to
75:22 - make sure that we run an update before
75:24 - we unload our target scene so we can do
75:26 - that with a very simple script let's
75:29 - make a new c-sharp script this won't be
75:31 - our another update since it won't wait
75:34 - for the first update and here just add
75:36 - it to an empty game object okay let's
75:40 - see the code now in here we just do on
75:43 - our private void update in here and
75:46 - let's just call a function on loader to
75:48 - let it know that we have fired an update
75:50 - and we can unload the target scene so we
75:53 - go into the loader and confection let's
75:55 - say load target scene okay let's make
76:00 - this function over here all we need to
76:06 - do is to store our targeting and in here
76:16 - we load our target team all right that
76:21 - should do it
76:21 - so we should now be able to see the
76:22 - loading scene show up before our target
76:24 - scene in here we're calling load we
76:27 - first moved in loading scene then that
76:29 - loads the unloading scene which runs
76:30 - this script and on the first update it
76:32 - will run this code and this code won't
76:35 - load the final target scene so we should
76:37 - now be able to see it in loading scene
76:38 - showing up okay here we are let's move
76:41 - now let's hit a pipe and the after we
76:44 - honor hit retry any up there you go
76:46 - there was the unloading scene right
76:47 - there
76:48 - now since the final scene load so
76:50 - quickly you can't really see the
76:51 - benefits of this but just imagine you
76:53 - had a lot more stuff into our game here
76:55 - and the game scene would take longer to
76:56 - load previously it would be stuck
76:59 - showing the game over window and being
77:00 - completely unresponsive whereas now it
77:03 - would show the unloading scene and some
77:04 - of the final scene was ready so with our
77:06 - load that are nice and working let's
77:07 - make a main menu we want a very simple
77:10 - main menu where we can just start the
77:12 - game or quit playing now in order to
77:14 - create the main menu we could go in here
77:16 - and create a new scene then we would set
77:18 - up the camera and the UI all over again
77:20 - or let's simply go in here and
77:23 - our game scene so press control-d in
77:25 - order to duplicate let's say this is the
77:27 - main menu all right so now in here and
77:30 - let's get rid of all the things related
77:32 - to our game scene and leave only the
77:34 - main camera and UI setup
77:48 - okay so here is our set up scene now in
77:52 - the canvas let's make our main menu so
77:54 - we make a new game object what's going
77:58 - on this the main menu let's stretch it
78:01 - to occupy everything now inside we're
78:06 - going to have just two buttons when to
78:08 - play and when to quit so let's make the
78:11 - buttons the example like we did with the
78:12 - game over retry button so we can
78:14 - actually go there in order to grab it so
78:17 - here's the retry button just copy it and
78:19 - paste it in here
78:50 - okay so here we have our very basic main
78:53 - menu with two very simple buttons now
78:55 - let's make a script to control this so
78:58 - new script for our main menu window and
79:03 - just right in there okay now in here
79:06 - let's go into our price going away to
79:10 - grab a reference to the play button okay
79:20 - so in here on the click function for the
79:21 - play all we need to do is load our game
79:23 - scene so we're going to do the exact
79:25 - same thing with it on the game over
79:26 - window so just load the game scene so
79:29 - copy that yep that's it so the only
79:32 - button should be working again back here
79:35 - in the game we have to remember to go
79:36 - into our build settings in order to add
79:38 - our open scene there you go so we now
79:39 - have our three scenes in our build okay
79:42 - and if we start okay here it is there's
79:45 - a play button click it any up there you
79:47 - go we are now playing okay nice now for
79:49 - the quit button over here in order to
79:55 - quit the desktop all we need to do is
79:57 - call application quit now we can't
80:01 - actually test this right now since if we
80:03 - run and over here we click on the quit
80:06 - button nothing actually happens since
80:07 - this line doesn't run in the editor but
80:09 - if we build our executable it would
80:11 - actually quit our application so just
80:14 - like that we have a fully functioning
80:15 - main menu we start off in here hit play
80:17 - and we are back to playing and we can
80:21 - play and now we can die and go back and
80:23 - retry and nice okay great so now that
80:26 - this is working on the on the GAMEOVER
80:28 - window let's add another button to go
80:30 - back to the main menu so let's go into
80:32 - the game scene over here duplicate the
80:35 - retry button come with the main menu
80:37 - button
80:48 - okay that's our button now in the game
80:51 - over in the code over here we have the
80:53 - code for the retry button and now the
80:54 - code for the main menu button and all we
80:58 - need to do is load our main menu scene
81:00 - so in order to load it all we need to do
81:02 - is add it into our scene and so the main
81:05 - menu and that's it we can now easily
81:08 - load into the main menu
81:09 - let's try okay here we are on the main
81:13 - menu hit play and there you go we are
81:15 - now playing now hit a pipe there's the
81:18 - game over window with a retry and main
81:20 - menu click on main menu and yup we are
81:22 - back on the main menu so we can now quit
81:24 - or play
81:24 - yep okay awesome so we can now start at
81:27 - the main menu begin playing go back to
81:29 - the main menu and quit the game so far
81:32 - our game is completely muted so let's
81:34 - add some nice sounds over here in the
81:36 - project files have had the sounds folder
81:38 - with a bunch of different sounds so one
81:41 - for the party on some button sounds
81:43 - blues and a Scorza the sound effects
81:46 - will create a chip town which is a great
81:48 - free tool to create simple sounds that
81:49 - is an expanded version of another
81:51 - excellent tool which was SFX R so let's
81:54 - create a class to help us play our
81:56 - sounds in here a new C sharp script
81:58 - this will be our sound manager this
82:02 - class won't be responsible for playing
82:03 - all of our sounds so for starters let's
82:06 - make it static so we don't accidentally
82:08 - Senshi ate it now here let's first make
82:13 - a very simple function to play a simple
82:15 - sound so a public static void play sound
82:20 - in here in order to play our sound let's
82:23 - first create a game object
82:28 - we're going to create it with a audio
82:31 - source component now in order to play
82:41 - something we can go into audio source
82:43 - and call play one shot this takes an
82:46 - audio clip and place it once so that
82:49 - means we need a reference for our audio
82:51 - clip so to grab our reference let's add
82:53 - it into our game assets class in here
82:56 - let's just add a public audio clip and
82:58 - let's start with a bird jump okay now
83:02 - back in the same manner let's start
83:04 - playing this one so going to the game
83:05 - assets get the instance and play our
83:09 - bird job alright so this is very simple
83:11 - now to play our song let's go into the
83:13 - bird class in here let's go into our
83:16 - bird jump so here is our jump function
83:18 - and in here we can actually see some
83:21 - manager to play our sound okay that
83:24 - should do it for testing let's try here
83:26 - in the editor and let's go into our game
83:28 - assets and there's our field for our
83:30 - audio clip and let's drag the bird jump
83:32 - okay let's see here we are and when I
83:35 - click yep there you go we got a nice
83:38 - jump sound every time the bird jumps
83:40 - okay great so we can play a simple sound
83:44 - now let's change our code in order to be
83:46 - able to play different sounds so over
83:49 - here on the Sound Manager let's create a
83:51 - new to keep track of all our possible
83:53 - sounds okay we have our sounds and now
84:02 - in this function we receive a sound and
84:06 - now all we need to know is the audio
84:07 - clip that matches this sound so let's go
84:10 - into the game assets in here let's
84:13 - create a class to hold both an audio
84:14 - clip and a sound so a public class let's
84:20 - call it sound audio clip
84:24 - in here we have a public sound manager
84:28 - that sound and a public audio clip I do
84:33 - now in order to see this class in the
84:35 - editor we need to have the serum Liza
84:37 - Vaughn attribute okay so now instead of
84:40 - having references to audio clips we are
84:42 - going to have an array of sound audio
84:44 - clip so now we can go see how this looks
84:50 - in the editor and he appears our game
84:52 - assets with our sound audio clip array
84:54 - so in here and let's fill in all of
84:56 - these values as you can see each element
84:58 - has a sound so that one for the bird Jam
85:01 - when we drag the audio clip and the same
85:03 - thing for all the others okay we have
85:05 - filmed our array with their matching
85:07 - sound a noon and our audio clip now over
85:11 - here what we need to do is identify the
85:13 - audio clip that matches this sound so
85:15 - let's make a function to do just that
85:35 - okay here's our simple function we just
85:38 - do a very simple for each so I go
85:40 - through the entire array see if the
85:42 - sound matches the sound that we're
85:43 - looking for if so return the other clip
85:45 - and here we are supposed to always be
85:48 - able to match a sound with an audio clip
85:49 - in case that doesn't happen let's do a
85:51 - analog error to say that sound was not
85:53 - found and we returned no okay so now we
85:56 - need to do is go up here in order to get
85:58 - the audio clip for this sound okay so
86:02 - this function should be working now
86:05 - let's add our various sound so for Sony
86:07 - burn here on the words on the play sound
86:09 - we pass in the sound of bird jump when
86:14 - the bird dies and let's pass in the
86:16 - loose sound and over here on the unlevel
86:22 - when we increase our current score in
86:33 - here we just play the sound for the
86:34 - score
86:35 - okay our three sounds should now be
86:37 - playable let's see okay here we are
86:39 - everything is quiet now click and you
86:42 - have to jump sound works now let's see
86:43 - the score yep there's a score one two
86:47 - three four okay great
86:49 - now let's see the game over sound yep
86:51 - there you go our nice game over sound
86:53 - they're gonna hit retry again everything
86:55 - song jumps and that's right and game
86:57 - over okay awesome alright so as you can
87:00 - see we have all of our sounds correctly
87:02 - working now let's add the button sounds
87:04 - in order to another button sounds we're
87:07 - going to use something really cool an
87:08 - extension method so let's go into the
87:10 - sound manager and in here we're going to
87:13 - make a function to add button sounds
87:15 - which won't be an extension method of
87:16 - the button UI class so here a public
87:19 - static void let's call it add button
87:22 - sounds and now in order to make this an
87:24 - extension method we add this button UI
87:27 - prior but why
87:32 - the this keyword means that this is an
87:34 - extension method so we're essentially
87:36 - adding the Add button sounds method to
87:38 - the button ey class without actually
87:40 - modifying the code on the button UI
87:42 - class this is a great way for adding
87:44 - extra functionality to a previously
87:46 - written class so in order to use this
87:48 - function we can go for example on the
87:50 - GAMEOVER window and here we have both
87:53 - our buttons so we can simply access the
87:55 - button ey and call Add button sounds as
87:58 - you can see it says that it is an
88:00 - extension method so even though we're
88:02 - calling this method which appears to be
88:04 - called on the button UI this method
88:06 - actually exists in here so now here we
88:10 - can add these sounds to this button okay
88:22 - so we add on to this button UI a
88:24 - function on the mouse over to play the
88:26 - button over and on the mouse click to
88:28 - play the button click alright so let's
88:30 - test and see if our game over window now
88:32 - has sounds ok here we are now let's died
88:40 - and see the game over window yep there
88:42 - you go now let's pass the mouse yep
88:44 - there you go there's our nice sound not
88:46 - this one yep we are or two nice sounds
88:48 - so you can point and there you go a nice
88:50 - button sound now let's add the sound to
88:52 - these ones as well all we need is here
88:57 - on the main menu window and call Add
88:59 - button sounds and everything should be
89:00 - working here we are in the main menu and
89:04 - if we pass the mouse and we have a panel
89:07 - issue the issue here is because the game
89:10 - assets object does not exist in the main
89:11 - menu scene so we're trying to access a
89:14 - reference but there's no reference to be
89:15 - accessed so in solution to this problem
89:17 - is to go in here grab the game assets
89:20 - and making a prefab and I'll back in the
89:23 - main menu and we drag an instance of
89:25 - that same prefab now if we try we should
89:28 - be able to see that we have our
89:29 - references in here mighty pass if there
89:32 - you go
89:33 - that all the buttons work great okay
89:35 - awesome so we have added button sounds
89:37 - as well as fixed a simple problem
89:40 - alright so we are valid sound to our
89:42 - game we created the some integer class
89:45 - to be responsible for all sounds and the
89:47 - other scripts called the play sound to
89:49 - play the sounds when needed so now that
89:51 - we have this working let's deal with
89:53 - saving a high score now we are already
89:55 - calculating the score and displaying it
89:57 - in the UI so let's begin by seeing how
89:59 - we can store some data in order to do
90:02 - that we're going to use player preps
90:03 - this is the simplest way to store
90:05 - persistent data in unity so we're going
90:08 - to use player preps dot set int in order
90:12 - to store the highest score so in here
90:14 - let's test it out we store using a key
90:16 - of high score and let's set a score of
90:19 - 10 so just like this we are setting the
90:22 - play preps high score keen so we're then
90:25 - going to player preps call save and then
90:28 - let's see if the score was correctly
90:30 - saved so we do a debug log go into the
90:33 - player preps and get the int that is
90:36 - stored with the key high score all right
90:40 - so we should be able to see the log same
90:41 - 10 any of here in the console as you can
90:44 - see it doesn't need say 10 so we are
90:46 - correctly saving and loading our high
90:48 - score we can test by taking away this
90:51 - and it won't still say 10 yep there you
90:54 - go still says 10 so we now have
90:55 - persistent that so with this let's add
90:58 - the high score to the score window so
91:01 - here in the corner we have the current
91:03 - score and let's put above it our high
91:04 - score so let's go into the score window
91:07 - we're going to have another text game
91:14 - let's make it in the editor here is the
91:18 - score text let's just duplicate and make
91:20 - the high score text and put it above it
91:22 - just so we can see it okay now let's
91:30 - update it in the code so in here and
91:32 - let's set the high score text on our
91:34 - private voyage start so we set the high
91:37 - score text text and now in here we don't
91:41 - want to deal with the point press
91:42 - directly from our window class so let's
91:44 - make another class that won't deal with
91:46 - this course so over here make a new
91:48 - script this is only our score class
91:53 - in here let's make a function to return
91:55 - the high score so a public static int
91:58 - get high score and here on we're going
92:04 - to do is the same thing with it in here
92:05 - so point predicate end of our high score
92:13 - alright that's it now let's also make
92:15 - this class static to keep things nice
92:18 - and clean ok and now we can go back into
92:21 - our score window then here we can set
92:27 - the high score text to be on these four
92:29 - and we get the high score alright so
92:33 - we're asking the skorca let's return the
92:35 - high score it's only T and we should be
92:41 - able to see the text correctly on
92:42 - display any of there it is a high score
92:44 - which is currently stored as ten right
92:47 - so far so good now let's make a function
92:49 - to set a new high score so on the score
92:52 - class let's make a public static we're
92:56 - going to call it try set new high score
92:59 - and to return a boolean so here we
93:03 - receive a name for the score and
93:05 - essentially this is a function that
93:06 - we're going to call when the bird dies
93:08 - so we get this called with whatever
93:10 - score we have and here we update the
93:13 - high score if it is a new high score so
93:16 - first we get the current high score then
93:21 - we test if this score is higher than the
93:23 - previous one then we have a new high
93:27 - score so with the new one we're going to
93:29 - save it exactly as we did in here we set
93:37 - the end the high score is our new high
93:39 - score and then we return true since we
93:42 - did set a new high score and if not
93:44 - we'll return false which means we did
93:47 - not set any high school all right so far
93:51 - so good
93:51 - now let's go on the game Handler and
93:54 - here let's try calling the function to
93:56 - update the high score to 20 so join to
93:59 - the score and we try seven your high
94:01 - score on let's say 20 ok let's play and
94:04 - see if the score window correctly
94:06 - updated and if they're dizzy score win
94:09 - now says we have a high score of 20 okay
94:11 - so we can read the current high score
94:13 - and save a new one also just for testing
94:16 - let's go in the score and make a
94:18 - function to reset our high score so we
94:20 - can easily test all we do is set the
94:29 - high score back in to zero okay and now
94:31 - let's see where we're going to call our
94:33 - try set new high score
94:34 - the answer is we want to do it when the
94:37 - bird dies
94:37 - so let's subscribe to that event over
94:40 - here now here to subscribe to that event
94:43 - we could use the same pattern we did on
94:44 - the game over window where we have a
94:46 - monobehaviour and on start we subscribe
94:48 - to that event hovering here in order to
94:51 - keep our score class static let's go
94:53 - with a different approach all we need
94:54 - this to I have some sort of start
94:55 - function that we call from somewhere so
94:57 - for example we can have a public static
95:00 - void start and we call this function
95:04 - over here for example on the game hammer
95:06 - we call score dot start and now in here
95:12 - we can subscribe to the bird event so
95:19 - this is just a different approach and we
95:21 - achieve the exact same results pretty
95:22 - much as in here except we don't have to
95:24 - attach our score to any game object
95:26 - using a mana behavior so just a
95:28 - different pattern and here we have the
95:30 - function that is called when the bird
95:31 - dies so we can simply try to set the new
95:34 - high score and now we need the current
95:36 - score so we asked the unlevel for the
95:39 - get our pipes passed count and you try
95:45 - to set it okay so when the bird dies
95:48 - this function is fired which tries to
95:50 - set a new high score so this should be
95:52 - working now the current high score that
95:55 - we have saved is 20 so let's call reset
95:57 - before we do anything so on start we
95:59 - call reset and then we can play so here
96:02 - we are again with the high score of zero
96:03 - now let's start playing and beat the
96:05 - high score so all we need to do is go
96:08 - past one two now let's die and there yo
96:11 - game over we got a three now let's hit
96:13 - retry and we should be able to see high
96:15 - score three any of there it is high
96:17 - score of three now if we just hit
96:20 - one and we die without it zero or we try
96:23 - and yep sunsets three now let's try
96:25 - beating our high score of three okay
96:34 - here we are with the score six which is
96:36 - higher than three
96:37 - let's hit retry and there we go we have
96:38 - a new high score okay awesome
96:40 - so we have pretty much everything
96:42 - working now for one last thing let's set
96:44 - the high score indicator in the game
96:46 - over window so here in the afternoon
96:49 - let's go into the game over window so
97:02 - you have our high score text now let's
97:04 - do the code here on the game over window
97:07 - when the bird dies we show we updated
97:09 - text now let's also get a reference to
97:12 - the high score text so here on let's see
97:23 - if we have beat the new high score so
97:25 - here we're going to either show the
97:27 - current high score or say congratulatory
97:29 - message saying we have a new high score
97:30 - so let's test if the score in this run
97:33 - is a new high score so we can go into
97:35 - the unlevel get the product passed count
97:37 - if this one is bigger than the score dot
97:41 - get the high score if so then we have a
97:47 - new high score so let's set the high
97:49 - score text so it says new high score and
97:56 - if not
98:04 - if not then we just print the corn high
98:06 - score alright let you do it okay here we
98:09 - are let's try dying with just zero so
98:12 - hit this pipe right away
98:13 - there you go zero and it says high score
98:15 - six alright great now let's try to beat
98:18 - our high score so let's go past six
98:20 - pipes okay we have passed our current
98:32 - high score and we die and there you go
98:34 - we have our message saying new high
98:35 - score okay so just like that our scoring
98:39 - system is fully working all right so our
98:42 - game is pretty much completely done we
98:45 - start off with a bird completely sound
98:46 - then I click and the bird starts jumping
98:49 - and everything starts happening the
98:51 - pipes are coming we can cause the birth
98:54 - to jump and get through the pipes over
98:57 - time the pipes will come harder and the
98:58 - gaps become smaller as you can see when
99:02 - I pass the pipe there is the score
99:04 - increasing just like that yep exactly
99:06 - and now when you hit a pipe we have a
99:09 - nice game over window here we can see
99:12 - the score we got in this run as well as
99:13 - the current saved high score then we can
99:16 - quickly hit retry and here we are back
99:18 - again waiting for input so we can play
99:20 - again and over here and if we die again
99:24 - here the other button we have is to go
99:27 - back to the main menu here we are in the
99:31 - simple main menu where we can play or
99:33 - quit alright so the game is completely
99:35 - and fully working now it's time to
99:37 - polish up everything by adding the tiny
99:39 - details didn't make a huge difference
99:41 - first let's fix one quite serious issue
99:43 - which is there's currently no ground so
99:46 - in here if I fall down there you go
99:48 - nothing happens I'm still supposedly
99:51 - alive and the score is increasing
99:52 - forever so let's add a ground that moves
99:55 - along with the pipes
101:52 - you
103:51 - okay so here's our ground it works very
103:54 - much like the pipes so it gets fun moves
103:56 - to the left gets this pond and it's
103:59 - constantly spawning new ones so it goes
104:01 - on for infinity and if we stop if there
104:05 - you go we now can collide with the floor
104:06 - and we can no longer fall towards
104:08 - infinity so here in the scene view you
104:16 - can see how they are being spawn there
104:18 - you go moving to the left and after a
104:21 - while the one on the left gets pushed to
104:23 - the right side and there you go and
104:25 - everything will look seamless and it
104:27 - never ends okay great
104:29 - okay now let's add some cloud sprite
106:21 - you
106:57 - you
107:27 - you
108:18 - you
108:28 - okay so here we have a bunch of cloud
108:31 - sprites they are moving with a slower
108:33 - rate so they look like a nice parallax
108:36 - effect
108:44 - you
108:55 - you
112:11 - you
112:18 - you
112:59 - you
113:23 - you
113:40 - you
114:14 - you
114:41 - okay so we now have had a nice message
114:44 - before we start as soon as we start the
114:46 - message Heights and the high score shows
114:48 - up and also add the nice animation to
114:51 - the GAMEOVER window so there you go when
114:54 - it pops up it gets nicely animated so go
114:56 - and yep pops up nice and like that okay
114:59 - awesome
115:11 - you
117:06 - and now we have the bird animated
117:08 - flapping its wings and when we click it
117:11 - now points up and then starts pointing
117:12 - down based on its velocity
117:14 - all right that's another nice effect
117:17 - okay so here is our final polished game
117:20 - we start off with everything completely
117:22 - stop waiting for our input we can play
117:25 - the game with the keyboard the mouse or
117:26 - even with touch as soon as we press our
117:29 - button the bird starts flying an 11
117:31 - starts being generated the pipes start
117:34 - coming with gaps in between them we have
117:36 - nice sound effects for the bird jump and
117:38 - every time we pass a pipe the score
117:41 - increases over time as more pipes get
117:47 - spawned the game becomes more difficult
117:48 - to the gaps getting smaller if we hit a
117:53 - pipe the bird dies and we have a nice
117:56 - game over window we are soaring a high
117:59 - score and the current score and now in
118:02 - here we can press retry in order to very
118:04 - quickly try over there you go and now in
118:08 - here if we die again we can see in the
118:11 - game of window we can go back into the
118:12 - main menu click it and we go to a nice
118:15 - very simple main menu or we can either
118:17 - play again or quit the game
118:20 - everything is built correctly so the
118:22 - game works on both desktop and mobile
118:24 - the game is also nicely polished as you
118:27 - can see the bird has a nice animation
118:28 - flapping its wings it rotates up as we
118:31 - jump and rotates down as it starts it
118:33 - fall down we have some parallax clouds
118:36 - at the top and a moving ground at the
118:38 - bottom and the a mover window as you saw
118:42 - has a nice animation we can hit right
118:44 - try and keep trying to beat our high
118:46 - score so in this video we went through
118:50 - the complete creation of flappy bird in
118:52 - unity starting completely from scratch I
118:54 - hope you found along and learn how to
118:56 - make this simple yet interesting game
118:58 - this was a massive video that took a lot
119:00 - of effort to make so let me know in the
119:01 - comments if you like this style of
119:03 - content and would like to see more as
119:05 - always you can download the completed
119:06 - project files in utilities from unity
119:08 - code monkey dot-com if you liked the
119:10 - video subscribe the channel for more ent
119:12 - tutorials post any questions you have in
119:14 - the cart
119:14 - then I'll do my best instrument all
119:16 - right see you next time
119:21 - [Music]

Cleaned transcript:

in this video we're going to create flappy bird completely from scratch in unity this is a great game for beginners to start with it's a very simple design that still involves some interesting logic let's begin hello and welcome I'm your code monkey and this channel is all about helping you learn how to make your own games with nf2 torrents made by a professional indie game developer so if you find the video helpful consider subscribing okay so here is what we're going to create in this video we're going to start off completely from scratch and build the whole game we start off with everything stopped waiting for our input we can play the game with the keyboard the mouse or with touch input as soon as you press the button there you go the bird starts flying and the own level starts being generated the pipes start coming in with gaps in between them we have nice sound effects for the bird jump and every time the score increases as you can see as more pipes get spawned the game becomes more difficult as the gaps in between them become smaller and when we die there you go we have a nice game over window that pops up in here you can see that we are storing our current score and our high score then we have our two buttons to retry and back to the main menu now when we retry it's very quick it reloads the main scene and we can try again very easily and the other button for the main menu we can get and we go into a very simple main menu where we can go into playing the game or quit to the desktop so we hit play and here we are back again everything is built correctly so the game works on both desktop and mobile the game is also nicely polished as you can see with bird flapping its wings when I click you can see it nicely rotate with jump velocity there are clouds in the background being moved with a nice parallax effect along with our ground and the pipes and here on the GAMEOVER window as you can see it also has a nice polished animation so this is our final goal now let's go through an overview of how we're going to get there we're going to start off with a completely empty scene making a brand new unity project then we're going to begin with our initial setup first setup the main scene and camera as well as organizing our hierarchy and project folders then with the basic setup done we're going to start working on the bird make the game object and the script to control it listen to input and use unity physics in order to move it with burden we're going to handle the other essential component of the game the pipes first learn how each pipe is setup with a body and head sprite as well as handle collisions between the bird and the pipes then we're going to start working on a level script which won't be responsible for spawning our pipes start off with a simple function to create a pipe with the correct size and position then expand the Panda to make a function to create both a bottom and a top pipe with a certain gap between them with the pipes being correctly spawned we're going to handle their movement as well as correct spawning and cleanup we're going to implement increasing difficulty based on the number of pipes spawned so as the player goes along the pipes become more frequent and with smaller gaps then we're going to get to work on making the UI first deal with the setup and then add a simple window to display the current score with the score working we're going to handle our game over state so make another window in the UI that pops up when the game ends which is when the bird hits a pipe the window shows the score and has a very quick retry button then we're going to make a proper loader class to handle all of our loading and with that it's time to make a simple main menu just another scene containing a button to play another to quit without that the game won't be almost fully working so it's time to finally add some sounds we're going to make a nice class that will be responsible for playing every sound and then after that we're going to handle our score detect when we have a high score and save it when we beat it as well as a nice message in the game over window so at that point the game won't pretty much be done and with everything done it won't be time to work on punch so we're going to add all the tiny little things that greatly improve presentation like the ground and claps per rotation when jumping as well as a nice animation on the game over window alright so again here is final game after all of that we have our bird jumping and going through the pipes these score increases and we have some nice sound effects everything is nice and polished and the game is very nice and playable all right so this is our goal let's get started so here we are in the unity main window let's name our new project flappy bird we're going to use the 2d template and let's it create alright here's our completely empty scene well let's first rename the scene in order to have a more appropriate name so this will be the game scene this will be the main scene where our game is we won't later have a different scene for the main menu and anything else we need so in here let's set up our camera since we selected 2d our camera is already in orthographic mode let's just change the size so we can use a larger unit size in our game and here the size is the orthographic size which represents half the vertical space shown in the camera so in here and let's set to 15 and now here on the scene view we can see that our camera is now displaying right here from minus 50 all the way up to plus 50 so we have a hundred units being displayed all right now let's make our main starting object so we make a new game object let's put it on zero zero zero now this won't contain the main script that handles our game so let's name it our game hemily it will also be the main container for our preset scene objects the better you keep your objects organized in your hierarchy these are it is to find what you're looking for so here let's drag our camera in order to be a child of the game hello okay now let's make a game handler script in order to handle our game this will be the entry point for most of the game so in here first let's make a new folder this will be our scripts folder and inside we create a new C sharp script and this will be our game helmet okay let's open the script and in here and let's just do a debug download on the start okay very similar script just so we can make sure that our script is running so now back in the editor let's select our game object and drag the script onto it okay let's test any of their lives on the console game hell more dots are okay great everything is looking good so far now let's set up some visuals so first we make a new folder this won't be our textures folder all right I have copied some textures onto this folder as always you can download the project files from the website so in here we have a simple background texture a bird a ground a pipe body and a pipe head here is also a white pixel texture it's literally just a one by one white texture this is great whenever we want to display a colored rectangle so let's begin by setting up the import options for this texture it's one by one so we set the pixels per unit to one so when we add this texture to a sprite renderer it won't occupy exactly one unit now for the other textures it's going to depend so let's start making our objects and then we'll hand all the pixels per sprite so first of all make a game I'll check this will be our background we add a sprite renderer component and drag the background sprite so here's our background sprite occupying the entirely of our camera view okay now that we have our background let's make our bird so a new sprite this will be our bird and let's drag the bird sprite okay this seems like a good science here it is in the game view and now that we have multiple sprites let's handle our sorting layers so we can simply go from the spread rendering here at a sorting layer now we have the default let's make a background layer and also a over layer so we have the background then on top of the background we have the default and on top the font we have another layer this one is just in case we need it later so here in our background we put it on the background and the bird let's leave it on the default okay so that's our basic setup for the main sprites we're going to need we have our hierarchy organized we our main camera our main object the bird and the background the project files are also nicely organized into folders so we have the scenes scripts and textures and now in order to help us develop the game faster we're going to use some very helpful classes from decode monkey utilities this is just an optional step you don't absolutely need to have them but it will help us in iterating and debugging our game in many ways the scale of a game the vampers based on the tools at our disposal so you can go to the website unity code market account download utilities for free and then you get a unity package file when you open that file you won't see this window so in here let's simply import everything and there you go here in our project files you can now see a new folder and in here it contains all of the utilities as you can see it also contains all these source files so feel free to go through all of these in order to see how all work now to make sure everything is set up correctly let's go back into our code into our game hammer and in here and let's spawn some testing popups so first we go here using code monkey and using code monkey utils and here let's spawned some popups every once in a while so for that we can use the function periodic this lets us automatically call a function every certain amount of time so this is the function we won't call inside we just do a text pop up on your mouse position okay so here it is very simple we are simply going to execute this function every 300 milliseconds so we should be able to see a nice text pop up just see if our utilities have been correctly set up let's see any app as you can see there are the messages so we have all of our utilities correctly worth this will be very useful as we go on so we have our complete set up almost done let's add just one more very useful thing let's make a class that we can use to easily reference assets from code so for example let's say here in the game ham where I want to spawn a pipe so what I would do would be create a new game object so here for example I'm creating a new game object with a sprite render and I mean here I need a reference for this part that I want to use so this is where it's really helpful to have a class that contains all of our asset references so let's do that here let's make a new csharp script this will be our game assets and now let's also make a game assets game object again keep it organized so drag it in there and drag our script onto it okay now this won't be a very simple class now for starters one thing we need is to be able to access our fields from everywhere else in our code so let's make a static accessor so we have a private static instance and the public function to get the instance then we just set the instance on our private Roy away okay so now everywhere else in our code we can access this in order to get this instance being static means that this can be accessed from everywhere else in our code so now all we need to do is add public fields for whatever assets we need and we won't be able to reference them through code so here just for testing let's do our public sprite for the pipe head sprite and now we can go back into our editor and there's our script as you can see there is the field now we can drag our pipe head okay so we have our asset reference right there so now we can go back into the game Handler and in here we can finally access that so we're going to became assets we get the instance and then we access the pipe heads Frank alright so let's see and if there is our created game object with the correct pipe head sprite so as you can see we're able to reference this asset through code now just one last thing and here we need to make sure that our awake runs before anyone else tries to access it so for that we can go into edit project settings now in here we have the script execution order and we can simply drag the game assets and drag it onto the top that will make sure that this script gets executed before any others test it again and yep everything is working perfectly fine ok great so here we have made all of our initial setup and we are finally ready to begin creating our game we setup the main camera as well as our main game object that won't be the entry point for our game we also import the code monkey utilities which won't be extremely useful for helping us make our games faster and we made the game assets class which also be very useful for grabbing asset references through code okay with all that done let's begin making some basic control for our bird we want the bird to be controlled on by either pressing the spacebar or clicking on the mouse so let's make a script to handle our bird so a new csharp script don't let's simply call this bird and let's drag it onto our bird game object okay now in here let's first make a private Lloyd update then our update let's capture the space key so we do if input dot get key down key code out space so this one the space is pressed now when we hit space we want the bird to jump so we're going to make a function to do that so jump and now in order to do the movement and later test for collisions we're going to use the Unity physics system so let's go to the editor to set that up okay here we are on the bird game object and in here let's add a circle Collider 2d and let's look at the size so here on let's make it slightly smaller than the sprite so the game is a bit more forgiving and exciting okay now this is just a Collider so right now it doesn't do anything in order to handle gravity let's add a rigidbody 2d and here for the constraints let's freeze the movement on the X it's a bird long ago up and down alright so that's pretty much it for the physics setup so we can test out this code and see any of their is the bird is already being affected by gravity okay so far so good now all we need to do is tweak these values to make sure they feel just right so in order to test our values let's first teste jumping so here on the private void awake let's grab a reference to our rigidbody okay we have the reference to our rigid body and now in here on our jump we want to jump to be repeatable and consistent so the bird is meant to jump the exact same amount every single time that's how we're going to make sure that the game is fair now to achieve that we're going to modify the rigid body don't laissez that won't give it an instant jump as soon as we press so in here we use vector to data to move around and then we need a certain jump amount so let's go up here to define a constant for the jump amount so a private constant load for the jump amount and here we multiply a vector sodaro by our jump or not okay well let's see if when we press space we can see our bird jumping there's a bird press space and if there you go he started going up okay great now let's tweak these valleys okay so these values seem just about right so when I press give there yo he has a nice and repeatable jump so if I price exactly at the same time you can see that everything is repeatable so it's very much based on player skill okay great so the valleys we have 35 on the gravity scale and here we have a hundred on the jump amount so just like that here's our basic bird jumping up in there okay awesome now let's make the jump also based on the mouse click so we can play either with the mouse or the keyboard so here we're testing for gate key down on space and let's also test or input not yet mouse button down on the in left mouse button so mouse button zero let's see okay here we are space stone works and click yep there you go clicking some words okay awesome so we now have two different input methods and our game works perfectly fine now with this it would also be very simple to make it work with touch input since it's pretty much the same as the mouse so here we have our basic jump working now that we have the basic jump let's work on our pipes so over here as you can see there are two pipe sprites there's the pipe head and the pipe body so to see how they're meant to be set up let's make one in the editor so just drag the pipe body and drag the pipe head so essentially we're going to have our pipe body then don't be stretched based on a certain height and then we have the pipe head on top of the body so this is how we're going to create our pipe now how we're going to handle collisions is again using the physics system so let's move the pipe right next to the burn okay like that and here on the pipe body and let's make sure it reaches just the top of the head and in here we add a box Collider this is how we're going to test for collisions let's make this a is trigger and everything else leave the same now back in our Bert code in here let's make a private void on trigger enter to D so this function gets called whenever this collider hits another Collider so in this case and let's just do a pop up so again let's go up here using the code monkey Stoney's so you can go into the CM debug class to just do a text pop up on the mouse position okay let's see if our collisions are working okay here we are now let's fall and touch the pipe any of their Dean that pop up and yep just like that okay so we are correctly and successfully identifying collisions between the bird and the pipes okay great so we now have the basic collisions working and also we know what we need in order to create a working pipe now let's make a script which will handle our level by creating and moving our pipes so we make a new csharp script let's call this our level let's make a new game object for our level and drag the script onto it and again keep things organized so drag it on there okay and I'm here in our level class let's begin by creating just a simple pipe so let's make a function a private boy create pipe here for the parameters let's receive a float for the height of the pipe and also a float for the exposition now let's create a pipe like the one we created here in the editor so we have a body and a head now here we can use prefabs in order to insensate our pipe so let's go here make a new folder for our prefabs and let's drag the pipe body and the pipe head let's name this TPF pipe body and pipette okay so here are both of our prefabs now in here we instantiate and now we need a reference to our pipe so we can go into our game assets in here at a public transform so we have our two fields for the head in the body let's drag them here's the game assets drag the pipe body and the pipe head okay we have our references and then we can go back into our level we instantiate go into the game assets class you get the instance and access the PF pipe head okay so we have the pipette being instantiated and also the pipe body and just like that we have both them being instantiated now let's test this out so in here make our private voice start we're going to create a pipe and for now the parameters don't matter so much is passed zero just so we can test okay here we are in yep we have correctly in Senshi in our prefabs here are both of our codes okay great now that we can create them let's position them so let's modify the pipe head position for the X we pass in our exposition and the Y will be based on the height but for now let's leave it just at zero and also please leave pipe body on the x position so let's test finding two pipes so the first one on zero and the second one on 20 okay let's see if we have two pipes being accentuated any of there it is we have a pipe here and one in there okay great now with positioning them based on the height let's start off by making a pipe that occupies half of the screen so over here in the main camera we set the orthographic size as 15 so that means we can see a hundred units so this one goes from minus 52 plus 50 so if you place them down here and put a height of 50 it should occupy half of the screen and now here on our prefabs there are some things we need to change over here on the pipe body so far we just changed it on the scale however right now we're going to do it differently here on the sprite instead of simple draw mode and let's choose sliced so we can now reset the scale and now instead we move based on the height let's fix this warning so go into our pipe body make this foam rect so here is our updated sprite instead of modifying the unloadin scale we're going to modify the draw mode width and height so here it goes up and down okay and one more thing go here onto our sprite and we're going to set a pivot on the bottom so now we can modify the height in units and place it right on the bottom so we're going to place our sprite on minus 50 and we want to add at a height of 50 and just like that the fight will reach exactly the middle of the screen okay now let's position this through our code also one thing we need to see is the width of our pipe so for example you could decide to have a variable wind but in our case not to keep things simple we're going to always keep the same width so let's sort this as our constant so here on the level let's make a private Const code for the pipe width and put that back and now we can go here into our pipe body so we access our sprite render and modify the size so for the size we pass in a new vector2 first with the fight width and then for the height we want so in this case our height so if we go in here and we pass in 50 which now be able to see our pipe body having 50 height let's see and he appears both our pipes let's see if they are indeed and yep there you go they are on the Y of zero new in a height of 50 okay so the height is indeed working however now we need the head to be on top of the pipe since this one is meant to be going bottomup so that means that we need to take the head and move around the way up there to the height except if we place it on the height it would be placed in here which would go past our desired height so we need to put it on the height minus half of the height of the head so let's do that through code so you position the pipe body make it the correct size and now for the pipe head it won't be placed on the height minus half of the head height so let's see how much is half of that height and here we can make also the head based on slice so we can easily see our width and height so here's our values essentially we wanted to put it up there minus half of that so minus 1.8 and it would be just in there now obviously you can also see that the head is behind the body that is not meant to happen so we can also just set the order in layer leave it on default and put it on 10 okay that should do it so let's put this value in our code so another predacons float for the pipe head height so in here we position the pipe in on the height minus half of the head height okay let you do it let's see and here we are and yep there's our pipe correctly positioned the pipe starts on zero goes all the way up to 50 so to the top of the screen and the head isn't it placed exactly on top so here we have a perfect pipe with a height of 50 okay so far so good now one thing we need is obviously to update the valleys on the box on either as you can see it's only down here so let's set the Buckskin letter size to match the size of the sprite so the box weather is here on the pipe body so we just take the Buckskin weather and modify the size going to give the same pipe with an hour height okay now let's see okay here we are the pipes are correct let's look at the buxom weather and there you go the height is correct however it is still on that origin whereas the sprite has an origin on the bottom that is because we set the pivot on the sprite to be on the bottom so we need to do is shift our box Collider up by half of its height let's do that here we take the size then we also modify the offset now the offset on the X is zero it's correctly centered and here its height x 0.5 any of there it is it's perfectly correct as you can see there to the box wire and yep it goes perfectly all the way to the top okay great now let's fix the issue of the pipes being spawned right here from the zero we want to spawn them obviously right here from the bottom so that means we need to know the camera orthographic size so let's make that over here and now that our private conflict for the camera ortho size which in this case we're using 50 in here in order to position them all we do is put them on or through size then add all the rest okay let's see if the body in the head are now starting from the bottom any of their it is we now have our pipe spawning right from the bottom okay great so we have pretty much our create pipe function working what's responding different heights so when we'd 1543 and Twain any of there's our pipes all of them with the correct Heights okay great so everything is working great however in the game you don't just have pipes on the bottom but also on the top so let's do that or here are not create pipe function let's add another parameter let's receive a bowl and this will be create on bottom so if this one is true we create a pipe on the bottom if it's false we create it on the top so in here essentially for our positions we just have to reverse it so here let's define a pipe head Y position so by default on the bottom we do what we were doing previously then we have an else if we were not from the bottom then we want to create from top so it will start on plus camera ortho size minus the height and plus the pipe head height times point five and that's what we use in here okay so that's the head correctly placed now for the body so the body is very simple if we are on the bottom we start on cameras or through size and on plus cameras I see from the top however the one thing is if we do it like this essentially we spawn around top and it won't start at top the screen and then go past outside of the screen since we set the pivot on the bottom so we can fix that by setting the high body dot local scale keeping it 1 on the X and invert it on the Y ok so this should be working so let's test it out in here so we should be able to see a pipe on the bottom and one on the top post them with 40 of height let's see and if there is we have correctly set up our pipes so we have a pipe right here on the bottom and when right there on the top we can all get the scene view and yep everything is perfectly start exactly in there they go exactly for 40 ok great so everything is perfect here testing with a height at 50 and yep they meet exactly in the middle all right great so we cannot spawn pipes both on the top and the bottom they are dynamic so we can spawn any size that we want now that we have similar is working in the flappy bird game design we normally always have a pipe on the top and one on the bottom so let's make a function that takes a gap size and calculates the size of the top and bottom pipes so in here we have our nice create pipe function ok everything is working perfect and I mean here we make another a private boy create gap pipes now in here will receive a float for the gap line meaning the height of the gap also evolves for the gap size so how big is the gap and also our fault for the exposition so we want to create a gap at this Y at this height with this specific size and obviously placed on this x position so that means we need to come like the height for both the top pipe and the lower pipe so let's start with the bottom pipe which is a symbol so we just do a create a pipe now for the height on a bottom pipe it will be the gap Y minus half of our gap size so gasp size times 0.5 F so this is our bottom pipe and now for the top pipe we need to know the total size of our play area so that's our camera ortho size x 2 so our play harriet has a hundred so to create our other pipe the height of this pipe is the ortho size times 2 F so the total playable area the gap wine and half of the gap size so we spawn our top pipe first of all we spawn it with the total size of the total playable area so it starts on top and reaches the bottom then we take away the gap wine so it goes just past that and then we take away half of the abbé sieyès okay so this should do it now let's go up here to test making a pipe so we create the gap pipes for the gap wine let's start off right in the middle so on 50 and for the gap size and let's say a size of 20 ok so we should be able to see two pipes that make up a gap with 20 of height and the app is right down the middle let's see and if there it is there's our pipes both of them being created by just one function and let's make sure that this is correctly working so let's create a game object just don't look at it any of there it is up here we have a Y of 10 and down here if there you go minus 10 so here we have a gap with size of 20 okay so our code is working perfectly great we automatically calculated the top and bottom pipes based on a certain gap Y and gap size so now with this next function we can get to work on making me in level generator but before we do that the pipes are not meant to be static but rather move with a level so here we have two options we can move our bird across the level and keep the pipe static or we can keep the bird static and move the pipes let's move the pipes instead so we don't have to deal with moving the camera so over here in the level class we need to keep track of what pipes have been spawned so we can actually move them so up here let's make a list of pipes so a private list let's store transforms and call this deep pipe list on the private void awake we initialize our pipe list and over here when we create the pipes let's add them to the list both the head and the body so in here pipe list add the pipe head and here at the pipe body okay so we are populating our list with all of our pipes now let's go to our update and in here and let's make a function called handle pipe movement now in this function let's just cycle through all the pipes and in here all we need to do is modify the pipe transform that position and move them to the left now we need to know how much we move them so let's go up here in order to make another constant for the pipe move speed and then here we just move them to the left so a new vector3 with 1 on the x x our speed and by time.com time alright so that's it very simple we go through our pipe list and we move the mounted left so let's test and here it is we have our pipe moving to the left ok great so this is working however the code isn't looking quite bad over here we have a list of transforms and each pipe is composed of two differ transforms it would make more sense to have a list of actual pipes and then the pipe class would handle whatever it contains so let's do exactly that down here let's make a class called pipe and then we have a transform for the pipe head so we have a feel to sort the pipette in the pipe body transform and we receive both of them in the constructor all right now also a public void move function and in here we're going to move the head and body exactly as previously so over here we were doing this and now we go down here and do the same thing for both the head and the body okay so far so good so we now have this nice simple class and now in here when we create a pipe we create the pipe head in a pipe body then in here we create a national pipe object so we now have an instance of our nice pipe class and now in here in our pipe list instead of stirring transforms let's store pipes so fix all these errors and here on the pipe list we no longer to add the head or the body but rather down here we do item list and add our pipe okay so this is working now we have on list of pipes and now in here on our Hema movement we cycle through all the pipes and instead of moving it directly we just call might not move all right that you do it what says to see if it's still working any of here we are and the pipe is still moving exactly the same as previously now one issue we have is regarding the cleaner now if we go into our scene view over here is the camera and there's the pipe continuing to move to the left as you can see it's going to continue moving towards infinity what we really want to do is clean up and destroy the pipe once it gets to a certain point right here on the edge of our screen so when it gets passed we wanted to be destroyed so it doesn't keep eating memory so we're here in our hmmm pipe movement have to remove it let's test if the pipe position is under a certain value so to get the position let's go into the pipe so here we're going to have a public float let's go get exposition and in here both of them are gonna be placed on the same X so either one is fine so let's just return the pipet transform that position dot X so we have a function which returns the pipe x position and now over here have to remove them we just need to test if the pipe dot get X position if it is under a certain value so to define that valve let's go up here to make another constant so project cons float let's call this the pipe destroy x position to see the position let's go into the editor over here we have our camera so let's see where that is so here it is the edge is on minus 90 now the way we set up our camera is going to depend on horizontally so in here if we had five by four it would be smaller so we need to make sure that we pick the value at the widest possible resolution so the why this is sixteen by nine so let's put it a bit on the edge so let's say minus a hundred so very here the pipe destroy exposition is on 100 M so we can now go down here test if the position is under the destroy exposition then we want to destroy D pipe so let's make a function in there to do that so we probably boy call of destroy self any here this is going to destroy the pipe so we need to do is run on destroy both transforms so we destroy the pipe head and the body transforms game objects and now in here that's one we need to come type dot destroy self ok the pipes have been destroyed now we need to remove them from the list so in here if we try to remove it directly whilst inside a for each we're going to have an error so instead of a for each let's do a simple for okay we have a symbol for instead so now in here after we destroyed the pipe we remove the pipe from the list and then since we are modifying the list we need to make sure we don't skip an index so we need to do I if we didn't then we would skip the index whenever we destroy a pipe alright so all this code should be working we're handling our movement same as previously going through every single pipe we moved them then we check the x position if it's past a certain value so if it's offscreen then we destroy the pipe and remove it from the list let's see ok here we are let's look at the scene view and if there's the pipe there's the camera and the destroyed position is somewhere in here so let's wait to see it go going to the left when it gets there yep there you go the pipe has been correctly destroyed right great so we have our pipes being correctly cleaned up alright so now that we have pipe movement and cleanup work it's finally time to handle level generation so to generate their own level what we need to do is constantly spawn pipes we want them to be generated but not come random we want a level to start off easy and become increasingly more difficult so that means fewer pipes that start with larger gaps and as it goes forward more pipes with smaller gaps we already have the pipes being automatically removed so all we really need to think about is how to spawn them so here in the code the first thing we're going to need is some timer between each pipe spawn so over here and let's define our timer so a private float let's call this the pipe spawn timer then we also need a maximum so a proud float for the pipe spawn time remarks now here on awaking let's set the timer max let's put it at 0.5 so spawn a pipe every half a second now on our update let's call another function to handle spawning okay we have a function tamil are spawning now in here the first thing we do is decrease the timer so the pipe spawn timer we decrease it by time dump time then we check if it's under zero it's in there zero then it's time to spawn another pipe so the first thing we do is reset the timer so we increase it by the max and in here let's spawn a pipe so we're going to use the same function to create gap pipes and I mean here we need the gap line in the gap size we'll deal with that later but more importantly we need the x position so we need to know where we're going to spawn it so for the X we can use pretty much the opposite of what we did to destroy so in here let's make another constant and the pipe spawn x position and set of minus 100 so beyond plus 100 okay so that I need here when you create the pipes we use that okay so here we are creating a pipe gap right on the edge on the right side so let's test and see if we have a pipe being spawned every half a second okay here we are and yep exactly pipes are being spawned every half a second obviously they are moving too slow and spawning too fast but yep the code is working every pipe is being spawned with the exact correct gap and moving to the left so let's look at the scene in order to make sure they're being destroyed there you go they're being spawned out there at the edge of the screen and yep they get destroyed in there okay great so our basic spawning is working now we just need to modify the valleys for the speed the spawn timer and also the only the gap height and Suns so first the speed and let's increase it and also increase the spawn time and okay that is looking quite a bit more appropriate we have the primes being spawned at a nice decent rate alright good so here we have our pipes being spawned now let's handle the height and the gap size now for the height we're going to essentially just randomize it and for the gap size we're going to tighten it over time so let's make a feel for that a private float for the gap size this is the gap size that we're going to use the spawn so let's start off at 50 so it's art it is extremely wide and now in here when we are spawning our pipe let's use that capsize and now we need to know what the height should be now in here we cannot randomize fix values since it's going to be dependent on the gap size so let's make a float for the mean height or D come elated and the min height won't be the gap size multiplied by 0.5 so the minimum height that we can spawn is gonna be half the gap size so right at the bottom so in this case with a gap of 50 the absolute minimum height will be 25 however even with that the gap will essentially touch the floor so let's add a mandatory minimum so a float for the height edge limit and let's say 10 F so it's not right at the bottom and for the height to come like the height was this nice limit so this should be a good minimum and now for the maximum first we start off the maximum at the total height over here we have the camera orthographic size and we know that the height of the camera is double the orthographic so a float for the total height will be the orthographic size x Qi so for our max height we start off at a total height and then we take away half the gap size so gap size times 0.5 and we also take away the height edge limit all right let you do it so we now have a nice minimum and maximum so for the height we just do a random range between the min height and the max height all right that should do it so let's see if our pipes now have a gap of 50 at random Heights okay okay here we are in yep as you can see they are moving down moving up so the height is random and they are not touching exactly on the edges so right now you can see the game is already quite nicely playable all right so the pipes are being spawned correctly the height is correctly calculated now all that's left to do is actually calculate a tightening gap so first just test out to make sure the code works with a small gaps and let's say 20 any of there we go there's one there one there and yep the height is indeed changing and 20 is already quite a bit difficult as you see I died and you know 20 is already very tough right great so everything is being correctly generated nice so now that we have our nice gap filled we can easily use it to increase our difficulty over time so at STARTTLS we start off at 50 nice and easy and now to increase our difficulty let's keep things nice and clean so define an informal T so in here if Tony Kanaan for need difficulty we're going to have easi then medium hard and finally impossible okay now down here let's make a function to get the current difficulty so we're going to return the difficulty now we need a way to keep track of when we should increase the difficulty so let's do it based on the number of pipes spawned so in here let's have a present for the pipes spawned and down here when we have the create gap pipes in here let's increase the pipe spawned and on the gap deferral let's just do some very simple ifs okay so you have a function that returns the current difficulty based on some preset values now let's make a function to actually set the difficulty values so a private void for our set difficulty this what is going to set all the various fields related to difficulty right now the only film we're using is for the gap size so uneasy we start off with the gap size of 50 okay so in here we are shrinking the gap size every time we increase our difficulty now over here on our awake instead of setting the gap size originally we call set difficulty and we start off at easy all right and then finally when we actually spawn our pipes so here we are we are increasing the file spawn and let's update our difficulty so set difficulty and get the different so whenever we spawn a pipe we update the difficulty right so that's pretty much it the more pipes respond the harder the difficulty and the smaller the gap so let's see if that happens every 10 pipes we are increasing let's see okay here we are and let's see and they're all starting off nice and small nice and easy and now when we get to number 10 the pipe gap should become smaller and there you go this one is quite a bit smaller than the previous one and now it keeps going and yep now it's definitely getting harder and yep all of them are quite a bit more difficulty quite a bit small gaps and there you go that one is already extremely small and in here I couldn't make it alright great so the difficulty is working based on the gaps but we can also modify the spawn timer so you could actually start spawning over here on the 50 okay so here we have our values and we need to do is tweak these values to get the game easier or harder so just like that we have our difficulty increasing over time so here is the game so far in yep it doesn't look quite nice however one issue is that all of that is just happening in the background right now there is no way to actually visualize any progress over here I have no idea how many times I have passed so we're going to deal with that by adding a simple UI element don't let us know how many pipes we have passed we're going to have a score window so let's begin by making it over here in the editor now in order to make a score window we need to setup the UI with a canvas so let's go here to our game handler game object in order to keep things nice and organized and in here let's make a new empty game object let's call this TTY now you can leave it in any position you want but personally I don't like to put it to the side so there it is so you have the main scene here and the UI in here just easier to keep track of things now inside the UI let's create a new canvas so we're here to UI a new canvas here is the canvas and as you can see it automatically create the event system let's keep things organized and drag it in there okay now inside the canvas let's create a UI images show we can see it there you go so here's our UI being displayed now let's set up our cannabis in here instead of overlay let's select camera this allows you to assign a camera that won't display the UI which is what we're going to do so in here we create a new camera let's call this the UI camera so this is the camera that is going to display our UI so here in the canvas just drag our camera onto it and just like that okay this is now our UI and as you can see in the game we can still see it okay so these are any camera settings very similar just don't clear orthographic and with the size of a hundred and here on the canvas for skill mode let's go with scale with screen size which resize UI elements to fit the screen and resolution and in here the reference resolution is the main resolution for your UI so if the current resolution is smaller don't be scaled down and bigger don't be scale up so this depends on your platform but for example for desktop games I'd like to put it in 720p so very simple 1280 by 720 then let's fully match by height which means that elements won't be resized if the height of our resolution changes so here's the game window and as you can see the square has that size and if I shift it up so as you can see it scales with the vertical size however if I change resolution to change the horizontal size as you can see the square does not change so this is what it means to match only just with the height and the reference pixels leave it at a hundred all right so this is our very simple UI correctly setup now inside our canvas where we can put any UI objects so let's make a new game object this will be our score window let's anchor our score to the right side and inside let's put up a UI text for the current score called as the score text alright here's our nice text object to any of there you go there's in our screen on the court okay now let's do the script in order to update our text object so in here make a new script this won't be our score window drag it on to the game object now in here let's first go into our prayers Boyd awake in order to grab the reference to the text field so we have our reference and now we need to deal with the score now for the score let's go into our level and find a way to return the pipe spawned so we make a public int get pipes spawn and we simply return the pipe spawn however in order to access this function we need to access the in level instance so let's make a static function to return the instance so up here so we have a static instance and we set it on our awake and then we have a static function we return the instance and now we can go back in the score window make our private void update and in here we set the score text text go into the in level class get the instance and get the pipe spawn alright so that's it we now have our nice score window asking the level for how many pipes have been spawned so let's see this working any of there it is one pipes one two pipes three four and so on all right great so as you can see the counter is correctly increasing as it's so posted right now one obvious issue we have is that the score is meant to increase when the bird passes a pipe and not when the pipe is spun so let's do that let's go to where the pipes are being spawned over here in the unlevel now we don't want to use the pipe spawned count but rather we want the score to increase based on when the pipes move so when the pipe gets passed the bird now in this case we are moving the pipes and not the bird so we need to test if the pipe is to the right of the bird then we move the pipe and then we test if it's to the left of the bird so before we do our movement let's define a bowl for is to the right of burned and this won't be if the pipe dot get position if the position into the pipe is to the right of the bird position it's not for the burn let's do another the bird is on zero okay then here we are to write the bird if the pipe X is to the right of the vertex position then we move the pipe then we test if the bird was to the right and is no longer to the right so less than or equal to the x position so we're here the pipe was to the right of the bird and now it no longer is so it's in here that we have successfully passed me bird so we have the logic for detecting it now we just need to handle the score so let's go up here make a private end for the pipes pass count and all we do is increase it in here five pass the bird so we increase it all right now we need a function to return this value so the same thing we did previously so here we have a function to get that value and now in the score window instead of getting the previous one we get the pipes passed all right that should do it let's test okay so here we are sir off at zero and when we pass this and yep the score increased and it looks nice although as you can see we have a nice error it's increasing by two every single time so 12 14 16 and so on the reason is because we have two pipes so we are passing two pipes every time we pass one gap so we want to calculate the gaps and not necessarily the pipes let's sort that so this in here is that we have two pipes per gap so one way we can solve this is very similarly doing the score count on a specific type of pipe either the top pipe or the bottom pile so that means that we need the pipe to know if it's a top or a bottom so in here on the gray pipe function we create either on the bottom or on the top so when we create a pipe let's pass in the same ball create bottom so in here a private ball for the crepe bottom and we receive it okay so now we know if this pipe is a bottom or a top now here let's just make a ball to return that and let's rename this to a more appropriate name okay so now we can use this function in order to test our scoring logic so I'm doing here we test if it's the right amount and left and the pipe is a bottom pipe if it is then we test for the score if not then we ignore it right so now we should have fixed our problem of increasing the score by two let's see okay here we are let's pass this one and if there you go increased by one two three and so on okay great so our code is working and everything is increasing exactly as intended all right so our logic is working and the scoring is working it's not with the basic sword let's see on with making a game over scenario right now over here when the bird hits a pipe we get a nice pump up but nothing actually happens everything keeps moving and there's no game over screen I don't so we are detecting the hits but not doing anything first let's stop the bird when we detect bird death so let's go to our bird class so we are taking birth death over here on our trigger enter now the bird is being controlled using physics so we can simply stop them by just going into the bird rigidbody2d in order to set the body type to body type dot static so this means exactly what it says the bird won't be completely static so let's see okay here we are now let's hit a pipe and see any of there you go hit the pipe and the bird no longer moves the bird has come only static and I click and nothing happens okay great now obviously as you can see the pipes are still being spawned and moving so let's stop that now in order to stop it we need over here the unlevel class to know when the bird has died so in order to communicate that to the level class let's go into the bird to add an event so we're going to have a public event and call it Ondine so the burden on fire this event when he dies so let's go in here here we have the birth death so we simply trigger the event all right that's it for firing our event now in order to subscribe to the event as you can see this is not static so we need an instance of our birth class so let's make a static instance the same we did for the level so you have a static instance that we set on a week then we have a function to get a static instance and now we can go into our level class and over here on our start we can go into the bird get the instance and subscribe to the on bird died event so here we have the function to test when the burden has died now let's just make sure that this code is working so instead of putting the popup in here let's spawn the popup on the unlevel make sure that this code is running so let's see the pop up when we hit the pipe and if there you go there's a nice pop up in the bar top okay great so we have this event being correctly fired now that we have that that means we know in our level class when the bird has died so we can use that to stop moving and spawning the pipes so let's go up here and keep things nice and clean so we make a private inhome for the current state and the possible states are either plain or the bird is dead and also store the current state now if we're here on a way preset is the start so starting state lights are off as plain then here on our update we're only going to have a movement and spawning if the current state is state that plane so if it's not playing we do nothing and finally in here when we have the bird died we simply modify the state and set it to state that bird death alright that should do it so we're here on the bird class we are not looking for the physics so we capture the trigger enter when we hit a Collider when we do we fire this event that the unlevel class is listening on this event which fires this function which then modify the state and if the state is per dead then of this movement then spawning no longer runs so let's see if everything stops the second we hit a pipe okay here we are still moving let's hit that pipe any of there you go everything stopped the bird stopped and level stopped the pipe stopped everything started awesome so we have pretty much a fully functioning game over state the bird and the pipes all stop now one of the main features of flappy bird is a quick restart and the way we built our game actually makes that extremely simple all we need to do is reload this current scene and we can easily start over so we're here when the bird has died let's just restart automatically in order to restart with a small delay let's use the function timer from the code monkey Tony's this lets is easily trigger an action after some time so we're going to trigger an action after one second and that action is going to be extremely simple all we need to do is reload the current scene all right that should do it so when the bird dies this code runs which creates a function timer which won't trigger this action after one second which will reload the current scene so let's try it okay move forward now let's hit the top pipe and there you go everything's stopped and after one second there you go everything starts over so hit this one and yep we got a nice restart and let's increase the score count so now you got a score of 1 to hit this one and they're going after one second reloads and everything is back to normal right awesome so far everything is working very nicely however when we start the game it's quite daring to start immediately now let's make it so that the game doesn't start until the player does a first jump that means we need to stop spawning pipes and moving the bird so first let's do it on a bird over here to stop the movement we can do the same thing that we did over here on the death so we set the rigidbody to be static so here on the weight that's what we said now let's also store a state in our bird the possible states are waiting to start then we have plain and dead okay now on our update we do a switch on the current state all right so case we are playing we do the same as previously and if we are waiting to start we also do the same thing so we listen to the same input we cause a jump and then we modify the state to be state at play and finally we change the rigidbody back into being dynamic okay so that you do it show the bird should start off as static then when we press spacebar for the first time we go into playing everything goes back to dynamic and everything continues so let's see if the bird waits for our input okay here we are and the bird is indeed stopped and when I press there you go everything starts and now everything's work normally gravity and so on okay right now as he saw the pipes were still moving while the bird was stopped so let's sort that over here on the eleven class let's add another state so first we count waiting to start now let's use the same pattern with it for the birthdeath so on the bird we make an event let's call this on started playing and we fire the event in here okay so we have this event and now back into the unlevel over here and let's do the same thing go into the word get the instance and subscribe to the on star plane when we start playing only to do is set the current state to be state that plane and on awake instead of starting on playing we start on waiting to start and that's it let's test okay here we are and nothing is moving score zero birds not moving no pipes nothing awesome now I click and there you go and everything starts exactly as in tennis so the bird is now moving pipes are spawning moving and so on now let's hit a pipe and after one second reloads to start and again nothing's moving click and we can start playing all over again and yep awesome great now let's replace our automatic reset with a more appropriate game over window so for that here in the editor let's make a new game object this will be the game over window okay so we have a very simple game over window we just have a background some text and the score text now let's make a button to retry so for that first we make a game object let's call this the retry button then inside we make an image for the background and then also some text say we try okay so now in the button game object we can add the button UI component this is from the code monkey Tonys it save nice and simple component that makes button handling very easy so in here for example we can easily set the button to have a mouseover color so when we pass the mouse over the button the color won't change right so that's it for the editor now let's make a script to handle it so a new csharp script this will be our game over window drag it onto the window now in here the same we did with the score we know let's grab a reference to our text object okay we have the text object now let's also set the button click action so here we have the action that happens when I click on the button let's do the same thing for reloading the scene so over here we have this code we are loading the current scene that some we're going to do and get rid of this from here and just put it in here alright that's it the button should be working now for the score text let's listen to the bird ID event so a private to its start and on cert we go into the bird get instance and subscribe to the on that event when the bird dies this function will be calmed so we have take a score text and text won't be the same thing that we did here on the open window so we get the instance get the fives past count all right that should be updating the text now one final thing is we only want this window to show when the bird actually dies so it's made two simple functions so we have a show and hide function the assembly set the game object to either active or inactive so that it's visible or invisible now on a wake we start off as hidden so we hide it and when we get the bird that we show it alright that should do it the window starts off hidden it shows when the bird dies it updates see text and only we try button we are reloading the current scene so let's see all of that in action okay so here we are and everything starts off stopped let's start jumping and if there you so far so good we have five swings pond and the bird moving now let's hit a pipe and if we're dead and there's the window popping up and indeed we have a score for score four and over here we have our nice button as you can see already has a very nice mouse over effect and when we click on it there you go we are back at the beginning and the scene reloads alright awesome okay so we have pretty much on the main design of our game working we start off with the bird and the completely stopped once we do our first jump everything starts the bird starts jumping the pipe starts bombing over time the pipes get harder as the gaps grow smaller and smaller and finally when I hit a pipe there you go we have a nice game over a window showing our score and having a we try button so we can click and start over okay so everything is great so far we have the basic design working now let's keep going first let's see only the unloading so right now everything works but in this slightly Genki way so when I hit and I click retry it immediately loads just the target seen since the seen loads pre fast this isn't really an issue but it would still be better to have a proper loading screen also our code in here on the game over window we are directly interfacing with the scene manager and using a string to load the target scene which is also not ideal so let's make a proper loading class so we're here in our project files let's make an easy sharp script this will be our loader let's make this a static class to make sure that we don't instantiate it right here let's start off with a public static void load function and now in here instead of receiving a string for the scene that we want load and let's make it nice and new so in here a public you noon call it scene and in here we can fill it up with all our scenes so right now we just have the game scene and on the load we receive a scene as a parameter now for the moment let's do the same thing we did in here so use the scene manager to load scene and instead of a string we use our scene in them okay great this code is now much more clean and now back in the game over window in here instead of that code interfacing directly with the scene manager we now go into the unloaded class in written load and then we pass in a target team okay so everything should still be working exactly the same but the code is now much cleaner let's see okay here we are let's move and die okay there's a game over window hit retry and there you go everything some words say that I'm home the same clean with trolley and everything loads back up okay awesome so now let's deal with the potential issue of our loading screen if they seem to have longer term load then we would essentially have a freeze frame while the scene gets loaded which would make the game unresponsive which is never a good thing so we should really have a simple loading scene so we're here on our scene so let's create a new scene this will be the unloading scene and then here extremely simple we just make a new UI canvas let's add a new UI text just saying loading a method we have an extremely simple loading team so what we want is to first move it into this scene and then we'll load our target scene that way the player knows that the game is loading instead of thinking it might have crashed since the screen is no longer frozen and in here since we made a proper unloader class we don't need to deal with anything over here on the email window we still count the unloader and now in here let's handle our loading scene so the first we have a scene into our enemy so we have the unloading scene and in here first we do see manager can load the scene when the loading scene and then we'll know the target scene however if we do it like this there won't be an issue so let's see it in order to load very scenes let's go into our build settings and in here make sure we have the unloading scene into our scenes in our bill so here we are again let's try dying and seeing now let's see if we see our moving scene and no we did not see it the issue in here is that we're unloading first the unloading scene and then the target scene exactly one segment after the other if there is no update between them then the screen won't actually refresh so we need to make sure that we run an update before we unload our target scene so we can do that with a very simple script let's make a new csharp script this won't be our another update since it won't wait for the first update and here just add it to an empty game object okay let's see the code now in here we just do on our private void update in here and let's just call a function on loader to let it know that we have fired an update and we can unload the target scene so we go into the loader and confection let's say load target scene okay let's make this function over here all we need to do is to store our targeting and in here we load our target team all right that should do it so we should now be able to see the loading scene show up before our target scene in here we're calling load we first moved in loading scene then that loads the unloading scene which runs this script and on the first update it will run this code and this code won't load the final target scene so we should now be able to see it in loading scene showing up okay here we are let's move now let's hit a pipe and the after we honor hit retry any up there you go there was the unloading scene right there now since the final scene load so quickly you can't really see the benefits of this but just imagine you had a lot more stuff into our game here and the game scene would take longer to load previously it would be stuck showing the game over window and being completely unresponsive whereas now it would show the unloading scene and some of the final scene was ready so with our load that are nice and working let's make a main menu we want a very simple main menu where we can just start the game or quit playing now in order to create the main menu we could go in here and create a new scene then we would set up the camera and the UI all over again or let's simply go in here and our game scene so press controld in order to duplicate let's say this is the main menu all right so now in here and let's get rid of all the things related to our game scene and leave only the main camera and UI setup okay so here is our set up scene now in the canvas let's make our main menu so we make a new game object what's going on this the main menu let's stretch it to occupy everything now inside we're going to have just two buttons when to play and when to quit so let's make the buttons the example like we did with the game over retry button so we can actually go there in order to grab it so here's the retry button just copy it and paste it in here okay so here we have our very basic main menu with two very simple buttons now let's make a script to control this so new script for our main menu window and just right in there okay now in here let's go into our price going away to grab a reference to the play button okay so in here on the click function for the play all we need to do is load our game scene so we're going to do the exact same thing with it on the game over window so just load the game scene so copy that yep that's it so the only button should be working again back here in the game we have to remember to go into our build settings in order to add our open scene there you go so we now have our three scenes in our build okay and if we start okay here it is there's a play button click it any up there you go we are now playing okay nice now for the quit button over here in order to quit the desktop all we need to do is call application quit now we can't actually test this right now since if we run and over here we click on the quit button nothing actually happens since this line doesn't run in the editor but if we build our executable it would actually quit our application so just like that we have a fully functioning main menu we start off in here hit play and we are back to playing and we can play and now we can die and go back and retry and nice okay great so now that this is working on the on the GAMEOVER window let's add another button to go back to the main menu so let's go into the game scene over here duplicate the retry button come with the main menu button okay that's our button now in the game over in the code over here we have the code for the retry button and now the code for the main menu button and all we need to do is load our main menu scene so in order to load it all we need to do is add it into our scene and so the main menu and that's it we can now easily load into the main menu let's try okay here we are on the main menu hit play and there you go we are now playing now hit a pipe there's the game over window with a retry and main menu click on main menu and yup we are back on the main menu so we can now quit or play yep okay awesome so we can now start at the main menu begin playing go back to the main menu and quit the game so far our game is completely muted so let's add some nice sounds over here in the project files have had the sounds folder with a bunch of different sounds so one for the party on some button sounds blues and a Scorza the sound effects will create a chip town which is a great free tool to create simple sounds that is an expanded version of another excellent tool which was SFX R so let's create a class to help us play our sounds in here a new C sharp script this will be our sound manager this class won't be responsible for playing all of our sounds so for starters let's make it static so we don't accidentally Senshi ate it now here let's first make a very simple function to play a simple sound so a public static void play sound in here in order to play our sound let's first create a game object we're going to create it with a audio source component now in order to play something we can go into audio source and call play one shot this takes an audio clip and place it once so that means we need a reference for our audio clip so to grab our reference let's add it into our game assets class in here let's just add a public audio clip and let's start with a bird jump okay now back in the same manner let's start playing this one so going to the game assets get the instance and play our bird job alright so this is very simple now to play our song let's go into the bird class in here let's go into our bird jump so here is our jump function and in here we can actually see some manager to play our sound okay that should do it for testing let's try here in the editor and let's go into our game assets and there's our field for our audio clip and let's drag the bird jump okay let's see here we are and when I click yep there you go we got a nice jump sound every time the bird jumps okay great so we can play a simple sound now let's change our code in order to be able to play different sounds so over here on the Sound Manager let's create a new to keep track of all our possible sounds okay we have our sounds and now in this function we receive a sound and now all we need to know is the audio clip that matches this sound so let's go into the game assets in here let's create a class to hold both an audio clip and a sound so a public class let's call it sound audio clip in here we have a public sound manager that sound and a public audio clip I do now in order to see this class in the editor we need to have the serum Liza Vaughn attribute okay so now instead of having references to audio clips we are going to have an array of sound audio clip so now we can go see how this looks in the editor and he appears our game assets with our sound audio clip array so in here and let's fill in all of these values as you can see each element has a sound so that one for the bird Jam when we drag the audio clip and the same thing for all the others okay we have filmed our array with their matching sound a noon and our audio clip now over here what we need to do is identify the audio clip that matches this sound so let's make a function to do just that okay here's our simple function we just do a very simple for each so I go through the entire array see if the sound matches the sound that we're looking for if so return the other clip and here we are supposed to always be able to match a sound with an audio clip in case that doesn't happen let's do a analog error to say that sound was not found and we returned no okay so now we need to do is go up here in order to get the audio clip for this sound okay so this function should be working now let's add our various sound so for Sony burn here on the words on the play sound we pass in the sound of bird jump when the bird dies and let's pass in the loose sound and over here on the unlevel when we increase our current score in here we just play the sound for the score okay our three sounds should now be playable let's see okay here we are everything is quiet now click and you have to jump sound works now let's see the score yep there's a score one two three four okay great now let's see the game over sound yep there you go our nice game over sound they're gonna hit retry again everything song jumps and that's right and game over okay awesome alright so as you can see we have all of our sounds correctly working now let's add the button sounds in order to another button sounds we're going to use something really cool an extension method so let's go into the sound manager and in here we're going to make a function to add button sounds which won't be an extension method of the button UI class so here a public static void let's call it add button sounds and now in order to make this an extension method we add this button UI prior but why the this keyword means that this is an extension method so we're essentially adding the Add button sounds method to the button ey class without actually modifying the code on the button UI class this is a great way for adding extra functionality to a previously written class so in order to use this function we can go for example on the GAMEOVER window and here we have both our buttons so we can simply access the button ey and call Add button sounds as you can see it says that it is an extension method so even though we're calling this method which appears to be called on the button UI this method actually exists in here so now here we can add these sounds to this button okay so we add on to this button UI a function on the mouse over to play the button over and on the mouse click to play the button click alright so let's test and see if our game over window now has sounds ok here we are now let's died and see the game over window yep there you go now let's pass the mouse yep there you go there's our nice sound not this one yep we are or two nice sounds so you can point and there you go a nice button sound now let's add the sound to these ones as well all we need is here on the main menu window and call Add button sounds and everything should be working here we are in the main menu and if we pass the mouse and we have a panel issue the issue here is because the game assets object does not exist in the main menu scene so we're trying to access a reference but there's no reference to be accessed so in solution to this problem is to go in here grab the game assets and making a prefab and I'll back in the main menu and we drag an instance of that same prefab now if we try we should be able to see that we have our references in here mighty pass if there you go that all the buttons work great okay awesome so we have added button sounds as well as fixed a simple problem alright so we are valid sound to our game we created the some integer class to be responsible for all sounds and the other scripts called the play sound to play the sounds when needed so now that we have this working let's deal with saving a high score now we are already calculating the score and displaying it in the UI so let's begin by seeing how we can store some data in order to do that we're going to use player preps this is the simplest way to store persistent data in unity so we're going to use player preps dot set int in order to store the highest score so in here let's test it out we store using a key of high score and let's set a score of 10 so just like this we are setting the play preps high score keen so we're then going to player preps call save and then let's see if the score was correctly saved so we do a debug log go into the player preps and get the int that is stored with the key high score all right so we should be able to see the log same 10 any of here in the console as you can see it doesn't need say 10 so we are correctly saving and loading our high score we can test by taking away this and it won't still say 10 yep there you go still says 10 so we now have persistent that so with this let's add the high score to the score window so here in the corner we have the current score and let's put above it our high score so let's go into the score window we're going to have another text game let's make it in the editor here is the score text let's just duplicate and make the high score text and put it above it just so we can see it okay now let's update it in the code so in here and let's set the high score text on our private voyage start so we set the high score text text and now in here we don't want to deal with the point press directly from our window class so let's make another class that won't deal with this course so over here make a new script this is only our score class in here let's make a function to return the high score so a public static int get high score and here on we're going to do is the same thing with it in here so point predicate end of our high score alright that's it now let's also make this class static to keep things nice and clean ok and now we can go back into our score window then here we can set the high score text to be on these four and we get the high score alright so we're asking the skorca let's return the high score it's only T and we should be able to see the text correctly on display any of there it is a high score which is currently stored as ten right so far so good now let's make a function to set a new high score so on the score class let's make a public static we're going to call it try set new high score and to return a boolean so here we receive a name for the score and essentially this is a function that we're going to call when the bird dies so we get this called with whatever score we have and here we update the high score if it is a new high score so first we get the current high score then we test if this score is higher than the previous one then we have a new high score so with the new one we're going to save it exactly as we did in here we set the end the high score is our new high score and then we return true since we did set a new high score and if not we'll return false which means we did not set any high school all right so far so good now let's go on the game Handler and here let's try calling the function to update the high score to 20 so join to the score and we try seven your high score on let's say 20 ok let's play and see if the score window correctly updated and if they're dizzy score win now says we have a high score of 20 okay so we can read the current high score and save a new one also just for testing let's go in the score and make a function to reset our high score so we can easily test all we do is set the high score back in to zero okay and now let's see where we're going to call our try set new high score the answer is we want to do it when the bird dies so let's subscribe to that event over here now here to subscribe to that event we could use the same pattern we did on the game over window where we have a monobehaviour and on start we subscribe to that event hovering here in order to keep our score class static let's go with a different approach all we need this to I have some sort of start function that we call from somewhere so for example we can have a public static void start and we call this function over here for example on the game hammer we call score dot start and now in here we can subscribe to the bird event so this is just a different approach and we achieve the exact same results pretty much as in here except we don't have to attach our score to any game object using a mana behavior so just a different pattern and here we have the function that is called when the bird dies so we can simply try to set the new high score and now we need the current score so we asked the unlevel for the get our pipes passed count and you try to set it okay so when the bird dies this function is fired which tries to set a new high score so this should be working now the current high score that we have saved is 20 so let's call reset before we do anything so on start we call reset and then we can play so here we are again with the high score of zero now let's start playing and beat the high score so all we need to do is go past one two now let's die and there yo game over we got a three now let's hit retry and we should be able to see high score three any of there it is high score of three now if we just hit one and we die without it zero or we try and yep sunsets three now let's try beating our high score of three okay here we are with the score six which is higher than three let's hit retry and there we go we have a new high score okay awesome so we have pretty much everything working now for one last thing let's set the high score indicator in the game over window so here in the afternoon let's go into the game over window so you have our high score text now let's do the code here on the game over window when the bird dies we show we updated text now let's also get a reference to the high score text so here on let's see if we have beat the new high score so here we're going to either show the current high score or say congratulatory message saying we have a new high score so let's test if the score in this run is a new high score so we can go into the unlevel get the product passed count if this one is bigger than the score dot get the high score if so then we have a new high score so let's set the high score text so it says new high score and if not if not then we just print the corn high score alright let you do it okay here we are let's try dying with just zero so hit this pipe right away there you go zero and it says high score six alright great now let's try to beat our high score so let's go past six pipes okay we have passed our current high score and we die and there you go we have our message saying new high score okay so just like that our scoring system is fully working all right so our game is pretty much completely done we start off with a bird completely sound then I click and the bird starts jumping and everything starts happening the pipes are coming we can cause the birth to jump and get through the pipes over time the pipes will come harder and the gaps become smaller as you can see when I pass the pipe there is the score increasing just like that yep exactly and now when you hit a pipe we have a nice game over window here we can see the score we got in this run as well as the current saved high score then we can quickly hit retry and here we are back again waiting for input so we can play again and over here and if we die again here the other button we have is to go back to the main menu here we are in the simple main menu where we can play or quit alright so the game is completely and fully working now it's time to polish up everything by adding the tiny details didn't make a huge difference first let's fix one quite serious issue which is there's currently no ground so in here if I fall down there you go nothing happens I'm still supposedly alive and the score is increasing forever so let's add a ground that moves along with the pipes you okay so here's our ground it works very much like the pipes so it gets fun moves to the left gets this pond and it's constantly spawning new ones so it goes on for infinity and if we stop if there you go we now can collide with the floor and we can no longer fall towards infinity so here in the scene view you can see how they are being spawn there you go moving to the left and after a while the one on the left gets pushed to the right side and there you go and everything will look seamless and it never ends okay great okay now let's add some cloud sprite you you you you okay so here we have a bunch of cloud sprites they are moving with a slower rate so they look like a nice parallax effect you you you you you you you you okay so we now have had a nice message before we start as soon as we start the message Heights and the high score shows up and also add the nice animation to the GAMEOVER window so there you go when it pops up it gets nicely animated so go and yep pops up nice and like that okay awesome you and now we have the bird animated flapping its wings and when we click it now points up and then starts pointing down based on its velocity all right that's another nice effect okay so here is our final polished game we start off with everything completely stop waiting for our input we can play the game with the keyboard the mouse or even with touch as soon as we press our button the bird starts flying an 11 starts being generated the pipes start coming with gaps in between them we have nice sound effects for the bird jump and every time we pass a pipe the score increases over time as more pipes get spawned the game becomes more difficult to the gaps getting smaller if we hit a pipe the bird dies and we have a nice game over window we are soaring a high score and the current score and now in here we can press retry in order to very quickly try over there you go and now in here if we die again we can see in the game of window we can go back into the main menu click it and we go to a nice very simple main menu or we can either play again or quit the game everything is built correctly so the game works on both desktop and mobile the game is also nicely polished as you can see the bird has a nice animation flapping its wings it rotates up as we jump and rotates down as it starts it fall down we have some parallax clouds at the top and a moving ground at the bottom and the a mover window as you saw has a nice animation we can hit right try and keep trying to beat our high score so in this video we went through the complete creation of flappy bird in unity starting completely from scratch I hope you found along and learn how to make this simple yet interesting game this was a massive video that took a lot of effort to make so let me know in the comments if you like this style of content and would like to see more as always you can download the completed project files in utilities from unity code monkey dotcom if you liked the video subscribe the channel for more ent tutorials post any questions you have in the cart then I'll do my best instrument all right see you next time
