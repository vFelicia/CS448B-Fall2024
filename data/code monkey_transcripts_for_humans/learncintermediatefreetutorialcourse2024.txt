With timestamps:

00:00 - hello and welcome I'm your KMI welcome
00:02 - to the free intermediate section for my
00:04 - complete C Mastery course by going
00:06 - through this course you will learn how
00:07 - to be able to make games websites apps
00:09 - Robotics and literally anything C is an
00:11 - extremely versatile language the core
00:13 - starts from the absolute Basics like how
00:14 - code executes line by line and what is a
00:16 - variable then covering intermediate
00:18 - topics like what are interfaces generics
00:20 - and events and how you can use them to
00:21 - build some really awesome things you
00:23 - will also learn the theory behind how to
00:24 - choose good naming rules clean code
00:26 - guidelines and learn about design
00:28 - patterns and finally the advance section
00:29 - which I'm currently working on and
00:31 - covers quite a lot of advanced topics
00:33 - right now there's a handful of lectures
00:34 - already out and I'm constantly uploading
00:36 - more now this free YouTube over here
00:37 - this one contains all the video lectures
00:39 - for the intermediate section like I said
00:41 - in the previous video my goal is to
00:42 - publish the video lectures over here for
00:44 - free on YouTube if the premium version
00:46 - sells a certain number of copies and I'm
00:48 - very happy to report that has indeed
00:50 - passed that threshold which is why this
00:51 - video is over here for you on YouTube
00:53 - I've already posted a video with all of
00:54 - the free video lectures for the beginner
00:56 - section and in about 2 to2 months I will
00:58 - publish the free video with the advance
01:00 - section so if you're watching this in
01:01 - the future check the link in the
01:02 - description to see links for both of
01:03 - those the premium version of the course
01:05 - has all the video lectures for all the
01:06 - sections and also has a bunch of really
01:08 - nice bonuses So speaking of that here
01:10 - are the bonuses for the premium version
01:12 - I came up with some that I think are
01:14 - really awesome and definitely worth it
01:15 - if you can't afford it well at the same
01:17 - time not putting any knowledge behind
01:18 - the pay wall so even people who can't
01:20 - afford it they can still learn from the
01:21 - free lectures they really just need to
01:24 - do a little bit of extra work themselves
01:25 - the premium version is really just
01:27 - selling convenience making it really
01:28 - easy for you to truly gain the knowledge
01:30 - the premium version comes with a
01:32 - companion project this is a Unity
01:34 - project that contains a bunch of extra
01:35 - content basically the video lectures
01:37 - won't being preas themselves there's
01:39 - still really only half the course the
01:41 - other half of it is inside of this
01:42 - project it has a bunch of custom editor
01:44 - Windows to guide you through each
01:46 - lecture and each lecture has a section
01:48 - on frequently asked questions these are
01:50 - common questions that have some really
01:51 - detailed answers that provide even more
01:53 - details on what is covered in the
01:54 - lecture then there are some quizzes
01:56 - these are multiple choice questions
01:58 - again all with very detailed anwers it's
02:00 - really not just correct or incorrect if
02:02 - you pay close attention to each lecture
02:04 - you should be able to get most of these
02:05 - right but whether you do or don't by
02:07 - reading the extra explanation that will
02:08 - help you truly learn that topic then the
02:10 - interactive exercises I'm really happy
02:12 - with this feature I think this will
02:14 - really help you learn learning by doing
02:16 - is always much better and these
02:17 - exercises encourage you to put what you
02:19 - learned into practice instead of just
02:20 - blindly watching the video lectures I
02:22 - designed a ton of hcraft exercise for
02:24 - all the lectures to help you put into
02:26 - practice and truly learn the contents of
02:28 - each lecture there are all kinds of
02:29 - exercises some are about spotting and
02:32 - fixing errors others are about asking
02:33 - you to Define some function or class or
02:35 - Implement some kind of logic there are
02:37 - some where you just write code and
02:38 - somewhere you write code and then play
02:40 - the code in unity in order to complete
02:41 - the exercise then each exercise also
02:43 - contains a hint just in case you get
02:45 - stuck or a solution in case you get
02:47 - really stuck as well as a video
02:49 - walkthrough of me going through that
02:50 - exercise and completing it while
02:51 - explaining everything in detail so you
02:53 - heard the kind of person who gets stuck
02:54 - in tutorial hell then I truly believe
02:56 - that this will really help you escape it
02:58 - in order to learn need to actually do
02:59 - things and and this exercise encourage
03:01 - you to do that they encourage you to do
03:02 - it as opposed to just blindly watching
03:04 - the video lectures then the companion
03:06 - project also has a companion window
03:08 - basically this window is also listening
03:09 - to a bunch of errors and if it finds one
03:11 - it will help guide you in the right
03:12 - direction I manually wrote a ton of text
03:14 - for when text lots of errors all of them
03:17 - based on common errors that I see people
03:18 - ask about in comments in my own videos
03:20 - so this should help prevent you from
03:22 - getting stuck in your Learning Journey
03:23 - and allow you to get help instantly then
03:25 - the course also has an AI to help you
03:27 - answer questions this one was trained on
03:29 - the contents of the course and my own
03:31 - knowledge so it should be very accurate
03:32 - and helpful but more than that it's
03:34 - simply the fact that it is extremely
03:36 - fast you post a question in the course
03:37 - comments and within a few minutes the a
03:39 - will respond with probably a very good
03:41 - answer although of course I myself will
03:43 - also still be answering all the
03:44 - questions manually the goal with this AI
03:46 - is really speed so you get a response
03:47 - almost instantly and then within the
03:49 - next few hours I will manually answer
03:51 - myself then a simple bonus is how the
03:53 - premium version has the course split
03:54 - into lectures as opposed to Here on
03:56 - YouTube where it will be one giant video
03:58 - it has to be that way the how the
04:00 - YouTube algorithm works this is a small
04:01 - thing but it can be helpful especially
04:03 - if you take your time to slowly go
04:04 - through the course just like you should
04:06 - do remember that the only goal is really
04:08 - that you are actually learning yourself
04:10 - it does not matter how quickly you go
04:11 - through it so separate lectures help
04:13 - with that so that you can pause and
04:14 - actually try out your knowledge before
04:16 - going further and you don't have to
04:18 - memorize specific time stamps and over
04:20 - here on YouTube the videos have the
04:21 - normal YouTube ads as usual whereas the
04:23 - premium version has no ads so there's
04:25 - nothing to interrupt you while you're
04:26 - learning another two great bonuses is
04:28 - the private Discord and and thean live
04:30 - study group you get access to a private
04:32 - Discord with a really nice community of
04:33 - people all on their own Learning Journey
04:35 - I'm there myself as much as I can to
04:37 - answer questions or really just chat and
04:38 - every week I also do a private life QA
04:41 - you can join me on the live stream and
04:42 - ask anything you want and I'll do my
04:43 - best to help so these are the nice
04:45 - bonuses that I came up with that I think
04:46 - are really nice and really awesome while
04:48 - not taking away anything or putting any
04:50 - knowledge behind the pay wall if you can
04:52 - afford then I highly recommend the
04:53 - premium version these bonuses will help
04:55 - you truly learn and learn much much
04:57 - faster than the 10 years that it took me
04:59 - but if you can important that's okay
05:01 - like I said there's no hidden knowledge
05:02 - hidden behind the paywall you really
05:04 - just need to put more effort in yourself
05:05 - in order to actually apply knowledge
05:07 - that you gain so whether you get the
05:08 - premium version or watch your free
05:09 - lectures I really hope you'll learn a
05:11 - lot also just in case you're new to my
05:13 - channel so a bit about me and my
05:14 - credentials or why you should listen to
05:16 - what I have to teach for me I've been
05:18 - programming for over 25 years and
05:19 - specifically using C for over 10 years
05:22 - I'm a professional indie game developer
05:23 - with several successful games PO on seam
05:25 - covering a wide range of genres my games
05:27 - are usually focused on complex systems
05:29 - since I am merely a programmer it's what
05:31 - I really love to do and what I love to
05:32 - teach also a couple of years ago I
05:34 - started over here this YouTube channel
05:35 - making free video tutorials to basically
05:37 - share my knowledge to help you learn how
05:39 - to make your own games there's already
05:41 - over 800 free videos over here on this
05:42 - channel if you want to continue learning
05:44 - Beyond this course also one very
05:45 - important note for both beginners but
05:47 - also for intermediate users which is
05:49 - simply take your time take it slow
05:51 - remember this is your Learning Journey
05:53 - no one else's the only thing that
05:54 - matters is that you're learning it does
05:55 - not matter how long it takes you so it
05:57 - does not matter if someone learns all of
05:58 - this much faster than than you you are
06:00 - really not in competition with anyone
06:02 - but yourself also you are not expected
06:04 - to go through this course in one day one
06:06 - week or even one month basally all the
06:08 - content out of this course this contains
06:10 - knowledge that took me 10 years to learn
06:12 - so really just take it slow take your
06:13 - time and really just focus on learning
06:15 - and one final request if you find this
06:17 - video helpful if so go ahead and hit the
06:19 - like button and subscribe to the channel
06:21 - it's a tiny thing but it really does
06:22 - help all right so let's get to the first
06:25 - lecture hello and welcome I'm your KMI
06:28 - welcome to the intermediate section
06:29 - we're going to take things up a notch
06:31 - and learn some more intermediate
06:32 - Concepts but before we do let me just
06:34 - quickly say if you are still very much a
06:36 - beginner If the previous section was
06:37 - your very first exposure to any kind of
06:39 - programming if so then just be aware
06:41 - that it's perfectly normal that it takes
06:42 - you some time in order to understand the
06:44 - context of this intermediate section
06:45 - that's perfectly normal learning and
06:47 - trally understanding all that we're
06:48 - going to see all of that takes quite
06:49 - some time remember that the only thing
06:51 - that really matters is that you're
06:52 - learning how long it takes you isn't
06:54 - really relevant so really just focus on
06:55 - actually understanding actually learning
06:57 - for me it took me literally decades to
06:59 - learn and all of this so if it takes you
07:01 - 6 months to go through this intermediate
07:02 - section if so then you're still going to
07:04 - be doing much much better than me so all
07:06 - that to say take your time and just
07:08 - focus on learning now if you took a
07:09 - break between the beginner section and
07:11 - this one then I encourage you to go back
07:12 - and at least rewatch The naming lecture
07:14 - and the clean code principles I put
07:16 - those two lectures in the beginner
07:17 - section just because I want the
07:18 - beginners to be aware of it but as you
07:19 - grow as a programmer as you become an
07:21 - intermediate those two concepts naming
07:23 - rules and clean code principles those
07:25 - become even more important to fully
07:26 - understand and fully apply so if it's
07:28 - been a while since you saw the beginner
07:29 - section go ahead and rewatch those just
07:31 - quickly and with that that's the intro
07:32 - out of the way so let's go into the next
07:34 - lecture where we're going to see a nice
07:35 - overview of everything that we're going
07:36 - to learn in this intermediate section
07:39 - hello and welcome I'm your Cod monkey in
07:42 - this intermediate section we're going to
07:43 - go one level up relative to the beginner
07:45 - section and learn some more complex
07:47 - stuff so let's see an overview of all
07:48 - the lectures beginning with something
07:50 - very important that I debated whether I
07:52 - should put in the beginner section it's
07:54 - going to be Visual Studio shortcuts I
07:55 - end up putting it here because for
07:57 - beginners technically it's more
07:58 - important to learn how to write WR the
07:59 - code and it's not as important to be
08:01 - extremely efficient with how fast you
08:03 - use your ID but for intermediates this
08:05 - is a must have so we're going to learn
08:07 - about a ton of shortcuts to help you
08:08 - write code and navigate your environment
08:10 - much better then comes one of the most
08:12 - important lectures in this whole
08:14 - intermediate section it's all about
08:15 - refactoring this is the process of
08:17 - rewriting your code to make sure it is
08:19 - as readable and understandable as
08:21 - possible as an intermediate you
08:22 - absolutely need to know that this is a
08:24 - natural part of the code writing process
08:26 - and something you should not skip next
08:28 - is a lecture on s pretty simple and very
08:30 - useful it's how you can define a
08:32 - specific list of values that you can use
08:34 - in many ways after that we'll learn
08:36 - about properties which are kind of like
08:37 - a mix between variables and functions
08:40 - then we're going to learn about
08:41 - multi-dimensional arrays meaning arrays
08:43 - that can hold multiple dimensions of
08:44 - data after that we're going to learn
08:46 - about Ness Loops which is especially
08:48 - important in order to cycle through
08:49 - multi-dimensional arrays next we're
08:51 - going to learn another method for doing
08:53 - some looping logic we're going to learn
08:55 - about recursion this is something that
08:56 - for people with a math background it
08:58 - might actually be similar to understand
09:00 - than R Loops then we're going to learn
09:02 - about an extremely useful data type the
09:03 - dictionary this is a key value pair that
09:06 - has tons of really awesome use cases
09:08 - after that we're going to learn about
09:09 - some more collections like q and stack
09:11 - then we're going to learn about the
09:13 - prams keyword and what exactly does it
09:15 - do in a function next we'll learn about
09:17 - optional parameters how to define them
09:19 - and how to call them from a function
09:21 - then another crucial lecture for
09:22 - intermediates this one is on learning
09:24 - the differences between value and
09:26 - reference types this is extremely
09:27 - important if you don't know this
09:29 - difference then you will go crazy at
09:30 - some point in the future wondering why
09:32 - something isn't changing and it's
09:33 - usually going to be because you don't
09:35 - know you're working with a copy and not
09:36 - a reference related to that is the
09:38 - lecture on structs these are similar to
09:40 - classes but importantly they are a value
09:42 - type next we're going to learn some more
09:44 - intermediate use case for classes we're
09:46 - going to learn about inheritance
09:48 - polymorphism and a bunch more then learn
09:50 - about interfaces this is one of my
09:52 - favorite features of csharp it allows
09:54 - you to write some really nice modular
09:56 - code related to that we're going to see
09:57 - various ways of testing for types and
09:59 - converting to and from various types
10:02 - also related is the lecture on switch
10:03 - pattern matching this is a really simple
10:06 - way to do a switch not just on value but
10:08 - also on type then we're going to learn
10:09 - all about delegates lambdas and
10:11 - Anonymous functions this is how we can
10:13 - store a function itself inside a field
10:16 - next we're going to learn the
10:17 - differences between lambdas and local
10:19 - functions after that we learn about
10:21 - events which is how we can have one
10:22 - class we notified when something happens
10:25 - then the next lecture that one is going
10:26 - to be all about generics this is another
10:28 - super power powerful C feature that
10:30 - makes your code work with multiple types
10:33 - next is a simple lecture on constant and
10:35 - read only what they are and what are the
10:37 - differences between those two after that
10:39 - is a lecture on exceptions and how to
10:41 - handle them with a try catch then a
10:43 - lecture on implementing I numerable so
10:45 - we can add support for something like a
10:47 - 4 in for some custom types next we're
10:49 - going to learn about namespaces what
10:51 - they are and how to make your own then a
10:53 - really important lecture on one of the
10:55 - most important design patterns the
10:56 - single T pattern and after that is a
10:58 - general over review of a bunch more
11:00 - design patterns and finally after doing
11:02 - all of that we're going to check out the
11:03 - intermediate project that uses all of
11:05 - this to make something really
11:07 - interesting hello and welcome I'm your
11:09 - codm in this lecture we're going to
11:11 - learn about a bunch of really useful
11:12 - Visual Studio shortcuts okay so as we
11:15 - get to the intermediate Sage it is
11:16 - really important to be good at using
11:18 - your tools and as a programmer your main
11:20 - tool is going to be your ID so you
11:21 - should be very comfortable with
11:23 - shortcuts and moving around your codeb
11:24 - base but also this is something that you
11:26 - pick up with experience so this lecture
11:28 - this one is really not meant to be a
11:29 - step-by-step lecture but rather I just
11:31 - want to show you a bunch of shortcuts
11:33 - that I use myself just so you are aware
11:34 - they exist and over time you won't pick
11:36 - them up and they won't become more and
11:37 - more natural okay so the most basic but
11:39 - honestly most useful one is simply
11:41 - moving the cursor normally beginners
11:42 - they use the mouse to move around so
11:44 - they scroll down and click wherever they
11:46 - want to write and then sometimes
11:47 - beginners use the arrow keys and they
11:49 - press it like a million times in order
11:50 - to get wherever they want to go
11:52 - technically this works but it's
11:53 - obviously not very efficient there are
11:54 - many ways to speed this up and
11:56 - importantly many ways to navigate your
11:57 - code base without your fingers ever
11:59 - leaving the keyboard for example when
12:00 - moving left to right technically you can
12:02 - indeed just press the right arrow key
12:04 - and eventually you won't get there but
12:05 - as you can see going left to right like
12:07 - this takes quite a while I got to press
12:09 - like some like 50 times in order to get
12:11 - to the beginning or the end so one of
12:12 - the best super simple shortcuts is
12:14 - simply to hold down the control key and
12:15 - now as you move left and right yep
12:17 - instead of going letter by letter it
12:18 - goes word by word so that way now I can
12:20 - get to the beginning or the end of this
12:22 - line in just about four five presses
12:23 - instead of being like literally 50 so it
12:25 - is literally 10 times faster then of
12:27 - course you also have the home and end
12:29 - key I use these all the time especially
12:31 - when combined with shift for quickly
12:32 - selecting something so for example if I
12:34 - want to move this line above the
12:35 - Southern Line if so then us what I do is
12:37 - press end to go to the end of this line
12:39 - then hold shift and press up to select
12:41 - and now press end again in order to
12:42 - select just that one then I press CR X
12:44 - to cut I move up press contrl V and yep
12:47 - like that so if you do it pretty quickly
12:49 - it goes quite fast very easy to do all
12:51 - this and again I did all of that without
12:54 - ever my fingers leaving the keyboard if
12:56 - I were to use the mouse I would have to
12:57 - select like this crl x go like this like
12:59 - this so in this case not much of a speed
13:01 - difference but just the fact that your
13:03 - fingers never have to leave the keyboard
13:04 - that alone is a huge bonus and again on
13:06 - all these shortcuts we're going to see
13:07 - how differen is usually pretty small
13:09 - like saving like a second 5 seconds or
13:12 - fractions of a second so that does sound
13:13 - like a super tiny amount but considering
13:15 - how you're probably going to be
13:16 - programming for many years and you're
13:18 - going to write millions of lines of code
13:19 - throughout your entire life when you
13:21 - look at it like that those tiny amounts
13:22 - of time they really add up so that's the
13:24 - main thing just moving left and right
13:26 - holding control to go between each word
13:28 - or using and then home in order to go
13:30 - back to the beginning and the end and
13:31 - combining all of that with shift in
13:33 - order to really move around super
13:34 - quickly so that's the first tiep and
13:36 - then for something that is sadly not
13:37 - default is moving the cursor up and down
13:39 - so by default if you do that it
13:41 - obviously only moves one line at a time
13:43 - so again the same thing in order to move
13:45 - down 20 or 30 lines that actually takes
13:47 - quite a lot of pressing in order to move
13:48 - and by default the alternative is using
13:50 - page up or page down although personally
13:52 - I'm not a big fan of this I find that
13:53 - these move the cursor way too much so
13:55 - every time I press page down it takes me
13:57 - quite a while to realize where the
13:59 - cursor is and how much actually moved so
14:01 - I don't like how this moves way too much
14:02 - so in my code I added something so that
14:04 - I can move the cursor up and down
14:06 - vertically by just five lines that way I
14:08 - can very easily go down and continue
14:10 - scrolling down and I'm never lost
14:12 - because the screen never changes a
14:13 - massive amount I'm always moving down
14:14 - moving up select this line of code do
14:16 - something move down write something so
14:18 - on now sadly this behavior isn't
14:20 - available by default in Visual Studio at
14:22 - least not that I know of so for this I
14:24 - installed this extension called visual
14:26 - Commander this one lets you basically
14:27 - apply some hotkeys to l anything you can
14:29 - do in visual studio and then with that
14:31 - install just go up here into extensions
14:33 - and here is the V command and on this
14:35 - one here are some commands that I made
14:37 - so here is the window so I've got move
14:38 - up and move down so I can edit in order
14:40 - to see what this is doing and yep it is
14:42 - executing the command line up so
14:44 - literally just moves the line up and the
14:45 - other one this one does the same thing
14:47 - but line down so I've got these two
14:48 - commands here if I have the cursor
14:50 - somewhere and I go into that extension
14:52 - and I use the move up command yep it
14:53 - does move up by six lines so then as you
14:55 - can see I just assigned some keyboard
14:57 - shortcuts to those so control up and
14:59 - control down then I just went into tools
15:01 - options and over here go down into the
15:03 - keyboard shortcuts and then find vs
15:06 - command and up here command one command
15:07 - two those are two ones that I made and
15:09 - as you can see I've have assigned them
15:10 - to control up arrow and control down
15:12 - arrow so all that if I press control up
15:14 - or control down as you can see the
15:15 - cursor moves quite a lot faster so I
15:17 - find this to be much better than just
15:19 - pressing one just moves one line or
15:20 - pressing page up which always causes me
15:22 - to lose and get lost so with just these
15:24 - steps you can see how I can move in the
15:26 - code really fast without ever touching
15:27 - the mouse like let's say want to go down
15:29 - I want to find for example the awake I
15:31 - want to select the awake I want to cut
15:33 - it and paste it down here and there you
15:34 - go just like this and remove these lines
15:36 - form met and so on so as you can see
15:38 - just using these control in order to
15:40 - move between the words using this
15:41 - shortcut in order to move vertically
15:43 - really fast and combined with home and
15:45 - end and with shift and all that put all
15:47 - those together and yep you can move
15:48 - through the cursor you can move in your
15:50 - code base really quickly without ever
15:51 - leaving the keyboard then of course if
15:53 - you're working on some kind of Big File
15:55 - like for example this is the player
15:56 - class from my steam game dinky Gardians
15:58 - so this a pre massive class for this one
16:00 - if I want to get to the bottom and if I
16:02 - go even with this short this is going to
16:04 - take quite a while so for that one if
16:05 - you want to move a massive amount you
16:07 - can use control home or control end in
16:09 - order to go to the beginning or the end
16:10 - the file so this is yet another way to
16:11 - very quickly move around and another
16:13 - very useful one for moving around is
16:15 - simply put the cursor on top of some
16:17 - kind of symbol like for example let's
16:18 - say this one this event on player picked
16:20 - up the experience and then if you press
16:22 - control shift and either up or down this
16:25 - will move the cursor to the next or
16:26 - previous reference of that symbol so for
16:28 - example over here you can see how it's
16:29 - really useful how in this huge line of
16:31 - code this script has almost a thousand
16:33 - lines of code but I can very easily see
16:35 - exactly where this one is being
16:36 - referenced I just move up and down yep
16:38 - here is the definition and here is where
16:39 - I'm using it so whenever you want to see
16:41 - all the various places in which you are
16:42 - using some kind of symbol that can be a
16:44 - function can be an event can be a
16:46 - variable can be literally anything just
16:47 - hold down control shift and then up and
16:49 - down and you can see all the places in
16:51 - which that symbol is being used then
16:52 - another extremely useful shortcut that I
16:54 - use all the time is control and comma
16:56 - this one pops out this window and now
16:58 - here you can search for any class you
17:00 - just typee a name and find it like for
17:02 - example I want to open up the dinky
17:04 - class so I'm going to type in dinky and
17:06 - now just one thing is this shows
17:07 - actually every symbol so in this case in
17:09 - this game since it's all about dinkies
17:11 - I've got tons of references to dinkies
17:13 - so you can see all of these in lower
17:14 - case I usually write my variables in
17:16 - lowercase so I know that's not the one I
17:18 - know the one that I want in order to
17:19 - open the file is the actual file itself
17:21 - so I can type in dinky docs and yep that
17:23 - does show the file press enter and yep
17:25 - here I am the dinky file and again press
17:27 - control home to get the beginning yep
17:29 - here's the dinky definition and I can
17:30 - see all this code just like this so if I
17:32 - want to move to like the tutorial
17:34 - manager so I just write tutorial manager
17:36 - just right a little bit yep I can
17:38 - already see this one so this the class
17:39 - we can also see the icon over there so
17:41 - that one means a f that one means a
17:43 - class this one means an event and so on
17:45 - so I can see this one press enter and
17:46 - yep here I am in this one and again move
17:48 - up move down everything works again note
17:50 - how throughout all of this my fingers
17:52 - never leave the keyboard I never touch a
17:53 - mouse so personally whenever I'm making
17:55 - my games and I want to open another
17:56 - class I never go into unity and manual
17:59 - double click on that file I always do it
18:00 - over here press control comma search for
18:02 - anything press enter and it opens or
18:04 - alternatively for example that one that
18:06 - I mentioned when you got tons of
18:07 - references something like over here tons
18:09 - of references to a dinky so I can just
18:10 - go into this one and then I can put the
18:12 - cursor on top of the type itself and I
18:14 - press on F12 and Yep this one takes me
18:16 - to the class definition F12 is a
18:18 - shortcut but if you want to use the
18:19 - mouse you can also just right click on
18:21 - it and over here we can see yep F12 is
18:23 - indeed a shortcut to go to definition
18:25 - now since we're here with the mouse one
18:26 - really useful one is over here the fine
18:28 - all references when you click on this
18:30 - this is going to show all of the
18:31 - references to that type so this can work
18:34 - with whatever is under the cursor so in
18:36 - this case I select the dinky class so
18:38 - this is going to show me all of the
18:39 - places in my entire code base where the
18:41 - dinky class is being used or
18:42 - alternatively you can put it just on a
18:44 - field and yep now this one is going to
18:46 - show all the places and you can click in
18:47 - order to automatically go to that line
18:49 - and of course it also works with
18:51 - functions so for example over here this
18:52 - function I'm pressing control shift up
18:54 - and down in order to see all the
18:55 - references within this file but this
18:57 - function is not called from within this
18:58 - F so in order to find where on Earth am
19:00 - I calling this again right click go to
19:02 - references and if I can see okay so it's
19:04 - being called from this script right here
19:05 - inside dinking manager it's calling this
19:07 - function another really useful use case
19:09 - for that particular one is when working
19:11 - with interface so let's say I want to
19:12 - see all the class that implement this
19:14 - interface again right click find all
19:16 - references and if I can see all of these
19:18 - look at these these are all implementing
19:20 - the UN interactable interface then
19:21 - something that I use all the time is
19:24 - control RR that is the shortcut for
19:26 - renaming the current symbol so I just
19:27 - plac the cursor for example over here on
19:29 - top of the is moving field press control
19:31 - RR and now let's say I want this to be a
19:33 - little bit more descriptive so is player
19:35 - moving so I change that and note how
19:38 - again the other shortcut control shift
19:39 - and up and down note how this one did
19:41 - rename every single reference of this
19:43 - symbol so all of those I don't need to
19:45 - change them just modify them once use
19:47 - the rename feature and automatically
19:48 - renames all of them and if I find out
19:50 - that the previous one works better again
19:52 - just edit go ahead remove this press
19:54 - enter and Y there you go all of those
19:56 - have now been renamed remember that
19:58 - refact ing is an extremely important and
20:00 - importantly it's a perfectly normal part
20:02 - of the process in fact the next lecture
20:03 - is entirely dedicated to the topic of
20:05 - refactoring if there is something that
20:07 - you wrote some name but then later on
20:08 - you think it should have a better name
20:10 - just take some time in order to rename
20:12 - it simp place the cursor over it press
20:14 - contr RR write the new name and it will
20:16 - automatically rename every instance of
20:18 - that symbol this works on everything
20:20 - everything from simple variables to even
20:22 - entire classes and it even renames every
20:24 - single reference in your entire code
20:25 - base so for example here I am on the
20:26 - dinky class which is used throughout the
20:28 - entirety of this code base I can press
20:30 - control RR and I can modify this whole
20:32 - thing and say something and Y like it
20:34 - says here rename will update 297
20:37 - references in 58 files so this rename
20:39 - feature is really awesome really useful
20:41 - it automatically handles modifying
20:42 - everything and everything is handled
20:44 - automatically for you then when you have
20:46 - multiple windows open for moving between
20:48 - them you can use control tab if you just
20:50 - use one it goes back and forth between
20:52 - the last open tab so this is something
20:54 - that I use all the time whenever I'm
20:56 - working between two files and I want to
20:57 - quickly move between them but instead of
20:59 - doing just that and letting go you can
21:01 - hold down control and tab and as long as
21:03 - you hold down control you can see this
21:05 - window and over here you can move up or
21:06 - down in order to move between all the
21:08 - various windows that you have open so
21:10 - for example let's say I want to go into
21:11 - dinky off world yep there you go now I'm
21:13 - looking at this class and if I quickly
21:15 - control tab I go back into the previous
21:17 - class and this tab over here this one
21:19 - only works for the windows that are open
21:21 - so again the same thing if you want to
21:22 - open up a new window just press contrl
21:24 - comma open the window let's say for
21:26 - example I want to find the carry vehicle
21:28 - so I just type in the carry vehicle yep
21:29 - it's right here control enter and this
21:31 - one opens up the carry vehicle class now
21:33 - control Tab and off want want I go back
21:34 - to the link key and move between them
21:36 - like that then here's a really simple
21:38 - one you can raise an entire line by just
21:40 - having the cursor anywhere on that line
21:42 - pressing contr X that one cuts the
21:44 - entire line that one acts as a cut
21:46 - meaning if you press contrl + V you get
21:47 - the line back alternatively for
21:49 - duplicating you can press contrl D
21:51 - although honestly I rarely ever use this
21:53 - one because I can never remember whether
21:54 - it's going to duplicate on the line
21:56 - above or below it so usually if I want
21:58 - to duplicate something I just do the
22:00 - shortcuts that I mentioned a while ago
22:01 - so end above and cut move cut and so on
22:04 - now speaking of copy paste if you press
22:07 - control shift and V if you do that you
22:09 - get a list of your clipboard history so
22:11 - for example a while ago I showed cutting
22:13 - the awake class and yep it is still
22:15 - saved in here so if I press on enter yep
22:17 - it paste that one exactly like that so
22:18 - remember that your clipboard has history
22:20 - it is not just the last thing that you
22:21 - copied you can access the entire history
22:23 - another useful tiny time saer is
22:26 - actually when using the mouse when using
22:27 - that if you want want to select some
22:29 - kind of word some kind of symbol
22:30 - obviously you can do the basic thing
22:32 - which is just click and hold and drag
22:34 - throughout to select it so obviously
22:35 - that works but it's a little bit fiddly
22:37 - if you move up or down can be quite
22:38 - tricky so the similar shortcut for that
22:40 - whenever you want to select some kind of
22:41 - word you can just double click and it
22:43 - select it or alternatively hold down
22:45 - control and click in order to select the
22:46 - entire thing this can be quite useful
22:48 - for example when you have some copy
22:49 - pasted code and you want to change some
22:51 - kind of name but for some reason the
22:53 - rename function doesn't work like for
22:54 - example let's say I want to duplicate
22:56 - this code over here so right now I
22:57 - cannot use rename because this one is
22:59 - going to conflict with that one so
23:01 - instead let's say the active dinky list
23:04 - so I press I select this one control
23:06 - click and there you go like that and if
23:07 - I want like that so control click in
23:09 - order to do control V and so on this one
23:11 - can be quite useful sometimes then
23:12 - something that I only very rarely use is
23:15 - shift and ALT hold those and then move
23:17 - upward down and this one basically lets
23:19 - you select multiple lines of code and
23:21 - edit them at the same time like I said I
23:23 - rarely use this but sometimes can be
23:25 - useful for example for quickly appending
23:27 - or removing some kind of
23:28 - like for example on this enome I've got
23:30 - these values I want to write all of them
23:32 - and say tier one tier two and so on so I
23:34 - can select all lines and write here and
23:36 - writes on all of them or alternatively
23:37 - if this one did have it and I want to
23:38 - remove them just select them all and I
23:40 - can remove them so basically you can
23:41 - write code on multiple lines at the same
23:43 - time and if you want to quit this just
23:44 - press escape and yep back into a single
23:46 - cursor another Super useful one is when
23:48 - working with events like for example the
23:49 - on any dinky started starving so I can
23:51 - just write the event name then plus
23:54 - equals and then here Visual Studio
23:55 - automatically has a shortcut so you can
23:57 - press tab to insert start then if you
23:59 - want you can rename it but usually I
24:00 - keep the exact same name that it
24:02 - suggests so just press enter and Y there
24:04 - you go I've got a new event now I can
24:06 - come here and again use the shortcut
24:07 - contr X to get rid of that go above go
24:09 - to the end press enter go to new line
24:11 - then write some new code so really
24:13 - useful and if afterwards you decide that
24:16 - you want a better name for this event
24:17 - again remember just say quick control RR
24:19 - in order to rename then if you want to
24:21 - find something of course you have contrl
24:22 - f for example finding when I'm invoking
24:25 - some kind of event so just write invoke
24:26 - and if it finds it obviously nor then
24:28 - the shortcut for going to the next
24:30 - element that one is pressing on F3 and
24:32 - it goes to the next one so it finds that
24:34 - one that one that one and so on in order
24:35 - to go to the previous one you use shift
24:37 - F3 and goes backwards also by the way
24:39 - this works whether the control F window
24:41 - is open over there but if I press ones
24:42 - in order to close down that window and
24:44 - with this if I press an F3 yep it still
24:46 - remembers the last thing that I searched
24:47 - then for quickly commenting or
24:49 - uncommenting something you can do contrl
24:51 - KC and yep it automatically comments
24:53 - that entire line and if you have
24:55 - multiple lines selected control KC yep
24:57 - automatically comments the opposite to
24:59 - uncomment is control KU and yep
25:01 - automatically uncommons that although
25:02 - personally I never really use this one
25:04 - myself again it goes back to how I'm so
25:06 - proficient at just moving the cursor so
25:07 - if I just want to comment all of these I
25:09 - just do the common star go down there
25:11 - common star there you go just like this
25:13 - another useful shortcut is extract
25:15 - method so you can select a whole bunch
25:17 - of code then press contrl R and M and
25:19 - this one creates a new method with that
25:21 - code so let's say setup and if there you
25:23 - go pretty much took that code and plac
25:24 - it in its own method so this can
25:26 - sometimes be useful although again this
25:27 - is another one that I don't really use
25:29 - myself because again I'm prettyy fast at
25:30 - just moving the cursor so if I want to
25:32 - do this kind of thing I really just go
25:34 - into the code that I want I just go I
25:36 - use I move the cursor move up move down
25:38 - then do private void my setup do some
25:41 - kind of function then write it just like
25:42 - this and everything works if you want to
25:45 - go to a certain line you can press
25:46 - control and G this one lets you input
25:48 - some kind of line num so let's say let's
25:50 - see what is that line 500 so just type
25:52 - in 500 and yep there you go here we are
25:54 - on line 500 now for this one normally I
25:56 - don't really use it when writing code
25:58 - code but I do use this one quite a lot
26:00 - when writing the text script for my
26:01 - courses since normally I write my course
26:03 - in a simple text file sometimes it has
26:05 - tens of thousands of lines so for that
26:07 - usually I like to move around by using
26:08 - the line number although in the code I
26:10 - never really have such massive files so
26:12 - I don't normally tend to use it but it's
26:13 - only a nice thing to know then of course
26:15 - the one that you already know if you
26:16 - make some kind of mistake control Z in
26:18 - order to undo and one you might not know
26:20 - is control shift Zed in order to redo
26:22 - then for moving between visual stud and
26:24 - unity just a simple alt tab so just once
26:26 - and moves or if you have multiple files
26:28 - just keep pressing Tab and perhaps the
26:30 - simplest and most useful one is simply
26:32 - autocomplete I really advise you to get
26:33 - comfortable with how autocomplete Works
26:35 - learn how to just type a few lectures
26:38 - and then either press enter or dot or
26:40 - semicolon in order to quickly
26:41 - autocomplete honestly I don't remember
26:43 - the last time that I were something like
26:44 - for example try get component I just try
26:46 - a little bit and write like that for
26:48 - example dinky just like this then out
26:50 - Dinky Dinky just like this super simple
26:53 - so just get used with how little you
26:55 - have to write in order to press enter in
26:57 - order to automatically write everything
26:58 - everything else this works with Fields
26:59 - but obviously it also works with things
27:01 - like functions it works with classes it
27:03 - works with literally anything okay so
27:05 - that was a lot of shortcuts personally I
27:07 - use a lot of these all the time but
27:08 - again I've been writing code for over 25
27:10 - years if you're not used to using
27:12 - shortcuts then I really don't expect you
27:13 - to suddenly use all of these right away
27:15 - all at once like I said this lecture
27:17 - this one is really not meant to be a
27:18 - step-by-step lecture for the most part
27:20 - right now I just want you to memorize
27:22 - the first ones that I mentioned about
27:23 - how to move through the cursor quickly
27:25 - just memorize those and simply remember
27:26 - that the other ones exist then
27:28 - periodically come back to this lecture
27:29 - every once in a while and watch it again
27:31 - if you do that several times over the
27:32 - next few months then soon enough all of
27:34 - these shortcuts that I mentioned all of
27:35 - these will be natural to you just like
27:37 - they are to me hello and welcome I'm
27:40 - your KMI in this lecture we're going to
27:42 - learn all about refactoring okay so
27:44 - before we learn some more programming
27:45 - syntax let's cover some very important
27:47 - Theory one of the types of comments that
27:49 - I get most often is basically beginners
27:51 - asking me how do I memorize all the code
27:53 - and write everything perfectly the first
27:54 - time and the simple answer is I don't
27:57 - what you see in a video like this course
27:59 - what you see is really after I've done
28:00 - tons of research and written and most
28:02 - importantly Rewritten a ton of code this
28:04 - is one of the crucial things that
28:06 - separates beginners from intermediates
28:07 - beginners think that when the code is
28:09 - written that's it it's written forever
28:11 - and will never change so you have to get
28:12 - it right on the first time whereas
28:14 - intermediate programmers they know that
28:15 - code is a semi living thing that is
28:17 - constantly changing as your game or your
28:20 - program changes and progresses
28:21 - refactoring which is a term for
28:23 - rewriting code or simply reorganizing it
28:25 - that one is a Perfectly Natural part of
28:27 - the process if a very simple process is
28:29 - simply when you first try to build some
28:30 - kind of system like for example making a
28:32 - health system at first your primary goal
28:34 - should be simply to get it working you
28:36 - should obviously try to write some good
28:37 - clean code but it's nearly impossible to
28:39 - get it perfectly on the first try so the
28:41 - first goal is just get it working and
28:42 - now here's the really important step
28:44 - that separates beginners from
28:45 - intermediates after you get the system
28:47 - working then look at it analyze the code
28:49 - and see if it could be written in a
28:50 - better way perhaps there's some
28:52 - variables that could have a better name
28:54 - perhaps there are some functions that
28:55 - are clearly doing too many things and
28:57 - should be split into multiple smaller
28:58 - functions perhaps you have a whole bunch
29:00 - of data separated that should make more
29:02 - sense being placed in its own custom
29:04 - class so the first step is indeed just
29:05 - get it working but then don't forget the
29:07 - Second Step that one is how to get it
29:09 - working properly remember that your code
29:11 - is a living thing you won't continue
29:12 - living and working with that code
29:14 - especially as you start to make bigger
29:15 - and more complex projects so since
29:17 - you're going to use and reuse that code
29:19 - in the future make sure you write it
29:20 - properly it is perfectly okay to write
29:22 - semi there code on the first time what
29:24 - is not okay is to leave it there so when
29:27 - it is working take some time to do some
29:28 - refactoring if needed so if you are a
29:30 - beginner about to transition into the
29:32 - intermediate stage I want you to truly
29:34 - learn and fully internalize this it is
29:36 - perfectly fine in fact it's essential to
29:38 - rewrite code you are not expected to
29:40 - write everything perfect on the first
29:41 - try but you are expected to constantly
29:44 - be thinking about how the code could be
29:45 - improved and if you do find some
29:47 - possible Improvement take some time and
29:49 - refactor that code always keep that in
29:50 - mind especially as we go through this
29:52 - intermediate section which naturally
29:53 - will increase in complexity compared to
29:55 - beginner section so keep that in mind
29:57 - and let's go to the next lecture and
29:59 - learn about
30:00 - enums hello and welcome I'm your Cod
30:02 - monkey in this lecture we're going to
30:04 - learn one super useful feature of C
30:06 - which are enums these allow you to
30:08 - Define enumeration with a set of named
30:10 - constants it's really useful in so many
30:12 - scenarios okay so enums are really great
30:15 - like for example look at this code this
30:16 - function over here get next player
30:17 - action this is supposed to be something
30:19 - like a turnbas strategy game so the
30:21 - player has this function and uses this
30:23 - in order to calculate what is the next
30:25 - player action then does a whole bunch of
30:27 - tests to find out what is the next valid
30:29 - action and doing so it returns an INT
30:31 - which is going to be some kind of code
30:33 - for whatever action the player should be
30:34 - taking so for example the player checks
30:36 - if it has no enemy if so then it returns
30:38 - zero so zero means no enemy gen checks
30:40 - if there's no path to the enemy if so
30:43 - returns one so one means no path to
30:44 - enemy then checks within attack distance
30:46 - so two means moving towards enemy or
30:48 - three means attacking the enemy now the
30:50 - big problem that is immediately apparent
30:51 - in this code is that returning an INT
30:53 - value that one is really not very
30:54 - intuitive int is really supposed to be a
30:56 - number so matching into some kind of
30:59 - behavior that seems quite strange just
31:01 - like this you have to memorize that zero
31:02 - means no enemy one means no path and so
31:04 - on so numbers really are not the best
31:07 - type to use here and I said this is one
31:08 - of the many scenarios where enums are
31:10 - really excellent so first we Define an
31:12 - enum and the way we do that is we just
31:14 - type in enum then the name of the enum
31:16 - so for example let's say player action
31:18 - and then open and close the currently
31:20 - braces and now here we just Define a set
31:22 - of names for our various enim States so
31:24 - for example in this case we want one to
31:25 - represent no enemy we want one to say no
31:28 - path to enemy and we separate them with
31:31 - a comma and one moving toward enemy and
31:34 - finally attacking enemy all right yep
31:36 - just like this so now we have to find an
31:39 - inum which inside can have four of these
31:41 - possible values by the way the inum just
31:43 - like classes just like types just like
31:45 - anything also can have an access
31:46 - modifier so again the same rule if you
31:48 - don't need it to access from anywhere
31:50 - make it private if you do need to access
31:51 - it from somewhere make it public okay so
31:53 - like this we have thein our n now we can
31:55 - refactor this code in order to make it
31:57 - much more understandable so for example
31:58 - instead of returning an INT let's return
32:00 - of type player action then over here
32:02 - instead of returning a number we just
32:04 - return player action dot in this case no
32:06 - enemy so instead of having this we just
32:08 - have this and Y right away this makes a
32:10 - lot more sense so let's apply the same
32:12 - thing to all these so this one is the no
32:14 - path to enemy and this one is going to
32:16 - be the moving toward enemy and finally
32:19 - we have the attacking enemy and yep just
32:21 - like this so now we don't need those
32:23 - comments to explain what the number is
32:24 - supposed to mean just looking at the
32:26 - actual value itself just like this we
32:28 - can understand what exactly this is
32:29 - meant to be doing so enums really are
32:31 - this simple we just Define the values
32:33 - for our enum and then use it in any way
32:35 - we want by the way here we are returning
32:37 - an enom but an enum is really just a
32:39 - type so we can do anything we want with
32:41 - it like for example we can make it a
32:42 - return type for a function or we can
32:44 - just make a variable of type layer
32:45 - action and we can set it to one of the
32:48 - values in our enum we can use it as a
32:50 - parameter we can use it on pretty much
32:52 - anything we want anything we can also
32:53 - use any other type in then another very
32:56 - common use case for enums is doing
32:57 - something like like a state machine so
32:59 - for example let's define a private enum
33:01 - for the state and on this state let's
33:03 - say we have the state looking for enemy
33:05 - then we have moving to enemy and finally
33:08 - attacking enemy so these are our various
33:10 - possible States and then we have some
33:12 - kind of function to handle the state so
33:14 - this is going to handle our state
33:16 - machine and over here we just do a
33:17 - switch and do a switch on our state so
33:19 - we would have some kind of state
33:21 - variable holding the current state for
33:23 - this unit and then we do a switch on
33:25 - that state and you case case something
33:27 - so case for example moving to enemy then
33:29 - we have the moving to enemy logic
33:31 - afterwards we do a break then we do all
33:33 - the other cases so looking for the enemy
33:35 - and so on so yeah this is a really
33:37 - simple State machine and you can see how
33:38 - by using an actual enum for the state
33:40 - that makes it much easier to understand
33:42 - as opposed to if we had the state being
33:44 - some kind of int and over here instead
33:46 - of these we would have just zero one and
33:48 - two and we would have to memorize what
33:50 - these numbers mean so just looking at
33:52 - this it is very clear just how good
33:53 - enums are with numbers it becomes really
33:55 - messy but if we apply some enums
33:57 - everything looks really understandable
33:59 - now enums also have an interesting
34:01 - property which is on the back end these
34:03 - values are actually stored as ins so to
34:06 - run some testing code over here I'm
34:07 - writing some code in the unity project
34:10 - so let's just do a private void start
34:12 - which is going to run this function
34:13 - automatically so now over here for
34:15 - example let's define a player action
34:17 - just a field of player action and let's
34:19 - set it to something for example let's
34:20 - say no enemy which is the first one that
34:22 - we defined so we Define this and now
34:25 - let's do we debug. log on displayer
34:27 - action and if we do this and here in the
34:29 - console we can see it pretty much print
34:31 - out a string of the state so no enemy
34:33 - however like I said on the back end
34:34 - these values are actually stored as ins
34:37 - so if we cast this down into an INT
34:39 - let's see what this one says and yep the
34:41 - int is going to be zero however instead
34:43 - of printing out the in for no enemy
34:45 - let's say the one for no path to enemy
34:47 - so this is the second state that we
34:49 - defined and you have this one now prints
34:51 - one so theorder is based on how you
34:53 - define them so the first one is going to
34:55 - be on essentially index zero then one
34:57 - two three and so on and you can also do
34:59 - the opposite so we can for example let's
35:02 - cast onto a player action and let's cast
35:04 - for example the number two any you
35:06 - casting the number two onto our enome
35:07 - does return moving toward enemy so due
35:09 - to this property due to how enom really
35:11 - are stored as ins in the back end
35:13 - because this there are some interesting
35:15 - things you can do with it for example
35:16 - another common use case for enom is when
35:18 - making some kind of game tutorial with
35:20 - various stages so You' have an enum for
35:22 - the tutorial stage then have like stage
35:25 - one which is like player teaching the
35:27 - movement controls in stage two stage
35:29 - three and so on so you'd have this kind
35:31 - of thing and then you will Define some
35:33 - kind of variable to store the current
35:35 - tutorial stage so let's say we're
35:36 - starting off on stage one and then we
35:38 - can just do tutorial stage Plus+ and
35:41 - let's do a log on this one so we're
35:42 - defining it as stage one then we're
35:44 - doing Plus+ let's see what this one says
35:46 - and yep it says stage two so it went on
35:48 - to the next inum value then we could
35:50 - simply compare against the last value in
35:51 - the tutorial stage in order to know if
35:53 - we've reached the end alternatively you
35:54 - can also handle the conversion back and
35:56 - forth using strings so for example
35:58 - string for the tutorial stage string and
36:01 - here let's grab the tutorial stage and
36:03 - call the usual two string function so
36:05 - this going to convert onto a string and
36:07 - now if we take this and we try to cast
36:09 - it to a tutorial stage if we do it that
36:11 - nope this does not work this is an error
36:13 - we cannot automatically convert the
36:14 - string into our enum so if you want to
36:16 - do this the correct way to do it is go
36:18 - inside the enum class this one exists
36:20 - inside system so we go inside of this
36:23 - one and then there's a parse or a tri
36:25 - parse so the only difference is this one
36:26 - returns a bone whether the par succeeded
36:28 - or not whereas this one assumes it
36:29 - always succeeds and you can see these
36:31 - also have versions with these angled
36:33 - brackets these are generics which I'm
36:35 - going to cover in more detail later on
36:36 - in this intermediate section so for
36:38 - example and since we know that the code
36:40 - perfectly matches the Eternal stage
36:42 - let's just do a parse we're going to
36:43 - parse onto the type of tutorial stage
36:45 - and we're going to parse this string
36:47 - okay so if we see this we should be able
36:48 - to see the usual stage two because we
36:50 - got stage one we increase it convert it
36:52 - into a string and then from a string
36:53 - back into our enum and if there it is
36:55 - correct then yet another thing you can
36:57 - do with inom is simply cycle through all
36:59 - the possible values and for that we can
37:01 - do for example for each for each inside
37:03 - the tutorial stage let's cycle through
37:05 - all the tutorial stages then in and now
37:08 - here you can't do for example tutorial
37:10 - stage. count. something no that doesn't
37:12 - happen that doesn't work so instead in
37:13 - order to get all the values you go again
37:15 - inside the inom class and for this one
37:17 - you can pass in get values and this one
37:19 - takes in a type so here to get a type we
37:21 - want to type tutorial stage but just
37:23 - like this nope this does not work in
37:25 - order to get the actual type object for
37:27 - that that we use the keyword type of and
37:30 - pass in our tutorial stage so yep like
37:32 - this it works so debug.log on this one
37:35 - and this should print out all of our
37:37 - possible elements inside our enum so
37:39 - let's just print some just separate from
37:40 - the other logs let's see and if there it
37:42 - is stage one two three and four all
37:44 - right so those are enums really useful
37:46 - in so many scenarios they are really
37:48 - easy to use and help you make your code
37:50 - a lot more readable and
37:53 - understandable hello and welcome I'm
37:54 - your Cod monkey in this lecture we're
37:56 - going to learn all About Properties in C
37:59 - these are kind of a mix between a
38:00 - variable and a function so you can sore
38:02 - some data and run some logic okay so
38:04 - properties these are actually pretty
38:05 - simple to Define so we Define them
38:07 - pretty much like a normal variable so
38:09 - we've got the access modifiers let's
38:11 - make it private then we have the type
38:12 - let's say of type string then we give it
38:15 - some name and the usual naming rule is
38:17 - for properties to use Pascal case
38:19 - meaning upper case on the first letter
38:20 - so for example player name and then if
38:23 - we just put a semicolon if we just do
38:25 - this then this is a normal variable it's
38:26 - not a property in order to make it a
38:28 - property instead of this we open and
38:30 - close a code block and now here we add
38:32 - two pieces of logic one is called get so
38:35 - let's do get and then a semicolon and
38:37 - then the other one is called set so
38:38 - let's set and then a semicolon and if
38:40 - that's it this is a super simple
38:42 - property and in order to use it over
38:43 - here in our static main function let's
38:45 - just Define this one as static so then
38:48 - down here in our main we can use it just
38:49 - like if as if it were a regular variable
38:52 - so we can go inside the player name and
38:54 - we can set it to something like Code
38:55 - Monkey so let's do this and then do a
38:57 - console the right line and let's print
38:59 - out the player name okay let's see and
39:01 - if there it is and does print out the
39:02 - name so pretty much the same as a
39:04 - regular variable however in reality this
39:06 - is not a variable in reality the C
39:08 - compiler is doing a little bit of magic
39:10 - in the background properties are really
39:12 - not variables they don't actually store
39:14 - any data directly so what we have
39:15 - defined here is what is called an auto
39:17 - implemented property in the background
39:19 - the C compiler is generating a hidden
39:21 - variable that does sore data for this
39:23 - property so we can also just manually do
39:25 - exactly that so let's do a private
39:28 - static string for the player name and
39:30 - again since this one is a variable we're
39:32 - going to use chemel case and then let's
39:34 - use it over here on the property so
39:36 - inside this code block for this get in
39:38 - this set we can actually expand upon it
39:40 - so for the get let's add a code block
39:42 - inside it and over here let's return our
39:44 - backup field so let's just return the
39:46 - player name the underlying one okay then
39:48 - for the set again same thing let's add a
39:50 - code block and for this one we want to
39:52 - set the player name so player name
39:53 - equals and then we use the keyword value
39:56 - so this basically going to be whatever
39:57 - value we assign to the player name so
39:59 - when we run this line of code it is
40:01 - going to run this sort of mini function
40:03 - and it's going to assign the value to
40:04 - whatever we assign here which in turn is
40:06 - going to assign it onto the underlying
40:07 - value okay so if we test like this and
40:10 - everything still works the same it still
40:11 - prints out Code Monkey so what we have
40:13 - over here is literally exactly the same
40:15 - as we had previously the C compiler
40:17 - simply builds all of this automatically
40:19 - in the background whenever we do a
40:20 - property where we have just a get in
40:22 - just a set and we do not Define any of
40:24 - these code blocks now here the get in
40:25 - the set these are pretty much functions
40:28 - which means you can write pretty much
40:29 - any code here for example we can do some
40:31 - validation so over here on the get
40:33 - function for example let's test if the
40:35 - underlying player name equals n so if it
40:37 - hasn't been set if so then we can return
40:39 - some kind of default so unknown if we do
40:42 - it like this and we erase the setting so
40:44 - we just have the player name
40:45 - uninitialized and if there it is now it
40:47 - does print out unknown so we basically
40:48 - added some extal logic onto our get
40:50 - function and when setting same thing we
40:52 - can also validate the value for example
40:54 - let's say this player cannot be named
40:55 - Code Monkey so we can test if the value
40:58 - if the value equals for example Code
40:59 - Monkey if so then either we can set the
41:01 - value to some default value or for
41:03 - example we can throw a new exception
41:05 - cannot name player Code Monkey by the
41:07 - way I'm going to cover exceptions in
41:09 - detail in a future lecture this is
41:11 - pretty much just an error message so if
41:12 - down here we can try to set the player
41:14 - name equals Code Monkey if we try doing
41:17 - this and if there it is right away we
41:19 - see an exception because again it is
41:21 - running our validation code and our
41:22 - validation code does not let usame this
41:24 - so usually this is the goal of
41:25 - properties which is how you can do
41:27 - something validation for processing
41:29 - either the get or the set function and
41:31 - one extremely useful thing you can do
41:32 - with properties is simply make different
41:34 - access modifiers for each of these now
41:36 - right now we made the player name we
41:38 - made this one private which means that
41:40 - both of these are going to be set to
41:41 - private and if instead we make this
41:43 - public if so then now both these are
41:46 - public meaning any class in our codebase
41:48 - can access either the get or the set
41:50 - however you can also add different
41:51 - accessories here for example we can
41:53 - leave the get like this in order for
41:54 - anyone to access it and we can make the
41:56 - set as private that means that this
41:58 - class can now access and set the value
42:00 - over here on the player name but other
42:02 - classes can only use the get so yep here
42:04 - we do see an error so I create the
42:06 - completely separate class named player
42:07 - and inside I'm trying to access the
42:09 - player name and modifyed nope I cannot
42:10 - use it because the set accessor is an
42:12 - accessible however if I do a console
42:15 - right line on this one if I do it then
42:17 - Yep this is perfectly valid code so this
42:19 - property can now be accessed we can
42:20 - access the get from any class anywhere
42:22 - in our code base but only this class can
42:24 - access the set so right now you might be
42:26 - wondering Okay so is this really all the
42:28 - same as just making a field with some
42:30 - get and set functions and yeah pretty
42:31 - much it is if we were to make a private
42:34 - static void set player name and receive
42:37 - a string for the player name if we do
42:39 - this and set the player name and then we
42:41 - have a private static string for the get
42:44 - player name and over here we return our
42:46 - player name so if we have this code and
42:49 - then up here and let's say we don't want
42:50 - any of this validation so we just have
42:52 - the basic Auto Implement property so
42:55 - just get any a set so you have just like
42:57 - this the property that we defined up
42:58 - here it is doing pretty much exactly the
43:00 - same thing as what we have down here we
43:02 - have a field with set and get functions
43:04 - and that's pretty much the same thing
43:05 - that we have here so these two pieces of
43:07 - code these are pretty much identical now
43:09 - I have to say that personally I'm not a
43:11 - big fan of properties simply because I
43:13 - do not like how they look like variables
43:15 - but act like functions personally I find
43:17 - that needlessly confusing if I want to
43:19 - store some data I want to use a variable
43:21 - and if I want to use some logic I want
43:23 - to use a function combining both in a
43:25 - strange way to me just seems really odd
43:27 - mod it seems needlessly confusing but
43:29 - that's really just me that's just
43:30 - personal preference a lot of people
43:32 - really like using properties in fact the
43:33 - official C documentation is full of
43:35 - properties so while personally I don't
43:37 - like them and don't normally use them
43:39 - it's not because they're bad it's really
43:40 - just personal preference so if you do
43:42 - like them feel free to use them in your
43:43 - projects for me the only place where I
43:45 - use properties is when I use the
43:46 - Singleton pattern I'm going to cover
43:48 - that in detail later on in the course
43:49 - but over here let me just quickly show
43:51 - you how the property helps Implement
43:52 - that pattern usually in that pattern you
43:54 - want some feel to store the Singleton
43:56 - reference but importantly you want only
43:58 - the Singleton class to be able to set
43:59 - that field while anyone else can get it
44:01 - so the property accessors are really
44:03 - useful for that so usually for that you
44:05 - make a public make it static for the
44:07 - Singleton pattern make it of the type
44:09 - that you are making the singlet ton so
44:10 - for example the program type then
44:12 - usually call it instance and then we
44:14 - have a get and a private set so y this
44:16 - way the access is exactly as intended by
44:18 - that pattern we have a public property
44:20 - with a public yet and a private set
44:22 - meaning this one can only be set inside
44:24 - of this class but any other class can
44:26 - get it like said I cover single tens in
44:28 - detail in a future lecture but I just
44:29 - want to show that this is pretty much
44:31 - the only scenario where I use properties
44:32 - for anything else I normally just make a
44:34 - regular field and if I need to I may get
44:36 - or set variables if I need to modify but
44:38 - again it's all personal preference so if
44:40 - you don't like properties then go ahead
44:41 - and use them okay so that's properties
44:43 - they are a really interesting mix
44:44 - between a variable and a function
44:46 - allowing you to handle store data and
44:48 - process it in some way when getting and
44:50 - setting hello and welcome I'm your kodm
44:54 - in this lecture we're going to learn
44:55 - about multi-dimensional arrays Okay so
44:57 - so in the basic section we already
44:58 - learned about arrays this is how we can
45:00 - store multiple pieces of data in just
45:02 - one variable we've got essentially
45:03 - multiple containers at each different
45:05 - index so now we can just go one step
45:07 - further and essentially make multiple
45:09 - dimensions of these arrays for example
45:10 - we can make it have two Dimensions so it
45:13 - has two axes and then each position
45:15 - instead of having just one coordinate it
45:16 - actually has two so for example on this
45:18 - array we can go on to position 0 0 and
45:20 - place some kind of number or we can go
45:22 - into position 2 three and place some
45:24 - kind of number go into 41 and draw
45:26 - something and so on so each of these
45:27 - positions works exactly the same as the
45:29 - elements in a regular array they can be
45:31 - set or you can get their value and this
45:33 - is an example of a 2d array so you've
45:35 - got a certain axis and another axis but
45:37 - you can have as many dimensions as you
45:38 - want you can have a 3D array 4D array 5D
45:41 - 6D or literally anything you want
45:43 - however this is also just one type of
45:45 - multi-dimensional array there are
45:46 - multiple types and multiple ways to
45:48 - build them so this is the syntax for
45:50 - building a regular onedimensional array
45:52 - so in then the square brackets in Array
45:54 - then create an array with some kind of
45:55 - size and one way to make a
45:57 - multidimensional array is to make an
45:58 - array with multiple Dimensions so to do
46:00 - that here when we Define array we
46:02 - include a comma for the dimensions so in
46:04 - this case we have two Dimensions so one
46:06 - on the left side one on the right side
46:07 - technically there's no limit so you can
46:09 - add as many dimensions as you want so
46:11 - here let's do a simple 2D array so we do
46:13 - that and then afterwards we just include
46:15 - the size for both dimensions and Y like
46:17 - this we have a two- dimensional array on
46:18 - the First Dimension it has a size of
46:20 - five and on the second one it has a size
46:21 - of six this creates the array and then
46:23 - in order to modify a certain index we
46:25 - can just access it with the coord
46:26 - coordinates so go inside the interray
46:29 - and now on a flat array you would just
46:30 - put an index but this one is
46:32 - multidimensional has two Dimensions so
46:33 - we need to put the index for both
46:34 - dimensions so for example 02 and have
46:37 - this will access the element inside the
46:38 - array on position 02 you can use this to
46:41 - read the value or assign it to something
46:43 - else then when it comes to arrays you
46:45 - will eventually want to cycle through
46:46 - them and normally you would do some kind
46:48 - of four so four and I equals z i unless
46:51 - in the interray do length do this Plus+
46:54 - so normally this is how you would cycle
46:55 - through an array how however now with a
46:57 - two- dimensional array if we do this
46:59 - then this one this interray do length
47:01 - this one is going to return the total
47:02 - length so in this case it is going to
47:04 - return essentially 5 * 6 so we can do a
47:06 - console. right line to see so the
47:08 - interray length and if there it is the
47:10 - result is indeed 30 which is 5 * 6 so
47:12 - that's the total size the array when we
47:14 - have a multi-dimensional array in order
47:16 - to get the length of a single dimension
47:18 - for that we can access the function get
47:20 - length this one as you can see takes a
47:22 - parameter for the dimension so let's
47:24 - first cycle through all the elements in
47:26 - the First Dimension and then inside we
47:28 - can do another for Loop by the way I'm
47:29 - going to cover nested Loops in detail in
47:31 - the next lecture but yep just like this
47:33 - this is going to cycle through every
47:34 - element in the entire array will cycle
47:36 - through the First Dimension then the
47:37 - second dimension in order to go through
47:39 - every single element we can do a console
47:41 - d right line and print out the interray
47:44 - on position I and J this won't print out
47:46 - the value stored in that coordinate
47:48 - let's also just print out the I then
47:50 - Comm then DJ then something so we can
47:53 - see what we're seeing okay let's see and
47:55 - if there is we can see it all working
47:57 - so first checks position 0 0 then 0 1 02
47:59 - and so on until it gets to one Zer so on
48:01 - and so on and all the vales are just
48:03 - zero because we just initialized all
48:05 - with zero but as you can see this is
48:06 - indeed cycling through the entire array
48:08 - through both dimensions of our
48:09 - multi-dimensional array alternatively
48:11 - for initializing the array contents we
48:13 - can do this note the difference between
48:15 - this syntax and the syntax we just want
48:17 - to mention so here we have some
48:19 - currently braces and then inside we have
48:21 - multiple pieces of curly braces one for
48:23 - each of the second dimension of the
48:25 - actual array and up here you can see the
48:27 - array being initialized so 0 0 has one
48:29 - two three then on one Zer it has like
48:31 - that one crucial important thing about
48:33 - these kinds of arrays and initializing
48:35 - it like this the shape needs to match so
48:37 - on the first one if we initialize this
48:39 - with four elements then the second one
48:40 - also needs to have four elements in
48:42 - order to have multi-dimensional arrays
48:43 - with differently sized elements for that
48:45 - we can use Jagged arrays which I'm going
48:47 - to cover in a little bit but before we
48:48 - get to that like I said there are
48:50 - multiple ways of doing multi-dimensional
48:51 - arrays this is just one way where you
48:53 - have a single array with multiple
48:55 - dimensions and the other common
48:56 - alternative is simply to have an array
48:58 - of arrays so instead of int and square
49:01 - brackets and having a common we have int
49:03 - and then square brackets open close and
49:05 - then open and close again this is
49:07 - basically creating a new array of arrays
49:10 - then we can do the usual cycle through
49:11 - it so for in IAL Z less than array.
49:15 - length here we can use length because
49:17 - again this is not a multi-dimensional
49:18 - array it is an array of arrays meaning
49:21 - it's an array and inside each position
49:23 - each element itself is going to be an
49:24 - array of multiple elements so we can do
49:27 - this i++ and we can go in Array on this
49:30 - index and inside it we create a new in
49:33 - Array of whatever length we want like
49:35 - for example six so basically what we
49:37 - have here is what we had previously when
49:39 - we had a multi-dimensional array with
49:40 - five and then six on the other dimension
49:42 - and then for accessing this one we
49:44 - access it by interray then access the
49:46 - First Dimension like say on position
49:48 - zero and then the second dimension let's
49:49 - say on position two so y this is how you
49:51 - set or read some elements from an array
49:53 - of arrays so this is also a valid way of
49:56 - starting multiple Dimensions instead of
49:58 - having just one array with multiple
49:59 - Dimensions you have multiple arrays of
50:01 - arrays and of course the same thing that
50:03 - I said a while ago about having no limit
50:05 - to how many dimensions you can have that
50:06 - still applies here so you can have as
50:08 - many arrays of arrays as you want so
50:10 - this code looks pretty insane but Yep
50:12 - this is perfectly valid code one crucial
50:14 - difference about these two types is
50:15 - basically defaults that they will use
50:17 - for example down here when we create an
50:19 - interray with multiple Dimensions when
50:21 - we do this by default all the elements
50:23 - inside of this array won't be on zero so
50:25 - like we see all the elements defa to
50:26 - zero whereas on this one since this is
50:29 - an array of arrays if we just cycle
50:31 - through the main array if you try to
50:33 - access this one so let's do a console do
50:35 - right line on this one so let's print
50:37 - out the array on this index let's do
50:40 - that and see what this prints out to see
50:41 - basically what each element of this
50:43 - array defaults you and if there it is
50:44 - the answer is essentially null we can
50:46 - compare this equals null and if there it
50:48 - is true so all of these elements are set
50:50 - to null so there is one big difference
50:52 - between array of arrays and
50:53 - multi-dimensional arrays these get
50:55 - initialized with every value at Z zero
50:56 - on whatever type you're using for the
50:58 - array whereas this one since each
51:00 - element inside of the main array since
51:02 - each of those is actually an object It's
51:04 - actually an array of something else
51:05 - because that by default the default
51:07 - value for some kind of array is going to
51:09 - be null because arrays are reference
51:10 - types as opposed to Value types which by
51:12 - the way I cover value and reference
51:14 - types what those are I cover those in
51:16 - detail in a future video and then
51:18 - another difference between these two
51:19 - types one thing that you can have with
51:21 - array of arrays but you cannot have with
51:23 - a multi-dimensional array one of those
51:25 - things is what is called a GI array
51:27 - meaning each subarray can have a
51:29 - different size down here when we Define
51:31 - the small dimensional array by default
51:33 - the shape of this array of multiple
51:34 - Dimensions the shape will pretty much be
51:36 - a rectangular size so over here five in
51:38 - one dimension and six on another one it
51:40 - will always have some kind of
51:42 - rectangular shape however in Array of
51:45 - arrays that does not have to be the case
51:47 - for example when initializing this we
51:48 - can set the one on index zero to be a
51:51 - new interray and let's say this one has
51:53 - a size of three then on the next one on
51:56 - ele index one we can say this one has a
51:58 - size of six then on index two we can say
52:00 - this one has 10 and so on so using an
52:03 - array of arrays technically each array
52:05 - inside the main array each of those can
52:07 - have whatever size you want as for what
52:09 - use case this would have for example
52:11 - imagine some kind of grid for a theater
52:13 - when you go to movies and select a seat
52:15 - usually different rows have different
52:16 - number of seats so that's an example
52:18 - where this kind of data structure could
52:19 - be useful you would have maybe three
52:21 - seats on the first row then six on the
52:23 - second one and so on so that could work
52:25 - it does have some use case although
52:27 - personally I pretty much never use them
52:29 - since in games usually things have some
52:31 - kind of rectangular shape things like an
52:33 - inventory or World usually those have
52:35 - some kind of rectangular shape as
52:36 - opposed to some weird Jagged shape now
52:38 - when working with multi-dimensional Rays
52:40 - we need to cycle through them just like
52:42 - we saw so let's learn about nested Loops
52:44 - in detail in the next
52:45 - lecture hello and welcome I'm your kmy
52:48 - in this lecture we're going to learn
52:50 - about nested Loops okay so let's see
52:52 - what they are they are really simply
52:54 - just a loop within another loop so for
52:56 - example let do a for Loop for in I equal
52:58 - Z let's say less than three I ++ so a
53:01 - regular for Loop and then inside it we
53:03 - can write another for Loop let's say in
53:05 - J equals z J less than 2 j++ and by the
53:08 - way usually the convention for these
53:10 - iterator variables usually use the
53:12 - variable I then you use J then if you
53:15 - need more you need k l MN and so on
53:18 - that's usually the standard convention
53:20 - but it's not a requirement it's really
53:21 - just a convention so these can be named
53:23 - whatever you want but in general I and J
53:25 - are very commonly used so over here
53:27 - let's do this let's do a loop inside
53:29 - another loop and now let's print out the
53:30 - I and J to see exactly how this code is
53:33 - running so let's print out I then a
53:35 - little comma and then J okay let's see
53:38 - and if there it is so we start off with
53:39 - an i of zero and a j of zero and then we
53:42 - have an i of still zero but then a j of
53:44 - one meaning that for each time this Loop
53:46 - is running this one is going to run as
53:48 - many times as this Loop is meant to run
53:50 - so it goes inside this inside this runs
53:52 - this line then when this one ends goes
53:54 - back into this for Loop and runs this
53:56 - line again then this one reaches the end
53:58 - so that is why this one ends and again
54:00 - goes back into this one which again runs
54:02 - this Loop starting from the beginning
54:03 - and runs more and more and so on so here
54:04 - it is running 0 0 0 1 1 0 1 1 two 0 and
54:08 - 2 1 the important thing to remember here
54:10 - is the code execution order meaning for
54:12 - every time the outer loop runs the inner
54:14 - loop is going to run multiple times two
54:16 - times in this case also remember what we
54:18 - covered in the basic section about
54:20 - variable scope if you define some kind
54:22 - of variable inside this in Loop like a
54:24 - int H equals 5 if we do this and down
54:26 - here you try to access the age nope that
54:28 - does not work if you define something
54:30 - inside the scope of this inner loop it
54:32 - does not exist outside of it and here we
54:34 - have one Loop but technically we can
54:35 - have as many as we want again the same
54:37 - logic for every time that this Loop runs
54:39 - any Loop inside of it will run as many
54:41 - times as those run as you can imagine if
54:43 - you do a ton of Loops within other Loops
54:45 - if you do that it becomes really hard to
54:47 - understand the logic the deeper you go
54:49 - so usually just having one less Loop in
54:51 - most cases that is the most you should
54:52 - do then we already saw these briefly
54:54 - being used in the last lecture covering
54:56 - multi dimensional arrays that's a very
54:58 - common use case so here it is that same
55:00 - code so we've got the outer loop going
55:01 - through the First Dimension and then we
55:03 - got the second inner loop that one is
55:05 - going through the second dimension and
55:07 - by doing this this is going to cycle
55:08 - through every element inside of this
55:10 - multi-dimensional array then on Loops
55:12 - there are two important keywords one is
55:14 - called break and this one breaks out of
55:16 - the innermost Loop so for example if we
55:18 - don't include the break let's see how
55:19 - many times this prints with the value on
55:21 - J and if there you go the value on J
55:22 - goes from 0 to 1 0 1 and so on but if we
55:25 - add a break over over here and if there
55:27 - it is now the J only goes to zero and
55:29 - immediately breaks out of that inner
55:30 - loop now the important thing to note
55:32 - here about break is how it only applies
55:34 - to the innermost Loop so this one does
55:36 - not break out of the outer loop as you
55:38 - can see the outer loop still run 0 1 two
55:40 - and so on so break only affects the
55:42 - innermost Loop if you do want to break
55:43 - out of the uttermost loop if so you can
55:45 - Define some kind of ball break from Loop
55:48 - you set it to something like false then
55:50 - inside this one you do some kind of
55:51 - logic that would eventually set this one
55:53 - to true and then down here you would
55:55 - test that and if so then call break and
55:57 - let's see and yep now this one does go
55:59 - inside as soon as it goes inside sets a
56:01 - break to true and breaks from that one
56:02 - so breaks from the inner loop and once
56:04 - this one is through it also breaks from
56:05 - the outer loop now the other important
56:07 - keyword is continue this one continues
56:09 - or pretty much skips to the next
56:11 - iteration of the loop so if we write
56:13 - some kind of code after this continue so
56:15 - let's do a light right line and write
56:17 - something like this even Visual Studio
56:19 - is telling you so this line is slightly
56:21 - faded because it will never run so
56:23 - unreachable code detected that is
56:24 - because as soon as the code gets to this
56:26 - continue it is going to ignore
56:27 - everything afterwards inside this Loop
56:29 - and go to the next iteration of this
56:31 - Loop so if we run this and if there it
56:33 - is it runs through every single element
56:35 - so the J is only 0 1 01 and so on but
56:37 - note how our second message this one did
56:39 - not ever show up if we were to put this
56:41 - inside some kind of if let's say if I
56:43 - equals z then continue so basically on
56:45 - the first I when the I is zero then it
56:48 - should not print this message but on the
56:49 - other ones it should and if there it is
56:51 - so once on zero it is going to continue
56:53 - and ignore this line but on the others
56:54 - it is going to run this line and again
56:56 - again same thing as previously note how
56:57 - this one only applies to the innermost
56:59 - Loop even when we're running our
57:01 - continuous over here on I of zero note
57:03 - that the I still runs all of them so 0 1
57:05 - 2 so again always remember that break
57:07 - and continue those only affect the
57:09 - innermost Loop now I should also say
57:10 - that break and continue are not specific
57:12 - to just Nest Loops you can use these
57:14 - keywords with any Loop including just a
57:16 - single regular for Loop or some kind of
57:18 - for each for example if we have some
57:21 - kind of player class so for example
57:23 - here's some simpar code so we've got a
57:25 - basic player class then we create a list
57:26 - of type player then we create a new
57:28 - special player we add that special
57:30 - player onto the list and then three
57:31 - random players then we do a four each
57:33 - inside of that player list cycling
57:34 - through every single one of them and
57:36 - then we check if that one is a special
57:38 - player if so let's continue if not let's
57:39 - write the name so if you do this we
57:41 - should be able to see the print of only
57:43 - three players and not the special player
57:44 - because that one will be skipped over
57:45 - here on the continue and if there you go
57:47 - exactly that three players and no
57:48 - special player now also on the topic of
57:50 - nest and Loops here we have a four
57:52 - inside another four but you can list any
57:54 - Loop of any type so for for example over
57:56 - here we can have a four inside another
57:58 - four and then inside both these fours
58:00 - we've got our 4 in so this perfectly
58:02 - works or we could replace this with a
58:04 - while or do while so literally anything
58:06 - works so as you can see neston Loops can
58:08 - be really useful especially when cycling
58:09 - through multi-dimensional arrays but if
58:11 - you go too deep if you Nest too much it
58:14 - can negatively affect code readability
58:16 - if that's the case consider whether you
58:17 - really need to make that Nest Loop and
58:19 - if so perhaps consider making a function
58:21 - that in itself has a loop then within
58:23 - some kind of other loop you just call
58:24 - that function so just be aware that Ness
58:26 - Loops can become messy very quickly so
58:29 - do be careful to use them properly and
58:31 - only when needed okay now that we've
58:32 - learned some more advanced us case for
58:34 - Loops we are ready to learn something
58:36 - that some people find quite complex
58:38 - which is recursion so let's learn that
58:40 - in the next
58:41 - lecture hello and welcome I'm your Cod
58:43 - monkey in this lecture we're going to
58:45 - learn about recursion which is a
58:47 - different way of doing Loops or just
58:48 - running logic multiple times okay so
58:51 - recursion this sounds like a really
58:53 - fancy word but in terms of logic it's
58:55 - really super simple it really just means
58:57 - a function that calls itself so for
58:58 - example over here let's make a function
59:00 - so private static void let's call it
59:02 - test recursion so we have this function
59:04 - which does some kind of thing and then
59:06 - inside this function we call itself and
59:08 - up here we call the first function so y
59:11 - That's it this is recursion it's pretty
59:12 - much just a function which inside calls
59:14 - itself now right away you might be able
59:16 - to tell a big issue here you can
59:18 - probably already tell that this is going
59:19 - to be an infinite Loop since this
59:21 - function will call itself for infinity
59:23 - and actually if we try to run this code
59:25 - we actually get a fun piece of trivia
59:27 - yep here we have an infinite Loop that
59:29 - eventually ended and it end with this
59:31 - error a stack Overflow exception and Yep
59:33 - this is where the famous website got its
59:35 - name basically as you call functions
59:37 - your CPU stores references to those
59:38 - functions in something called a call
59:40 - stack that's a stack of all the
59:41 - functions that have been called in the
59:43 - current process the CPU needs to know
59:45 - that so that it knows that when a
59:46 - function ends where should it jump back
59:48 - to but of course memory has the limit so
59:50 - if you call a function within a function
59:52 - way too many times eventually you reach
59:54 - that maximum which then caus the stack
59:56 - to loop back which in turn is called a
59:58 - stack Overflow so with this code we have
60:00 - an infinite Loop not very useful but
60:02 - like we already saw in the last lecture
60:04 - and in the beginner section Loops can be
60:06 - extremely useful and recursion is really
60:08 - just one type of loop so with recursion
60:10 - we can do literally anything we can do
60:12 - with normal Loops for example let's
60:14 - write a while loop let's increase some
60:16 - kind of number one by one until five so
60:18 - here we have a simple while loop so we
60:20 - Define number of zero and while the
60:21 - number is under five we just incremented
60:23 - so that's it pretty simple now let's do
60:25 - the exact same thing using recursion so
60:27 - on this we have a function and really
60:29 - since recursion is all about a function
60:31 - calling itself all we really need to do
60:33 - is pass in our variable as our parameter
60:35 - so we can just receive an inert number
60:37 - and inside do number Plus+ however just
60:40 - like this it won't work since like we
60:41 - saw on the electr on scope and functions
60:44 - function parameters are actually local
60:45 - variables so when we call this function
60:47 - with this we're working with a copy and
60:49 - not the original data so to get some
60:51 - kind of result back from our function
60:52 - let's simply set it as our return type
60:54 - so let's return of type in and then here
60:57 - we can do our logic and basically then
60:58 - do return number in order to return the
61:00 - final number so now when do we want to
61:02 - return the final number so now let's do
61:04 - the same condition that we had up there
61:05 - so if number is under five so we do if
61:08 - the number if number is under five if so
61:10 - then we're going to call test recursion
61:12 - again and we're going to return it with
61:14 - number + one and in order to get the
61:16 - data back let's call it return on this
61:18 - and if not if the number is above or
61:20 - equal to five if so let's just return
61:22 - the regular number so just like this
61:24 - let's just give this a proper name so
61:26 - let's rename this to recursion increment
61:30 - then up here let's call the same thing
61:31 - and we're going to start off by calling
61:33 - it with number zero and let's do a
61:34 - console. right line on this to see the
61:36 - result so let's see the result on this
61:39 - one and also a console. right line on
61:41 - the other number made with the regular W
61:43 - Loop okay so let's see if both these do
61:46 - return five and if there it is they both
61:48 - return five so we both have this logic
61:50 - that this one is going to run this logic
61:52 - multiple times and this one is also
61:53 - going to run the same logic multiple
61:54 - times so here as we call this the first
61:57 - time number is going to be zero and if
61:58 - number is under five if so then this one
62:01 - is going to return the result of this
62:02 - function and this function call will
62:04 - pass in the number so 0 + one pass in
62:06 - number one so once again that is going
62:08 - to go inside this function now with the
62:09 - number one which again still under so
62:11 - it's going to return another call of
62:13 - this function which again with the
62:14 - number 1 + 1 equals 2 and so on and as
62:17 - soon as it gets a five just Returns the
62:18 - final number so basically here we are
62:20 - stacking multiple function calls on top
62:22 - of one another and when the final one
62:24 - returns they all basically return and
62:26 - the call stack collapses and we end up
62:28 - with the finnal final result then if we
62:30 - wanted instead of having a hardcode
62:32 - maximum over here we could have another
62:34 - one as a parameter so an end for the
62:37 - number Max so we have that and we
62:39 - receive it here and we just pass it
62:41 - along the same way onto the next
62:42 - function call and then we could also
62:44 - have a parameter for the incrementer so
62:46 - increment amount so we have this one
62:49 - instead of increasing by one we increase
62:50 - by the increment amount so then over
62:52 - here let's put it five and then one and
62:55 - over here let's also pass in the
62:56 - incremented amount and have same result
62:58 - 55 and what we have built here is
63:01 - essentially the exact same logic as some
63:02 - kind of for Loop if you remember the for
63:04 - Loop has some kind of initializer
63:06 - iterator variable then it has some kind
63:08 - of condition usually some kind of
63:09 - maximum number and it increments by a
63:11 - certain amount so what we have here is
63:12 - literally the exact same thing as a for
63:14 - Loop except it's being handled with
63:15 - recursion so all the logic you can do
63:18 - with any kind of loop you can do with
63:20 - recursion this is really just an
63:21 - interesting way to handle running logic
63:23 - multiple times by simply being very
63:25 - clever about how a function can call
63:27 - itself multiple times now I should also
63:29 - say that personally I'm not really much
63:31 - of a fan of recursion in general I find
63:33 - it needlessly confusing I much prefer to
63:35 - have a simple for Loop where I can very
63:37 - easily see the iterator and the end
63:39 - condition as opposed having to look at
63:41 - the parameters for a function and trying
63:43 - to guess when it will stop calling
63:44 - itself so personally for me I pretty
63:46 - much never use recursion I always use
63:48 - just regular Loops I find those much
63:50 - more straightforward but recursion is a
63:52 - valid option so I definitely wanted to
63:54 - cover it especially if you're into
63:56 - advanced mathematics if so then you
63:57 - might actually like it since mathematics
63:59 - has a lot of this kind of stuff if you
64:01 - like that then perhaps for you recursion
64:03 - might be much more natural much more
64:04 - intuitive than working with regular for
64:06 - Loops just always be careful the same
64:08 - issue with for Loops which is always be
64:09 - careful not to end up with infinite
64:11 - Loops hello and welcome I'm your kod
64:14 - Maki in this lecture we're going to
64:15 - learn about one of the most useful
64:17 - collections the dictionary okay so
64:19 - dictionaries are a super useful data
64:21 - type for storing multiple pieces of data
64:23 - and doing so in a very organized way
64:25 - dictionaries are all about key value
64:27 - pairs meaning that the dictionary itself
64:29 - is a whole container and inside that
64:31 - container you store various keys so like
64:33 - some key for stone some wood and some
64:35 - gold and then for each key each key has
64:37 - a corresponding value and then that
64:39 - value can have whatever that you want
64:41 - importantly is both the key and the
64:42 - value both these can be of whatever type
64:44 - you want so for example in some kind of
64:46 - game starting the resource amount the
64:47 - resource type itself can be the key and
64:49 - the amount that you're currently holding
64:51 - that one can be the value if you were to
64:52 - build something like that using an array
64:54 - or some kind of list if so then you
64:56 - would have to memorize that for example
64:57 - index zero that one refers to Wood index
64:59 - one refers to Stone index two to gold
65:01 - and so on so you'd have to memorize what
65:04 - type each index belongs to whereas with
65:06 - dictionary the key itself can be very
65:07 - descriptive about what value it stores
65:10 - you can use a proper name or a proper
65:11 - object reference that makes a lot more
65:14 - sense than keeping in mind what index
65:15 - belongs to what now to build a
65:17 - dictionary this is actually super easy
65:19 - we just type in dictionary and then we
65:21 - open up the angle brackets now this
65:24 - syntax these are generics kind of like
65:26 - we use on the list I'm going to cover
65:27 - generics in detail in a future lecture
65:29 - in this intermediate section so we open
65:31 - the angle brackets and then we have two
65:33 - types the first one is going to be
65:35 - whatever type we want for our key so for
65:37 - example let's define enum for that so
65:38 - private enum for the resource type so we
65:41 - have this and then inside for the values
65:43 - let's go with stone then wood then gold
65:45 - okay those are the values for our
65:47 - resource type and over here we can use
65:48 - that resource type itself as our key and
65:50 - then for the value type let's say we
65:52 - just want to store the amount so let's
65:53 - use a simple int so let's let's name
65:55 - this resource type amount dictionary and
65:59 - then we can simply construct it so just
66:00 - new dictionary of this type okay just
66:03 - like this so this is going to create our
66:04 - dictionary but so far it's going to be
66:06 - just empty to add a key value pair we go
66:08 - inside the resource app amount
66:10 - dictionary inside our dictionary and we
66:12 - call the add function over here we need
66:14 - to pass in the key and the value so
66:16 - let's pass in resource type let's say
66:18 - Stone then for Value let's say 56 see if
66:21 - this is going to add the Key Stone onto
66:23 - our dictionary and it's going to link
66:25 - the value 56 with that stone this is how
66:28 - we can add a value and then for reading
66:29 - a value we do it pretty much as if it
66:31 - were an array so we use the square
66:32 - brackets and inside here we put the type
66:34 - for our key so in this case our resource
66:36 - type do stone so if we do a console
66:39 - downright line on this one let's see any
66:41 - y it does print 56 okay great now one
66:44 - key point about dictionaries is that the
66:46 - key itself this one must be unique so if
66:48 - we try adding a value on the same stod
66:50 - key if we try adding some kind of value
66:53 - nope right away we have an error an item
66:55 - with the same key already has been added
66:57 - so remember that each key must be unique
66:59 - if you want to update the value we can
67:01 - just access it so as if it were an array
67:03 - and then set it to something and Yep
67:04 - this will work now when getting a value
67:07 - if we try getting a value that does not
67:08 - exist so if we try going to this on the
67:11 - resource type. wood if we try doing a
67:13 - console. right line on this one yep here
67:15 - we have another error key not found
67:17 - exception the given key was not present
67:18 - in the dictionary so if you don't know
67:21 - whether a certain value exists you have
67:23 - two options first you can just check to
67:25 - see if it's contains that key so access
67:26 - the dictionary and call contains key
67:29 - then pass in the key so this will return
67:31 - true or false if this key exists inside
67:34 - the dictionary or not that's one
67:35 - approach and the other one is to access
67:37 - the dictionary and call try get value
67:40 - this one like the name implies tries to
67:41 - get some kind of value for some key so
67:43 - the first parameter is going to be the
67:45 - key so let's say resource type. wood and
67:48 - then the second parameter this is the
67:49 - first time that we're seeing this this
67:51 - one is not just an INT value parameter
67:53 - it is an out in this means that it's an
67:55 - output parameter this is a more advanced
67:57 - topic that I cover in detail in the
67:58 - advance section for now just know that
68:00 - this is an output parameter so this
68:02 - function is basically going to return
68:03 - both so it is going to return true or
68:05 - false true if the dictionary has this
68:07 - key and false if it does not and if it
68:09 - does have then it's going to Output
68:11 - whatever it is in here so let's Define a
68:13 - variable for the wood amount so if it
68:15 - does have wood then it's going to store
68:16 - the amount on that one so then we can
68:18 - see if this one does have this value if
68:21 - so then let's print out the W amount
68:24 - except we didn't add so this should not
68:25 - run and if there it is that doesn't run
68:27 - but if over here instead of assigning
68:29 - Stone let's assign to Wood and if there
68:30 - it is now it does run again if you're
68:32 - not familiar with this output syntax
68:34 - don't worry about it I'm going to cover
68:36 - it in more detail in a later lecture if
68:38 - you do use it just know that it has this
68:40 - syntax also like we saw we can modify
68:42 - values so we can go inside this resource
68:44 - type. wood and set it to something to
68:46 - modify it so this works but this also
68:49 - works for simply adding values so
68:50 - instead of calling that add you can just
68:52 - do it like this and if it does work and
68:54 - does add that value and of course since
68:56 - we can add values we can also remove
68:57 - them so we can call remove and then pass
68:59 - in some type of key so let's say
69:01 - resource. wood so this should remove the
69:03 - key so then this code should not run and
69:05 - if there is doesn't run so here we are
69:07 - creating a dictionary and then
69:09 - afterwards on a separate line we are
69:10 - assigning values but like we have with
69:12 - arrays and class and so on we can also
69:14 - initialize the object directly when we
69:16 - create it the way we do that is we open
69:18 - and close the Cur braces so the same as
69:20 - we do to initialize some kind of array
69:22 - or list and then inside it we put
69:24 - whatever element we want to initialize
69:26 - inside this dictionary but remember
69:28 - dictionary is a key value pair so we
69:31 - need to somehow Define a key and a value
69:33 - pair over here if we just do resource
69:35 - type. Stone and then 10 if we just do
69:38 - this nope this is an error the correct
69:40 - way to define a key value pair is with
69:42 - another pair of curly braces so put this
69:43 - one inside open and close just like this
69:46 - and then if we want to initialize more
69:48 - we can just start with wood and
69:50 - something and so on now importantly here
69:52 - pay close attention to the syntax so
69:54 - we've got currently braces on the whole
69:55 - dictionary and then again for each
69:57 - individual key value pair now one common
70:00 - thing you're going to do with
70:01 - dictionaries is simply cycling through
70:02 - them for that we can just do a four each
70:05 - directly on our resource type dictionary
70:07 - and for this one the iterator variable
70:09 - will be a type key value pair simp like
70:12 - this and then inside this one we can
70:13 - access the key or the value so let's do
70:16 - a console. right line this one. key and
70:19 - let's do a colon and key value. value
70:22 - let's get rid of this code and let's
70:23 - test and if there is second through the
70:25 - entire dictionary and prints out Stone
70:26 - and then the amount alternatively
70:28 - instead of sing through the dictionary
70:29 - itself inside of here we've got a keys
70:31 - collection this just basically going to
70:33 - scroll through every single one of the
70:35 - keys so over here you would have just
70:37 - resource type just resource type this
70:40 - would be the key and then you could
70:41 - simply access and print out the resource
70:43 - type and then go inside the dictionary
70:45 - on this type to see the amount and if
70:47 - there is same result so this is the
70:49 - other type for each and also finally you
70:51 - can also cycle through just the values
70:53 - and on all of this always remember that
70:55 - these are really just key value pairs
70:57 - meaning it's up to you to Define what
70:59 - value you want to use for the key and
71:00 - the value it does not have to be just
71:03 - simple types like ins and enums for
71:05 - example the key can be some kind of
71:06 - player class and the value can be some
71:08 - kind of weapon class that would be
71:10 - perfectly fine so just remember that it
71:12 - doesn't have to be just simple types you
71:14 - can use whatever type you want for the
71:15 - key and the value now here's a bonus tip
71:18 - specific to Unity let's say you want to
71:20 - build some kind of resource manager
71:21 - something like this so you have a
71:23 - resource manager class and inside You'
71:25 - got a dictionary of resource type and an
71:26 - INT but then you want it to be preset
71:28 - with some amount that you want to set in
71:30 - the editor but the issue with
71:31 - dictionaries is that Unity does not
71:33 - serialize them so even if we add
71:35 - serialized field private even if we do
71:37 - this here in the editor nope we do not
71:39 - see it the resource manager has no
71:40 - Fields nothing shows up in the editor so
71:43 - instead here's a neat trick you can do
71:45 - you can create a custom class and on
71:47 - that class you basically use the key
71:49 - value pair so here I've got a resource
71:50 - type and an INT amount now importantly
71:52 - we need to mark this type as
71:53 - serializable in order to show show up in
71:55 - the editor and if we do and then we just
71:57 - make a list of this type if so then Yep
71:59 - this one does now show up over here in
72:01 - the editor so we can set it to something
72:03 - and then we have all of our elements of
72:05 - our custom type so we can set all of
72:07 - them to whatever we want so there it is
72:09 - all the various values all the various
72:10 - keys and then on this same script over
72:12 - here on the awake we just create the
72:14 - dictionary we cycle through the list
72:16 - that we exposed in the editor and we
72:18 - just go inside the dictionary on that
72:19 - type and set it to that amount then we
72:21 - can just print out the concept
72:22 - dictionary and here in the console we
72:24 - can inde yep we did create the
72:26 - dictionary and we did initialize it with
72:27 - our data all right so that's the
72:29 - dictionary it's a super useful data type
72:32 - really helpful when you have two pieces
72:33 - of data that can be connected like a key
72:35 - value pair so this is absolutely
72:37 - essential in things like resource
72:38 - management or linking any kind of data
72:41 - together with one
72:44 - another hello and welcome I'm your Cod
72:46 - mon in this lecture we're going to learn
72:48 - about some other collection types like
72:50 - cues TXS and a bunch more okay so in the
72:52 - beginner section we already learned
72:54 - about arrays and lists then in the last
72:56 - lecture we learned about dictionaries
72:58 - honestly those are really the only
72:59 - collections that I normally use myself
73:01 - but there's still a bunch more that can
73:03 - be useful in certain scenarios so here
73:04 - let's see them one simple one is called
73:07 - the stack think of it like a stack of
73:09 - papers you can place papers on top so
73:11 - you can push them and for grabbing a
73:13 - paper you can only grab the one that is
73:15 - on the top in this case on the stack
73:16 - grabbing simply means pop so you can
73:18 - push and pop elements this is what is
73:21 - called a first in last out collection or
73:23 - also known as f here in the code the way
73:26 - we do it is super simple we just create
73:28 - a new stack this one takes a generic
73:30 - type so similar to the list so let's say
73:32 - a stack of strings let's call name stack
73:35 - and we construct it then on this one we
73:38 - can call the function push in order to
73:39 - push values onto the stack so let's push
73:41 - the string Code Monkey then let's push
73:43 - the string for Iron Man and let's push
73:46 - the one for Spider-Man okay so with that
73:48 - we push them and now if we go into the
73:50 - stack and we call Pop this one is going
73:52 - to remove and return the object on top
73:54 - of the stack so like I said this is a
73:56 - fellow collection meaning first in last
73:58 - out so ask yourself what do you think
74:00 - this will return this is the first
74:02 - element that is added so technically
74:03 - this is going to be the last one out so
74:05 - let's do a console down right line on
74:07 - this okay let's see what this returns
74:09 - and you correct this does return
74:10 - Spider-Man like I said first in last out
74:13 - so we first put Code Monkey so this
74:14 - means this is going to be the last
74:16 - element that we're going to grab and
74:17 - when we pop we are going to grab the one
74:19 - that we last put on there which is going
74:20 - to be this one and eventually if we
74:22 - don't put up anything so if we comment
74:24 - out all of this and we try doing a pop
74:26 - yep here we have an error the sack is
74:28 - empty so to avoid that we can use triy
74:30 - pop which will try to get an element if
74:33 - it exists and if you want to just look
74:34 - at the last element without removing it
74:36 - we can call Peak okay so that's a stack
74:38 - another related collection is a q this
74:41 - one the easiest way to visualize is some
74:43 - kind of queue of people so the first
74:45 - person that gets added onto the queue is
74:47 - going to be the first one that gets out
74:48 - so this one is a fivefold collection
74:50 - first in first out the way we build it
74:53 - is pretty much the same as a stack
74:54 - except this one is a que so then let's
74:56 - make a queue of string so for the string
74:59 - q and let's construct it so a new one
75:01 - and build it then on the string Q in
75:04 - order to add elements we call in Q so
75:06 - again same thing let's ass in Code
75:08 - Monkey then Iron Man and finally
75:11 - Spider-Man okay so we queue all of those
75:13 - and now on string Q we call DQ in order
75:16 - to grab the element this one again like
75:18 - the pop that we saw previously this one
75:20 - removes and Returns the object so if we
75:22 - do a console. right line on this one
75:25 - again Q is fifo first in first out so
75:28 - let's see what this one returns and if
75:30 - this one returns Code Monkey which was
75:31 - the first element that we add so some
75:34 - practical examples a q can be useful in
75:36 - something like a tycoon game where you
75:38 - have literally a queue of people like
75:40 - for example in my own game battle round
75:41 - Tycoon when there's a queue to join each
75:43 - Arena and for the sck a great practical
75:46 - example is how this can be very useful
75:48 - for making some kind of undo system so
75:50 - maybe something like a city Builder you
75:52 - can push onto the stack the action to
75:54 - place a building somewhere and then to
75:56 - make an undo you simply revert that
75:58 - action which would eventually demolish
76:00 - that building now importantly you always
76:02 - want to do it based on the last building
76:03 - that was built and not the first one so
76:05 - these two collections definitely have
76:07 - their own use cases although like I said
76:09 - normally I just use lists I've built
76:11 - both these systems like a q for a tyen
76:13 - game and an undo kind system I've built
76:16 - both of these using just list remember
76:18 - how on a list you can access the list on
76:19 - index zero and call remove that to
76:22 - remove it from a certain index so
76:23 - similar to a que or you can also just
76:25 - access it the last element on the index
76:27 - the last element on the list similar to
76:29 - a tack so personally I normally do all
76:31 - this custom logic using list but if you
76:33 - like these two collections can be quite
76:35 - useful so just remember they do exist
76:37 - next collection is what is called a hash
76:39 - set this one allows you to store a set
76:41 - of elements so let's make a hash set of
76:43 - string so for the string hash set let's
76:47 - construct it then go in the string hash
76:49 - set and this one we call add to add
76:51 - elements so for example add the element
76:52 - code monkey and Yep this one does work
76:55 - however one important thing about this
76:57 - type the hash set the important thing is
76:59 - that all elements have to be unique so
77:01 - like this it works but if I duplicate it
77:03 - and now I do a console. right line and
77:06 - let's print out the string hash set.
77:09 - count in order to count all the elements
77:11 - so we're adding two elements and then
77:12 - counting it so let's see what this
77:13 - returns any if this one returns a one
77:16 - because again we added a duplicate
77:17 - element so it actually didn't actually
77:19 - added so you can add elements you can
77:21 - remove elements and you can also do a
77:23 - union to combine multiple hat sets so
77:25 - the hashset can be useful for some kind
77:27 - of elements where you always want it to
77:29 - be unique so maybe a player ID so for
77:31 - those kinds of use case it can be a
77:33 - useful collection the next one we have
77:35 - the sorted list this one pretty simple
77:37 - like name implies this is the same as
77:39 - regular list but it gets sorted
77:40 - automatically so you can make a sord
77:42 - list of int another collection is a
77:45 - sorted set so this one pretty simple
77:47 - same thing it records a set of elements
77:50 - and it is constantly maintained in a
77:51 - sword order alternatively you also have
77:54 - a sword list this one has a key value
77:56 - pair then you have the sord dictionary
77:58 - and so on so there's a bunch of
77:59 - collections that serve various purposes
78:01 - like I said personally I really just
78:03 - sick with arrays lists and dictionaries
78:05 - I normally don't use any of these but it
78:07 - is good to know that the language can do
78:09 - all these things by default maybe you
78:11 - have some use case for which the queue
78:12 - is perfect so definitely make sure you
78:14 - know these collections
78:15 - exist hello and welcome I'm your codm in
78:19 - this lecture we're going to learn about
78:20 - the prams keyword that we can use in a
78:21 - function which then allows us to call it
78:23 - with any number of parameters
78:25 - okay so let's make a function to see it
78:27 - so let's make a private static void
78:29 - let's call it print player name and
78:31 - receive a string for the player name
78:33 - then over here just a console. right
78:35 - line on the player name so that's it
78:37 - super simple just a regular function
78:38 - like any other and up here we can call
78:40 - it and call it with code monkey and hope
78:43 - it does work it does print great but now
78:45 - let's say that I want to support two
78:46 - player names I want both of them I want
78:48 - support for both one player name and two
78:50 - player names so in order to do that I
78:53 - need to copy paste this and make another
78:54 - one with player name and then player
78:56 - name two see if this works but now I
78:58 - have two functions one with one
79:00 - parameter and one with two parameters
79:02 - and now let's say I want to support
79:03 - three parameters so again I need to make
79:05 - another function duplicate a ton of code
79:07 - and so on so right away you can see the
79:09 - issue this is basically the problem that
79:11 - pram solves so for that let's make just
79:13 - one function and up here let's call it
79:15 - to two parameters and right now yep we
79:17 - have an error because this one can only
79:18 - take one parameter so now here for the
79:20 - parameter let's write the keyword params
79:23 - we write params and then we write write
79:24 - the type for the parameter and in order
79:26 - to use with params this type needs to be
79:28 - an array so let's make a s array and for
79:31 - the player name array and up here let's
79:33 - just do a console. right line on this
79:35 - one. link just to see how many we call
79:37 - and right away we can see we have no
79:38 - errors up here so calling this function
79:40 - with two parameters does work let's run
79:42 - it and Y it prints out two and now let's
79:44 - call this function with just one
79:46 - parameter and again no errors and yep
79:48 - now it prints out with one also if we
79:50 - pass in with no parameters and yep we do
79:53 - have an empty array so that's it super
79:55 - simple you can just add the prams
79:56 - keyword and that way now we support any
79:59 - number of parameters this only has two
80:01 - requirements the first one is that the
80:02 - type over here needs to be an array for
80:04 - example if you make string it does not
80:06 - work if we make it just ring then no it
80:08 - does not work if we make an array of
80:10 - multiple Dimensions this one also does
80:11 - not work so it needs to be an array of
80:13 - some type it can be string it can be int
80:16 - it can be pretty much anything and the
80:18 - second requirement is that this one
80:19 - needs to come at the end so afterwards
80:21 - if we Define an INT H nope does not work
80:23 - here we have an error and the a says
80:25 - here a params parameter must be the last
80:27 - parameter in a parameter list so if we
80:29 - want to combine a params along with
80:31 - regular parameters we need to make sure
80:33 - the regular ones come before and the
80:35 - params comes after this way now yep up
80:37 - here we can type in an INT and then any
80:40 - number of strings and yep all of this
80:43 - does work that's it really simple and
80:46 - sometimes quite useful so anytime you
80:48 - have some function where you would like
80:49 - to receive any number of parameters
80:51 - whenever that happens always remember to
80:53 - use the param keyword
80:55 - hello and welcome I'm your kodm in this
80:57 - lecture we're going to learn about how
80:59 - we can use optional parameters in a
81:00 - function meaning parameters that we are
81:02 - not required to use okay so here is a
81:05 - normal regular function it supposedly
81:07 - spawn some kind of unit so it takes a
81:09 - spawn position the type of the unit the
81:11 - spawn rotation and some kind of Health
81:12 - amount and then to call this function we
81:14 - call it as usual so we call it and pass
81:16 - in all of our parameters if we run this
81:18 - it would work spawning unit of type
81:20 - melee with health 56 on this position
81:22 - this rotation but now let's say we want
81:24 - to spawn a ton of units and we don't
81:25 - want to be forced to pass in all of
81:27 - these parameters especially for example
81:29 - if some of them are going to be default
81:31 - to some amount there is going to be copy
81:33 - pasted all the time let's say for
81:34 - example the only thing we want to care
81:36 - about is the spawn position and then it
81:38 - will default to all the other ones so
81:40 - one option would be to Simply make
81:41 - another version of this function so
81:43 - let's make another one and let's make
81:44 - another version that only takes a spawn
81:46 - position and then in turn that one calls
81:48 - the other version passes in the spawn
81:50 - position and then passes in defaults for
81:52 - all the other ones so let's say melee
81:54 - turn. identity in order to have the
81:56 - regular rotation and let's say 100
81:58 - Health amount so we can do this and now
82:00 - do this and spawn on new Vector three of
82:03 - 1050 something like this and if there it
82:05 - is we have no error and running the code
82:07 - yep it did work it did use those
82:08 - defaults and the 1050 position so this
82:11 - works this is one valid option but we
82:13 - have another option where we don't need
82:15 - to Define multiple functions we can
82:17 - simply use optional parameters to use
82:19 - them it's really simple so we just have
82:21 - our function with our parameters and
82:22 - then after the parameter we simply write
82:24 - an equals and then assign some kind of
82:26 - default value so for example for the
82:28 - health amount let's default it to 100
82:30 - and now up here when calling this
82:31 - function we need to include all the
82:33 - other parameters so for this one let's
82:35 - include the unit type and let's include
82:37 - a quaran rotation but now we don't have
82:40 - to include a health amount so like that
82:41 - this one has no Health amount and if we
82:43 - run yep the health amount defaults to
82:45 - that 100 default so it's really this
82:47 - simple you just set equals and then some
82:48 - kind of default value we just have a few
82:50 - simple rules for how we can use this
82:52 - first is how the optional parameters
82:54 - these have to appear after the mandatory
82:56 - parameters so for example if here on the
82:58 - UN type before the Quan if on this one I
83:01 - Define an optional parameter like this
83:03 - no here we have an error it is saying
83:05 - optional parameters must appear after
83:06 - all the required parameters then another
83:08 - rule simply has to do with default
83:10 - values also by the way like I mentioned
83:12 - in the beginner section the compiler
83:14 - doesn't really care about new lines so
83:15 - if you have something with tons of
83:17 - parameters you can just place them all
83:18 - in a new line that way it becomes a
83:20 - little bit easier to read so like this
83:22 - okay so like I said the second rule
83:24 - simply has has to do with default values
83:25 - and the rule is how default values need
83:27 - to exist at compile time so here we
83:29 - cannot construct an object we cannot do
83:32 - new quion and then construct a new quion
83:35 - with something nope this does not work
83:37 - like it says here default parameter for
83:39 - Value spawn rotation must be a compile
83:41 - time constant so we cannot do this but
83:44 - we can use for example the qu. identity
83:47 - this is a constant and yep so we cannot
83:49 - use that but we can use the default
83:51 - keyword this will basically use the
83:52 - default value for that type so in the
83:54 - case of a quan which is a struct it is
83:56 - simply going to initialize that struct
83:57 - with everything at zero so for this
83:59 - struct we can use this and for the
84:01 - vector 3 same thing we can use that and
84:03 - for the unit type this one is an inome
84:05 - so we can just sign a default value and
84:07 - like this and everything works
84:09 - alternatively we can also use constants
84:11 - which is something that we're going to
84:12 - cover in a few lectures so you can
84:13 - define a constant and then you can
84:14 - definitely use that constant as a
84:16 - default value so optional parameters
84:18 - need to have certain defaults in order
84:19 - to work and then over here for passing
84:21 - in the parameters since we marked all
84:22 - those as defaults we can call it just
84:24 - like this and yep the code runs it works
84:26 - and works with all the defaults then
84:28 - alternatively we can pass them in one by
84:30 - one so for example if we want a spawn
84:32 - position let's put some kind of Spawn
84:34 - position and then for the unit type
84:36 - let's say we want like this so yep we
84:38 - just assigned two parameters and yep it
84:40 - did work but now let's say the only
84:41 - parameter that I want to assign is just
84:43 - the health amount so for that I go up
84:45 - here and I just write some kind of in so
84:47 - just 56 and no this one obviously has an
84:49 - error because argument one it expects a
84:52 - vector three not an INT so just like
84:54 - this you need to pass in all the
84:55 - parameters in order however you can
84:57 - actually pass them without being in
84:58 - order and for that we really just need
85:00 - to write the name of the parameter so in
85:02 - this case the parameter is the health
85:03 - amount so we write that and then a colon
85:06 - and yep just like this it does work this
85:08 - is basally calling the function and
85:10 - assign the health amount parameter to
85:11 - this value and on the other ones since
85:13 - we didn't assign them these Remain the
85:14 - defaults and if you're running the code
85:16 - we do see with health of 56 also by
85:18 - using the same method we can pass in
85:20 - parameters in any word you want so for
85:22 - example the health amount then let's
85:23 - pass in the unit type so unit type and
85:26 - unit type. something and Yep this is
85:28 - definitely valid code as long as I write
85:30 - the name of the parameters and then
85:31 - callon then give it a value everything
85:33 - does work all right so that's optional
85:35 - parameters it's quite a useful feature
85:37 - to help you avoid having tons of
85:38 - function versions for all kinds of
85:40 - parameter
85:41 - combinations hello and welcome I'm your
85:43 - Cod monkey in this lecture we're going
85:45 - to learn something very important the
85:47 - difference between value types and
85:48 - reference types if you don't know the
85:50 - difference then at some point in the
85:51 - future you won't go crazy because you
85:52 - think something is behaving as a
85:53 - reference when it's behaving as a copy
85:56 - so in C you have several types and
85:58 - mainly they are either value types or
86:00 - reference types reference types they
86:02 - store references to their underlying
86:03 - data whereas Val types they contain that
86:06 - data directly some examples of Val types
86:08 - are the symbol types like int float Bull
86:10 - and so on these are all value types and
86:12 - for reference types these are things
86:14 - like class object arrays and strings
86:16 - however importantly struct is a valid
86:18 - type we're going to cover strs in detail
86:20 - in the next lecture they look similar to
86:22 - classes but this is the one big
86:23 - difference between them strs are value
86:25 - types and classes are reference types
86:27 - and over here as you can see arrays are
86:29 - reference types even if the underlying
86:31 - data if you're making an array of int
86:32 - ins by themselves are value types but if
86:34 - you make an array of int the array is
86:36 - going to be a reference type and then
86:38 - strings are a bit of a special use case
86:40 - in that they are technically reference
86:42 - types but in some cases they behave like
86:44 - valid types so the big difference is
86:46 - shown down here with reference types you
86:47 - can have multiple variables and you can
86:50 - have all those variables all of them
86:51 - pointing to the same underlying object
86:53 - whereas with value types any variable
86:55 - you make with some kind of value if you
86:57 - then assign that variable to another
86:59 - variable you are making a copy instead
87:01 - of a reference to the original value
87:02 - another difference is how reference
87:04 - types can be null whereas value types
87:05 - cannot so for example if you have some
87:07 - kind of enome for your weapon types if
87:09 - the player does not have any weapon you
87:11 - cannot set it to null enums cannot be
87:13 - null neither can inss floats balls and
87:14 - so on so here let's see some code first
87:17 - let's define an INT which is a simple
87:19 - value type okay very basic just the
87:21 - variable named a and contains the value
87:23 - seven but now let's make some kind of
87:25 - class which is going to work as a
87:26 - reference type so here let's make a
87:29 - class call it my class and inside let's
87:31 - just expose an INT a okay and now up
87:34 - here let's create a new my class so my
87:37 - class equals a new my class and then
87:39 - let's go inside that one and set the a
87:41 - to some kind of value let's say seven
87:43 - and then let's make another my class
87:46 - call it my second class and now let's
87:48 - assign this one to the my class and over
87:50 - here we go inside the my second class
87:52 - and modify a to a different so here now
87:55 - we have two different variables we're
87:56 - initializing the first one like this
87:58 - then we're assigning it to the second
88:00 - variable and then we're modifying the
88:02 - value inside of the second variable so
88:04 - if we print out over here the my class.
88:06 - a what do you think this will say so
88:08 - let's do a console. right line and print
88:10 - this out let's see if it says seven or
88:11 - five and if there it is it does say five
88:14 - again that is because classes are
88:15 - reference types so over here even though
88:17 - we have two separate variables they are
88:19 - both pointing to the same underlying
88:21 - class so they're both pointing to the
88:23 - same underlying memory position they're
88:25 - both pointing the same actual object
88:27 - both them are referencing just a single
88:29 - instance of our my class so by going
88:31 - through either of these we're actually
88:32 - modifying the same underlying object we
88:35 - do not have two objects we have just one
88:36 - and two references to that same object
88:38 - so when we modify this one we're not
88:40 - modifying it just on this second object
88:42 - but since this one has the same
88:44 - reference as this one both of them are
88:45 - modifying the actual underlying object
88:47 - so by modifying either of them we are
88:49 - modifying the same underlying object now
88:51 - let's look at this exact same example
88:53 - but using our ends which are value types
88:55 - so you've got an INT a of seven then
88:57 - let's define an INT B and let's assign
88:59 - it to the value of a and then let's go
89:01 - inside B and set B to something else
89:03 - let's put it on five and now let's do a
89:06 - console. right line on a and let's see
89:08 - what this one prints so we print seven
89:10 - or five and if there it is the result is
89:12 - seven again this is because int int is a
89:15 - value type and not a reference type so
89:17 - over here we're defining a variable a
89:19 - and assigning the value seven and then
89:21 - we're assigning B and then we're
89:23 - defining B and assigning it to the value
89:25 - of a but again since a is a value type
89:27 - this is going to essentially copy the
89:28 - data that is currently stored inside a
89:30 - so after this point we have two
89:32 - variables and each of them holds a copy
89:34 - of their data and then over here when we
89:36 - modify B that is only modifying the copy
89:37 - that was created in here and not
89:39 - modifying the original data that we have
89:40 - in here this is the one big difference
89:42 - between valid types and reference types
89:44 - is how up here we are working with a
89:45 - reference and we have two references
89:47 - that both of them point to the same
89:48 - underlying object whereas down here we
89:50 - have copies so we have one copy here one
89:52 - copy there and by by modifying the
89:54 - second copy this has no relation to the
89:56 - original data now the scenario that is
89:58 - most important to know this difference
89:59 - is when working with structs which we're
90:01 - going to cover in detail in the next
90:02 - lecture for now don't worry too much
90:04 - about what they are I just want you to
90:05 - see the difference so a struct is made
90:07 - pretty much the same way as a class we
90:09 - just change the keyword into struct and
90:11 - let's name this my struct so like this
90:13 - and up here we can write literally the
90:15 - exact same code but write it with a
90:17 - struct instead of our class so up here
90:20 - use my struct then over here here this
90:22 - one is my struct
90:24 - and my second struct and then we modify
90:27 - this one here and we print out the my
90:29 - struct a okay so here's our test
90:32 - literally we have the same code down
90:33 - here as we have up here the only
90:35 - difference is one code is working with
90:37 - the class another one is working with
90:38 - the struct so let's see the difference
90:39 - between these two ending up with the
90:41 - exact same code we have two different
90:43 - results that is exactly because of the
90:44 - difference between value types and
90:46 - reference types the class has a value of
90:48 - five and the struct has a value of seven
90:49 - that is because the class up here again
90:51 - both of these are referencing the same
90:53 - underlying object so when we modify the
90:55 - second one we're both modifying the same
90:57 - unlying object so when we print out the
90:59 - data stored in the first one again same
91:01 - object so this one prints out five and
91:03 - yep we do have five and then down here
91:05 - when we're structs structs are value
91:07 - types so over here we create a brand new
91:09 - struct but then on the second one when
91:11 - we assign it we're actually creating a
91:13 - copy of the data so now this one this
91:15 - one has a completely separate copy that
91:17 - has no relation no reference to the
91:19 - original data to the original myru so
91:21 - when we modify this one we're only
91:22 - modifying this copy and not touching
91:25 - this one at all so that is why on the
91:26 - Str the result is seven which is the
91:28 - original value that we set over here
91:29 - because when we modify this we're only
91:31 - modifying this copy and have no relation
91:33 - to this original data now this
91:35 - difference between Valu reference types
91:37 - is also very important in functions for
91:39 - example private static void my function
91:42 - let's do some kind of test function and
91:44 - here let's receive of type my class
91:46 - another one of type my struct then let's
91:49 - just go inside and put it on something
91:51 - so my class and my struct let's modif if
91:54 - I so do the exact same test as
91:55 - previously let's just comment out this
91:57 - testing code and then over here let's
91:59 - create a my class my class let's create
92:02 - a brand new one then let's put my class
92:05 - set the a to 7 and create a new struct
92:08 - we also set it at seven so both them
92:10 - have the same value in their a field and
92:12 - then we call my function pass in our my
92:15 - class and our my struct and then let's
92:17 - do a console. right line on the my
92:20 - class. a then some space and my struck.
92:23 - a okay so again let's see what happens
92:26 - and yep there it is my class has a value
92:28 - of five and my struct has a value of
92:29 - seven again that's the same difference
92:31 - between valid types and reference types
92:33 - it's how when we call this function and
92:35 - we pass in our values the class is going
92:37 - to be passed in as a reference so as we
92:39 - modify this one we're actually modifying
92:40 - the reference so we're modifying the
92:42 - underlying object that was sent into
92:44 - this function whereas for the struct the
92:46 - function receives a copy of the data so
92:48 - the copy that we receive over here
92:50 - inside the function this has no relation
92:51 - to the actual data defined up here so so
92:53 - whil inside this function modifying this
92:55 - class modifies the actual data outside
92:57 - of it but modifying this struck only
92:59 - modifies the local copy also what I
93:01 - mentioned while go about how AR raise
93:03 - our reference types so for example let's
93:05 - do another test so let's make our
93:07 - function take in some kind of int and
93:09 - then an interray then over here let's
93:12 - modify the value of a and let's go
93:14 - inside the interray on index zero and
93:17 - let's modified value okay so now up here
93:19 - let's define some kind of int and let's
93:22 - define an INT array let's construct an
93:24 - interray and just put a value on there
93:27 - okay so now we call my function pass in
93:30 - a and the interray and now let's do a
93:32 - Conant out right line let's print out
93:35 - the A and then print out the interray on
93:38 - index zero okay so again let's see what
93:40 - this does and if there it is same thing
93:42 - the int was not modified inside the
93:44 - function but the array was that is
93:46 - because inss are value types so this one
93:49 - is passed in as a copy but in arrays
93:51 - these are reference types so when we
93:53 - pass in an interray onto our function
93:55 - we're passing in a reference to the
93:56 - original data so when we modify this
93:58 - inside the function we're modifying the
94:00 - actual original data and also since
94:02 - we're on the topic of value types and
94:03 - reference types I mentioned a while ago
94:05 - how value types cannot be null so you
94:06 - cannot Define an INT b equals null so
94:09 - this is not possible we have an error
94:11 - cannot convert null into n because it is
94:13 - a non-nullable value type however if you
94:15 - really want to do this you can do it
94:17 - instead you just have to use a custom
94:19 - type called nullable and with this you
94:21 - can make any value type like ins BS
94:23 - floats and so you can make any of those
94:24 - into nulls and this is something that
94:27 - can sometimes be useful I cover nullable
94:29 - in detail in a lecture in the advance
94:30 - section okay so that's the differences
94:32 - between Val types and reference types be
94:35 - very very careful with this difference
94:37 - it might sound like I repeated myself
94:38 - way too much during this lecture but
94:40 - that's because this is really so
94:41 - important always keep in mind whether
94:43 - you are working with a copy or a
94:45 - reference one of the most important ways
94:46 - to see this difference in action is in
94:48 - the difference between classes and
94:50 - structs so let's learn about strs in the
94:52 - next lecture hello and welcome I'm your
94:54 - codemy in this lecture we're going to
94:56 - learn all about structs these are
94:58 - structures of data that are similar to
95:00 - classes but also a little bit different
95:02 - okay so structs like I said are pretty
95:03 - similar to classes in how you define
95:05 - them you literally just swap class for
95:07 - struct so for here for example let's
95:09 - make a class named player right now this
95:12 - is a class and just by swapping this
95:13 - into struct yep now this one is a struct
95:15 - so that's it super simple however just
95:17 - doing this has some really important
95:18 - implications the main one is how classes
95:20 - are reference types and strs are value
95:22 - types which is what we covered in the
95:24 - last lecture this means that when you
95:26 - use something as a class like a class
95:27 - parameter it gets passed in as a
95:29 - reference whereas with a struct it gets
95:31 - passed it as a copy so here we can do a
95:33 - simple quick test make a player struct
95:35 - and a player class then just run this
95:38 - code just making the usual start
95:40 - function because over here I'm working
95:41 - in unity let's make a private void test
95:43 - function test function struct and
95:46 - another one test function class okay so
95:48 - here is some code we create a new struct
95:49 - and new class and we assign a field in
95:51 - set of them to the value one then we
95:53 - have have two functions and these
95:54 - functions these do the same thing so
95:56 - they just set that field into two and
95:58 - then we do a log so let's see whether
96:00 - this one keeps the number one or whether
96:02 - it keeps number two any like the log
96:04 - says here the struct keeps in number one
96:05 - whereas the class keeps in number two
96:07 - again that is because struct is a value
96:09 - type meaning these are passed in as a
96:10 - copy so over here we are modifying the
96:12 - copy and not the original data but
96:14 - classes are reference type so when we
96:16 - modify a class inside a function it
96:17 - modifies the actual position memory the
96:19 - actual original object so the reference
96:21 - type gets changed but the value type
96:23 - does not get changed this difference is
96:24 - really extremely important so I truly
96:26 - hope you fully understood everything in
96:27 - the previous lecture if not go back to
96:29 - it and rewatch it it is really important
96:31 - so you don't get to confused like I did
96:33 - many times before I memorize this this
96:35 - is one of the main differences between
96:37 - structs and classes how classes are
96:39 - reference types and structs are value
96:40 - types in general structs are mainly used
96:42 - as just data containers meant to
96:44 - organize your data the simplest example
96:46 - is really just the vector three type
96:48 - inside of unity so we can inspect this
96:50 - one so let's right click and go to the
96:52 - definition and up over here we do see
96:54 - this is a struct and it's a struct that
96:56 - pretty much just hold three components
96:58 - so x y and Zed so rather than having
97:00 - three separate Fields whenever we want
97:02 - some kind of position we just make a
97:03 - struct that in itself has these three
97:05 - Fields whenever we have several pieces
97:07 - of data that all of them make up one
97:09 - logical unit then perhaps consider
97:11 - making that a struct however again
97:13 - remember how it's a value type for
97:15 - example in unity you cannot even
97:16 - directly modify one of those components
97:18 - so if I set the position do 5 equals
97:20 - something if I do this nope it does not
97:22 - work now technically this is more
97:24 - related to the fact this position is
97:25 - actually a property and not a variable
97:27 - but still the reason why it's a property
97:28 - is because it actually copies the data
97:30 - and sends it over to the back end of the
97:32 - engine itself so in unity when you need
97:34 - to modify something you need to assign
97:36 - it to a new Vector 3 so basically you
97:38 - need to give it another copy of another
97:39 - piece of data in order to actually
97:40 - modify it so usually structs are used in
97:42 - an immutable manner meaning they never
97:44 - change once you create a struct with a
97:46 - certain value usually you keep it at
97:48 - that value however that is not an
97:49 - absolute requirement it's really just a
97:51 - good convention to follow for example
97:53 - the Vector three struct so let's do a
97:55 - position Define it as something 10 21
97:58 - something and like this this struct
98:00 - inside actually contains the normalized
98:03 - function and if we do this and then do a
98:05 - debug down log on this position let's
98:07 - see Yep this function does indeed modify
98:10 - the underlying data so in theory strs
98:12 - can indeed be mutable they can change
98:14 - but in order to avoid confusion you
98:16 - should probably avoid this as much as
98:17 - possible you should probably always
98:19 - treat your structs as immutable just
98:20 - following that one simple rule will make
98:22 - things much simpler to understand now
98:24 - strs like classes they can have Fields
98:26 - they can also have functions like we saw
98:27 - here the normaliz and they can even have
98:29 - properties one big difference is how
98:31 - they cannot inherit I talk about
98:33 - inheritance in more detail in the next
98:34 - lecture but basically with a class you
98:36 - can make it inherit another class so po
98:39 - class base class and then poly class for
98:43 - some kind of unit class and this one can
98:45 - extend Base Class so this works this is
98:48 - valid code but over here on this player
98:50 - struct if we try extending Base Class
98:52 - nope and error struct s cannot extend
98:54 - classes the one thing they can do is
98:56 - actually what this error message is
98:57 - telling us they can indeed Implement
98:59 - interfaces I will also cover interface
99:00 - in detail in a few lectures then strs
99:02 - can also have Constructors just like
99:04 - classes however in most C versions you
99:07 - cannot have a parameterless Constructor
99:09 - so over here public player just like
99:11 - this with no parameters and nope we have
99:13 - an error so as you can see parameterless
99:16 - Constructor is not available in C 9 but
99:19 - if you're using a letter version this is
99:21 - possible instead of defining it yourself
99:22 - it always has one by default so up here
99:24 - we can do new player and Yep this works
99:26 - so for the constructors if we Define any
99:28 - of them it has to have some kind of
99:30 - parameter so usually on the Constructor
99:32 - you add some kind of thing to initialize
99:34 - the acttion struct itself and then one
99:35 - common error with Constructors is this
99:37 - one right here which is all of the
99:39 - elements all the fields must be fully
99:40 - assigned before controls returned to the
99:42 - color so if we Define a Constructor like
99:44 - this we must initialize all the fields
99:46 - so over here this. a equals a and yep
99:48 - now it does work so every Constructor
99:50 - you make has to initialize every single
99:52 - field within that struct again this has
99:54 - to do with difference between value
99:55 - types and reference types as soon as you
99:57 - define something of struct type like for
99:59 - example some kind of variable like a
100:01 - kind of player variable like this as
100:03 - soon as you define it like this if you
100:04 - define it like this it's an error
100:06 - because it is uninitialized but we can
100:08 - initialize it we can just use default
100:10 - this is a keyword that pretty much
100:11 - Returns the default of whatever type we
100:13 - have so if we do it like this let's see
100:15 - what this says and yep the default of a
100:17 - struct is indeed a struct and then we
100:19 - can even go inside of it so let's print
100:21 - out the A and yep so it creates a struct
100:24 - and initialize the variables all of them
100:25 - at zero so that's what default does
100:27 - initialize everything with a zero value
100:29 - however if we now make this into a class
100:31 - and if there it is default value for a
100:33 - class is null and since it's null that
100:35 - means it has no object so we cannot
100:36 - access anything inside of it again goes
100:38 - back difference between value types and
100:39 - reference types reference types by
100:41 - default are null whereas value types
100:43 - they always have some kind of value so
100:44 - when you make a struct you can create a
100:46 - new struct like we saw by using the
100:48 - default parameter on list Constructor or
100:50 - we can use any custom Constructors or we
100:52 - can just make the struct and over here
100:54 - Define any kind of thing so a equals 2
100:56 - and Yep this is valid code for
100:57 - initializing a struct one more important
100:59 - thing about structs is once again how
101:01 - they are related to Value types and not
101:03 - reference types so one big difference is
101:05 - how they are sored in the stack instead
101:07 - of the Heap these are two different
101:08 - positions in memory one is much more
101:10 - efficient than another I actually have a
101:12 - nice story about this in my first steam
101:14 - game Survivor squad for the
101:16 - implementation of the fog of war the
101:18 - world basically has a ton of tiny quads
101:20 - on top then as the player sees some area
101:22 - those quads are Mark as invisible and
101:24 - they are not rendered so each of those
101:25 - tiny quads needs a little bit of data in
101:27 - order to know the position and know
101:29 - whether it's visible or not in the first
101:31 - version of this system I started that as
101:33 - a class and it was terribly slow and
101:34 - then I literally just swapped class for
101:36 - struct and suddenly got a massive speed
101:38 - boost all because of how struges are
101:39 - very efficiently stored in memory so in
101:41 - general you use struges to hold
101:42 - different pieces of data together and in
101:44 - general you should use them as immutable
101:46 - pieces of data meaning they should not
101:48 - change and consider using them when you
101:50 - have some kind of memory performance
101:51 - issues hello and welcome I'm your Kodi
101:55 - in this lecture we're going to learn
101:56 - some intermediate topics related to
101:58 - classes things like inheritance
102:00 - polymorphism protected override and a
102:02 - bunch more okay so in the basic section
102:04 - we already learned the absolute basic of
102:05 - classes how we can define a class which
102:07 - has Fields properties and functions and
102:09 - then you can create instances of that
102:11 - class so that's the basics but of course
102:13 - classes can do so much more one of the
102:15 - main things they can do is simply the
102:16 - concept of inheritance that is how you
102:18 - can have one class that inherits
102:20 - something from some other Base Class for
102:22 - example let's say we have this General
102:23 - unit class meaning this represents any
102:25 - kind of unit in our game and all the
102:27 - units are going to have some kind of
102:28 - speed and some kind of move function and
102:30 - then we can have the player and the
102:32 - player is a type of unit and to Define
102:34 - that relationship we can make the player
102:36 - class extend the unit based class that
102:38 - means that player is going to inherit
102:39 - everything from this unit class so on
102:41 - the player class itself we are not
102:42 - defining any speed field or any move
102:44 - function instead just by making it
102:46 - extend the base class it is going to
102:48 - inherit all of these elements
102:49 - essentially the player class this one
102:51 - contains everything inside player and
102:53 - everything inside unit then we can have
102:55 - another enemy class which again is also
102:57 - meant to be some kind of unit so we also
102:59 - extend the same unit based class and
103:00 - again this one is going to inherit
103:02 - everything so the enemy class itself is
103:03 - also going to have a speed move function
103:05 - and so on so anytime we have some common
103:07 - logic that belongs to any kind of unit
103:09 - we just need to add it onto the unit
103:11 - class itself and anything that inherits
103:13 - from that unit class any of those class
103:15 - are going to automatically receive the
103:16 - new code that we add to our unit and
103:18 - then each of the classes that inherit
103:19 - from base class each of those can also
103:21 - have code themselves that is unrelated
103:23 - to the base class so for example the
103:24 - player can have some kind of move player
103:26 - function and the enemy can have some
103:28 - kind of enemy health field these only
103:30 - belong to these classes and do not
103:32 - belong to the base class so for example
103:33 - the enemy has no relation to the player
103:35 - move player and the player has no
103:36 - relation to the enemy health so always
103:38 - keep in mind that the inheritance does
103:40 - not go both ways meaning the above unit
103:42 - this one over here has no knowledge that
103:44 - there is a player extending it and the
103:46 - player has this kind of function so the
103:47 - player inherits everything from unit but
103:49 - unit does not know anything about player
103:51 - or enemy okay so let's see the synx here
103:53 - is the basic unit class we've got a
103:55 - speed field and a move function and now
103:57 - let's make a clear so let's make a
103:59 - player class and now in order to make
104:01 - this one extend our unit class for that
104:03 - after the player class name after that
104:05 - we write a con and then the name of the
104:07 - class that we want to extend so in this
104:09 - case unit and if that's it just like
104:10 - this the player is going to be extending
104:12 - the unit class if we write any code
104:14 - inside of here we can already access the
104:15 - unit Fields so for example let's make a
104:18 - Constructor so a public player
104:20 - Constructor and over here we can access
104:22 - yep we can access the field we can set
104:24 - it to something and we can call move
104:25 - function yep that does work so even
104:27 - though speed and move are not defined
104:28 - over here in the player itself since the
104:30 - player extends unit it also inherits all
104:32 - of this but then like I said inheritance
104:34 - does not go both ways so up here on this
104:36 - one let's make one for the move player
104:39 - let's make some kind of move player
104:40 - function and now down here on the unit
104:42 - script if we try calling that nope that
104:44 - does not work the unit does not know
104:46 - anything named move player this function
104:48 - only exists on the player class itself
104:50 - now another thing we can do is override
104:51 - some base function so for testing let's
104:53 - actually go up here let's create a new
104:55 - unit so let's build a new unit and a new
104:58 - player okay so we have these and if we
105:01 - call uh the move function and on the
105:04 - player let's call the same move function
105:06 - so if we run this it should print this
105:08 - line twice and if that's correct it only
105:10 - print three times cuz I included over
105:11 - here in the Constructor but yep it did
105:13 - work so now like I said we can overwrite
105:15 - some base function so for that over here
105:17 - on the Move function let's add the
105:19 - keyword virtual and now we can go onto
105:22 - the player and on the player let's
105:24 - define a function Exel like this one so
105:26 - let's define one just like this inside
105:28 - let's say move player and if we do it
105:31 - just like this we actually see this
105:32 - green squiggling line and we can check
105:34 - and Y this is basically telling us that
105:37 - this one is hiding the inherited member
105:39 - and if we want to override an
105:40 - implementation we can add the override
105:42 - keyword or add new keyword if we want
105:44 - new function but nope we do want to
105:45 - override that one so on the base L we
105:47 - add the virtual keyword and on this one
105:49 - we add the override keyword and yep so
105:51 - now like this using this code so the
105:53 - unit has this one it's a virtual
105:55 - function and this one is overriding that
105:56 - function with a different message so we
105:58 - have two different messages and up here
106:00 - we are creating a unit creating a player
106:02 - and then calling the same move function
106:03 - on both them so now let's see what this
106:05 - prints and there it is so when we call
106:07 - move on a unit it is running move unit
106:10 - but when calling the same move function
106:11 - on a player it is actually running the
106:13 - overridden logic so this is how you can
106:16 - extend some Bas class so make it inherit
106:18 - from something else and then override
106:20 - certain functions to have different
106:21 - behavior from the base class now this is
106:23 - also a great time for me to mention how
106:25 - you can override the two string function
106:27 - basically every single class in C is
106:29 - always going to extend the base object
106:31 - class and that base object class always
106:33 - has a two string function so for example
106:35 - up here we did not Define any kind of
106:36 - two string in here but we can call two
106:38 - string Yep this does work as you can see
106:40 - this exists in the object Base Class
106:42 - this is the main way of how any single
106:44 - object any single type can be converted
106:46 - onto a string we can do a console. right
106:49 - line and we can print out for example
106:51 - player and Yep this does work because
106:53 - this one is going to automatically call
106:54 - two string in order to convert the
106:56 - player onto a string so anyways yep all
106:58 - objects have this function implemented
107:00 - automatically however if we run this yep
107:03 - the player just says essentially just
107:05 - prints out the actual name for the type
107:07 - so we're inside the names space c course
107:09 - we're inside the program class so that's
107:11 - the program class up here and then
107:13 - inside the player type so sometimes
107:15 - printing this is not very useful but the
107:16 - two string function this one is also
107:18 - marked as virtual which means we can
107:20 - also override it so let's do the same
107:21 - thing let's you public override and
107:23 - automatically this one already shows us
107:25 - some code hints so let's override the
107:27 - two string function and it like this so
107:29 - it returns a string and it's call two
107:31 - string and over here we just return the
107:33 - string that we want to name our player
107:35 - so for example let's give the player
107:36 - some kind of name so let's give it a
107:38 - string for the player name and let's
107:40 - receive this string over here so we've
107:42 - got a string for the player name and set
107:43 - this. player name equals this and then
107:46 - down here let's print out player and
107:48 - then the player name okay so we do this
107:50 - and up here let's print the name as code
107:52 - mon key and then we do the same thing so
107:54 - let's do a console the right line and
107:56 - let's just put player so not even any
107:58 - two strings so just like this let's see
107:59 - what this does and if there we go now we
108:01 - have overridden that behavior so we can
108:03 - now say whatever message we want from
108:04 - our custom type okay great so with this
108:07 - we can inherit from Basel and we can
108:09 - overwrite some functions and of course
108:11 - what I'm saying here applies to any
108:12 - class you want to extend you can have as
108:14 - many classes extending a base class as
108:16 - you want so for example we can make a
108:18 - class for an enemy and also make the
108:20 - enemy also extend our unit and for on
108:23 - this one we can also again we can also
108:24 - override the exact same move function so
108:27 - we can do this this one is move enemy
108:29 - and now here let's do the same testing
108:31 - code Enemy enemy let's construct a brand
108:33 - new enemy and then we call enemy. move
108:36 - and let's see what this runs and if
108:38 - they're going like that so move unit
108:40 - move Player move enemy even though over
108:41 - here we are always calling the exact
108:43 - same function so basically we have three
108:45 - implementations of this and each of them
108:47 - is slightly different because they're
108:48 - overriding the base implementation
108:50 - basically the Only Rule with inheritance
108:52 - is how you can inherit once you can only
108:54 - extend a single Base Class so if over
108:56 - here we were to define a unit 2 okay
108:59 - here's a complely separate class and
109:00 - over here let's try to extend that one
109:03 - as well and NOP we have an error it is
109:05 - telling us that eny cannot have multiple
109:07 - based classes so we can only ever
109:09 - inhered from a single Base Class if you
109:11 - want to achieve something similar to
109:12 - that kind of result for that we have
109:14 - interfaces which we're going to cover
109:16 - later on in a future lecture but you can
109:18 - definitely go the other way as deep as
109:20 - you want so over here for example we
109:21 - have enemy which turn extends the unit
109:23 - class then we can go one step further so
109:25 - let's have another class for example the
109:27 - enemy melee and let's have this one
109:29 - extend enemy and Yep this does work then
109:32 - we could have another one for the anime
109:34 - melee boss something like this so for
109:36 - some kind of boss that also extends
109:37 - melee this one extends enemy melee just
109:40 - like this and yep all of this is valid
109:41 - code however just like this you can
109:43 - probably already tell how this can
109:45 - become quite confusing quite quickly so
109:47 - over here let me point out that
109:49 - inheritance is a tool that can be very
109:50 - powerful but also can be very easily
109:53 - abused to the point where it's much
109:54 - worse than not using it there's a common
109:56 - programming joke that goes basically you
109:58 - want the banana so you construct a
109:59 - banana but end up with an entire jungle
110:01 - that's because the Banana class would
110:03 - extend the fruit class which in turn
110:04 - would extend the tree class which
110:06 - requires the jungle class and so on so
110:07 - if you have complex really deep
110:10 - inheritance structures if you have that
110:11 - you can end up with some really messy
110:13 - code one common saying to counteract
110:15 - this is prefer composition over
110:16 - inheritance this is how you can instead
110:19 - of having a complex web of inheritance
110:20 - instead of that you can compose your
110:22 - comp objects based on separate
110:24 - components that make up the final object
110:26 - now this is a more advanced topic so
110:27 - don't worry too much if you're not fully
110:29 - understanding everything that I'm saying
110:30 - here I'm only saying this just in case
110:31 - you were curious and want to research
110:33 - further on this topic if you want you
110:35 - can Google composition versus
110:36 - inheritance and you will get a ton of
110:38 - really interesting results the only
110:39 - thing I want you to take away right now
110:41 - is just remember to be very careful when
110:42 - you're using inheritance always ask
110:44 - yourself if you absolutely need it
110:46 - sometimes you do but many times chances
110:48 - are there's a better way to achieve the
110:49 - same result in a much easier way that
110:51 - does not become insan complex but
110:53 - inheritance does have its place so let's
110:55 - learn a little bit more about it one
110:57 - extremely crucial thing that is not
110:58 - related specifically to just inheritance
111:00 - is the concept of polymorphism this is
111:03 - how you can treat an object as a
111:04 - different type of the object as long as
111:06 - those types are related so for example
111:08 - up here if we Define a field of type
111:11 - player so we have this field and we can
111:13 - assign this to the player that we
111:15 - created Yep this does work however we
111:17 - cannot assign our enemy object over here
111:20 - that is because you cannot implicitly
111:21 - convert our enemy into a player because
111:24 - again going back to the diagram even
111:26 - though they share the same Base Class
111:27 - they by themselves are two complet
111:29 - separate types however now let's make a
111:31 - field of type unit so we have a unit and
111:34 - obviously for this one we can assign our
111:36 - unit type Yep this does work and on this
111:38 - one we can also assign the player type
111:40 - Yep this also does work because again
111:42 - player extents unit so it can be used in
111:44 - place of a unit and same thing for the
111:46 - enemy object Yep this one also does work
111:49 - and now if we go into this unit 2 and
111:51 - call the move function let's see what
111:53 - this runs and if there it is this one
111:54 - runs the move enemy that is because even
111:56 - though we assigned this to a unit
111:57 - variable even though we did the object
111:59 - itself is still an enemy object so the
112:01 - object itself the type itself that one
112:03 - is still overriding our base move
112:04 - function and for example if we assign
112:06 - this to player Yep this does work but
112:08 - like we saw on the player itself let's
112:10 - define a public void move player so
112:12 - let's define this function that only
112:14 - exists on the player type so we did this
112:16 - and if we go over here onto player and
112:18 - call move player Yep this does work this
112:19 - is valid code however if we go through
112:21 - the unit and call move player and nope
112:23 - that does not work it does not exist
112:25 - that is because again this field this
112:27 - one is now of type unit even though the
112:29 - object itself is of type player since
112:31 - we're accessing it of type unit we can
112:32 - only access the things that unit itself
112:34 - has so for example one fun thing you can
112:36 - do with this kind of property is for
112:38 - example having list of units for some
112:41 - kind of unit list you can do this and
112:43 - now inside of here we can place a unit
112:45 - we can place a player and we can place
112:46 - an enemy and Yep this works it works
112:48 - because our player class and our enemy
112:50 - class those extend our unit base class
112:53 - so they can all be cast down into a unit
112:55 - type now like I said the concept of
112:56 - polymorphism which is basically using
112:58 - one type as a different type that
113:00 - concept is not specific to inheritance
113:02 - for example it also works with interface
113:04 - which we're going to see in the next
113:05 - lecture if we have some kind of function
113:08 - that requires the player specific type
113:09 - if so then we need to receive some kind
113:11 - of parameter specifically as type player
113:13 - but we can do a bunch of logic that
113:14 - works on just units and that logic won't
113:17 - work on units it won't work on players
113:18 - enemies and anything else that extends
113:20 - our unit based class and now that we are
113:22 - only looking at inheritance we can also
113:23 - look at a different access modifier so
113:25 - far we've pretty much just been using
113:27 - public and private private means that
113:29 - only this class can access it and public
113:31 - means that anything else can access but
113:33 - when it comes to inheritance we have
113:35 - another Super useful one and that is
113:36 - protected for example let's go down into
113:39 - our unit and for example over here for
113:41 - the speed instead of public let's make
113:43 - this protected so by making it protected
113:45 - we can use it over here inside the unit
113:47 - class so yep this works this is valid
113:48 - code and importantly over here on the
113:51 - player Yep this one is still valid code
113:53 - we have no errors here by making it
113:55 - protected that means that only this
113:57 - class only the class that defines it and
113:59 - any classes that extend this Base Class
114:01 - any of those can access this protected
114:03 - field so up here the player can indeed
114:04 - access the speed but for example up here
114:06 - in our static in our main program over
114:09 - here if we try going into a unit and try
114:11 - accessing the speed field I hope it does
114:13 - not work unit. speed is inaccessible due
114:15 - to its protection level so if you make
114:17 - something protected it is only
114:19 - accessible from within that class and
114:21 - any other class that extend that class
114:23 - so if you have some kind of behavior in
114:25 - your base class that the extend classes
114:27 - should be able to modify and only those
114:29 - classes if so then make it protected or
114:31 - for example in a field make it protected
114:33 - virtual and yep like this all the other
114:35 - class can access so this one just needs
114:37 - to modify into protected override and
114:39 - then same thing on this one protected
114:41 - override and by doing that the class
114:43 - that extend That Base Class those canate
114:45 - access it but over here this one can no
114:47 - longer access then one really
114:48 - interesting thing is the concept of
114:50 - abstract classes the these are classes
114:53 - that have a definition but cannot be
114:54 - constructed directly for example let's
114:56 - say our unit class here this one should
114:58 - never be created this should simply be a
115:00 - base class that should be inherited by
115:02 - the player or the enemy or any other
115:04 - kind of unit type but we're never meant
115:06 - to have just a base unit class so for
115:08 - that we can add the abstract keyword and
115:11 - Yep this one marks this class as
115:13 - abstract and now if we go up here yep we
115:15 - do see this error since a class is
115:16 - marked as abstract we cannot create an
115:18 - instance of this type this can be really
115:21 - useful to provide a base definition for
115:22 - something but also make sure that base
115:24 - definition itself can never be used
115:25 - directly only the class that extended
115:27 - can be created along with marking a
115:29 - class as abstract you can also Mark
115:31 - functions so for example let's make a
115:33 - public abstract and make some kind of
115:36 - void attack function so we do this and
115:38 - then we just do a semicolon meaning we
115:40 - do not provide an implementation for
115:42 - this function and instead just by
115:43 - defining this we can see we have some
115:45 - errors over here in the enemy class and
115:46 - the player class and here yep it says
115:48 - that we must implement the attack
115:50 - function so if the B class has some kind
115:53 - of abstract function we have to
115:55 - absolutely Implement that and over here
115:57 - by the way quick tip Visual Studio
115:59 - actually has these quick tips so if you
116:00 - click on this little thing it tells you
116:02 - to implement the abstract class and it's
116:03 - going to automatically write it and if
116:05 - there does so we need to write that one
116:07 - and yep no longer have an error so this
116:09 - can be useful if you have something
116:11 - where you are not meant to provide any
116:12 - kind of default implementation you just
116:14 - mark it as abstract and any class that
116:16 - extends this class W be forced to
116:18 - provide their own implementation to this
116:20 - function but if you do want to provide
116:21 - default implementation then just do it
116:23 - like this just make a regular virtual
116:25 - function and then any other class can
116:27 - either override or not override then
116:29 - another keyword is sealed what this one
116:31 - does is it prevents classes from
116:33 - extending this one so as you can see up
116:35 - here we have an error since we marked
116:36 - that one as sealed it is telling us
116:38 - enemy cannot derive from seal type unit
116:40 - now personally I've never really used
116:41 - seal but in complex projects with tons
116:44 - of classes sometimes it can be wise to
116:46 - make something sealed if it is never
116:47 - supposed to be extended again remember
116:49 - the main clean code principle the main
116:51 - goal is really to to minimize complexity
116:53 - so if you have some class that is never
116:55 - meant to be extended no matter what if
116:57 - so you can make it seal in order to help
116:58 - you make sure that the compiler enforces
117:00 - that rule so it can be useful in that
117:02 - way but personally I rarely ever so it
117:04 - can be useful that way but personally I
117:06 - never really use it then yet another
117:08 - more advanced thing related to classes
117:10 - are destructors so we write those kind
117:12 - of like a Constructor so kind of like up
117:14 - here we have a player Constructor for a
117:16 - Destructor we write it pretty much the
117:18 - same way so we write just the player as
117:20 - if it were a Constructor so there's no
117:21 - return to type it's just in type and
117:23 - then before it we add the T key which by
117:26 - the way like it says here this one
117:27 - cannot be marked as public so it just
117:29 - runs just like this so this a Destructor
117:31 - and now any code that we write here this
117:33 - is all going to run when this object is
117:35 - destroyed which if you remember from
117:36 - what I mentioned in the beginning c is a
117:39 - program language with managed memory you
117:41 - don't need to directly handle the memory
117:43 - yourself so the destruction of an object
117:45 - happens when there are no more
117:46 - references to that object so for example
117:48 - here let's do a console d right line for
117:50 - the play this structor to see when this
117:52 - runs so for example over here for some
117:54 - testing code we're calling some kind of
117:56 - my function and inside we're just
117:57 - calling a player so pretty much just
117:59 - constructing a brand new player then
118:00 - over here I'm calling gc. collect so GC
118:03 - stands for the garbage collection so
118:05 - this is the system that automatically
118:06 - handles all the memory and calling
118:08 - collect simply forces it in order to do
118:10 - it if I didn't force then this would
118:11 - happen randomly as the program grows and
118:13 - then just calling another function just
118:15 - keep it running so let's see this and if
118:17 - there it is just like that so the player
118:18 - was created then we call the function
118:20 - this one created a local variable
118:22 - meaning that this variable ends as soon
118:24 - as this function ends so as soon as this
118:26 - function ended this variable was marked
118:28 - for Destruction then when we force
118:29 - fently called the garbage collection
118:31 - when we did that it automatically
118:33 - destruct the object then continue
118:34 - running the program but remember how
118:36 - destruction of an object happens when
118:38 - there are no more references to that
118:39 - object so that is why over here this one
118:41 - is a local variable meaning it only
118:43 - exists inside of this function so as
118:44 - soon as we exit this function naturally
118:46 - this object has no more references to it
118:48 - however if instead of describing it in
118:49 - here let's make a PL ler over here
118:53 - Player test and then down here instead
118:55 - of defining some kind of function like
118:57 - that let's set that field to that okay
119:00 - so just like this and now if we test and
119:02 - yep the distruct does not run because
119:03 - Player test this one is a static
119:05 - reference and this one continues holding
119:07 - a reference to that object even though
119:08 - this function has ended so this is yet
119:10 - another place where it's really
119:11 - important to understand the scope of
119:12 - exactly what code you're writing one
119:14 - practical example of when to define the
119:16 - structor is when you have some kind of
119:18 - class that requires some cleanup like
119:19 - for example if on the Constructor itself
119:21 - you open up some kind of file for
119:23 - reading if you do that then make sure
119:24 - you close that file on the destructor so
119:26 - these can be really useful for disposing
119:28 - of any unwanted memory all right so
119:29 - those are some more intermediate topics
119:31 - related to classes as you can see
119:33 - there's lots of stuff you can do with
119:34 - them but also specifically on the topic
119:36 - of inheritance remember what I said
119:38 - about how it can become really messy
119:40 - really easily so always use it with care
119:42 - and something that I mentioned quite a
119:43 - lot in this lecture are interfaces so
119:45 - let's learn what those are in the next
119:48 - lecture hello and welcome I'm your Cod
119:50 - monkey in this lecture we're going to
119:52 - learn about interfaces this is one of my
119:54 - favorites and just straight up best
119:56 - features of C you define an interface
119:58 - that represents some kind of behavior or
120:00 - type and then you implement that
120:01 - interface in any class you want okay so
120:03 - interfaces these are simultaneously
120:05 - really simple and also really powerful
120:08 - an interface is essentially just a
120:09 - contract so you define an interface then
120:11 - you define whatever functions that
120:12 - interface has then any classes that
120:15 - Implement that interface any of those
120:17 - they must Implement those same functions
120:19 - so you have a guarantee that anything
120:21 - that implements that interface will
120:22 - implement the functions defined in the
120:23 - interface by doing this you can then
120:25 - write code directly against the
120:27 - interface type and that code won't work
120:28 - on any object that implements that
120:30 - interface this logic is somewhat similar
120:32 - to the class inheritance that we just
120:34 - covered in the previous lecture except
120:35 - you cannot create an object of the
120:37 - interface type another difference is how
120:39 - a class can only inherit from a single
120:41 - based class but a class can Implement
120:43 - multiple interface so for example with
120:45 - this structure right here an i
120:46 - attackable interface that is implemented
120:48 - by both the player and the enemy with
120:50 - this we could have some kind of bond
120:51 - object then the bullet could receive an
120:53 - object of type I attackable for some
120:55 - kind of Target then the bullet itself
120:57 - would call the damage function on that I
120:59 - attackable meaning the bullet itself
121:01 - would not know if it's attacking an
121:02 - enemy or player but because those work
121:04 - with the interface the bullet would be
121:05 - able to deal damage to both players and
121:07 - enemies so here's a different demo for
121:09 - some kind of interaction system I've got
121:11 - three objects and I want to interact
121:12 - with all of them and over here on the
121:14 - building I can click and yep I can
121:15 - indeed interact with however clicking on
121:17 - these two does nothing here is the code
121:19 - running that demo now don't worry if you
121:21 - don't understand everything this is
121:22 - doing it's not really important this is
121:24 - just a demo just so we can see the
121:25 - interface in action over here all we're
121:27 - doing is testing for a mouse click then
121:29 - we get the mouse position and test if
121:31 - there's any collider under that position
121:33 - and then try to get the type of that
121:34 - collider so in this case we're trying to
121:35 - test are we clicking on something that
121:37 - is a building object so it has a
121:39 - building component attached to it if so
121:41 - then we call the interact function and
121:43 - that in turn spawns that chat bubble so
121:45 - this works perfectly fine with the
121:46 - building type but now let's say I want
121:48 - to interact also with the zombie and
121:49 - also with a push button right now it
121:51 - doesn't work I am clicking on the zombie
121:53 - and the push button nope nothing happens
121:55 - the only one that works is the building
121:57 - itself that's because over here this
121:59 - logic this was made specifically just
122:00 - for the building type so it does not
122:02 - work with any other type in order to
122:04 - make this work with those other objects
122:05 - I pretty much just need to copy paste
122:07 - all this code then make this one to make
122:09 - it work with a zombie and make this one
122:11 - down here to make it work with a push
122:13 - button okay let's see like this so
122:15 - interact with the building it works the
122:16 - push button works and the zombie also
122:18 - works okay so now I can de interact with
122:20 - all the objects but obviously the code
122:22 - over here does not look very good we've
122:23 - got tons of duplicated logic this is
122:26 - really messy code if we want to add yet
122:28 - another interactable object we have to
122:30 - come here and copy paste a ton more code
122:32 - so you can imagine how this becomes
122:33 - really tricky if we have dozens or
122:35 - hundreds of interactable objects so this
122:37 - is definitely not a good approach and
122:39 - this is exactly where interface come in
122:41 - instead of making this code work with
122:43 - each individual type instead of that we
122:45 - can make it work against an interface
122:47 - here's a super simple interface that I
122:48 - defined again I'm going to cover this
122:50 - syntax in a little bit then all the
122:52 - other objects they are implementing this
122:53 - interface and over here now for the If
122:55 - instead of testing for each individual
122:56 - type I'm just testing for the
122:58 - interactable interface type and if we
123:00 - test this click on the building and it
123:02 - works the button works and the zombie
123:03 - also works okay great because we made
123:06 - this code work with the interface itself
123:08 - that means that this now works with any
123:10 - class that implements that interface so
123:11 - if I want to make more interactable
123:13 - objects I really just need to make a new
123:15 - class and implement this interface and
123:16 - everything won't work there's no need to
123:18 - touch this code anymore so this is the
123:20 - Practical example now let's see the
123:22 - Syntax for how we build interfaces now
123:24 - the way we Define it is really simple
123:26 - for example let's define an interface
123:27 - for an object that can be attacked so we
123:29 - start the access modifier and for an
123:31 - interface you probably wanted public
123:33 - then instead of writing class instead of
123:34 - that we write the keyword interface and
123:36 - then we write whatever name we want for
123:38 - the interface and the general naming
123:40 - rule is to start interfaces with a
123:42 - capital I this not required it's just a
123:44 - good convention to follow so in this
123:45 - case to represent something that can be
123:47 - attacked let's call it I attackable okay
123:49 - yep so this is our interface now let's
123:51 - think of what functions we need so that
123:53 - something is attackable and the answer
123:55 - is we probably just need a damage
123:56 - function so over here let's type in
123:58 - public which by the way everything
124:00 - defined in an interface needs to be
124:02 - public you cannot Define private things
124:04 - inside an interface that's because
124:05 - interfaces like I said they are pretty
124:07 - much defining a contract that other
124:09 - classes must Implement if we were to
124:11 - define something as private then other
124:12 - classes could not interact with anything
124:14 - inside of this interface so it wouldn't
124:16 - really make any sense to have any
124:17 - private elements inside an interface so
124:19 - everything inside of here is public and
124:21 - by the way way this is actually another
124:22 - reason why I personally really like
124:24 - being as explicit as possible if you
124:26 - omit the access modifier if you do that
124:28 - over here on an interface and make some
124:30 - kind of my function if you do it then
124:32 - this one W default to public but if you
124:34 - write this exact same code over here
124:36 - inside a class if you do it then now
124:38 - this one will default to private so this
124:40 - is yet another reason why I like being
124:41 - very explicit that way there are no
124:43 - questions as to what access modifier we
124:45 - are using for what element so over here
124:47 - I like to be very explicit and write
124:49 - public void and let's call it damage and
124:51 - Y we just Define the function and then
124:53 - put a semicolon meaning we do not write
124:55 - an implementation in this interface here
124:57 - we are just defining the function
124:58 - signature so that's just the name the
125:01 - return type and any parameters if there
125:02 - are any and that's really it we don't
125:04 - provide any implementation in our
125:06 - classes like for example let's make a
125:08 - random player class and on this one we
125:11 - can Implement our interface and we do
125:13 - that pretty much exactly how we saw for
125:15 - extending a base class in the previous
125:16 - lecture so we add a con and then our
125:18 - interface so I attackable and if there
125:21 - it is just like this and we have an
125:22 - error and if we see yep the error
125:25 - because the player does not implement
125:26 - the interface member I attackable do
125:28 - damage again like I said if you
125:30 - implement an interface you have to
125:31 - implement everything within that
125:33 - interface so over here you absolutely
125:35 - must implement this damage function and
125:37 - since the interface itself since this
125:38 - one has no function body because that we
125:41 - can have whatever implementation we want
125:43 - meaning the player can have some kind of
125:45 - implementation then the enemy can have a
125:47 - different one and so on so pretty much
125:48 - similar to what we saw in the previous
125:50 - lecture on extending base classes how we
125:52 - could override and provide different
125:54 - implementation for the same function
125:55 - over here it's kind of a similar thing
125:57 - so let's do a public void damage and
125:59 - here we can let's just do a console the
126:02 - right line and just print out player
126:04 - damage okay so yep that's it and now for
126:07 - example up here in our main let's make a
126:09 - field of type ey attackable and now we
126:12 - can simply construct a player and we can
126:14 - sign it over here yep just like this
126:16 - this works again similar to what we
126:18 - covered in the previous lecture this is
126:19 - polymorphism in action since a player
126:22 - implements the ey attackable interface
126:23 - we can use a player object and assign it
126:25 - to a variable of type I attackable and
126:28 - then through this interface field
126:29 - through this one we can access whatever
126:30 - functions we have in our interface like
126:32 - for ex damage and Yep this does work so
126:34 - now we have similar benefits to what we
126:36 - saw in the previous lecture on
126:37 - inheritance for example let's make
126:39 - another class let's make an enemy class
126:41 - that also implements ey attackable and Y
126:43 - just like this it works and now up here
126:46 - if we have some kind of code that works
126:48 - against the I attackable interface like
126:50 - for example let's make a private static
126:52 - void attack object and we receive an
126:55 - object of type I attackable so we can do
126:57 - this and then on attackable we can call
126:59 - damage and now up here we can call this
127:01 - attack object and we can pass in an
127:03 - object of type player and pass in one of
127:06 - type enemy and yep both these work just
127:08 - fine so this function over here that was
127:10 - written directly to work with this
127:11 - interface type it does not care what
127:13 - object we pass in as long as that type
127:15 - also implements our interface now one
127:18 - limitation of interfac is they cannot
127:20 - have Fields so for example down here in
127:22 - the interface let's make a public in
127:24 - health and no this does not work
127:26 - interfaces cannot contain instance
127:28 - Fields again this goes back to the
127:30 - difference between an interface and a
127:31 - base Class A Base Class can contain
127:33 - actual data since a base class can be
127:35 - constructed but an interface this one is
127:37 - just a contract so this one holds no
127:39 - data so that is why over here we cannot
127:41 - have any Fields but we can have
127:43 - properties so y this does work so we can
127:45 - define a public health property and
127:48 - again same thing all these need to
127:49 - implement that one then we can also have
127:51 - functions of course then we can also
127:53 - have events which we're going to cover
127:55 - later so the main limitation is really
127:56 - how you cannot have Fields because again
127:58 - interface cannot store any actual data
128:00 - another thing is actually here we Define
128:02 - this function with no body and then the
128:04 - classes must Implement that function and
128:06 - this actually used to be the only way
128:08 - but in recent C versions you can now add
128:10 - an optional default implementation so
128:12 - you can write a function here and just
128:14 - write the code AS nmal so you can do
128:16 - this and now classes that implement this
128:17 - interface they are not absolutely
128:19 - required to implement this damage
128:21 - function if they don't then it's simply
128:22 - going to use the default one so as you
128:24 - can see over here we have no error and
128:26 - up here we can still pass in an enemy
128:28 - and through this function we can call
128:29 - damage function and the only thing is
128:31 - one is going to run the player damage
128:32 - and this one is going to run default so
128:34 - let's test and it Pickel like that so
128:36 - the player did Implement their own
128:37 - custom implementation but the enemy
128:39 - didn't so it used the default one this
128:41 - feature for default implementations this
128:43 - is especially great when working with
128:44 - some complex projects things that are
128:46 - already using a bunch of interface and
128:48 - you want to add a bunch more Behavior if
128:50 - over here you just add a brand new
128:52 - function so test function if you just do
128:54 - this then all of a sudden we broke all
128:56 - of this code this is obviously not very
128:57 - good so if you do this if you add after
129:00 - the fact and you don't want to break
129:01 - your current code just provide default
129:02 - implementation and yep now everything
129:04 - does work so like I said interfaces look
129:06 - slightly similar to class inheritance
129:09 - however one huge huge difference between
129:11 - them is how you can only ever inherit
129:13 - from a single base class but you can
129:15 - Implement as many interfaces as you want
129:17 - so for example here we can make an
129:19 - interface and let's call it movable so
129:22 - this would represent something that can
129:24 - move then an interface call it I has
129:26 - inventory so this represents something
129:28 - that has an in then up here let's say
129:30 - the enemy can move but has no inventory
129:33 - and the player can move and has an
129:35 - inventory and yep we can Implement all
129:38 - of these interface in the previous
129:39 - lecture I talked about how you should
129:41 - prefer composition over inheritance and
129:43 - this is exactly one way you can do that
129:45 - you can have interface that each Define
129:47 - some kind of behavior like for example
129:49 - whether the object can be attacked
129:51 - whether it moves whether it has an
129:52 - inventory you can do that and then your
129:54 - classes you can Implement only the
129:56 - interface that are related to that
129:57 - object so for example the player can
129:59 - attack and move and has an inventory but
130:01 - the enemy does not have an inventory so
130:03 - it does not Implement that interface
130:05 - this is a much better pattern as opposed
130:06 - to making all of these requirements on
130:08 - some kind of unit based class and then
130:10 - the enemy would also have some kind of
130:12 - inventory even though they would never
130:13 - use it so this is an example of
130:15 - composition over inheritance and for
130:17 - example in my game Thinking Guardians I
130:18 - use interfaces all over the place I use
130:21 - them to Define all kinds of behavior and
130:23 - then have tons of code that works
130:24 - directly with those interface and really
130:26 - does not care what the underlying type
130:28 - is implementing that interface so it can
130:30 - be a dinky it can be a machine it can be
130:31 - the player it really does not matter as
130:33 - long as that type implements that
130:35 - interface it does work when extremely
130:36 - common interface in games is simply
130:38 - making some kind of interaction system
130:40 - so just like we covered in the demo and
130:42 - if you want to learn more about
130:43 - specifically that type so you can see a
130:44 - practical use case if you want you can
130:46 - check out my dedicated tutorial on how
130:48 - to make an interaction system do
130:50 - something that can talk to NPCs push
130:52 - buttons or open doors and like we saw in
130:54 - the demo if you don't use an interface
130:55 - then you have to copy paste a bunch of
130:57 - code but if you do use an interface then
130:59 - it makes it super simple for your system
131:01 - to work with any object you want so
131:03 - interfaces are really truly awesome they
131:05 - are definitely one of my favorite C
131:07 - features they are extremely useful so
131:09 - definitely make sure you fully
131:10 - understand them they will help you a ton
131:12 - in pretty much any game any code you
131:14 - want to make now that we've covered
131:15 - interface and inheritance these are two
131:18 - things that deal with a lot of types
131:19 - that work as different types now that we
131:21 - done that we're ready to handle the
131:23 - various ways of doing type conversion so
131:25 - let's do that in the next
131:26 - lecture hello and welcome I'm your codm
131:29 - in this lecture we're going to learn
131:31 - some things about comparing various
131:33 - types we're going to see whether they're
131:34 - an interface or Bas class and we're
131:36 - going to see how we can convert between
131:37 - them okay so previously we already
131:39 - covered inheritance and interfaces those
131:41 - are two ways we have of handling an
131:43 - object of a certain type that also works
131:45 - as a different type for example if we
131:47 - have our eye attackable interface and
131:49 - both the enemy and the player implement
131:51 - that interface if we have a field of
131:53 - type I attackable over here we can
131:56 - construct a new player any of it works
131:58 - and we can construct new enemy and if
132:00 - this also does work but then let's say
132:02 - we have some special logic that we only
132:04 - want to run if the object is a player
132:06 - and not an enemy for example over here
132:08 - on the player let's define a public void
132:11 - player say hello something like this so
132:14 - if we have this function that only
132:15 - exists on the player so it does not
132:16 - exist on the enemy on the unit on the
132:18 - interface nope only exists on the player
132:20 - and over here if we have a field of ey
132:22 - attackable even though we placed a
132:24 - player object inside that field if we go
132:26 - through it and try to call player say
132:28 - hello nope this does not work like it
132:31 - says here eye attackable does not
132:32 - contain a definition for that so it does
132:34 - not really matter what is the specific
132:36 - object that we have stored inside this
132:38 - variable this variable is of this type
132:40 - so we can only interact with things that
132:41 - exist inside of this type if you have a
132:43 - film like this and you want to see if
132:45 - the underlying object stored in there is
132:47 - of a certain type or a different one if
132:49 - so you can do if attackable and then use
132:52 - the keyword is and then the type is
132:54 - player so we can say this and let's do a
132:56 - console d right line just to see if this
132:58 - one is a player let's just get rid of
133:01 - this code for now okay let's see if this
133:02 - one prints and if it does print that
133:04 - object is indeed of type player and if
133:06 - we replace it for an enemy and run and
133:09 - if that one does not print because this
133:10 - one is no longer of type player so this
133:12 - is the simplest way for how you can tell
133:14 - if a certain variable if the object SED
133:16 - within that variable is a a certain
133:18 - specific type alternatively on Prem much
133:21 - every other object we can see we have a
133:23 - bunch of functions that are available to
133:25 - every single object like we already saw
133:27 - the two string so this one exists on
133:28 - every object but the other one that is
133:30 - all super useful is this one the get
133:31 - type this one Returns the specific type
133:33 - of that object so for example let's do a
133:35 - right line on this one to see what this
133:37 - one says Okay so let's print this and
133:39 - see what this one says any if that one
133:41 - says the type so this one is of type
133:42 - enemy so here we can get an object of
133:45 - type type which actually only tells us
133:47 - the type of the object that this is so
133:49 - over here we can check the attack of do
133:51 - get type in order to get the type
133:53 - contained within that variable and
133:55 - instead of using is we simply compare
133:57 - with the type of player example like
133:59 - this we have an error because player
134:01 - this is the name of the class in order
134:02 - to get the type we use the keyword type
134:04 - of and this Returns the type of whatever
134:06 - is within the parentheses so in this
134:08 - case the player type and Yep this now
134:10 - works the same thing as we saw
134:11 - previously with the is so this one this
134:13 - is an enemy so this is not going to run
134:15 - and if there go it's an enemy but if we
134:17 - solop this for type player and if there
134:19 - it is now it does run now when
134:21 - difference between this get type method
134:22 - and the other one using the is keyword
134:24 - one difference is this one does not
134:26 - check for inheritance or interfaces so
134:28 - if we see is of type I attackable which
134:31 - again the player class this one is
134:33 - indeed implementing I attackable so
134:34 - let's see if this one runs or not and
134:36 - Noe this one does not run so if you use
134:38 - this method of getting the type and
134:39 - using a type of to do an equality check
134:42 - if so when it comes to interface instead
134:44 - of that you can access the function
134:45 - inside of this specifically the function
134:47 - is interface this will tell you if this
134:50 - type is an interface and then you have a
134:51 - bunch more you have a function for
134:53 - checking if it's an instance of a type
134:55 - you can check if it's a subass of
134:57 - something or you can check if it's a
134:59 - sign a b two and from something or
135:00 - alternatively for this case for testing
135:02 - against interface you can use the
135:04 - previous method which personally is the
135:05 - one that I prefer so just see if the
135:07 - attackable is attackable which in this
135:09 - case doesn't make much sense but let's
135:10 - test any yep it does work but if we were
135:13 - to make a new player over here let's see
135:15 - and if it does work alternatively we
135:17 - could test if the player is a unit and
135:19 - if this also works so there are various
135:21 - ways to test if a certain variable if a
135:23 - certain object is of a specific object
135:26 - type so for example let's go back to our
135:28 - original demo so testing if the
135:30 - attackable is a player and if so we want
135:33 - to run this specific function on the
135:34 - player class right now even though we
135:36 - have identified that this object is of
135:38 - type player we still cannot go here and
135:41 - call player say hello nope this still
135:43 - does not work even though we have
135:45 - verified that it is of this type we
135:46 - still need to convert it onto that type
135:49 - and for this we also have two options
135:51 - One is using the as keyword so let's
135:53 - define a player field and for this let's
135:56 - use the attackable as of type player so
135:59 - if we do this and now do this and over
136:01 - here let's just print out something okay
136:03 - let's see any yep it does work it did
136:05 - run that so here we convert our
136:07 - attackable into a specific player type
136:09 - and then we can call any functions that
136:11 - are specific to this player type the
136:12 - other conversion method similar to this
136:14 - one is simply casting which we already
136:16 - saw when we cast some floats down into
136:18 - ins so instead of using attackable as
136:21 - player we just put player in parenthesis
136:23 - and then attackable and like this and
136:25 - yep it does work so these are two ways
136:27 - for converting types and the difference
136:29 - is usually related to whether the
136:31 - conversion succeeds or not so for
136:32 - example let's go outside of the if
136:35 - testing the player let's just comment
136:37 - this out so up here let's create a new
136:39 - player and then let's create a new enemy
136:43 - and now let's do a player test player
136:45 - and we're going to take the enemy and
136:47 - cast it down into a player which
136:48 - obviously this will not work it does not
136:50 - work because enemy has no relation to
136:52 - the player itself the enemy implements
136:54 - the attackable extends a unit but has no
136:56 - relation directly to the player itself
136:58 - and in this case the compiler doesn't
136:59 - even let us run this code however we can
137:02 - try forcing something that won't work so
137:04 - let's put it an i attackable and up here
137:06 - on this attackable let's make it a new
137:09 - enemy so this one is an enemy meaning
137:11 - this one will not work but now we don't
137:12 - have a compile error because technically
137:14 - I attackable might be convertible into a
137:16 - player it might or might not be and if
137:18 - we test this and yep if we try to C
137:21 - something that does not work we're going
137:22 - to have this error unable to cast of
137:24 - type enemy into player and using the
137:26 - other method so let's see what that one
137:28 - does so attackable as player and in this
137:30 - conversion method we have no error and
137:32 - let's just do a console. right line to
137:35 - see what is stored on that one let's see
137:37 - any y it's empty meaning that one
137:38 - contains null so this difference between
137:40 - the two methods if you use a cast and
137:42 - the cast fails it is going to throw an
137:44 - exception whereas the as if the as fail
137:46 - it is simply going to store null over
137:47 - here on this field so remember this
137:49 - difference if you use this me method in
137:51 - order to figure out whether this cast
137:52 - worked if so then compare this one
137:54 - against null or if you use this method
137:56 - then before you do make sure to test if
137:58 - the player is actually castable which up
138:00 - here this code is normally what I do so
138:03 - I just check if something is a specific
138:04 - type and only if so that's when I cast
138:07 - down and then do some complicated logic
138:09 - also related to type conversion when
138:11 - working with value types like for
138:12 - example an INT on this one if you do
138:15 - some kind of thing like this so a as
138:18 - float if you do it nope it does not work
138:21 - the as operator must be used with a
138:22 - reference type that is because like we
138:24 - saw if this one fails this one is going
138:25 - to return null but a value type can
138:27 - never be null so that is why the as so
138:29 - that is why the as keyword can only be
138:30 - used with reference types so when you
138:32 - ever have this kind of thing you only
138:34 - have to use the cast option and
138:36 - something related that I mentioned
138:37 - briefly in the beginning of this course
138:39 - is how every type in C is convertible
138:41 - down into the object type this is the
138:43 - base type for pry much anything in C you
138:46 - can convert any type into an object so
138:49 - for example something you can do is to
138:50 - find some kind of int then you define
138:52 - some kind of object and you can place an
138:54 - INT inside of that object and then you
138:56 - can Define another int go inside the
138:58 - object and cast it down back into an end
139:00 - and Yep this does work this is
139:02 - technically something that is called
139:03 - boxing which I'm going to cover in more
139:05 - detail in a lecture in the advanced
139:06 - section this is basically how you can
139:08 - convert anything onto an object and then
139:10 - convert it back this topic of type
139:11 - conversion is also something that won be
139:13 - very important in a few lectures when we
139:15 - cover events the default type for any
139:17 - kind of event is the event handler and
139:20 - this one if we we inspect how it is yep
139:22 - this one has a parameter of type object
139:24 - so when working with this we're going to
139:25 - need to do some conversion and usually
139:27 - for events you know what type is fireing
139:29 - this event so you can just use a cast in
139:30 - order to convert this object onto
139:31 - whatever type you want but like I said
139:33 - I'm going to cover events in a few
139:34 - lectures so with that here we'll learn
139:36 - the various ways of handling type
139:38 - conversion these can be very useful when
139:40 - combined with interface or inheritance
139:42 - anytime you need to do some kind of type
139:44 - checking or convert back and forth
139:45 - between one or two types now you know
139:47 - the various methods for doing it hello
139:50 - and welcome I'm your Codi in this
139:52 - lecture we're going to learn about
139:53 - switch pattern matching this is how you
139:55 - can do a switch on a type instead of
139:56 - just a value this is a super quick
139:58 - lecture since it's actually really
139:59 - simple but I want to make sure you
140:01 - definitely know about this okay so we
140:03 - already learned how to handle multiple
140:04 - types with inheritance and interfaces
140:06 - now let's see a more advanced use case
140:07 - for the switch that is perfect for this
140:09 - scenario so in the last lecture we
140:11 - already covered how to check if an
140:12 - object is of a certain type so for
140:14 - example if I have an eye attackable
140:16 - field and I set this to a new player
140:19 - then we can check if attack
140:21 - is of type player and if so do some kind
140:23 - of logic then we could also test if
140:25 - attackable is of type enemy we could
140:28 - check if it's of type of the red Barrel
140:31 - so this works perfectly fine but just
140:33 - like we saw on the lecture on the
140:34 - regular ifs if you have to do a ton of
140:37 - them together then at that point a
140:38 - switch is better and actually on a
140:40 - switch we can also do this kind of logic
140:42 - testing if a certain field is of a
140:44 - certain type so instead of this let's do
140:47 - a switch and switch on attackable and
140:49 - then on the cas we can add the type
140:51 - definition so for example case player
140:53 - and then assign it to some kind of
140:55 - variable name player and if there it is
140:57 - this is valid code what this going to do
140:59 - is if the attackable is of type player
141:01 - then it's going to cast attackable onto
141:03 - a player type and it's going to assign
141:05 - that reference over here on the player
141:06 - so for example over here we can access
141:07 - the player and call a function that only
141:09 - exists on the player like this one
141:11 - player say hello so this one and Y this
141:13 - should work so let's run and if exactly
141:15 - it does work so here this is both
141:17 - testing a specific type it is also
141:19 - casting that type and assigning a
141:20 - variable reference so with this instead
141:22 - of having all those ifs we can do here
141:23 - case Enemy enemy and case red Barrel red
141:26 - barrel and in P these now work so now
141:29 - inside of this we can put any kind of
141:30 - enemy specific logic and of course we
141:33 - always have the default case just in
141:34 - case it does not match anything then
141:36 - it's going to run this code also this
141:38 - actually lets you do one more thing that
141:39 - I actually didn't know until I did the
141:41 - research for this course which is on
141:43 - this case you can add extra conditions
141:45 - so for example up here on the player
141:47 - let's find a end for the player Health
141:49 - something like this and now here on the
141:51 - player we can use the keyword when and
141:53 - then Define some kind of condition so
141:55 - for example when player. health is above
141:58 - 50 if so then we're going to run this
142:01 - and put one without it and it's going to
142:02 - run this so over here for test let's do
142:05 - a consant out right line on this so this
142:07 - one Health 50 and the other one is a
142:09 - default now up here on the player let's
142:11 - construct it and let's put the health on
142:13 - 100 so that should go inside of this one
142:15 - so let's see and it ex goes inside that
142:17 - one whereas if over here if the health
142:19 - is 20 and if if there it is it only runs
142:21 - the other one so this whole thing is
142:22 - called switch pattern matching so as you
142:24 - can see we can do a switch and then
142:26 - Define all kinds of patterns and
142:27 - depending on which pattern it matches
142:29 - going to run different kinds of code
142:30 - with this the switch can be used in tons
142:32 - of way so not just testing for a
142:34 - specific value you can cast into a type
142:36 - and then couple it with some kind of
142:38 - condition and doing that you can do all
142:39 - kinds of logic on different switches but
142:41 - again always remember the number one
142:42 - rule code is meant to be readable and
142:45 - understandable so if you end up with a
142:46 - mountain of switches with tons of
142:48 - complex when case conditions at that
142:50 - point it's probably best to refactor
142:52 - your code in some way but for simple use
142:54 - case this is really useful especially
142:55 - for this kind of use case where we have
142:57 - some kind of Base glass or some kind of
142:59 - interface and we want to do some
143:01 - specific logic depending on what type it
143:02 - is hello and welcome I'm your KMI in
143:05 - this lecture we're going to learn about
143:07 - delegates lambdas and Anonymous
143:09 - functions okay so delegates they are
143:10 - really powerful C feature they basically
143:13 - let you store a function inside a
143:14 - variable or use it as some kind of
143:16 - parameter here is a working demo so I
143:18 - can click and it spawns a chat bubble
143:21 - then I can press a button to change the
143:22 - action and now if I click yep now it
143:24 - spawns a regular Sprite and now press
143:26 - another button now I click and yep now
143:28 - it's spawning some particles so the same
143:30 - action clicking is doing different
143:32 - Behavior based on what action I select
143:34 - here is the code for the click actions
143:36 - and delate is this one over here it's
143:37 - something of type action this is a
143:39 - delegate and then I've got a bunch of
143:41 - functions toine here so spawn chat
143:42 - bubble a Sprite or a particle effect and
143:45 - I can see over here on start that I'm
143:46 - assigning The Click action to this
143:48 - function so importantly it is not
143:50 - calling the the function nope it is
143:51 - passing in the function itself and
143:52 - storing it over here inside of this
143:54 - field and then on Mouse click I simply
143:56 - run whatever is stored inside that
143:58 - variable so the variable stores a
143:59 - function and then by calling this I can
144:01 - run whatever function is stored within
144:02 - that variable then these buttons simply
144:04 - do that they simply assign a different
144:06 - function onto that variable and with
144:08 - that I can click do one Behavior press
144:10 - to select something else do another
144:12 - behavior and another one just like that
144:13 - so this a practical example now let's
144:15 - see the syntax to define a delegate
144:17 - first let's write the access modifier
144:19 - let's go ahead with private and then
144:21 - let's use the keyword delegate and then
144:23 - you write essentially a function
144:24 - signature so let's make something super
144:26 - simple for the return type let's use
144:28 - void then for the name for this delegate
144:30 - let's call it attack delegate then we
144:32 - add any parameters we want or basically
144:34 - none of them okay so yep so just like
144:36 - this we have defined our delegate type
144:38 - now we can use this type just like we
144:39 - can use any other type so for example
144:41 - here let's make a field of this type so
144:43 - let's make it of type attack delegate
144:45 - and let's give it some name like attack
144:47 - action okay so just like this and then
144:49 - like I said the goal is you can sort
144:51 - functions inside a delegate variable so
144:53 - over here let's make a regular function
144:55 - let's call it melee attack and let's
144:57 - just do a cons on the right line and
144:59 - let's print out melee attack yep just
145:02 - like this now importantly we need to
145:03 - make sure that this function signature
145:05 - has to match our delegate signature so
145:07 - it needs to match a return time so both
145:08 - need to return void and needs to match a
145:10 - number of parameters so in this case
145:12 - zero so this yep now we can go inside
145:14 - our attack action and we can assign it
145:16 - to our melee attack and again
145:18 - importantly we assign it just like this
145:20 - so so we assign the function itself we
145:22 - do not call the function no this is very
145:23 - different we assign the function itself
145:25 - just like this so you can do this and
145:27 - then basically we can run whatever
145:28 - function is stored within this delate
145:30 - and we do that by calling it like we
145:32 - call any other function so just like
145:33 - this okay let's test and if exactly it
145:36 - ran our melee attack function so for
145:38 - example you could have multiple enemy
145:39 - types each with different attacks and in
145:41 - order to trigger those different attacks
145:43 - you would simply assign a different
145:44 - function onto the delate variable then
145:46 - like I said the delate can have whatever
145:48 - return type and whatever parameters you
145:49 - want so for example let's make another
145:51 - delegate let's make one that returns in
145:54 - call it my delegate and let's receive a
145:56 - string parameter save just like this
145:58 - this is the delegate reference and like
146:00 - I said when assigning something of this
146:01 - type so for example down here let's make
146:03 - a field of this type my delegate and now
146:06 - when assigning it like I said it needs
146:07 - to match the function signature so if I
146:10 - try assigning melee attack and nope we
146:12 - have an error it is telling does that
146:14 - there is no version of the Mele attack
146:16 - function that matches the delegate my
146:18 - delegate so there's no version of this
146:20 - fun function that returns an INT and
146:21 - takes an A String so in order for this
146:23 - to work let's go make a private static
146:25 - void my test function and actually not
146:28 - void so actually in here let's return an
146:30 - INT and let's receive a string parameter
146:32 - so we have this one and now up here we
146:34 - assign this to this field of type my
146:36 - delegate and if now it does work let's
146:38 - just return zero just fix that error and
146:40 - yep like this this does work it works
146:42 - because the function signature now
146:43 - matches so they both return an in type
146:46 - and they both have a string parameter
146:47 - also by the way over here you need to
146:49 - Define some some kind of name for the
146:51 - parameter so like this it's an error so
146:53 - you need to Define it with some kind of
146:54 - name but down here when you assign the
146:56 - proper function this one does not have
146:57 - to have the exact same name needs to be
146:59 - the exact same type but not the exact
147:00 - same name okay great so this is the
147:02 - basis of delegates so up here we Define
147:04 - delegate and then we assign it so that's
147:06 - great and delegates are really super
147:08 - useful I use them all the time but
147:10 - always having to Define them before you
147:12 - use them that is a little bit of a pain
147:14 - so for that c has some really awesome
147:16 - default delegates that are super useful
147:18 - one of them is simply called action so
147:20 - so let's make a field and let's make it
147:22 - of type action which by the way exists
147:24 - inside the system namespace so action
147:27 - let's call my action and we can inspect
147:29 - the action in order to see the function
147:31 - signature for this delate and Yep this
147:32 - is a delate that returns void and takes
147:34 - in no parameters so pretty much exactly
147:36 - the same that we defined up here so down
147:38 - here if we grab my action and we assign
147:40 - it to melee attack and Yep this does
147:42 - work because again the function
147:43 - signature matches this one returns void
147:45 - and has no parameters so rather than
147:46 - having to constantly Define your own
147:48 - custom delegate with void no parameters
147:50 - if you want that you can just use action
147:52 - and then there are actually various
147:53 - action definitions you can add the angle
147:55 - brackets this means a generic we're
147:57 - going to cover what are generics in
147:59 - detail in a future lecture so this you
148:00 - can see there are 16 inversions of this
148:02 - type and these are basically just
148:04 - different amounts of parameters so you
148:05 - can see there's all the way up to 16
148:07 - parameters basically on these you can
148:09 - include whatever type you want for the
148:10 - parameters so let's say an action that
148:12 - takes in an INT what this means is a
148:14 - function that will return voids and it's
148:16 - going to have an in for the parameter so
148:18 - the equivalent for example up here would
148:20 - be some kind of in like this so this
148:22 - would equal pretty much this and down
148:24 - here of course since we changed the
148:25 - delegate that we're using this one is no
148:27 - longer valid so in this case we would
148:28 - need to make something that returns void
148:31 - and then takes in an in parameter yep
148:33 - just like this and if we assign this one
148:34 - to that one and yep it does match so
148:36 - action is really awesome it's a built-in
148:39 - type so rather than having to Define
148:40 - your delegates you can just use this
148:41 - directly the only thing is that action
148:43 - always returns void so all the various
148:46 - versions that we saw all the 16 versions
148:48 - every single one of these is just the
148:49 - fact number of parameters but they
148:51 - always always return void meaning they
148:53 - cannot return any value if you do want
148:55 - to delegate that return something for
148:56 - that you have the funk and this one
148:59 - works pretty much the same as the action
149:00 - so this one also has tons of things so
149:02 - let's put in the generic in order see
149:04 - all the types and this one as you can
149:06 - see has a generic named T result so this
149:08 - is basically going to be the return type
149:10 - and then has all kinds of those for all
149:11 - kinds of parameters so this basically
149:13 - going to return some type and then have
149:15 - any kind of any number of parameters so
149:17 - for example in this case this my funk
149:19 - this one is of type int meaning it's
149:22 - going to return an INT so let's actually
149:24 - Define it so let's take this one go down
149:27 - here and we're going to need to assign
149:29 - it to something so let's make another
149:30 - function that matches that delegate so
149:32 - again this one has no parameters and
149:35 - it's going to return an INT so let's
149:36 - make it return int and with zero
149:38 - parameters and if we take this and let's
149:41 - just return zero and if we take this and
149:43 - assign it any yep it does work so the
149:45 - built-in action and Funk delegates these
149:47 - are super useful if you have some common
149:49 - use case you can really just use theu
149:50 - there's no need to Define your own
149:52 - delegates but defining your own delegate
149:53 - is also still something proper the one
149:55 - big benefit is of course this one has a
149:57 - custom name so even though this one
149:59 - perfectly matches an action delegate
150:01 - with the name attack delegate that makes
150:02 - it a bit more clear as to what the
150:04 - intent is as opposed to this one Funk
150:06 - this one has no clear intent on what
150:07 - exactly what it's doing so they both
150:09 - have their use case but in many ways for
150:11 - Simplicity when you just need something
150:12 - based that works using Funk and action
150:14 - those are excellent then for assigning a
150:16 - delegate so over here we are creating of
150:18 - something of some type that we are
150:20 - creating a separate function and then
150:21 - assigning it so this works but we can
150:24 - also do what is called an anonymous
150:25 - function or sometimes called a Lambda
150:27 - expression so for example let's define a
150:29 - field of type action and now when
150:31 - assigning it we can just put in the
150:33 - parentheses for the parameters which in
150:35 - this case action has no parameters and
150:37 - then we do a little arrow symbol and
150:39 - then let's open and close a code block
150:41 - so yep just like this this is valid code
150:44 - what we have here is a Lambda expression
150:46 - for defining some kind of function that
150:48 - takes in no parameters and returns
150:50 - nothing so what we have here is pretty
150:52 - much the same short hand as what we have
150:53 - here we can place the console right line
150:55 - there and Yep this is exactly the same
150:57 - as this except when doing this we didn't
150:59 - have to define a complete separate
151:00 - function so these lambas this is another
151:03 - really super useful thing I use them all
151:05 - the time especially when writing any
151:06 - code for buttons in unity buttons have a
151:08 - click action and normally I just use a
151:10 - Lambda in order to Define what Behavior
151:12 - I want when I click on a button as
151:13 - opposed to having to write a separate
151:15 - function and then assigning it to the
151:16 - delegate so there are really great time
151:18 - Savers and you can use them on any
151:20 - delate type so over here an action with
151:22 - no parameters but if we make an action
151:23 - that takes an INT parameter if so then
151:25 - we just need to define the in parameter
151:27 - over there and if this does work and
151:29 - alternatively if we make a funk let's
151:31 - make a fun that takes an INT and returns
151:33 - a bow so this one takes an INT parameter
151:36 - and then over here just needs to return
151:37 - some kind of volume yep that works and
151:39 - then alternatively if you want you can
151:40 - even simplify this even further so let's
151:42 - erase all this let's put just false just
151:45 - like this and Yep this is perfectly
151:46 - valid code this is doing the exact same
151:48 - that we saw previously the compiler is
151:50 - smart enough to know that if this
151:51 - delegate expects a return value it is
151:53 - smart enough in order to add the return
151:55 - into whatever statement we write so this
151:57 - is perfectly valid code although
151:58 - normally like I said I prefer being
152:00 - explicit so personally I prefer to
152:02 - always write everything perfect now an
152:04 - interesting property about delegates is
152:06 - multicast meaning how you can sore
152:08 - multiple functions inside a delegate so
152:10 - for example let's see here our attack
152:11 - action so we're assigning it to just the
152:13 - melee attack let's make another one
152:15 - let's make a range attack and over here
152:18 - if we do this and then assign it to
152:20 - range attack if we do this and let's
152:22 - just get rid of the other code so if we
152:24 - run this code and if there you go it
152:26 - only runs the range attack however
152:28 - instead of assigning we can do plus
152:30 - equals and now if we run this and if
152:32 - there we go now run both even though
152:34 - over here on the delegate we only ran
152:36 - the delegate once since the delegate
152:38 - itself is storing the reference to two
152:39 - separate functions it is going to run
152:41 - both those functions whenever we run our
152:43 - delegate so this means that the delegate
152:45 - itself it can store multiple objects it
152:47 - kind of has a list in the background of
152:48 - all the functions that are stored within
152:50 - it and since you can do plus equals to
152:52 - add it you can also do minus equals so
152:54 - let's run that one which should run both
152:56 - then do a minus equals and then print
152:58 - and let's see this and if there you go
152:59 - so the first time that we ran the D the
153:01 - first time it ran melee attack and range
153:03 - attack but the second time since we
153:05 - raise the range attack we did minus
153:06 - equals because that the second time it
153:08 - only ran the melee attack now when
153:10 - really common use case for delegates is
153:12 - doing a synchronous programming and
153:13 - handling callbacks if you're familiar
153:15 - with JavaScript you're certainly very
153:16 - familiar with this and in game
153:18 - development for example one very common
153:20 - use cases for pathf finding you tell a
153:22 - unit to move somewhere and you can pass
153:23 - in a delegate for what to do when the
153:25 - unit gets there so for example here's a
153:27 - basic unit class and it has some kind of
153:29 - pathfinding so it has some kind of move
153:31 - to function it takes in a Target
153:32 - position then an action for the unreach
153:34 - Target action so we would create a unit
153:36 - we would tell it to move somewhere and
153:38 - we would pass in a delegate so in this
153:40 - case could be a simple Lambda so a
153:41 - simple Anonymous function we could pass
153:43 - that in then the unit would do all kind
153:44 - of movement and eventually it would
153:46 - reach the Target and when it reaches the
153:47 - target then it would call that function
153:49 - and doing the so then it would run
153:51 - whatever logic we set when we call the
153:52 - move to function so if we test this yep
153:55 - there it is now the unit is moving and
153:56 - after a while it gets there and yep it
153:57 - reaches the target another common use
153:59 - case is when doing something that
154:00 - contacts a web server so some kind of
154:02 - web request I made a tutorial on that
154:05 - and for that I made the class receive a
154:06 - delegate for the Callback that is called
154:08 - whenever the server responds so
154:09 - delegates are super useful extremely
154:11 - versatile it can be sometimes a little
154:13 - bit tricky to understand at first since
154:14 - they look like variables but they're
154:16 - actually storing functions if there's
154:18 - something you didn't understand
154:19 - definitely go ahead and rewatch this
154:20 - lecture once again and go through the
154:22 - interactive exercises this is an
154:23 - extremely powerful feature that you
154:25 - absolutely must understand now here I
154:27 - mentioned lambdas for making Anonymous
154:28 - functions but there's actually another
154:30 - way of doing something similar we can
154:32 - create normal local functions so let's
154:34 - learn differences between them in the
154:35 - next
154:36 - lecture hello and welcome I'm your Cod
154:38 - Maki in this lecture we're going to
154:40 - learn about local functions and how they
154:42 - differ from lambdas okay so in the
154:44 - previous lecture we covered delegates
154:45 - and lambdas lambdas are one way to make
154:48 - an anonymous function so we have some
154:50 - kind of action my action we do a Lambda
154:52 - by writing the parentheses with the
154:54 - parameters then we do a little arrow and
154:56 - a code block just like this this is a
154:59 - Lambda expression however there is
155:01 - another method for making Anonymous
155:02 - functions it's called local functions
155:04 - and they're EXA like the name implies
155:06 - just like you can have local variables
155:08 - so in something so this is a local
155:09 - variable just like this you can also
155:11 - Define a function within another
155:12 - function and you define them pretty much
155:14 - exactly the same as another function so
155:15 - for example void print let's receive a
155:18 - string message and then we put a codee
155:20 - block and inside let's go console and
155:23 - right line and let's print out the
155:25 - message and that said here we have a
155:27 - valid local function we have this
155:29 - function inside this main function now
155:31 - naturally we cannot call this from
155:32 - anywhere else so if there's another one
155:35 - so another private static void so if we
155:38 - have another function here from this one
155:40 - if we try accessing print nope this does
155:42 - not exist so this is a local function
155:44 - which just like a local variable is only
155:46 - accessible within this function and we
155:48 - saw the delegates in the previous
155:49 - lecture so we can use these exactly the
155:51 - same way so action my action two and I
155:54 - can assign it to print and actually this
155:56 - one takes a message so let's do action
155:58 - of type string and yep there you go this
156:00 - is perfectly valid code so here this and
156:02 - here this just put a string here just to
156:04 - make it exactly the same so a string
156:07 - message like this and Y both this and
156:10 - this are exactly the same thing now
156:11 - let's see the differences and first is
156:13 - really just a syntax you can see how the
156:15 - Lambda over here this one does not have
156:17 - Name by default the only way to
156:19 - reference this Lambda expression the
156:20 - only way is by going through the actual
156:22 - delegate that stores it whereas the
156:24 - local function over here this one has a
156:25 - proper name you don't need to assign
156:27 - this to any kind of delegate field in
156:28 - order to be able to actually use it the
156:30 - another thing is how the local function
156:31 - can be defined anywhere so for example I
156:34 - can Define the print in there and up
156:35 - here I can call print and Yep this is
156:38 - valid code there's no errors again only
156:41 - inside the actual function code block
156:42 - because it's a local function but I can
156:44 - Define it down here and use that up here
156:46 - this is valid whereas with the Lambda
156:48 - you cannot do this if I accessing the my
156:50 - action nope obviously there's an error I
156:52 - cannot use the local variable before it
156:54 - is declared whereas for the local
156:56 - function that one works just fine the
156:58 - difference for this is because local
156:59 - functions these one are defined in
157:01 - compile time whereas lambdas these are
157:03 - defined at runtime so because that the
157:05 - compiler knows that this function is
157:07 - coming so it can use it but this one can
157:09 - only be used after it is declared also
157:11 - importantly is how the delegate over
157:13 - here the Lambda this Anonymous
157:14 - expression lambdas are actual objects
157:16 - that are declared and assigned at
157:18 - runtime they are exal objects that exist
157:20 - in memory so every time we run this my
157:23 - action every time we do that it is going
157:24 - to create a brand new object every time
157:26 - we run the main function every time we
157:28 - do it it is going to create a brand new
157:30 - instance of this object it's going to
157:31 - create a brand new Lambda whereas local
157:34 - functions these are defined as compile
157:36 - time so in memory they only exist once
157:38 - so we could call the main function 100
157:40 - times and it would create 100 instances
157:42 - of this Lambda but only one instance of
157:44 - this print function so in terms of
157:46 - memory if your memory limited then local
157:48 - functions would be a better option than
157:50 - using lambdas so in general both local
157:52 - functions and Lambda serve a somewhat
157:54 - similar purpose they allow you to Define
157:56 - functions whilst inside another function
157:58 - local functions can be great for
157:59 - organizing logic within a function
158:01 - assuming whatever you're doing in that
158:03 - function is only ever done within that
158:04 - other function and lambdas are great for
158:06 - super quick things like assigning logic
158:08 - to a button click for the most part
158:09 - personally I really only use lambdas but
158:11 - local functions also have their use case
158:14 - hello and welcome I'm your Kodi in this
158:17 - lecture we're going to learn all about
158:18 - events this is extremely powerful
158:20 - feature of C it helps us write much
158:22 - better code with much fewer dependencies
158:24 - okay so events this is basically how you
158:26 - can have one class and that class fires
158:29 - off events when something happens and
158:31 - the subscribers that listen to that
158:32 - event those will be notified whenever
158:34 - that event happens for example here's a
158:36 - working demo so there's a tower and I
158:38 - can click to damage it and by using
158:40 - events we can have some kind of health
158:42 - bar and that health bar is listening to
158:44 - when the tower takes damage and when it
158:45 - does the health bar listens that event
158:47 - and updates its own state so the UI
158:49 - element over here this one is listening
158:50 - to the build damage event itself and
158:52 - then updates the health bar events have
158:54 - Publishers and subscribers or sometimes
158:56 - subscribers are call listeners those two
158:58 - terms are really used interchangeably
159:00 - the event is defined within some kind of
159:02 - class and then you can listen or
159:04 - subscribe to that event from anywhere
159:05 - else now what that means is that when
159:07 - the event is invoked all of these
159:08 - subscribers those all get notified that
159:10 - the event happened and note how this
159:12 - relationship only goes one way so the
159:14 - subscribers attach to the event in order
159:16 - to be notified but the event publisher
159:18 - this one has no idea that are any
159:19 - subscribers this is really excellent for
159:21 - keeping your Cod decoupled the event
159:23 - publisher does not know and does not
159:24 - need to know if there are any
159:26 - subscribers at all maybe there are some
159:27 - maybe there are none it does not matter
159:29 - the event publisher itself is completely
159:31 - decoupled from any subscribers as far as
159:33 - the event publisher knows it just knows
159:34 - that it fired off an event that's it it
159:36 - does not know and does not care if
159:38 - anyone is listening and the other
159:39 - benefit of using events is that our code
159:41 - can be based on when things happen as
159:43 - opposed to constantly pulling for
159:44 - something for example over here on this
159:46 - demo the health bar does not have to
159:48 - constantly pull the tower to check its
159:49 - Health State on every single update so
159:52 - it does not have to ask that question 60
159:54 - times a second the health bar is
159:55 - perfectly idle it only listens when the
159:57 - event is published so only when
159:59 - something actually happens does the
160:00 - health bar take action here in the code
160:02 - the tower script this one has an
160:04 - undamaged event then this demo is really
160:06 - super simple I'm just testing for the
160:07 - mouse click and if so calling the damage
160:09 - function and damage function simply
160:11 - Alters the health amount and fires off
160:13 - the event again note how this Tower does
160:15 - not know anything about any kind of
160:16 - health bar it is completely decoupled
160:18 - and then on the the health bar itself
160:20 - this one does know that Tower exists it
160:21 - attaches itself to the on Tower on
160:23 - damaged event and when that event
160:25 - happens it simply updates the health bar
160:27 - so in order to show how the code is
160:28 - decoupled I can just go ahead and get
160:30 - rid of the health bar so I can just
160:32 - disable this game object and yep
160:34 - everything does work because the tower
160:36 - does not depend on the health bar okay
160:37 - so that's a quick overview of events now
160:39 - let's see the syntax and the way that we
160:41 - make events is actually super simple
160:43 - this lecture will be really easy to
160:44 - understand because we already learned
160:45 - about delegates which are quite closely
160:47 - related to Events first we our access
160:49 - modifier and usually for events you do
160:52 - want them to be public you want it
160:53 - public so that any other classes can
160:55 - listen to that event it doesn't make
160:56 - much sense to have one event that is
160:58 - only listenable from that class so
161:00 - usually events are public and then we
161:02 - have the keyword event on lowercase this
161:04 - is a special keyword then we add the
161:06 - delegate and like we covered in the
161:08 - delegates lecture we can Define our
161:10 - custom delegate or we can use the
161:11 - built-in action for example so let's use
161:13 - this one just because it's so easy and
161:15 - then we give it some kind of name
161:16 - usually the convention is to start your
161:18 - event names with on and then whatever
161:20 - happened so for example on player
161:22 - damaged see up like this and in terms of
161:24 - naming rules events are usually Pascal
161:26 - Cas just like properties okay so great
161:28 - so just like this we have defined our
161:30 - event now let's ready quick demo just
161:32 - see how it works and for that let me
161:33 - actually just put this inside a basic
161:35 - player class just so that makes a little
161:38 - bit more sense so put it inside there
161:40 - and now let's make some kind of damage
161:42 - function so let's call damage and now
161:44 - here the first thing we can do with our
161:45 - event is simply fire it and for that we
161:47 - do it pretty much as if this was a a
161:49 - normal delegate and we were just calling
161:51 - it so let's go on player damage and
161:53 - simply call it like this so that's it
161:55 - super simple however this code will
161:57 - actually throw an error but let's test
161:58 - it like this up here let's just create a
162:00 - new player just construct a brand new
162:02 - player then on player let's call damage
162:04 - and let's test any right away we have an
162:06 - error we have a no reference exception
162:08 - so this has to do with the fact that
162:09 - this event currently does not have any
162:11 - listeners if it has no listeners then
162:13 - this field is essentially set to n so
162:15 - before invoking an event we need to
162:16 - check if it has some listeners and we
162:18 - can do that just by checking against
162:19 - null so if the event is not null if so
162:22 - then that means it has some listeners so
162:24 - we can safely call that event so like
162:26 - this if we run and Y no errors although
162:28 - also nothing happened so now that we are
162:30 - correctly firing off the event let's add
162:32 - in listener let's make another class
162:34 - let's make it a class and call it player
162:36 - health bar something like this and now
162:38 - in order to listen an event we need some
162:39 - kind of reference so let's actually make
162:41 - a Constructor for our player health bar
162:43 - and the Constructor let's receive an
162:45 - object of type player so we received
162:47 - that and now here we can go through the
162:48 - player and now we can indeed access the
162:50 - onplay damage event also here in Visual
162:52 - Studio it shows this little lightning
162:54 - bolt this means an event so we can
162:56 - access that event and then we can do
162:58 - plus equals in order to subscribe to
162:59 - that event and here by the way Visual
163:01 - Studio has this really nice shortcut it
163:03 - is going to autorite the player on
163:04 - player damage event so just press tab to
163:06 - insert usually I do this then if you
163:08 - want you can rename it or just press
163:10 - enter and yep there's our event function
163:12 - now if you don't see this shortcut or if
163:14 - you're using different ID you can just
163:15 - manually write this function it's a
163:17 - pretty basic function the only important
163:18 - thing is just like we covered in the
163:20 - delegates lecture the function signature
163:22 - needs to match event signature so in
163:23 - this case for the event we made it of
163:25 - type action which means it must return
163:27 - void and must have no parameters okay so
163:30 - here we are listening to the event let's
163:32 - just do a log so console. right line
163:34 - let's just print out the on player
163:36 - damage event just like this and now up
163:39 - here let's construct our player health
163:41 - bar so let's construct a brand new one
163:44 - let's make it and this one requires a
163:46 - reference to our players so let's pass
163:47 - it in so first we create the health bar
163:49 - and then we call damage on the player so
163:51 - now basically what will happen is when
163:53 - we call damage the player damage this
163:55 - one is going to fire the on player
163:56 - damage event it is going to check
163:57 - against null and since we have a
163:59 - listener this one is not going to be
164:00 - null so it is going to run our event and
164:02 - by running that event it is essentially
164:03 - going to run this code and print this
164:05 - slide so let's see any if there it is
164:07 - the event was fired and listener did
164:08 - listen to that event all right Awesome
164:11 - Again note one of the big benefits of
164:13 - about events the player class this one
164:15 - has absolutely no relation to the player
164:16 - health bar so the player class is
164:18 - completely decoupled from the player
164:20 - health bar as opposed to for example if
164:22 - we were to make this public and then up
164:24 - here we would have some kind of private
164:26 - field of player health bar then we would
164:29 - need to keep this reference and in doing
164:31 - those on the damage we would call the
164:33 - player on damage function if we did this
164:35 - then the player class would be tially
164:37 - comp to this one so for example if I
164:38 - remove this one obviously there are
164:40 - errors because this type no longer
164:41 - exists whereas if we go back to what we
164:43 - had previously here is just the event
164:45 - here is just the player class and if I
164:47 - completely remove this one yep there are
164:48 - no errors inside the player class this
164:50 - is what it means to be completely
164:51 - decoupled is that the player class does
164:53 - not know and does not care if anything
164:55 - listens that listens to that event if it
164:57 - does then great if not then also great
165:00 - then one important thing about events is
165:01 - how multiple classes can listen to one
165:03 - event for example if over here I make
165:06 - another one let's make this a Mana bar
165:08 - so do it like this do it pretty much the
165:10 - same and over here let's say Mana bar
165:12 - something and then up here if we
165:14 - construct a new of type this if we do it
165:17 - then now we have two listeners to this
165:18 - event so when this fires it is actually
165:20 - going to run both of these listeners and
165:22 - if there is both them did run so events
165:24 - can be listened to by multiple listeners
165:27 - and then over here we are subscribing
165:29 - but if you want at some point to stop
165:30 - listening to that event you can simply
165:32 - swap the plus equals to minus equals and
165:34 - yep with that we can unsubscribe and at
165:36 - this point I should point out that
165:37 - unsubscribing to events is actually very
165:39 - important if you don't then you might
165:41 - end up with memory leaks depending on
165:43 - the left time of the object if the
165:44 - listener gets destroyed but the poish
165:46 - lives on if so then it will actually
165:48 - keep firing events onto a listener that
165:50 - no longer exists so that could cause all
165:52 - kinds of issues so always keep that in
165:54 - mind either pay attention to the
165:55 - lifetime of the objects because if the
165:58 - player has the same lifetime as this one
166:00 - then technically you don't need to
166:01 - unsubscribe but if they do have
166:02 - different lifetimes if so then when this
166:04 - object is destroyed make sure you
166:05 - unsubscribe to that event so yep we can
166:08 - either do plus equals or minus equals to
166:09 - subscribe or unsubscribe and on the
166:12 - class that defines the event we can also
166:13 - call the event and now right away you
166:15 - might be thinking that this looks
166:16 - exactly like delegates especially the
166:18 - delegates multicast function and if
166:20 - that's right this is indeed very similar
166:22 - to delegates in fact if over here I just
166:24 - remove the event keyword if I do no
166:27 - nothing changed there are no errors and
166:28 - if we run this yep everything still ran
166:30 - exactly the same so technically it works
166:32 - like this however adding the event
166:34 - keyword had some really useful
166:35 - limitations first of all is who can
166:37 - trigger that event if we do not add the
166:39 - event keyword then anyone would access
166:41 - to this event can invoke it so for
166:43 - example down here on the player health
166:45 - bar I can go on there call it and Yep
166:47 - this will work so this player health bar
166:49 - will be invoking this event usually you
166:51 - do not want this you want the class that
166:53 - defines the event to be the only one
166:55 - that can actually invoke the event and
166:57 - if you add the event keyword then the
166:58 - compiler actually enforces that rule so
167:00 - yep down here nope it cannot call it the
167:02 - event can only appear on the left hand
167:04 - side of a plus equals or minus equals so
167:06 - subscribing or unsubscribing except of
167:08 - course when used from within the player
167:10 - class within where the event was defined
167:12 - so the event keyword is really nice for
167:14 - essentially protecting you for yourself
167:16 - remember how the main clean Cod
167:17 - principle is simply minim in complexity
167:20 - so the more you minimize access to a
167:21 - particular field the better it is
167:23 - another limitation that this keyword
167:25 - adds is simply the ability to clear the
167:27 - event so again if we remove it then for
167:29 - example down here the player manavar
167:31 - this one can go into the event and set
167:33 - it to null and if we test the code like
167:35 - this yep look that issue basically the
167:37 - menar completely raised the original
167:39 - event listener so the player health bar
167:40 - this one no longer listens to everything
167:42 - anything because this one pretty much
167:43 - broke the code again this is something
167:45 - you don't want to happen with events and
167:47 - again this is something that just by
167:48 - adding the event keyword the compiler
167:50 - will help you by enforcing some rules
167:52 - and yep like it says here once again
167:53 - same thing Bing the event keyword the
167:55 - only thing you can do outside of that
167:56 - main class the only thing you can do is
167:58 - subscribe and unsubscribe and nothing
168:00 - else so in many ways events are indeed
168:02 - pretty much delegates since they in fact
168:04 - actually they use delegates like we saw
168:06 - here we are using the action delegate
168:08 - but even keyword that would add some
168:10 - really nice limitations to basically
168:11 - protect the code from yourself and of
168:13 - course since he use delegates we can use
168:14 - anything more than just a simple action
168:16 - if we want to pass in some data for the
168:18 - event we can really just use a delicate
168:20 - with parameters so for example let's use
168:22 - an action of type int and then over here
168:24 - when we call the event we can pass in
168:26 - any kind of int value and then down here
168:28 - on these in order to listen again The
168:30 - Listener function needs to perfectly
168:31 - match that one so if this one expects an
168:33 - end then over here we also need to put
168:34 - an INT and yep like this it will also
168:37 - work and the parameter over here will be
168:39 - whatever you do when you call the event
168:41 - now another thing is over here we've
168:42 - been using the action delegate you can
168:44 - use whatever delegate you want you can
168:46 - build your own delegates or you can use
168:47 - action the built-in type but in general
168:49 - the C standard is to use the event
168:52 - handler this one right here that exists
168:54 - inside of system this one has a
168:56 - signature where it takes in an object
168:58 - for the sender and an event arcs so
169:00 - usually when invoking the event for the
169:02 - object sender you pass in this so you
169:04 - can pass in a reference to whatever
169:06 - object was firing that event and for the
169:08 - event ARS if there aren't any you can
169:09 - just use the constant event ARS empty so
169:12 - yep just like this but again this is not
169:14 - a requirement like we saw you can use
169:16 - pretty much any delegate you want you
169:17 - can use action and everything works just
169:19 - fine but generally this is the C
169:21 - standard if you see a bunch of C code
169:23 - chance are they're going to be using the
169:24 - event handler and then this one actually
169:26 - has a second parameter that defines what
169:29 - are the event arcs again that parameter
169:31 - is also used with generics so let's open
169:33 - up that one and yep it has a type of
169:34 - event arcs so while following the
169:37 - standard if you still want to pass extra
169:39 - data you can for that usually you make
169:41 - some kind of class that extends event
169:42 - args so here let's make a class and
169:45 - usually the standard name is to give it
169:46 - the same name as events so on player
169:49 - damaged and then you simply append event
169:51 - arcs at the end and we make this a class
169:54 - that extends event arcs simply like this
169:56 - and then over here we add whatever
169:58 - parameters we want so like for example
169:59 - in this case maybe we would have like
170:02 - previous Health in order to know the
170:03 - previous Health before the player was
170:05 - damaged and then over here on the event
170:06 - hangler we use generics and we pass in
170:09 - our custom type just like this and then
170:11 - over here when we invoke the events
170:13 - instead of event arsmt we just construct
170:16 - a new object of our type and add
170:18 - whatever that we want so just like this
170:20 - and again on all these other ones of
170:22 - course we need to remake the function
170:24 - signature in order to perfectly match
170:26 - and again this something that Visual
170:27 - Studio does by default so just do plus
170:29 - equals and it's automatically going to
170:31 - write with the perfect event signature
170:33 - and over here on this one in order to
170:34 - access that data that is going to be
170:36 - over here on the second parameter so we
170:38 - can access e and then inside we've got
170:40 - the previous El and we can do whatever
170:41 - we want also one of the first things we
170:43 - saw is over here if we do not add this
170:45 - null check if we don't then this is
170:47 - actually going to throw a null reference
170:49 - exception so you always need to check
170:50 - for null however there's a special way
170:52 - to make this code a little bit more
170:54 - compact so you've got event and again
170:56 - just like this going to fire off null if
170:57 - we have null listeners so what we can do
171:00 - is we can use what is called a null
171:01 - conditional operator I'm going to cover
171:03 - these in more detail in the advance
171:05 - section but basically we can just set a
171:07 - question mark and basically this will
171:09 - mean that the code to the right side
171:10 - this code will only run if the code on
171:12 - the left side is not equal to null so we
171:14 - can do the question mark and then call
171:16 - invoke which is basically going to
171:17 - invoke the event and just like this so
171:19 - again the question mark basically means
171:21 - that is only going to continue executing
171:23 - code to the right if the code on the
171:24 - left does not equal null so if this one
171:26 - is not null if we do have listeners to
171:28 - our event then we are going to invoke
171:29 - the event so instead of having a normal
171:31 - test for null usually with events you
171:33 - have this kind of syntax so you just do
171:35 - a non-conditional operator and call
171:37 - invoke and invoke that event now one of
171:39 - the best things about events is what I
171:40 - mentioned already about code decoupling
171:42 - that truly is one of the magical powers
171:44 - of events it's how the event publisher
171:46 - does not know and does not care how many
171:48 - listeners that are to that event it
171:50 - simply fires off the event and does not
171:51 - care what else happens then all the
171:53 - listeners if there are any they will
171:55 - listen to that event and do whatever
171:56 - logic they want based on that event this
171:58 - is really a crucial thing about events
172:00 - decoupling your code as much as possible
172:02 - is one of the best rules you can follow
172:04 - in order to write better clean code and
172:06 - like we saw this is especially great
172:07 - when games when working with the UI
172:09 - usually you want your UI to display your
172:11 - game logic like for example the health
172:13 - of some kind of tower you want some kind
172:15 - of visual for it but you also do not
172:16 - want the tower itself to be the pendent
172:18 - on some kind of visual in theory your
172:20 - game should work entirely without any UI
172:22 - and by using vents this is really simple
172:24 - you can just make it so for example over
172:26 - here the tower class just fires off some
172:28 - kind of event and then maybe we do and
172:30 - maybe we don't have some kind of
172:31 - external display on top that displays
172:33 - some data based on that event if DUI
172:35 - exists then great but if it doesn't then
172:36 - the tower works just exactly the same so
172:38 - events as you can see are extremely
172:40 - useful in helping you write better more
172:41 - performant and more the cou on code
172:44 - definitely make sure you fully
172:45 - understand them which if you fully
172:46 - understood everything in the delegates
172:48 - lecture hopefully you manag to quite
172:49 - easily understand this lecture hello and
172:52 - welcome I'm your codm in this lecture
172:54 - we're going to learn all about generics
172:56 - this is yet another really powerful C
172:58 - feature this one lets you write code
173:00 - that can be used with a multitude of
173:02 - types okay so let's learn about generics
173:04 - and you've actually already seen them in
173:05 - action in a bunch of places for example
173:07 - quite a long time ago we learned about
173:09 - list and in list this type requires
173:11 - putting another type within those angle
173:13 - brackets this right here for example
173:15 - list of inth this is what is called the
173:17 - generic the list type works with
173:18 - generics which means it can work with
173:20 - any type so we can make a list of ins we
173:22 - can make a list of strings we can make a
173:24 - list of program types and so on if it
173:26 - did not have generics in we would need
173:28 - to create a separate list class for
173:30 - every single type we wanted to use it
173:31 - with that would definitely not be very
173:32 - fun not very easy to use whereas with
173:34 - generics we just Define the list class
173:36 - just once just one time and then that
173:38 - class can work with any type we want
173:40 - also same thing when we saw the delegate
173:42 - so we saw for example the action and we
173:44 - saw this one has all kinds of parameters
173:46 - so we can have an action that takes in a
173:48 - parameter of type int we can have a type
173:50 - string we can have a type B and so on
173:52 - same thing for the funk so again there's
173:54 - no need to create a specific action
173:56 - class that works specifically with an
173:57 - INT another one specifically with a
173:59 - float and so on the action class itself
174:00 - that one is made to work with generics
174:02 - it takes a generic T type and that type
174:04 - can be whatever you want now one of the
174:06 - best practical examples of how useful
174:08 - generics are is actually my grid system
174:10 - playlist I've built a ton of interesting
174:12 - systems and games on top of that base
174:14 - system and the reason why I could do
174:15 - that is because the grid system itself
174:17 - that one is made to work with generics
174:18 - here is that class the grid class with
174:20 - generics here it works with a generic
174:22 - type that I Nam T grid object so I can
174:25 - define a specific grid that works with a
174:27 - specific type again could be something
174:28 - simple like an INT a float bow and so on
174:31 - or it can be a specific custom grid
174:33 - object class that I Define and with that
174:35 - with that grid object I can place
174:36 - whatever custom dat I want and the grid
174:38 - system will work perfectly with it so I
174:40 - don't need to make a brand new grid
174:42 - system for every kind of thing that I
174:43 - want to do with a grid I just use the
174:45 - exact same grid system for any type and
174:47 - byting this class using generics by
174:49 - doing that I managed to reuse this Base
174:51 - Class and build all those complex
174:53 - systems that I made in all those videos
174:54 - so how we make a generic class is
174:56 - actually really simple we just write the
174:58 - class name as usual for example let's
175:00 - make our own custom list so let's make a
175:02 - class let's call it my list and then we
175:05 - put our angle brackets and inside here
175:07 - we give our generic type of name and
175:09 - technically you can give it whatever
175:10 - name you want there's no rules here
175:12 - however usually the convention is to
175:13 - name this t for type and alternatively
175:16 - if you have multiple types the
175:17 - convention is to use T and then perhaps
175:19 - a number so T1 T2 T3 so this is what the
175:22 - action uses or alternatively if you want
175:24 - any more descriptive name usually once
175:25 - again you would still start to type with
175:27 - t and then pass in something like for
175:29 - example T unit another example of
175:31 - generics that we've also already seen is
175:32 - the dictionary and if we look inside the
175:34 - dictionary Yep this one named the
175:36 - generics T key and T value so yep you
175:38 - can write whatever you want but over
175:39 - here let's just write a t so just like
175:41 - this so here we have our class with a
175:43 - generic type and now inside of this code
175:45 - we can use the type T so for example
175:47 - let's make a public field of type T so
175:49 - yep just like this now importantly is
175:51 - how T doesn't really exist we don't have
175:53 - any class named specifically t t is
175:56 - really just the name that we defined
175:57 - this can be whatever class we're going
175:59 - to use with so when we use our my list
176:01 - with a type int then this field will be
176:04 - an in field so this our BAS glass and
176:06 - now up here we can make a new let's
176:08 - create a new M list and then for type
176:10 - let's go with int just like this so this
176:12 - is a m list of type int and over here we
176:15 - can go inside access the field and yep
176:17 - note how this field is indeed of type in
176:19 - and yep so this does work then for
176:21 - example let's say we want this class to
176:23 - work with blls again since we are using
176:25 - generics we don't need to make another
176:27 - class definition we can just go up here
176:29 - make another M list in this case of type
176:31 - B let's name it b m list and then do a
176:34 - new in of bow and now we can go inside
176:36 - we can access the field and Yep this one
176:38 - is now a field of type B so over here we
176:41 - have two instances of our class and each
176:43 - of them is working with a different
176:44 - underlying type then our generic we
176:46 - Define our type te where we're using it
176:48 - over here in the field but we can also
176:50 - Define some kind of functions for
176:52 - example let's make a private void my
176:54 - function and we can receive a parameter
176:56 - of type t or alternatively we can make a
176:59 - return of type T and take in no
177:00 - parameters also by the way one quick Tip
177:02 - since over here we do not know what type
177:04 - T is going to be since we don't know
177:06 - that then for example we cannot return
177:08 - null this does not work and the reason
177:10 - why it does not work is because T
177:11 - technically could be a non-nullable
177:13 - value type like for example up here when
177:15 - we are creating our list of ins or bones
177:17 - these are are not nullable values these
177:19 - are value types not reference types so
177:21 - because that over here we cannot return
177:23 - null so if you do have some kind of
177:25 - logic that is meant to return a default
177:26 - value instead of returning null instead
177:28 - of that you can use the keyword default
177:30 - and this will return either null on a
177:32 - reference type or the zero equivalent on
177:34 - some kind of value type so for example
177:36 - let's do this let's make it public and
177:38 - then up here let's call it so let's call
177:40 - my function let's put a right line on
177:43 - this let's see what default value is for
177:45 - both these so let's see and if there it
177:47 - is default value for an INT is zero
177:49 - default value for a ball is false then
177:51 - on the generic definition over here like
177:54 - we saw we can already Define more than
177:55 - one type so we can Define T1 T2 T3 and
177:59 - so on we can do this and then we can use
178:01 - different types in our code this works
178:03 - so here we have our generic class but we
178:06 - can also use generics without making an
178:08 - entire class generic we can have just a
178:10 - single function so over here let's make
178:13 - a test function and on the function
178:15 - itself let's make that function work
178:16 - with generics the way we do it is really
178:18 - the same thing so after the function
178:19 - name we put the angle brackets then some
178:22 - kind of generic name and now we can use
178:24 - this type in any way like for example
178:26 - use it over here for a parameter or we
178:28 - can use it for the return type and yep
178:30 - everything works isly the same over here
178:32 - let's do a console d right line let's
178:35 - print out p and for example up here
178:37 - let's call out this one and we can call
178:39 - in with an INT and if this works we can
178:41 - call in with a string and Y it also
178:43 - works call in with a sh Yep this works
178:46 - call in with a bullion and Y this also
178:48 - works so here we have a function the
178:50 - function was defined with generics which
178:52 - means that we can run this function with
178:53 - whatever type we want then it can also
178:55 - make stru that use generics so instead
178:57 - of a class this can be a struct and yep
178:59 - structs can also use generics another
179:01 - one is also on interfaces so up here we
179:03 - can Define interface my interface and on
179:06 - this one we can also use a custom type
179:08 - and then we can use this type like for
179:10 - example some kind of function that
179:11 - returns of type T Yep this is also valid
179:14 - so lots of use cases for how you can
179:15 - Define generics and how you can use them
179:17 - and another extremely useful thing we
179:19 - can do is simply apply some type
179:20 - constraints to T right now we have no
179:22 - constraints meaning this T this can be
179:24 - used with any type for the generic it
179:26 - can be ins bowls some kind of custom
179:28 - player class it can be literally
179:29 - anything now let's say for example we
179:31 - want this one to only work with classes
179:33 - for that we can go over here into the
179:35 - class definition and afterwards we write
179:37 - the keyword where and then our generic
179:40 - type so in this case T and then put a
179:42 - con and then let's say for example class
179:44 - meaning that this one this type M list
179:46 - can only be used with a the T type as
179:48 - long as that type is of type class so
179:50 - like for example here we see some errors
179:52 - because ins and Bs these are not classes
179:54 - so we cannot use with those we need to
179:56 - make some kind of class for some kind of
179:58 - player and now of here we can make this
180:00 - of type player and if now this does work
180:03 - and again the issue that we saw a while
180:04 - ago on how we cannot return null from
180:06 - this one but if we do enforce that t has
180:09 - to be of type class classes can always
180:10 - be null so now we can indeed use null
180:12 - here then another interesting constraint
180:14 - is let's say for example we want to
180:16 - construct whatever type we use here and
180:18 - right now over here on this function if
180:20 - I try to do new T if I do this nope
180:22 - there's an error again same thing we
180:24 - cannot do it because we have no
180:26 - guarantee that whatever type we use here
180:28 - whatever type we use has some kind of
180:30 - Constructor in order to make that work
180:31 - again we can apply another constraint in
180:33 - this case this one is named new just
180:35 - like this so now we can use this class
180:37 - with any generic type as long as that
180:39 - generic type is a class and has a
180:41 - parameter lless Constructor which over
180:42 - here the player by default has some kind
180:44 - of parameter list Constructor so yep
180:46 - this one is perfectly valid code and
180:48 - over here yep we can do new T in order
180:49 - to construct a brand new player for
180:51 - example we can put this on that one and
180:53 - this one is going to construct a new
180:55 - object of type T which in this case is
180:56 - going to be the player so when we run
180:58 - this it should say something of type
180:59 - player and if there it is it's done like
181:01 - that there's a bunch of really useful
181:03 - constraints we can apply to our generic
181:04 - type there's a great list on the C docs
181:07 - we can see how we can force T in order
181:09 - to be of type struct of type class we
181:11 - can ensure that it is a nonnal type we
181:13 - can ensure that it has a parameter
181:15 - Constructor or one of the most useful
181:17 - ones are simple L these ones basically
181:19 - requiring T to extend some kind of Base
181:21 - Class or Implement some kind of
181:22 - interface and all of these work on a
181:24 - class definition but also over here on
181:26 - just a single function so again where T
181:29 - is a class and now it ensures that we
181:31 - can only call this function with the
181:32 - type that is actually a class and when
181:34 - using the one that enforces that it
181:36 - extends some kind of interface for
181:38 - example let's make a function get attack
181:40 - winner and let's receive two types T1
181:43 - and T2 Ral let's give it proper names so
181:46 - T attackable and T defendable then we
181:49 - receive those so we can enforce that t
181:51 - attackable does have to implement the I
181:53 - attackable interface and we can enforce
181:55 - that t defendable has to implement the I
181:57 - defendable interface and now since we've
181:59 - applied these constraints because that
182:01 - now we can assume some things about
182:03 - these types for example we can go inside
182:05 - our attackable object and we can call
182:07 - get attack points then we can go into
182:09 - the defendable and call the get defense
182:11 - points just like this now with this if
182:13 - we had a player type that implements
182:15 - both these interfaces and a unit en type
182:17 - that also implements both of them if so
182:19 - we could call this function and pass in
182:21 - either two players or a player and an
182:22 - enemy or two enemies and all of this
182:24 - logic would work because all of them
182:26 - match the perfect generic constraints
182:28 - that we have so that means that this
182:30 - function this single function is really
182:32 - adaptable and can be used with a ton of
182:34 - different types whereas if we were to
182:36 - remove these then nope we cannot access
182:38 - these functions because we have no
182:39 - guarantee that whatever types we use
182:41 - here will actually have these interfaces
182:43 - in generally one of the best benefits of
182:45 - generics is how they make your code Type
182:47 - safe meaning they help you avoid errors
182:48 - when using incompatible types for
182:51 - example let's say we have some kind of
182:52 - resource so we have a type for gold a
182:54 - type for wood and then we have an
182:55 - inventory class that takes in a generic
182:57 - type so then up here we created
182:59 - different inventories one for gold one
183:01 - for wood if we go inside the gold
183:03 - inventory and we try to add and let's
183:05 - try to add some wood if we do this and
183:07 - nope obviously this one throws an error
183:09 - this is how generic samp is by making
183:10 - our code Type safe if we make an object
183:13 - of a type and we Define that this one
183:14 - only works with gold types if so then we
183:16 - cannot add some wood on there the type
183:18 - itself is going to be forced as soon as
183:20 - we create the object and we cannot break
183:22 - that rule all right so those are
183:23 - generics it's another extremely useful
183:25 - sear feature I use them all the time
183:27 - they are super useful for making your
183:28 - code really adaptable so definitely make
183:30 - sure you fully understand this and make
183:32 - sure you use it whenever you need to
183:34 - this is really powerful but also for
183:35 - beginners might be a little bit
183:37 - confusing so if you feel a little bit
183:38 - lost maybe go rewatch The ler one more
183:40 - time maybe go inspect the demo and
183:42 - definitely make sure you do all of the
183:43 - interactive exercises this is a really
183:45 - powerful feature you definitely must
183:47 - know about
183:48 - hello and welcome I'm your Cod monkey in
183:50 - this lecture we're going to learn about
183:51 - constants and the readon keyword okay so
183:54 - normally we have regular variables like
183:56 - for example int Ag and a variable just
183:58 - like name implies the value inside of it
183:59 - can change they're intentionally
184:01 - supposed to be modifiable so over here I
184:03 - can set it to one value and then set it
184:05 - to another value Yep this works but
184:07 - sometimes you really don't want
184:08 - something to modify some things are
184:09 - meant to have some kind of fixed value
184:11 - like for example Pi it has a fixed value
184:14 - and in C you can actually see it with
184:16 - math. pi y there it is 3.1415 926 and so
184:20 - on and note over here how this one is a
184:22 - constant meaning it always has this
184:24 - value you cannot change to something
184:26 - else so if here I put it to just three
184:28 - nope this does not work I cannot assign
184:30 - this to anything else it's a constant
184:32 - meaning the value is always going to be
184:33 - fixed so I need to Define some kind of
184:35 - field for something where the value
184:37 - should never change like for example
184:39 - some kind of float for some kind of
184:41 - player speed if we set it like this then
184:43 - this is a perfectly regular field so we
184:45 - can read it then we can modify it in
184:46 - order to make it a constant we just go
184:48 - here and we add the keyword const and if
184:50 - there it is now we can use this field
184:52 - whatever we want and this is always
184:53 - going to have this constant value we
184:55 - cannot modify this by the way for the
184:57 - name like I mentioned in the naming
184:58 - rules lecture usually constants are
185:00 - uppercase snake case so everything is
185:02 - uppercase and split all the words with
185:03 - an underscore and of course since
185:05 - constants cannot change then we have to
185:07 - assign some kind of value so if we
185:09 - Define something as constant we have to
185:10 - Define it with some kind of value okay
185:12 - so Yep this is our constant and
185:14 - constants are also basically static by
185:16 - nature meaning they do not belong to any
185:18 - instance of any class they belong to the
185:20 - class itself so for example over here
185:22 - we're working inside the static main
185:24 - function and usually we can only access
185:25 - static members so if this one is just a
185:28 - regular field if it is like this then
185:29 - over here we cannot access the player
185:31 - speed we cannot access it because this
185:33 - one is not static but by marking
185:36 - something as cons that makes it
185:37 - essentially static by default so over
185:39 - here we can do Con on the right line we
185:41 - can print this out and up here we can
185:43 - indeed access player speed also
185:44 - importantly is how Conant they are set
185:46 - at compile time time meaning the value
185:49 - has to be evaluated and defined during
185:51 - compilation not during runtime so that
185:53 - means constants are also somewhat
185:54 - Limited in what types you can use with
185:56 - them for example we cannot make some
185:58 - kind of class let's make a class player
186:00 - so we have this and now up here we
186:02 - cannot make a private cons of type
186:04 - player for the player we cannot do this
186:06 - because we need to assign a value and if
186:09 - we construct a brand new player nope
186:10 - this does not work because this line
186:11 - would only run during runtime and not
186:14 - during compilation so for the most part
186:16 - cons can only be used with the built-in
186:18 - type so things like float bll we can use
186:21 - string and so on however classes custom
186:23 - classes or even default ones like for
186:25 - example object these cannot be constant
186:27 - so constants have a bunch of limitations
186:30 - but for example if we inspect the vector
186:31 - 3 struct so let's go inside of this one
186:34 - so let's right click and over here let's
186:35 - go to definition so here is the vector 3
186:38 - struct and if we scroll down we can see
186:40 - it as some things that look kind of like
186:42 - constants like VOR 3.0 or. one but again
186:45 - a strug cannot be constant so note how
186:46 - these are not Conant instead these are
186:49 - Statics and this is actually property
186:50 - and only has a get and always returns
186:52 - the same value so this is one of the
186:53 - workarounds you can do if you're trying
186:55 - to make a Conant of a type that cannot
186:57 - be constant alternatively there's
186:58 - another really interesting workaround
187:00 - you can build something similar to a
187:02 - Conant by using the keyword read only so
187:04 - let's define a field instead of making
187:05 - this a constant let's make it a read
187:07 - only and if this one now does work we
187:09 - don't have any more errors what read
187:11 - only means is that these fields cannot
187:13 - be changed after they are set so if we
187:15 - try down here assigning it to a brand
187:17 - new thing nope does not work this throws
187:19 - an error so if you mark something as
187:21 - read only it can have some kind of
187:22 - object type but it must be set either
187:25 - over here directly in the Declaration or
187:27 - it must be set in some kind of
187:28 - Constructor this one works with any type
187:30 - so it can be custom classes or it can
187:32 - also be the built-in types like int and
187:34 - so on it can still be useful to use read
187:36 - only instead of cons even for these
187:38 - basic types like for example on the
187:39 - player class over here let's say each
187:42 - player would have a different kind of
187:44 - maximum health so they would have a
187:46 - private read only for the health max and
187:48 - then on the player Constructor we could
187:50 - receive a certain health max then assign
187:53 - the health max onto this one just like
187:55 - this meaning that this would sort of act
187:57 - like a constant meaning we cannot change
187:59 - it afterwards but this way by using the
188:01 - read only tag basically we can set it to
188:02 - a different value and does not have to
188:04 - be set directly at compound time so
188:06 - that's really the main difference
188:07 - between these two for any data that you
188:09 - never want to change and any data that
188:11 - can be defined at compound time for
188:13 - those you can use const and if not you
188:15 - can make it read only once again
188:17 - remember the the main goal behind
188:18 - writing good clean code the main goal is
188:20 - minimizing complexity and the best way
188:22 - to do that is minimize how many things
188:23 - can change so if something is never
188:25 - meant to change then either just make it
188:27 - a constant or read only doing that will
188:29 - help you make your code much easier to
188:31 - understand hello and welcome I'm your
188:33 - Kodi in this lecture we're going to
188:35 - learn about exceptions as well as how to
188:37 - handle them and Fire custom exceptions
188:39 - okay so exceptions these are really
188:41 - errors we've already see them a bunch
188:43 - for example here's some code that is
188:44 - going to throw an error so I def find an
188:46 - in a variable with value zero and then I
188:49 - just do oneide by a so 1 divide by 0 you
188:51 - can never divide by zero so this is
188:53 - going to throw an error let's try
188:54 - running and if there it is right away
188:56 - divide by zero exception so when you
188:58 - hear the word exception than error now
189:00 - if I were to write some logic after this
189:02 - like for example let's say conso the
189:03 - right line let's print out something so
189:06 - let's try running and nope that message
189:07 - does not run as soon as the code gets
189:09 - the exception it stops executing that's
189:12 - where exceptions are meant to do but
189:14 - sometimes you don't want to happen
189:15 - usually if something goes wrong you want
189:17 - to know that something went wrong but
189:18 - then you also want to handle it so
189:20 - usually you don't want to have unhandled
189:22 - exceptions so the way that we can handle
189:24 - exceptions is with a trap block meaning
189:26 - we write the keyword try and then put a
189:28 - code block and inside that code block we
189:30 - put whatever code might fire some kind
189:32 - of exception then to make this valid we
189:34 - need a second piece of code which is
189:36 - called the catch but first let's run it
189:37 - just like this so this is still going to
189:39 - throw an exception this is still going
189:41 - to throw an error dividing by zero but
189:42 - now let's see if this line does run and
189:44 - if there go it did run and we do not
189:46 - have our exception now technically the
189:47 - exception still happen it really just
189:49 - happen silently for example if we were
189:51 - to put a log over here inside after our
189:54 - exception just say something and we're
189:55 - going to see how this log does not run
189:57 - and if that one does not run only this
189:59 - one down here that's because this line
190:00 - is still throwing an error so it stops
190:02 - executing anything afterwards but since
190:04 - we put it inside a try catch because
190:06 - that as soon as the error happens
190:07 - basally it's going to drop into after
190:09 - the try but like I said usually you want
190:11 - to handle exceptions now we only just
190:12 - ignore them so for that over here on the
190:15 - catch block we can add some parentheses
190:17 - and we can put some kind of exception
190:18 - type for a general catchall you can just
190:21 - use the exception type then give it some
190:23 - kind of name like exception and now
190:25 - inside of this object over here we have
190:28 - a ton of data related to that exception
190:30 - we can see the message the stack tray
190:31 - the source and so on so for example over
190:33 - here let's do a console. right line
190:36 - let's print out the exception. message
190:39 - and then let's also print out the
190:40 - exception let's say these stack TR okay
190:42 - let's see and if there it is that one
190:44 - did find an exception so attempted to
190:46 - divide by zero and found in our program
190:48 - on line 19 which Yip it is exactly that
190:50 - one so yep with this we are catching our
190:52 - exception and you can also add multiple
190:54 - catches you can have different ones to
190:56 - test for specific types like for example
190:58 - let's set another catch and for this one
191:00 - Let's test for the specific divide by
191:02 - zero exception except one important
191:04 - thing about having multiple catches is
191:06 - how it's going to go from top to bottom
191:08 - and since every exception always extends
191:10 - from exception this one is always going
191:12 - to run first so this one is never going
191:13 - to run so let's put the specific one
191:16 - before the generic one and another thing
191:18 - if we don't need any data inside of our
191:20 - exception itself if we just want to test
191:22 - out what type happened if so then we
191:24 - don't need to give it any kind of value
191:25 - so just like this it's going to work
191:27 - it's going to catch an exception of this
191:29 - specific type so let's do a consant do
191:31 - right line let's print out our divide by
191:33 - zero exception okay let's see and it
191:35 - picks on like that so we have our divide
191:37 - by zero exception and then the code
191:38 - continues running downwards okay great
191:41 - also another thing you can add is after
191:43 - the exception you can add the when
191:45 - keyword and over here we can test for
191:47 - for some kind of condition so for
191:48 - example when exception is of type divide
191:52 - by zero exception so if we do this then
191:54 - yep same thing this code is going to run
191:55 - pretty much the same thing as this one
191:57 - so it gets an exception stores it in
191:59 - here and tests out if it is this type
192:00 - and if so it's going to run this one so
192:02 - here we have a try and then a catch but
192:05 - there's yet another block that we can
192:06 - add and that one is the finally you add
192:09 - this one after the catch and basically
192:11 - over here the code inside this this code
192:12 - will always run so let's do a console.
192:15 - right line and let's say final
192:17 - and for example up here let's make sure
192:19 - it doesn't go inside of this catch so
192:21 - let's put when exception let's make it
192:24 - of a type that isn't going to happen so
192:25 - let's say for example the argument out
192:27 - of range exception okay like this so
192:29 - this one is not going to run but we're
192:30 - going to see how the finally is still
192:32 - going to run so the finally always runs
192:34 - no matter what so like this if we run
192:36 - yep we do cash our exception then the
192:37 - finally runs and then the hello there so
192:39 - now you might be think that the finally
192:41 - works is only the same thing as down
192:42 - here so we could just put this in here
192:43 - and it would work but one difference is
192:45 - on the finally over here when we can
192:47 - exception let's say for example we want
192:49 - to end this function so we call return
192:51 - and let's see what this does any we call
192:53 - return meaning this function is going to
192:54 - terminate so it is not going to continue
192:56 - running afterwards however even though
192:57 - we are returning even though we still
192:59 - get the final message so this finally
193:01 - block runs after the catch every single
193:04 - time so usually the finally code block
193:06 - this one can be really useful if you
193:08 - need to do some kind of cleanup code for
193:10 - example if over here on the try you were
193:11 - opening up some file for reading you
193:13 - want to make sure that if you do open up
193:15 - the file even if there is any kind of
193:16 - VAR you want to make sure you do clean
193:18 - it up also by the way you don't need to
193:19 - add the catch so you can just do a try
193:22 - finally and Yep this also works okay so
193:24 - this is how we can catch exceptions now
193:26 - to throw them ourselves we can also do
193:28 - that for example let's say we have our
193:30 - custom class for our player and then
193:32 - over here in the player Constructor and
193:34 - then let's make a test function and on
193:36 - this function we want to spawn some kind
193:38 - of exception so the way we throw an
193:40 - exception is with a keyword throw and
193:42 - then whatever exception we want like for
193:44 - example let's just throw a regular
193:45 - exception so just like this and for this
193:47 - one you can open it up just like this so
193:49 - just make a regular empty exception or
193:51 - it can give some kind of message so for
193:53 - example player exception okay so yep
193:56 - just like this so now up here let's
193:57 - remove our previous testing code and now
194:00 - let's create a new player and go inside
194:02 - the player and call test function okay
194:03 - let's see and if there it is that one
194:05 - did fire off a player exception so if
194:07 - you want to throw your own exceptions in
194:09 - your own code this how you do it just
194:10 - use the throw keyword and then you can
194:12 - even make your own exception type for
194:14 - example let's make a class let's call it
194:16 - in valid player name exception the Only
194:19 - Rule is that we need to extend from
194:21 - exception so just like this and now over
194:23 - here instead of spawning a general
194:25 - exception we can do our regular one so
194:27 - just like this let's run our code and if
194:29 - there is exactly like that so exception
194:31 - of type and of our type invalid player
194:33 - name exception also one more thing is
194:35 - for example over here if we do a try
194:37 - catch sometimes you might be running
194:38 - this inside some kind of function and
194:40 - that function might be calling some
194:41 - other function that might throw an
194:42 - exception so essentially you've got
194:44 - functions within functions and sometimes
194:46 - you want to basically just keep throwing
194:47 - the exception all the way up the call
194:48 - chain so if you want to do that you can
194:50 - just call throw just like this and this
194:53 - basally going to rethrow the exact same
194:55 - exception and if there is in this case
194:56 - since we are throwing once again on the
194:58 - main then we end up with a regular
195:00 - exception so by using the try catch to
195:02 - handle exceptions you can make your code
195:03 - a lot more robust for example when
195:05 - making a game you really never want the
195:06 - game to crash if something goes wrong
195:08 - like for example the player somehow has
195:10 - zero items and CA a divide by zero
195:12 - exception if that happens you really
195:14 - don't want the code to break you don't
195:15 - want the game to crash so if that
195:17 - happens you probably want to have that
195:18 - in some kind of TR catch Block in order
195:20 - to catch the exception and handle it in
195:22 - some kind of graceful way and especially
195:24 - when working with some external code
195:26 - like for example contacting some API on
195:27 - some web server for those you really
195:29 - want to add try and catch in order to
195:31 - make sure that your program continues
195:33 - running correctly regardless of what the
195:34 - server
195:35 - applies hello and welcome I'm your KMI
195:38 - in this lecture we're going to learn
195:40 - about enumerators how to implement I
195:42 - enumerable and I enumerator okay so
195:44 - something we've already seen several
195:45 - times is doing a simple for each on a
195:47 - list so we can do a list of in some kind
195:50 - of int list then we just construct a
195:52 - list and we can do a for each in I in
195:55 - the int list and Yep this works
195:56 - perfectly so we can do a four each and
195:58 - cycle through every element in our list
196:00 - but then if we try doing a four each on
196:02 - some kind of custom type so for example
196:04 - here let's make a player new player and
196:07 - then let's try doing a for each on this
196:08 - player and hope this does not work we
196:10 - have an error like it says here the for
196:12 - each statement cannot operate on
196:14 - variables of this type because player
196:16 - does not contain an extension definition
196:18 - for get enumerator in order to make the
196:20 - four each work with custom types for
196:22 - that we need to make our custom types
196:23 - enumerable so let's learn how to do that
196:25 - for example let's define a class for
196:27 - holding a single stat so some kind of
196:29 - name and value so just name it stat and
196:32 - inside just have a string name and just
196:34 - an in for value and then let's make a
196:37 - class to hold a bunch of player stats so
196:39 - class called player stats and over here
196:42 - for example let's have some fields of
196:43 - type stat let's say for Dex for strength
196:47 - wisdom and so on so yep just like this
196:49 - let's just construct these objects okay
196:52 - so yep just like this and now let's say
196:54 - that we want to do a for each and we
196:56 - want the for each to work on our player
196:57 - stats so basically we want to be able to
196:59 - cycle through each one of these stats
197:01 - individually so to do that the first
197:03 - thing we need to do is over here let's
197:04 - Implement an interface let's implement
197:06 - the I inumerable this one takes in a
197:09 - generic so let's say our generic type is
197:11 - going to be of type stat yep just like
197:14 - this so now we can implement this
197:15 - interface so it require us to implement
197:17 - those two functions this requires us to
197:19 - do something that constructs an object
197:21 - of type I in numerator so inumerable and
197:24 - numerator those sound similar but they
197:26 - are different so let's make a class that
197:28 - is going to be our enumerator usually
197:30 - for that we build it as a nested class
197:32 - so here let's make that so the player
197:34 - stat enumerator and we're going to
197:36 - implement I enumerator and again also of
197:39 - type stat then let's see what we need to
197:41 - implement on this one so over here let's
197:43 - select and then over here on this little
197:45 - light bulb let's implement this inter
197:46 - interface save there you go now we need
197:48 - to implement all of these and over here
197:50 - we just need to handle some kind of
197:51 - index and based on the index we're going
197:53 - to return either of these ones so that
197:55 - means we also need a reference to our
197:57 - player stats object so let's make a
197:59 - Constructor here and on the Constructor
198:01 - let's receive our player stats so you
198:04 - have this let's store it inside so just
198:07 - like this we have our player stats and
198:08 - then we also need some kind of index in
198:10 - order to know the move next the current
198:11 - and so on so let's do an in for the
198:14 - index and for the index let's default it
198:16 - to minus one the reason for that is
198:18 - because the four each is going to call
198:19 - the move next before it grabs the
198:21 - current so let's start off at minus one
198:23 - and then on the move next that's pretty
198:24 - simple so let's just do index Plus+ then
198:27 - since we have just three stats so this
198:29 - one is going to be index zero one and
198:31 - two because that over here if the index
198:34 - is bigger than two if so let's just look
198:36 - back to minus one then this one needs to
198:39 - return true if the enumerator was
198:40 - successfully Advanced and false if it
198:42 - has passed the end the collection so we
198:44 - can just return if the index is not
198:47 - minus one okay that's our move next
198:49 - function to dispose we don't really need
198:51 - to implement that one and the reset we
198:53 - can just set the index to minus one so
198:55 - what's important is over here the
198:56 - current this one is a property so let's
198:59 - go ahead and implement this property
199:00 - this one is going to have a get and on
199:02 - the get we're simply going to test out
199:04 - our index so let's do a switch on our
199:07 - index let's add a default and let's add
199:09 - a k Zer so k0 let's return go inside the
199:12 - player stats and on index zero let's
199:15 - return for example let's go go up here
199:17 - let's see so the first one is Dex then
199:19 - case one and two for this one let's
199:21 - return strength and this one let's
199:22 - return wisdom okay so yep so that's a
199:24 - current and over here for this other
199:26 - current we can just do a pass through
199:28 - onto that one just like this so Yep this
199:31 - is our enumerator class so we receive
199:33 - our player set so we have the original
199:35 - object we have some kind of index then
199:37 - on move next we just increase the index
199:39 - and on current we just grab the value
199:41 - based on that index so now here on the
199:44 - get numerator we only just need to
199:46 - return a new player stats enumerator
199:48 - object and on that one we need to pass
199:50 - in this so just like this and on this
199:52 - one again same thing we can do a pass
199:54 - through function so return get En
199:56 - numerator okay so now finally up here we
199:58 - can construct let's construct an object
200:01 - of this type of our player stats let's
200:04 - construct a brand new object and now yep
200:06 - now we can do a for each on that one
200:08 - this one is going to return a type stat
200:10 - stat in our player stat let's just see
200:12 - conso the right line on our stat and
200:15 - just to be able to see that let's inside
200:17 - our stat so inside this one and let's
200:19 - just override our two string and let's
200:22 - return the name and then the value okay
200:25 - so just like this let's test and see if
200:27 - our 4 each is working and if it's going
200:29 - to go through all of our various stats
200:31 - and if there is Exel like that so it did
200:33 - a 4 each through our custom type it
200:34 - found dexterity strength and wisdom all
200:36 - right awesome so this is how you make
200:38 - your custom types work with a 4 each you
200:41 - just need to implement both of these
200:43 - interfaces just do that do some basic
200:45 - logic in order to grab the current value
200:47 - and with that you can then use your
200:49 - custom types inside a for each by the
200:51 - way alternatively for this specific use
200:53 - case where we have a fixed number of
200:54 - elements that we want to cycle through
200:56 - for this a simpler approach is just on
200:58 - the enumerator we can just do a yield
201:01 - return so over here on the function to
201:03 - get the enumerator instead of creating a
201:04 - brand new enumerator instead of defining
201:06 - this entire class and creating all that
201:08 - if we just have a fixed number of
201:10 - elements we can type in the keyword
201:11 - yield yield return and then whatever
201:14 - we're going to return so let's say
201:16 - return that X then do another yield
201:18 - return for strength and another one for
201:20 - wisdom basically what this is going to
201:22 - do is this function is actually going to
201:23 - be called multiple times so by making
201:25 - something a numerator and using yield
201:28 - return by doing that this function is
201:30 - essentially going to store its state so
201:31 - the first time that we call this it is
201:33 - going to return Dex the second time we
201:35 - call it is going to return strength and
201:37 - the third time we call this it is going
201:38 - to return wisdom let's test this and if
201:41 - it works exactly the same we have our
201:42 - three stats so basically whenever you
201:44 - have a dynamic number of elements so if
201:47 - inside your custom type you have some
201:48 - kind of list some kind of collection for
201:50 - that you can define an entire enumerator
201:52 - and write all of this code but when you
201:54 - have just a fixed number just a bunch of
201:56 - simple stats a bunch of simple elements
201:58 - for that just using a simple yeld return
202:00 - this one is much easier also since we're
202:02 - on the topic of I numerator and I
202:04 - numerable let me mention one Unity
202:05 - specific thing which are Cod routines if
202:08 - you're just using C without Unity then
202:10 - don't worry about this part but Unity
202:12 - basically has co- routines which is a
202:13 - way to run logic across multiple frames
202:15 - and specifically it works with I in
202:17 - numerator in order to make a co- routine
202:19 - we make a function that returns I in
202:22 - numerator and then over here you can do
202:24 - whatever logic you want then when you
202:26 - want to split the logic you can do yield
202:28 - return and then Unity actually has some
202:30 - nice built-in functions like for example
202:32 - we can do yield return wait for end of
202:34 - frame this basically going to wait for
202:36 - the end of frame before running the code
202:38 - down here or for example we have wait
202:41 - for seconds this is going to wait for a
202:43 - bunch of seconds before continuing to
202:45 - execute the code for let's wait for 3
202:47 - seconds then let's do a debug. log and
202:50 - say something so let's do debug. log
202:53 - before and after okay so this is going
202:55 - to basically run some code after some
202:57 - time so this is a great way to handle
202:59 - timing based logic in your games with
203:01 - this we have a code routine and now to
203:03 - start we just need to be working inside
203:05 - a monob behavior class and of course
203:07 - this script needs to be attached to a
203:08 - game object so then we do this and let's
203:11 - make a start and over here on start we
203:12 - just need to call the function start Co
203:14 - routine and this one takes our I
203:17 - enumerator so let's just call my code
203:18 - routine just like this yep so this is
203:21 - going to start running this code routine
203:23 - so we should be able to see this log
203:24 - immediately then wait 3 seconds and then
203:26 - see this log okay it's running there's
203:28 - the first message and after 3 seconds we
203:30 - should be able to see yep there it is
203:32 - the second message all right awesome so
203:35 - these are Co routines which is a Unity
203:36 - specific thing that works with I
203:38 - numerator now personally I must say I'm
203:40 - not a big fan of Co routines simply
203:42 - because I don't like this pattern that
203:44 - they force you to use it feels needless
203:46 - ly convoluted to me you need to be
203:48 - working on a mon Behavior you need to
203:49 - call start Cod routine you need to make
203:51 - a special function that returns aerator
203:53 - use yield return and so on so personally
203:55 - I'm not a big fan of this huge pattern
203:57 - personally I prefer using super simple
203:59 - FL timers but Coe routines work great so
204:02 - you you like this then definitely go
204:03 - ahead and use them okay so those are
204:05 - enumerators it's how you can make your
204:07 - custom types work inside a 4 in and
204:09 - various other settling Logic for example
204:11 - things like link which we're going to
204:12 - cover later on in the advance
204:14 - section hello and welcome I'm your Cod
204:16 - mon in this lecture we're going to learn
204:18 - about namespaces in C okay so namespaces
204:21 - this is one of the main ways you have of
204:23 - organizing your code think of it kind of
204:25 - like folders for your code for example
204:27 - you would have some kind of folder for
204:28 - your game logic another one for some a
204:30 - logic another for the UI and so on
204:32 - basically it helps you keep things
204:34 - organized and actually we've already
204:35 - been using a bunch of namespaces up here
204:38 - all of these using statements these are
204:39 - all namespaces for example the console
204:41 - class that we've been using this one
204:43 - exists inside of the system namespace we
204:45 - can access it by writing using system up
204:47 - here and then we can access the console
204:48 - class although actually when making a
204:50 - console app the system names space is
204:52 - included automatically so technically
204:53 - you don't need to explicitly Define it
204:55 - but in most case you do need it so you
204:57 - do need to add using some kind of
204:58 - namespace and also over here on this
205:00 - template when we create the brand new
205:02 - project it automatically created our
205:04 - program class with our main function and
205:06 - it put it all inside a namespace now I
205:08 - should say technically you don't need to
205:09 - have a namespace so if I get rid of this
205:11 - and this Yep this still works this is
205:13 - perfectly valid code basically when it
205:14 - compiles it will simply place this class
205:16 - in the root namespace to create a
205:18 - namespace you really just follow this
205:20 - symbol syntax so you write the keyword
205:21 - namespace and then whatever you want to
205:23 - name your namespace also namespaces they
205:25 - can have nested namespaces for example
205:27 - inside the system namespace there's a
205:29 - whole bunch of stuff like for example
205:31 - the IO namespace this is the one that
205:33 - contains a bunch of classes related to
205:34 - input and output and so on then here is
205:37 - a script inside of unity so Unity
205:39 - normally has most their things inside
205:41 - the unity engine namespace for example
205:43 - mono Behavior this one exists inside of
205:44 - unity engine then if you want to do
205:46 - things inside the UI then you would use
205:48 - using unityengine.ui so basically all
205:51 - the classes are nicely organized in
205:53 - namespace that makes sense for them you
205:54 - can also make nesson namespace yourself
205:57 - you can just write some kind of name
205:58 - then add dot then add another name and
206:00 - so on then one big benefit of name
206:03 - spaces is avoiding name conflicts for
206:05 - example let's say I want to define a
206:07 - player class and now let's say I want to
206:09 - define a completely separate class but I
206:11 - really do want it to have also the same
206:13 - name so also another player class since
206:15 - classes have to be unique this does not
206:17 - work here we have an error that it says
206:19 - that this Nam space already contains the
206:20 - definition for our class named player
206:22 - and right way this is also giving us a
206:24 - hint as to what the solution to this
206:25 - problem is the solution is simply put it
206:27 - in another namespace so namespace I can
206:30 - give it whatever name I want then I can
206:32 - place this class inside of that
206:33 - namespace and up here I can use either
206:35 - of them so I can use player and this one
206:37 - is referencing this one down here this
206:39 - one inside of this namespace or I can go
206:41 - inside the code monke namespace access
206:43 - player and up with this now I'm
206:44 - referencing the other one in the other
206:46 - name space the another common issue is
206:48 - sometimes you have a conflict that the
206:50 - compiler cannot resolve for example over
206:52 - here I added using system and using
206:54 - Unity engine and now I want to use the
206:56 - random class but the problem is that
206:58 - there is a random class in both Unity
207:00 - engine and inside of system so the two
207:02 - name space that I'm using up here they
207:04 - both have a class with the exact same
207:05 - name so basically the compiler over here
207:07 - does not know which class I'm referring
207:09 - to so to solve this problem either we
207:10 - get rid of one of the using statements
207:13 - and Yep this works so now there's no
207:14 - more errors however that won't probably
207:16 - break any other place where you're using
207:17 - classes from that namespace so in this
207:20 - case for example if I add the
207:22 - serializable attribute which exists
207:23 - inside of system by solving this problem
207:25 - I now cause this problem so to solve
207:27 - these kinds of naming collisions usually
207:29 - the simplest thing is to just write the
207:30 - full name so for example up here on this
207:32 - one I can write system and even now this
207:35 - one works and this one has no problem or
207:36 - alternatively I can just add the using
207:39 - system up here so this one no longer has
207:41 - an error but this one does have the
207:42 - error and over here I can just write the
207:45 - full name Unity engine not random and
207:47 - yep like this compiler doesn't have any
207:49 - questions it knows that I'm trying to
207:50 - use the random class that exists inside
207:52 - Unity engine another thing you can do
207:54 - with Nam spaces is simply using an alias
207:57 - so over here we can say using then give
207:59 - it some kind of name like Unity random
208:01 - and then say equals Unity engine. random
208:04 - so basically this one is now an alias to
208:06 - this so down here instead of using all
208:09 - this we can use this and if there you go
208:11 - it does work this can be quite useful
208:13 - when you have a really complex project
208:14 - with some super long names when that
208:16 - happens using the Alias can really help
208:18 - simplify your code okay so that's
208:20 - namespaces it's a simple yet very useful
208:22 - C feature as your project grows more and
208:25 - more they become more and more
208:27 - useful hello and welcome I'm your Cod
208:29 - monkey in this lecture we're going to
208:31 - learn about the Singleton pattern in
208:32 - terms of game development this is
208:34 - probably the most useful pattern and
208:35 - also one with a lot of pros and some
208:37 - cons so let's learn about it okay so the
208:39 - Singleton like name implies we have just
208:41 - a single instance of something in this
208:43 - case we have a single instance of some
208:44 - kind of class so for example we have
208:46 - some kind of game manager class and over
208:49 - here the way that we have just a single
208:51 - instance is usually with some kind of
208:52 - static field again static means that the
208:54 - field belongs to the class itself and
208:56 - not any instance of that class so
208:58 - usually we make it private static let's
209:01 - call it of game manager and for the name
209:03 - we call it instance instance is usually
209:05 - a common name used for Singleton
209:07 - although sometimes it's literally named
209:08 - Singleton so either one so here we have
209:11 - our private field and we made this
209:13 - private specifically for one very good
209:14 - reason the reason is because this class
209:16 - should be the only one that is
209:18 - responsible for creating the Singleton
209:19 - instance other classes should only be
209:21 - able to get it so the way that we're
209:23 - going to expose this is by using a
209:25 - public property so let's make one also
209:27 - going to return typ game manager and
209:29 - property usually starts by pass case so
209:31 - you've got our property instance and
209:33 - over here on the get on the get we just
209:35 - return our instance and then for the set
209:37 - for this one again like I said the
209:39 - instance should only be set by this one
209:41 - so for that one let's make a private set
209:43 - and on private set just set instance
209:44 - equals value okay okay yep so just like
209:47 - this basically here we have a field that
209:49 - anyone can access but only this class
209:51 - can set now for actually creating this
209:53 - Singleton let's first cover the barebone
209:55 - C method and then I'll cover the unity
209:57 - specific method so Singleton usually
209:59 - have what is called Las intiation this
210:02 - means that the instance is created only
210:03 - when it's needed for the first time and
210:05 - in order to do that we just put that
210:07 - logic over here on the get we just check
210:09 - if our current instance it is null if so
210:11 - that means we have no instance and if so
210:14 - then we just create a brand new one so
210:15 - we create and then we return it so
210:17 - basically this means that as our program
210:18 - starts there will be no single T
210:20 - instance and then the very first time
210:22 - that we use it it will actually create
210:23 - that Singleton also as a general rule
210:25 - Singleton usually have private
210:27 - Constructors so if you define some kind
210:29 - of Constructor it's going to be private
210:31 - that way any code up here cannot do new
210:33 - game manager nope this does not work
210:34 - because the Constructor is private again
210:36 - that's because the singl ton is meant to
210:38 - be the one that is responsible for
210:39 - creating the Singleton instance so the
210:41 - way that we use this is actually very
210:42 - simple alternatively another way of
210:44 - implementing the Singleton pattern is
210:46 - without Las intiation so an alternative
210:48 - would be to expose the Constructor and
210:51 - then just check if the instance if it is
210:53 - null if so set the instance to this so
210:55 - this is another way that the single
210:56 - pattern could be implemented but again
210:58 - usually you have some kind of private
211:00 - Constructor that only this one calls and
211:02 - over here we don't even need any kind of
211:04 - set because only that one is going to be
211:05 - set so this is the basic C Singleton
211:07 - pattern and now in order to use it it's
211:09 - actually real simple we just access the
211:11 - static property so we just go inside the
211:12 - game manager access the instance just
211:14 - like this so let's do a console the
211:16 - right line and now we didn't create any
211:19 - kind of game manager object up here this
211:20 - code is not creating anything does not
211:22 - know anything about any of that it just
211:24 - knows that it's accessing the game
211:25 - manager accessing the static instance
211:27 - that's it so if we test this and if
211:28 - there it is then we do have an objective
211:30 - type game manager so just by accessing
211:32 - the static instance it automatically
211:34 - created that object and return that
211:35 - instance then over here we can do
211:36 - whatever we want so for example some
211:38 - kind of public test function so we have
211:40 - some kind of function that does
211:41 - something and then up here in our code
211:43 - we can go inside the game manager we can
211:46 - access the static instance we can call
211:48 - test function and Yep this will indeed
211:49 - work also by the way note how just one
211:51 - instance is created so up here we are
211:53 - accessing one instance in here and then
211:55 - going through this one to calling the
211:56 - test function so we're accessing this
211:58 - property twice but when this code runs
212:00 - obviously since instance is only going
212:02 - to be null just once it is only going to
212:03 - create one game manager so no matter how
212:05 - many times we call this we end up with
212:07 - just one single instance and since we
212:09 - made the Constructor private because
212:11 - that nothing else can construct this
212:12 - object so we know for a fact that this
212:14 - class will only have a single instance
212:16 - making this the Singleton pattern as for
212:18 - the benefit of it the benefit is that
212:20 - it's really super simple to use just by
212:22 - accessing the class itself and accessing
212:23 - some static instance just through this
212:25 - we have a reference to whatever object
212:27 - we have of type game manager so we can
212:29 - call functions on this class we can do
212:30 - any kind of thing we don't need to keep
212:32 - track of any kind of game manager
212:34 - reference so for example if we had some
212:36 - kind of class of type player and then
212:38 - the player does something it like adds
212:41 - some kind of score so the player would
212:43 - end up killing some enemy or something
212:44 - over here the player does not need to
212:46 - store a direct reference to the game
212:47 - manager we can just go inside game
212:48 - manager access static incense and then
212:50 - we would call some kind of AD score
212:52 - function by using the single we have our
212:54 - instance of the game manager really
212:56 - easily accessible from pretty much
212:57 - anywhere in our code base and now that
212:59 - we've seen the single over here the
213:01 - barebone C Singleton let's see how to
213:03 - make it in unity in unity it's a little
213:05 - bit different since Unity components
213:07 - have to extend mon behavior and one of
213:08 - the biggest limitations of that is you
213:10 - cannot access the Constructor directly
213:12 - so in unity you simply make a regular
213:14 - script extend mod Behavior as usual then
213:17 - that script is attached to some kind of
213:18 - game object so all pre standard and over
213:20 - here in the code here personally this is
213:22 - the only scenario where I use properties
213:24 - and here I don't even use the backing
213:26 - field directly I use the auto
213:28 - implemented property so I make it public
213:30 - because I want to have a public yet
213:32 - let's make it static of type game
213:34 - manager let's call it instance and then
213:36 - this one has a public yet and a private
213:38 - set so yep just like this so this field
213:41 - has the perfect accessibility that I
213:42 - want for the Singleton so any class can
213:44 - get it but only this class can set it
213:46 - and then on the unity's standard awake
213:48 - function over here on this one just set
213:50 - instance equals this and yep that's
213:52 - really it the awake is going to run when
213:53 - this game object runs and when that
213:55 - happens it is going to assign the
213:56 - instance into this now this one
213:58 - technically isn't enforcing the
213:59 - Singleton rule if over here in unity I
214:02 - duplicate this object multiple times
214:03 - then I'm going to end up with multiple
214:05 - game managers and the one that is going
214:06 - to be set on that static instance is
214:08 - going to be whatever is the last one
214:09 - that runs so for this problem normally
214:12 - the only thing I do is I'm really just
214:13 - careful enough to only make one object
214:15 - object that has the static script that I
214:17 - want but if you want you can also add
214:18 - some proper safety checks one way to do
214:20 - it is over here before assigning the
214:22 - instance we check if instance is not
214:24 - known if so that means that this script
214:26 - already exists and the instance has
214:27 - already been assigned if so this should
214:29 - not happen so over here we can probably
214:31 - just fire off a log error so if over
214:33 - here I duplicate this object and I try
214:35 - running if there it is we have a log
214:37 - error and tells us what the issue is we
214:38 - can see it's on the game manager class
214:40 - then you can either manually fix this so
214:42 - go into the hierar key and delete the
214:43 - second one or over here on the script
214:45 - itself we can destroy this game object
214:46 - to make sure only one is kept alive so
214:48 - for example instead of that let's just
214:50 - destroy this game object and then call
214:52 - return so the rest of the code does not
214:53 - work so if we run this and if there it
214:55 - is we have our error because we do still
214:58 - have two game managers however if we
214:59 - only in the hierarchy yep the second one
215:01 - was inde the destroyed now this
215:02 - Singleton pattern is extremely useful
215:04 - when you have some kind of class of
215:06 - which there is only meant to ever exist
215:07 - just one single instance of that class
215:09 - for example in games it is very common
215:11 - to have some kind of General game
215:12 - manager and again you have just one
215:14 - usually you also have some some kind of
215:16 - audio manager some kind of input manager
215:17 - and so on then for single play games you
215:20 - might just have one player or even just
215:21 - one world so if you have just one of
215:23 - something then the single pattern is
215:25 - actually really great it makes a lot of
215:27 - sense and makes it really easy to access
215:28 - that static instance for example if your
215:30 - UI code wants to show the player's
215:32 - Health it doesn't need to have a direct
215:33 - reference to the player it can just grab
215:35 - the Singleton reference or if your
215:37 - player needs some kind of input it
215:38 - doesn't need a reference to the input
215:40 - manager it just access the static
215:42 - instance and that's it so the single T
215:44 - is great especially in game development
215:45 - where you normally have tons of systems
215:47 - that have a single instance however the
215:49 - Singleton pattern also has some
215:50 - potential problems if you Google you
215:52 - will find a lot of people arguing that
215:54 - this is a terrible pattern although I
215:55 - should say usually those anti- Singleton
215:57 - comments are always a little bit too
215:59 - extreme the Singleton is a tool and just
216:01 - like any tool it can be used or abused
216:04 - and in general Singleton seems to be
216:06 - worse for regular game development not
216:08 - game development for game development
216:09 - like I said it does have a ton of
216:11 - benefits that do outweigh many of the
216:13 - possible cons and in general if you
216:14 - write some good code you can actually
216:16 - minimize a lot of those cons like the
216:18 - main con is simply the fact that
216:19 - Singleton are by definition global data
216:21 - the whole purpose of Singleton is to
216:23 - have a single instance of something that
216:25 - you can easily access from anywhere so
216:27 - because that it means that it can have
216:28 - many of the negatives that any kind of
216:30 - global data can have your code can
216:32 - easily become really messy way tons and
216:34 - tons of connections between various
216:35 - classes since Singletons are so easy to
216:37 - use you might be inclined to use them
216:39 - all the time and make it so that every
216:41 - class pretty much depends on a ton of
216:42 - singl ton classes doing so ends up with
216:45 - a massive dependencies ideally your code
216:47 - in your classes should be as decoupled
216:49 - as possible you shouldn't have a ton of
216:50 - connections this advice is applicable
216:52 - really all the time not just in relation
216:54 - to singl tense but single tense May
216:56 - violating this guideline very easy so
216:58 - that is why you need to be extra careful
216:59 - and because those issues of classes
217:01 - becoming coupled with tons more classes
217:03 - because that testing can become insanely
217:05 - hard simp because in order to test
217:07 - something if the class you're testing
217:09 - accesses some kind of single T then that
217:11 - single T needs to be created in order to
217:12 - test and in turn maybe that single T
217:14 - then uses yet another Singleton and on
217:16 - and on so you might end up requiring a
217:18 - ton of setup to do even just a basic
217:20 - barebones test another more serious
217:22 - problem is with regards to multi-thread
217:23 - code you need to be very careful to make
217:25 - your Singleton thread safe or simply
217:27 - make sure you only access singl ton from
217:29 - the main thread for example if you use
217:31 - Unity dots to write some super
217:33 - performant multi-thread code the simple
217:35 - way to avoid this problem is to do all
217:36 - your logic in tons of threads then at
217:38 - the end after all those jobs are
217:39 - completed then you do anything that
217:41 - requires a main thread like for example
217:43 - accessing The Sound Manager single T to
217:45 - play some s a sound effect so Singleton
217:47 - can indeed do have some negatives but
217:49 - they're also extremely powerful and
217:50 - extremely useful it is a pattern that
217:52 - can be very good in used but also very
217:54 - easy to abuse personally I use a ton of
217:56 - Singleton in all my games I just also
217:58 - make sure not to abuse that pattern I
218:00 - make sure to control how often I use
218:02 - them and limit class coupling as much as
218:04 - possible so my advice is don't be afraid
218:06 - of Singletons they definitely have their
218:07 - place but use them properly so they
218:09 - actually help you as opposed to hurt you
218:11 - now the Singleton pattern is just one of
218:13 - many programming patterns it is the one
218:15 - that I use most often and I find most
218:16 - useful so I made this static in lecture
218:18 - now next one let's go through a bunch of
218:20 - other patterns that also have their use
218:22 - case hello and welcome I'm your Cod Maki
218:25 - in this lecture we're going to talk
218:26 - about a bunch of design patterns okay so
218:28 - first of all what are design patterns in
218:30 - the last lecture we already covered one
218:32 - specific design pattern the Singleton
218:34 - these are basically some general
218:36 - reusable solutions to some common
218:37 - programming problems the Wikipedia page
218:39 - has a great reference with tons and tons
218:41 - of detail for example the Singleton
218:43 - pattern that we just saw this one one is
218:45 - a nice solution for the problem of how
218:47 - do you ensure a class is only one
218:48 - instance and how do you ensure that it
218:50 - has a global point that is easily
218:52 - accessible that's the entire purpose
218:53 - behind that pattern and by writing the
218:55 - code like we saw in the previous lecture
218:57 - that is how we can achieve those rules
218:58 - so that is a very good solution to that
219:00 - common problem and within that pattern
219:02 - we also saw another mini pattern the
219:04 - lazy initialization so this is how we
219:06 - made sure that the single T only gets
219:07 - created the first time that it's
219:08 - actually needed another pattern we've
219:10 - actually already seen is the Observer
219:12 - pattern this is a pattern where an
219:14 - observer interacts with a subject to be
219:16 - notified whenever something happens so
219:17 - Yep this is literally what we already
219:19 - covered in the events lecture a class
219:21 - subscribes to an event and again gets
219:23 - notified when that event is fired so
219:24 - using events is essentially The Observer
219:26 - pattern another common one is the
219:28 - command pattern with this one you can
219:30 - basically create commands that can be
219:31 - executed later on so one common use case
219:34 - for this kind of pattern is making some
219:35 - kind of undo system so when you do some
219:38 - kind of action you create a command for
219:39 - the undo action with all the data that
219:41 - is needed to perform that undo and then
219:43 - when you want to undo it simply runs
219:45 - that command so this is the kind of
219:46 - thing that can easily be built by
219:48 - combining a stack with delegates another
219:50 - interesting one is the factory pattern
219:52 - with this one you basically put the
219:53 - creation of an object in some kind of
219:55 - factory class and then instead of having
219:57 - every class with a Constructor that
219:58 - anyone can call instead only that
220:00 - factory class is responsible for
220:01 - creating those objects again we also saw
220:03 - a part of that pattern in the Singleton
220:05 - pattern where the Singleton itself is
220:07 - responsible for creating the object so
220:08 - the factory pattern is pretty much just
220:10 - a more dedicated part of this pattern it
220:12 - can be really useful to limit the number
220:14 - of placees from which a a certain type
220:15 - of object can be created then the object
220:18 - pool pattern this is a really useful one
220:20 - this is how you can create a pool of a
220:21 - bunch of objects and in doing so it
220:23 - really reduces the impact for creating
220:25 - and destroying objects Unity actually
220:27 - recently introduced an object pool type
220:29 - that does exactly that if you have
220:31 - performance issues with spawning and
220:33 - destroying objects you should definitely
220:34 - be using some kind of pulling then
220:37 - dependency injection this is an
220:38 - excellent pattern for testing your
220:40 - programs this one uses interfaces quite
220:42 - heavily it's one of the main reasons why
220:44 - interfaces are really EXC
220:45 - you can inject different types of
220:47 - objects as long as they Implement a
220:48 - common interface then the adapter
220:50 - pattern or simply a wrapper this is
220:52 - especially great when working with some
220:54 - kind of third party code you build a
220:56 - wrapper that only contains the info you
220:58 - care about and then you don't have to
220:59 - worry about any more of the underlying
221:01 - implementation so as you can see over
221:02 - here there are tons and tons of patterns
221:04 - and pretty much all of these have
221:05 - dedicated pages so if you want to dig
221:07 - deeper I definitely encourage you to do
221:08 - so these patterns were created by some
221:10 - very smart people in order to solve some
221:12 - very common problem so rather than
221:14 - Reinventing the wheel just being
221:15 - familiar with some of these is really
221:16 - great but you really don't need to
221:18 - memorize all of these I highly encourage
221:20 - you to research them just so you know
221:21 - they exist but don't try to memorize
221:24 - everything in one go like with the
221:25 - visual studio shortcuts lecture this is
221:28 - something that you pick up more and more
221:29 - over time but definitely do take the
221:31 - time to research these in a little bit
221:33 - more like the say goes there's no point
221:34 - in Reinventing the wheel sometimes you
221:36 - have problem for which a pattern would
221:38 - be the perfect solution and if you know
221:40 - that pattern then you can simply apply
221:41 - it rather than having to reinvent a
221:43 - brand new solution now for me personally
221:44 - I don't normally just use the Singleton
221:46 - and the Observer pattern specifically I
221:48 - use those pretty much EXA like they are
221:50 - designed and then I use various other
221:52 - ones when I need them even if I don't
221:54 - necessarily follow these strict patterns
221:56 - so sometimes for example I have some
221:57 - kind of factory pattern I have that
221:59 - where some objects are created only in a
222:01 - specific place but I don't necessarily
222:03 - create a brand new specific Factory
222:05 - class then like I said sometimes I use
222:07 - something similar to the command pattern
222:10 - especially in management games to queue
222:11 - up all kinds of actions and in unity
222:13 - Unity is all made about composition of
222:15 - various scripts so technically it is the
222:17 - composite pattern and I do normally try
222:19 - to compose my complex objects usually by
222:21 - composing them based on interfaces
222:23 - rather than just making one huge object
222:25 - with all kinds of logic so I highly
222:27 - encourage you to research some design
222:28 - patterns in order to be familiar with
222:29 - them but again don't worry too much
222:31 - about memorizing them especially not all
222:32 - of them I certainly do not have
222:34 - memorized all of these patterns only a
222:36 - handful of them then as you go through
222:37 - in your Game Dev or programming career
222:39 - you'll learn which ones you will
222:40 - commonly use as you encounter similar
222:43 - problems hello and welcome I'm your Cod
222:45 - mon in this lecture we're going to see a
222:47 - nice project that incorporates
222:49 - everything we've learned so far in this
222:50 - intermediate section although actually
222:52 - we've already covered a ton of stuff and
222:54 - some of it wasn't necessary to get this
222:55 - zmo build which this is actually a great
222:58 - practical example of everything you're
222:59 - learning in this course this course is
223:01 - all about C and C has a ton of tools and
223:03 - features but that does not mean you need
223:05 - to absolutely use everything all at once
223:07 - every time the goal of all this is to
223:09 - use the things that help you achieve
223:11 - whatever goal you're trying to achieve
223:12 - so let's see the demo it's inside the UN
223:14 - project inside the lectures and down
223:16 - here at the bottom we've got the
223:17 - intermediate project so we have our game
223:20 - scene let's open it and here is the
223:22 - miname running so I've got a player
223:24 - object I can move around by pressing the
223:25 - arrow keys or was then down here I've
223:28 - got an inventory with three slots and
223:29 - there are some weapons and some items
223:31 - that I can pick up there's also some
223:33 - enemies that are spawning coming to me
223:34 - so I can approach the weapon order to
223:35 - pick it up and I can click in order to
223:37 - start shooting and start taking down
223:38 - some enemies so as I shoot they take
223:40 - some damage they get a health bar that
223:42 - goes down and updates and eventually
223:44 - they die and they spawn want a bunch of
223:45 - money then for the money it's also
223:47 - something that I can pick up so I can
223:48 - touch it and pick up all this money I
223:50 - can see the UI is updating as I pick up
223:52 - some more money and there's a bunch more
223:55 - items and objects so for example there's
223:57 - some bombs those bombs are also
223:58 - attackable so I can attack them and I
224:00 - can destroy them and then I've got the
224:02 - other weapons so I'm using a pistol and
224:04 - then I can pick up a shotgun and down
224:06 - here on the inventory yep I picked it up
224:07 - so now I can swap the shotgun and I can
224:09 - start shooting and this one has a
224:10 - different shoot so this one can now
224:12 - shoot multiple bones at once and again I
224:14 - can pick up all this money and then over
224:16 - there is also a nice little potion I can
224:18 - pick it up and again that's also another
224:20 - item it's a usable item so I can use it
224:22 - click to use it and if there you go this
224:24 - goes into some kind of super mode where
224:25 - the player is now moving much faster so
224:27 - I can move around really fast and
224:29 - eventually it ends up and I can select
224:31 - another different one so let's go back
224:32 - to the pistol let's go into that one
224:33 - speed it up back to the pistol shoot
224:35 - that one shoot that one and so on so Yep
224:38 - this is the demo with lots of stuff
224:39 - happening that involves a lot of the
224:41 - things that we've already learned about
224:43 - there's player movement there are all
224:44 - kinds of interactions there's shooting
224:46 - there's enemy there's Health there's
224:48 - damage there's an inventory a whole
224:50 - bunch of items abilities and so on so as
224:52 - you can see in lots of stuff now let's
224:54 - inspect this to see how it all works and
224:56 - how all the elements of C how all of
224:58 - them are being used although also before
225:00 - we look at the code let me make one
225:01 - quick note basically how I built this
225:03 - project is not the absolute only way to
225:05 - do this you could build this exact same
225:07 - project in a million different ways so
225:09 - as we're going through it if you think
225:11 - to yourself that you would build some
225:12 - element in a different way than I did
225:14 - that does not mean that you're wrong
225:16 - there's always many many ways to achieve
225:17 - the same result and the way that I buil
225:19 - this demo is simply just one way out of
225:20 - the millions of possible ways to build
225:22 - it so if you come up with different way
225:23 - to implement the exact same elements you
225:25 - can definitely be right as well okay so
225:27 - here in the project files we can see
225:28 - that this demo is quite a bit larger
225:30 - than the beginner demo there's quite a
225:32 - few more files that's due to the fact
225:35 - that it is larger than the beginner
225:36 - project but also due to the fact that
225:38 - the code is much more well organized
225:40 - there's plenty of small class that do
225:41 - one thing and one thing only as opposed
225:43 - to the beginner project where try to
225:45 - make it as compact as possible which
225:46 - meant putting too much Logic on the
225:48 - player class whereas over here you can
225:50 - see how each file is actually pretty
225:51 - compact you can see most of it pretty
225:53 - much just over here on the quick code
225:55 - preview most of these files are actually
225:56 - pretty small so let's begin inspecting
225:59 - this and let's actually begin with the
226:00 - most complex script of all the player
226:02 - script let's do just a quick overview of
226:04 - this one before we see everything one by
226:06 - one and right away as soon as we open
226:08 - this we can actually already see a bunch
226:09 - of things that we learned in this
226:10 - intermediate section so right away we
226:12 - can see a namespace so all of the code
226:14 - for this project all of it is inside
226:16 - this specific namespace and one of the
226:18 - benefits that I talked about namespace
226:20 - is simply the fact of name collisions
226:22 - and actually on this companion project
226:24 - note how all the code for all of the
226:26 - various lectures and all the demos all
226:27 - it is inside this one project and I do
226:29 - have a bunch of other demos that also
226:31 - have some kind of player class but
226:33 - because over here I'm using a nam space
226:34 - that makes it sure that this player
226:36 - class does not have a naming conflict
226:38 - with any of the other player class so
226:40 - that's the first thing using namespaces
226:42 - then by the way the mono Behavior over
226:43 - here here we have are seeing an instance
226:45 - of inheritance and mon behavior is
226:47 - really just a base Unity class basically
226:50 - if you want to attach any script as a
226:51 - component in unity so for example over
226:53 - here if I select the player object and I
226:55 - look in it yep it has the player script
226:57 - attached to it so in order to attach a
226:59 - script onto a game object needs to
227:00 - inherit from that class then we can also
227:02 - see over here we have the Singleton
227:04 - pattern so we've got a public static
227:05 - player instance with a public yet and a
227:07 - private set and this one the instance is
227:09 - being set over here on a wake this is a
227:11 - Unity specific function that is called
227:13 - whenever this script is initialized
227:15 - so on awake we are instantiating the
227:17 - instance onto this since this little
227:19 - demo is meant to be a single player game
227:21 - it makes perfect sense that the player
227:22 - is a singl t since there is only ever
227:23 - meant to be just one player next we can
227:26 - also see usage of a bunch of constants
227:28 - again constants are values that are
227:29 - never meant to be changed so in this
227:31 - little demo it makes perfect sense to
227:33 - use a Conant for the base movement speed
227:35 - for the damage amount and for the super
227:37 - timer Max then we can see a whole bunch
227:39 - of events we're going to see these in
227:40 - detail a little bit then we've got a
227:42 - bunch of fields and by the way the
227:44 - serial field here this syntax is
227:46 - actually an attribute this is something
227:48 - that I cover in detail in a lecture in
227:50 - the advanced section over here this
227:52 - specific attribute this is another Unity
227:54 - specific thing it is just so I can
227:56 - expose these fields over here on the
227:58 - unity inspector without having to make
228:00 - these fields public if I were to just
228:01 - make them private without this attribute
228:03 - then it would not show up in the editor
228:04 - so in order to do that and keep the code
228:06 - clean keep the fields private in order
228:08 - to do that they need to Mark the
228:09 - serialized field private okay then we
228:11 - have a bunch more Fields then we got
228:13 - some inventory logic we're to see this
228:15 - in a little bit then we've got the
228:16 - update this is another Unity specific
228:18 - function basically the code in here is
228:19 - going to run whenever the frame updates
228:22 - so if the game is running at 60 frames
228:23 - per second these functions are going to
228:25 - run 60 times per second we've got a
228:27 - function here to handle the object
228:28 - rotation so that's the logic for how
228:30 - over here the pistol is rotating to face
228:32 - wherever I'm aiming with the mouse then
228:34 - there's some code to handle the items
228:36 - I'm going to cover the inventory in a
228:37 - little bit then some code to shoot then
228:40 - we've got some standard movement code so
228:43 - just some basic IFS calculating a
228:45 - certain move vector and then just moving
228:47 - the transform alongside this move
228:49 - Direction the transform is basically the
228:51 - game object in unity then we've got the
228:53 - super and let's begin by inspecting in
228:54 - detail over here the collisions again
228:57 - this is another Unity specific function
228:59 - this one has to do with the unity
229:00 - physics system basically over here for
229:02 - all the objects that can be picked up
229:04 - like for example over here the money the
229:06 - money object over here has a little
229:07 - collider so this little box is a physics
229:10 - collider and basically as a player goes
229:12 - inside of this collider is going to
229:13 - trigger that function and and over here
229:15 - this function will be called with
229:16 - whatever object it collided with so the
229:18 - first thing we do is try to get a
229:19 - component again this another Unity
229:21 - specific function this one tries to get
229:23 - any component of a certain type that is
229:25 - attached to the same game object so
229:27 - basically as the player collides with
229:28 - this money object it is going to try to
229:29 - get some of these components and
229:31 - specifically it is looking for a
229:32 - component that implements interface I
229:34 - grab object so here we see an example of
229:36 - an interface and in this case this is an
229:38 - interface that represents any kind of
229:40 - object that can be grabbed so in this
229:42 - game that's a money that's the weapons
229:43 - that's a potion and so on
229:45 - and the interface defines a bunch of
229:46 - functions which all objects that
229:48 - implement this interface must Implement
229:50 - so one of those is of course the money
229:51 - class so this one as you can see it
229:53 - extends the mono Behavior class this is
229:55 - the base Unity class so this can be used
229:56 - as a component and then it implements
229:58 - the igrab object interface then for the
230:00 - logic over here it's pretty simple this
230:02 - is really just a movement logic so over
230:04 - here with a weapon if I shoot a zombie y
230:06 - there you go the money gets spawned and
230:07 - moves a little bit just to have a nice
230:09 - little bit of visual polish so as the
230:11 - enemy dies it spawns some money and
230:13 - moves a little bit and then stops moving
230:14 - so that's really this code in action it
230:16 - moves the transform then lowers the
230:18 - magnitude which is how big is the
230:20 - movement Direction vector and if it is
230:22 - in a certain magnitude then just
230:24 - disables the script which means this
230:25 - update function will no longer be called
230:27 - then down here it implements the
230:29 - functions for that interface so we've
230:31 - got one to destroy this object and then
230:33 - some related to inventory objects now in
230:35 - this case money is not an inventory item
230:37 - it cannot be placed in inventory so over
230:39 - here for these functions just returns
230:41 - false and null before we see the
230:42 - inventory let's actually see how the
230:44 - money is actually connect to the UI so
230:46 - over here in the UI we've got a little
230:48 - indicator to show how much money the
230:49 - player is holding so going back on the
230:51 - player script here on the on trigger
230:53 - enter over here we try to get a
230:55 - component of that interface type and
230:57 - basically if the player hits the money
230:58 - object then this is going to be true it
231:00 - is going to be able to get this grab
231:01 - object component and when it does it is
231:03 - going to fire off this event it is going
231:05 - to fire off with some custom event TS
231:07 - and basically pass along the grab object
231:09 - that was grabbed so this event is
231:11 - defined up here so just a basic event
231:13 - handler that has a custom event Ts for
231:15 - our grab object and over here actually
231:17 - something also pretty interesting which
231:19 - is how in the events you can subscribe
231:21 - to the events from anywhere meaning you
231:22 - can actually subscribe from the class
231:24 - that actually fires off that event so
231:26 - that's exactly what I'm doing here so I
231:27 - subscribe to the on player grab object
231:29 - event and then over here accessing the
231:32 - event ARS in order to get the grab
231:33 - object and doing some type checking in
231:35 - order to see if that grab object is of
231:37 - type money so this identifies what
231:39 - object I picked up and if so then it's
231:41 - going to increase the money amount this
231:42 - is just a basic integer and as it does
231:45 - it also fires off another event on money
231:46 - amount change and the one that listens
231:49 - that event is this little UI element so
231:51 - over here in the hierarchy if I go
231:53 - inside the canvas I've got this player
231:54 - UI script and yeah this one is pretty
231:56 - simple so on start which is a Unity
231:58 - function that gets called whenever this
232:00 - object is initialized so right after the
232:02 - awake so when that happens it accesses
232:05 - the player static instance again the
232:06 - singl ton which is super easy to use
232:08 - which in this case makes perfect sense
232:10 - because this is a single player game
232:11 - there's only one player so use that to
232:13 - easily access the player and then simply
232:16 - subscribes to the event on money amount
232:17 - changed and when that happens it simply
232:19 - calls the function in order to update
232:20 - the text so it just goes inside the
232:22 - player static instance again accessing
232:24 - the Singleton calling a function to get
232:26 - the money amount that the player is
232:27 - currently holding and just passing that
232:29 - on into string in order to update the
232:30 - text this right here is a great example
232:32 - of one of the main purposes of events it
232:35 - allows you to keep your code decoupled
232:36 - and specifically in games it allows you
232:38 - to decouple your logic from your UI
232:40 - elements note how over here on the
232:42 - player class this one has no Direct
232:44 - connection to any UI class it does not
232:47 - know and does not care if there is any
232:48 - UI listening to any kind of money amount
232:50 - or anything meaning this player class is
232:52 - completely decoupled from this UI class
232:54 - which does display the money so if I'm
232:57 - playing the game and I pick up some
232:58 - money yep the UI up there is indeed
233:00 - updating it works great however if I go
233:03 - there and I disable the player UI game
233:05 - object so this script is no longer
233:06 - running but despite that there are no
233:08 - errors because again the player UI that
233:10 - one depends on the logic class but the
233:12 - logic class does not depend on the UI
233:13 - class meaning that the player can exist
233:16 - without or with any y it does not matter
233:18 - it works either way that is really one
233:20 - of the main powers of events it is how
233:22 - it helps you make your code much more
233:24 - decoupled so things can exist without
233:26 - other things now let's look at how the
233:28 - inventory over here works so this one
233:30 - also has a nice content for our capacity
233:32 - then it has a bunch of events that get
233:34 - fired whenever some things happen to
233:36 - this inventory in order to store the
233:37 - inventory items it is stored simply on a
233:39 - list and then just keeps an integer for
233:41 - the selected index so basically which
233:43 - item is currently being being selected
233:45 - then we've got some basic functions so
233:47 - one testing if we can add an item so
233:48 - really just testing the inventory list
233:50 - against the capacity then we got a
233:52 - function to add an object and over here
233:54 - we have an example of a custom exception
233:57 - so basically if we try to add an object
233:58 - without first checking if we can add it
234:00 - so if we try to add it but we can't if
234:02 - so then this is going to throw a custom
234:04 - exception of this type inventory for
234:06 - exception so the exception is defined
234:08 - down here pretty simple doesn't even
234:09 - have any extra data it's really just a
234:11 - type just to be identified exactly what
234:13 - exception it is but assuming things go
234:15 - well it simply adds the item onto the
234:16 - inventory and fires off an event to know
234:18 - that the item list is changed and then
234:20 - just has some more functions in order to
234:22 - set the selected index to get it in
234:24 - order to get the entire inventory item
234:26 - list and get the selected item so here
234:28 - we have a pretty basic inventory it
234:31 - sores a list of things and exposes a
234:32 - bunch of functions that can do certain
234:34 - things so you can work with the
234:36 - inventory also again note how in this
234:38 - inventory class there is no mention of
234:40 - any y anywhere once again that is
234:42 - because of the same thing so this
234:43 - inventory class is this one handles the
234:45 - actual inventory logic and then we have
234:47 - a separate UI class that listens to
234:49 - these events and then updates UI so over
234:51 - here we can see that so inside the
234:53 - canvas we've got the inventory UI so
234:55 - that is this element down here and on
234:57 - this script we have a reference to the
234:58 - inventory this is the one that is
235:00 - currently being held by the player and
235:02 - then we have a list of all the inventory
235:03 - slots these are all of these individual
235:06 - slots these are individual objects and
235:08 - as such they have a custom class in
235:10 - order to handle each individual one so
235:13 - rather than putting the logic for each
235:14 - each specific one inside of the main
235:16 - inventory UI class rather than doing
235:17 - that it is nicely separated so there's
235:19 - one class that handles the entire
235:20 - inventory another one that handles each
235:22 - individual slot then in this slot this
235:24 - one is a pretty simple script we just
235:26 - have a reference to an image and the
235:27 - select game object so the image is the
235:29 - icon Sprite and the select game object
235:31 - is this little green arrow in order to
235:33 - show which item is actually being
235:34 - selected then over here the behavior for
235:36 - each slot is actually pretty simple so
235:38 - we've got one to set the selected state
235:40 - so this really just either enables or
235:42 - disabl that select the G object with the
235:44 - visual
235:44 - then we got one to set the item Sprite
235:46 - again just setting the Sprite for
235:48 - whatever object is placed in that item
235:49 - location and then we have another one in
235:51 - order to set the click action so over
235:53 - here we can see delegates in action so
235:55 - we've got a simple action Delegate for
235:57 - the click action and simply just going
235:59 - inside the button and adding a click
236:01 - action so so an action that is triggered
236:04 - whenever we click on the button and all
236:06 - of these functions these are all handled
236:07 - by the other inventory UI class so over
236:09 - here this one again this one has a list
236:11 - of all the inventory slots and on start
236:13 - first we access the inventory and we
236:15 - subscribe to the two events that we need
236:17 - to so one then the item list changes and
236:19 - one when the select index changes then
236:21 - here we can see the click actions we can
236:23 - see a use of Lambda Expressions so
236:26 - instead of defining proper functions
236:27 - we're really just using the inline
236:29 - Lambda expression this works great when
236:30 - it comes to button actions so we're
236:32 - telling it giving it a click action for
236:35 - the inventory slot on index zero so the
236:37 - first slot telling you to select this
236:39 - index when we click on it then doing the
236:41 - same thing for all the other slots and
236:43 - then we have the functions listening to
236:46 - the various events so when the atom list
236:48 - changes when that happens we want to
236:49 - update the atom list and update which
236:51 - one is selected and on this one same
236:53 - thing just update selected and then for
236:55 - these for updating the item list first
236:57 - thing we do is cycle through the
236:58 - internal list we set the select the
237:00 - state to false in order to deselect all
237:02 - of them and we set the items right to
237:03 - null in order to disable the items then
237:05 - we cycle through the inventory item list
237:07 - that is inside the inventory we go
237:10 - through each of those elements in order
237:11 - to set the slot to the corresponding
237:13 - item Sprite basically this populates all
237:15 - the buttons and then for the update
237:17 - selected this one is also pretty simple
237:18 - so first we deselect all the buttons
237:20 - then we ask the inventory to get the
237:22 - select index and set that one to select
237:24 - it as just that one so yep here the
237:26 - inventory is empty and as I pick up a
237:28 - pistol yep it sets a weapon and sets
237:29 - that and if I click on one of these I
237:31 - can swap which item is selected then if
237:33 - I shoot I can use the pistol I can pick
237:35 - up the shotgun click the selected and
237:37 - use it or pick up this one click it and
237:39 - use it see y That's the inventory with
237:41 - various slots let's also see this over
237:43 - here the inventory this one has an item
237:45 - list and it's of this type I inventory
237:47 - item this another interface here we can
237:49 - see the usage of an enum in order to
237:51 - define the item type so it can be a
237:53 - pistol shotgun or potion and then
237:55 - various functions so one to get the atom
237:57 - type to get the Sprite and to use the
237:58 - item so with this let's look at the
238:00 - weapons and first of all in terms of
238:02 - structure I decided to separate the
238:04 - logical items that go inside the
238:06 - inventory and the actual items that
238:07 - exist in the world so for example over
238:09 - here in the world there's a pistol that
238:11 - the player can pick up this one has
238:13 - script of type pistol object so there's
238:15 - that one and then there's an actual
238:17 - pistol that contains logic so there's
238:18 - onlyu there's the potion object and
238:20 - potion shotgun object and the shotgun
238:22 - here for the pistol object this is the
238:24 - one that implements Agra object so this
238:25 - is how the player can actually pick up
238:27 - the weapon and this one unlike the money
238:29 - this one does return true because does
238:31 - have an inventory item and when calling
238:33 - the function to get it it simply creates
238:35 - a new pistol so this is the class that
238:37 - is meant to handle the logic for the
238:38 - actual pistol as to when that runs it's
238:40 - over here on the player when the player
238:41 - triggers an enter so when it goes into
238:44 - inside another collider it checks if it
238:45 - has a grabbed object which again the
238:47 - pistel object does implement this
238:49 - interface then the pistel object can
238:51 - indeed have an inventory item so then it
238:53 - checks if the inventory can add that
238:55 - item if so it adds it onto the inventory
238:57 - and goes into the grab object nor to
238:58 - grab the inventory item so that is what
239:01 - is going to construct a brand new pistol
239:03 - and over here is the pistol script this
239:05 - one has a function to return the atom
239:07 - type so that it knows okay this is a
239:08 - pistol it has one to return the atom
239:10 - Sprite and over here we see another
239:13 - instance of the single class we've got
239:15 - the game assets this is a class that I
239:17 - use in pretty much all of my games it's
239:19 - just a super simple way to access any
239:20 - kind of assets so here in the game in
239:23 - the scene I've got a game assets object
239:25 - and inside it as this script and then
239:27 - this script I can drag any references
239:29 - that I want to reference anywhere in the
239:30 - code base so this is another really
239:32 - useful use case for the Singleton
239:34 - pattern so anyway so the pistol gets the
239:36 - Sprite for the pistol and then it has a
239:38 - function to use the item which in turn
239:40 - is going to tell the player in order to
239:41 - shoot then the player shoot function
239:43 - this one is pretty simple it really just
239:45 - fires a rast this kind of like a laser
239:47 - in the physics World in order to find
239:49 - other colliders this is basically how it
239:51 - finds other things that it can shoot and
239:53 - over here again note how I'm not looking
239:55 - specifically for an enemy or a bomb but
239:57 - rather an eye attackable interface so
239:59 - this is how the player can actually
240:01 - shoot any kind of object not just
240:02 - enemies not just bombs it can shoot
240:04 - anything that implements this interface
240:06 - but before we get to that let's actually
240:07 - go back into the player class and over
240:09 - here note the override on all of these
240:11 - that is because the pistol this one is
240:12 - actually extending a weapon Base Class
240:15 - and this one here it is this one is an
240:17 - inventory item so that is how it can be
240:19 - placed on the actual inventory and this
240:21 - one is marked as abstract because we are
240:22 - never meant to construct just a base
240:24 - weapon but rather the weapons that
240:26 - extend from this class and everything is
240:28 - abstract so this is all up to the
240:29 - extending classes to implement these
240:31 - functions so the pistol over here
240:33 - implements these functions like this and
240:35 - the other weapon is over here the
240:36 - shotgun again this one also extends the
240:38 - weapon and this one does override with
240:39 - different things so it returns a
240:41 - different item type a different Sprite
240:43 - and over here we got a bit of different
240:44 - logic so the pistol just shoots once
240:47 - whereas the shotgun shoots multiple
240:48 - times so now we can go back here into
240:50 - the shooting code so again this one
240:52 - fires a rast in order to find all the
240:54 - physics objects that it hit if it did
240:56 - manage to hit something if so then it's
240:58 - going to try to see if that something is
240:59 - an ey attackable object and if so it is
241:02 - going to cause damage to that object
241:04 - here is the eye attackable interface
241:05 - really super simple just as a damage
241:07 - function so basically in order to make
241:09 - something damageable by the player all
241:11 - we need to do is implement this
241:13 - interface so for example here we have
241:15 - the bomb class this one does implement
241:17 - the ey attackable interface and this one
241:19 - is another super simple class it has the
241:21 - damage function down here for the
241:22 - interface and simply passes that damage
241:24 - function along down to the health system
241:26 - so the health system this is a great
241:28 - example of composition over inheritance
241:31 - basically the Bob is meant to have some
241:32 - kind of health so it has a health system
241:35 - but specifically it has a health system
241:36 - in a field as opposed to having of the
241:38 - health system code directly inside the
241:39 - bomb class this way it makes this health
241:41 - system reusable which it is indeed
241:43 - reusable since the enemy also uses a
241:45 - health system so let's inspect it and
241:47 - over here this is another preim class
241:49 - just has a basic functions for handling
241:51 - some kind of health so just as a health
241:53 - and a health about Max then as usual it
241:55 - has events for whenever all kinds of
241:57 - things happen so on health change or on
241:59 - dead then we've got the damage functions
242:01 - counts down the health amount and if
242:03 - under zero fires off the on dead and
242:05 - either way fires off the on health
242:07 - change so that is why over here the bomb
242:09 - this one we can note on start this one
242:11 - is listening to the health system on
242:12 - that event and when that happens happens
242:14 - it is going to run this code which is
242:16 - going to destroy the bomb and fire off
242:18 - this event the class that listens to
242:20 - that event is over here the game manager
242:21 - which again this is another one of there
242:23 - exists only one so this one is a
242:25 - Singleton and over here we can see that
242:27 - it is listening to the bomb on any dead
242:29 - event and when that happens basically
242:31 - just spawns a VFX prefab just as that
242:33 - and Shakes the camera so over here if I
242:36 - pick up a weapon and I shoot a bomb and
242:37 - I destroy it yep there you go it fires
242:39 - off some VFX and Shakes the camera yep
242:41 - there it is that's the bomb also note
242:43 - how the bomb also has a health bar that
242:45 - Updates this is another UI element that
242:48 - again is being driven by events so here
242:50 - in the scene we can see the bomb we can
242:52 - see the bomb has a canvas inside the
242:54 - health bar UI and this one note how this
242:57 - class is health bar this has nothing to
242:58 - do with any bomb or any enemy this one
243:01 - simply works with a health system it
243:03 - does not matter where the health system
243:04 - is attached it could be the player it
243:06 - could be a bomb could be an enemy could
243:08 - be building does not matter this health
243:10 - bar works on any kind of health system
243:12 - and the way it works is super simple
243:13 - just listening to a bunch of events and
243:15 - when it does then just goes into the
243:17 - health system to get the health
243:18 - normalize and use that in order to make
243:20 - the bar image fill them out so another
243:22 - super simple super short script it does
243:24 - one thing and just one thing and then
243:26 - our enemy class again this one also
243:28 - implements I attackable so it can be
243:30 - damaged it also has a health system so
243:32 - again it can be damaged it also fires
243:34 - off and on any dead event and note how
243:37 - just on this one and the same thing is
243:38 - over here on the bomb note how these are
243:41 - static events meaning that they belong
243:43 - to the class itself and not any instance
243:45 - of that class so that is why over here
243:47 - on the game manager when listening to
243:48 - that event it does not need a reference
243:50 - to every single Bob and every single
243:51 - enemy it just listens to the static
243:53 - event which is going to be fired from
243:55 - any instance of that class so for
243:57 - example when any enemy dies when it does
243:59 - it's going to run this code which really
244:01 - this one just spawns the money so spawns
244:03 - and sets it to go into a random position
244:05 - then back over here on the enemy class
244:07 - so we've got the event we've got the
244:08 - health system then on update we have
244:11 - some super basic AI literally just
244:13 - moving towards the player and again the
244:14 - player has a single T so it makes it
244:16 - super easy to access and then just
244:18 - listens when the health system dies and
244:19 - when that does it just destroys this
244:21 - game object so Yep this is another super
244:23 - simple class and the last two scripts
244:25 - that we need to look into are the
244:26 - holding object Visual and the weapon
244:28 - animator so the holding object visual
244:30 - this one is inside of the player game
244:32 - object here we have a holding object so
244:34 - basically inside of this object we place
244:36 - either the pistol game object or place
244:39 - the other game objects over here inside
244:40 - the prefabs we've got one for a pistol
244:42 - for a potion for a shot
244:44 - that is how over here the weapon that
244:46 - I'm rotating I can select different
244:47 - weapons and rotate some so this game
244:50 - object has that script attached and this
244:52 - one really just has the reference to the
244:53 - inventory in order to know when the
244:54 - selected weapon changes and when that
244:56 - happens it really just updates its
244:57 - visual that involves getting the select
245:00 - inventory item then doing a quick n
245:02 - check just to make sure there is an item
245:03 - selected and checking for the item type
245:05 - this one is going to be an inum so over
245:07 - here doing a switch on that enum and
245:09 - depending on that spawning a different
245:10 - prefab and finally for each weapon like
245:12 - for example over here the pistol it has
245:14 - a weapon animated script here is that
245:15 - script and right away we can see a
245:17 - Conant for a string like I said you
245:19 - should avoid using strings as
245:20 - identifiers at all cost but sadly
245:23 - actually the unity animator system this
245:24 - one requires using strings so rather
245:27 - than using a string down here for the
245:28 - set trigger on the animator instead of
245:30 - doing that I Define a constant up here
245:32 - and then for the rest of the code I only
245:33 - use this constant that really helps
245:35 - limit the amount of strings meaning the
245:37 - amount of potential problems that we
245:38 - have so it has a constant a bunch of
245:41 - fields then we've got the animator once
245:43 - again and this one also works based on
245:45 - events so it subscribes to the on shoot
245:47 - event on the player and when that
245:49 - happens simply just set the animator
245:50 - North to shoot it spawn the VFX prefab
245:53 - the little dirt that gets thrown out
245:54 - whenever shooting and then just spawn
245:56 - the bullet Ray prefab finally on this
245:58 - one since this element is being swapped
246:00 - out meaning it's spawned and destroyed
246:02 - we need to make sure to unsubscribe to
246:04 - the event so we don't have for example a
246:06 - dead weapon animator still listening to
246:07 - the same event so over here on the on
246:09 - Destroy which is a Unity function that
246:11 - gets called whenever the S game object
246:12 - is destroyed whenever this happens we
246:14 - are just unsubscribing to the event so
246:16 - we don't get comebacks for an object
246:17 - that is destroyed put all that together
246:19 - and here is the object I've got the
246:20 - inventory I can pick up a pistol and I
246:22 - can shoot a bunch of zombies when I
246:24 - shoot them they drop some money I can
246:25 - pick up that money then I can pick up
246:27 - different weapons so for example I can
246:29 - select now the shotgun and now this one
246:31 - shoots many more bullets I can shoot
246:33 - enemies and I can also shoot some bombs
246:35 - and boom there you go they all blow up
246:37 - it's all really satisfying then I can
246:38 - also pick up a different potion I can
246:40 - use it and all of a sudden I'm moving
246:42 - much faster and there you go just like
246:44 - this all right awesome so this is our
246:46 - intermediate project in this really nice
246:49 - project we have Incorporated almost
246:50 - everything we have learned so far you
246:52 - can go ahead and inspect this project
246:54 - for yourself in your own time in order
246:55 - to see how all the concepts we have
246:57 - learned have been used in this project
246:59 - feel free to play around the code and
247:00 - modify some parts to see how it all
247:02 - works if you make a mistake and you
247:04 - break something you can always just
247:05 - redownload the companion project so
247:07 - don't be afraid to experiment as always
247:08 - you'll learn by doing so take some time
247:10 - to do just that maybe build upon this in
247:13 - some way maybe see how you could add
247:15 - another weapon or another grabbable
247:16 - object or another enemy type hopefully
247:19 - with this video you understood how it's
247:20 - all structured so with this plus the
247:22 - knowledge you've gained through this
247:23 - entire course so far with all that it
247:25 - should mean you should be able to fully
247:27 - understand how all this is working how
247:29 - all these systems are interconnected if
247:31 - not then go rewatch some lectures on
247:33 - some topics that you find tricking or
247:35 - simply feel free to post a question in
247:36 - the comments and I'll do my best to
247:37 - clarify any
247:39 - doubts hello and welcome I'm your km all
247:42 - right so congrats on watching this
247:44 - entire free video course I hope you
247:46 - learn a ton I really hope that you took
247:47 - your time and really focused on learning
247:49 - all the topics in this intermediate
247:50 - section and if you're watching this
247:52 - video then I also hope that you also
247:53 - learned everything from the previous
247:55 - video on the beginner section if so then
247:57 - you are hopefully much more skilled now
247:58 - than you were when you started this
247:59 - course if you're watching this in the
248:01 - future then check the links in the
248:02 - description or the pin comment to see
248:03 - whether the Advan section video is over
248:05 - here on YouTube like I said in the
248:07 - previous video my goal is really to make
248:08 - all the video lectures free over here on
248:10 - YouTube if the premium version sells
248:12 - over a certain number of copies and I'm
248:14 - very happy to report that it has indeed
248:15 - gone past that threshold which is why
248:17 - this intermediate video is over here
248:18 - free on YouTube and the video lectures
248:20 - for the invent section those will also
248:21 - be coming out for free in about 1 to two
248:23 - months or if you want you can just go
248:25 - ahead and pick up the premium version
248:26 - right now and continue on to the
248:27 - advanced section right away you can
248:29 - watch all those lectures along with all
248:31 - of the awesome bonuses that the premium
248:32 - version has all right so thanks for
248:34 - watching I hope you learned a ton and
248:36 - I'll see you next time

Cleaned transcript:

hello and welcome I'm your KMI welcome to the free intermediate section for my complete C Mastery course by going through this course you will learn how to be able to make games websites apps Robotics and literally anything C is an extremely versatile language the core starts from the absolute Basics like how code executes line by line and what is a variable then covering intermediate topics like what are interfaces generics and events and how you can use them to build some really awesome things you will also learn the theory behind how to choose good naming rules clean code guidelines and learn about design patterns and finally the advance section which I'm currently working on and covers quite a lot of advanced topics right now there's a handful of lectures already out and I'm constantly uploading more now this free YouTube over here this one contains all the video lectures for the intermediate section like I said in the previous video my goal is to publish the video lectures over here for free on YouTube if the premium version sells a certain number of copies and I'm very happy to report that has indeed passed that threshold which is why this video is over here for you on YouTube I've already posted a video with all of the free video lectures for the beginner section and in about 2 to2 months I will publish the free video with the advance section so if you're watching this in the future check the link in the description to see links for both of those the premium version of the course has all the video lectures for all the sections and also has a bunch of really nice bonuses So speaking of that here are the bonuses for the premium version I came up with some that I think are really awesome and definitely worth it if you can't afford it well at the same time not putting any knowledge behind the pay wall so even people who can't afford it they can still learn from the free lectures they really just need to do a little bit of extra work themselves the premium version is really just selling convenience making it really easy for you to truly gain the knowledge the premium version comes with a companion project this is a Unity project that contains a bunch of extra content basically the video lectures won't being preas themselves there's still really only half the course the other half of it is inside of this project it has a bunch of custom editor Windows to guide you through each lecture and each lecture has a section on frequently asked questions these are common questions that have some really detailed answers that provide even more details on what is covered in the lecture then there are some quizzes these are multiple choice questions again all with very detailed anwers it's really not just correct or incorrect if you pay close attention to each lecture you should be able to get most of these right but whether you do or don't by reading the extra explanation that will help you truly learn that topic then the interactive exercises I'm really happy with this feature I think this will really help you learn learning by doing is always much better and these exercises encourage you to put what you learned into practice instead of just blindly watching the video lectures I designed a ton of hcraft exercise for all the lectures to help you put into practice and truly learn the contents of each lecture there are all kinds of exercises some are about spotting and fixing errors others are about asking you to Define some function or class or Implement some kind of logic there are some where you just write code and somewhere you write code and then play the code in unity in order to complete the exercise then each exercise also contains a hint just in case you get stuck or a solution in case you get really stuck as well as a video walkthrough of me going through that exercise and completing it while explaining everything in detail so you heard the kind of person who gets stuck in tutorial hell then I truly believe that this will really help you escape it in order to learn need to actually do things and and this exercise encourage you to do that they encourage you to do it as opposed to just blindly watching the video lectures then the companion project also has a companion window basically this window is also listening to a bunch of errors and if it finds one it will help guide you in the right direction I manually wrote a ton of text for when text lots of errors all of them based on common errors that I see people ask about in comments in my own videos so this should help prevent you from getting stuck in your Learning Journey and allow you to get help instantly then the course also has an AI to help you answer questions this one was trained on the contents of the course and my own knowledge so it should be very accurate and helpful but more than that it's simply the fact that it is extremely fast you post a question in the course comments and within a few minutes the a will respond with probably a very good answer although of course I myself will also still be answering all the questions manually the goal with this AI is really speed so you get a response almost instantly and then within the next few hours I will manually answer myself then a simple bonus is how the premium version has the course split into lectures as opposed to Here on YouTube where it will be one giant video it has to be that way the how the YouTube algorithm works this is a small thing but it can be helpful especially if you take your time to slowly go through the course just like you should do remember that the only goal is really that you are actually learning yourself it does not matter how quickly you go through it so separate lectures help with that so that you can pause and actually try out your knowledge before going further and you don't have to memorize specific time stamps and over here on YouTube the videos have the normal YouTube ads as usual whereas the premium version has no ads so there's nothing to interrupt you while you're learning another two great bonuses is the private Discord and and thean live study group you get access to a private Discord with a really nice community of people all on their own Learning Journey I'm there myself as much as I can to answer questions or really just chat and every week I also do a private life QA you can join me on the live stream and ask anything you want and I'll do my best to help so these are the nice bonuses that I came up with that I think are really nice and really awesome while not taking away anything or putting any knowledge behind the pay wall if you can afford then I highly recommend the premium version these bonuses will help you truly learn and learn much much faster than the 10 years that it took me but if you can important that's okay like I said there's no hidden knowledge hidden behind the paywall you really just need to put more effort in yourself in order to actually apply knowledge that you gain so whether you get the premium version or watch your free lectures I really hope you'll learn a lot also just in case you're new to my channel so a bit about me and my credentials or why you should listen to what I have to teach for me I've been programming for over 25 years and specifically using C for over 10 years I'm a professional indie game developer with several successful games PO on seam covering a wide range of genres my games are usually focused on complex systems since I am merely a programmer it's what I really love to do and what I love to teach also a couple of years ago I started over here this YouTube channel making free video tutorials to basically share my knowledge to help you learn how to make your own games there's already over 800 free videos over here on this channel if you want to continue learning Beyond this course also one very important note for both beginners but also for intermediate users which is simply take your time take it slow remember this is your Learning Journey no one else's the only thing that matters is that you're learning it does not matter how long it takes you so it does not matter if someone learns all of this much faster than than you you are really not in competition with anyone but yourself also you are not expected to go through this course in one day one week or even one month basally all the content out of this course this contains knowledge that took me 10 years to learn so really just take it slow take your time and really just focus on learning and one final request if you find this video helpful if so go ahead and hit the like button and subscribe to the channel it's a tiny thing but it really does help all right so let's get to the first lecture hello and welcome I'm your KMI welcome to the intermediate section we're going to take things up a notch and learn some more intermediate Concepts but before we do let me just quickly say if you are still very much a beginner If the previous section was your very first exposure to any kind of programming if so then just be aware that it's perfectly normal that it takes you some time in order to understand the context of this intermediate section that's perfectly normal learning and trally understanding all that we're going to see all of that takes quite some time remember that the only thing that really matters is that you're learning how long it takes you isn't really relevant so really just focus on actually understanding actually learning for me it took me literally decades to learn and all of this so if it takes you 6 months to go through this intermediate section if so then you're still going to be doing much much better than me so all that to say take your time and just focus on learning now if you took a break between the beginner section and this one then I encourage you to go back and at least rewatch The naming lecture and the clean code principles I put those two lectures in the beginner section just because I want the beginners to be aware of it but as you grow as a programmer as you become an intermediate those two concepts naming rules and clean code principles those become even more important to fully understand and fully apply so if it's been a while since you saw the beginner section go ahead and rewatch those just quickly and with that that's the intro out of the way so let's go into the next lecture where we're going to see a nice overview of everything that we're going to learn in this intermediate section hello and welcome I'm your Cod monkey in this intermediate section we're going to go one level up relative to the beginner section and learn some more complex stuff so let's see an overview of all the lectures beginning with something very important that I debated whether I should put in the beginner section it's going to be Visual Studio shortcuts I end up putting it here because for beginners technically it's more important to learn how to write WR the code and it's not as important to be extremely efficient with how fast you use your ID but for intermediates this is a must have so we're going to learn about a ton of shortcuts to help you write code and navigate your environment much better then comes one of the most important lectures in this whole intermediate section it's all about refactoring this is the process of rewriting your code to make sure it is as readable and understandable as possible as an intermediate you absolutely need to know that this is a natural part of the code writing process and something you should not skip next is a lecture on s pretty simple and very useful it's how you can define a specific list of values that you can use in many ways after that we'll learn about properties which are kind of like a mix between variables and functions then we're going to learn about multidimensional arrays meaning arrays that can hold multiple dimensions of data after that we're going to learn about Ness Loops which is especially important in order to cycle through multidimensional arrays next we're going to learn another method for doing some looping logic we're going to learn about recursion this is something that for people with a math background it might actually be similar to understand than R Loops then we're going to learn about an extremely useful data type the dictionary this is a key value pair that has tons of really awesome use cases after that we're going to learn about some more collections like q and stack then we're going to learn about the prams keyword and what exactly does it do in a function next we'll learn about optional parameters how to define them and how to call them from a function then another crucial lecture for intermediates this one is on learning the differences between value and reference types this is extremely important if you don't know this difference then you will go crazy at some point in the future wondering why something isn't changing and it's usually going to be because you don't know you're working with a copy and not a reference related to that is the lecture on structs these are similar to classes but importantly they are a value type next we're going to learn some more intermediate use case for classes we're going to learn about inheritance polymorphism and a bunch more then learn about interfaces this is one of my favorite features of csharp it allows you to write some really nice modular code related to that we're going to see various ways of testing for types and converting to and from various types also related is the lecture on switch pattern matching this is a really simple way to do a switch not just on value but also on type then we're going to learn all about delegates lambdas and Anonymous functions this is how we can store a function itself inside a field next we're going to learn the differences between lambdas and local functions after that we learn about events which is how we can have one class we notified when something happens then the next lecture that one is going to be all about generics this is another super power powerful C feature that makes your code work with multiple types next is a simple lecture on constant and read only what they are and what are the differences between those two after that is a lecture on exceptions and how to handle them with a try catch then a lecture on implementing I numerable so we can add support for something like a 4 in for some custom types next we're going to learn about namespaces what they are and how to make your own then a really important lecture on one of the most important design patterns the single T pattern and after that is a general over review of a bunch more design patterns and finally after doing all of that we're going to check out the intermediate project that uses all of this to make something really interesting hello and welcome I'm your codm in this lecture we're going to learn about a bunch of really useful Visual Studio shortcuts okay so as we get to the intermediate Sage it is really important to be good at using your tools and as a programmer your main tool is going to be your ID so you should be very comfortable with shortcuts and moving around your codeb base but also this is something that you pick up with experience so this lecture this one is really not meant to be a stepbystep lecture but rather I just want to show you a bunch of shortcuts that I use myself just so you are aware they exist and over time you won't pick them up and they won't become more and more natural okay so the most basic but honestly most useful one is simply moving the cursor normally beginners they use the mouse to move around so they scroll down and click wherever they want to write and then sometimes beginners use the arrow keys and they press it like a million times in order to get wherever they want to go technically this works but it's obviously not very efficient there are many ways to speed this up and importantly many ways to navigate your code base without your fingers ever leaving the keyboard for example when moving left to right technically you can indeed just press the right arrow key and eventually you won't get there but as you can see going left to right like this takes quite a while I got to press like some like 50 times in order to get to the beginning or the end so one of the best super simple shortcuts is simply to hold down the control key and now as you move left and right yep instead of going letter by letter it goes word by word so that way now I can get to the beginning or the end of this line in just about four five presses instead of being like literally 50 so it is literally 10 times faster then of course you also have the home and end key I use these all the time especially when combined with shift for quickly selecting something so for example if I want to move this line above the Southern Line if so then us what I do is press end to go to the end of this line then hold shift and press up to select and now press end again in order to select just that one then I press CR X to cut I move up press contrl V and yep like that so if you do it pretty quickly it goes quite fast very easy to do all this and again I did all of that without ever my fingers leaving the keyboard if I were to use the mouse I would have to select like this crl x go like this like this so in this case not much of a speed difference but just the fact that your fingers never have to leave the keyboard that alone is a huge bonus and again on all these shortcuts we're going to see how differen is usually pretty small like saving like a second 5 seconds or fractions of a second so that does sound like a super tiny amount but considering how you're probably going to be programming for many years and you're going to write millions of lines of code throughout your entire life when you look at it like that those tiny amounts of time they really add up so that's the main thing just moving left and right holding control to go between each word or using and then home in order to go back to the beginning and the end and combining all of that with shift in order to really move around super quickly so that's the first tiep and then for something that is sadly not default is moving the cursor up and down so by default if you do that it obviously only moves one line at a time so again the same thing in order to move down 20 or 30 lines that actually takes quite a lot of pressing in order to move and by default the alternative is using page up or page down although personally I'm not a big fan of this I find that these move the cursor way too much so every time I press page down it takes me quite a while to realize where the cursor is and how much actually moved so I don't like how this moves way too much so in my code I added something so that I can move the cursor up and down vertically by just five lines that way I can very easily go down and continue scrolling down and I'm never lost because the screen never changes a massive amount I'm always moving down moving up select this line of code do something move down write something so on now sadly this behavior isn't available by default in Visual Studio at least not that I know of so for this I installed this extension called visual Commander this one lets you basically apply some hotkeys to l anything you can do in visual studio and then with that install just go up here into extensions and here is the V command and on this one here are some commands that I made so here is the window so I've got move up and move down so I can edit in order to see what this is doing and yep it is executing the command line up so literally just moves the line up and the other one this one does the same thing but line down so I've got these two commands here if I have the cursor somewhere and I go into that extension and I use the move up command yep it does move up by six lines so then as you can see I just assigned some keyboard shortcuts to those so control up and control down then I just went into tools options and over here go down into the keyboard shortcuts and then find vs command and up here command one command two those are two ones that I made and as you can see I've have assigned them to control up arrow and control down arrow so all that if I press control up or control down as you can see the cursor moves quite a lot faster so I find this to be much better than just pressing one just moves one line or pressing page up which always causes me to lose and get lost so with just these steps you can see how I can move in the code really fast without ever touching the mouse like let's say want to go down I want to find for example the awake I want to select the awake I want to cut it and paste it down here and there you go just like this and remove these lines form met and so on so as you can see just using these control in order to move between the words using this shortcut in order to move vertically really fast and combined with home and end and with shift and all that put all those together and yep you can move through the cursor you can move in your code base really quickly without ever leaving the keyboard then of course if you're working on some kind of Big File like for example this is the player class from my steam game dinky Gardians so this a pre massive class for this one if I want to get to the bottom and if I go even with this short this is going to take quite a while so for that one if you want to move a massive amount you can use control home or control end in order to go to the beginning or the end the file so this is yet another way to very quickly move around and another very useful one for moving around is simply put the cursor on top of some kind of symbol like for example let's say this one this event on player picked up the experience and then if you press control shift and either up or down this will move the cursor to the next or previous reference of that symbol so for example over here you can see how it's really useful how in this huge line of code this script has almost a thousand lines of code but I can very easily see exactly where this one is being referenced I just move up and down yep here is the definition and here is where I'm using it so whenever you want to see all the various places in which you are using some kind of symbol that can be a function can be an event can be a variable can be literally anything just hold down control shift and then up and down and you can see all the places in which that symbol is being used then another extremely useful shortcut that I use all the time is control and comma this one pops out this window and now here you can search for any class you just typee a name and find it like for example I want to open up the dinky class so I'm going to type in dinky and now just one thing is this shows actually every symbol so in this case in this game since it's all about dinkies I've got tons of references to dinkies so you can see all of these in lower case I usually write my variables in lowercase so I know that's not the one I know the one that I want in order to open the file is the actual file itself so I can type in dinky docs and yep that does show the file press enter and yep here I am the dinky file and again press control home to get the beginning yep here's the dinky definition and I can see all this code just like this so if I want to move to like the tutorial manager so I just write tutorial manager just right a little bit yep I can already see this one so this the class we can also see the icon over there so that one means a f that one means a class this one means an event and so on so I can see this one press enter and yep here I am in this one and again move up move down everything works again note how throughout all of this my fingers never leave the keyboard I never touch a mouse so personally whenever I'm making my games and I want to open another class I never go into unity and manual double click on that file I always do it over here press control comma search for anything press enter and it opens or alternatively for example that one that I mentioned when you got tons of references something like over here tons of references to a dinky so I can just go into this one and then I can put the cursor on top of the type itself and I press on F12 and Yep this one takes me to the class definition F12 is a shortcut but if you want to use the mouse you can also just right click on it and over here we can see yep F12 is indeed a shortcut to go to definition now since we're here with the mouse one really useful one is over here the fine all references when you click on this this is going to show all of the references to that type so this can work with whatever is under the cursor so in this case I select the dinky class so this is going to show me all of the places in my entire code base where the dinky class is being used or alternatively you can put it just on a field and yep now this one is going to show all the places and you can click in order to automatically go to that line and of course it also works with functions so for example over here this function I'm pressing control shift up and down in order to see all the references within this file but this function is not called from within this F so in order to find where on Earth am I calling this again right click go to references and if I can see okay so it's being called from this script right here inside dinking manager it's calling this function another really useful use case for that particular one is when working with interface so let's say I want to see all the class that implement this interface again right click find all references and if I can see all of these look at these these are all implementing the UN interactable interface then something that I use all the time is control RR that is the shortcut for renaming the current symbol so I just plac the cursor for example over here on top of the is moving field press control RR and now let's say I want this to be a little bit more descriptive so is player moving so I change that and note how again the other shortcut control shift and up and down note how this one did rename every single reference of this symbol so all of those I don't need to change them just modify them once use the rename feature and automatically renames all of them and if I find out that the previous one works better again just edit go ahead remove this press enter and Y there you go all of those have now been renamed remember that refact ing is an extremely important and importantly it's a perfectly normal part of the process in fact the next lecture is entirely dedicated to the topic of refactoring if there is something that you wrote some name but then later on you think it should have a better name just take some time in order to rename it simp place the cursor over it press contr RR write the new name and it will automatically rename every instance of that symbol this works on everything everything from simple variables to even entire classes and it even renames every single reference in your entire code base so for example here I am on the dinky class which is used throughout the entirety of this code base I can press control RR and I can modify this whole thing and say something and Y like it says here rename will update 297 references in 58 files so this rename feature is really awesome really useful it automatically handles modifying everything and everything is handled automatically for you then when you have multiple windows open for moving between them you can use control tab if you just use one it goes back and forth between the last open tab so this is something that I use all the time whenever I'm working between two files and I want to quickly move between them but instead of doing just that and letting go you can hold down control and tab and as long as you hold down control you can see this window and over here you can move up or down in order to move between all the various windows that you have open so for example let's say I want to go into dinky off world yep there you go now I'm looking at this class and if I quickly control tab I go back into the previous class and this tab over here this one only works for the windows that are open so again the same thing if you want to open up a new window just press contrl comma open the window let's say for example I want to find the carry vehicle so I just type in the carry vehicle yep it's right here control enter and this one opens up the carry vehicle class now control Tab and off want want I go back to the link key and move between them like that then here's a really simple one you can raise an entire line by just having the cursor anywhere on that line pressing contr X that one cuts the entire line that one acts as a cut meaning if you press contrl + V you get the line back alternatively for duplicating you can press contrl D although honestly I rarely ever use this one because I can never remember whether it's going to duplicate on the line above or below it so usually if I want to duplicate something I just do the shortcuts that I mentioned a while ago so end above and cut move cut and so on now speaking of copy paste if you press control shift and V if you do that you get a list of your clipboard history so for example a while ago I showed cutting the awake class and yep it is still saved in here so if I press on enter yep it paste that one exactly like that so remember that your clipboard has history it is not just the last thing that you copied you can access the entire history another useful tiny time saer is actually when using the mouse when using that if you want want to select some kind of word some kind of symbol obviously you can do the basic thing which is just click and hold and drag throughout to select it so obviously that works but it's a little bit fiddly if you move up or down can be quite tricky so the similar shortcut for that whenever you want to select some kind of word you can just double click and it select it or alternatively hold down control and click in order to select the entire thing this can be quite useful for example when you have some copy pasted code and you want to change some kind of name but for some reason the rename function doesn't work like for example let's say I want to duplicate this code over here so right now I cannot use rename because this one is going to conflict with that one so instead let's say the active dinky list so I press I select this one control click and there you go like that and if I want like that so control click in order to do control V and so on this one can be quite useful sometimes then something that I only very rarely use is shift and ALT hold those and then move upward down and this one basically lets you select multiple lines of code and edit them at the same time like I said I rarely use this but sometimes can be useful for example for quickly appending or removing some kind of like for example on this enome I've got these values I want to write all of them and say tier one tier two and so on so I can select all lines and write here and writes on all of them or alternatively if this one did have it and I want to remove them just select them all and I can remove them so basically you can write code on multiple lines at the same time and if you want to quit this just press escape and yep back into a single cursor another Super useful one is when working with events like for example the on any dinky started starving so I can just write the event name then plus equals and then here Visual Studio automatically has a shortcut so you can press tab to insert start then if you want you can rename it but usually I keep the exact same name that it suggests so just press enter and Y there you go I've got a new event now I can come here and again use the shortcut contr X to get rid of that go above go to the end press enter go to new line then write some new code so really useful and if afterwards you decide that you want a better name for this event again remember just say quick control RR in order to rename then if you want to find something of course you have contrl f for example finding when I'm invoking some kind of event so just write invoke and if it finds it obviously nor then the shortcut for going to the next element that one is pressing on F3 and it goes to the next one so it finds that one that one that one and so on in order to go to the previous one you use shift F3 and goes backwards also by the way this works whether the control F window is open over there but if I press ones in order to close down that window and with this if I press an F3 yep it still remembers the last thing that I searched then for quickly commenting or uncommenting something you can do contrl KC and yep it automatically comments that entire line and if you have multiple lines selected control KC yep automatically comments the opposite to uncomment is control KU and yep automatically uncommons that although personally I never really use this one myself again it goes back to how I'm so proficient at just moving the cursor so if I just want to comment all of these I just do the common star go down there common star there you go just like this another useful shortcut is extract method so you can select a whole bunch of code then press contrl R and M and this one creates a new method with that code so let's say setup and if there you go pretty much took that code and plac it in its own method so this can sometimes be useful although again this is another one that I don't really use myself because again I'm prettyy fast at just moving the cursor so if I want to do this kind of thing I really just go into the code that I want I just go I use I move the cursor move up move down then do private void my setup do some kind of function then write it just like this and everything works if you want to go to a certain line you can press control and G this one lets you input some kind of line num so let's say let's see what is that line 500 so just type in 500 and yep there you go here we are on line 500 now for this one normally I don't really use it when writing code code but I do use this one quite a lot when writing the text script for my courses since normally I write my course in a simple text file sometimes it has tens of thousands of lines so for that usually I like to move around by using the line number although in the code I never really have such massive files so I don't normally tend to use it but it's only a nice thing to know then of course the one that you already know if you make some kind of mistake control Z in order to undo and one you might not know is control shift Zed in order to redo then for moving between visual stud and unity just a simple alt tab so just once and moves or if you have multiple files just keep pressing Tab and perhaps the simplest and most useful one is simply autocomplete I really advise you to get comfortable with how autocomplete Works learn how to just type a few lectures and then either press enter or dot or semicolon in order to quickly autocomplete honestly I don't remember the last time that I were something like for example try get component I just try a little bit and write like that for example dinky just like this then out Dinky Dinky just like this super simple so just get used with how little you have to write in order to press enter in order to automatically write everything everything else this works with Fields but obviously it also works with things like functions it works with classes it works with literally anything okay so that was a lot of shortcuts personally I use a lot of these all the time but again I've been writing code for over 25 years if you're not used to using shortcuts then I really don't expect you to suddenly use all of these right away all at once like I said this lecture this one is really not meant to be a stepbystep lecture for the most part right now I just want you to memorize the first ones that I mentioned about how to move through the cursor quickly just memorize those and simply remember that the other ones exist then periodically come back to this lecture every once in a while and watch it again if you do that several times over the next few months then soon enough all of these shortcuts that I mentioned all of these will be natural to you just like they are to me hello and welcome I'm your KMI in this lecture we're going to learn all about refactoring okay so before we learn some more programming syntax let's cover some very important Theory one of the types of comments that I get most often is basically beginners asking me how do I memorize all the code and write everything perfectly the first time and the simple answer is I don't what you see in a video like this course what you see is really after I've done tons of research and written and most importantly Rewritten a ton of code this is one of the crucial things that separates beginners from intermediates beginners think that when the code is written that's it it's written forever and will never change so you have to get it right on the first time whereas intermediate programmers they know that code is a semi living thing that is constantly changing as your game or your program changes and progresses refactoring which is a term for rewriting code or simply reorganizing it that one is a Perfectly Natural part of the process if a very simple process is simply when you first try to build some kind of system like for example making a health system at first your primary goal should be simply to get it working you should obviously try to write some good clean code but it's nearly impossible to get it perfectly on the first try so the first goal is just get it working and now here's the really important step that separates beginners from intermediates after you get the system working then look at it analyze the code and see if it could be written in a better way perhaps there's some variables that could have a better name perhaps there are some functions that are clearly doing too many things and should be split into multiple smaller functions perhaps you have a whole bunch of data separated that should make more sense being placed in its own custom class so the first step is indeed just get it working but then don't forget the Second Step that one is how to get it working properly remember that your code is a living thing you won't continue living and working with that code especially as you start to make bigger and more complex projects so since you're going to use and reuse that code in the future make sure you write it properly it is perfectly okay to write semi there code on the first time what is not okay is to leave it there so when it is working take some time to do some refactoring if needed so if you are a beginner about to transition into the intermediate stage I want you to truly learn and fully internalize this it is perfectly fine in fact it's essential to rewrite code you are not expected to write everything perfect on the first try but you are expected to constantly be thinking about how the code could be improved and if you do find some possible Improvement take some time and refactor that code always keep that in mind especially as we go through this intermediate section which naturally will increase in complexity compared to beginner section so keep that in mind and let's go to the next lecture and learn about enums hello and welcome I'm your Cod monkey in this lecture we're going to learn one super useful feature of C which are enums these allow you to Define enumeration with a set of named constants it's really useful in so many scenarios okay so enums are really great like for example look at this code this function over here get next player action this is supposed to be something like a turnbas strategy game so the player has this function and uses this in order to calculate what is the next player action then does a whole bunch of tests to find out what is the next valid action and doing so it returns an INT which is going to be some kind of code for whatever action the player should be taking so for example the player checks if it has no enemy if so then it returns zero so zero means no enemy gen checks if there's no path to the enemy if so returns one so one means no path to enemy then checks within attack distance so two means moving towards enemy or three means attacking the enemy now the big problem that is immediately apparent in this code is that returning an INT value that one is really not very intuitive int is really supposed to be a number so matching into some kind of behavior that seems quite strange just like this you have to memorize that zero means no enemy one means no path and so on so numbers really are not the best type to use here and I said this is one of the many scenarios where enums are really excellent so first we Define an enum and the way we do that is we just type in enum then the name of the enum so for example let's say player action and then open and close the currently braces and now here we just Define a set of names for our various enim States so for example in this case we want one to represent no enemy we want one to say no path to enemy and we separate them with a comma and one moving toward enemy and finally attacking enemy all right yep just like this so now we have to find an inum which inside can have four of these possible values by the way the inum just like classes just like types just like anything also can have an access modifier so again the same rule if you don't need it to access from anywhere make it private if you do need to access it from somewhere make it public okay so like this we have thein our n now we can refactor this code in order to make it much more understandable so for example instead of returning an INT let's return of type player action then over here instead of returning a number we just return player action dot in this case no enemy so instead of having this we just have this and Y right away this makes a lot more sense so let's apply the same thing to all these so this one is the no path to enemy and this one is going to be the moving toward enemy and finally we have the attacking enemy and yep just like this so now we don't need those comments to explain what the number is supposed to mean just looking at the actual value itself just like this we can understand what exactly this is meant to be doing so enums really are this simple we just Define the values for our enum and then use it in any way we want by the way here we are returning an enom but an enum is really just a type so we can do anything we want with it like for example we can make it a return type for a function or we can just make a variable of type layer action and we can set it to one of the values in our enum we can use it as a parameter we can use it on pretty much anything we want anything we can also use any other type in then another very common use case for enums is doing something like like a state machine so for example let's define a private enum for the state and on this state let's say we have the state looking for enemy then we have moving to enemy and finally attacking enemy so these are our various possible States and then we have some kind of function to handle the state so this is going to handle our state machine and over here we just do a switch and do a switch on our state so we would have some kind of state variable holding the current state for this unit and then we do a switch on that state and you case case something so case for example moving to enemy then we have the moving to enemy logic afterwards we do a break then we do all the other cases so looking for the enemy and so on so yeah this is a really simple State machine and you can see how by using an actual enum for the state that makes it much easier to understand as opposed to if we had the state being some kind of int and over here instead of these we would have just zero one and two and we would have to memorize what these numbers mean so just looking at this it is very clear just how good enums are with numbers it becomes really messy but if we apply some enums everything looks really understandable now enums also have an interesting property which is on the back end these values are actually stored as ins so to run some testing code over here I'm writing some code in the unity project so let's just do a private void start which is going to run this function automatically so now over here for example let's define a player action just a field of player action and let's set it to something for example let's say no enemy which is the first one that we defined so we Define this and now let's do we debug. log on displayer action and if we do this and here in the console we can see it pretty much print out a string of the state so no enemy however like I said on the back end these values are actually stored as ins so if we cast this down into an INT let's see what this one says and yep the int is going to be zero however instead of printing out the in for no enemy let's say the one for no path to enemy so this is the second state that we defined and you have this one now prints one so theorder is based on how you define them so the first one is going to be on essentially index zero then one two three and so on and you can also do the opposite so we can for example let's cast onto a player action and let's cast for example the number two any you casting the number two onto our enome does return moving toward enemy so due to this property due to how enom really are stored as ins in the back end because this there are some interesting things you can do with it for example another common use case for enom is when making some kind of game tutorial with various stages so You' have an enum for the tutorial stage then have like stage one which is like player teaching the movement controls in stage two stage three and so on so you'd have this kind of thing and then you will Define some kind of variable to store the current tutorial stage so let's say we're starting off on stage one and then we can just do tutorial stage Plus+ and let's do a log on this one so we're defining it as stage one then we're doing Plus+ let's see what this one says and yep it says stage two so it went on to the next inum value then we could simply compare against the last value in the tutorial stage in order to know if we've reached the end alternatively you can also handle the conversion back and forth using strings so for example string for the tutorial stage string and here let's grab the tutorial stage and call the usual two string function so this going to convert onto a string and now if we take this and we try to cast it to a tutorial stage if we do it that nope this does not work this is an error we cannot automatically convert the string into our enum so if you want to do this the correct way to do it is go inside the enum class this one exists inside system so we go inside of this one and then there's a parse or a tri parse so the only difference is this one returns a bone whether the par succeeded or not whereas this one assumes it always succeeds and you can see these also have versions with these angled brackets these are generics which I'm going to cover in more detail later on in this intermediate section so for example and since we know that the code perfectly matches the Eternal stage let's just do a parse we're going to parse onto the type of tutorial stage and we're going to parse this string okay so if we see this we should be able to see the usual stage two because we got stage one we increase it convert it into a string and then from a string back into our enum and if there it is correct then yet another thing you can do with inom is simply cycle through all the possible values and for that we can do for example for each for each inside the tutorial stage let's cycle through all the tutorial stages then in and now here you can't do for example tutorial stage. count. something no that doesn't happen that doesn't work so instead in order to get all the values you go again inside the inom class and for this one you can pass in get values and this one takes in a type so here to get a type we want to type tutorial stage but just like this nope this does not work in order to get the actual type object for that that we use the keyword type of and pass in our tutorial stage so yep like this it works so debug.log on this one and this should print out all of our possible elements inside our enum so let's just print some just separate from the other logs let's see and if there it is stage one two three and four all right so those are enums really useful in so many scenarios they are really easy to use and help you make your code a lot more readable and understandable hello and welcome I'm your Cod monkey in this lecture we're going to learn all About Properties in C these are kind of a mix between a variable and a function so you can sore some data and run some logic okay so properties these are actually pretty simple to Define so we Define them pretty much like a normal variable so we've got the access modifiers let's make it private then we have the type let's say of type string then we give it some name and the usual naming rule is for properties to use Pascal case meaning upper case on the first letter so for example player name and then if we just put a semicolon if we just do this then this is a normal variable it's not a property in order to make it a property instead of this we open and close a code block and now here we add two pieces of logic one is called get so let's do get and then a semicolon and then the other one is called set so let's set and then a semicolon and if that's it this is a super simple property and in order to use it over here in our static main function let's just Define this one as static so then down here in our main we can use it just like if as if it were a regular variable so we can go inside the player name and we can set it to something like Code Monkey so let's do this and then do a console the right line and let's print out the player name okay let's see and if there it is and does print out the name so pretty much the same as a regular variable however in reality this is not a variable in reality the C compiler is doing a little bit of magic in the background properties are really not variables they don't actually store any data directly so what we have defined here is what is called an auto implemented property in the background the C compiler is generating a hidden variable that does sore data for this property so we can also just manually do exactly that so let's do a private static string for the player name and again since this one is a variable we're going to use chemel case and then let's use it over here on the property so inside this code block for this get in this set we can actually expand upon it so for the get let's add a code block inside it and over here let's return our backup field so let's just return the player name the underlying one okay then for the set again same thing let's add a code block and for this one we want to set the player name so player name equals and then we use the keyword value so this basically going to be whatever value we assign to the player name so when we run this line of code it is going to run this sort of mini function and it's going to assign the value to whatever we assign here which in turn is going to assign it onto the underlying value okay so if we test like this and everything still works the same it still prints out Code Monkey so what we have over here is literally exactly the same as we had previously the C compiler simply builds all of this automatically in the background whenever we do a property where we have just a get in just a set and we do not Define any of these code blocks now here the get in the set these are pretty much functions which means you can write pretty much any code here for example we can do some validation so over here on the get function for example let's test if the underlying player name equals n so if it hasn't been set if so then we can return some kind of default so unknown if we do it like this and we erase the setting so we just have the player name uninitialized and if there it is now it does print out unknown so we basically added some extal logic onto our get function and when setting same thing we can also validate the value for example let's say this player cannot be named Code Monkey so we can test if the value if the value equals for example Code Monkey if so then either we can set the value to some default value or for example we can throw a new exception cannot name player Code Monkey by the way I'm going to cover exceptions in detail in a future lecture this is pretty much just an error message so if down here we can try to set the player name equals Code Monkey if we try doing this and if there it is right away we see an exception because again it is running our validation code and our validation code does not let usame this so usually this is the goal of properties which is how you can do something validation for processing either the get or the set function and one extremely useful thing you can do with properties is simply make different access modifiers for each of these now right now we made the player name we made this one private which means that both of these are going to be set to private and if instead we make this public if so then now both these are public meaning any class in our codebase can access either the get or the set however you can also add different accessories here for example we can leave the get like this in order for anyone to access it and we can make the set as private that means that this class can now access and set the value over here on the player name but other classes can only use the get so yep here we do see an error so I create the completely separate class named player and inside I'm trying to access the player name and modifyed nope I cannot use it because the set accessor is an accessible however if I do a console right line on this one if I do it then Yep this is perfectly valid code so this property can now be accessed we can access the get from any class anywhere in our code base but only this class can access the set so right now you might be wondering Okay so is this really all the same as just making a field with some get and set functions and yeah pretty much it is if we were to make a private static void set player name and receive a string for the player name if we do this and set the player name and then we have a private static string for the get player name and over here we return our player name so if we have this code and then up here and let's say we don't want any of this validation so we just have the basic Auto Implement property so just get any a set so you have just like this the property that we defined up here it is doing pretty much exactly the same thing as what we have down here we have a field with set and get functions and that's pretty much the same thing that we have here so these two pieces of code these are pretty much identical now I have to say that personally I'm not a big fan of properties simply because I do not like how they look like variables but act like functions personally I find that needlessly confusing if I want to store some data I want to use a variable and if I want to use some logic I want to use a function combining both in a strange way to me just seems really odd mod it seems needlessly confusing but that's really just me that's just personal preference a lot of people really like using properties in fact the official C documentation is full of properties so while personally I don't like them and don't normally use them it's not because they're bad it's really just personal preference so if you do like them feel free to use them in your projects for me the only place where I use properties is when I use the Singleton pattern I'm going to cover that in detail later on in the course but over here let me just quickly show you how the property helps Implement that pattern usually in that pattern you want some feel to store the Singleton reference but importantly you want only the Singleton class to be able to set that field while anyone else can get it so the property accessors are really useful for that so usually for that you make a public make it static for the Singleton pattern make it of the type that you are making the singlet ton so for example the program type then usually call it instance and then we have a get and a private set so y this way the access is exactly as intended by that pattern we have a public property with a public yet and a private set meaning this one can only be set inside of this class but any other class can get it like said I cover single tens in detail in a future lecture but I just want to show that this is pretty much the only scenario where I use properties for anything else I normally just make a regular field and if I need to I may get or set variables if I need to modify but again it's all personal preference so if you don't like properties then go ahead and use them okay so that's properties they are a really interesting mix between a variable and a function allowing you to handle store data and process it in some way when getting and setting hello and welcome I'm your kodm in this lecture we're going to learn about multidimensional arrays Okay so so in the basic section we already learned about arrays this is how we can store multiple pieces of data in just one variable we've got essentially multiple containers at each different index so now we can just go one step further and essentially make multiple dimensions of these arrays for example we can make it have two Dimensions so it has two axes and then each position instead of having just one coordinate it actually has two so for example on this array we can go on to position 0 0 and place some kind of number or we can go into position 2 three and place some kind of number go into 41 and draw something and so on so each of these positions works exactly the same as the elements in a regular array they can be set or you can get their value and this is an example of a 2d array so you've got a certain axis and another axis but you can have as many dimensions as you want you can have a 3D array 4D array 5D 6D or literally anything you want however this is also just one type of multidimensional array there are multiple types and multiple ways to build them so this is the syntax for building a regular onedimensional array so in then the square brackets in Array then create an array with some kind of size and one way to make a multidimensional array is to make an array with multiple Dimensions so to do that here when we Define array we include a comma for the dimensions so in this case we have two Dimensions so one on the left side one on the right side technically there's no limit so you can add as many dimensions as you want so here let's do a simple 2D array so we do that and then afterwards we just include the size for both dimensions and Y like this we have a two dimensional array on the First Dimension it has a size of five and on the second one it has a size of six this creates the array and then in order to modify a certain index we can just access it with the coord coordinates so go inside the interray and now on a flat array you would just put an index but this one is multidimensional has two Dimensions so we need to put the index for both dimensions so for example 02 and have this will access the element inside the array on position 02 you can use this to read the value or assign it to something else then when it comes to arrays you will eventually want to cycle through them and normally you would do some kind of four so four and I equals z i unless in the interray do length do this Plus+ so normally this is how you would cycle through an array how however now with a two dimensional array if we do this then this one this interray do length this one is going to return the total length so in this case it is going to return essentially 5 * 6 so we can do a console. right line to see so the interray length and if there it is the result is indeed 30 which is 5 * 6 so that's the total size the array when we have a multidimensional array in order to get the length of a single dimension for that we can access the function get length this one as you can see takes a parameter for the dimension so let's first cycle through all the elements in the First Dimension and then inside we can do another for Loop by the way I'm going to cover nested Loops in detail in the next lecture but yep just like this this is going to cycle through every element in the entire array will cycle through the First Dimension then the second dimension in order to go through every single element we can do a console d right line and print out the interray on position I and J this won't print out the value stored in that coordinate let's also just print out the I then Comm then DJ then something so we can see what we're seeing okay let's see and if there is we can see it all working so first checks position 0 0 then 0 1 02 and so on until it gets to one Zer so on and so on and all the vales are just zero because we just initialized all with zero but as you can see this is indeed cycling through the entire array through both dimensions of our multidimensional array alternatively for initializing the array contents we can do this note the difference between this syntax and the syntax we just want to mention so here we have some currently braces and then inside we have multiple pieces of curly braces one for each of the second dimension of the actual array and up here you can see the array being initialized so 0 0 has one two three then on one Zer it has like that one crucial important thing about these kinds of arrays and initializing it like this the shape needs to match so on the first one if we initialize this with four elements then the second one also needs to have four elements in order to have multidimensional arrays with differently sized elements for that we can use Jagged arrays which I'm going to cover in a little bit but before we get to that like I said there are multiple ways of doing multidimensional arrays this is just one way where you have a single array with multiple dimensions and the other common alternative is simply to have an array of arrays so instead of int and square brackets and having a common we have int and then square brackets open close and then open and close again this is basically creating a new array of arrays then we can do the usual cycle through it so for in IAL Z less than array. length here we can use length because again this is not a multidimensional array it is an array of arrays meaning it's an array and inside each position each element itself is going to be an array of multiple elements so we can do this i++ and we can go in Array on this index and inside it we create a new in Array of whatever length we want like for example six so basically what we have here is what we had previously when we had a multidimensional array with five and then six on the other dimension and then for accessing this one we access it by interray then access the First Dimension like say on position zero and then the second dimension let's say on position two so y this is how you set or read some elements from an array of arrays so this is also a valid way of starting multiple Dimensions instead of having just one array with multiple Dimensions you have multiple arrays of arrays and of course the same thing that I said a while ago about having no limit to how many dimensions you can have that still applies here so you can have as many arrays of arrays as you want so this code looks pretty insane but Yep this is perfectly valid code one crucial difference about these two types is basically defaults that they will use for example down here when we create an interray with multiple Dimensions when we do this by default all the elements inside of this array won't be on zero so like we see all the elements defa to zero whereas on this one since this is an array of arrays if we just cycle through the main array if you try to access this one so let's do a console do right line on this one so let's print out the array on this index let's do that and see what this prints out to see basically what each element of this array defaults you and if there it is the answer is essentially null we can compare this equals null and if there it is true so all of these elements are set to null so there is one big difference between array of arrays and multidimensional arrays these get initialized with every value at Z zero on whatever type you're using for the array whereas this one since each element inside of the main array since each of those is actually an object It's actually an array of something else because that by default the default value for some kind of array is going to be null because arrays are reference types as opposed to Value types which by the way I cover value and reference types what those are I cover those in detail in a future video and then another difference between these two types one thing that you can have with array of arrays but you cannot have with a multidimensional array one of those things is what is called a GI array meaning each subarray can have a different size down here when we Define the small dimensional array by default the shape of this array of multiple Dimensions the shape will pretty much be a rectangular size so over here five in one dimension and six on another one it will always have some kind of rectangular shape however in Array of arrays that does not have to be the case for example when initializing this we can set the one on index zero to be a new interray and let's say this one has a size of three then on the next one on ele index one we can say this one has a size of six then on index two we can say this one has 10 and so on so using an array of arrays technically each array inside the main array each of those can have whatever size you want as for what use case this would have for example imagine some kind of grid for a theater when you go to movies and select a seat usually different rows have different number of seats so that's an example where this kind of data structure could be useful you would have maybe three seats on the first row then six on the second one and so on so that could work it does have some use case although personally I pretty much never use them since in games usually things have some kind of rectangular shape things like an inventory or World usually those have some kind of rectangular shape as opposed to some weird Jagged shape now when working with multidimensional Rays we need to cycle through them just like we saw so let's learn about nested Loops in detail in the next lecture hello and welcome I'm your kmy in this lecture we're going to learn about nested Loops okay so let's see what they are they are really simply just a loop within another loop so for example let do a for Loop for in I equal Z let's say less than three I ++ so a regular for Loop and then inside it we can write another for Loop let's say in J equals z J less than 2 j++ and by the way usually the convention for these iterator variables usually use the variable I then you use J then if you need more you need k l MN and so on that's usually the standard convention but it's not a requirement it's really just a convention so these can be named whatever you want but in general I and J are very commonly used so over here let's do this let's do a loop inside another loop and now let's print out the I and J to see exactly how this code is running so let's print out I then a little comma and then J okay let's see and if there it is so we start off with an i of zero and a j of zero and then we have an i of still zero but then a j of one meaning that for each time this Loop is running this one is going to run as many times as this Loop is meant to run so it goes inside this inside this runs this line then when this one ends goes back into this for Loop and runs this line again then this one reaches the end so that is why this one ends and again goes back into this one which again runs this Loop starting from the beginning and runs more and more and so on so here it is running 0 0 0 1 1 0 1 1 two 0 and 2 1 the important thing to remember here is the code execution order meaning for every time the outer loop runs the inner loop is going to run multiple times two times in this case also remember what we covered in the basic section about variable scope if you define some kind of variable inside this in Loop like a int H equals 5 if we do this and down here you try to access the age nope that does not work if you define something inside the scope of this inner loop it does not exist outside of it and here we have one Loop but technically we can have as many as we want again the same logic for every time that this Loop runs any Loop inside of it will run as many times as those run as you can imagine if you do a ton of Loops within other Loops if you do that it becomes really hard to understand the logic the deeper you go so usually just having one less Loop in most cases that is the most you should do then we already saw these briefly being used in the last lecture covering multi dimensional arrays that's a very common use case so here it is that same code so we've got the outer loop going through the First Dimension and then we got the second inner loop that one is going through the second dimension and by doing this this is going to cycle through every element inside of this multidimensional array then on Loops there are two important keywords one is called break and this one breaks out of the innermost Loop so for example if we don't include the break let's see how many times this prints with the value on J and if there you go the value on J goes from 0 to 1 0 1 and so on but if we add a break over over here and if there it is now the J only goes to zero and immediately breaks out of that inner loop now the important thing to note here about break is how it only applies to the innermost Loop so this one does not break out of the outer loop as you can see the outer loop still run 0 1 two and so on so break only affects the innermost Loop if you do want to break out of the uttermost loop if so you can Define some kind of ball break from Loop you set it to something like false then inside this one you do some kind of logic that would eventually set this one to true and then down here you would test that and if so then call break and let's see and yep now this one does go inside as soon as it goes inside sets a break to true and breaks from that one so breaks from the inner loop and once this one is through it also breaks from the outer loop now the other important keyword is continue this one continues or pretty much skips to the next iteration of the loop so if we write some kind of code after this continue so let's do a light right line and write something like this even Visual Studio is telling you so this line is slightly faded because it will never run so unreachable code detected that is because as soon as the code gets to this continue it is going to ignore everything afterwards inside this Loop and go to the next iteration of this Loop so if we run this and if there it is it runs through every single element so the J is only 0 1 01 and so on but note how our second message this one did not ever show up if we were to put this inside some kind of if let's say if I equals z then continue so basically on the first I when the I is zero then it should not print this message but on the other ones it should and if there it is so once on zero it is going to continue and ignore this line but on the others it is going to run this line and again again same thing as previously note how this one only applies to the innermost Loop even when we're running our continuous over here on I of zero note that the I still runs all of them so 0 1 2 so again always remember that break and continue those only affect the innermost Loop now I should also say that break and continue are not specific to just Nest Loops you can use these keywords with any Loop including just a single regular for Loop or some kind of for each for example if we have some kind of player class so for example here's some simpar code so we've got a basic player class then we create a list of type player then we create a new special player we add that special player onto the list and then three random players then we do a four each inside of that player list cycling through every single one of them and then we check if that one is a special player if so let's continue if not let's write the name so if you do this we should be able to see the print of only three players and not the special player because that one will be skipped over here on the continue and if there you go exactly that three players and no special player now also on the topic of nest and Loops here we have a four inside another four but you can list any Loop of any type so for for example over here we can have a four inside another four and then inside both these fours we've got our 4 in so this perfectly works or we could replace this with a while or do while so literally anything works so as you can see neston Loops can be really useful especially when cycling through multidimensional arrays but if you go too deep if you Nest too much it can negatively affect code readability if that's the case consider whether you really need to make that Nest Loop and if so perhaps consider making a function that in itself has a loop then within some kind of other loop you just call that function so just be aware that Ness Loops can become messy very quickly so do be careful to use them properly and only when needed okay now that we've learned some more advanced us case for Loops we are ready to learn something that some people find quite complex which is recursion so let's learn that in the next lecture hello and welcome I'm your Cod monkey in this lecture we're going to learn about recursion which is a different way of doing Loops or just running logic multiple times okay so recursion this sounds like a really fancy word but in terms of logic it's really super simple it really just means a function that calls itself so for example over here let's make a function so private static void let's call it test recursion so we have this function which does some kind of thing and then inside this function we call itself and up here we call the first function so y That's it this is recursion it's pretty much just a function which inside calls itself now right away you might be able to tell a big issue here you can probably already tell that this is going to be an infinite Loop since this function will call itself for infinity and actually if we try to run this code we actually get a fun piece of trivia yep here we have an infinite Loop that eventually ended and it end with this error a stack Overflow exception and Yep this is where the famous website got its name basically as you call functions your CPU stores references to those functions in something called a call stack that's a stack of all the functions that have been called in the current process the CPU needs to know that so that it knows that when a function ends where should it jump back to but of course memory has the limit so if you call a function within a function way too many times eventually you reach that maximum which then caus the stack to loop back which in turn is called a stack Overflow so with this code we have an infinite Loop not very useful but like we already saw in the last lecture and in the beginner section Loops can be extremely useful and recursion is really just one type of loop so with recursion we can do literally anything we can do with normal Loops for example let's write a while loop let's increase some kind of number one by one until five so here we have a simple while loop so we Define number of zero and while the number is under five we just incremented so that's it pretty simple now let's do the exact same thing using recursion so on this we have a function and really since recursion is all about a function calling itself all we really need to do is pass in our variable as our parameter so we can just receive an inert number and inside do number Plus+ however just like this it won't work since like we saw on the electr on scope and functions function parameters are actually local variables so when we call this function with this we're working with a copy and not the original data so to get some kind of result back from our function let's simply set it as our return type so let's return of type in and then here we can do our logic and basically then do return number in order to return the final number so now when do we want to return the final number so now let's do the same condition that we had up there so if number is under five so we do if the number if number is under five if so then we're going to call test recursion again and we're going to return it with number + one and in order to get the data back let's call it return on this and if not if the number is above or equal to five if so let's just return the regular number so just like this let's just give this a proper name so let's rename this to recursion increment then up here let's call the same thing and we're going to start off by calling it with number zero and let's do a console. right line on this to see the result so let's see the result on this one and also a console. right line on the other number made with the regular W Loop okay so let's see if both these do return five and if there it is they both return five so we both have this logic that this one is going to run this logic multiple times and this one is also going to run the same logic multiple times so here as we call this the first time number is going to be zero and if number is under five if so then this one is going to return the result of this function and this function call will pass in the number so 0 + one pass in number one so once again that is going to go inside this function now with the number one which again still under so it's going to return another call of this function which again with the number 1 + 1 equals 2 and so on and as soon as it gets a five just Returns the final number so basically here we are stacking multiple function calls on top of one another and when the final one returns they all basically return and the call stack collapses and we end up with the finnal final result then if we wanted instead of having a hardcode maximum over here we could have another one as a parameter so an end for the number Max so we have that and we receive it here and we just pass it along the same way onto the next function call and then we could also have a parameter for the incrementer so increment amount so we have this one instead of increasing by one we increase by the increment amount so then over here let's put it five and then one and over here let's also pass in the incremented amount and have same result 55 and what we have built here is essentially the exact same logic as some kind of for Loop if you remember the for Loop has some kind of initializer iterator variable then it has some kind of condition usually some kind of maximum number and it increments by a certain amount so what we have here is literally the exact same thing as a for Loop except it's being handled with recursion so all the logic you can do with any kind of loop you can do with recursion this is really just an interesting way to handle running logic multiple times by simply being very clever about how a function can call itself multiple times now I should also say that personally I'm not really much of a fan of recursion in general I find it needlessly confusing I much prefer to have a simple for Loop where I can very easily see the iterator and the end condition as opposed having to look at the parameters for a function and trying to guess when it will stop calling itself so personally for me I pretty much never use recursion I always use just regular Loops I find those much more straightforward but recursion is a valid option so I definitely wanted to cover it especially if you're into advanced mathematics if so then you might actually like it since mathematics has a lot of this kind of stuff if you like that then perhaps for you recursion might be much more natural much more intuitive than working with regular for Loops just always be careful the same issue with for Loops which is always be careful not to end up with infinite Loops hello and welcome I'm your kod Maki in this lecture we're going to learn about one of the most useful collections the dictionary okay so dictionaries are a super useful data type for storing multiple pieces of data and doing so in a very organized way dictionaries are all about key value pairs meaning that the dictionary itself is a whole container and inside that container you store various keys so like some key for stone some wood and some gold and then for each key each key has a corresponding value and then that value can have whatever that you want importantly is both the key and the value both these can be of whatever type you want so for example in some kind of game starting the resource amount the resource type itself can be the key and the amount that you're currently holding that one can be the value if you were to build something like that using an array or some kind of list if so then you would have to memorize that for example index zero that one refers to Wood index one refers to Stone index two to gold and so on so you'd have to memorize what type each index belongs to whereas with dictionary the key itself can be very descriptive about what value it stores you can use a proper name or a proper object reference that makes a lot more sense than keeping in mind what index belongs to what now to build a dictionary this is actually super easy we just type in dictionary and then we open up the angle brackets now this syntax these are generics kind of like we use on the list I'm going to cover generics in detail in a future lecture in this intermediate section so we open the angle brackets and then we have two types the first one is going to be whatever type we want for our key so for example let's define enum for that so private enum for the resource type so we have this and then inside for the values let's go with stone then wood then gold okay those are the values for our resource type and over here we can use that resource type itself as our key and then for the value type let's say we just want to store the amount so let's use a simple int so let's let's name this resource type amount dictionary and then we can simply construct it so just new dictionary of this type okay just like this so this is going to create our dictionary but so far it's going to be just empty to add a key value pair we go inside the resource app amount dictionary inside our dictionary and we call the add function over here we need to pass in the key and the value so let's pass in resource type let's say Stone then for Value let's say 56 see if this is going to add the Key Stone onto our dictionary and it's going to link the value 56 with that stone this is how we can add a value and then for reading a value we do it pretty much as if it were an array so we use the square brackets and inside here we put the type for our key so in this case our resource type do stone so if we do a console downright line on this one let's see any y it does print 56 okay great now one key point about dictionaries is that the key itself this one must be unique so if we try adding a value on the same stod key if we try adding some kind of value nope right away we have an error an item with the same key already has been added so remember that each key must be unique if you want to update the value we can just access it so as if it were an array and then set it to something and Yep this will work now when getting a value if we try getting a value that does not exist so if we try going to this on the resource type. wood if we try doing a console. right line on this one yep here we have another error key not found exception the given key was not present in the dictionary so if you don't know whether a certain value exists you have two options first you can just check to see if it's contains that key so access the dictionary and call contains key then pass in the key so this will return true or false if this key exists inside the dictionary or not that's one approach and the other one is to access the dictionary and call try get value this one like the name implies tries to get some kind of value for some key so the first parameter is going to be the key so let's say resource type. wood and then the second parameter this is the first time that we're seeing this this one is not just an INT value parameter it is an out in this means that it's an output parameter this is a more advanced topic that I cover in detail in the advance section for now just know that this is an output parameter so this function is basically going to return both so it is going to return true or false true if the dictionary has this key and false if it does not and if it does have then it's going to Output whatever it is in here so let's Define a variable for the wood amount so if it does have wood then it's going to store the amount on that one so then we can see if this one does have this value if so then let's print out the W amount except we didn't add so this should not run and if there it is that doesn't run but if over here instead of assigning Stone let's assign to Wood and if there it is now it does run again if you're not familiar with this output syntax don't worry about it I'm going to cover it in more detail in a later lecture if you do use it just know that it has this syntax also like we saw we can modify values so we can go inside this resource type. wood and set it to something to modify it so this works but this also works for simply adding values so instead of calling that add you can just do it like this and if it does work and does add that value and of course since we can add values we can also remove them so we can call remove and then pass in some type of key so let's say resource. wood so this should remove the key so then this code should not run and if there is doesn't run so here we are creating a dictionary and then afterwards on a separate line we are assigning values but like we have with arrays and class and so on we can also initialize the object directly when we create it the way we do that is we open and close the Cur braces so the same as we do to initialize some kind of array or list and then inside it we put whatever element we want to initialize inside this dictionary but remember dictionary is a key value pair so we need to somehow Define a key and a value pair over here if we just do resource type. Stone and then 10 if we just do this nope this is an error the correct way to define a key value pair is with another pair of curly braces so put this one inside open and close just like this and then if we want to initialize more we can just start with wood and something and so on now importantly here pay close attention to the syntax so we've got currently braces on the whole dictionary and then again for each individual key value pair now one common thing you're going to do with dictionaries is simply cycling through them for that we can just do a four each directly on our resource type dictionary and for this one the iterator variable will be a type key value pair simp like this and then inside this one we can access the key or the value so let's do a console. right line this one. key and let's do a colon and key value. value let's get rid of this code and let's test and if there is second through the entire dictionary and prints out Stone and then the amount alternatively instead of sing through the dictionary itself inside of here we've got a keys collection this just basically going to scroll through every single one of the keys so over here you would have just resource type just resource type this would be the key and then you could simply access and print out the resource type and then go inside the dictionary on this type to see the amount and if there is same result so this is the other type for each and also finally you can also cycle through just the values and on all of this always remember that these are really just key value pairs meaning it's up to you to Define what value you want to use for the key and the value it does not have to be just simple types like ins and enums for example the key can be some kind of player class and the value can be some kind of weapon class that would be perfectly fine so just remember that it doesn't have to be just simple types you can use whatever type you want for the key and the value now here's a bonus tip specific to Unity let's say you want to build some kind of resource manager something like this so you have a resource manager class and inside You' got a dictionary of resource type and an INT but then you want it to be preset with some amount that you want to set in the editor but the issue with dictionaries is that Unity does not serialize them so even if we add serialized field private even if we do this here in the editor nope we do not see it the resource manager has no Fields nothing shows up in the editor so instead here's a neat trick you can do you can create a custom class and on that class you basically use the key value pair so here I've got a resource type and an INT amount now importantly we need to mark this type as serializable in order to show show up in the editor and if we do and then we just make a list of this type if so then Yep this one does now show up over here in the editor so we can set it to something and then we have all of our elements of our custom type so we can set all of them to whatever we want so there it is all the various values all the various keys and then on this same script over here on the awake we just create the dictionary we cycle through the list that we exposed in the editor and we just go inside the dictionary on that type and set it to that amount then we can just print out the concept dictionary and here in the console we can inde yep we did create the dictionary and we did initialize it with our data all right so that's the dictionary it's a super useful data type really helpful when you have two pieces of data that can be connected like a key value pair so this is absolutely essential in things like resource management or linking any kind of data together with one another hello and welcome I'm your Cod mon in this lecture we're going to learn about some other collection types like cues TXS and a bunch more okay so in the beginner section we already learned about arrays and lists then in the last lecture we learned about dictionaries honestly those are really the only collections that I normally use myself but there's still a bunch more that can be useful in certain scenarios so here let's see them one simple one is called the stack think of it like a stack of papers you can place papers on top so you can push them and for grabbing a paper you can only grab the one that is on the top in this case on the stack grabbing simply means pop so you can push and pop elements this is what is called a first in last out collection or also known as f here in the code the way we do it is super simple we just create a new stack this one takes a generic type so similar to the list so let's say a stack of strings let's call name stack and we construct it then on this one we can call the function push in order to push values onto the stack so let's push the string Code Monkey then let's push the string for Iron Man and let's push the one for SpiderMan okay so with that we push them and now if we go into the stack and we call Pop this one is going to remove and return the object on top of the stack so like I said this is a fellow collection meaning first in last out so ask yourself what do you think this will return this is the first element that is added so technically this is going to be the last one out so let's do a console down right line on this okay let's see what this returns and you correct this does return SpiderMan like I said first in last out so we first put Code Monkey so this means this is going to be the last element that we're going to grab and when we pop we are going to grab the one that we last put on there which is going to be this one and eventually if we don't put up anything so if we comment out all of this and we try doing a pop yep here we have an error the sack is empty so to avoid that we can use triy pop which will try to get an element if it exists and if you want to just look at the last element without removing it we can call Peak okay so that's a stack another related collection is a q this one the easiest way to visualize is some kind of queue of people so the first person that gets added onto the queue is going to be the first one that gets out so this one is a fivefold collection first in first out the way we build it is pretty much the same as a stack except this one is a que so then let's make a queue of string so for the string q and let's construct it so a new one and build it then on the string Q in order to add elements we call in Q so again same thing let's ass in Code Monkey then Iron Man and finally SpiderMan okay so we queue all of those and now on string Q we call DQ in order to grab the element this one again like the pop that we saw previously this one removes and Returns the object so if we do a console. right line on this one again Q is fifo first in first out so let's see what this one returns and if this one returns Code Monkey which was the first element that we add so some practical examples a q can be useful in something like a tycoon game where you have literally a queue of people like for example in my own game battle round Tycoon when there's a queue to join each Arena and for the sck a great practical example is how this can be very useful for making some kind of undo system so maybe something like a city Builder you can push onto the stack the action to place a building somewhere and then to make an undo you simply revert that action which would eventually demolish that building now importantly you always want to do it based on the last building that was built and not the first one so these two collections definitely have their own use cases although like I said normally I just use lists I've built both these systems like a q for a tyen game and an undo kind system I've built both of these using just list remember how on a list you can access the list on index zero and call remove that to remove it from a certain index so similar to a que or you can also just access it the last element on the index the last element on the list similar to a tack so personally I normally do all this custom logic using list but if you like these two collections can be quite useful so just remember they do exist next collection is what is called a hash set this one allows you to store a set of elements so let's make a hash set of string so for the string hash set let's construct it then go in the string hash set and this one we call add to add elements so for example add the element code monkey and Yep this one does work however one important thing about this type the hash set the important thing is that all elements have to be unique so like this it works but if I duplicate it and now I do a console. right line and let's print out the string hash set. count in order to count all the elements so we're adding two elements and then counting it so let's see what this returns any if this one returns a one because again we added a duplicate element so it actually didn't actually added so you can add elements you can remove elements and you can also do a union to combine multiple hat sets so the hashset can be useful for some kind of elements where you always want it to be unique so maybe a player ID so for those kinds of use case it can be a useful collection the next one we have the sorted list this one pretty simple like name implies this is the same as regular list but it gets sorted automatically so you can make a sord list of int another collection is a sorted set so this one pretty simple same thing it records a set of elements and it is constantly maintained in a sword order alternatively you also have a sword list this one has a key value pair then you have the sord dictionary and so on so there's a bunch of collections that serve various purposes like I said personally I really just sick with arrays lists and dictionaries I normally don't use any of these but it is good to know that the language can do all these things by default maybe you have some use case for which the queue is perfect so definitely make sure you know these collections exist hello and welcome I'm your codm in this lecture we're going to learn about the prams keyword that we can use in a function which then allows us to call it with any number of parameters okay so let's make a function to see it so let's make a private static void let's call it print player name and receive a string for the player name then over here just a console. right line on the player name so that's it super simple just a regular function like any other and up here we can call it and call it with code monkey and hope it does work it does print great but now let's say that I want to support two player names I want both of them I want support for both one player name and two player names so in order to do that I need to copy paste this and make another one with player name and then player name two see if this works but now I have two functions one with one parameter and one with two parameters and now let's say I want to support three parameters so again I need to make another function duplicate a ton of code and so on so right away you can see the issue this is basically the problem that pram solves so for that let's make just one function and up here let's call it to two parameters and right now yep we have an error because this one can only take one parameter so now here for the parameter let's write the keyword params we write params and then we write write the type for the parameter and in order to use with params this type needs to be an array so let's make a s array and for the player name array and up here let's just do a console. right line on this one. link just to see how many we call and right away we can see we have no errors up here so calling this function with two parameters does work let's run it and Y it prints out two and now let's call this function with just one parameter and again no errors and yep now it prints out with one also if we pass in with no parameters and yep we do have an empty array so that's it super simple you can just add the prams keyword and that way now we support any number of parameters this only has two requirements the first one is that the type over here needs to be an array for example if you make string it does not work if we make it just ring then no it does not work if we make an array of multiple Dimensions this one also does not work so it needs to be an array of some type it can be string it can be int it can be pretty much anything and the second requirement is that this one needs to come at the end so afterwards if we Define an INT H nope does not work here we have an error and the a says here a params parameter must be the last parameter in a parameter list so if we want to combine a params along with regular parameters we need to make sure the regular ones come before and the params comes after this way now yep up here we can type in an INT and then any number of strings and yep all of this does work that's it really simple and sometimes quite useful so anytime you have some function where you would like to receive any number of parameters whenever that happens always remember to use the param keyword hello and welcome I'm your kodm in this lecture we're going to learn about how we can use optional parameters in a function meaning parameters that we are not required to use okay so here is a normal regular function it supposedly spawn some kind of unit so it takes a spawn position the type of the unit the spawn rotation and some kind of Health amount and then to call this function we call it as usual so we call it and pass in all of our parameters if we run this it would work spawning unit of type melee with health 56 on this position this rotation but now let's say we want to spawn a ton of units and we don't want to be forced to pass in all of these parameters especially for example if some of them are going to be default to some amount there is going to be copy pasted all the time let's say for example the only thing we want to care about is the spawn position and then it will default to all the other ones so one option would be to Simply make another version of this function so let's make another one and let's make another version that only takes a spawn position and then in turn that one calls the other version passes in the spawn position and then passes in defaults for all the other ones so let's say melee turn. identity in order to have the regular rotation and let's say 100 Health amount so we can do this and now do this and spawn on new Vector three of 1050 something like this and if there it is we have no error and running the code yep it did work it did use those defaults and the 1050 position so this works this is one valid option but we have another option where we don't need to Define multiple functions we can simply use optional parameters to use them it's really simple so we just have our function with our parameters and then after the parameter we simply write an equals and then assign some kind of default value so for example for the health amount let's default it to 100 and now up here when calling this function we need to include all the other parameters so for this one let's include the unit type and let's include a quaran rotation but now we don't have to include a health amount so like that this one has no Health amount and if we run yep the health amount defaults to that 100 default so it's really this simple you just set equals and then some kind of default value we just have a few simple rules for how we can use this first is how the optional parameters these have to appear after the mandatory parameters so for example if here on the UN type before the Quan if on this one I Define an optional parameter like this no here we have an error it is saying optional parameters must appear after all the required parameters then another rule simply has to do with default values also by the way like I mentioned in the beginner section the compiler doesn't really care about new lines so if you have something with tons of parameters you can just place them all in a new line that way it becomes a little bit easier to read so like this okay so like I said the second rule simply has has to do with default values and the rule is how default values need to exist at compile time so here we cannot construct an object we cannot do new quion and then construct a new quion with something nope this does not work like it says here default parameter for Value spawn rotation must be a compile time constant so we cannot do this but we can use for example the qu. identity this is a constant and yep so we cannot use that but we can use the default keyword this will basically use the default value for that type so in the case of a quan which is a struct it is simply going to initialize that struct with everything at zero so for this struct we can use this and for the vector 3 same thing we can use that and for the unit type this one is an inome so we can just sign a default value and like this and everything works alternatively we can also use constants which is something that we're going to cover in a few lectures so you can define a constant and then you can definitely use that constant as a default value so optional parameters need to have certain defaults in order to work and then over here for passing in the parameters since we marked all those as defaults we can call it just like this and yep the code runs it works and works with all the defaults then alternatively we can pass them in one by one so for example if we want a spawn position let's put some kind of Spawn position and then for the unit type let's say we want like this so yep we just assigned two parameters and yep it did work but now let's say the only parameter that I want to assign is just the health amount so for that I go up here and I just write some kind of in so just 56 and no this one obviously has an error because argument one it expects a vector three not an INT so just like this you need to pass in all the parameters in order however you can actually pass them without being in order and for that we really just need to write the name of the parameter so in this case the parameter is the health amount so we write that and then a colon and yep just like this it does work this is basally calling the function and assign the health amount parameter to this value and on the other ones since we didn't assign them these Remain the defaults and if you're running the code we do see with health of 56 also by using the same method we can pass in parameters in any word you want so for example the health amount then let's pass in the unit type so unit type and unit type. something and Yep this is definitely valid code as long as I write the name of the parameters and then callon then give it a value everything does work all right so that's optional parameters it's quite a useful feature to help you avoid having tons of function versions for all kinds of parameter combinations hello and welcome I'm your Cod monkey in this lecture we're going to learn something very important the difference between value types and reference types if you don't know the difference then at some point in the future you won't go crazy because you think something is behaving as a reference when it's behaving as a copy so in C you have several types and mainly they are either value types or reference types reference types they store references to their underlying data whereas Val types they contain that data directly some examples of Val types are the symbol types like int float Bull and so on these are all value types and for reference types these are things like class object arrays and strings however importantly struct is a valid type we're going to cover strs in detail in the next lecture they look similar to classes but this is the one big difference between them strs are value types and classes are reference types and over here as you can see arrays are reference types even if the underlying data if you're making an array of int ins by themselves are value types but if you make an array of int the array is going to be a reference type and then strings are a bit of a special use case in that they are technically reference types but in some cases they behave like valid types so the big difference is shown down here with reference types you can have multiple variables and you can have all those variables all of them pointing to the same underlying object whereas with value types any variable you make with some kind of value if you then assign that variable to another variable you are making a copy instead of a reference to the original value another difference is how reference types can be null whereas value types cannot so for example if you have some kind of enome for your weapon types if the player does not have any weapon you cannot set it to null enums cannot be null neither can inss floats balls and so on so here let's see some code first let's define an INT which is a simple value type okay very basic just the variable named a and contains the value seven but now let's make some kind of class which is going to work as a reference type so here let's make a class call it my class and inside let's just expose an INT a okay and now up here let's create a new my class so my class equals a new my class and then let's go inside that one and set the a to some kind of value let's say seven and then let's make another my class call it my second class and now let's assign this one to the my class and over here we go inside the my second class and modify a to a different so here now we have two different variables we're initializing the first one like this then we're assigning it to the second variable and then we're modifying the value inside of the second variable so if we print out over here the my class. a what do you think this will say so let's do a console. right line and print this out let's see if it says seven or five and if there it is it does say five again that is because classes are reference types so over here even though we have two separate variables they are both pointing to the same underlying class so they're both pointing to the same underlying memory position they're both pointing the same actual object both them are referencing just a single instance of our my class so by going through either of these we're actually modifying the same underlying object we do not have two objects we have just one and two references to that same object so when we modify this one we're not modifying it just on this second object but since this one has the same reference as this one both of them are modifying the actual underlying object so by modifying either of them we are modifying the same underlying object now let's look at this exact same example but using our ends which are value types so you've got an INT a of seven then let's define an INT B and let's assign it to the value of a and then let's go inside B and set B to something else let's put it on five and now let's do a console. right line on a and let's see what this one prints so we print seven or five and if there it is the result is seven again this is because int int is a value type and not a reference type so over here we're defining a variable a and assigning the value seven and then we're assigning B and then we're defining B and assigning it to the value of a but again since a is a value type this is going to essentially copy the data that is currently stored inside a so after this point we have two variables and each of them holds a copy of their data and then over here when we modify B that is only modifying the copy that was created in here and not modifying the original data that we have in here this is the one big difference between valid types and reference types is how up here we are working with a reference and we have two references that both of them point to the same underlying object whereas down here we have copies so we have one copy here one copy there and by by modifying the second copy this has no relation to the original data now the scenario that is most important to know this difference is when working with structs which we're going to cover in detail in the next lecture for now don't worry too much about what they are I just want you to see the difference so a struct is made pretty much the same way as a class we just change the keyword into struct and let's name this my struct so like this and up here we can write literally the exact same code but write it with a struct instead of our class so up here use my struct then over here here this one is my struct and my second struct and then we modify this one here and we print out the my struct a okay so here's our test literally we have the same code down here as we have up here the only difference is one code is working with the class another one is working with the struct so let's see the difference between these two ending up with the exact same code we have two different results that is exactly because of the difference between value types and reference types the class has a value of five and the struct has a value of seven that is because the class up here again both of these are referencing the same underlying object so when we modify the second one we're both modifying the same unlying object so when we print out the data stored in the first one again same object so this one prints out five and yep we do have five and then down here when we're structs structs are value types so over here we create a brand new struct but then on the second one when we assign it we're actually creating a copy of the data so now this one this one has a completely separate copy that has no relation no reference to the original data to the original myru so when we modify this one we're only modifying this copy and not touching this one at all so that is why on the Str the result is seven which is the original value that we set over here because when we modify this we're only modifying this copy and have no relation to this original data now this difference between Valu reference types is also very important in functions for example private static void my function let's do some kind of test function and here let's receive of type my class another one of type my struct then let's just go inside and put it on something so my class and my struct let's modif if I so do the exact same test as previously let's just comment out this testing code and then over here let's create a my class my class let's create a brand new one then let's put my class set the a to 7 and create a new struct we also set it at seven so both them have the same value in their a field and then we call my function pass in our my class and our my struct and then let's do a console. right line on the my class. a then some space and my struck. a okay so again let's see what happens and yep there it is my class has a value of five and my struct has a value of seven again that's the same difference between valid types and reference types it's how when we call this function and we pass in our values the class is going to be passed in as a reference so as we modify this one we're actually modifying the reference so we're modifying the underlying object that was sent into this function whereas for the struct the function receives a copy of the data so the copy that we receive over here inside the function this has no relation to the actual data defined up here so so whil inside this function modifying this class modifies the actual data outside of it but modifying this struck only modifies the local copy also what I mentioned while go about how AR raise our reference types so for example let's do another test so let's make our function take in some kind of int and then an interray then over here let's modify the value of a and let's go inside the interray on index zero and let's modified value okay so now up here let's define some kind of int and let's define an INT array let's construct an interray and just put a value on there okay so now we call my function pass in a and the interray and now let's do a Conant out right line let's print out the A and then print out the interray on index zero okay so again let's see what this does and if there it is same thing the int was not modified inside the function but the array was that is because inss are value types so this one is passed in as a copy but in arrays these are reference types so when we pass in an interray onto our function we're passing in a reference to the original data so when we modify this inside the function we're modifying the actual original data and also since we're on the topic of value types and reference types I mentioned a while ago how value types cannot be null so you cannot Define an INT b equals null so this is not possible we have an error cannot convert null into n because it is a nonnullable value type however if you really want to do this you can do it instead you just have to use a custom type called nullable and with this you can make any value type like ins BS floats and so you can make any of those into nulls and this is something that can sometimes be useful I cover nullable in detail in a lecture in the advance section okay so that's the differences between Val types and reference types be very very careful with this difference it might sound like I repeated myself way too much during this lecture but that's because this is really so important always keep in mind whether you are working with a copy or a reference one of the most important ways to see this difference in action is in the difference between classes and structs so let's learn about strs in the next lecture hello and welcome I'm your codemy in this lecture we're going to learn all about structs these are structures of data that are similar to classes but also a little bit different okay so structs like I said are pretty similar to classes in how you define them you literally just swap class for struct so for here for example let's make a class named player right now this is a class and just by swapping this into struct yep now this one is a struct so that's it super simple however just doing this has some really important implications the main one is how classes are reference types and strs are value types which is what we covered in the last lecture this means that when you use something as a class like a class parameter it gets passed in as a reference whereas with a struct it gets passed it as a copy so here we can do a simple quick test make a player struct and a player class then just run this code just making the usual start function because over here I'm working in unity let's make a private void test function test function struct and another one test function class okay so here is some code we create a new struct and new class and we assign a field in set of them to the value one then we have have two functions and these functions these do the same thing so they just set that field into two and then we do a log so let's see whether this one keeps the number one or whether it keeps number two any like the log says here the struct keeps in number one whereas the class keeps in number two again that is because struct is a value type meaning these are passed in as a copy so over here we are modifying the copy and not the original data but classes are reference type so when we modify a class inside a function it modifies the actual position memory the actual original object so the reference type gets changed but the value type does not get changed this difference is really extremely important so I truly hope you fully understood everything in the previous lecture if not go back to it and rewatch it it is really important so you don't get to confused like I did many times before I memorize this this is one of the main differences between structs and classes how classes are reference types and structs are value types in general structs are mainly used as just data containers meant to organize your data the simplest example is really just the vector three type inside of unity so we can inspect this one so let's right click and go to the definition and up over here we do see this is a struct and it's a struct that pretty much just hold three components so x y and Zed so rather than having three separate Fields whenever we want some kind of position we just make a struct that in itself has these three Fields whenever we have several pieces of data that all of them make up one logical unit then perhaps consider making that a struct however again remember how it's a value type for example in unity you cannot even directly modify one of those components so if I set the position do 5 equals something if I do this nope it does not work now technically this is more related to the fact this position is actually a property and not a variable but still the reason why it's a property is because it actually copies the data and sends it over to the back end of the engine itself so in unity when you need to modify something you need to assign it to a new Vector 3 so basically you need to give it another copy of another piece of data in order to actually modify it so usually structs are used in an immutable manner meaning they never change once you create a struct with a certain value usually you keep it at that value however that is not an absolute requirement it's really just a good convention to follow for example the Vector three struct so let's do a position Define it as something 10 21 something and like this this struct inside actually contains the normalized function and if we do this and then do a debug down log on this position let's see Yep this function does indeed modify the underlying data so in theory strs can indeed be mutable they can change but in order to avoid confusion you should probably avoid this as much as possible you should probably always treat your structs as immutable just following that one simple rule will make things much simpler to understand now strs like classes they can have Fields they can also have functions like we saw here the normaliz and they can even have properties one big difference is how they cannot inherit I talk about inheritance in more detail in the next lecture but basically with a class you can make it inherit another class so po class base class and then poly class for some kind of unit class and this one can extend Base Class so this works this is valid code but over here on this player struct if we try extending Base Class nope and error struct s cannot extend classes the one thing they can do is actually what this error message is telling us they can indeed Implement interfaces I will also cover interface in detail in a few lectures then strs can also have Constructors just like classes however in most C versions you cannot have a parameterless Constructor so over here public player just like this with no parameters and nope we have an error so as you can see parameterless Constructor is not available in C 9 but if you're using a letter version this is possible instead of defining it yourself it always has one by default so up here we can do new player and Yep this works so for the constructors if we Define any of them it has to have some kind of parameter so usually on the Constructor you add some kind of thing to initialize the acttion struct itself and then one common error with Constructors is this one right here which is all of the elements all the fields must be fully assigned before controls returned to the color so if we Define a Constructor like this we must initialize all the fields so over here this. a equals a and yep now it does work so every Constructor you make has to initialize every single field within that struct again this has to do with difference between value types and reference types as soon as you define something of struct type like for example some kind of variable like a kind of player variable like this as soon as you define it like this if you define it like this it's an error because it is uninitialized but we can initialize it we can just use default this is a keyword that pretty much Returns the default of whatever type we have so if we do it like this let's see what this says and yep the default of a struct is indeed a struct and then we can even go inside of it so let's print out the A and yep so it creates a struct and initialize the variables all of them at zero so that's what default does initialize everything with a zero value however if we now make this into a class and if there it is default value for a class is null and since it's null that means it has no object so we cannot access anything inside of it again goes back difference between value types and reference types reference types by default are null whereas value types they always have some kind of value so when you make a struct you can create a new struct like we saw by using the default parameter on list Constructor or we can use any custom Constructors or we can just make the struct and over here Define any kind of thing so a equals 2 and Yep this is valid code for initializing a struct one more important thing about structs is once again how they are related to Value types and not reference types so one big difference is how they are sored in the stack instead of the Heap these are two different positions in memory one is much more efficient than another I actually have a nice story about this in my first steam game Survivor squad for the implementation of the fog of war the world basically has a ton of tiny quads on top then as the player sees some area those quads are Mark as invisible and they are not rendered so each of those tiny quads needs a little bit of data in order to know the position and know whether it's visible or not in the first version of this system I started that as a class and it was terribly slow and then I literally just swapped class for struct and suddenly got a massive speed boost all because of how struges are very efficiently stored in memory so in general you use struges to hold different pieces of data together and in general you should use them as immutable pieces of data meaning they should not change and consider using them when you have some kind of memory performance issues hello and welcome I'm your Kodi in this lecture we're going to learn some intermediate topics related to classes things like inheritance polymorphism protected override and a bunch more okay so in the basic section we already learned the absolute basic of classes how we can define a class which has Fields properties and functions and then you can create instances of that class so that's the basics but of course classes can do so much more one of the main things they can do is simply the concept of inheritance that is how you can have one class that inherits something from some other Base Class for example let's say we have this General unit class meaning this represents any kind of unit in our game and all the units are going to have some kind of speed and some kind of move function and then we can have the player and the player is a type of unit and to Define that relationship we can make the player class extend the unit based class that means that player is going to inherit everything from this unit class so on the player class itself we are not defining any speed field or any move function instead just by making it extend the base class it is going to inherit all of these elements essentially the player class this one contains everything inside player and everything inside unit then we can have another enemy class which again is also meant to be some kind of unit so we also extend the same unit based class and again this one is going to inherit everything so the enemy class itself is also going to have a speed move function and so on so anytime we have some common logic that belongs to any kind of unit we just need to add it onto the unit class itself and anything that inherits from that unit class any of those class are going to automatically receive the new code that we add to our unit and then each of the classes that inherit from base class each of those can also have code themselves that is unrelated to the base class so for example the player can have some kind of move player function and the enemy can have some kind of enemy health field these only belong to these classes and do not belong to the base class so for example the enemy has no relation to the player move player and the player has no relation to the enemy health so always keep in mind that the inheritance does not go both ways meaning the above unit this one over here has no knowledge that there is a player extending it and the player has this kind of function so the player inherits everything from unit but unit does not know anything about player or enemy okay so let's see the synx here is the basic unit class we've got a speed field and a move function and now let's make a clear so let's make a player class and now in order to make this one extend our unit class for that after the player class name after that we write a con and then the name of the class that we want to extend so in this case unit and if that's it just like this the player is going to be extending the unit class if we write any code inside of here we can already access the unit Fields so for example let's make a Constructor so a public player Constructor and over here we can access yep we can access the field we can set it to something and we can call move function yep that does work so even though speed and move are not defined over here in the player itself since the player extends unit it also inherits all of this but then like I said inheritance does not go both ways so up here on this one let's make one for the move player let's make some kind of move player function and now down here on the unit script if we try calling that nope that does not work the unit does not know anything named move player this function only exists on the player class itself now another thing we can do is override some base function so for testing let's actually go up here let's create a new unit so let's build a new unit and a new player okay so we have these and if we call uh the move function and on the player let's call the same move function so if we run this it should print this line twice and if that's correct it only print three times cuz I included over here in the Constructor but yep it did work so now like I said we can overwrite some base function so for that over here on the Move function let's add the keyword virtual and now we can go onto the player and on the player let's define a function Exel like this one so let's define one just like this inside let's say move player and if we do it just like this we actually see this green squiggling line and we can check and Y this is basically telling us that this one is hiding the inherited member and if we want to override an implementation we can add the override keyword or add new keyword if we want new function but nope we do want to override that one so on the base L we add the virtual keyword and on this one we add the override keyword and yep so now like this using this code so the unit has this one it's a virtual function and this one is overriding that function with a different message so we have two different messages and up here we are creating a unit creating a player and then calling the same move function on both them so now let's see what this prints and there it is so when we call move on a unit it is running move unit but when calling the same move function on a player it is actually running the overridden logic so this is how you can extend some Bas class so make it inherit from something else and then override certain functions to have different behavior from the base class now this is also a great time for me to mention how you can override the two string function basically every single class in C is always going to extend the base object class and that base object class always has a two string function so for example up here we did not Define any kind of two string in here but we can call two string Yep this does work as you can see this exists in the object Base Class this is the main way of how any single object any single type can be converted onto a string we can do a console. right line and we can print out for example player and Yep this does work because this one is going to automatically call two string in order to convert the player onto a string so anyways yep all objects have this function implemented automatically however if we run this yep the player just says essentially just prints out the actual name for the type so we're inside the names space c course we're inside the program class so that's the program class up here and then inside the player type so sometimes printing this is not very useful but the two string function this one is also marked as virtual which means we can also override it so let's do the same thing let's you public override and automatically this one already shows us some code hints so let's override the two string function and it like this so it returns a string and it's call two string and over here we just return the string that we want to name our player so for example let's give the player some kind of name so let's give it a string for the player name and let's receive this string over here so we've got a string for the player name and set this. player name equals this and then down here let's print out player and then the player name okay so we do this and up here let's print the name as code mon key and then we do the same thing so let's do a console the right line and let's just put player so not even any two strings so just like this let's see what this does and if there we go now we have overridden that behavior so we can now say whatever message we want from our custom type okay great so with this we can inherit from Basel and we can overwrite some functions and of course what I'm saying here applies to any class you want to extend you can have as many classes extending a base class as you want so for example we can make a class for an enemy and also make the enemy also extend our unit and for on this one we can also again we can also override the exact same move function so we can do this this one is move enemy and now here let's do the same testing code Enemy enemy let's construct a brand new enemy and then we call enemy. move and let's see what this runs and if they're going like that so move unit move Player move enemy even though over here we are always calling the exact same function so basically we have three implementations of this and each of them is slightly different because they're overriding the base implementation basically the Only Rule with inheritance is how you can inherit once you can only extend a single Base Class so if over here we were to define a unit 2 okay here's a complely separate class and over here let's try to extend that one as well and NOP we have an error it is telling us that eny cannot have multiple based classes so we can only ever inhered from a single Base Class if you want to achieve something similar to that kind of result for that we have interfaces which we're going to cover later on in a future lecture but you can definitely go the other way as deep as you want so over here for example we have enemy which turn extends the unit class then we can go one step further so let's have another class for example the enemy melee and let's have this one extend enemy and Yep this does work then we could have another one for the anime melee boss something like this so for some kind of boss that also extends melee this one extends enemy melee just like this and yep all of this is valid code however just like this you can probably already tell how this can become quite confusing quite quickly so over here let me point out that inheritance is a tool that can be very powerful but also can be very easily abused to the point where it's much worse than not using it there's a common programming joke that goes basically you want the banana so you construct a banana but end up with an entire jungle that's because the Banana class would extend the fruit class which in turn would extend the tree class which requires the jungle class and so on so if you have complex really deep inheritance structures if you have that you can end up with some really messy code one common saying to counteract this is prefer composition over inheritance this is how you can instead of having a complex web of inheritance instead of that you can compose your comp objects based on separate components that make up the final object now this is a more advanced topic so don't worry too much if you're not fully understanding everything that I'm saying here I'm only saying this just in case you were curious and want to research further on this topic if you want you can Google composition versus inheritance and you will get a ton of really interesting results the only thing I want you to take away right now is just remember to be very careful when you're using inheritance always ask yourself if you absolutely need it sometimes you do but many times chances are there's a better way to achieve the same result in a much easier way that does not become insan complex but inheritance does have its place so let's learn a little bit more about it one extremely crucial thing that is not related specifically to just inheritance is the concept of polymorphism this is how you can treat an object as a different type of the object as long as those types are related so for example up here if we Define a field of type player so we have this field and we can assign this to the player that we created Yep this does work however we cannot assign our enemy object over here that is because you cannot implicitly convert our enemy into a player because again going back to the diagram even though they share the same Base Class they by themselves are two complet separate types however now let's make a field of type unit so we have a unit and obviously for this one we can assign our unit type Yep this does work and on this one we can also assign the player type Yep this also does work because again player extents unit so it can be used in place of a unit and same thing for the enemy object Yep this one also does work and now if we go into this unit 2 and call the move function let's see what this runs and if there it is this one runs the move enemy that is because even though we assigned this to a unit variable even though we did the object itself is still an enemy object so the object itself the type itself that one is still overriding our base move function and for example if we assign this to player Yep this does work but like we saw on the player itself let's define a public void move player so let's define this function that only exists on the player type so we did this and if we go over here onto player and call move player Yep this does work this is valid code however if we go through the unit and call move player and nope that does not work it does not exist that is because again this field this one is now of type unit even though the object itself is of type player since we're accessing it of type unit we can only access the things that unit itself has so for example one fun thing you can do with this kind of property is for example having list of units for some kind of unit list you can do this and now inside of here we can place a unit we can place a player and we can place an enemy and Yep this works it works because our player class and our enemy class those extend our unit base class so they can all be cast down into a unit type now like I said the concept of polymorphism which is basically using one type as a different type that concept is not specific to inheritance for example it also works with interface which we're going to see in the next lecture if we have some kind of function that requires the player specific type if so then we need to receive some kind of parameter specifically as type player but we can do a bunch of logic that works on just units and that logic won't work on units it won't work on players enemies and anything else that extends our unit based class and now that we are only looking at inheritance we can also look at a different access modifier so far we've pretty much just been using public and private private means that only this class can access it and public means that anything else can access but when it comes to inheritance we have another Super useful one and that is protected for example let's go down into our unit and for example over here for the speed instead of public let's make this protected so by making it protected we can use it over here inside the unit class so yep this works this is valid code and importantly over here on the player Yep this one is still valid code we have no errors here by making it protected that means that only this class only the class that defines it and any classes that extend this Base Class any of those can access this protected field so up here the player can indeed access the speed but for example up here in our static in our main program over here if we try going into a unit and try accessing the speed field I hope it does not work unit. speed is inaccessible due to its protection level so if you make something protected it is only accessible from within that class and any other class that extend that class so if you have some kind of behavior in your base class that the extend classes should be able to modify and only those classes if so then make it protected or for example in a field make it protected virtual and yep like this all the other class can access so this one just needs to modify into protected override and then same thing on this one protected override and by doing that the class that extend That Base Class those canate access it but over here this one can no longer access then one really interesting thing is the concept of abstract classes the these are classes that have a definition but cannot be constructed directly for example let's say our unit class here this one should never be created this should simply be a base class that should be inherited by the player or the enemy or any other kind of unit type but we're never meant to have just a base unit class so for that we can add the abstract keyword and Yep this one marks this class as abstract and now if we go up here yep we do see this error since a class is marked as abstract we cannot create an instance of this type this can be really useful to provide a base definition for something but also make sure that base definition itself can never be used directly only the class that extended can be created along with marking a class as abstract you can also Mark functions so for example let's make a public abstract and make some kind of void attack function so we do this and then we just do a semicolon meaning we do not provide an implementation for this function and instead just by defining this we can see we have some errors over here in the enemy class and the player class and here yep it says that we must implement the attack function so if the B class has some kind of abstract function we have to absolutely Implement that and over here by the way quick tip Visual Studio actually has these quick tips so if you click on this little thing it tells you to implement the abstract class and it's going to automatically write it and if there does so we need to write that one and yep no longer have an error so this can be useful if you have something where you are not meant to provide any kind of default implementation you just mark it as abstract and any class that extends this class W be forced to provide their own implementation to this function but if you do want to provide default implementation then just do it like this just make a regular virtual function and then any other class can either override or not override then another keyword is sealed what this one does is it prevents classes from extending this one so as you can see up here we have an error since we marked that one as sealed it is telling us enemy cannot derive from seal type unit now personally I've never really used seal but in complex projects with tons of classes sometimes it can be wise to make something sealed if it is never supposed to be extended again remember the main clean code principle the main goal is really to to minimize complexity so if you have some class that is never meant to be extended no matter what if so you can make it seal in order to help you make sure that the compiler enforces that rule so it can be useful in that way but personally I rarely ever so it can be useful that way but personally I never really use it then yet another more advanced thing related to classes are destructors so we write those kind of like a Constructor so kind of like up here we have a player Constructor for a Destructor we write it pretty much the same way so we write just the player as if it were a Constructor so there's no return to type it's just in type and then before it we add the T key which by the way like it says here this one cannot be marked as public so it just runs just like this so this a Destructor and now any code that we write here this is all going to run when this object is destroyed which if you remember from what I mentioned in the beginning c is a program language with managed memory you don't need to directly handle the memory yourself so the destruction of an object happens when there are no more references to that object so for example here let's do a console d right line for the play this structor to see when this runs so for example over here for some testing code we're calling some kind of my function and inside we're just calling a player so pretty much just constructing a brand new player then over here I'm calling gc. collect so GC stands for the garbage collection so this is the system that automatically handles all the memory and calling collect simply forces it in order to do it if I didn't force then this would happen randomly as the program grows and then just calling another function just keep it running so let's see this and if there it is just like that so the player was created then we call the function this one created a local variable meaning that this variable ends as soon as this function ends so as soon as this function ended this variable was marked for Destruction then when we force fently called the garbage collection when we did that it automatically destruct the object then continue running the program but remember how destruction of an object happens when there are no more references to that object so that is why over here this one is a local variable meaning it only exists inside of this function so as soon as we exit this function naturally this object has no more references to it however if instead of describing it in here let's make a PL ler over here Player test and then down here instead of defining some kind of function like that let's set that field to that okay so just like this and now if we test and yep the distruct does not run because Player test this one is a static reference and this one continues holding a reference to that object even though this function has ended so this is yet another place where it's really important to understand the scope of exactly what code you're writing one practical example of when to define the structor is when you have some kind of class that requires some cleanup like for example if on the Constructor itself you open up some kind of file for reading if you do that then make sure you close that file on the destructor so these can be really useful for disposing of any unwanted memory all right so those are some more intermediate topics related to classes as you can see there's lots of stuff you can do with them but also specifically on the topic of inheritance remember what I said about how it can become really messy really easily so always use it with care and something that I mentioned quite a lot in this lecture are interfaces so let's learn what those are in the next lecture hello and welcome I'm your Cod monkey in this lecture we're going to learn about interfaces this is one of my favorites and just straight up best features of C you define an interface that represents some kind of behavior or type and then you implement that interface in any class you want okay so interfaces these are simultaneously really simple and also really powerful an interface is essentially just a contract so you define an interface then you define whatever functions that interface has then any classes that Implement that interface any of those they must Implement those same functions so you have a guarantee that anything that implements that interface will implement the functions defined in the interface by doing this you can then write code directly against the interface type and that code won't work on any object that implements that interface this logic is somewhat similar to the class inheritance that we just covered in the previous lecture except you cannot create an object of the interface type another difference is how a class can only inherit from a single based class but a class can Implement multiple interface so for example with this structure right here an i attackable interface that is implemented by both the player and the enemy with this we could have some kind of bond object then the bullet could receive an object of type I attackable for some kind of Target then the bullet itself would call the damage function on that I attackable meaning the bullet itself would not know if it's attacking an enemy or player but because those work with the interface the bullet would be able to deal damage to both players and enemies so here's a different demo for some kind of interaction system I've got three objects and I want to interact with all of them and over here on the building I can click and yep I can indeed interact with however clicking on these two does nothing here is the code running that demo now don't worry if you don't understand everything this is doing it's not really important this is just a demo just so we can see the interface in action over here all we're doing is testing for a mouse click then we get the mouse position and test if there's any collider under that position and then try to get the type of that collider so in this case we're trying to test are we clicking on something that is a building object so it has a building component attached to it if so then we call the interact function and that in turn spawns that chat bubble so this works perfectly fine with the building type but now let's say I want to interact also with the zombie and also with a push button right now it doesn't work I am clicking on the zombie and the push button nope nothing happens the only one that works is the building itself that's because over here this logic this was made specifically just for the building type so it does not work with any other type in order to make this work with those other objects I pretty much just need to copy paste all this code then make this one to make it work with a zombie and make this one down here to make it work with a push button okay let's see like this so interact with the building it works the push button works and the zombie also works okay so now I can de interact with all the objects but obviously the code over here does not look very good we've got tons of duplicated logic this is really messy code if we want to add yet another interactable object we have to come here and copy paste a ton more code so you can imagine how this becomes really tricky if we have dozens or hundreds of interactable objects so this is definitely not a good approach and this is exactly where interface come in instead of making this code work with each individual type instead of that we can make it work against an interface here's a super simple interface that I defined again I'm going to cover this syntax in a little bit then all the other objects they are implementing this interface and over here now for the If instead of testing for each individual type I'm just testing for the interactable interface type and if we test this click on the building and it works the button works and the zombie also works okay great because we made this code work with the interface itself that means that this now works with any class that implements that interface so if I want to make more interactable objects I really just need to make a new class and implement this interface and everything won't work there's no need to touch this code anymore so this is the Practical example now let's see the Syntax for how we build interfaces now the way we Define it is really simple for example let's define an interface for an object that can be attacked so we start the access modifier and for an interface you probably wanted public then instead of writing class instead of that we write the keyword interface and then we write whatever name we want for the interface and the general naming rule is to start interfaces with a capital I this not required it's just a good convention to follow so in this case to represent something that can be attacked let's call it I attackable okay yep so this is our interface now let's think of what functions we need so that something is attackable and the answer is we probably just need a damage function so over here let's type in public which by the way everything defined in an interface needs to be public you cannot Define private things inside an interface that's because interfaces like I said they are pretty much defining a contract that other classes must Implement if we were to define something as private then other classes could not interact with anything inside of this interface so it wouldn't really make any sense to have any private elements inside an interface so everything inside of here is public and by the way way this is actually another reason why I personally really like being as explicit as possible if you omit the access modifier if you do that over here on an interface and make some kind of my function if you do it then this one W default to public but if you write this exact same code over here inside a class if you do it then now this one will default to private so this is yet another reason why I like being very explicit that way there are no questions as to what access modifier we are using for what element so over here I like to be very explicit and write public void and let's call it damage and Y we just Define the function and then put a semicolon meaning we do not write an implementation in this interface here we are just defining the function signature so that's just the name the return type and any parameters if there are any and that's really it we don't provide any implementation in our classes like for example let's make a random player class and on this one we can Implement our interface and we do that pretty much exactly how we saw for extending a base class in the previous lecture so we add a con and then our interface so I attackable and if there it is just like this and we have an error and if we see yep the error because the player does not implement the interface member I attackable do damage again like I said if you implement an interface you have to implement everything within that interface so over here you absolutely must implement this damage function and since the interface itself since this one has no function body because that we can have whatever implementation we want meaning the player can have some kind of implementation then the enemy can have a different one and so on so pretty much similar to what we saw in the previous lecture on extending base classes how we could override and provide different implementation for the same function over here it's kind of a similar thing so let's do a public void damage and here we can let's just do a console the right line and just print out player damage okay so yep that's it and now for example up here in our main let's make a field of type ey attackable and now we can simply construct a player and we can sign it over here yep just like this this works again similar to what we covered in the previous lecture this is polymorphism in action since a player implements the ey attackable interface we can use a player object and assign it to a variable of type I attackable and then through this interface field through this one we can access whatever functions we have in our interface like for ex damage and Yep this does work so now we have similar benefits to what we saw in the previous lecture on inheritance for example let's make another class let's make an enemy class that also implements ey attackable and Y just like this it works and now up here if we have some kind of code that works against the I attackable interface like for example let's make a private static void attack object and we receive an object of type I attackable so we can do this and then on attackable we can call damage and now up here we can call this attack object and we can pass in an object of type player and pass in one of type enemy and yep both these work just fine so this function over here that was written directly to work with this interface type it does not care what object we pass in as long as that type also implements our interface now one limitation of interfac is they cannot have Fields so for example down here in the interface let's make a public in health and no this does not work interfaces cannot contain instance Fields again this goes back to the difference between an interface and a base Class A Base Class can contain actual data since a base class can be constructed but an interface this one is just a contract so this one holds no data so that is why over here we cannot have any Fields but we can have properties so y this does work so we can define a public health property and again same thing all these need to implement that one then we can also have functions of course then we can also have events which we're going to cover later so the main limitation is really how you cannot have Fields because again interface cannot store any actual data another thing is actually here we Define this function with no body and then the classes must Implement that function and this actually used to be the only way but in recent C versions you can now add an optional default implementation so you can write a function here and just write the code AS nmal so you can do this and now classes that implement this interface they are not absolutely required to implement this damage function if they don't then it's simply going to use the default one so as you can see over here we have no error and up here we can still pass in an enemy and through this function we can call damage function and the only thing is one is going to run the player damage and this one is going to run default so let's test and it Pickel like that so the player did Implement their own custom implementation but the enemy didn't so it used the default one this feature for default implementations this is especially great when working with some complex projects things that are already using a bunch of interface and you want to add a bunch more Behavior if over here you just add a brand new function so test function if you just do this then all of a sudden we broke all of this code this is obviously not very good so if you do this if you add after the fact and you don't want to break your current code just provide default implementation and yep now everything does work so like I said interfaces look slightly similar to class inheritance however one huge huge difference between them is how you can only ever inherit from a single base class but you can Implement as many interfaces as you want so for example here we can make an interface and let's call it movable so this would represent something that can move then an interface call it I has inventory so this represents something that has an in then up here let's say the enemy can move but has no inventory and the player can move and has an inventory and yep we can Implement all of these interface in the previous lecture I talked about how you should prefer composition over inheritance and this is exactly one way you can do that you can have interface that each Define some kind of behavior like for example whether the object can be attacked whether it moves whether it has an inventory you can do that and then your classes you can Implement only the interface that are related to that object so for example the player can attack and move and has an inventory but the enemy does not have an inventory so it does not Implement that interface this is a much better pattern as opposed to making all of these requirements on some kind of unit based class and then the enemy would also have some kind of inventory even though they would never use it so this is an example of composition over inheritance and for example in my game Thinking Guardians I use interfaces all over the place I use them to Define all kinds of behavior and then have tons of code that works directly with those interface and really does not care what the underlying type is implementing that interface so it can be a dinky it can be a machine it can be the player it really does not matter as long as that type implements that interface it does work when extremely common interface in games is simply making some kind of interaction system so just like we covered in the demo and if you want to learn more about specifically that type so you can see a practical use case if you want you can check out my dedicated tutorial on how to make an interaction system do something that can talk to NPCs push buttons or open doors and like we saw in the demo if you don't use an interface then you have to copy paste a bunch of code but if you do use an interface then it makes it super simple for your system to work with any object you want so interfaces are really truly awesome they are definitely one of my favorite C features they are extremely useful so definitely make sure you fully understand them they will help you a ton in pretty much any game any code you want to make now that we've covered interface and inheritance these are two things that deal with a lot of types that work as different types now that we done that we're ready to handle the various ways of doing type conversion so let's do that in the next lecture hello and welcome I'm your codm in this lecture we're going to learn some things about comparing various types we're going to see whether they're an interface or Bas class and we're going to see how we can convert between them okay so previously we already covered inheritance and interfaces those are two ways we have of handling an object of a certain type that also works as a different type for example if we have our eye attackable interface and both the enemy and the player implement that interface if we have a field of type I attackable over here we can construct a new player any of it works and we can construct new enemy and if this also does work but then let's say we have some special logic that we only want to run if the object is a player and not an enemy for example over here on the player let's define a public void player say hello something like this so if we have this function that only exists on the player so it does not exist on the enemy on the unit on the interface nope only exists on the player and over here if we have a field of ey attackable even though we placed a player object inside that field if we go through it and try to call player say hello nope this does not work like it says here eye attackable does not contain a definition for that so it does not really matter what is the specific object that we have stored inside this variable this variable is of this type so we can only interact with things that exist inside of this type if you have a film like this and you want to see if the underlying object stored in there is of a certain type or a different one if so you can do if attackable and then use the keyword is and then the type is player so we can say this and let's do a console d right line just to see if this one is a player let's just get rid of this code for now okay let's see if this one prints and if it does print that object is indeed of type player and if we replace it for an enemy and run and if that one does not print because this one is no longer of type player so this is the simplest way for how you can tell if a certain variable if the object SED within that variable is a a certain specific type alternatively on Prem much every other object we can see we have a bunch of functions that are available to every single object like we already saw the two string so this one exists on every object but the other one that is all super useful is this one the get type this one Returns the specific type of that object so for example let's do a right line on this one to see what this one says Okay so let's print this and see what this one says any if that one says the type so this one is of type enemy so here we can get an object of type type which actually only tells us the type of the object that this is so over here we can check the attack of do get type in order to get the type contained within that variable and instead of using is we simply compare with the type of player example like this we have an error because player this is the name of the class in order to get the type we use the keyword type of and this Returns the type of whatever is within the parentheses so in this case the player type and Yep this now works the same thing as we saw previously with the is so this one this is an enemy so this is not going to run and if there go it's an enemy but if we solop this for type player and if there it is now it does run now when difference between this get type method and the other one using the is keyword one difference is this one does not check for inheritance or interfaces so if we see is of type I attackable which again the player class this one is indeed implementing I attackable so let's see if this one runs or not and Noe this one does not run so if you use this method of getting the type and using a type of to do an equality check if so when it comes to interface instead of that you can access the function inside of this specifically the function is interface this will tell you if this type is an interface and then you have a bunch more you have a function for checking if it's an instance of a type you can check if it's a subass of something or you can check if it's a sign a b two and from something or alternatively for this case for testing against interface you can use the previous method which personally is the one that I prefer so just see if the attackable is attackable which in this case doesn't make much sense but let's test any yep it does work but if we were to make a new player over here let's see and if it does work alternatively we could test if the player is a unit and if this also works so there are various ways to test if a certain variable if a certain object is of a specific object type so for example let's go back to our original demo so testing if the attackable is a player and if so we want to run this specific function on the player class right now even though we have identified that this object is of type player we still cannot go here and call player say hello nope this still does not work even though we have verified that it is of this type we still need to convert it onto that type and for this we also have two options One is using the as keyword so let's define a player field and for this let's use the attackable as of type player so if we do this and now do this and over here let's just print out something okay let's see any yep it does work it did run that so here we convert our attackable into a specific player type and then we can call any functions that are specific to this player type the other conversion method similar to this one is simply casting which we already saw when we cast some floats down into ins so instead of using attackable as player we just put player in parenthesis and then attackable and like this and yep it does work so these are two ways for converting types and the difference is usually related to whether the conversion succeeds or not so for example let's go outside of the if testing the player let's just comment this out so up here let's create a new player and then let's create a new enemy and now let's do a player test player and we're going to take the enemy and cast it down into a player which obviously this will not work it does not work because enemy has no relation to the player itself the enemy implements the attackable extends a unit but has no relation directly to the player itself and in this case the compiler doesn't even let us run this code however we can try forcing something that won't work so let's put it an i attackable and up here on this attackable let's make it a new enemy so this one is an enemy meaning this one will not work but now we don't have a compile error because technically I attackable might be convertible into a player it might or might not be and if we test this and yep if we try to C something that does not work we're going to have this error unable to cast of type enemy into player and using the other method so let's see what that one does so attackable as player and in this conversion method we have no error and let's just do a console. right line to see what is stored on that one let's see any y it's empty meaning that one contains null so this difference between the two methods if you use a cast and the cast fails it is going to throw an exception whereas the as if the as fail it is simply going to store null over here on this field so remember this difference if you use this me method in order to figure out whether this cast worked if so then compare this one against null or if you use this method then before you do make sure to test if the player is actually castable which up here this code is normally what I do so I just check if something is a specific type and only if so that's when I cast down and then do some complicated logic also related to type conversion when working with value types like for example an INT on this one if you do some kind of thing like this so a as float if you do it nope it does not work the as operator must be used with a reference type that is because like we saw if this one fails this one is going to return null but a value type can never be null so that is why the as so that is why the as keyword can only be used with reference types so when you ever have this kind of thing you only have to use the cast option and something related that I mentioned briefly in the beginning of this course is how every type in C is convertible down into the object type this is the base type for pry much anything in C you can convert any type into an object so for example something you can do is to find some kind of int then you define some kind of object and you can place an INT inside of that object and then you can Define another int go inside the object and cast it down back into an end and Yep this does work this is technically something that is called boxing which I'm going to cover in more detail in a lecture in the advanced section this is basically how you can convert anything onto an object and then convert it back this topic of type conversion is also something that won be very important in a few lectures when we cover events the default type for any kind of event is the event handler and this one if we we inspect how it is yep this one has a parameter of type object so when working with this we're going to need to do some conversion and usually for events you know what type is fireing this event so you can just use a cast in order to convert this object onto whatever type you want but like I said I'm going to cover events in a few lectures so with that here we'll learn the various ways of handling type conversion these can be very useful when combined with interface or inheritance anytime you need to do some kind of type checking or convert back and forth between one or two types now you know the various methods for doing it hello and welcome I'm your Codi in this lecture we're going to learn about switch pattern matching this is how you can do a switch on a type instead of just a value this is a super quick lecture since it's actually really simple but I want to make sure you definitely know about this okay so we already learned how to handle multiple types with inheritance and interfaces now let's see a more advanced use case for the switch that is perfect for this scenario so in the last lecture we already covered how to check if an object is of a certain type so for example if I have an eye attackable field and I set this to a new player then we can check if attack is of type player and if so do some kind of logic then we could also test if attackable is of type enemy we could check if it's of type of the red Barrel so this works perfectly fine but just like we saw on the lecture on the regular ifs if you have to do a ton of them together then at that point a switch is better and actually on a switch we can also do this kind of logic testing if a certain field is of a certain type so instead of this let's do a switch and switch on attackable and then on the cas we can add the type definition so for example case player and then assign it to some kind of variable name player and if there it is this is valid code what this going to do is if the attackable is of type player then it's going to cast attackable onto a player type and it's going to assign that reference over here on the player so for example over here we can access the player and call a function that only exists on the player like this one player say hello so this one and Y this should work so let's run and if exactly it does work so here this is both testing a specific type it is also casting that type and assigning a variable reference so with this instead of having all those ifs we can do here case Enemy enemy and case red Barrel red barrel and in P these now work so now inside of this we can put any kind of enemy specific logic and of course we always have the default case just in case it does not match anything then it's going to run this code also this actually lets you do one more thing that I actually didn't know until I did the research for this course which is on this case you can add extra conditions so for example up here on the player let's find a end for the player Health something like this and now here on the player we can use the keyword when and then Define some kind of condition so for example when player. health is above 50 if so then we're going to run this and put one without it and it's going to run this so over here for test let's do a consant out right line on this so this one Health 50 and the other one is a default now up here on the player let's construct it and let's put the health on 100 so that should go inside of this one so let's see and it ex goes inside that one whereas if over here if the health is 20 and if if there it is it only runs the other one so this whole thing is called switch pattern matching so as you can see we can do a switch and then Define all kinds of patterns and depending on which pattern it matches going to run different kinds of code with this the switch can be used in tons of way so not just testing for a specific value you can cast into a type and then couple it with some kind of condition and doing that you can do all kinds of logic on different switches but again always remember the number one rule code is meant to be readable and understandable so if you end up with a mountain of switches with tons of complex when case conditions at that point it's probably best to refactor your code in some way but for simple use case this is really useful especially for this kind of use case where we have some kind of Base glass or some kind of interface and we want to do some specific logic depending on what type it is hello and welcome I'm your KMI in this lecture we're going to learn about delegates lambdas and Anonymous functions okay so delegates they are really powerful C feature they basically let you store a function inside a variable or use it as some kind of parameter here is a working demo so I can click and it spawns a chat bubble then I can press a button to change the action and now if I click yep now it spawns a regular Sprite and now press another button now I click and yep now it's spawning some particles so the same action clicking is doing different Behavior based on what action I select here is the code for the click actions and delate is this one over here it's something of type action this is a delegate and then I've got a bunch of functions toine here so spawn chat bubble a Sprite or a particle effect and I can see over here on start that I'm assigning The Click action to this function so importantly it is not calling the the function nope it is passing in the function itself and storing it over here inside of this field and then on Mouse click I simply run whatever is stored inside that variable so the variable stores a function and then by calling this I can run whatever function is stored within that variable then these buttons simply do that they simply assign a different function onto that variable and with that I can click do one Behavior press to select something else do another behavior and another one just like that so this a practical example now let's see the syntax to define a delegate first let's write the access modifier let's go ahead with private and then let's use the keyword delegate and then you write essentially a function signature so let's make something super simple for the return type let's use void then for the name for this delegate let's call it attack delegate then we add any parameters we want or basically none of them okay so yep so just like this we have defined our delegate type now we can use this type just like we can use any other type so for example here let's make a field of this type so let's make it of type attack delegate and let's give it some name like attack action okay so just like this and then like I said the goal is you can sort functions inside a delegate variable so over here let's make a regular function let's call it melee attack and let's just do a cons on the right line and let's print out melee attack yep just like this now importantly we need to make sure that this function signature has to match our delegate signature so it needs to match a return time so both need to return void and needs to match a number of parameters so in this case zero so this yep now we can go inside our attack action and we can assign it to our melee attack and again importantly we assign it just like this so so we assign the function itself we do not call the function no this is very different we assign the function itself just like this so you can do this and then basically we can run whatever function is stored within this delate and we do that by calling it like we call any other function so just like this okay let's test and if exactly it ran our melee attack function so for example you could have multiple enemy types each with different attacks and in order to trigger those different attacks you would simply assign a different function onto the delate variable then like I said the delate can have whatever return type and whatever parameters you want so for example let's make another delegate let's make one that returns in call it my delegate and let's receive a string parameter save just like this this is the delegate reference and like I said when assigning something of this type so for example down here let's make a field of this type my delegate and now when assigning it like I said it needs to match the function signature so if I try assigning melee attack and nope we have an error it is telling does that there is no version of the Mele attack function that matches the delegate my delegate so there's no version of this fun function that returns an INT and takes an A String so in order for this to work let's go make a private static void my test function and actually not void so actually in here let's return an INT and let's receive a string parameter so we have this one and now up here we assign this to this field of type my delegate and if now it does work let's just return zero just fix that error and yep like this this does work it works because the function signature now matches so they both return an in type and they both have a string parameter also by the way over here you need to Define some some kind of name for the parameter so like this it's an error so you need to Define it with some kind of name but down here when you assign the proper function this one does not have to have the exact same name needs to be the exact same type but not the exact same name okay great so this is the basis of delegates so up here we Define delegate and then we assign it so that's great and delegates are really super useful I use them all the time but always having to Define them before you use them that is a little bit of a pain so for that c has some really awesome default delegates that are super useful one of them is simply called action so so let's make a field and let's make it of type action which by the way exists inside the system namespace so action let's call my action and we can inspect the action in order to see the function signature for this delate and Yep this is a delate that returns void and takes in no parameters so pretty much exactly the same that we defined up here so down here if we grab my action and we assign it to melee attack and Yep this does work because again the function signature matches this one returns void and has no parameters so rather than having to constantly Define your own custom delegate with void no parameters if you want that you can just use action and then there are actually various action definitions you can add the angle brackets this means a generic we're going to cover what are generics in detail in a future lecture so this you can see there are 16 inversions of this type and these are basically just different amounts of parameters so you can see there's all the way up to 16 parameters basically on these you can include whatever type you want for the parameters so let's say an action that takes in an INT what this means is a function that will return voids and it's going to have an in for the parameter so the equivalent for example up here would be some kind of in like this so this would equal pretty much this and down here of course since we changed the delegate that we're using this one is no longer valid so in this case we would need to make something that returns void and then takes in an in parameter yep just like this and if we assign this one to that one and yep it does match so action is really awesome it's a builtin type so rather than having to Define your delegates you can just use this directly the only thing is that action always returns void so all the various versions that we saw all the 16 versions every single one of these is just the fact number of parameters but they always always return void meaning they cannot return any value if you do want to delegate that return something for that you have the funk and this one works pretty much the same as the action so this one also has tons of things so let's put in the generic in order see all the types and this one as you can see has a generic named T result so this is basically going to be the return type and then has all kinds of those for all kinds of parameters so this basically going to return some type and then have any kind of any number of parameters so for example in this case this my funk this one is of type int meaning it's going to return an INT so let's actually Define it so let's take this one go down here and we're going to need to assign it to something so let's make another function that matches that delegate so again this one has no parameters and it's going to return an INT so let's make it return int and with zero parameters and if we take this and let's just return zero and if we take this and assign it any yep it does work so the builtin action and Funk delegates these are super useful if you have some common use case you can really just use theu there's no need to Define your own delegates but defining your own delegate is also still something proper the one big benefit is of course this one has a custom name so even though this one perfectly matches an action delegate with the name attack delegate that makes it a bit more clear as to what the intent is as opposed to this one Funk this one has no clear intent on what exactly what it's doing so they both have their use case but in many ways for Simplicity when you just need something based that works using Funk and action those are excellent then for assigning a delegate so over here we are creating of something of some type that we are creating a separate function and then assigning it so this works but we can also do what is called an anonymous function or sometimes called a Lambda expression so for example let's define a field of type action and now when assigning it we can just put in the parentheses for the parameters which in this case action has no parameters and then we do a little arrow symbol and then let's open and close a code block so yep just like this this is valid code what we have here is a Lambda expression for defining some kind of function that takes in no parameters and returns nothing so what we have here is pretty much the same short hand as what we have here we can place the console right line there and Yep this is exactly the same as this except when doing this we didn't have to define a complete separate function so these lambas this is another really super useful thing I use them all the time especially when writing any code for buttons in unity buttons have a click action and normally I just use a Lambda in order to Define what Behavior I want when I click on a button as opposed to having to write a separate function and then assigning it to the delegate so there are really great time Savers and you can use them on any delate type so over here an action with no parameters but if we make an action that takes an INT parameter if so then we just need to define the in parameter over there and if this does work and alternatively if we make a funk let's make a fun that takes an INT and returns a bow so this one takes an INT parameter and then over here just needs to return some kind of volume yep that works and then alternatively if you want you can even simplify this even further so let's erase all this let's put just false just like this and Yep this is perfectly valid code this is doing the exact same that we saw previously the compiler is smart enough to know that if this delegate expects a return value it is smart enough in order to add the return into whatever statement we write so this is perfectly valid code although normally like I said I prefer being explicit so personally I prefer to always write everything perfect now an interesting property about delegates is multicast meaning how you can sore multiple functions inside a delegate so for example let's see here our attack action so we're assigning it to just the melee attack let's make another one let's make a range attack and over here if we do this and then assign it to range attack if we do this and let's just get rid of the other code so if we run this code and if there you go it only runs the range attack however instead of assigning we can do plus equals and now if we run this and if there we go now run both even though over here on the delegate we only ran the delegate once since the delegate itself is storing the reference to two separate functions it is going to run both those functions whenever we run our delegate so this means that the delegate itself it can store multiple objects it kind of has a list in the background of all the functions that are stored within it and since you can do plus equals to add it you can also do minus equals so let's run that one which should run both then do a minus equals and then print and let's see this and if there you go so the first time that we ran the D the first time it ran melee attack and range attack but the second time since we raise the range attack we did minus equals because that the second time it only ran the melee attack now when really common use case for delegates is doing a synchronous programming and handling callbacks if you're familiar with JavaScript you're certainly very familiar with this and in game development for example one very common use cases for pathf finding you tell a unit to move somewhere and you can pass in a delegate for what to do when the unit gets there so for example here's a basic unit class and it has some kind of pathfinding so it has some kind of move to function it takes in a Target position then an action for the unreach Target action so we would create a unit we would tell it to move somewhere and we would pass in a delegate so in this case could be a simple Lambda so a simple Anonymous function we could pass that in then the unit would do all kind of movement and eventually it would reach the Target and when it reaches the target then it would call that function and doing the so then it would run whatever logic we set when we call the move to function so if we test this yep there it is now the unit is moving and after a while it gets there and yep it reaches the target another common use case is when doing something that contacts a web server so some kind of web request I made a tutorial on that and for that I made the class receive a delegate for the Callback that is called whenever the server responds so delegates are super useful extremely versatile it can be sometimes a little bit tricky to understand at first since they look like variables but they're actually storing functions if there's something you didn't understand definitely go ahead and rewatch this lecture once again and go through the interactive exercises this is an extremely powerful feature that you absolutely must understand now here I mentioned lambdas for making Anonymous functions but there's actually another way of doing something similar we can create normal local functions so let's learn differences between them in the next lecture hello and welcome I'm your Cod Maki in this lecture we're going to learn about local functions and how they differ from lambdas okay so in the previous lecture we covered delegates and lambdas lambdas are one way to make an anonymous function so we have some kind of action my action we do a Lambda by writing the parentheses with the parameters then we do a little arrow and a code block just like this this is a Lambda expression however there is another method for making Anonymous functions it's called local functions and they're EXA like the name implies just like you can have local variables so in something so this is a local variable just like this you can also Define a function within another function and you define them pretty much exactly the same as another function so for example void print let's receive a string message and then we put a codee block and inside let's go console and right line and let's print out the message and that said here we have a valid local function we have this function inside this main function now naturally we cannot call this from anywhere else so if there's another one so another private static void so if we have another function here from this one if we try accessing print nope this does not exist so this is a local function which just like a local variable is only accessible within this function and we saw the delegates in the previous lecture so we can use these exactly the same way so action my action two and I can assign it to print and actually this one takes a message so let's do action of type string and yep there you go this is perfectly valid code so here this and here this just put a string here just to make it exactly the same so a string message like this and Y both this and this are exactly the same thing now let's see the differences and first is really just a syntax you can see how the Lambda over here this one does not have Name by default the only way to reference this Lambda expression the only way is by going through the actual delegate that stores it whereas the local function over here this one has a proper name you don't need to assign this to any kind of delegate field in order to be able to actually use it the another thing is how the local function can be defined anywhere so for example I can Define the print in there and up here I can call print and Yep this is valid code there's no errors again only inside the actual function code block because it's a local function but I can Define it down here and use that up here this is valid whereas with the Lambda you cannot do this if I accessing the my action nope obviously there's an error I cannot use the local variable before it is declared whereas for the local function that one works just fine the difference for this is because local functions these one are defined in compile time whereas lambdas these are defined at runtime so because that the compiler knows that this function is coming so it can use it but this one can only be used after it is declared also importantly is how the delegate over here the Lambda this Anonymous expression lambdas are actual objects that are declared and assigned at runtime they are exal objects that exist in memory so every time we run this my action every time we do that it is going to create a brand new object every time we run the main function every time we do it it is going to create a brand new instance of this object it's going to create a brand new Lambda whereas local functions these are defined as compile time so in memory they only exist once so we could call the main function 100 times and it would create 100 instances of this Lambda but only one instance of this print function so in terms of memory if your memory limited then local functions would be a better option than using lambdas so in general both local functions and Lambda serve a somewhat similar purpose they allow you to Define functions whilst inside another function local functions can be great for organizing logic within a function assuming whatever you're doing in that function is only ever done within that other function and lambdas are great for super quick things like assigning logic to a button click for the most part personally I really only use lambdas but local functions also have their use case hello and welcome I'm your Kodi in this lecture we're going to learn all about events this is extremely powerful feature of C it helps us write much better code with much fewer dependencies okay so events this is basically how you can have one class and that class fires off events when something happens and the subscribers that listen to that event those will be notified whenever that event happens for example here's a working demo so there's a tower and I can click to damage it and by using events we can have some kind of health bar and that health bar is listening to when the tower takes damage and when it does the health bar listens that event and updates its own state so the UI element over here this one is listening to the build damage event itself and then updates the health bar events have Publishers and subscribers or sometimes subscribers are call listeners those two terms are really used interchangeably the event is defined within some kind of class and then you can listen or subscribe to that event from anywhere else now what that means is that when the event is invoked all of these subscribers those all get notified that the event happened and note how this relationship only goes one way so the subscribers attach to the event in order to be notified but the event publisher this one has no idea that are any subscribers this is really excellent for keeping your Cod decoupled the event publisher does not know and does not need to know if there are any subscribers at all maybe there are some maybe there are none it does not matter the event publisher itself is completely decoupled from any subscribers as far as the event publisher knows it just knows that it fired off an event that's it it does not know and does not care if anyone is listening and the other benefit of using events is that our code can be based on when things happen as opposed to constantly pulling for something for example over here on this demo the health bar does not have to constantly pull the tower to check its Health State on every single update so it does not have to ask that question 60 times a second the health bar is perfectly idle it only listens when the event is published so only when something actually happens does the health bar take action here in the code the tower script this one has an undamaged event then this demo is really super simple I'm just testing for the mouse click and if so calling the damage function and damage function simply Alters the health amount and fires off the event again note how this Tower does not know anything about any kind of health bar it is completely decoupled and then on the the health bar itself this one does know that Tower exists it attaches itself to the on Tower on damaged event and when that event happens it simply updates the health bar so in order to show how the code is decoupled I can just go ahead and get rid of the health bar so I can just disable this game object and yep everything does work because the tower does not depend on the health bar okay so that's a quick overview of events now let's see the syntax and the way that we make events is actually super simple this lecture will be really easy to understand because we already learned about delegates which are quite closely related to Events first we our access modifier and usually for events you do want them to be public you want it public so that any other classes can listen to that event it doesn't make much sense to have one event that is only listenable from that class so usually events are public and then we have the keyword event on lowercase this is a special keyword then we add the delegate and like we covered in the delegates lecture we can Define our custom delegate or we can use the builtin action for example so let's use this one just because it's so easy and then we give it some kind of name usually the convention is to start your event names with on and then whatever happened so for example on player damaged see up like this and in terms of naming rules events are usually Pascal Cas just like properties okay so great so just like this we have defined our event now let's ready quick demo just see how it works and for that let me actually just put this inside a basic player class just so that makes a little bit more sense so put it inside there and now let's make some kind of damage function so let's call damage and now here the first thing we can do with our event is simply fire it and for that we do it pretty much as if this was a a normal delegate and we were just calling it so let's go on player damage and simply call it like this so that's it super simple however this code will actually throw an error but let's test it like this up here let's just create a new player just construct a brand new player then on player let's call damage and let's test any right away we have an error we have a no reference exception so this has to do with the fact that this event currently does not have any listeners if it has no listeners then this field is essentially set to n so before invoking an event we need to check if it has some listeners and we can do that just by checking against null so if the event is not null if so then that means it has some listeners so we can safely call that event so like this if we run and Y no errors although also nothing happened so now that we are correctly firing off the event let's add in listener let's make another class let's make it a class and call it player health bar something like this and now in order to listen an event we need some kind of reference so let's actually make a Constructor for our player health bar and the Constructor let's receive an object of type player so we received that and now here we can go through the player and now we can indeed access the onplay damage event also here in Visual Studio it shows this little lightning bolt this means an event so we can access that event and then we can do plus equals in order to subscribe to that event and here by the way Visual Studio has this really nice shortcut it is going to autorite the player on player damage event so just press tab to insert usually I do this then if you want you can rename it or just press enter and yep there's our event function now if you don't see this shortcut or if you're using different ID you can just manually write this function it's a pretty basic function the only important thing is just like we covered in the delegates lecture the function signature needs to match event signature so in this case for the event we made it of type action which means it must return void and must have no parameters okay so here we are listening to the event let's just do a log so console. right line let's just print out the on player damage event just like this and now up here let's construct our player health bar so let's construct a brand new one let's make it and this one requires a reference to our players so let's pass it in so first we create the health bar and then we call damage on the player so now basically what will happen is when we call damage the player damage this one is going to fire the on player damage event it is going to check against null and since we have a listener this one is not going to be null so it is going to run our event and by running that event it is essentially going to run this code and print this slide so let's see any if there it is the event was fired and listener did listen to that event all right Awesome Again note one of the big benefits of about events the player class this one has absolutely no relation to the player health bar so the player class is completely decoupled from the player health bar as opposed to for example if we were to make this public and then up here we would have some kind of private field of player health bar then we would need to keep this reference and in doing those on the damage we would call the player on damage function if we did this then the player class would be tially comp to this one so for example if I remove this one obviously there are errors because this type no longer exists whereas if we go back to what we had previously here is just the event here is just the player class and if I completely remove this one yep there are no errors inside the player class this is what it means to be completely decoupled is that the player class does not know and does not care if anything listens that listens to that event if it does then great if not then also great then one important thing about events is how multiple classes can listen to one event for example if over here I make another one let's make this a Mana bar so do it like this do it pretty much the same and over here let's say Mana bar something and then up here if we construct a new of type this if we do it then now we have two listeners to this event so when this fires it is actually going to run both of these listeners and if there is both them did run so events can be listened to by multiple listeners and then over here we are subscribing but if you want at some point to stop listening to that event you can simply swap the plus equals to minus equals and yep with that we can unsubscribe and at this point I should point out that unsubscribing to events is actually very important if you don't then you might end up with memory leaks depending on the left time of the object if the listener gets destroyed but the poish lives on if so then it will actually keep firing events onto a listener that no longer exists so that could cause all kinds of issues so always keep that in mind either pay attention to the lifetime of the objects because if the player has the same lifetime as this one then technically you don't need to unsubscribe but if they do have different lifetimes if so then when this object is destroyed make sure you unsubscribe to that event so yep we can either do plus equals or minus equals to subscribe or unsubscribe and on the class that defines the event we can also call the event and now right away you might be thinking that this looks exactly like delegates especially the delegates multicast function and if that's right this is indeed very similar to delegates in fact if over here I just remove the event keyword if I do no nothing changed there are no errors and if we run this yep everything still ran exactly the same so technically it works like this however adding the event keyword had some really useful limitations first of all is who can trigger that event if we do not add the event keyword then anyone would access to this event can invoke it so for example down here on the player health bar I can go on there call it and Yep this will work so this player health bar will be invoking this event usually you do not want this you want the class that defines the event to be the only one that can actually invoke the event and if you add the event keyword then the compiler actually enforces that rule so yep down here nope it cannot call it the event can only appear on the left hand side of a plus equals or minus equals so subscribing or unsubscribing except of course when used from within the player class within where the event was defined so the event keyword is really nice for essentially protecting you for yourself remember how the main clean Cod principle is simply minim in complexity so the more you minimize access to a particular field the better it is another limitation that this keyword adds is simply the ability to clear the event so again if we remove it then for example down here the player manavar this one can go into the event and set it to null and if we test the code like this yep look that issue basically the menar completely raised the original event listener so the player health bar this one no longer listens to everything anything because this one pretty much broke the code again this is something you don't want to happen with events and again this is something that just by adding the event keyword the compiler will help you by enforcing some rules and yep like it says here once again same thing Bing the event keyword the only thing you can do outside of that main class the only thing you can do is subscribe and unsubscribe and nothing else so in many ways events are indeed pretty much delegates since they in fact actually they use delegates like we saw here we are using the action delegate but even keyword that would add some really nice limitations to basically protect the code from yourself and of course since he use delegates we can use anything more than just a simple action if we want to pass in some data for the event we can really just use a delicate with parameters so for example let's use an action of type int and then over here when we call the event we can pass in any kind of int value and then down here on these in order to listen again The Listener function needs to perfectly match that one so if this one expects an end then over here we also need to put an INT and yep like this it will also work and the parameter over here will be whatever you do when you call the event now another thing is over here we've been using the action delegate you can use whatever delegate you want you can build your own delegates or you can use action the builtin type but in general the C standard is to use the event handler this one right here that exists inside of system this one has a signature where it takes in an object for the sender and an event arcs so usually when invoking the event for the object sender you pass in this so you can pass in a reference to whatever object was firing that event and for the event ARS if there aren't any you can just use the constant event ARS empty so yep just like this but again this is not a requirement like we saw you can use pretty much any delegate you want you can use action and everything works just fine but generally this is the C standard if you see a bunch of C code chance are they're going to be using the event handler and then this one actually has a second parameter that defines what are the event arcs again that parameter is also used with generics so let's open up that one and yep it has a type of event arcs so while following the standard if you still want to pass extra data you can for that usually you make some kind of class that extends event args so here let's make a class and usually the standard name is to give it the same name as events so on player damaged and then you simply append event arcs at the end and we make this a class that extends event arcs simply like this and then over here we add whatever parameters we want so like for example in this case maybe we would have like previous Health in order to know the previous Health before the player was damaged and then over here on the event hangler we use generics and we pass in our custom type just like this and then over here when we invoke the events instead of event arsmt we just construct a new object of our type and add whatever that we want so just like this and again on all these other ones of course we need to remake the function signature in order to perfectly match and again this something that Visual Studio does by default so just do plus equals and it's automatically going to write with the perfect event signature and over here on this one in order to access that data that is going to be over here on the second parameter so we can access e and then inside we've got the previous El and we can do whatever we want also one of the first things we saw is over here if we do not add this null check if we don't then this is actually going to throw a null reference exception so you always need to check for null however there's a special way to make this code a little bit more compact so you've got event and again just like this going to fire off null if we have null listeners so what we can do is we can use what is called a null conditional operator I'm going to cover these in more detail in the advance section but basically we can just set a question mark and basically this will mean that the code to the right side this code will only run if the code on the left side is not equal to null so we can do the question mark and then call invoke which is basically going to invoke the event and just like this so again the question mark basically means that is only going to continue executing code to the right if the code on the left does not equal null so if this one is not null if we do have listeners to our event then we are going to invoke the event so instead of having a normal test for null usually with events you have this kind of syntax so you just do a nonconditional operator and call invoke and invoke that event now one of the best things about events is what I mentioned already about code decoupling that truly is one of the magical powers of events it's how the event publisher does not know and does not care how many listeners that are to that event it simply fires off the event and does not care what else happens then all the listeners if there are any they will listen to that event and do whatever logic they want based on that event this is really a crucial thing about events decoupling your code as much as possible is one of the best rules you can follow in order to write better clean code and like we saw this is especially great when games when working with the UI usually you want your UI to display your game logic like for example the health of some kind of tower you want some kind of visual for it but you also do not want the tower itself to be the pendent on some kind of visual in theory your game should work entirely without any UI and by using vents this is really simple you can just make it so for example over here the tower class just fires off some kind of event and then maybe we do and maybe we don't have some kind of external display on top that displays some data based on that event if DUI exists then great but if it doesn't then the tower works just exactly the same so events as you can see are extremely useful in helping you write better more performant and more the cou on code definitely make sure you fully understand them which if you fully understood everything in the delegates lecture hopefully you manag to quite easily understand this lecture hello and welcome I'm your codm in this lecture we're going to learn all about generics this is yet another really powerful C feature this one lets you write code that can be used with a multitude of types okay so let's learn about generics and you've actually already seen them in action in a bunch of places for example quite a long time ago we learned about list and in list this type requires putting another type within those angle brackets this right here for example list of inth this is what is called the generic the list type works with generics which means it can work with any type so we can make a list of ins we can make a list of strings we can make a list of program types and so on if it did not have generics in we would need to create a separate list class for every single type we wanted to use it with that would definitely not be very fun not very easy to use whereas with generics we just Define the list class just once just one time and then that class can work with any type we want also same thing when we saw the delegate so we saw for example the action and we saw this one has all kinds of parameters so we can have an action that takes in a parameter of type int we can have a type string we can have a type B and so on same thing for the funk so again there's no need to create a specific action class that works specifically with an INT another one specifically with a float and so on the action class itself that one is made to work with generics it takes a generic T type and that type can be whatever you want now one of the best practical examples of how useful generics are is actually my grid system playlist I've built a ton of interesting systems and games on top of that base system and the reason why I could do that is because the grid system itself that one is made to work with generics here is that class the grid class with generics here it works with a generic type that I Nam T grid object so I can define a specific grid that works with a specific type again could be something simple like an INT a float bow and so on or it can be a specific custom grid object class that I Define and with that with that grid object I can place whatever custom dat I want and the grid system will work perfectly with it so I don't need to make a brand new grid system for every kind of thing that I want to do with a grid I just use the exact same grid system for any type and byting this class using generics by doing that I managed to reuse this Base Class and build all those complex systems that I made in all those videos so how we make a generic class is actually really simple we just write the class name as usual for example let's make our own custom list so let's make a class let's call it my list and then we put our angle brackets and inside here we give our generic type of name and technically you can give it whatever name you want there's no rules here however usually the convention is to name this t for type and alternatively if you have multiple types the convention is to use T and then perhaps a number so T1 T2 T3 so this is what the action uses or alternatively if you want any more descriptive name usually once again you would still start to type with t and then pass in something like for example T unit another example of generics that we've also already seen is the dictionary and if we look inside the dictionary Yep this one named the generics T key and T value so yep you can write whatever you want but over here let's just write a t so just like this so here we have our class with a generic type and now inside of this code we can use the type T so for example let's make a public field of type T so yep just like this now importantly is how T doesn't really exist we don't have any class named specifically t t is really just the name that we defined this can be whatever class we're going to use with so when we use our my list with a type int then this field will be an in field so this our BAS glass and now up here we can make a new let's create a new M list and then for type let's go with int just like this so this is a m list of type int and over here we can go inside access the field and yep note how this field is indeed of type in and yep so this does work then for example let's say we want this class to work with blls again since we are using generics we don't need to make another class definition we can just go up here make another M list in this case of type B let's name it b m list and then do a new in of bow and now we can go inside we can access the field and Yep this one is now a field of type B so over here we have two instances of our class and each of them is working with a different underlying type then our generic we Define our type te where we're using it over here in the field but we can also Define some kind of functions for example let's make a private void my function and we can receive a parameter of type t or alternatively we can make a return of type T and take in no parameters also by the way one quick Tip since over here we do not know what type T is going to be since we don't know that then for example we cannot return null this does not work and the reason why it does not work is because T technically could be a nonnullable value type like for example up here when we are creating our list of ins or bones these are are not nullable values these are value types not reference types so because that over here we cannot return null so if you do have some kind of logic that is meant to return a default value instead of returning null instead of that you can use the keyword default and this will return either null on a reference type or the zero equivalent on some kind of value type so for example let's do this let's make it public and then up here let's call it so let's call my function let's put a right line on this let's see what default value is for both these so let's see and if there it is default value for an INT is zero default value for a ball is false then on the generic definition over here like we saw we can already Define more than one type so we can Define T1 T2 T3 and so on we can do this and then we can use different types in our code this works so here we have our generic class but we can also use generics without making an entire class generic we can have just a single function so over here let's make a test function and on the function itself let's make that function work with generics the way we do it is really the same thing so after the function name we put the angle brackets then some kind of generic name and now we can use this type in any way like for example use it over here for a parameter or we can use it for the return type and yep everything works isly the same over here let's do a console d right line let's print out p and for example up here let's call out this one and we can call in with an INT and if this works we can call in with a string and Y it also works call in with a sh Yep this works call in with a bullion and Y this also works so here we have a function the function was defined with generics which means that we can run this function with whatever type we want then it can also make stru that use generics so instead of a class this can be a struct and yep structs can also use generics another one is also on interfaces so up here we can Define interface my interface and on this one we can also use a custom type and then we can use this type like for example some kind of function that returns of type T Yep this is also valid so lots of use cases for how you can Define generics and how you can use them and another extremely useful thing we can do is simply apply some type constraints to T right now we have no constraints meaning this T this can be used with any type for the generic it can be ins bowls some kind of custom player class it can be literally anything now let's say for example we want this one to only work with classes for that we can go over here into the class definition and afterwards we write the keyword where and then our generic type so in this case T and then put a con and then let's say for example class meaning that this one this type M list can only be used with a the T type as long as that type is of type class so like for example here we see some errors because ins and Bs these are not classes so we cannot use with those we need to make some kind of class for some kind of player and now of here we can make this of type player and if now this does work and again the issue that we saw a while ago on how we cannot return null from this one but if we do enforce that t has to be of type class classes can always be null so now we can indeed use null here then another interesting constraint is let's say for example we want to construct whatever type we use here and right now over here on this function if I try to do new T if I do this nope there's an error again same thing we cannot do it because we have no guarantee that whatever type we use here whatever type we use has some kind of Constructor in order to make that work again we can apply another constraint in this case this one is named new just like this so now we can use this class with any generic type as long as that generic type is a class and has a parameter lless Constructor which over here the player by default has some kind of parameter list Constructor so yep this one is perfectly valid code and over here yep we can do new T in order to construct a brand new player for example we can put this on that one and this one is going to construct a new object of type T which in this case is going to be the player so when we run this it should say something of type player and if there it is it's done like that there's a bunch of really useful constraints we can apply to our generic type there's a great list on the C docs we can see how we can force T in order to be of type struct of type class we can ensure that it is a nonnal type we can ensure that it has a parameter Constructor or one of the most useful ones are simple L these ones basically requiring T to extend some kind of Base Class or Implement some kind of interface and all of these work on a class definition but also over here on just a single function so again where T is a class and now it ensures that we can only call this function with the type that is actually a class and when using the one that enforces that it extends some kind of interface for example let's make a function get attack winner and let's receive two types T1 and T2 Ral let's give it proper names so T attackable and T defendable then we receive those so we can enforce that t attackable does have to implement the I attackable interface and we can enforce that t defendable has to implement the I defendable interface and now since we've applied these constraints because that now we can assume some things about these types for example we can go inside our attackable object and we can call get attack points then we can go into the defendable and call the get defense points just like this now with this if we had a player type that implements both these interfaces and a unit en type that also implements both of them if so we could call this function and pass in either two players or a player and an enemy or two enemies and all of this logic would work because all of them match the perfect generic constraints that we have so that means that this function this single function is really adaptable and can be used with a ton of different types whereas if we were to remove these then nope we cannot access these functions because we have no guarantee that whatever types we use here will actually have these interfaces in generally one of the best benefits of generics is how they make your code Type safe meaning they help you avoid errors when using incompatible types for example let's say we have some kind of resource so we have a type for gold a type for wood and then we have an inventory class that takes in a generic type so then up here we created different inventories one for gold one for wood if we go inside the gold inventory and we try to add and let's try to add some wood if we do this and nope obviously this one throws an error this is how generic samp is by making our code Type safe if we make an object of a type and we Define that this one only works with gold types if so then we cannot add some wood on there the type itself is going to be forced as soon as we create the object and we cannot break that rule all right so those are generics it's another extremely useful sear feature I use them all the time they are super useful for making your code really adaptable so definitely make sure you fully understand this and make sure you use it whenever you need to this is really powerful but also for beginners might be a little bit confusing so if you feel a little bit lost maybe go rewatch The ler one more time maybe go inspect the demo and definitely make sure you do all of the interactive exercises this is a really powerful feature you definitely must know about hello and welcome I'm your Cod monkey in this lecture we're going to learn about constants and the readon keyword okay so normally we have regular variables like for example int Ag and a variable just like name implies the value inside of it can change they're intentionally supposed to be modifiable so over here I can set it to one value and then set it to another value Yep this works but sometimes you really don't want something to modify some things are meant to have some kind of fixed value like for example Pi it has a fixed value and in C you can actually see it with math. pi y there it is 3.1415 926 and so on and note over here how this one is a constant meaning it always has this value you cannot change to something else so if here I put it to just three nope this does not work I cannot assign this to anything else it's a constant meaning the value is always going to be fixed so I need to Define some kind of field for something where the value should never change like for example some kind of float for some kind of player speed if we set it like this then this is a perfectly regular field so we can read it then we can modify it in order to make it a constant we just go here and we add the keyword const and if there it is now we can use this field whatever we want and this is always going to have this constant value we cannot modify this by the way for the name like I mentioned in the naming rules lecture usually constants are uppercase snake case so everything is uppercase and split all the words with an underscore and of course since constants cannot change then we have to assign some kind of value so if we Define something as constant we have to Define it with some kind of value okay so Yep this is our constant and constants are also basically static by nature meaning they do not belong to any instance of any class they belong to the class itself so for example over here we're working inside the static main function and usually we can only access static members so if this one is just a regular field if it is like this then over here we cannot access the player speed we cannot access it because this one is not static but by marking something as cons that makes it essentially static by default so over here we can do Con on the right line we can print this out and up here we can indeed access player speed also importantly is how Conant they are set at compile time time meaning the value has to be evaluated and defined during compilation not during runtime so that means constants are also somewhat Limited in what types you can use with them for example we cannot make some kind of class let's make a class player so we have this and now up here we cannot make a private cons of type player for the player we cannot do this because we need to assign a value and if we construct a brand new player nope this does not work because this line would only run during runtime and not during compilation so for the most part cons can only be used with the builtin type so things like float bll we can use string and so on however classes custom classes or even default ones like for example object these cannot be constant so constants have a bunch of limitations but for example if we inspect the vector 3 struct so let's go inside of this one so let's right click and over here let's go to definition so here is the vector 3 struct and if we scroll down we can see it as some things that look kind of like constants like VOR 3.0 or. one but again a strug cannot be constant so note how these are not Conant instead these are Statics and this is actually property and only has a get and always returns the same value so this is one of the workarounds you can do if you're trying to make a Conant of a type that cannot be constant alternatively there's another really interesting workaround you can build something similar to a Conant by using the keyword read only so let's define a field instead of making this a constant let's make it a read only and if this one now does work we don't have any more errors what read only means is that these fields cannot be changed after they are set so if we try down here assigning it to a brand new thing nope does not work this throws an error so if you mark something as read only it can have some kind of object type but it must be set either over here directly in the Declaration or it must be set in some kind of Constructor this one works with any type so it can be custom classes or it can also be the builtin types like int and so on it can still be useful to use read only instead of cons even for these basic types like for example on the player class over here let's say each player would have a different kind of maximum health so they would have a private read only for the health max and then on the player Constructor we could receive a certain health max then assign the health max onto this one just like this meaning that this would sort of act like a constant meaning we cannot change it afterwards but this way by using the read only tag basically we can set it to a different value and does not have to be set directly at compound time so that's really the main difference between these two for any data that you never want to change and any data that can be defined at compound time for those you can use const and if not you can make it read only once again remember the the main goal behind writing good clean code the main goal is minimizing complexity and the best way to do that is minimize how many things can change so if something is never meant to change then either just make it a constant or read only doing that will help you make your code much easier to understand hello and welcome I'm your Kodi in this lecture we're going to learn about exceptions as well as how to handle them and Fire custom exceptions okay so exceptions these are really errors we've already see them a bunch for example here's some code that is going to throw an error so I def find an in a variable with value zero and then I just do oneide by a so 1 divide by 0 you can never divide by zero so this is going to throw an error let's try running and if there it is right away divide by zero exception so when you hear the word exception than error now if I were to write some logic after this like for example let's say conso the right line let's print out something so let's try running and nope that message does not run as soon as the code gets the exception it stops executing that's where exceptions are meant to do but sometimes you don't want to happen usually if something goes wrong you want to know that something went wrong but then you also want to handle it so usually you don't want to have unhandled exceptions so the way that we can handle exceptions is with a trap block meaning we write the keyword try and then put a code block and inside that code block we put whatever code might fire some kind of exception then to make this valid we need a second piece of code which is called the catch but first let's run it just like this so this is still going to throw an exception this is still going to throw an error dividing by zero but now let's see if this line does run and if there go it did run and we do not have our exception now technically the exception still happen it really just happen silently for example if we were to put a log over here inside after our exception just say something and we're going to see how this log does not run and if that one does not run only this one down here that's because this line is still throwing an error so it stops executing anything afterwards but since we put it inside a try catch because that as soon as the error happens basally it's going to drop into after the try but like I said usually you want to handle exceptions now we only just ignore them so for that over here on the catch block we can add some parentheses and we can put some kind of exception type for a general catchall you can just use the exception type then give it some kind of name like exception and now inside of this object over here we have a ton of data related to that exception we can see the message the stack tray the source and so on so for example over here let's do a console. right line let's print out the exception. message and then let's also print out the exception let's say these stack TR okay let's see and if there it is that one did find an exception so attempted to divide by zero and found in our program on line 19 which Yip it is exactly that one so yep with this we are catching our exception and you can also add multiple catches you can have different ones to test for specific types like for example let's set another catch and for this one Let's test for the specific divide by zero exception except one important thing about having multiple catches is how it's going to go from top to bottom and since every exception always extends from exception this one is always going to run first so this one is never going to run so let's put the specific one before the generic one and another thing if we don't need any data inside of our exception itself if we just want to test out what type happened if so then we don't need to give it any kind of value so just like this it's going to work it's going to catch an exception of this specific type so let's do a consant do right line let's print out our divide by zero exception okay let's see and it picks on like that so we have our divide by zero exception and then the code continues running downwards okay great also another thing you can add is after the exception you can add the when keyword and over here we can test for for some kind of condition so for example when exception is of type divide by zero exception so if we do this then yep same thing this code is going to run pretty much the same thing as this one so it gets an exception stores it in here and tests out if it is this type and if so it's going to run this one so here we have a try and then a catch but there's yet another block that we can add and that one is the finally you add this one after the catch and basically over here the code inside this this code will always run so let's do a console. right line and let's say final and for example up here let's make sure it doesn't go inside of this catch so let's put when exception let's make it of a type that isn't going to happen so let's say for example the argument out of range exception okay like this so this one is not going to run but we're going to see how the finally is still going to run so the finally always runs no matter what so like this if we run yep we do cash our exception then the finally runs and then the hello there so now you might be think that the finally works is only the same thing as down here so we could just put this in here and it would work but one difference is on the finally over here when we can exception let's say for example we want to end this function so we call return and let's see what this does any we call return meaning this function is going to terminate so it is not going to continue running afterwards however even though we are returning even though we still get the final message so this finally block runs after the catch every single time so usually the finally code block this one can be really useful if you need to do some kind of cleanup code for example if over here on the try you were opening up some file for reading you want to make sure that if you do open up the file even if there is any kind of VAR you want to make sure you do clean it up also by the way you don't need to add the catch so you can just do a try finally and Yep this also works okay so this is how we can catch exceptions now to throw them ourselves we can also do that for example let's say we have our custom class for our player and then over here in the player Constructor and then let's make a test function and on this function we want to spawn some kind of exception so the way we throw an exception is with a keyword throw and then whatever exception we want like for example let's just throw a regular exception so just like this and for this one you can open it up just like this so just make a regular empty exception or it can give some kind of message so for example player exception okay so yep just like this so now up here let's remove our previous testing code and now let's create a new player and go inside the player and call test function okay let's see and if there it is that one did fire off a player exception so if you want to throw your own exceptions in your own code this how you do it just use the throw keyword and then you can even make your own exception type for example let's make a class let's call it in valid player name exception the Only Rule is that we need to extend from exception so just like this and now over here instead of spawning a general exception we can do our regular one so just like this let's run our code and if there is exactly like that so exception of type and of our type invalid player name exception also one more thing is for example over here if we do a try catch sometimes you might be running this inside some kind of function and that function might be calling some other function that might throw an exception so essentially you've got functions within functions and sometimes you want to basically just keep throwing the exception all the way up the call chain so if you want to do that you can just call throw just like this and this basally going to rethrow the exact same exception and if there is in this case since we are throwing once again on the main then we end up with a regular exception so by using the try catch to handle exceptions you can make your code a lot more robust for example when making a game you really never want the game to crash if something goes wrong like for example the player somehow has zero items and CA a divide by zero exception if that happens you really don't want the code to break you don't want the game to crash so if that happens you probably want to have that in some kind of TR catch Block in order to catch the exception and handle it in some kind of graceful way and especially when working with some external code like for example contacting some API on some web server for those you really want to add try and catch in order to make sure that your program continues running correctly regardless of what the server applies hello and welcome I'm your KMI in this lecture we're going to learn about enumerators how to implement I enumerable and I enumerator okay so something we've already seen several times is doing a simple for each on a list so we can do a list of in some kind of int list then we just construct a list and we can do a for each in I in the int list and Yep this works perfectly so we can do a four each and cycle through every element in our list but then if we try doing a four each on some kind of custom type so for example here let's make a player new player and then let's try doing a for each on this player and hope this does not work we have an error like it says here the for each statement cannot operate on variables of this type because player does not contain an extension definition for get enumerator in order to make the four each work with custom types for that we need to make our custom types enumerable so let's learn how to do that for example let's define a class for holding a single stat so some kind of name and value so just name it stat and inside just have a string name and just an in for value and then let's make a class to hold a bunch of player stats so class called player stats and over here for example let's have some fields of type stat let's say for Dex for strength wisdom and so on so yep just like this let's just construct these objects okay so yep just like this and now let's say that we want to do a for each and we want the for each to work on our player stats so basically we want to be able to cycle through each one of these stats individually so to do that the first thing we need to do is over here let's Implement an interface let's implement the I inumerable this one takes in a generic so let's say our generic type is going to be of type stat yep just like this so now we can implement this interface so it require us to implement those two functions this requires us to do something that constructs an object of type I in numerator so inumerable and numerator those sound similar but they are different so let's make a class that is going to be our enumerator usually for that we build it as a nested class so here let's make that so the player stat enumerator and we're going to implement I enumerator and again also of type stat then let's see what we need to implement on this one so over here let's select and then over here on this little light bulb let's implement this inter interface save there you go now we need to implement all of these and over here we just need to handle some kind of index and based on the index we're going to return either of these ones so that means we also need a reference to our player stats object so let's make a Constructor here and on the Constructor let's receive our player stats so you have this let's store it inside so just like this we have our player stats and then we also need some kind of index in order to know the move next the current and so on so let's do an in for the index and for the index let's default it to minus one the reason for that is because the four each is going to call the move next before it grabs the current so let's start off at minus one and then on the move next that's pretty simple so let's just do index Plus+ then since we have just three stats so this one is going to be index zero one and two because that over here if the index is bigger than two if so let's just look back to minus one then this one needs to return true if the enumerator was successfully Advanced and false if it has passed the end the collection so we can just return if the index is not minus one okay that's our move next function to dispose we don't really need to implement that one and the reset we can just set the index to minus one so what's important is over here the current this one is a property so let's go ahead and implement this property this one is going to have a get and on the get we're simply going to test out our index so let's do a switch on our index let's add a default and let's add a k Zer so k0 let's return go inside the player stats and on index zero let's return for example let's go go up here let's see so the first one is Dex then case one and two for this one let's return strength and this one let's return wisdom okay so yep so that's a current and over here for this other current we can just do a pass through onto that one just like this so Yep this is our enumerator class so we receive our player set so we have the original object we have some kind of index then on move next we just increase the index and on current we just grab the value based on that index so now here on the get numerator we only just need to return a new player stats enumerator object and on that one we need to pass in this so just like this and on this one again same thing we can do a pass through function so return get En numerator okay so now finally up here we can construct let's construct an object of this type of our player stats let's construct a brand new object and now yep now we can do a for each on that one this one is going to return a type stat stat in our player stat let's just see conso the right line on our stat and just to be able to see that let's inside our stat so inside this one and let's just override our two string and let's return the name and then the value okay so just like this let's test and see if our 4 each is working and if it's going to go through all of our various stats and if there is Exel like that so it did a 4 each through our custom type it found dexterity strength and wisdom all right awesome so this is how you make your custom types work with a 4 each you just need to implement both of these interfaces just do that do some basic logic in order to grab the current value and with that you can then use your custom types inside a for each by the way alternatively for this specific use case where we have a fixed number of elements that we want to cycle through for this a simpler approach is just on the enumerator we can just do a yield return so over here on the function to get the enumerator instead of creating a brand new enumerator instead of defining this entire class and creating all that if we just have a fixed number of elements we can type in the keyword yield yield return and then whatever we're going to return so let's say return that X then do another yield return for strength and another one for wisdom basically what this is going to do is this function is actually going to be called multiple times so by making something a numerator and using yield return by doing that this function is essentially going to store its state so the first time that we call this it is going to return Dex the second time we call it is going to return strength and the third time we call this it is going to return wisdom let's test this and if it works exactly the same we have our three stats so basically whenever you have a dynamic number of elements so if inside your custom type you have some kind of list some kind of collection for that you can define an entire enumerator and write all of this code but when you have just a fixed number just a bunch of simple stats a bunch of simple elements for that just using a simple yeld return this one is much easier also since we're on the topic of I numerator and I numerable let me mention one Unity specific thing which are Cod routines if you're just using C without Unity then don't worry about this part but Unity basically has co routines which is a way to run logic across multiple frames and specifically it works with I in numerator in order to make a co routine we make a function that returns I in numerator and then over here you can do whatever logic you want then when you want to split the logic you can do yield return and then Unity actually has some nice builtin functions like for example we can do yield return wait for end of frame this basically going to wait for the end of frame before running the code down here or for example we have wait for seconds this is going to wait for a bunch of seconds before continuing to execute the code for let's wait for 3 seconds then let's do a debug. log and say something so let's do debug. log before and after okay so this is going to basically run some code after some time so this is a great way to handle timing based logic in your games with this we have a code routine and now to start we just need to be working inside a monob behavior class and of course this script needs to be attached to a game object so then we do this and let's make a start and over here on start we just need to call the function start Co routine and this one takes our I enumerator so let's just call my code routine just like this yep so this is going to start running this code routine so we should be able to see this log immediately then wait 3 seconds and then see this log okay it's running there's the first message and after 3 seconds we should be able to see yep there it is the second message all right awesome so these are Co routines which is a Unity specific thing that works with I numerator now personally I must say I'm not a big fan of Co routines simply because I don't like this pattern that they force you to use it feels needless ly convoluted to me you need to be working on a mon Behavior you need to call start Cod routine you need to make a special function that returns aerator use yield return and so on so personally I'm not a big fan of this huge pattern personally I prefer using super simple FL timers but Coe routines work great so you you like this then definitely go ahead and use them okay so those are enumerators it's how you can make your custom types work inside a 4 in and various other settling Logic for example things like link which we're going to cover later on in the advance section hello and welcome I'm your Cod mon in this lecture we're going to learn about namespaces in C okay so namespaces this is one of the main ways you have of organizing your code think of it kind of like folders for your code for example you would have some kind of folder for your game logic another one for some a logic another for the UI and so on basically it helps you keep things organized and actually we've already been using a bunch of namespaces up here all of these using statements these are all namespaces for example the console class that we've been using this one exists inside of the system namespace we can access it by writing using system up here and then we can access the console class although actually when making a console app the system names space is included automatically so technically you don't need to explicitly Define it but in most case you do need it so you do need to add using some kind of namespace and also over here on this template when we create the brand new project it automatically created our program class with our main function and it put it all inside a namespace now I should say technically you don't need to have a namespace so if I get rid of this and this Yep this still works this is perfectly valid code basically when it compiles it will simply place this class in the root namespace to create a namespace you really just follow this symbol syntax so you write the keyword namespace and then whatever you want to name your namespace also namespaces they can have nested namespaces for example inside the system namespace there's a whole bunch of stuff like for example the IO namespace this is the one that contains a bunch of classes related to input and output and so on then here is a script inside of unity so Unity normally has most their things inside the unity engine namespace for example mono Behavior this one exists inside of unity engine then if you want to do things inside the UI then you would use using unityengine.ui so basically all the classes are nicely organized in namespace that makes sense for them you can also make nesson namespace yourself you can just write some kind of name then add dot then add another name and so on then one big benefit of name spaces is avoiding name conflicts for example let's say I want to define a player class and now let's say I want to define a completely separate class but I really do want it to have also the same name so also another player class since classes have to be unique this does not work here we have an error that it says that this Nam space already contains the definition for our class named player and right way this is also giving us a hint as to what the solution to this problem is the solution is simply put it in another namespace so namespace I can give it whatever name I want then I can place this class inside of that namespace and up here I can use either of them so I can use player and this one is referencing this one down here this one inside of this namespace or I can go inside the code monke namespace access player and up with this now I'm referencing the other one in the other name space the another common issue is sometimes you have a conflict that the compiler cannot resolve for example over here I added using system and using Unity engine and now I want to use the random class but the problem is that there is a random class in both Unity engine and inside of system so the two name space that I'm using up here they both have a class with the exact same name so basically the compiler over here does not know which class I'm referring to so to solve this problem either we get rid of one of the using statements and Yep this works so now there's no more errors however that won't probably break any other place where you're using classes from that namespace so in this case for example if I add the serializable attribute which exists inside of system by solving this problem I now cause this problem so to solve these kinds of naming collisions usually the simplest thing is to just write the full name so for example up here on this one I can write system and even now this one works and this one has no problem or alternatively I can just add the using system up here so this one no longer has an error but this one does have the error and over here I can just write the full name Unity engine not random and yep like this compiler doesn't have any questions it knows that I'm trying to use the random class that exists inside Unity engine another thing you can do with Nam spaces is simply using an alias so over here we can say using then give it some kind of name like Unity random and then say equals Unity engine. random so basically this one is now an alias to this so down here instead of using all this we can use this and if there you go it does work this can be quite useful when you have a really complex project with some super long names when that happens using the Alias can really help simplify your code okay so that's namespaces it's a simple yet very useful C feature as your project grows more and more they become more and more useful hello and welcome I'm your Cod monkey in this lecture we're going to learn about the Singleton pattern in terms of game development this is probably the most useful pattern and also one with a lot of pros and some cons so let's learn about it okay so the Singleton like name implies we have just a single instance of something in this case we have a single instance of some kind of class so for example we have some kind of game manager class and over here the way that we have just a single instance is usually with some kind of static field again static means that the field belongs to the class itself and not any instance of that class so usually we make it private static let's call it of game manager and for the name we call it instance instance is usually a common name used for Singleton although sometimes it's literally named Singleton so either one so here we have our private field and we made this private specifically for one very good reason the reason is because this class should be the only one that is responsible for creating the Singleton instance other classes should only be able to get it so the way that we're going to expose this is by using a public property so let's make one also going to return typ game manager and property usually starts by pass case so you've got our property instance and over here on the get on the get we just return our instance and then for the set for this one again like I said the instance should only be set by this one so for that one let's make a private set and on private set just set instance equals value okay okay yep so just like this basically here we have a field that anyone can access but only this class can set now for actually creating this Singleton let's first cover the barebone C method and then I'll cover the unity specific method so Singleton usually have what is called Las intiation this means that the instance is created only when it's needed for the first time and in order to do that we just put that logic over here on the get we just check if our current instance it is null if so that means we have no instance and if so then we just create a brand new one so we create and then we return it so basically this means that as our program starts there will be no single T instance and then the very first time that we use it it will actually create that Singleton also as a general rule Singleton usually have private Constructors so if you define some kind of Constructor it's going to be private that way any code up here cannot do new game manager nope this does not work because the Constructor is private again that's because the singl ton is meant to be the one that is responsible for creating the Singleton instance so the way that we use this is actually very simple alternatively another way of implementing the Singleton pattern is without Las intiation so an alternative would be to expose the Constructor and then just check if the instance if it is null if so set the instance to this so this is another way that the single pattern could be implemented but again usually you have some kind of private Constructor that only this one calls and over here we don't even need any kind of set because only that one is going to be set so this is the basic C Singleton pattern and now in order to use it it's actually real simple we just access the static property so we just go inside the game manager access the instance just like this so let's do a console the right line and now we didn't create any kind of game manager object up here this code is not creating anything does not know anything about any of that it just knows that it's accessing the game manager accessing the static instance that's it so if we test this and if there it is then we do have an objective type game manager so just by accessing the static instance it automatically created that object and return that instance then over here we can do whatever we want so for example some kind of public test function so we have some kind of function that does something and then up here in our code we can go inside the game manager we can access the static instance we can call test function and Yep this will indeed work also by the way note how just one instance is created so up here we are accessing one instance in here and then going through this one to calling the test function so we're accessing this property twice but when this code runs obviously since instance is only going to be null just once it is only going to create one game manager so no matter how many times we call this we end up with just one single instance and since we made the Constructor private because that nothing else can construct this object so we know for a fact that this class will only have a single instance making this the Singleton pattern as for the benefit of it the benefit is that it's really super simple to use just by accessing the class itself and accessing some static instance just through this we have a reference to whatever object we have of type game manager so we can call functions on this class we can do any kind of thing we don't need to keep track of any kind of game manager reference so for example if we had some kind of class of type player and then the player does something it like adds some kind of score so the player would end up killing some enemy or something over here the player does not need to store a direct reference to the game manager we can just go inside game manager access static incense and then we would call some kind of AD score function by using the single we have our instance of the game manager really easily accessible from pretty much anywhere in our code base and now that we've seen the single over here the barebone C Singleton let's see how to make it in unity in unity it's a little bit different since Unity components have to extend mon behavior and one of the biggest limitations of that is you cannot access the Constructor directly so in unity you simply make a regular script extend mod Behavior as usual then that script is attached to some kind of game object so all pre standard and over here in the code here personally this is the only scenario where I use properties and here I don't even use the backing field directly I use the auto implemented property so I make it public because I want to have a public yet let's make it static of type game manager let's call it instance and then this one has a public yet and a private set so yep just like this so this field has the perfect accessibility that I want for the Singleton so any class can get it but only this class can set it and then on the unity's standard awake function over here on this one just set instance equals this and yep that's really it the awake is going to run when this game object runs and when that happens it is going to assign the instance into this now this one technically isn't enforcing the Singleton rule if over here in unity I duplicate this object multiple times then I'm going to end up with multiple game managers and the one that is going to be set on that static instance is going to be whatever is the last one that runs so for this problem normally the only thing I do is I'm really just careful enough to only make one object object that has the static script that I want but if you want you can also add some proper safety checks one way to do it is over here before assigning the instance we check if instance is not known if so that means that this script already exists and the instance has already been assigned if so this should not happen so over here we can probably just fire off a log error so if over here I duplicate this object and I try running if there it is we have a log error and tells us what the issue is we can see it's on the game manager class then you can either manually fix this so go into the hierar key and delete the second one or over here on the script itself we can destroy this game object to make sure only one is kept alive so for example instead of that let's just destroy this game object and then call return so the rest of the code does not work so if we run this and if there it is we have our error because we do still have two game managers however if we only in the hierarchy yep the second one was inde the destroyed now this Singleton pattern is extremely useful when you have some kind of class of which there is only meant to ever exist just one single instance of that class for example in games it is very common to have some kind of General game manager and again you have just one usually you also have some some kind of audio manager some kind of input manager and so on then for single play games you might just have one player or even just one world so if you have just one of something then the single pattern is actually really great it makes a lot of sense and makes it really easy to access that static instance for example if your UI code wants to show the player's Health it doesn't need to have a direct reference to the player it can just grab the Singleton reference or if your player needs some kind of input it doesn't need a reference to the input manager it just access the static instance and that's it so the single T is great especially in game development where you normally have tons of systems that have a single instance however the Singleton pattern also has some potential problems if you Google you will find a lot of people arguing that this is a terrible pattern although I should say usually those anti Singleton comments are always a little bit too extreme the Singleton is a tool and just like any tool it can be used or abused and in general Singleton seems to be worse for regular game development not game development for game development like I said it does have a ton of benefits that do outweigh many of the possible cons and in general if you write some good code you can actually minimize a lot of those cons like the main con is simply the fact that Singleton are by definition global data the whole purpose of Singleton is to have a single instance of something that you can easily access from anywhere so because that it means that it can have many of the negatives that any kind of global data can have your code can easily become really messy way tons and tons of connections between various classes since Singletons are so easy to use you might be inclined to use them all the time and make it so that every class pretty much depends on a ton of singl ton classes doing so ends up with a massive dependencies ideally your code in your classes should be as decoupled as possible you shouldn't have a ton of connections this advice is applicable really all the time not just in relation to singl tense but single tense May violating this guideline very easy so that is why you need to be extra careful and because those issues of classes becoming coupled with tons more classes because that testing can become insanely hard simp because in order to test something if the class you're testing accesses some kind of single T then that single T needs to be created in order to test and in turn maybe that single T then uses yet another Singleton and on and on so you might end up requiring a ton of setup to do even just a basic barebones test another more serious problem is with regards to multithread code you need to be very careful to make your Singleton thread safe or simply make sure you only access singl ton from the main thread for example if you use Unity dots to write some super performant multithread code the simple way to avoid this problem is to do all your logic in tons of threads then at the end after all those jobs are completed then you do anything that requires a main thread like for example accessing The Sound Manager single T to play some s a sound effect so Singleton can indeed do have some negatives but they're also extremely powerful and extremely useful it is a pattern that can be very good in used but also very easy to abuse personally I use a ton of Singleton in all my games I just also make sure not to abuse that pattern I make sure to control how often I use them and limit class coupling as much as possible so my advice is don't be afraid of Singletons they definitely have their place but use them properly so they actually help you as opposed to hurt you now the Singleton pattern is just one of many programming patterns it is the one that I use most often and I find most useful so I made this static in lecture now next one let's go through a bunch of other patterns that also have their use case hello and welcome I'm your Cod Maki in this lecture we're going to talk about a bunch of design patterns okay so first of all what are design patterns in the last lecture we already covered one specific design pattern the Singleton these are basically some general reusable solutions to some common programming problems the Wikipedia page has a great reference with tons and tons of detail for example the Singleton pattern that we just saw this one one is a nice solution for the problem of how do you ensure a class is only one instance and how do you ensure that it has a global point that is easily accessible that's the entire purpose behind that pattern and by writing the code like we saw in the previous lecture that is how we can achieve those rules so that is a very good solution to that common problem and within that pattern we also saw another mini pattern the lazy initialization so this is how we made sure that the single T only gets created the first time that it's actually needed another pattern we've actually already seen is the Observer pattern this is a pattern where an observer interacts with a subject to be notified whenever something happens so Yep this is literally what we already covered in the events lecture a class subscribes to an event and again gets notified when that event is fired so using events is essentially The Observer pattern another common one is the command pattern with this one you can basically create commands that can be executed later on so one common use case for this kind of pattern is making some kind of undo system so when you do some kind of action you create a command for the undo action with all the data that is needed to perform that undo and then when you want to undo it simply runs that command so this is the kind of thing that can easily be built by combining a stack with delegates another interesting one is the factory pattern with this one you basically put the creation of an object in some kind of factory class and then instead of having every class with a Constructor that anyone can call instead only that factory class is responsible for creating those objects again we also saw a part of that pattern in the Singleton pattern where the Singleton itself is responsible for creating the object so the factory pattern is pretty much just a more dedicated part of this pattern it can be really useful to limit the number of placees from which a a certain type of object can be created then the object pool pattern this is a really useful one this is how you can create a pool of a bunch of objects and in doing so it really reduces the impact for creating and destroying objects Unity actually recently introduced an object pool type that does exactly that if you have performance issues with spawning and destroying objects you should definitely be using some kind of pulling then dependency injection this is an excellent pattern for testing your programs this one uses interfaces quite heavily it's one of the main reasons why interfaces are really EXC you can inject different types of objects as long as they Implement a common interface then the adapter pattern or simply a wrapper this is especially great when working with some kind of third party code you build a wrapper that only contains the info you care about and then you don't have to worry about any more of the underlying implementation so as you can see over here there are tons and tons of patterns and pretty much all of these have dedicated pages so if you want to dig deeper I definitely encourage you to do so these patterns were created by some very smart people in order to solve some very common problem so rather than Reinventing the wheel just being familiar with some of these is really great but you really don't need to memorize all of these I highly encourage you to research them just so you know they exist but don't try to memorize everything in one go like with the visual studio shortcuts lecture this is something that you pick up more and more over time but definitely do take the time to research these in a little bit more like the say goes there's no point in Reinventing the wheel sometimes you have problem for which a pattern would be the perfect solution and if you know that pattern then you can simply apply it rather than having to reinvent a brand new solution now for me personally I don't normally just use the Singleton and the Observer pattern specifically I use those pretty much EXA like they are designed and then I use various other ones when I need them even if I don't necessarily follow these strict patterns so sometimes for example I have some kind of factory pattern I have that where some objects are created only in a specific place but I don't necessarily create a brand new specific Factory class then like I said sometimes I use something similar to the command pattern especially in management games to queue up all kinds of actions and in unity Unity is all made about composition of various scripts so technically it is the composite pattern and I do normally try to compose my complex objects usually by composing them based on interfaces rather than just making one huge object with all kinds of logic so I highly encourage you to research some design patterns in order to be familiar with them but again don't worry too much about memorizing them especially not all of them I certainly do not have memorized all of these patterns only a handful of them then as you go through in your Game Dev or programming career you'll learn which ones you will commonly use as you encounter similar problems hello and welcome I'm your Cod mon in this lecture we're going to see a nice project that incorporates everything we've learned so far in this intermediate section although actually we've already covered a ton of stuff and some of it wasn't necessary to get this zmo build which this is actually a great practical example of everything you're learning in this course this course is all about C and C has a ton of tools and features but that does not mean you need to absolutely use everything all at once every time the goal of all this is to use the things that help you achieve whatever goal you're trying to achieve so let's see the demo it's inside the UN project inside the lectures and down here at the bottom we've got the intermediate project so we have our game scene let's open it and here is the miname running so I've got a player object I can move around by pressing the arrow keys or was then down here I've got an inventory with three slots and there are some weapons and some items that I can pick up there's also some enemies that are spawning coming to me so I can approach the weapon order to pick it up and I can click in order to start shooting and start taking down some enemies so as I shoot they take some damage they get a health bar that goes down and updates and eventually they die and they spawn want a bunch of money then for the money it's also something that I can pick up so I can touch it and pick up all this money I can see the UI is updating as I pick up some more money and there's a bunch more items and objects so for example there's some bombs those bombs are also attackable so I can attack them and I can destroy them and then I've got the other weapons so I'm using a pistol and then I can pick up a shotgun and down here on the inventory yep I picked it up so now I can swap the shotgun and I can start shooting and this one has a different shoot so this one can now shoot multiple bones at once and again I can pick up all this money and then over there is also a nice little potion I can pick it up and again that's also another item it's a usable item so I can use it click to use it and if there you go this goes into some kind of super mode where the player is now moving much faster so I can move around really fast and eventually it ends up and I can select another different one so let's go back to the pistol let's go into that one speed it up back to the pistol shoot that one shoot that one and so on so Yep this is the demo with lots of stuff happening that involves a lot of the things that we've already learned about there's player movement there are all kinds of interactions there's shooting there's enemy there's Health there's damage there's an inventory a whole bunch of items abilities and so on so as you can see in lots of stuff now let's inspect this to see how it all works and how all the elements of C how all of them are being used although also before we look at the code let me make one quick note basically how I built this project is not the absolute only way to do this you could build this exact same project in a million different ways so as we're going through it if you think to yourself that you would build some element in a different way than I did that does not mean that you're wrong there's always many many ways to achieve the same result and the way that I buil this demo is simply just one way out of the millions of possible ways to build it so if you come up with different way to implement the exact same elements you can definitely be right as well okay so here in the project files we can see that this demo is quite a bit larger than the beginner demo there's quite a few more files that's due to the fact that it is larger than the beginner project but also due to the fact that the code is much more well organized there's plenty of small class that do one thing and one thing only as opposed to the beginner project where try to make it as compact as possible which meant putting too much Logic on the player class whereas over here you can see how each file is actually pretty compact you can see most of it pretty much just over here on the quick code preview most of these files are actually pretty small so let's begin inspecting this and let's actually begin with the most complex script of all the player script let's do just a quick overview of this one before we see everything one by one and right away as soon as we open this we can actually already see a bunch of things that we learned in this intermediate section so right away we can see a namespace so all of the code for this project all of it is inside this specific namespace and one of the benefits that I talked about namespace is simply the fact of name collisions and actually on this companion project note how all the code for all of the various lectures and all the demos all it is inside this one project and I do have a bunch of other demos that also have some kind of player class but because over here I'm using a nam space that makes it sure that this player class does not have a naming conflict with any of the other player class so that's the first thing using namespaces then by the way the mono Behavior over here here we have are seeing an instance of inheritance and mon behavior is really just a base Unity class basically if you want to attach any script as a component in unity so for example over here if I select the player object and I look in it yep it has the player script attached to it so in order to attach a script onto a game object needs to inherit from that class then we can also see over here we have the Singleton pattern so we've got a public static player instance with a public yet and a private set and this one the instance is being set over here on a wake this is a Unity specific function that is called whenever this script is initialized so on awake we are instantiating the instance onto this since this little demo is meant to be a single player game it makes perfect sense that the player is a singl t since there is only ever meant to be just one player next we can also see usage of a bunch of constants again constants are values that are never meant to be changed so in this little demo it makes perfect sense to use a Conant for the base movement speed for the damage amount and for the super timer Max then we can see a whole bunch of events we're going to see these in detail a little bit then we've got a bunch of fields and by the way the serial field here this syntax is actually an attribute this is something that I cover in detail in a lecture in the advanced section over here this specific attribute this is another Unity specific thing it is just so I can expose these fields over here on the unity inspector without having to make these fields public if I were to just make them private without this attribute then it would not show up in the editor so in order to do that and keep the code clean keep the fields private in order to do that they need to Mark the serialized field private okay then we have a bunch more Fields then we got some inventory logic we're to see this in a little bit then we've got the update this is another Unity specific function basically the code in here is going to run whenever the frame updates so if the game is running at 60 frames per second these functions are going to run 60 times per second we've got a function here to handle the object rotation so that's the logic for how over here the pistol is rotating to face wherever I'm aiming with the mouse then there's some code to handle the items I'm going to cover the inventory in a little bit then some code to shoot then we've got some standard movement code so just some basic IFS calculating a certain move vector and then just moving the transform alongside this move Direction the transform is basically the game object in unity then we've got the super and let's begin by inspecting in detail over here the collisions again this is another Unity specific function this one has to do with the unity physics system basically over here for all the objects that can be picked up like for example over here the money the money object over here has a little collider so this little box is a physics collider and basically as a player goes inside of this collider is going to trigger that function and and over here this function will be called with whatever object it collided with so the first thing we do is try to get a component again this another Unity specific function this one tries to get any component of a certain type that is attached to the same game object so basically as the player collides with this money object it is going to try to get some of these components and specifically it is looking for a component that implements interface I grab object so here we see an example of an interface and in this case this is an interface that represents any kind of object that can be grabbed so in this game that's a money that's the weapons that's a potion and so on and the interface defines a bunch of functions which all objects that implement this interface must Implement so one of those is of course the money class so this one as you can see it extends the mono Behavior class this is the base Unity class so this can be used as a component and then it implements the igrab object interface then for the logic over here it's pretty simple this is really just a movement logic so over here with a weapon if I shoot a zombie y there you go the money gets spawned and moves a little bit just to have a nice little bit of visual polish so as the enemy dies it spawns some money and moves a little bit and then stops moving so that's really this code in action it moves the transform then lowers the magnitude which is how big is the movement Direction vector and if it is in a certain magnitude then just disables the script which means this update function will no longer be called then down here it implements the functions for that interface so we've got one to destroy this object and then some related to inventory objects now in this case money is not an inventory item it cannot be placed in inventory so over here for these functions just returns false and null before we see the inventory let's actually see how the money is actually connect to the UI so over here in the UI we've got a little indicator to show how much money the player is holding so going back on the player script here on the on trigger enter over here we try to get a component of that interface type and basically if the player hits the money object then this is going to be true it is going to be able to get this grab object component and when it does it is going to fire off this event it is going to fire off with some custom event TS and basically pass along the grab object that was grabbed so this event is defined up here so just a basic event handler that has a custom event Ts for our grab object and over here actually something also pretty interesting which is how in the events you can subscribe to the events from anywhere meaning you can actually subscribe from the class that actually fires off that event so that's exactly what I'm doing here so I subscribe to the on player grab object event and then over here accessing the event ARS in order to get the grab object and doing some type checking in order to see if that grab object is of type money so this identifies what object I picked up and if so then it's going to increase the money amount this is just a basic integer and as it does it also fires off another event on money amount change and the one that listens that event is this little UI element so over here in the hierarchy if I go inside the canvas I've got this player UI script and yeah this one is pretty simple so on start which is a Unity function that gets called whenever this object is initialized so right after the awake so when that happens it accesses the player static instance again the singl ton which is super easy to use which in this case makes perfect sense because this is a single player game there's only one player so use that to easily access the player and then simply subscribes to the event on money amount changed and when that happens it simply calls the function in order to update the text so it just goes inside the player static instance again accessing the Singleton calling a function to get the money amount that the player is currently holding and just passing that on into string in order to update the text this right here is a great example of one of the main purposes of events it allows you to keep your code decoupled and specifically in games it allows you to decouple your logic from your UI elements note how over here on the player class this one has no Direct connection to any UI class it does not know and does not care if there is any UI listening to any kind of money amount or anything meaning this player class is completely decoupled from this UI class which does display the money so if I'm playing the game and I pick up some money yep the UI up there is indeed updating it works great however if I go there and I disable the player UI game object so this script is no longer running but despite that there are no errors because again the player UI that one depends on the logic class but the logic class does not depend on the UI class meaning that the player can exist without or with any y it does not matter it works either way that is really one of the main powers of events it is how it helps you make your code much more decoupled so things can exist without other things now let's look at how the inventory over here works so this one also has a nice content for our capacity then it has a bunch of events that get fired whenever some things happen to this inventory in order to store the inventory items it is stored simply on a list and then just keeps an integer for the selected index so basically which item is currently being being selected then we've got some basic functions so one testing if we can add an item so really just testing the inventory list against the capacity then we got a function to add an object and over here we have an example of a custom exception so basically if we try to add an object without first checking if we can add it so if we try to add it but we can't if so then this is going to throw a custom exception of this type inventory for exception so the exception is defined down here pretty simple doesn't even have any extra data it's really just a type just to be identified exactly what exception it is but assuming things go well it simply adds the item onto the inventory and fires off an event to know that the item list is changed and then just has some more functions in order to set the selected index to get it in order to get the entire inventory item list and get the selected item so here we have a pretty basic inventory it sores a list of things and exposes a bunch of functions that can do certain things so you can work with the inventory also again note how in this inventory class there is no mention of any y anywhere once again that is because of the same thing so this inventory class is this one handles the actual inventory logic and then we have a separate UI class that listens to these events and then updates UI so over here we can see that so inside the canvas we've got the inventory UI so that is this element down here and on this script we have a reference to the inventory this is the one that is currently being held by the player and then we have a list of all the inventory slots these are all of these individual slots these are individual objects and as such they have a custom class in order to handle each individual one so rather than putting the logic for each each specific one inside of the main inventory UI class rather than doing that it is nicely separated so there's one class that handles the entire inventory another one that handles each individual slot then in this slot this one is a pretty simple script we just have a reference to an image and the select game object so the image is the icon Sprite and the select game object is this little green arrow in order to show which item is actually being selected then over here the behavior for each slot is actually pretty simple so we've got one to set the selected state so this really just either enables or disabl that select the G object with the visual then we got one to set the item Sprite again just setting the Sprite for whatever object is placed in that item location and then we have another one in order to set the click action so over here we can see delegates in action so we've got a simple action Delegate for the click action and simply just going inside the button and adding a click action so so an action that is triggered whenever we click on the button and all of these functions these are all handled by the other inventory UI class so over here this one again this one has a list of all the inventory slots and on start first we access the inventory and we subscribe to the two events that we need to so one then the item list changes and one when the select index changes then here we can see the click actions we can see a use of Lambda Expressions so instead of defining proper functions we're really just using the inline Lambda expression this works great when it comes to button actions so we're telling it giving it a click action for the inventory slot on index zero so the first slot telling you to select this index when we click on it then doing the same thing for all the other slots and then we have the functions listening to the various events so when the atom list changes when that happens we want to update the atom list and update which one is selected and on this one same thing just update selected and then for these for updating the item list first thing we do is cycle through the internal list we set the select the state to false in order to deselect all of them and we set the items right to null in order to disable the items then we cycle through the inventory item list that is inside the inventory we go through each of those elements in order to set the slot to the corresponding item Sprite basically this populates all the buttons and then for the update selected this one is also pretty simple so first we deselect all the buttons then we ask the inventory to get the select index and set that one to select it as just that one so yep here the inventory is empty and as I pick up a pistol yep it sets a weapon and sets that and if I click on one of these I can swap which item is selected then if I shoot I can use the pistol I can pick up the shotgun click the selected and use it or pick up this one click it and use it see y That's the inventory with various slots let's also see this over here the inventory this one has an item list and it's of this type I inventory item this another interface here we can see the usage of an enum in order to define the item type so it can be a pistol shotgun or potion and then various functions so one to get the atom type to get the Sprite and to use the item so with this let's look at the weapons and first of all in terms of structure I decided to separate the logical items that go inside the inventory and the actual items that exist in the world so for example over here in the world there's a pistol that the player can pick up this one has script of type pistol object so there's that one and then there's an actual pistol that contains logic so there's onlyu there's the potion object and potion shotgun object and the shotgun here for the pistol object this is the one that implements Agra object so this is how the player can actually pick up the weapon and this one unlike the money this one does return true because does have an inventory item and when calling the function to get it it simply creates a new pistol so this is the class that is meant to handle the logic for the actual pistol as to when that runs it's over here on the player when the player triggers an enter so when it goes into inside another collider it checks if it has a grabbed object which again the pistel object does implement this interface then the pistel object can indeed have an inventory item so then it checks if the inventory can add that item if so it adds it onto the inventory and goes into the grab object nor to grab the inventory item so that is what is going to construct a brand new pistol and over here is the pistol script this one has a function to return the atom type so that it knows okay this is a pistol it has one to return the atom Sprite and over here we see another instance of the single class we've got the game assets this is a class that I use in pretty much all of my games it's just a super simple way to access any kind of assets so here in the game in the scene I've got a game assets object and inside it as this script and then this script I can drag any references that I want to reference anywhere in the code base so this is another really useful use case for the Singleton pattern so anyway so the pistol gets the Sprite for the pistol and then it has a function to use the item which in turn is going to tell the player in order to shoot then the player shoot function this one is pretty simple it really just fires a rast this kind of like a laser in the physics World in order to find other colliders this is basically how it finds other things that it can shoot and over here again note how I'm not looking specifically for an enemy or a bomb but rather an eye attackable interface so this is how the player can actually shoot any kind of object not just enemies not just bombs it can shoot anything that implements this interface but before we get to that let's actually go back into the player class and over here note the override on all of these that is because the pistol this one is actually extending a weapon Base Class and this one here it is this one is an inventory item so that is how it can be placed on the actual inventory and this one is marked as abstract because we are never meant to construct just a base weapon but rather the weapons that extend from this class and everything is abstract so this is all up to the extending classes to implement these functions so the pistol over here implements these functions like this and the other weapon is over here the shotgun again this one also extends the weapon and this one does override with different things so it returns a different item type a different Sprite and over here we got a bit of different logic so the pistol just shoots once whereas the shotgun shoots multiple times so now we can go back here into the shooting code so again this one fires a rast in order to find all the physics objects that it hit if it did manage to hit something if so then it's going to try to see if that something is an ey attackable object and if so it is going to cause damage to that object here is the eye attackable interface really super simple just as a damage function so basically in order to make something damageable by the player all we need to do is implement this interface so for example here we have the bomb class this one does implement the ey attackable interface and this one is another super simple class it has the damage function down here for the interface and simply passes that damage function along down to the health system so the health system this is a great example of composition over inheritance basically the Bob is meant to have some kind of health so it has a health system but specifically it has a health system in a field as opposed to having of the health system code directly inside the bomb class this way it makes this health system reusable which it is indeed reusable since the enemy also uses a health system so let's inspect it and over here this is another preim class just has a basic functions for handling some kind of health so just as a health and a health about Max then as usual it has events for whenever all kinds of things happen so on health change or on dead then we've got the damage functions counts down the health amount and if under zero fires off the on dead and either way fires off the on health change so that is why over here the bomb this one we can note on start this one is listening to the health system on that event and when that happens happens it is going to run this code which is going to destroy the bomb and fire off this event the class that listens to that event is over here the game manager which again this is another one of there exists only one so this one is a Singleton and over here we can see that it is listening to the bomb on any dead event and when that happens basically just spawns a VFX prefab just as that and Shakes the camera so over here if I pick up a weapon and I shoot a bomb and I destroy it yep there you go it fires off some VFX and Shakes the camera yep there it is that's the bomb also note how the bomb also has a health bar that Updates this is another UI element that again is being driven by events so here in the scene we can see the bomb we can see the bomb has a canvas inside the health bar UI and this one note how this class is health bar this has nothing to do with any bomb or any enemy this one simply works with a health system it does not matter where the health system is attached it could be the player it could be a bomb could be an enemy could be building does not matter this health bar works on any kind of health system and the way it works is super simple just listening to a bunch of events and when it does then just goes into the health system to get the health normalize and use that in order to make the bar image fill them out so another super simple super short script it does one thing and just one thing and then our enemy class again this one also implements I attackable so it can be damaged it also has a health system so again it can be damaged it also fires off and on any dead event and note how just on this one and the same thing is over here on the bomb note how these are static events meaning that they belong to the class itself and not any instance of that class so that is why over here on the game manager when listening to that event it does not need a reference to every single Bob and every single enemy it just listens to the static event which is going to be fired from any instance of that class so for example when any enemy dies when it does it's going to run this code which really this one just spawns the money so spawns and sets it to go into a random position then back over here on the enemy class so we've got the event we've got the health system then on update we have some super basic AI literally just moving towards the player and again the player has a single T so it makes it super easy to access and then just listens when the health system dies and when that does it just destroys this game object so Yep this is another super simple class and the last two scripts that we need to look into are the holding object Visual and the weapon animator so the holding object visual this one is inside of the player game object here we have a holding object so basically inside of this object we place either the pistol game object or place the other game objects over here inside the prefabs we've got one for a pistol for a potion for a shot that is how over here the weapon that I'm rotating I can select different weapons and rotate some so this game object has that script attached and this one really just has the reference to the inventory in order to know when the selected weapon changes and when that happens it really just updates its visual that involves getting the select inventory item then doing a quick n check just to make sure there is an item selected and checking for the item type this one is going to be an inum so over here doing a switch on that enum and depending on that spawning a different prefab and finally for each weapon like for example over here the pistol it has a weapon animated script here is that script and right away we can see a Conant for a string like I said you should avoid using strings as identifiers at all cost but sadly actually the unity animator system this one requires using strings so rather than using a string down here for the set trigger on the animator instead of doing that I Define a constant up here and then for the rest of the code I only use this constant that really helps limit the amount of strings meaning the amount of potential problems that we have so it has a constant a bunch of fields then we've got the animator once again and this one also works based on events so it subscribes to the on shoot event on the player and when that happens simply just set the animator North to shoot it spawn the VFX prefab the little dirt that gets thrown out whenever shooting and then just spawn the bullet Ray prefab finally on this one since this element is being swapped out meaning it's spawned and destroyed we need to make sure to unsubscribe to the event so we don't have for example a dead weapon animator still listening to the same event so over here on the on Destroy which is a Unity function that gets called whenever the S game object is destroyed whenever this happens we are just unsubscribing to the event so we don't get comebacks for an object that is destroyed put all that together and here is the object I've got the inventory I can pick up a pistol and I can shoot a bunch of zombies when I shoot them they drop some money I can pick up that money then I can pick up different weapons so for example I can select now the shotgun and now this one shoots many more bullets I can shoot enemies and I can also shoot some bombs and boom there you go they all blow up it's all really satisfying then I can also pick up a different potion I can use it and all of a sudden I'm moving much faster and there you go just like this all right awesome so this is our intermediate project in this really nice project we have Incorporated almost everything we have learned so far you can go ahead and inspect this project for yourself in your own time in order to see how all the concepts we have learned have been used in this project feel free to play around the code and modify some parts to see how it all works if you make a mistake and you break something you can always just redownload the companion project so don't be afraid to experiment as always you'll learn by doing so take some time to do just that maybe build upon this in some way maybe see how you could add another weapon or another grabbable object or another enemy type hopefully with this video you understood how it's all structured so with this plus the knowledge you've gained through this entire course so far with all that it should mean you should be able to fully understand how all this is working how all these systems are interconnected if not then go rewatch some lectures on some topics that you find tricking or simply feel free to post a question in the comments and I'll do my best to clarify any doubts hello and welcome I'm your km all right so congrats on watching this entire free video course I hope you learn a ton I really hope that you took your time and really focused on learning all the topics in this intermediate section and if you're watching this video then I also hope that you also learned everything from the previous video on the beginner section if so then you are hopefully much more skilled now than you were when you started this course if you're watching this in the future then check the links in the description or the pin comment to see whether the Advan section video is over here on YouTube like I said in the previous video my goal is really to make all the video lectures free over here on YouTube if the premium version sells over a certain number of copies and I'm very happy to report that it has indeed gone past that threshold which is why this intermediate video is over here free on YouTube and the video lectures for the invent section those will also be coming out for free in about 1 to two months or if you want you can just go ahead and pick up the premium version right now and continue on to the advanced section right away you can watch all those lectures along with all of the awesome bonuses that the premium version has all right so thanks for watching I hope you learned a ton and I'll see you next time
