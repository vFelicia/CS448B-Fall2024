With timestamps:

00:00 - in this video we're going to look at two
00:01 - ways we can handle events in unity dots
00:04 - events are very powerful but as you know
00:06 - that is not about being data oriented so
00:08 - that means we have to be smart in order
00:10 - to implement events which are object
00:11 - oriented let's begin
00:16 - [Music]
00:20 - hello and welcome I'm your code monkey
00:22 - and this channel is all about helping
00:23 - you learn how to make your own games
00:25 - with enough tutorials made by a
00:27 - professional indie game developer so if
00:29 - you find the video helpful consider
00:30 - subscribing okay so here we're going to
00:33 - cover several ways of handling events in
00:35 - unity dots first of all if you're not
00:37 - familiar with dots and check out the
00:38 - playlist linked in the description
00:40 - I've also covered c-sharp events in
00:42 - another video so check that out events
00:44 - are excellent for helping keep your code
00:45 - clean and making sure that your scripts
00:47 - are nicely decoupled from each other
00:49 - however events are normally object based
00:52 - which makes them tricky when applied to
00:53 - dots which is that oriented and very
00:55 - heavy on multi grab now unity dots is
00:58 - still early in development which means
01:00 - the best practices aren't yet known so
01:02 - that's why here I will cover two
01:03 - different possible ways of handling
01:05 - events first I will cover handling
01:07 - events using a native Q&A struct for our
01:10 - event type and then for the second
01:12 - method we're going to do it by creating
01:13 - entities and adding an event component
01:16 - then in the end I will showcase a nice
01:18 - complete class I built in order to make
01:20 - events very easy to use which as always
01:22 - you can download included in the project
01:24 - files ok so here is the demo scene I
01:27 - have my player object over here working
01:29 - as an entity and when I press space I
01:31 - can make it jump and pipe start being
01:33 - spawned this is taken from a project
01:36 - I've been working on trying to make
01:37 - flappy bird completely with dots so if
01:40 - you're watching this in the future then
01:41 - check the link in the description the
01:42 - flappy bird dots project should be out
01:44 - within about a week so now our test here
01:47 - is we want an event to be fired whenever
01:49 - we go through a pipe the way that this
01:51 - is set up is the player never actually
01:53 - moves horizontally the pipes are the
01:55 - only ones that are moving here is the
01:57 - game and the scene view side by side you
01:58 - can see if the player is always right
02:00 - down the middle right on x equals zero
02:02 - and the pipes are the only ones moving
02:03 - this video is made possible thanks to
02:05 - these awesome supporters go to
02:07 - patreon.com/scishow to code monkey to
02:10 - get some perks and help keep the videos
02:11 - free for everyone so over here is the
02:14 - pipe move system it is pretty simple all
02:17 - we're doing is an entities for each
02:18 - cycling through every single pipe and
02:21 - grabbing the translation then we are
02:23 - modifying translation based on you move
02:25 - direction moving it to the left by
02:26 - certain mooo speed and at a time but
02:28 - before we do that we store the
02:30 - exposition before moving and then we
02:32 - store the exposition
02:33 - after moving and our event s is right
02:35 - here first we're testing if the
02:37 - exposition before is above zero and
02:39 - afterwards is below or equal to zero
02:42 - then it's in here that we have passed
02:43 - the player and we want to fire off our
02:45 - event so here it is again I start
02:47 - jumping and pipes are coming and I go
02:49 - through the pipe and it's in there that
02:50 - I want the event alright so let's start
02:53 - off by making our very basic event so
02:55 - here inside of the system let's just
02:57 - define a public event after event
03:00 - handler and let's just call it on pipe
03:03 - task so when the pipe passes the player
03:05 - so here it is a very basic event if you
03:08 - want to learn more about events in
03:10 - c-sharp then check the video linked in
03:11 - the description now let's start with one
03:13 - approach based on using a native cue so
03:16 - during our entities for each we're going
03:19 - to have our native cue and over here
03:21 - we're going to add our event onto the
03:23 - cue and then after the job is processed
03:26 - then we're going to read through the cue
03:27 - and fire off our event so first we need
03:30 - our native cue so we define it as a
03:33 - private native cue and now here we need
03:37 - a type so let's define a basic event
03:40 - struck to be our type so just a public
03:42 - struct let's go to our PI past events
03:45 - and now here we could also add a field
03:48 - if we wanted our event to have extra
03:50 - information but in this case and let's
03:51 - keep it simple and all you want to do is
03:53 - now when this event happens so you
03:55 - create a native cue of this time so we
03:59 - have our event queue and now in order to
04:01 - initialize it let's go into protected
04:04 - and override e
04:05 - on create method and in here we
04:08 - construct our event queue now here we
04:10 - pick our allocator and in this case
04:12 - let's use persistent
04:13 - so we're going to use the exact same cue
04:16 - every time we run the system and since
04:18 - we're using persistent then we also need
04:20 - to make sure to be allocated so it's
04:22 - also override the void on destroy and in
04:26 - here we just do even heal dot dispose
04:28 - okay all right so here we have our very
04:31 - simple native queue that contains
04:33 - elements of Pi past event now down here
04:35 - we need to pass the event queue on to
04:37 - our job and here in order to make sure
04:39 - that our job is actually running
04:41 - correctly in parallel then instead of
04:43 - using the event queue directly we need
04:46 - to use a native
04:47 - q parallel right so here we define a
04:50 - native q of the same type then we're
04:54 - going to use the type parallel writer
04:57 - and we simply get it by going into the
05:00 - event queue and as parallel brighter
05:03 - okay and now we can use this one safely
05:05 - inside of our job so when we have the
05:08 - event let's simply in queue something
05:11 - onto our queue and let's just pass in
05:13 - our PI past event and that's pretty much
05:16 - it very simple we just have our queue
05:19 - and we in queue an event whenever
05:20 - something happens now after we schedule
05:23 - our job here is the similar tricky part
05:26 - see what we're doing all the way up here
05:28 - is we're only scheduling the job so by
05:31 - the time we get to the code down here
05:32 - then this job has not yet actually run
05:35 - it has only been scheduled so if the job
05:37 - has in front and that means in native
05:39 - queue hasn't actually been filmed and
05:41 - the job system is also smart enough to
05:43 - know that this one is being used so we
05:45 - can only read from the queue after this
05:47 - job completes and finishes writing - so
05:49 - just to see the error
05:50 - let's try reading the queue anyways so
05:52 - we - a while go into the event queue and
05:55 - we try to DQ so just like this we have
06:04 - our event and let's test and there it is
06:07 - right away we can see our error
06:08 - essentially saying that we cannot read
06:10 - from this native Cuba for the previous
06:12 - job has completed so the way we make
06:14 - this work is by completing the job so
06:17 - before we try to DQ and let's go into
06:19 - our job handle and call complete so this
06:22 - will make sure that job completes which
06:24 - will free up our event queue so we can
06:26 - then safely read it and now if we run
06:29 - here we are and start jumping and yet
06:31 - nowhere and we go through the pipe any
06:33 - of there we go we have our event now
06:35 - let's test using the actual c-sharp
06:37 - event so here let's create a new script
06:40 - call it just testing darts events let's
06:44 - create a new game object and attach our
06:50 - script onto it okay okay now here in our
06:52 - basic monobehaviour script let's test
06:54 - our event so let's go and make a private
06:57 - void start
06:59 - and on start let's subscribe to our
07:01 - event so here first let's access the
07:04 - entities world so we need using unity
07:07 - empties and then here we can access the
07:10 - world access the default game object
07:13 - injection world to get or create the
07:16 - system of type of our pipe move system
07:18 - so we have reference to our system and
07:20 - then inside we have our very nice event
07:22 - and we simply subscribe like no so here
07:26 - we just do a debug mark on the pipe
07:28 - event now finally we just need to
07:31 - actually trigger our event so back in
07:33 - our move system and here instead of
07:35 - doing the debug log we simply do our
07:37 - event and simply invoke all right so
07:41 - there it is let's test ok here we are
07:44 - let's start jumping and as soon as we go
07:46 - through the pipe if there we go we have
07:48 - our pipe event awesome so just like this
07:50 - we have a job component system working
07:52 - in the entities world and it is firing a
07:55 - regular C sharp event which we can then
07:57 - capture from anywhere so for example we
07:59 - could capture this event on the UI to do
08:01 - something so here we have our first way
08:04 - of handling events and the pattern is
08:06 - pretty simple essentially we just need
08:08 - to create an event queue that lives
08:10 - inside of our system so we make it
08:12 - persistent then inside our on update we
08:16 - construct a parallel writer so we can
08:18 - work multi-threading then we do our
08:20 - normal entities for each whenever we
08:22 - have something that we want to fire an
08:23 - event we use the parallel writer in
08:26 - order to in queue our event then
08:27 - afterwards we force the job to complete
08:29 - and we simply try to DQ every event
08:32 - inside of our event queue and once we do
08:34 - we simply call our regular C sharp event
08:36 - that we can listen from anywhere and
08:38 - again here we are jumping and we go
08:40 - through a pipe and there you go we have
08:41 - our piped event so everything is working
08:43 - perfectly fine great now if you're
08:46 - familiar with how the job system works
08:48 - then you will have noticed how calling
08:50 - complete here will have some
08:51 - consequences essentially we're creating
08:53 - a sync point we're stopping the rest of
08:55 - our game once this job is completing
08:57 - that is obviously not ideal ideally we
09:00 - want to make this job but then let the
09:02 - job system decide when it should be
09:04 - completed so one approach we can take to
09:06 - try to solve that problem is to create
09:08 - another system
09:14 - so here I have another system and now we
09:17 - can make sure that this system runs at
09:19 - the end of the frame by using the
09:21 - attribute update in group then we can
09:25 - pass in the group for the unlaid
09:26 - simulation system group and just like
09:30 - this now this system would run at the
09:32 - end the frame so then in here we could
09:34 - call complete on our job and in doing so
09:37 - we would make sure that we would only
09:38 - actually try to complete right at the
09:39 - end the frame however as you can see
09:41 - that means that we need to store a
09:43 - reference job so we can access it from
09:45 - this system so we need to store this and
09:47 - expose it then we also need to expose
09:50 - the queue and we would need to handle
09:52 - the event in a different way since we
09:53 - can't evoke it directly from another
09:55 - system so this approach of having a
09:57 - separate system would be better for
09:59 - performance however at the cost of
10:01 - increased complexity so here is the
10:03 - first way of handling events we're using
10:05 - a native cue inside of our system now
10:08 - let's check out the second method which
10:10 - won't be based on creating an entity and
10:12 - adding an event component so here we
10:14 - have the system back on its starting
10:16 - satan like we saw before now this
10:18 - approach is going to be based on
10:20 - creating an entity and adding a
10:21 - component onto it so first let's make
10:23 - that event component so in here we can
10:26 - simply make our Publix truck let's call
10:28 - this the event component and we simply
10:31 - implement I component data okay here's
10:34 - our very simple component and now when
10:36 - we have our event we want to create an
10:38 - entity and add our component so the
10:40 - simplest way would be we go into the
10:42 - empty manager and come create entity
10:45 - however when using the entity manager we
10:48 - are forcing a sync point so this would
10:50 - break everything related to our job
10:51 - threads so instead of using the entity
10:54 - manager directly we need to use a entity
10:56 - command buffer in order to queue up our
10:58 - actions so let's create one in order to
11:01 - do that we need to access the command
11:03 - buffer system so let's grab it on our
11:05 - protected override on create we go into
11:10 - the world in order to get or create the
11:12 - system of type and simulation command
11:15 - buffer system this is the command buffer
11:20 - system that runs where at the end of the
11:21 - sim
11:22 - so let's store this okay we have a
11:29 - reference to our command buffer system
11:31 - and now in here we access a system in
11:33 - order to create a command buffer so this
11:36 - returns an entity command buffer and in
11:41 - here this works the same way as the
11:43 - native queue meaning we do not use the
11:45 - empty command buffer but rather we use
11:47 - the entity command buffer dot concurrent
11:50 - so this is the same as a native Q dot
11:52 - parallel writer and we grab it by going
11:57 - into the command buffer and to concur
11:59 - all right so we have a concurrent struct
12:02 - of our entity command buffer and now
12:04 - this is what we can use down here on our
12:06 - job so we simply use the command buffer
12:08 - in order to create an entity here for
12:12 - job index we pass in the entity in query
12:14 - index and just like this we are creating
12:16 - an empty entity however we don't want it
12:19 - to be empty we wanted to have our nice
12:21 - event component so if we inspect this
12:23 - function you can see that there is a
12:25 - version that takes an archetype so we
12:27 - can use that let's go up here in order
12:30 - to construct our entity archetype and in
12:36 - order to construct we simply access the
12:37 - entity manager and call create archetype
12:41 - and we pass in our type of our event
12:44 - component so now here we have an empty
12:48 - archetype when we can use it when
12:49 - creating our entity all right so just
12:52 - like this it should be working
12:53 - whenever the Pinecrest is the player
12:54 - we're going to create an entity and that
12:57 - entity won't be added with the event
12:59 - component now we just need one thing
13:01 - which is to make sure that the empty
13:03 - command buffer actually runs after this
13:05 - job completes so we need to make sure
13:07 - that we add this job as a dependency to
13:09 - our and simulation command buffer system
13:11 - so we just go in here and we add job
13:14 - handle for producer and we pass in this
13:16 - job camel so this ensures that our
13:20 - command buffer will run only after this
13:22 - job panel has been completed
13:23 - ok so let's test ok here we are so let's
13:27 - go and go through the pipe and now pause
13:29 - and now we can look into the entity
13:32 - debugger and here we see all of our
13:34 - entities
13:35 - right down here we see a new entity and
13:38 - if there is our nearly created entity
13:40 - with our event component awesome okay so
13:43 - we have our entity being created with
13:45 - the event component being added when the
13:47 - event is triggered now we need to go
13:48 - through our entities and look for this
13:50 - event component so back in our script
13:52 - after we do everything let's do an
13:56 - entities dot for each and we're going to
14:01 - look for entities with our event
14:03 - component and when you do find them then
14:09 - in here and let's fire off the event so
14:12 - it's the find event like we did
14:13 - previously so event event handler there
14:17 - it is we have the on pipe past event and
14:19 - in here we simply invoke it now in order
14:23 - to access this we need to be running on
14:25 - the main thread so we do an empties for
14:27 - each and we call run now after we run we
14:31 - want to clean up and destroy all of the
14:32 - entities with our event component so to
14:35 - do that we can simply use the entity
14:37 - manager and call destroy and theme and
14:41 - in here there's a version which takes an
14:44 - entity query so we can get our entity
14:46 - query of type of of our event component
14:50 - so this won't destroy all the entities
14:52 - with our event component okay so this
14:55 - seems like it would work however we have
14:57 - several issues now first of all by
14:59 - default the entities for each won't be
15:01 - using burst however we can have access
15:03 - references while I using burst so if we
15:06 - try to run like this if there it is we
15:08 - got in there right away so we need to
15:10 - make sure that we can't run and use
15:12 - without burst so we do entities without
15:15 - first and then the normal for each okay
15:18 - and now we still have the same issue
15:20 - that we had with a native queue method
15:22 - which is that down here all we have is
15:26 - our job has been scheduled it has not
15:28 - actually run so if we run the code just
15:31 - like this there go over here we have an
15:34 - error the error is because we were using
15:36 - the NT manager to modify the own list of
15:38 - entities but we cannot do that once the
15:41 - job still requires a reference to those
15:43 - entities so down here we're trying to
15:45 - access the entity native array well we
15:47 - cannot modify
15:48 - since it's currently been scheduled to
15:49 - run on this job so one way we can solve
15:52 - this is by ensuring that previous job
15:53 - completes very much like we did
15:55 - previously so here we simply call job
15:58 - handle dot complete so here we are and
16:01 - it looks good and as soon as we go
16:02 - through the pipe if there you go we have
16:04 - our pipe event correctly being fired
16:05 - awesome so just like this we have our
16:08 - second method working we create an
16:10 - entity command buffer then when we have
16:13 - our event we write to the command buffer
16:15 - the action to create an entity and add
16:17 - our event component then afterwards we
16:20 - complete our job and we cycle through
16:22 - all of our entities and have the event
16:24 - component and if we find some then we
16:26 - invoke our event and after doing so we
16:28 - destroy all the entities with our event
16:30 - component okay so here you can see our
16:32 - second method working now the one issue
16:35 - here is we are creating a sync point so
16:38 - as soon as you get in here we stop in
16:39 - order to complete the jump so that means
16:41 - the whole game is going to be paused
16:42 - whilst this job is working now the
16:44 - benefit of this approach is that we can
16:46 - listen to events on the exact frame that
16:48 - they happen so as soon as an event
16:50 - happens up here we catch it down here
16:52 - and the downside is that we're forcing
16:54 - the game to sound whilst our job runs
16:56 - however right now we're actually both
16:59 - pausing the entire game and on listening
17:01 - to events on the next frame so the
17:03 - reason is actually on the way up here
17:05 - we're using a command buffer created on
17:08 - the end simulation system so that means
17:10 - that the command buffer will only run at
17:12 - the end of the simulation now in order
17:14 - to actually listen to events on the same
17:15 - frame we need to manually make a new
17:17 - command buffer and handle it ourselves
17:19 - so here instead of getting the command
17:21 - buffer from the system we can do a new
17:24 - entity command buffer let's all keep to
17:27 - the temp job everything else goes
17:31 - through the same okay then here we do
17:33 - not add the job handle for producer but
17:35 - instead we go into the command buffer
17:37 - and we call playback pass in our entity
17:39 - manager and then we make sure to dispose
17:43 - of our command buffer now to test that
17:46 - the events are happening on the same
17:47 - frame let's go up here and add a field
17:49 - onto our event component so let's add a
17:52 - public double call it the elapsed time
17:57 - and in here let's go and pick up the
18:00 - time
18:01 - it's time and this is also how we add
18:07 - more information on to our events so in
18:09 - here we create that then we get our
18:11 - created entity and then we can use the
18:16 - command buffer in order to set the
18:18 - component onto our event entity and we
18:29 - set the new component and we pass in the
18:31 - elapsed time and then down here when we
18:34 - listen to our event let's print both so
18:36 - let's do a debug log on our event
18:41 - component down elapsed time so the
18:43 - elapsed time inside even component and
18:45 - then also the one that we captured up
18:47 - here somehow we can test if we're
18:51 - capturing the event on the exact same
18:53 - frame if both of these are exactly the
18:55 - same so let's test ok here we are and
18:58 - let's go and as soon as we pass the
19:00 - event any of there you go you can see
19:02 - the numbers so you can see seven point
19:04 - five six five five six five yep there
19:06 - you go so here we have the event firing
19:09 - correctly and we can indeed verify that
19:11 - they are happening on the exact same
19:12 - frame awesome now again as I was saying
19:15 - the issue with this approach is we're
19:17 - pausing the game in here was job
19:19 - completes so if we don't absolutely need
19:21 - to have our events be triggered in the
19:23 - exact frame then we can essentially what
19:25 - they could run and only test for the
19:26 - events that happen on the previous frame
19:28 - so here let's not call job handled are
19:31 - complete and let's go back to using the
19:33 - end simulation commands off first so
19:35 - let's get this and remove this okay so
19:39 - everything's the same as previously so
19:41 - doing it like this means that we're not
19:43 - going to have this code actually run
19:45 - before we run this code so essentially
19:48 - when we go through the entities and here
19:50 - we're going to go before the command
19:51 - buffer runs so we won't be running one
19:53 - frame behind and if we run like this
19:56 - we're going to have the same error that
19:57 - we saw before so we cannot use the ante
19:59 - manager in here but what we can do is
20:02 - create another command buffer
20:10 - so we construct a new command buffer and
20:13 - as we go through our entities with
20:15 - events then in here we can queue up the
20:17 - action to destroy the entity and we pass
20:20 - in this entity and yep just like that
20:24 - all right so now this should be working
20:27 - let's test so here we are and jump and
20:30 - as we go through the pike any of there
20:33 - it is we have our event being fired and
20:35 - if we look at the timing you can see
20:37 - that event was fired on 4.80
20:40 - and yet it was captured on four point
20:43 - eight one so the event was actually
20:45 - triggered in one frame and then we only
20:47 - captured it in the next frame the
20:49 - benefit of this approach is we will let
20:51 - the job system handle whenever it's
20:52 - going to run the pipe move system so if
20:55 - you don't absolutely need the event to
20:56 - be caught in the exact frame that it's
20:58 - fired then this approach would be better
21:00 - since it wouldn't let the game continue
21:02 - uninterrupted
21:03 - so here is the complete second method we
21:06 - define a I component data for our event
21:08 - component and then we use a entity
21:11 - command buffer in order to construct an
21:12 - entity and add our event component then
21:15 - afterwards we read through all the
21:17 - entities with that component we fire off
21:19 - the event and we destroy that entity so
21:22 - this is the second method fully working
21:23 - now over here I have two nice classes
21:26 - that I wrote to handle events based on
21:28 - the entity method they work with
21:31 - generics so they should be usable in
21:33 - just about any scenario so this one uses
21:36 - the approach where it runs on the exact
21:37 - same frame and this one uses approach on
21:39 - the next frame
21:40 - I think the NT method is likely better
21:42 - than the native cube method so that's
21:44 - why I made both classes using this
21:46 - approach and I also made them to be as
21:48 - easy to use as possible so if you want
21:50 - you can inspect it yourself to see how
21:52 - it works it seems like a lot of code but
21:55 - it's really doing the same thing that we
21:56 - try to do in here so let's see how we
21:58 - can use this in the simplest way
22:00 - possible so here is the pipe move system
22:02 - using that very nice class so as you can
22:05 - see you define the normal C sharp event
22:07 - then on create we construct our nice
22:10 - object as you can see it's working with
22:12 - generics so as a generic you will pass
22:15 - in a certain component type for our
22:17 - event so in this case won't be working
22:19 - with this nice price passed
22:21 - and you can define your own component
22:23 - with whatever values you want just one
22:26 - thing the way that I set up it is
22:27 - necessary for the component to have at
22:30 - least one field even if you don't use it
22:32 - the reason is because later we're doing
22:34 - an eye job for each which does not work
22:36 - on empty tack components so we construct
22:39 - our object using our event component
22:41 - then down here we have the normal
22:43 - entities for each so before we do that
22:46 - we go into our dots events object in
22:48 - order to get an event trigger so this is
22:51 - struck that we can use safely inside of
22:53 - our entities for each then in here when
22:55 - we have our event we simply call on our
22:57 - trigger event and then we have two
23:00 - methods we can either pass in the event
23:02 - if we want to set it to a certain value
23:04 - or we can use a simplified version which
23:06 - simply creates the event with the
23:07 - archetype containing our event component
23:09 - in this case we're also passing in a
23:12 - value then afterwards we schedule we get
23:14 - our job handle so the same as previously
23:16 - and then we use our data fence objects
23:19 - you can't capture events we pass in the
23:22 - job handle where the events were
23:24 - scheduled and then we pass in a simple
23:26 - delegate to handle our events so
23:28 - delegate receives our event component
23:30 - and then we do whatever action we want
23:32 - to deal with our events so here we're
23:34 - invoking our normal c-sharp event and
23:37 - we're also printing the values just the
23:38 - test if this is working on the same
23:39 - frame or the next one so in this one I'm
23:42 - using the last version on the next frame
23:44 - so let's test okay so here we are and we
23:47 - start jumping and we go through the
23:48 - pipes and if there you go we have our
23:49 - event and you can verify that this one
23:51 - is using the version where it captures
23:53 - the event on the next frame so it's
23:55 - fired on three four three and it's
23:57 - captured on three four four and now here
23:59 - if I have an instance where I wanted to
24:00 - use the other method that captures on
24:02 - the same frame all I really need to do
24:04 - is use the other version so dots events
24:07 - use the same frame change all these and
24:09 - if there you go everything else is
24:11 - exactly the same and now if we test here
24:14 - we are and we go through and if there
24:17 - you go now you can see that we are now
24:18 - capturing on the exact same frame so
24:20 - here you can see how this class is
24:22 - extremely simple to use we just need to
24:25 - define it define the component for our
24:26 - event then we get the struct that we can
24:29 - use in our job we fire off the event and
24:30 - we capture the events very simple both
24:33 - of these classes are included in front
24:34 - so feel free to use them in your own
24:36 - projects alright so here we saw two
24:39 - approaches for handling events when
24:40 - using a native cue and when using an
24:42 - entity and an event component again
24:45 - that's is still in development so the
24:47 - best practices aren't yet known perhaps
24:49 - one of these has some benefits or some
24:51 - cons over the other that I'm not aware
24:52 - of or perhaps a completely different
24:54 - approach won't win out if you know
24:56 - another way of doing c-sharp events and
24:58 - dots and please post it in the comments
25:00 - either way here you have two possible
25:02 - ways of handling events events are
25:04 - extremely important so with this it
25:06 - should really help out when trying to
25:07 - make game as much three dots as possible
25:10 - if you're watching this in the future
25:11 - then check out the video where I made
25:13 - flappy bird almost entirely in dots for
25:15 - example the connection between the dots
25:17 - worm and the normal UI is handled using
25:19 - these events this video is made possible
25:21 - thanks to these awesome supporters go to
25:24 - patreon.com/scishow new code monkey to
25:26 - get some perks and help keep the videos
25:28 - free for everyone as always you can
25:29 - download the project files in utilities
25:31 - from in Tacoma com subscribe to the
25:34 - channel for more unity tutorials post
25:36 - any question have in the comments and
25:37 - I'll see you next time
25:39 - [Music]

Cleaned transcript:

in this video we're going to look at two ways we can handle events in unity dots events are very powerful but as you know that is not about being data oriented so that means we have to be smart in order to implement events which are object oriented let's begin hello and welcome I'm your code monkey and this channel is all about helping you learn how to make your own games with enough tutorials made by a professional indie game developer so if you find the video helpful consider subscribing okay so here we're going to cover several ways of handling events in unity dots first of all if you're not familiar with dots and check out the playlist linked in the description I've also covered csharp events in another video so check that out events are excellent for helping keep your code clean and making sure that your scripts are nicely decoupled from each other however events are normally object based which makes them tricky when applied to dots which is that oriented and very heavy on multi grab now unity dots is still early in development which means the best practices aren't yet known so that's why here I will cover two different possible ways of handling events first I will cover handling events using a native Q&A struct for our event type and then for the second method we're going to do it by creating entities and adding an event component then in the end I will showcase a nice complete class I built in order to make events very easy to use which as always you can download included in the project files ok so here is the demo scene I have my player object over here working as an entity and when I press space I can make it jump and pipe start being spawned this is taken from a project I've been working on trying to make flappy bird completely with dots so if you're watching this in the future then check the link in the description the flappy bird dots project should be out within about a week so now our test here is we want an event to be fired whenever we go through a pipe the way that this is set up is the player never actually moves horizontally the pipes are the only ones that are moving here is the game and the scene view side by side you can see if the player is always right down the middle right on x equals zero and the pipes are the only ones moving this video is made possible thanks to these awesome supporters go to patreon.com/scishow to code monkey to get some perks and help keep the videos free for everyone so over here is the pipe move system it is pretty simple all we're doing is an entities for each cycling through every single pipe and grabbing the translation then we are modifying translation based on you move direction moving it to the left by certain mooo speed and at a time but before we do that we store the exposition before moving and then we store the exposition after moving and our event s is right here first we're testing if the exposition before is above zero and afterwards is below or equal to zero then it's in here that we have passed the player and we want to fire off our event so here it is again I start jumping and pipes are coming and I go through the pipe and it's in there that I want the event alright so let's start off by making our very basic event so here inside of the system let's just define a public event after event handler and let's just call it on pipe task so when the pipe passes the player so here it is a very basic event if you want to learn more about events in csharp then check the video linked in the description now let's start with one approach based on using a native cue so during our entities for each we're going to have our native cue and over here we're going to add our event onto the cue and then after the job is processed then we're going to read through the cue and fire off our event so first we need our native cue so we define it as a private native cue and now here we need a type so let's define a basic event struck to be our type so just a public struct let's go to our PI past events and now here we could also add a field if we wanted our event to have extra information but in this case and let's keep it simple and all you want to do is now when this event happens so you create a native cue of this time so we have our event queue and now in order to initialize it let's go into protected and override e on create method and in here we construct our event queue now here we pick our allocator and in this case let's use persistent so we're going to use the exact same cue every time we run the system and since we're using persistent then we also need to make sure to be allocated so it's also override the void on destroy and in here we just do even heal dot dispose okay all right so here we have our very simple native queue that contains elements of Pi past event now down here we need to pass the event queue on to our job and here in order to make sure that our job is actually running correctly in parallel then instead of using the event queue directly we need to use a native q parallel right so here we define a native q of the same type then we're going to use the type parallel writer and we simply get it by going into the event queue and as parallel brighter okay and now we can use this one safely inside of our job so when we have the event let's simply in queue something onto our queue and let's just pass in our PI past event and that's pretty much it very simple we just have our queue and we in queue an event whenever something happens now after we schedule our job here is the similar tricky part see what we're doing all the way up here is we're only scheduling the job so by the time we get to the code down here then this job has not yet actually run it has only been scheduled so if the job has in front and that means in native queue hasn't actually been filmed and the job system is also smart enough to know that this one is being used so we can only read from the queue after this job completes and finishes writing so just to see the error let's try reading the queue anyways so we a while go into the event queue and we try to DQ so just like this we have our event and let's test and there it is right away we can see our error essentially saying that we cannot read from this native Cuba for the previous job has completed so the way we make this work is by completing the job so before we try to DQ and let's go into our job handle and call complete so this will make sure that job completes which will free up our event queue so we can then safely read it and now if we run here we are and start jumping and yet nowhere and we go through the pipe any of there we go we have our event now let's test using the actual csharp event so here let's create a new script call it just testing darts events let's create a new game object and attach our script onto it okay okay now here in our basic monobehaviour script let's test our event so let's go and make a private void start and on start let's subscribe to our event so here first let's access the entities world so we need using unity empties and then here we can access the world access the default game object injection world to get or create the system of type of our pipe move system so we have reference to our system and then inside we have our very nice event and we simply subscribe like no so here we just do a debug mark on the pipe event now finally we just need to actually trigger our event so back in our move system and here instead of doing the debug log we simply do our event and simply invoke all right so there it is let's test ok here we are let's start jumping and as soon as we go through the pipe if there we go we have our pipe event awesome so just like this we have a job component system working in the entities world and it is firing a regular C sharp event which we can then capture from anywhere so for example we could capture this event on the UI to do something so here we have our first way of handling events and the pattern is pretty simple essentially we just need to create an event queue that lives inside of our system so we make it persistent then inside our on update we construct a parallel writer so we can work multithreading then we do our normal entities for each whenever we have something that we want to fire an event we use the parallel writer in order to in queue our event then afterwards we force the job to complete and we simply try to DQ every event inside of our event queue and once we do we simply call our regular C sharp event that we can listen from anywhere and again here we are jumping and we go through a pipe and there you go we have our piped event so everything is working perfectly fine great now if you're familiar with how the job system works then you will have noticed how calling complete here will have some consequences essentially we're creating a sync point we're stopping the rest of our game once this job is completing that is obviously not ideal ideally we want to make this job but then let the job system decide when it should be completed so one approach we can take to try to solve that problem is to create another system so here I have another system and now we can make sure that this system runs at the end of the frame by using the attribute update in group then we can pass in the group for the unlaid simulation system group and just like this now this system would run at the end the frame so then in here we could call complete on our job and in doing so we would make sure that we would only actually try to complete right at the end the frame however as you can see that means that we need to store a reference job so we can access it from this system so we need to store this and expose it then we also need to expose the queue and we would need to handle the event in a different way since we can't evoke it directly from another system so this approach of having a separate system would be better for performance however at the cost of increased complexity so here is the first way of handling events we're using a native cue inside of our system now let's check out the second method which won't be based on creating an entity and adding an event component so here we have the system back on its starting satan like we saw before now this approach is going to be based on creating an entity and adding a component onto it so first let's make that event component so in here we can simply make our Publix truck let's call this the event component and we simply implement I component data okay here's our very simple component and now when we have our event we want to create an entity and add our component so the simplest way would be we go into the empty manager and come create entity however when using the entity manager we are forcing a sync point so this would break everything related to our job threads so instead of using the entity manager directly we need to use a entity command buffer in order to queue up our actions so let's create one in order to do that we need to access the command buffer system so let's grab it on our protected override on create we go into the world in order to get or create the system of type and simulation command buffer system this is the command buffer system that runs where at the end of the sim so let's store this okay we have a reference to our command buffer system and now in here we access a system in order to create a command buffer so this returns an entity command buffer and in here this works the same way as the native queue meaning we do not use the empty command buffer but rather we use the entity command buffer dot concurrent so this is the same as a native Q dot parallel writer and we grab it by going into the command buffer and to concur all right so we have a concurrent struct of our entity command buffer and now this is what we can use down here on our job so we simply use the command buffer in order to create an entity here for job index we pass in the entity in query index and just like this we are creating an empty entity however we don't want it to be empty we wanted to have our nice event component so if we inspect this function you can see that there is a version that takes an archetype so we can use that let's go up here in order to construct our entity archetype and in order to construct we simply access the entity manager and call create archetype and we pass in our type of our event component so now here we have an empty archetype when we can use it when creating our entity all right so just like this it should be working whenever the Pinecrest is the player we're going to create an entity and that entity won't be added with the event component now we just need one thing which is to make sure that the empty command buffer actually runs after this job completes so we need to make sure that we add this job as a dependency to our and simulation command buffer system so we just go in here and we add job handle for producer and we pass in this job camel so this ensures that our command buffer will run only after this job panel has been completed ok so let's test ok here we are so let's go and go through the pipe and now pause and now we can look into the entity debugger and here we see all of our entities right down here we see a new entity and if there is our nearly created entity with our event component awesome okay so we have our entity being created with the event component being added when the event is triggered now we need to go through our entities and look for this event component so back in our script after we do everything let's do an entities dot for each and we're going to look for entities with our event component and when you do find them then in here and let's fire off the event so it's the find event like we did previously so event event handler there it is we have the on pipe past event and in here we simply invoke it now in order to access this we need to be running on the main thread so we do an empties for each and we call run now after we run we want to clean up and destroy all of the entities with our event component so to do that we can simply use the entity manager and call destroy and theme and in here there's a version which takes an entity query so we can get our entity query of type of of our event component so this won't destroy all the entities with our event component okay so this seems like it would work however we have several issues now first of all by default the entities for each won't be using burst however we can have access references while I using burst so if we try to run like this if there it is we got in there right away so we need to make sure that we can't run and use without burst so we do entities without first and then the normal for each okay and now we still have the same issue that we had with a native queue method which is that down here all we have is our job has been scheduled it has not actually run so if we run the code just like this there go over here we have an error the error is because we were using the NT manager to modify the own list of entities but we cannot do that once the job still requires a reference to those entities so down here we're trying to access the entity native array well we cannot modify since it's currently been scheduled to run on this job so one way we can solve this is by ensuring that previous job completes very much like we did previously so here we simply call job handle dot complete so here we are and it looks good and as soon as we go through the pipe if there you go we have our pipe event correctly being fired awesome so just like this we have our second method working we create an entity command buffer then when we have our event we write to the command buffer the action to create an entity and add our event component then afterwards we complete our job and we cycle through all of our entities and have the event component and if we find some then we invoke our event and after doing so we destroy all the entities with our event component okay so here you can see our second method working now the one issue here is we are creating a sync point so as soon as you get in here we stop in order to complete the jump so that means the whole game is going to be paused whilst this job is working now the benefit of this approach is that we can listen to events on the exact frame that they happen so as soon as an event happens up here we catch it down here and the downside is that we're forcing the game to sound whilst our job runs however right now we're actually both pausing the entire game and on listening to events on the next frame so the reason is actually on the way up here we're using a command buffer created on the end simulation system so that means that the command buffer will only run at the end of the simulation now in order to actually listen to events on the same frame we need to manually make a new command buffer and handle it ourselves so here instead of getting the command buffer from the system we can do a new entity command buffer let's all keep to the temp job everything else goes through the same okay then here we do not add the job handle for producer but instead we go into the command buffer and we call playback pass in our entity manager and then we make sure to dispose of our command buffer now to test that the events are happening on the same frame let's go up here and add a field onto our event component so let's add a public double call it the elapsed time and in here let's go and pick up the time it's time and this is also how we add more information on to our events so in here we create that then we get our created entity and then we can use the command buffer in order to set the component onto our event entity and we set the new component and we pass in the elapsed time and then down here when we listen to our event let's print both so let's do a debug log on our event component down elapsed time so the elapsed time inside even component and then also the one that we captured up here somehow we can test if we're capturing the event on the exact same frame if both of these are exactly the same so let's test ok here we are and let's go and as soon as we pass the event any of there you go you can see the numbers so you can see seven point five six five five six five yep there you go so here we have the event firing correctly and we can indeed verify that they are happening on the exact same frame awesome now again as I was saying the issue with this approach is we're pausing the game in here was job completes so if we don't absolutely need to have our events be triggered in the exact frame then we can essentially what they could run and only test for the events that happen on the previous frame so here let's not call job handled are complete and let's go back to using the end simulation commands off first so let's get this and remove this okay so everything's the same as previously so doing it like this means that we're not going to have this code actually run before we run this code so essentially when we go through the entities and here we're going to go before the command buffer runs so we won't be running one frame behind and if we run like this we're going to have the same error that we saw before so we cannot use the ante manager in here but what we can do is create another command buffer so we construct a new command buffer and as we go through our entities with events then in here we can queue up the action to destroy the entity and we pass in this entity and yep just like that all right so now this should be working let's test so here we are and jump and as we go through the pike any of there it is we have our event being fired and if we look at the timing you can see that event was fired on 4.80 and yet it was captured on four point eight one so the event was actually triggered in one frame and then we only captured it in the next frame the benefit of this approach is we will let the job system handle whenever it's going to run the pipe move system so if you don't absolutely need the event to be caught in the exact frame that it's fired then this approach would be better since it wouldn't let the game continue uninterrupted so here is the complete second method we define a I component data for our event component and then we use a entity command buffer in order to construct an entity and add our event component then afterwards we read through all the entities with that component we fire off the event and we destroy that entity so this is the second method fully working now over here I have two nice classes that I wrote to handle events based on the entity method they work with generics so they should be usable in just about any scenario so this one uses the approach where it runs on the exact same frame and this one uses approach on the next frame I think the NT method is likely better than the native cube method so that's why I made both classes using this approach and I also made them to be as easy to use as possible so if you want you can inspect it yourself to see how it works it seems like a lot of code but it's really doing the same thing that we try to do in here so let's see how we can use this in the simplest way possible so here is the pipe move system using that very nice class so as you can see you define the normal C sharp event then on create we construct our nice object as you can see it's working with generics so as a generic you will pass in a certain component type for our event so in this case won't be working with this nice price passed and you can define your own component with whatever values you want just one thing the way that I set up it is necessary for the component to have at least one field even if you don't use it the reason is because later we're doing an eye job for each which does not work on empty tack components so we construct our object using our event component then down here we have the normal entities for each so before we do that we go into our dots events object in order to get an event trigger so this is struck that we can use safely inside of our entities for each then in here when we have our event we simply call on our trigger event and then we have two methods we can either pass in the event if we want to set it to a certain value or we can use a simplified version which simply creates the event with the archetype containing our event component in this case we're also passing in a value then afterwards we schedule we get our job handle so the same as previously and then we use our data fence objects you can't capture events we pass in the job handle where the events were scheduled and then we pass in a simple delegate to handle our events so delegate receives our event component and then we do whatever action we want to deal with our events so here we're invoking our normal csharp event and we're also printing the values just the test if this is working on the same frame or the next one so in this one I'm using the last version on the next frame so let's test okay so here we are and we start jumping and we go through the pipes and if there you go we have our event and you can verify that this one is using the version where it captures the event on the next frame so it's fired on three four three and it's captured on three four four and now here if I have an instance where I wanted to use the other method that captures on the same frame all I really need to do is use the other version so dots events use the same frame change all these and if there you go everything else is exactly the same and now if we test here we are and we go through and if there you go now you can see that we are now capturing on the exact same frame so here you can see how this class is extremely simple to use we just need to define it define the component for our event then we get the struct that we can use in our job we fire off the event and we capture the events very simple both of these classes are included in front so feel free to use them in your own projects alright so here we saw two approaches for handling events when using a native cue and when using an entity and an event component again that's is still in development so the best practices aren't yet known perhaps one of these has some benefits or some cons over the other that I'm not aware of or perhaps a completely different approach won't win out if you know another way of doing csharp events and dots and please post it in the comments either way here you have two possible ways of handling events events are extremely important so with this it should really help out when trying to make game as much three dots as possible if you're watching this in the future then check out the video where I made flappy bird almost entirely in dots for example the connection between the dots worm and the normal UI is handled using these events this video is made possible thanks to these awesome supporters go to patreon.com/scishow new code monkey to get some perks and help keep the videos free for everyone as always you can download the project files in utilities from in Tacoma com subscribe to the channel for more unity tutorials post any question have in the comments and I'll see you next time
