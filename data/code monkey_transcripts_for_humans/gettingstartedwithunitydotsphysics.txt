With timestamps:

00:00 - in this video we're going to look at how
00:01 - to use the new unity dots physics we're
00:04 - going to check out the various samples
00:05 - and then experiment with all the physics
00:07 - components do some ray casts and play
00:09 - with events let's begin
00:13 - [Music]
00:17 - hello and welcome I'm your code monkey
00:20 - and this channel is all about helping
00:21 - you learn how to make your own games
00:23 - with NF tutorials made by a professional
00:25 - indie game developer so if you find the
00:27 - video helpful consider subscribing so
00:29 - unity dots if you're not familiar with
00:31 - it stands for the data oriented
00:32 - technology stack it's composed of the
00:35 - entity component system the job system
00:37 - and the burst compiler essentially it
00:39 - promises epic performance several orders
00:41 - of magnitude better than working with
00:42 - game objects for more detailed
00:45 - explanation of dots and ECS check the
00:47 - links in the description here we're
00:48 - going to look at the implementation of
00:50 - physics in dots so in this scene here I
00:53 - have the unity physics package installed
00:55 - as well as the entities package now
00:58 - let's first look at these samples and
00:59 - then we'll play around with the physics
01:01 - ourselves these samples are located in
01:03 - this github repo there's a link in the
01:05 - description so check it out here I have
01:08 - downloaded and open the project so over
01:10 - here you have a whole bunch of demos
01:12 - covering all sorts of physics
01:13 - interactions for example here the most
01:16 - basic demo is just hello world made with
01:18 - physics objects so as we were in the
01:21 - game there you go the in letters fall
01:22 - down and then we can pick them up and
01:24 - drag them around there you go we have a
01:25 - bunch of physics interactions and if we
01:28 - pause the game and look at the hierarchy
01:29 - there you go we have no objects in here
01:31 - however if we go into our window
01:33 - analysis and into our entity debugger
01:36 - here we can see all the various letters
01:38 - and here in the inspector you can see
01:40 - all of the dots physics components so in
01:43 - this case we have the collider we have
01:44 - some mass velocity and damping so as you
01:47 - can see you can inspect all of these
01:48 - demos to see how they work and for
01:51 - example over here on the last one we
01:52 - have one of the most complex ones here
01:55 - it is we have some cars and a bunch of
01:56 - objects so we're here you can see a
01:58 - bunch of physics interactions so we have
02:01 - a car none of them working with physics
02:03 - on the wheels then you can see the
02:05 - antennas which look very springy over
02:07 - here on this car you can see the joints
02:10 - and hinges on the doors and you can also
02:12 - see the box thing inside so as I move
02:14 - and I stop and there you go and again
02:15 - all of this is using the dots physics
02:17 - package so go ahead and get samples and
02:21 - then inspect all the various demos and
02:22 - all of the code is here for you to learn
02:24 - for this video is made possible thanks
02:26 - to these awesome supporters go to
02:28 - patreon.com/scishow to code monkey to
02:30 - get
02:31 - and perks and help keep the videos free
02:32 - for everyone okay so now that we've
02:34 - looked at samples let's play around with
02:36 - it here we are in an empty scene now we
02:39 - want to make a very simple test let's
02:41 - make your ball bounce up and down
02:42 - now there are two ways we can do this we
02:44 - can do it using normal rigid bodies and
02:46 - colliders with the conversion workflow
02:48 - or we can use the dots physics
02:50 - components directly let's first use
02:52 - normal rigid bodies so we do exam like
02:54 - we've always done
02:55 - so over here we create a new cube so
02:58 - let's stretch it out to make it our
03:00 - floor okay so over here we have our four
03:09 - and as you can see we're using a regular
03:11 - box from other component now all we need
03:14 - to add is the convert to entity script
03:16 - and that's pretty much it now this
03:18 - object won't live as a Collider in the
03:20 - dot physics world now let's make the
03:22 - ball so over here we create a new 3d
03:24 - object let's make it a sphere and again
03:31 - it already contains a sphere Collider
03:33 - now in order to make it fall down what
03:35 - we need to do is that a regular
03:37 - rigidbody component make sure that
03:39 - gravity is enabled so it falls down and
03:41 - again all we need to do is have D
03:43 - convert to entity script all right so
03:45 - that's pretty much it we set it up
03:47 - exactly the same way as we did with
03:49 - normal and game objects the only
03:51 - difference is we have the convert 20
03:52 - script
03:53 - let's test any of their yo our sphere
03:56 - film down so here we don't everything
03:58 - exactly the same as we've always done
03:59 - with the usual components and just by
04:01 - adding the convert to entity script all
04:03 - the things get converted into dots
04:04 - physics entities so we can pause and
04:07 - look and yep we don't have anything on
04:09 - our game scene and we have our entities
04:11 - over here in the entity debugger okay so
04:14 - now let's use the dots physics
04:15 - components directly so let's duplicate
04:18 - this and put it on the side now over
04:25 - here on this one let's remove the box
04:27 - Collider component and inside let's add
04:29 - a component over here we sound like dots
04:31 - go into dots physics and in this case
04:34 - and let's select a physics shape now
04:36 - this component essentially merges some
04:38 - of the various colliders so you have a
04:39 - single shaped component type and over
04:42 - here you select the actual shape so in
04:44 - this case
04:44 - we want to be a box okay and again make
04:47 - sure you have the convert to entity
04:48 - component and that's it
04:50 - now for the bomb let's duplicate our
04:52 - sphere put it on the side and again get
04:54 - rid of the sphere come either as well as
04:56 - the rigidbody and now let's add a new
04:58 - component go into dots physics and first
05:01 - we add the physics shape in this case we
05:03 - want a sphere there you can see the
05:05 - gizmo okay and then let's also add a
05:08 - dots physics in this case let's add a
05:10 - physics body so this is the equivalent
05:13 - for the rigidbody and as you can see it
05:15 - looks pretty much the same and again
05:17 - make sure that it has he converted to
05:18 - entity script okay so that's it for our
05:20 - set up over here we have normal
05:22 - components and over here using the dots
05:23 - physics components directly
05:25 - let's test and yep both objects film
05:28 - down with gravity we have one working
05:30 - with normal components and the
05:32 - conversion workflow and we're working
05:34 - directly with the dots physics
05:35 - components awesome now let's make them
05:37 - bounce over here on the dots physics
05:39 - object in the physics shape you can see
05:42 - a field for the restitution so if we set
05:45 - it to one and keep the maximum then this
05:47 - object will not lose any energy so let's
05:49 - try two one and test and yep there's our
05:52 - ball and bouncing up and down now over
05:53 - here on the normal object on the sphere
05:56 - Collider we also have a space for a
05:58 - physics material so let's create a new
06:00 - physics material let's call it bouncy
06:03 - and over here we just set the bounciness
06:05 - to one and combine with the maximum and
06:08 - then we simply drag our bouncy in there
06:10 - all right let's see any of their here we
06:12 - have both spheres jumping up and down so
06:15 - one is using normal components and when
06:17 - using dots physics components awesome
06:19 - now since we were working with dots
06:20 - physics that means we're working with
06:22 - the entity component system world so
06:24 - again you can see that we're not using
06:25 - game objects and over here on the entity
06:28 - debugger we can see all of our various
06:30 - entities and you can see that both the
06:32 - one that we created with the dots
06:34 - physics components and the one that we
06:36 - created within normal physics components
06:37 - both of them have the exact same ECS
06:40 - components so this is the conversion
06:42 - workflow in action now you can find all
06:45 - the physics components in the package
06:46 - manual as it says in there we have all
06:49 - these components that are added
06:50 - depending on if they are needed or not
06:52 - so if a body does not move like the
06:54 - floor it does not have the
06:55 - physics velocity component so we're here
06:58 - if I sum like the cube there you go you
07:00 - can look in here and you can see that it
07:01 - has a physical editor and nothing else
07:03 - but if we still like the sphere and
07:05 - there you go you can see that it has a
07:06 - physical either mass velocity and
07:08 - damping this is another way that we can
07:10 - keep our code nice and performance since
07:12 - it will only have exactly the components
07:14 - that it needs and no more all right now
07:16 - let's write some code to interact with
07:18 - it
07:18 - over here let's make a new c-sharp
07:20 - script call this our ball jump system
07:23 - now in here let's get rid of the normal
07:25 - amount of behavior things instead we're
07:29 - going to be using unity dot entities now
07:34 - we're going to make this a component
07:35 - system alright now here let's do a
07:40 - simple entities dot for each cycle and
07:42 - let's second through all the entities
07:45 - with a physics velocity component
07:52 - alright so here we can modify the
07:54 - physics velocity so for example let's do
07:57 - a simple input when we press on the
08:01 - spacebar let's try to move it up so for
08:04 - that we're going to modify the physics
08:05 - velocity modify the linear and set in
08:09 - linear Y to a certain amount all right
08:12 - so that's it let's test ok so here we
08:15 - have our bouncing ball and by pressing
08:17 - space and there you go it does jump up
08:19 - so every time we press space we are
08:21 - interacting with dots physics so all we
08:23 - need to do is modify a specific that's
08:25 - physics component and everything works
08:27 - great so again check out the manual to
08:29 - see all of the other physics components
08:31 - and you can interact with them the same
08:32 - way you do with any other component type
08:34 - alright so now let's check out a simple
08:36 - ray cast over here let's make a new
08:39 - c-sharp script call this our test ray
08:41 - cast okay here's our script now first
08:44 - let's add the namespaces that we're
08:45 - going to need so first of all we need
08:47 - unity dot entities then we also need to
08:50 - be using unity that mathematics and
08:53 - finally using unity dot physics okay now
08:59 - right now we have to make our own ray
09:01 - cast function but I'm guessing in the
09:02 - future there won't be some sort of
09:03 - utilities class so we're hearing let's
09:05 - make it so we
09:07 - okay simple private void our recast now
09:11 - a recast will have a full 3/4 hour from
09:14 - position and another four three four the
09:17 - tube position so we're going to do a
09:19 - recast from and to now inside first we
09:22 - need to get our current physics world
09:24 - system so let's go into our world into
09:27 - our default world and we get an existing
09:30 - system we get it of type unity physics
09:33 - systems and get our build physics world
09:42 - now inside the build physics world we
09:45 - can access the actual physical world and
09:47 - then the collision world ok and now we
09:52 - can use our collision world and use the
09:54 - function cast break now for here as you
09:59 - can see we will require a ray cast input
10:01 - and it outputs a ray cast hit so first
10:05 - ray casts it is very simple so we make a
10:10 - new rake asset and again here pay
10:12 - attention we are using the array cast
10:13 - head inside unity dot physics and not
10:15 - the one inside unity engine so this will
10:18 - be our second parameter and now for the
10:20 - first one we need a ray cast input so
10:23 - let's create our ray cast input and now
10:27 - it's in here that we have the from in
10:28 - two positions so the start will be our
10:31 - from position the end won't be our two
10:35 - position and then finally we can add a
10:39 - filter now a filter is essentially the
10:42 - layers
10:47 - so here in the filter we have three
10:49 - fields first of all it belongs to and
10:51 - we're going to say that this rate
10:52 - belongs to own layers so in here we're
10:55 - essentially going to negate a zero if
10:57 - you're not familiar with the tilde
10:59 - character this is a bit operation not so
11:02 - we're doing not zero which means we end
11:04 - up with all the bits at the one I've
11:06 - made a video covering collisions layer
11:07 - masks and bitwise operators so check
11:09 - that out to learn more so here we're
11:12 - saying that this rake has belongs to all
11:13 - the layers and we wanted to collide with
11:15 - all the layers and finally group index
11:18 - which is just another way of filtering
11:20 - collisions by overriding the bit masks
11:22 - so for now let's leave it at zero
11:25 - alright so here we have all the
11:27 - information inside of our recaps input
11:29 - essentially we just have the from into
11:31 - so we use this in our function so we've
11:35 - passing the array cast input and then
11:37 - out for our ray cast hit and this one as
11:39 - you can see it returns a boolean so it
11:41 - returns true if we hit something and
11:43 - false if not so if so here we know that
11:47 - we hit something and now we can actually
11:49 - get the entity that we hit so we can
11:51 - access the array Cassatt and inside we
11:54 - have the rigidbody index field so here
11:57 - as you can see this field is an int so
11:59 - this is the index of our rigidbody and
12:01 - now we can access the entity that refers
12:03 - to this rigid body by using our built
12:06 - physics world to access our physics
12:10 - world then we access the bodies which as
12:12 - you can see is the native slice of
12:13 - rigidbody and we use this as our index
12:16 - so with this we have a rigidbody and
12:19 - then we can access the entity alright so
12:22 - this is the entity that we hit without
12:24 - raycast and now let's simply modify this
12:26 - one to return an entity and then we
12:28 - return this and if you do not hit
12:30 - anything then return entities got no
12:33 - okay so here we have our ray cast
12:36 - function we wherever from in the two we
12:39 - do a cast ray and we get our head entity
12:41 - all right so now let's test this out
12:43 - let's use a simple normal update all
12:59 - right so here we have some very basic
13:01 - code we do an if input get mouse button
13:03 - down on the in left mouse button so when
13:05 - we click we use the camera to create a
13:07 - normal screen point array and then we
13:10 - use our recast function pass in the
13:11 - array origin and then Direction times a
13:13 - certain amount so let's check to log and
13:15 - see if we can click to grab an entity
13:17 - okay so here we are there's our bouncing
13:20 - ball in our console now if I click on
13:22 - nowhere and there you go we have entity
13:24 - no now if I click on top of the four and
13:26 - there you go we had our entity click on
13:28 - top of the ball and there you go we have
13:30 - the other entity so over here we have a
13:32 - rick has correctly grabbing what we
13:34 - click on now over here the function that
13:36 - we made is only grabbing the closest hit
13:38 - but as you can see we have another one
13:40 - which takes a native list and returns
13:41 - all hits so if you want more than the
13:43 - closest that's what you would use and
13:45 - again here it is click on nowhere click
13:48 - on the ball and click on the floor
13:49 - alright awesome so here our simple ray
13:52 - cast function is working correctly
13:54 - however we're interacting with our ray
13:56 - cast directly very much from c-sharp now
13:59 - in order to get the maximum performance
14:00 - we should do our ray cast from a burst
14:02 - compile job so check the manual to see
14:05 - one implementation of a ray cast Q
14:07 - alright next let's check out triggers
14:09 - and events
14:10 - now to make a trigger let's first make a
14:12 - simple box so we're here for example
14:15 - let's duplicate this one put it a bit
14:16 - higher okay so over here we have the
14:24 - normal floor and then this second box
14:26 - let's call this our trigger and now in
14:29 - here on the physics shape just like we
14:31 - have a normal compiler over here we have
14:33 - is trigger so we simply click this and
14:36 - set it to true alright so that's pretty
14:37 - much it now we want to make it so that
14:39 - when the ball touches the trigger we're
14:41 - going to make it automatically jump up
14:42 - all right so let's make our script let's
14:45 - make it something and call it test
14:47 - triggers now the way that we handle our
14:50 - triggers is with a job
14:52 - so first let's make this a job component
14:54 - system
14:59 - okay now here we make our simple job in
15:05 - order to work with triggers we need to
15:07 - implement I trigger events job so this
15:12 - is the interface that we need to
15:13 - implement so we have our execute
15:15 - function which takes a trigger event
15:18 - object and we can inspect this and over
15:21 - here you can see that we have our entity
15:23 - pair Collider and body index and inside
15:25 - the entity pair we just have an entity a
15:28 - and B so this is a trigger between two
15:30 - objects interacting okay so now here
15:33 - when we get a trigger event let's push
15:34 - the entity up like we did when pressing
15:36 - space now the way we modify components
15:39 - from the entities involved in this
15:40 - trigger is we need to have a component
15:44 - data from entity of type physics
15:48 - velocity and then here first we check if
15:53 - has a component using our trigger event
15:56 - that entities dot entity a so if the
16:00 - entity a has a physics velocity
16:02 - component then we want to modify it and
16:04 - jump it up okay so if that one has a
16:13 - physics velocity we jump it up and let's
16:15 - do the same thing in case its entity B
16:18 - all right so just like this when we have
16:20 - a trigger interaction we're going to
16:22 - move up the entity that contains a
16:24 - velocity component so in our demo since
16:26 - we only have bound and only the ball
16:28 - will be moving up and then here we can
16:30 - also use first compile into our job
16:33 - alright so now to schedule it down here
16:36 - let's first make our trigger job and we
16:40 - need to set the physics velocity
16:41 - entities so we do is get component data
16:44 - from entity applied physics policy so
16:48 - then we're going to return our trigger
16:50 - job we're going to schedule it and now
16:52 - in order to schedule it we need the
16:54 - simulation and the physics world so for
16:56 - that let's also implement we also
16:59 - implement the uncreated function and
17:02 - here we can go into the world and we get
17:05 - or create our system up typed built
17:08 - physics world
17:11 - which as is how previously this is
17:14 - inside using unity about physics dot
17:16 - systems so with our built physics world
17:24 - we can use the second parameter which is
17:25 - our physics world then the third one is
17:27 - normal input dependencies and now for
17:30 - the first one it's a simulation and the
17:32 - simulation we get the step physics world
17:38 - and we use the step physics for on that
17:40 - simulation alright so here we have
17:44 - everything necessary we instantiate our
17:46 - new jump we pass in the components that
17:48 - we're going to need so we access those
17:50 - and if the entity has a component of
17:53 - type physics velocity then we're going
17:54 - to move it up and then we simply
17:56 - schedule and run our job all right so
17:58 - let's test any of there you go there's
18:00 - the ball as soon as it touches the
18:01 - trigger it starts going up so there you
18:03 - it's not touching down here at all so we
18:05 - can pause and over here use our camera
18:08 - and there you go
18:10 - yep the ball as soon as it touches the
18:12 - trigger it goes up it no longer to touch
18:13 - to the four so just like this we have
18:16 - implemented our simple triggers so only
18:18 - takes essentially making a job which
18:19 - implements I trigger your venn jobs then
18:22 - in here you can use the trigger event to
18:24 - access the entities involved in that
18:25 - interaction and do whatever you want to
18:27 - them now over here on the physics sample
18:29 - project you can go into setup and over
18:31 - here you have events and then for
18:34 - example let's open the portals there you
18:36 - go it's this scene so let's play it out
18:37 - any up over here you can see a different
18:40 - scenario so the bones come in they hit
18:42 - and they get teleported and moved around
18:43 - none of it is working using triggers
18:45 - another demo is here which essentially
18:47 - it has two triggers that are inverting
18:49 - the gravity and here in the code you can
18:51 - see a more robust implementation of the
18:53 - triggers so you have a job still
18:55 - implementing I trigger events job then
18:57 - you grab the entity a and B you try to
19:00 - see if they have the component that
19:01 - you're trying to modify so we're here
19:03 - it's ignoring triggers overlapping other
19:05 - triggers then also ignoring overlapping
19:07 - static bodies and then now I'm here
19:09 - doing all the modifications so just like
19:12 - this we have our triggers working now
19:14 - one more thing you may have heard about
19:15 - is the collaboration with havoc so
19:17 - essentially you have two possible
19:19 - physics engines you have unity physics
19:21 - and have up physics now in terms
19:23 - making your game there is no difference
19:25 - they both use the exact same components
19:27 - so in order to change them you literally
19:29 - just have a drop-down menu so here on
19:31 - the same there's already game object
19:33 - that contains a physics step component
19:35 - and using it over here you have the
19:37 - simulation type so it's currently set to
19:39 - unity physics and it's in here that you
19:41 - can set to have up physics so you just
19:43 - set that make sure you have the package
19:45 - and so on and everything works exactly
19:46 - the same so from a content creation
19:49 - standpoint there's nothing actually you
19:50 - need to do both physics engines are
19:52 - great and they have different design
19:54 - philosophy is related speed accuracy and
19:56 - state or staples the main difference is
19:58 - unity physics is free whereas havoc is
20:00 - paid for however right now there's a
20:02 - free trailer so you can play around with
20:03 - it here in the physics app you can also
20:05 - see for example you can modify the
20:06 - gravity so instead of having it pull
20:09 - down at 9.8 1 units let's pull it up and
20:12 - there you go just like that all of a
20:13 - sudden everything is floating now
20:15 - there's still a lot more to physics like
20:17 - joints hinges Collider casts and a lot
20:19 - more I want to keep this video as a
20:21 - simple beginner introduction so I don't
20:23 - leave it here for now but I won't be
20:24 - covering unity that's physics more in
20:26 - the future so let me know specifically
20:28 - what you don't like to see regarding
20:29 - dots physics if you want to explore it
20:31 - for yourself then check out the physics
20:33 - package manual along with these samples
20:34 - included this video is made possible
20:36 - thanks to these awesome supporters go to
20:39 - patreon.com/scishow natee code monkey to
20:41 - get some perks and help keep the videos
20:43 - free for everyone as always expand with
20:45 - the project fountain utilities from
20:46 - unity code monkey comm subscribe to the
20:49 - channel for more unity tutorials post
20:51 - any question having comes and i'll see
20:52 - you next time
20:54 - [Music]

Cleaned transcript:

in this video we're going to look at how to use the new unity dots physics we're going to check out the various samples and then experiment with all the physics components do some ray casts and play with events let's begin hello and welcome I'm your code monkey and this channel is all about helping you learn how to make your own games with NF tutorials made by a professional indie game developer so if you find the video helpful consider subscribing so unity dots if you're not familiar with it stands for the data oriented technology stack it's composed of the entity component system the job system and the burst compiler essentially it promises epic performance several orders of magnitude better than working with game objects for more detailed explanation of dots and ECS check the links in the description here we're going to look at the implementation of physics in dots so in this scene here I have the unity physics package installed as well as the entities package now let's first look at these samples and then we'll play around with the physics ourselves these samples are located in this github repo there's a link in the description so check it out here I have downloaded and open the project so over here you have a whole bunch of demos covering all sorts of physics interactions for example here the most basic demo is just hello world made with physics objects so as we were in the game there you go the in letters fall down and then we can pick them up and drag them around there you go we have a bunch of physics interactions and if we pause the game and look at the hierarchy there you go we have no objects in here however if we go into our window analysis and into our entity debugger here we can see all the various letters and here in the inspector you can see all of the dots physics components so in this case we have the collider we have some mass velocity and damping so as you can see you can inspect all of these demos to see how they work and for example over here on the last one we have one of the most complex ones here it is we have some cars and a bunch of objects so we're here you can see a bunch of physics interactions so we have a car none of them working with physics on the wheels then you can see the antennas which look very springy over here on this car you can see the joints and hinges on the doors and you can also see the box thing inside so as I move and I stop and there you go and again all of this is using the dots physics package so go ahead and get samples and then inspect all the various demos and all of the code is here for you to learn for this video is made possible thanks to these awesome supporters go to patreon.com/scishow to code monkey to get and perks and help keep the videos free for everyone okay so now that we've looked at samples let's play around with it here we are in an empty scene now we want to make a very simple test let's make your ball bounce up and down now there are two ways we can do this we can do it using normal rigid bodies and colliders with the conversion workflow or we can use the dots physics components directly let's first use normal rigid bodies so we do exam like we've always done so over here we create a new cube so let's stretch it out to make it our floor okay so over here we have our four and as you can see we're using a regular box from other component now all we need to add is the convert to entity script and that's pretty much it now this object won't live as a Collider in the dot physics world now let's make the ball so over here we create a new 3d object let's make it a sphere and again it already contains a sphere Collider now in order to make it fall down what we need to do is that a regular rigidbody component make sure that gravity is enabled so it falls down and again all we need to do is have D convert to entity script all right so that's pretty much it we set it up exactly the same way as we did with normal and game objects the only difference is we have the convert 20 script let's test any of their yo our sphere film down so here we don't everything exactly the same as we've always done with the usual components and just by adding the convert to entity script all the things get converted into dots physics entities so we can pause and look and yep we don't have anything on our game scene and we have our entities over here in the entity debugger okay so now let's use the dots physics components directly so let's duplicate this and put it on the side now over here on this one let's remove the box Collider component and inside let's add a component over here we sound like dots go into dots physics and in this case and let's select a physics shape now this component essentially merges some of the various colliders so you have a single shaped component type and over here you select the actual shape so in this case we want to be a box okay and again make sure you have the convert to entity component and that's it now for the bomb let's duplicate our sphere put it on the side and again get rid of the sphere come either as well as the rigidbody and now let's add a new component go into dots physics and first we add the physics shape in this case we want a sphere there you can see the gizmo okay and then let's also add a dots physics in this case let's add a physics body so this is the equivalent for the rigidbody and as you can see it looks pretty much the same and again make sure that it has he converted to entity script okay so that's it for our set up over here we have normal components and over here using the dots physics components directly let's test and yep both objects film down with gravity we have one working with normal components and the conversion workflow and we're working directly with the dots physics components awesome now let's make them bounce over here on the dots physics object in the physics shape you can see a field for the restitution so if we set it to one and keep the maximum then this object will not lose any energy so let's try two one and test and yep there's our ball and bouncing up and down now over here on the normal object on the sphere Collider we also have a space for a physics material so let's create a new physics material let's call it bouncy and over here we just set the bounciness to one and combine with the maximum and then we simply drag our bouncy in there all right let's see any of their here we have both spheres jumping up and down so one is using normal components and when using dots physics components awesome now since we were working with dots physics that means we're working with the entity component system world so again you can see that we're not using game objects and over here on the entity debugger we can see all of our various entities and you can see that both the one that we created with the dots physics components and the one that we created within normal physics components both of them have the exact same ECS components so this is the conversion workflow in action now you can find all the physics components in the package manual as it says in there we have all these components that are added depending on if they are needed or not so if a body does not move like the floor it does not have the physics velocity component so we're here if I sum like the cube there you go you can look in here and you can see that it has a physical editor and nothing else but if we still like the sphere and there you go you can see that it has a physical either mass velocity and damping this is another way that we can keep our code nice and performance since it will only have exactly the components that it needs and no more all right now let's write some code to interact with it over here let's make a new csharp script call this our ball jump system now in here let's get rid of the normal amount of behavior things instead we're going to be using unity dot entities now we're going to make this a component system alright now here let's do a simple entities dot for each cycle and let's second through all the entities with a physics velocity component alright so here we can modify the physics velocity so for example let's do a simple input when we press on the spacebar let's try to move it up so for that we're going to modify the physics velocity modify the linear and set in linear Y to a certain amount all right so that's it let's test ok so here we have our bouncing ball and by pressing space and there you go it does jump up so every time we press space we are interacting with dots physics so all we need to do is modify a specific that's physics component and everything works great so again check out the manual to see all of the other physics components and you can interact with them the same way you do with any other component type alright so now let's check out a simple ray cast over here let's make a new csharp script call this our test ray cast okay here's our script now first let's add the namespaces that we're going to need so first of all we need unity dot entities then we also need to be using unity that mathematics and finally using unity dot physics okay now right now we have to make our own ray cast function but I'm guessing in the future there won't be some sort of utilities class so we're hearing let's make it so we okay simple private void our recast now a recast will have a full 3/4 hour from position and another four three four the tube position so we're going to do a recast from and to now inside first we need to get our current physics world system so let's go into our world into our default world and we get an existing system we get it of type unity physics systems and get our build physics world now inside the build physics world we can access the actual physical world and then the collision world ok and now we can use our collision world and use the function cast break now for here as you can see we will require a ray cast input and it outputs a ray cast hit so first ray casts it is very simple so we make a new rake asset and again here pay attention we are using the array cast head inside unity dot physics and not the one inside unity engine so this will be our second parameter and now for the first one we need a ray cast input so let's create our ray cast input and now it's in here that we have the from in two positions so the start will be our from position the end won't be our two position and then finally we can add a filter now a filter is essentially the layers so here in the filter we have three fields first of all it belongs to and we're going to say that this rate belongs to own layers so in here we're essentially going to negate a zero if you're not familiar with the tilde character this is a bit operation not so we're doing not zero which means we end up with all the bits at the one I've made a video covering collisions layer masks and bitwise operators so check that out to learn more so here we're saying that this rake has belongs to all the layers and we wanted to collide with all the layers and finally group index which is just another way of filtering collisions by overriding the bit masks so for now let's leave it at zero alright so here we have all the information inside of our recaps input essentially we just have the from into so we use this in our function so we've passing the array cast input and then out for our ray cast hit and this one as you can see it returns a boolean so it returns true if we hit something and false if not so if so here we know that we hit something and now we can actually get the entity that we hit so we can access the array Cassatt and inside we have the rigidbody index field so here as you can see this field is an int so this is the index of our rigidbody and now we can access the entity that refers to this rigid body by using our built physics world to access our physics world then we access the bodies which as you can see is the native slice of rigidbody and we use this as our index so with this we have a rigidbody and then we can access the entity alright so this is the entity that we hit without raycast and now let's simply modify this one to return an entity and then we return this and if you do not hit anything then return entities got no okay so here we have our ray cast function we wherever from in the two we do a cast ray and we get our head entity all right so now let's test this out let's use a simple normal update all right so here we have some very basic code we do an if input get mouse button down on the in left mouse button so when we click we use the camera to create a normal screen point array and then we use our recast function pass in the array origin and then Direction times a certain amount so let's check to log and see if we can click to grab an entity okay so here we are there's our bouncing ball in our console now if I click on nowhere and there you go we have entity no now if I click on top of the four and there you go we had our entity click on top of the ball and there you go we have the other entity so over here we have a rick has correctly grabbing what we click on now over here the function that we made is only grabbing the closest hit but as you can see we have another one which takes a native list and returns all hits so if you want more than the closest that's what you would use and again here it is click on nowhere click on the ball and click on the floor alright awesome so here our simple ray cast function is working correctly however we're interacting with our ray cast directly very much from csharp now in order to get the maximum performance we should do our ray cast from a burst compile job so check the manual to see one implementation of a ray cast Q alright next let's check out triggers and events now to make a trigger let's first make a simple box so we're here for example let's duplicate this one put it a bit higher okay so over here we have the normal floor and then this second box let's call this our trigger and now in here on the physics shape just like we have a normal compiler over here we have is trigger so we simply click this and set it to true alright so that's pretty much it now we want to make it so that when the ball touches the trigger we're going to make it automatically jump up all right so let's make our script let's make it something and call it test triggers now the way that we handle our triggers is with a job so first let's make this a job component system okay now here we make our simple job in order to work with triggers we need to implement I trigger events job so this is the interface that we need to implement so we have our execute function which takes a trigger event object and we can inspect this and over here you can see that we have our entity pair Collider and body index and inside the entity pair we just have an entity a and B so this is a trigger between two objects interacting okay so now here when we get a trigger event let's push the entity up like we did when pressing space now the way we modify components from the entities involved in this trigger is we need to have a component data from entity of type physics velocity and then here first we check if has a component using our trigger event that entities dot entity a so if the entity a has a physics velocity component then we want to modify it and jump it up okay so if that one has a physics velocity we jump it up and let's do the same thing in case its entity B all right so just like this when we have a trigger interaction we're going to move up the entity that contains a velocity component so in our demo since we only have bound and only the ball will be moving up and then here we can also use first compile into our job alright so now to schedule it down here let's first make our trigger job and we need to set the physics velocity entities so we do is get component data from entity applied physics policy so then we're going to return our trigger job we're going to schedule it and now in order to schedule it we need the simulation and the physics world so for that let's also implement we also implement the uncreated function and here we can go into the world and we get or create our system up typed built physics world which as is how previously this is inside using unity about physics dot systems so with our built physics world we can use the second parameter which is our physics world then the third one is normal input dependencies and now for the first one it's a simulation and the simulation we get the step physics world and we use the step physics for on that simulation alright so here we have everything necessary we instantiate our new jump we pass in the components that we're going to need so we access those and if the entity has a component of type physics velocity then we're going to move it up and then we simply schedule and run our job all right so let's test any of there you go there's the ball as soon as it touches the trigger it starts going up so there you it's not touching down here at all so we can pause and over here use our camera and there you go yep the ball as soon as it touches the trigger it goes up it no longer to touch to the four so just like this we have implemented our simple triggers so only takes essentially making a job which implements I trigger your venn jobs then in here you can use the trigger event to access the entities involved in that interaction and do whatever you want to them now over here on the physics sample project you can go into setup and over here you have events and then for example let's open the portals there you go it's this scene so let's play it out any up over here you can see a different scenario so the bones come in they hit and they get teleported and moved around none of it is working using triggers another demo is here which essentially it has two triggers that are inverting the gravity and here in the code you can see a more robust implementation of the triggers so you have a job still implementing I trigger events job then you grab the entity a and B you try to see if they have the component that you're trying to modify so we're here it's ignoring triggers overlapping other triggers then also ignoring overlapping static bodies and then now I'm here doing all the modifications so just like this we have our triggers working now one more thing you may have heard about is the collaboration with havoc so essentially you have two possible physics engines you have unity physics and have up physics now in terms making your game there is no difference they both use the exact same components so in order to change them you literally just have a dropdown menu so here on the same there's already game object that contains a physics step component and using it over here you have the simulation type so it's currently set to unity physics and it's in here that you can set to have up physics so you just set that make sure you have the package and so on and everything works exactly the same so from a content creation standpoint there's nothing actually you need to do both physics engines are great and they have different design philosophy is related speed accuracy and state or staples the main difference is unity physics is free whereas havoc is paid for however right now there's a free trailer so you can play around with it here in the physics app you can also see for example you can modify the gravity so instead of having it pull down at 9.8 1 units let's pull it up and there you go just like that all of a sudden everything is floating now there's still a lot more to physics like joints hinges Collider casts and a lot more I want to keep this video as a simple beginner introduction so I don't leave it here for now but I won't be covering unity that's physics more in the future so let me know specifically what you don't like to see regarding dots physics if you want to explore it for yourself then check out the physics package manual along with these samples included this video is made possible thanks to these awesome supporters go to patreon.com/scishow natee code monkey to get some perks and help keep the videos free for everyone as always expand with the project fountain utilities from unity code monkey comm subscribe to the channel for more unity tutorials post any question having comes and i'll see you next time
