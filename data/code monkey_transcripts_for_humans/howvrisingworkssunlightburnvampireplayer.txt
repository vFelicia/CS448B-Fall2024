With timestamps:

00:00 - hello and welcome i'm your code monkey
00:02 - and lately i've been trying out v-rising
00:04 - it's an excellent vampire survival game
00:06 - that released a while ago it's exactly
00:08 - the kind of game that i like there's
00:09 - resource gathering crafting some nice
00:11 - combat building and so on as you can
00:13 - guess by the name it's all about
00:14 - vampires you play as a vampire and the
00:16 - game features many interesting vampire
00:18 - mechanics taken from the usual vampire
00:20 - myths
00:21 - so for example there are silver coins in
00:23 - the world vampires are weak to silver so
00:25 - if you pick up some coins you won't be
00:26 - constantly taking damage
00:28 - there's also a feed mechanic so when an
00:30 - enemy is weakened you can jump on them
00:32 - and feast on their blood doing so grants
00:34 - some interesting bonuses based on the
00:36 - quality and the type of one another
00:38 - obvious one is garlic there are some
00:40 - garlic defenses in the world and you
00:41 - need to basically buff up your garlic
00:43 - resistance before you can enter that
00:45 - area the game also has interesting
00:47 - faction mechanics so if a group of
00:49 - skeletons comes across some humans in
00:50 - the open world they won't start to fight
00:52 - it's really fun to just sit back fire
00:54 - some projectiles and watch as two enemy
00:56 - factions destroy one another while you
00:58 - sit back and go in the end and just pick
01:00 - up all the loot there's also a pretty
01:02 - robust base building system you can
01:03 - place down areas in a grid then place
01:05 - down walls and doors and inside your
01:07 - castle you can then place down crafting
01:09 - stations chests and so on
01:11 - it works pretty much exactly like what
01:13 - i've already covered in my house
01:14 - building system video so if you want to
01:16 - learn how to make something like that go
01:17 - watch that one
01:18 - so there's lots of interesting mechanics
01:20 - in v rising now here for this video the
01:22 - mechanic that i'd like to recreate is a
01:24 - pretty unique one that requires some
01:25 - clever trickery it's the satellite
01:27 - mechanic as you might know a big part of
01:29 - being a vampire is avoiding sunlight the
01:31 - game itself has a day night cycle when
01:33 - it's night time you can go anywhere
01:35 - without any issues however when it's
01:37 - daylight if you stay in the sun for too
01:39 - long then the sun starts to burn you and
01:41 - take quite a lot of damage if you don't
01:43 - find cover quickly then you will die
01:45 - thankfully the world is filled with tons
01:46 - of trees rocks and buildings so you can
01:48 - jump around between the shadows to move
01:50 - during the day this is a really
01:52 - interesting unique mechanic that
01:53 - perfectly fits the theme of this game so
01:55 - let's see how it actually works and how
01:57 - we can recreate it which involves some
01:58 - clever trickery and if you like this
02:00 - format and want to learn more about how
02:01 - to recreate various systems from
02:03 - interesting games and check out the
02:04 - entire how it's made playlist learn how
02:06 - the scout pro launcher from ottawa works
02:09 - learn how to clean a mesh like in rover
02:10 - mechanic simulator learn how to interact
02:13 - with worm objects and scan things like
02:14 - in cyberpunk or several others okay so
02:17 - here i've got a working demo recreating
02:19 - that mechanic i have my basic player
02:21 - character and i can walk around if you
02:23 - want to know about the character
02:24 - controller this one is based on unity's
02:26 - official third person controller just
02:28 - with an overhead camera
02:30 - and for the assets both the background
02:32 - and the character are from the cinti
02:33 - horror pack it's a really great pack
02:35 - with some spooky vibes obviously perfect
02:37 - for this video and actually right now
02:39 - this pack is discounted as part of a
02:41 - huge centicell it's their anniversary
02:43 - and pretty much every single pack is at
02:45 - half price really great so if you're a
02:47 - fan of their style just like me then
02:48 - check the link description they have
02:50 - asset packs to cover pretty much any
02:51 - game or theme now by inspecting the game
02:53 - we can look at the core components that
02:55 - make up this mechanic first one is
02:56 - really jesse day night cycle i've been
02:59 - meaning to make a tutorial on how to
03:00 - make a day night cycle for quite some
03:02 - time still haven't done it but it's
03:03 - actually pretty simple the main thing is
03:05 - really you just need to keep track of
03:07 - time for that over here i've got my
03:09 - script the sunlight system and as you
03:11 - can see i'm using a flow to store the
03:12 - daytime
03:13 - so it's just a simple float and then
03:15 - down here on update on every update i'm
03:18 - constantly increasing that one by
03:19 - time.time and in order to make it loop
03:21 - after increasing it i just use the
03:23 - modulo operator and some kind of daytime
03:25 - max now for here the maximum amount is
03:27 - arbitrary you can make it a normalized
03:29 - value or use 12 or 24 or literally
03:31 - anything you want
03:32 - for this case i simply went with 24 just
03:35 - to match the hours so with this logic
03:37 - each day is going to last 24 seconds
03:39 - then of course you can also apply just a
03:41 - basic multiplier if you want to make it
03:42 - faster or slower
03:44 - so if i put the multiplier and define it
03:46 - as 0.5 then each day is now going to
03:48 - last 48 seconds in this case to convert
03:50 - daytime into hours since i made the
03:52 - maximum as 24 with that i can just do a
03:55 - fourth in to get the hour so if i do a
03:57 - simple debug log to get the hour
04:00 - if we see what this says there it is on
04:02 - the console constantly increasing
04:08 - and as soon as it reaches the end the 24
04:10 - hours because we're using the module it
04:11 - loops back into zero and continues the
04:13 - next day so that's really all you need
04:15 - to define the logic for the day night
04:16 - cycle
04:17 - in this case for this game for the
04:19 - vampire game it is crucial that we know
04:20 - what is day time and what is night time
04:22 - and of course since the goal is you want
04:24 - to be playing at night since that's when
04:25 - you're most powerful because that the
04:27 - game doesn't have a realistic day-night
04:29 - cycle so instead of something like 16
04:30 - hours of daytime and only 8 hours of
04:32 - night you have pretty much the opposite
04:34 - so over here just a super basic if just
04:36 - get the hours if it's above 4 and less
04:38 - than 11 if so then consider daytime
04:40 - anything else it's nighttime okay so
04:42 - that handles the basic photology to keep
04:44 - track of time and for the visuals it's
04:46 - also pretty simple i just made them
04:48 - using a very simple animation so over
04:49 - here on the directional light i've got a
04:51 - standard light so everything's presented
04:53 - then i've got an animator and on the
04:54 - animator i've got an animation and as
04:56 - you can see as i move the animation
04:58 - there you go it just flips around
04:59 - changes the color and so on so you can
05:01 - see in scene view there it is here is
05:03 - the directional light so on the
05:05 - animation pretty much just rotating
05:07 - around going back and forth and so on
05:09 - and then over here on the light we can
05:11 - see the filter and the temperature so at
05:13 - night time got a very cold color and
05:15 - close the filter just to make it even
05:16 - more blue and then as the sun starts
05:18 - coming up there you go the temperature
05:20 - goes up the filter goes into white then
05:23 - just stays there for a little bit and
05:24 - then once again moves and you can see
05:26 - the shadows
05:27 - so for the visual it really is as simple
05:29 - as this one more thing for this cycle
05:31 - like i saw on the script i'm using a
05:32 - certain multiplier so we're here to
05:34 - control the animation first of all i
05:36 - define the animation exactly the same as
05:37 - i defined the default maximum so i had
05:39 - to find with 24 seconds and over here on
05:41 - the animation this one does last for
05:42 - exactly 24 seconds and then on the
05:44 - animator itself over here i've got just
05:47 - one animation
05:48 - and crucially one thing that you might
05:49 - not know the animator actually has a
05:51 - really nice multiplier field and that
05:53 - field can be based on a parameter so
05:55 - what i did is on the animator i defined
05:57 - a daytime multiplier and it's being
05:59 - applied onto this animation then here on
06:01 - the script i've got a reference to the
06:02 - day knight cycle animator and on awake i
06:05 - simply go in there and i modified the
06:06 - flow to what i have over here so if i
06:09 - want today to be super fast let's have
06:11 - put four in here and yep with that both
06:13 - the logic and the animations they're
06:15 - both perfectly correct then the final
06:17 - visual is just over here the clock so it
06:19 - rotates around when it's daytime the
06:20 - color changes doing that is super simple
06:22 - i've just got a basic canvas inside i've
06:24 - got a game object containing all of the
06:26 - elements i've got a background then a
06:28 - whole bunch of text objects for all the
06:30 - various numbers and then i just have the
06:32 - hand which inside has the actual sprite
06:35 - i made it a child sprite so i can modify
06:37 - the pivot position if you don't know how
06:39 - to do that i actually made a video super
06:40 - long time ago but it's super useful to
06:42 - know basically just offset the child in
06:44 - order to modify the pivot on the parent
06:46 - so with this one on the parent i can
06:47 - simply rotate over here on the z axis
06:49 - and i can rotate the clock around then
06:52 - here for the script controlling it is
06:53 - super simple
06:54 - literally just grabs a reference to the
06:56 - hand transform and modifies the euler
06:58 - angles to rotate it just goes into the
07:00 - sunlight system accesses the instance in
07:02 - order to ask for the date time
07:03 - normalized and multiplies it by 360
07:05 - degrees then also as if it's daytime if
07:07 - so change the background color to the
07:09 - day color if not change to the night
07:10 - color all of it is really pretty simple
07:12 - and here it is the element in action so
07:14 - it's rotating around and in a bit there
07:16 - you go yep it suddenly turns into
07:18 - sunlight
07:19 - okay so these are all the things that
07:20 - make up a basic day night cycle now for
07:22 - the really important part about this
07:24 - mechanic we need to identify when the
07:26 - player is being hit by sunlight
07:28 - so when does the player in shadow and
07:30 - when are they in sunlight
07:31 - now doing this is actually something
07:33 - that is seemingly simple but it's
07:35 - actually quite a bit complex
07:36 - now you might immediately have guessed
07:38 - the straightforward approach that would
07:40 - be using a raycast you know where the
07:42 - player exists so you can simply spawn a
07:44 - raycast right from the player position
07:45 - fire it towards the sky so there you go
07:47 - just in there technically that would
07:49 - work fire the raycast towards the sun
07:50 - and if there's nothing blocking then the
07:52 - player is in the sun if there is
07:53 - something blocking like for example a
07:54 - tree then the players in the shade
07:57 - so you would think that would work
07:59 - however in most games the physics shape
08:01 - of objects does not match the visual
08:02 - shape for example here on this demo i've
08:04 - got all kinds of trees and objects
08:07 - they all have con letters on them if i
08:08 - try moving there you go i cannot go
08:10 - through the tree the tree trunk is solid
08:12 - however if we inspect the tree don't
08:14 - look at it we can see that it does have
08:15 - a very basic leather this one is using a
08:18 - simple capsule collider and not
08:19 - something that actually has the shape of
08:21 - the mesh so the collider shape does not
08:23 - match the original shape and this is
08:25 - exactly what you should do
08:26 - now technically you could swap out disk
08:28 - and leather for a mesh container and
08:29 - then the raycast method would work but
08:32 - having mesh colliders on every single
08:33 - object especially when using it on
08:36 - complex objects like this tree with tons
08:37 - of tiny leaves using that would
08:39 - massively tank your game's performance
08:41 - look at the massive difference in the
08:43 - complex of the actual shape and even
08:45 - with that we can see that the mesh
08:46 - collider it would simply not function if
08:49 - it had the exact same shape as the
08:50 - object so even that one isn't really
08:52 - accurate so because those reasons that
08:53 - is why the obvious approach of using a
08:55 - raycast and collaterals that is why that
08:57 - would not work but instead we can use
08:59 - the next obvious approach which is
09:00 - perhaps even more obvious which is we
09:03 - can literally look at the sun from the
09:04 - point of view of the player if we can
09:06 - visually see the sun then that means
09:07 - there's nothing blocking it so we must
09:09 - be in sunlight and if not then we must
09:11 - be in the shade
09:12 - so that is the approach that i took and
09:14 - over here on the player game object
09:15 - inside it i have a second camera
09:18 - here it is the czech sunlight camera now
09:20 - this one is not running into the screen
09:22 - and said it is rendering onto a render
09:24 - texture now if you don't know about
09:25 - random textures i made a phone video on
09:27 - them they are super useful for making
09:29 - really interesting use cases like this
09:30 - one so the camera output goes on to this
09:32 - texture and then for this section for
09:34 - the settings over here i made with a
09:36 - pretty small size and zero
09:38 - anti-analyzing then for the camera
09:40 - background if you look at it
09:42 - over here for the environment for the
09:43 - background type i went with a solid
09:45 - color and i chose a really nice screen
09:47 - so the goal was if the camera can see
09:49 - this color then that means looking at
09:50 - the sky although that method wasn't
09:53 - actually working too well it has to do
09:55 - with how the background color is still
09:56 - affected by the sunlight color so for
09:58 - the final result i still went with a
10:00 - solid color but more importantly i set
10:01 - the alpha on zero and since i only care
10:03 - about a single pixel that is why the
10:05 - render texture over here is super tiny
10:07 - and again since all i want is really
10:09 - just looks straight at the sun because
10:10 - of that over here the field of view is
10:12 - also super tiny i can increase to see
10:14 - what this camera sees and there you go
10:15 - that's what it sees let's look at it in
10:17 - play mode so put the camera side by side
10:20 - so with this yep there you go as the sun
10:22 - rotates on the sky so does this camera
10:24 - so it's always pointing towards the sun
10:25 - and as i move there you go if it can see
10:28 - the sunlight there you go i'm in sun if
10:30 - not then i'm in the shape and of course
10:32 - again this whole thing works with just
10:33 - one fov
10:35 - one final thing that i also had to
10:36 - change is over here on the camera we've
10:38 - got the clipping planes so the camera
10:40 - just starts seeing at this distance and
10:41 - only sees up until this instance now if
10:44 - i put this at zero then the whole thing
10:46 - breaks because the camera is in there
10:47 - but it's actually looking at the hat
10:49 - that is not what we want we want to see
10:51 - if we can look at the sky from outside
10:53 - the character so that is why over here i
10:55 - set a nice tiny offset so that the
10:56 - camera starts viewing just from up here
10:58 - so that's really it for the camera setup
11:01 - it's just a second camera that is
11:02 - rendering with a super tiny fov
11:04 - rendering onto a texture with a specific
11:06 - color that has alpha of zero
11:08 - then the camera has this simple script
11:10 - attached to it over here it has a
11:12 - reference to the sun which is the
11:13 - directional light then it also grabs the
11:16 - camera target texture then down here i
11:18 - have a function to test if this camera
11:20 - if this character is catching sunlight
11:22 - and really what it does is just cause
11:24 - the read pixels functions in order to
11:25 - read the pixels from the render texture
11:27 - onto a regular texture
11:29 - now if you don't know about this method
11:31 - if you don't understand what this is
11:32 - doing
11:33 - then go watch my video on how to take a
11:34 - screenshot that's pretty much what it's
11:36 - doing here it creates a new texture
11:38 - based on the render texture then just
11:40 - reads the pixels so it reads the pixels
11:41 - from this texture onto this texture then
11:43 - with that to get the sky color i just
11:45 - call getpixel100 to get the sky color
11:47 - and then here like i mentioned i tested
11:49 - out two different approaches for the
11:51 - first one i want to grab this pixel and
11:53 - compare this pixel so get the color
11:55 - difference between the sky color and the
11:56 - camera background color
11:58 - and to do that instead of using just a
12:00 - simple equals since colors are really
12:02 - floats so you should never compare float
12:04 - directly to another float
12:06 - floats have limited precision so you
12:07 - should never ever compare them directly
12:09 - so to compare these two colors i simply
12:11 - made this function it's a super useful
12:13 - function that is part of my utilities so
12:15 - basically what it does just gets all the
12:16 - difference for all the colors so the rgb
12:18 - and a
12:19 - just gets the total difference for all
12:20 - those sums them all up and just returns
12:22 - it then over here i can just test the
12:24 - difference max so if it's under a
12:26 - certain maximum then i consider that the
12:27 - same color which in this case would mean
12:29 - that it's looking at the sky however
12:30 - like it said with this method that was
12:32 - getting some inconsistent results it has
12:34 - to do with how direct and intense the
12:36 - sunlight is
12:37 - if it is too intense and the camera
12:38 - differs from the background color by
12:40 - quite a lot so instead of comparing
12:42 - colors i just went to the second method
12:43 - where literally all i test is just the
12:45 - sky color alpha basically all of the
12:47 - objects in the game they have some alpha
12:49 - they're all solid so if this camera
12:51 - isn't looking at an object that has no
12:52 - alpha then i can be pretty sure that
12:53 - it's looking at the sky and the final
12:55 - thing to make all this work is around
12:57 - just looking straight towards the sun
12:58 - now here you might think that you can
13:00 - instead of doing this just do a simple
13:02 - transform.look at
13:04 - you might think that you can do this
13:05 - this one takes a target for the target
13:07 - transform position
13:09 - however directional lights don't really
13:11 - work like that
13:12 - they don't work based on the position
13:13 - you can move them you can place them
13:15 - anywhere the actual position of this
13:17 - game object has no impact at all the
13:19 - directional light only takes the
13:20 - rotation into account so in this case in
13:22 - order to keep it clean i left the
13:24 - position on zero zero zero so if i had
13:26 - the camera looking straight towards
13:28 - there then to be looking towards that
13:29 - position instead of looking towards the
13:31 - sun this guy
13:32 - so that is why you cannot just do we
13:33 - transform down look at and look at that
13:35 - game object instead you have to take the
13:37 - directional light grab the lights
13:38 - transform forward which is where the
13:40 - light is pointing and then you just
13:42 - invert it and set this one to that with
13:43 - that here it is in the game so look at
13:45 - as how the light rotates around the sky
13:49 - as it moves around you can see the
13:50 - camera is always perfectly pointing and
13:52 - finally for testing i also made this
13:54 - super simple debug element this one is
13:56 - set up as a world space canvas which is
13:58 - super useful check out my video on them
13:59 - if you've never used a world space
14:01 - canvas like i said really useful for
14:03 - adding ui elements onto the world
14:05 - so in this case i just add this one and
14:07 - then inside i just have a very basic
14:08 - image then on this world ui i simply
14:11 - have this script and this script really
14:13 - just has the czech sunlight camera as it
14:15 - is it catching sunlight if so change the
14:17 - color to the day color or the night
14:18 - color so with that i can walk around
14:20 - i've got this nice debug visual that is
14:22 - telling me here i'm in sunlight and if i
14:23 - get into the shade there you go now i'm
14:24 - in the shade now the final thing to make
14:26 - this work is just some basic logic and
14:28 - effects for logic here is the sunlight
14:30 - system script then i've got this
14:32 - function to try to deal sunlight damage
14:34 - and this function is running on every
14:35 - single update and over here the first
14:37 - thing that checks is it daytime so that
14:39 - function once again just says the hour
14:41 - so if so then it's in daytime it checks
14:43 - if it's daytime and then also as the
14:45 - checksum light camera as if the player
14:47 - is catching sunlight if so then it just
14:49 - increases a very basic timer by how long
14:51 - the player has been in sunlight and if
14:53 - this if is false so if it's not a time
14:56 - or the player is not catching sunlight
14:58 - if so then we just reset the timer and
15:00 - for the visuals i just have two basic
15:02 - particle systems so this one just has a
15:04 - handful of particles so the particles
15:05 - are flying away and they've got a nice
15:07 - trail so it looks pretty nice and the
15:09 - second one is pretty much the same thing
15:10 - but a lot more intense and again they
15:12 - also have a simple script doing the same
15:13 - thing to make sure that it looks
15:15 - straight towards the sun then back in
15:16 - logic i just have references to those
15:18 - two so the first one activates if the
15:20 - player has been in sunlight for more
15:21 - than 15 of the maximum time and second
15:24 - one activates after 50 percent and if
15:26 - the player is still there after the
15:27 - maximum amount of time then so the
15:29 - player starts taking damage for damage
15:31 - over here i'm using my own super useful
15:33 - health system that i've been using for
15:34 - many years i've used this in pretty much
15:36 - all of my steam games and a while ago i
15:38 - made it into a proper asset so check it
15:40 - out if you want a simple easy to use and
15:42 - fully featured health system it's
15:44 - completely free so feel free to use it
15:46 - in your own projects and finally the
15:47 - logic also grabs the post crossing
15:49 - volume and modifies the weight so over
15:51 - here i've got a separate game object
15:53 - with a post frosting volume this is a
15:54 - second one so i've got the main one over
15:57 - here is the main post crossing volume so
15:58 - with the main effects and then i've got
16:00 - a second one this one just increased the
16:02 - bloom and increased the color gain this
16:04 - one has a higher priority than the other
16:06 - one so this one has a priority of zero
16:08 - and the burning one has a priority of 10
16:10 - and then on that script all i'm doing is
16:12 - over here modifying the weight so if the
16:13 - player is not taking damage then we've
16:15 - got the regular view and as soon as the
16:16 - players start taking damage then we
16:18 - increase the weight on this one there
16:19 - you go looks really intense
16:20 - okay so with that here is the final
16:22 - mechanic now if it's nighttime i can
16:24 - walk around anywhere i can look at the
16:26 - clock to see when it's night time and
16:27 - when it's day time so after a while
16:29 - there you go it does become daytime i'm
16:30 - currently in the sun and there you go it
16:32 - starts to become much more intense and
16:34 - after a while i'm going to yep there you
16:35 - go i start taking damage so i better run
16:37 - away get into some shade and there you
16:39 - go in the shade i'm safe even though
16:41 - it's daytime when it's night time once
16:43 - again i can walk around anywhere and the
16:45 - day night cycle continues to loop in
16:47 - loop so here i can run around anywhere i
16:49 - can go anywhere i want
16:51 - and now it's about to become daytime so
16:53 - i better run away i better get in the
16:54 - shade and there you go even though it's
16:56 - daytime over here in the shade i'm fine
16:57 - and if i go outside there you go now i'm
16:59 - going to burn all right awesome so this
17:02 - mechanic is really interesting it's
17:03 - really awesome making this was pretty
17:05 - fun learning how to use the camera to
17:07 - build this was a nice fun challenge to
17:08 - complete so here it is my recreation of
17:11 - the v rising sunlight system and i hope
17:13 - you learned something
17:14 - also if you want to learn more about how
17:16 - the game actually works the developers
17:18 - actually did a really in-depth interview
17:19 - with unity on twitch they open up the
17:21 - project and showcase various interesting
17:23 - things for how it works definitely go
17:25 - watch that if you want to learn more
17:26 - about how this game works it's always
17:28 - great to see the behind the scenes of
17:29 - games made with unity that turned out to
17:31 - be excellent games and find massive
17:32 - success and again if you want to learn
17:34 - how to recreate various systems from
17:36 - interesting games then check out the how
17:37 - it's made playlist learn how to make
17:39 - these scout probe launcher from other
17:41 - wilds learn how to clean a mesh like in
17:43 - rover mechanic simulator learn how to
17:45 - interact with world objects and scan
17:46 - things like in cyberpunk and many others
17:49 - and finally if you're still watching
17:50 - this video to the end then thank you and
17:52 - i actually have a gift for you
17:54 - for some reason the v rising devs added
17:56 - my email to their email list now i'm not
17:58 - entirely sure why maybe they confused my
18:00 - channel for a more game playing channel
18:02 - instead of game dev or perhaps since the
18:04 - game is made with unity someone from the
18:05 - team might have learned something from
18:07 - my videos and they intentionally added
18:08 - it to the list
18:09 - anyways whatever the reason was they
18:11 - sent me a bunch of sim keys so as to
18:13 - thank you for sticking with the video to
18:14 - the end if you want to get the game
18:15 - here's some sim keys if you pick them up
18:18 - just let me know in the comments only
18:19 - about 5-10 people watch the videos to
18:21 - the end so this is a nice gift for you i
18:23 - hope you'll enjoy the game just like i
18:24 - did alright hope that's useful check out
18:27 - these videos to learn some more thanks
18:29 - to these awesome patreon supporters for
18:31 - making these videos possible thank you
18:33 - for watching and i'll see you next time
18:39 - [Music]
18:42 - you

Cleaned transcript:

hello and welcome i'm your code monkey and lately i've been trying out vrising it's an excellent vampire survival game that released a while ago it's exactly the kind of game that i like there's resource gathering crafting some nice combat building and so on as you can guess by the name it's all about vampires you play as a vampire and the game features many interesting vampire mechanics taken from the usual vampire myths so for example there are silver coins in the world vampires are weak to silver so if you pick up some coins you won't be constantly taking damage there's also a feed mechanic so when an enemy is weakened you can jump on them and feast on their blood doing so grants some interesting bonuses based on the quality and the type of one another obvious one is garlic there are some garlic defenses in the world and you need to basically buff up your garlic resistance before you can enter that area the game also has interesting faction mechanics so if a group of skeletons comes across some humans in the open world they won't start to fight it's really fun to just sit back fire some projectiles and watch as two enemy factions destroy one another while you sit back and go in the end and just pick up all the loot there's also a pretty robust base building system you can place down areas in a grid then place down walls and doors and inside your castle you can then place down crafting stations chests and so on it works pretty much exactly like what i've already covered in my house building system video so if you want to learn how to make something like that go watch that one so there's lots of interesting mechanics in v rising now here for this video the mechanic that i'd like to recreate is a pretty unique one that requires some clever trickery it's the satellite mechanic as you might know a big part of being a vampire is avoiding sunlight the game itself has a day night cycle when it's night time you can go anywhere without any issues however when it's daylight if you stay in the sun for too long then the sun starts to burn you and take quite a lot of damage if you don't find cover quickly then you will die thankfully the world is filled with tons of trees rocks and buildings so you can jump around between the shadows to move during the day this is a really interesting unique mechanic that perfectly fits the theme of this game so let's see how it actually works and how we can recreate it which involves some clever trickery and if you like this format and want to learn more about how to recreate various systems from interesting games and check out the entire how it's made playlist learn how the scout pro launcher from ottawa works learn how to clean a mesh like in rover mechanic simulator learn how to interact with worm objects and scan things like in cyberpunk or several others okay so here i've got a working demo recreating that mechanic i have my basic player character and i can walk around if you want to know about the character controller this one is based on unity's official third person controller just with an overhead camera and for the assets both the background and the character are from the cinti horror pack it's a really great pack with some spooky vibes obviously perfect for this video and actually right now this pack is discounted as part of a huge centicell it's their anniversary and pretty much every single pack is at half price really great so if you're a fan of their style just like me then check the link description they have asset packs to cover pretty much any game or theme now by inspecting the game we can look at the core components that make up this mechanic first one is really jesse day night cycle i've been meaning to make a tutorial on how to make a day night cycle for quite some time still haven't done it but it's actually pretty simple the main thing is really you just need to keep track of time for that over here i've got my script the sunlight system and as you can see i'm using a flow to store the daytime so it's just a simple float and then down here on update on every update i'm constantly increasing that one by time.time and in order to make it loop after increasing it i just use the modulo operator and some kind of daytime max now for here the maximum amount is arbitrary you can make it a normalized value or use 12 or 24 or literally anything you want for this case i simply went with 24 just to match the hours so with this logic each day is going to last 24 seconds then of course you can also apply just a basic multiplier if you want to make it faster or slower so if i put the multiplier and define it as 0.5 then each day is now going to last 48 seconds in this case to convert daytime into hours since i made the maximum as 24 with that i can just do a fourth in to get the hour so if i do a simple debug log to get the hour if we see what this says there it is on the console constantly increasing and as soon as it reaches the end the 24 hours because we're using the module it loops back into zero and continues the next day so that's really all you need to define the logic for the day night cycle in this case for this game for the vampire game it is crucial that we know what is day time and what is night time and of course since the goal is you want to be playing at night since that's when you're most powerful because that the game doesn't have a realistic daynight cycle so instead of something like 16 hours of daytime and only 8 hours of night you have pretty much the opposite so over here just a super basic if just get the hours if it's above 4 and less than 11 if so then consider daytime anything else it's nighttime okay so that handles the basic photology to keep track of time and for the visuals it's also pretty simple i just made them using a very simple animation so over here on the directional light i've got a standard light so everything's presented then i've got an animator and on the animator i've got an animation and as you can see as i move the animation there you go it just flips around changes the color and so on so you can see in scene view there it is here is the directional light so on the animation pretty much just rotating around going back and forth and so on and then over here on the light we can see the filter and the temperature so at night time got a very cold color and close the filter just to make it even more blue and then as the sun starts coming up there you go the temperature goes up the filter goes into white then just stays there for a little bit and then once again moves and you can see the shadows so for the visual it really is as simple as this one more thing for this cycle like i saw on the script i'm using a certain multiplier so we're here to control the animation first of all i define the animation exactly the same as i defined the default maximum so i had to find with 24 seconds and over here on the animation this one does last for exactly 24 seconds and then on the animator itself over here i've got just one animation and crucially one thing that you might not know the animator actually has a really nice multiplier field and that field can be based on a parameter so what i did is on the animator i defined a daytime multiplier and it's being applied onto this animation then here on the script i've got a reference to the day knight cycle animator and on awake i simply go in there and i modified the flow to what i have over here so if i want today to be super fast let's have put four in here and yep with that both the logic and the animations they're both perfectly correct then the final visual is just over here the clock so it rotates around when it's daytime the color changes doing that is super simple i've just got a basic canvas inside i've got a game object containing all of the elements i've got a background then a whole bunch of text objects for all the various numbers and then i just have the hand which inside has the actual sprite i made it a child sprite so i can modify the pivot position if you don't know how to do that i actually made a video super long time ago but it's super useful to know basically just offset the child in order to modify the pivot on the parent so with this one on the parent i can simply rotate over here on the z axis and i can rotate the clock around then here for the script controlling it is super simple literally just grabs a reference to the hand transform and modifies the euler angles to rotate it just goes into the sunlight system accesses the instance in order to ask for the date time normalized and multiplies it by 360 degrees then also as if it's daytime if so change the background color to the day color if not change to the night color all of it is really pretty simple and here it is the element in action so it's rotating around and in a bit there you go yep it suddenly turns into sunlight okay so these are all the things that make up a basic day night cycle now for the really important part about this mechanic we need to identify when the player is being hit by sunlight so when does the player in shadow and when are they in sunlight now doing this is actually something that is seemingly simple but it's actually quite a bit complex now you might immediately have guessed the straightforward approach that would be using a raycast you know where the player exists so you can simply spawn a raycast right from the player position fire it towards the sky so there you go just in there technically that would work fire the raycast towards the sun and if there's nothing blocking then the player is in the sun if there is something blocking like for example a tree then the players in the shade so you would think that would work however in most games the physics shape of objects does not match the visual shape for example here on this demo i've got all kinds of trees and objects they all have con letters on them if i try moving there you go i cannot go through the tree the tree trunk is solid however if we inspect the tree don't look at it we can see that it does have a very basic leather this one is using a simple capsule collider and not something that actually has the shape of the mesh so the collider shape does not match the original shape and this is exactly what you should do now technically you could swap out disk and leather for a mesh container and then the raycast method would work but having mesh colliders on every single object especially when using it on complex objects like this tree with tons of tiny leaves using that would massively tank your game's performance look at the massive difference in the complex of the actual shape and even with that we can see that the mesh collider it would simply not function if it had the exact same shape as the object so even that one isn't really accurate so because those reasons that is why the obvious approach of using a raycast and collaterals that is why that would not work but instead we can use the next obvious approach which is perhaps even more obvious which is we can literally look at the sun from the point of view of the player if we can visually see the sun then that means there's nothing blocking it so we must be in sunlight and if not then we must be in the shade so that is the approach that i took and over here on the player game object inside it i have a second camera here it is the czech sunlight camera now this one is not running into the screen and said it is rendering onto a render texture now if you don't know about random textures i made a phone video on them they are super useful for making really interesting use cases like this one so the camera output goes on to this texture and then for this section for the settings over here i made with a pretty small size and zero antianalyzing then for the camera background if you look at it over here for the environment for the background type i went with a solid color and i chose a really nice screen so the goal was if the camera can see this color then that means looking at the sky although that method wasn't actually working too well it has to do with how the background color is still affected by the sunlight color so for the final result i still went with a solid color but more importantly i set the alpha on zero and since i only care about a single pixel that is why the render texture over here is super tiny and again since all i want is really just looks straight at the sun because of that over here the field of view is also super tiny i can increase to see what this camera sees and there you go that's what it sees let's look at it in play mode so put the camera side by side so with this yep there you go as the sun rotates on the sky so does this camera so it's always pointing towards the sun and as i move there you go if it can see the sunlight there you go i'm in sun if not then i'm in the shape and of course again this whole thing works with just one fov one final thing that i also had to change is over here on the camera we've got the clipping planes so the camera just starts seeing at this distance and only sees up until this instance now if i put this at zero then the whole thing breaks because the camera is in there but it's actually looking at the hat that is not what we want we want to see if we can look at the sky from outside the character so that is why over here i set a nice tiny offset so that the camera starts viewing just from up here so that's really it for the camera setup it's just a second camera that is rendering with a super tiny fov rendering onto a texture with a specific color that has alpha of zero then the camera has this simple script attached to it over here it has a reference to the sun which is the directional light then it also grabs the camera target texture then down here i have a function to test if this camera if this character is catching sunlight and really what it does is just cause the read pixels functions in order to read the pixels from the render texture onto a regular texture now if you don't know about this method if you don't understand what this is doing then go watch my video on how to take a screenshot that's pretty much what it's doing here it creates a new texture based on the render texture then just reads the pixels so it reads the pixels from this texture onto this texture then with that to get the sky color i just call getpixel100 to get the sky color and then here like i mentioned i tested out two different approaches for the first one i want to grab this pixel and compare this pixel so get the color difference between the sky color and the camera background color and to do that instead of using just a simple equals since colors are really floats so you should never compare float directly to another float floats have limited precision so you should never ever compare them directly so to compare these two colors i simply made this function it's a super useful function that is part of my utilities so basically what it does just gets all the difference for all the colors so the rgb and a just gets the total difference for all those sums them all up and just returns it then over here i can just test the difference max so if it's under a certain maximum then i consider that the same color which in this case would mean that it's looking at the sky however like it said with this method that was getting some inconsistent results it has to do with how direct and intense the sunlight is if it is too intense and the camera differs from the background color by quite a lot so instead of comparing colors i just went to the second method where literally all i test is just the sky color alpha basically all of the objects in the game they have some alpha they're all solid so if this camera isn't looking at an object that has no alpha then i can be pretty sure that it's looking at the sky and the final thing to make all this work is around just looking straight towards the sun now here you might think that you can instead of doing this just do a simple transform.look at you might think that you can do this this one takes a target for the target transform position however directional lights don't really work like that they don't work based on the position you can move them you can place them anywhere the actual position of this game object has no impact at all the directional light only takes the rotation into account so in this case in order to keep it clean i left the position on zero zero zero so if i had the camera looking straight towards there then to be looking towards that position instead of looking towards the sun this guy so that is why you cannot just do we transform down look at and look at that game object instead you have to take the directional light grab the lights transform forward which is where the light is pointing and then you just invert it and set this one to that with that here it is in the game so look at as how the light rotates around the sky as it moves around you can see the camera is always perfectly pointing and finally for testing i also made this super simple debug element this one is set up as a world space canvas which is super useful check out my video on them if you've never used a world space canvas like i said really useful for adding ui elements onto the world so in this case i just add this one and then inside i just have a very basic image then on this world ui i simply have this script and this script really just has the czech sunlight camera as it is it catching sunlight if so change the color to the day color or the night color so with that i can walk around i've got this nice debug visual that is telling me here i'm in sunlight and if i get into the shade there you go now i'm in the shade now the final thing to make this work is just some basic logic and effects for logic here is the sunlight system script then i've got this function to try to deal sunlight damage and this function is running on every single update and over here the first thing that checks is it daytime so that function once again just says the hour so if so then it's in daytime it checks if it's daytime and then also as the checksum light camera as if the player is catching sunlight if so then it just increases a very basic timer by how long the player has been in sunlight and if this if is false so if it's not a time or the player is not catching sunlight if so then we just reset the timer and for the visuals i just have two basic particle systems so this one just has a handful of particles so the particles are flying away and they've got a nice trail so it looks pretty nice and the second one is pretty much the same thing but a lot more intense and again they also have a simple script doing the same thing to make sure that it looks straight towards the sun then back in logic i just have references to those two so the first one activates if the player has been in sunlight for more than 15 of the maximum time and second one activates after 50 percent and if the player is still there after the maximum amount of time then so the player starts taking damage for damage over here i'm using my own super useful health system that i've been using for many years i've used this in pretty much all of my steam games and a while ago i made it into a proper asset so check it out if you want a simple easy to use and fully featured health system it's completely free so feel free to use it in your own projects and finally the logic also grabs the post crossing volume and modifies the weight so over here i've got a separate game object with a post frosting volume this is a second one so i've got the main one over here is the main post crossing volume so with the main effects and then i've got a second one this one just increased the bloom and increased the color gain this one has a higher priority than the other one so this one has a priority of zero and the burning one has a priority of 10 and then on that script all i'm doing is over here modifying the weight so if the player is not taking damage then we've got the regular view and as soon as the players start taking damage then we increase the weight on this one there you go looks really intense okay so with that here is the final mechanic now if it's nighttime i can walk around anywhere i can look at the clock to see when it's night time and when it's day time so after a while there you go it does become daytime i'm currently in the sun and there you go it starts to become much more intense and after a while i'm going to yep there you go i start taking damage so i better run away get into some shade and there you go in the shade i'm safe even though it's daytime when it's night time once again i can walk around anywhere and the day night cycle continues to loop in loop so here i can run around anywhere i can go anywhere i want and now it's about to become daytime so i better run away i better get in the shade and there you go even though it's daytime over here in the shade i'm fine and if i go outside there you go now i'm going to burn all right awesome so this mechanic is really interesting it's really awesome making this was pretty fun learning how to use the camera to build this was a nice fun challenge to complete so here it is my recreation of the v rising sunlight system and i hope you learned something also if you want to learn more about how the game actually works the developers actually did a really indepth interview with unity on twitch they open up the project and showcase various interesting things for how it works definitely go watch that if you want to learn more about how this game works it's always great to see the behind the scenes of games made with unity that turned out to be excellent games and find massive success and again if you want to learn how to recreate various systems from interesting games then check out the how it's made playlist learn how to make these scout probe launcher from other wilds learn how to clean a mesh like in rover mechanic simulator learn how to interact with world objects and scan things like in cyberpunk and many others and finally if you're still watching this video to the end then thank you and i actually have a gift for you for some reason the v rising devs added my email to their email list now i'm not entirely sure why maybe they confused my channel for a more game playing channel instead of game dev or perhaps since the game is made with unity someone from the team might have learned something from my videos and they intentionally added it to the list anyways whatever the reason was they sent me a bunch of sim keys so as to thank you for sticking with the video to the end if you want to get the game here's some sim keys if you pick them up just let me know in the comments only about 510 people watch the videos to the end so this is a nice gift for you i hope you'll enjoy the game just like i did alright hope that's useful check out these videos to learn some more thanks to these awesome patreon supporters for making these videos possible thank you for watching and i'll see you next time you
