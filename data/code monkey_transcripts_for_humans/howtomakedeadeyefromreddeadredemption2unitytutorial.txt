With timestamps:

00:00 - hello and welcome I'm your code monkey
00:01 - in this video we're going to make the
00:02 - Deadeye ability from red redemption to
00:04 - let's begin
00:08 - okay so here's the scene I have prepared
00:10 - I have a player character I can move
00:12 - around and there are enemies being
00:14 - spawned and I can shoot my weapon and
00:16 - kill them once they get shot they fly
00:19 - away when they are dead okay so this is
00:22 - the base that we're going to use so over
00:24 - here is the player class it is very
00:26 - simple it simply deals with player
00:29 - movement and player shooting you can
00:31 - check out a detailed video on the player
00:33 - movement with the simple character
00:34 - movement video but it's still pretty
00:36 - simple so on the update I simply have a
00:39 - switch on state and right now there is
00:41 - only one state the normal state so on
00:43 - case normal we handle our movement
00:45 - so the function down here simply tests
00:47 - for the keyboard input on the WUSA and D
00:50 - Keys it creates a movement direction
00:53 - using those keys and moves the player
00:55 - accordingly then on the update we are
00:57 - also calling the Hamel aim shooting and
00:59 - this again it's only getting the target
01:01 - position which is the mouse world
01:03 - position
01:03 - it sets the aim target to that target
01:05 - position and when we press the left
01:07 - mouse button if we can fire then we fire
01:10 - and play the animation so that's a very
01:13 - simple setup for the player class over
01:15 - here on this scene I have a
01:17 - post-processing effect to simulate the
01:19 - Deadeye effect I have setup on the
01:21 - values and now in order to use the
01:23 - effect on we need to do is modify the
01:25 - weight in here so if it is on zero it's
01:27 - come on with disable these are the
01:28 - normal colors and if I increase it up to
01:30 - one then gets the complete effect in
01:33 - order to set up the post-processing we
01:34 - need is this post-process volume in here
01:37 - and on the main camera we also have a
01:39 - post-processing layer and using that
01:41 - layer and so on so again all we need to
01:44 - do is modify the weight to go from zero
01:46 - to one okay so let's begin by making a
01:49 - new C sharp script this will be the Dead
01:51 - Eye class this will handle the effects
01:54 - and the state of the Dead Eye in here
01:56 - let's make this a static function since
01:58 - we don't want to instantiate it so make
02:00 - it static and remove the amount of
02:02 - behavioral references this is going to
02:04 - be a very simple clean class so let's
02:06 - begin with a init function this won't
02:09 - receive the references that we're going
02:10 - to use so in it and in here first let's
02:14 - receive the post process volume that
02:16 - we're going to use to modify the weight
02:18 - so in order to do that we have to go
02:20 - using the Unity engine rendering that
02:24 - post-processing so now in here we can
02:26 - receive a post processed volume and
02:29 - let's call it the black/white post
02:31 - processed phone it isn't black and white
02:35 - it's more of a sepia but that's a good
02:36 - name for it so in here let's store it so
02:42 - in this class we're going to have two
02:44 - functions want to start the data effect
02:46 - and want to end it so let's begin with a
02:48 - public static void start and then we're
02:51 - going to have a public static void and
02:54 - now in our start let's simply enable the
02:57 - effect so we can see it in action so we
02:59 - simply do the black/white closed process
03:01 - volume and set the weight to one and on
03:04 - the end let's set the weight back to
03:06 - zero okay so that's the effect now let's
03:09 - also make a public static ball is active
03:13 - to test if the effect is active okay so
03:24 - this is our very simple that I class it
03:26 - has everything we need to start testing
03:28 - so now let's go into the player class
03:30 - and up here after we test for the
03:33 - shooting and the movement let's make
03:34 - another function this one will be the
03:36 - handle that I so let's make in here
03:40 - private void handle that I and in here
03:43 - drink test for an input let's say Kiko D
03:48 - so when we press E and let's toggle D
03:51 - that I effect so let's check if that I
03:54 - if it is active then we do that I dot
03:59 - end if it is not active then we do that
04:02 - either start okay so by pressing E we
04:05 - should be able to toggle the data effect
04:07 - and now finally all we need is to go and
04:09 - take the game hammer so in here we have
04:11 - the code that is currently spawning the
04:13 - enemies so let's add another serialize
04:16 - field and here we're going to receive
04:18 - the post processing volume
04:25 - and we're going to initialize that I
04:27 - class and give it this reference okay so
04:31 - just like this we have everything to be
04:32 - able to test okay here's my character
04:34 - everything well it's normal I can shoot
04:36 - and I can kill enemies okay and now if i
04:37 - press e if there go the effect is active
04:40 - and if i press e again
04:42 - yep no it's a day one so enable disable
04:45 - okay great so instead of enabling and
04:47 - disabling the effect instantly and let's
04:49 - add a slight animation so here on let me
04:52 - add a private static void and I'm going
04:54 - to call this the animate black/white
04:57 - effect receive a float for the start
05:00 - float for the N and a float for the
05:03 - animation time so in here we want to
05:06 - increase or decrease the weight starting
05:09 - at start ending at end and taking
05:11 - animate time to do the animation so
05:13 - that's essentially a very simple loop
05:15 - function so let's do that in order to do
05:17 - it I'm going to use the function updater
05:19 - from the code Mach utilities which is
05:21 - always you can grab for free from unity
05:23 - code Maki calm so I go up here using
05:26 - code monkey Dada tones so now I can go
05:30 - down here and use a function updater
05:32 - this essentially lets me trigger an
05:34 - action on every update so this action
05:37 - here on betray run every update so in
05:39 - here we want to set the white white
05:41 - post-process volume and modify the
05:43 - weight now let's use math F dot work
05:46 - we're going to start going to Evan end
05:48 - and then we need a time value so let's
05:51 - do clear a time which starts at zero and
05:53 - will end at one so in here let's
05:56 - increase it by unscaled out the time
05:59 - since we're also going to modify the
06:00 - normal time scale and we similarly
06:03 - divided by the animate time okay and
06:05 - finally the function of theater can
06:07 - receive an action which returns a
06:09 - boolean and if that bowline is true it
06:11 - destroys it so in here we'll return time
06:13 - bigger than one so essentially if time
06:16 - is very than 1 then the function updater
06:17 - won't destroy itself if not it won't
06:19 - keep running on every update okay so now
06:22 - we can go up here and on start we want
06:25 - to animate we want to start on zero F we
06:27 - want to end on one F and let's say
06:30 - between one second and
06:33 - and we do the same thing so we go from
06:35 - one to zero all right so let's also do
06:38 - the same thing to animate the time scale
06:40 - so in here make animates time scale
06:43 - effect and we're going to modify the
06:47 - time that time scale by that amount so
06:51 - the time scale if you don't know as you
06:53 - can see it is the scale at which the
06:54 - time is passing so essentially normal is
06:57 - that one F but if we want to do some
06:59 - slow motion effects we can simply reduce
07:00 - this value so in here when we activate
07:03 - let's put the game on slow motion at
07:05 - about 20% so we animate the time scale
07:09 - effect let's start that one up at normal
07:12 - time then we're going to slow it down to
07:15 - 20% and again do it over one second okay
07:18 - and here we start at point two and we
07:21 - end at one all right so we can tweak
07:23 - these values but it looks good for now
07:25 - so again what's test okay so here I am I
07:28 - can still move I can shoot enemies
07:30 - everything is fine now if I press E yep
07:33 - there you the effect is animated and
07:35 - after a while it is phone and the same
07:36 - thing for the time effect as you can see
07:38 - everything is on slow motion I can shoot
07:40 - them and everything works now if i press
07:42 - e yep everything goes back to normal
07:45 - after one second okay so we need to make
07:47 - the time scale animation a bit faster
07:49 - but everything else looks good
07:51 - okay so now that we have the officials
07:53 - working let's the only way the Dead Eye
07:54 - tags so essentially in here we want to
07:57 - add a bunch of positions and then we
07:59 - finally shoot towards all of those
08:00 - positions so in order to do that let's
08:02 - first go into the player and in here we
08:05 - want to add another state because we
08:07 - don't want them shooting once the data
08:09 - is active so let's have the state that I
08:13 - active so here let's rename this to
08:16 - handle that I activate and here we are
08:18 - simply going to enable and once we do we
08:22 - set this state to state that that I
08:24 - active okay so now I'm here on the
08:27 - update let's handle the other state so
08:31 - here let's make a function to handle the
08:33 - tag so handle dead i tagging
08:37 - and I mean here we want to capture
08:39 - onmousedown so if input dark yet mouse
08:43 - button down of the left mouse button so
08:45 - button zero and okay so let's grab the
08:49 - target position which is the vector
08:50 - three for the target position which we
08:55 - go into the Utah's class to get the
08:56 - mouse world position so that's the
08:59 - position that we want to tag so in order
09:01 - to do that we have to be able to add
09:03 - tags on the data so in here let's make
09:06 - another function a public static void
09:08 - try add tag and this will receive a
09:13 - vector three for deep tag position we're
09:17 - calling it try a tag so we have a limit
09:19 - so up here let's make a private constant
09:23 - for the tag amount Max and let's say a
09:26 - maximum of five tags then we're going to
09:29 - need a private static list of the vector
09:33 - 3 this will be the tag position listen
09:37 - so in here let's initialize the list and
09:40 - down here when we try to add a tag if
09:42 - the tag position only star count if it
09:44 - is less than the tag amount max then
09:48 - here we can add the tag so add the tag
09:50 - position to the tag position list so now
09:53 - we can go back into the player and here
09:55 - when we press a mouse button we can go
09:58 - into that I class and try to add a tag
10:00 - and this is the time so now we are
10:02 - successfully capturing all the various
10:04 - tag positions with a limit of five now
10:07 - we need the player to receive that list
10:08 - when the data actually ends so in order
10:11 - to do that we're going to modify the DAT
10:12 - I start class and in here we're going to
10:15 - receive an action which is on using
10:18 - system so we're going to receive an
10:21 - action and we're going to call it on
10:23 - that I end and that action will receive
10:27 - a list of vector threes an action is a
10:30 - function so in this case the start will
10:32 - be called with a function on the
10:34 - parameters and that function will
10:36 - receive a list of vector three as a
10:38 - parameter so in order to do that let's
10:40 - store this up here so now on the end
10:45 - after we do all the effects let's call
10:48 - this function using our tag
10:51 - list okay so now we can go back into the
10:53 - player and in here on start it expects a
10:56 - action that receives a list so in here
10:59 - let's make a private void on that I end
11:02 - and we're going to receive a list of
11:05 - vector3 this won't be the tag position
11:08 - lists and this function is what we're
11:11 - going to pass as an argument towards
11:12 - this function okay so essentially when
11:15 - this function is called we receive the
11:17 - tag position list which contains a list
11:19 - of all the positions that were tagged so
11:21 - in here all we need to do is shoot
11:22 - towards everything on one of them so I'm
11:25 - going to do a for and D equals zero
11:27 - going to cycle through the tag position
11:29 - list our count now in hearing at a
11:32 - vector3 for the tagged position so now I
11:36 - want to shoot this tag now obviously I
11:39 - don't want to shoot all the positions at
11:40 - the same time so I want there to be a
11:42 - little delay so in order to do that I'm
11:44 - going to use the function timer which
11:45 - again part of the code monkey utilities
11:47 - so this lets me easily trigger an action
11:50 - after some time so we're going to fire
11:53 - towards a tag using the same pistol fire
11:56 - rate that we use normally so in here
11:58 - let's trigger an action after fire rate
12:00 - multiplied by the index and here we
12:03 - simply do the same thing for the shoot
12:04 - target so we should this tag position
12:07 - after fire rate times I so essentially
12:10 - the first tag position will essentially
12:12 - fire instantly because it won't fire
12:14 - this action at fire rate times 0 which
12:17 - is 0 so it won't execute
12:19 - instantly then the second one won't fire
12:21 - towards the second tag position after if
12:24 - I write x 1 so the fire rate is at 200
12:28 - milliseconds so it won't fire at the
12:30 - first act position and 200 milliseconds
12:32 - later it won't fire at the second and so
12:34 - on ok so the last thing we need is to
12:36 - actually deactivate the Deadeye to call
12:39 - that I dot n so let's go up here handle
12:42 - dead I end and here let's make a fresh
12:47 - void handle that I N and we're going to
12:49 - do essentially the same thing as in here
12:51 - except instead of start we're going to
12:53 - trigger the end and we're going to bring
12:55 - the state back to normal ok so let's see
12:59 - fun with this is correct ok so here I am
13:02 - walking around I can still shoot I can
13:04 - do everything and now for pricey give
13:07 - there go the effects arts and Sun slow
13:09 - motion now I can click on various
13:10 - positions so click here click here here
13:13 - and here
13:13 - knife repress key yep choo-choo-choo yep
13:16 - there you go he fired into all the
13:18 - positions exactly as we wanted so again
13:20 - what's going to that I and shoot down
13:22 - and down and now actually there won't be
13:25 - an issue so let's see if there you go he
13:27 - actually fired five or six shots so
13:30 - that's because we are not clearing the
13:32 - list and if you can also see we also
13:34 - have an issue with the animation which
13:36 - is we click here here then we are aiming
13:39 - in there and check out the weapon and
13:40 - there you go the weapon is not working
13:42 - in the correct position so essentially
13:44 - we want to still block the normal aiming
13:47 - and movement until the effect is
13:49 - completed but after that everything is
13:52 - fine okay so first you fix the animation
13:55 - so in here when we press to end the data
13:57 - we check if that I dot is active if it
14:01 - is active then we end it and that's it
14:03 - we don't modify the state instead we
14:06 - modify the state down here or we add
14:09 - another function timer after the fire
14:11 - rate dot count so after every tag
14:14 - position has been shot then we are going
14:16 - to execute an action and that action
14:18 - will set the state back to normal
14:21 - ok so this solves the animation issue
14:23 - now again on the dead eye in here on
14:26 - start we have to reset the attack
14:28 - position list so it's very simple just
14:30 - here dot clear this list ok so let's see
14:34 - if those issues have been sold okay here
14:37 - I am again walking around naming
14:38 - perfectly fine okay now if I press E
14:41 - yeah there you go slow motion everything
14:43 - now I shoot there there and there and
14:45 - click shoot shoot shoot
14:47 - yep there you go the animation of the
14:49 - pistol was correct now it's back to
14:50 - normal so again let's see if it no
14:53 - longer save the previous one so again
14:55 - back into that I I'm going to shoot in
14:57 - here and here and it should only fire
14:58 - two shots one two yep there you go okay
15:01 - great so the effect is pretty much
15:03 - working right now now the only thing we
15:06 - need obviously is to actually see where
15:08 - we are actually tagging so we need to be
15:10 - able to view all the tags that have
15:12 - already been created so let's do that so
15:14 - over here on the antenna class
15:16 - let's create a inner class to deal with
15:19 - each specific that I tagged so in here
15:21 - let's make a public class and let's call
15:25 - this that I tagged this won't represent
15:29 - a single time so in here let's make a
15:32 - constructor and we're going to receive a
15:35 - vector3 for the EPAct position and we're
15:38 - going to store it internally then I
15:42 - would simply have a public vector three
15:45 - to get the position which will return
15:47 - the tag position okay so now we have a
15:50 - nice object that is responsible for each
15:52 - tag so using that we can go up here and
15:55 - essentially clean up our code instead of
15:58 - having a list of tag positions we're
16:00 - going to have a list of data tag so
16:02 - let's rename this to that I tag list so
16:07 - down here when we are adding a tag
16:10 - instead of adding a tag position we're
16:13 - going to add a new that I tagged using
16:15 - this tag position
16:16 - okay and on that I end up here let's
16:19 - calculate a list of vector three for the
16:22 - tag position list since that is what we
16:24 - want to pass back to our player so make
16:28 - any own list and now cycle through all
16:30 - the dead I tanks
16:38 - okay so we have reworked the code to
16:41 - work with a specific that I tagged
16:42 - object but everything else should still
16:44 - be working the player is still receiving
16:46 - a list of vector three okay so now let's
16:49 - see on with making the UI visual so
16:51 - we're here on my canvas I'm going to
16:53 - create an empty game object and I'm
16:55 - going to name this the Deadeye
16:56 - UI and inside I'm going to add a UI
17:00 - image which won't contain the cross
17:03 - image that I have in here so let's just
17:05 - tint it in red and make it a good size
17:08 - okay so this is our cross now let's name
17:11 - this into the cross template this is the
17:13 - template that we're going to duplicate
17:15 - so let's make the script to handle the
17:17 - UI so in here let's make a new C sharp
17:19 - script D dead eye UI and inside we're
17:23 - going to have a function a public static
17:26 - void
17:28 - add tag and this will receive a debt I
17:31 - doubt that I tagged that I tank in order
17:35 - to use a static let's store our instance
17:37 - so private static that UI for the
17:40 - instance so here let's also grab a
17:45 - reference to the transform for the tag
17:48 - template transform so in here on let's
17:57 - section we rename this to add tag static
17:59 - which will do an instance add tag and
18:05 - here we have a private void add tag
18:08 - which will receive the same thing so in
18:11 - here the first thing we want to do is
18:12 - duplicate our template so now we have
18:19 - our duplicated tag transform and now we
18:22 - need to actually position it where it
18:23 - should be so essentially we need to
18:26 - convert our data tag position which is a
18:29 - worm position into a UI position so in
18:32 - here we have a vector3 for the tag world
18:35 - position which is the data tag that get
18:37 - position so this is the position in the
18:40 - world so we take that and we do a camera
18:43 - that main that worm to screen point so
18:47 - we convert that Worman position into a
18:49 - screen position so a vector3 for the
18:51 - screen point now we want to convert the
18:54 - screen point into the UI point so we
18:57 - grab a vector3 for the UI world point
19:01 - which will be the UI camera that's what
19:04 - we're going to need a reference to and
19:06 - do screen to world points of the screen
19:11 - point so here what's at a private camera
19:15 - for the UI camera since we need that
19:17 - reference so now we have the UI world
19:20 - points all we needs to convert into a
19:22 - local point so a vector3 for the UI
19:25 - point which will be the transform dot
19:30 - inverse transform point so we take a
19:33 - world space and put it into a local
19:35 - space so we do that using the work
19:38 - world point and then we simply set the
19:41 - tag transform the local position said
19:45 - welcome position to be at this UI point
19:47 - and since the UI is on a different Z
19:49 - then let's simply reset the Z ok so
19:52 - again the Deadeye tag contains a world
19:55 - position up here on the get position so
19:57 - we get the world position since the
19:59 - camera and the UI camera are different
20:01 - we need to convert the position between
20:03 - one and the other so we convert from a
20:05 - world position into a screen position
20:07 - based on what the main camera is seeing
20:10 - so that gives us a position within
20:12 - somewhere in our screen bounds so taking
20:15 - that screen position then we use the UI
20:17 - camera to convert the screen into a
20:19 - world point using the perspective of the
20:22 - UI camera and then using that one point
20:25 - we convert it into a local point on this
20:28 - transform and that's what we're going to
20:30 - place it okay so now we can go back into
20:32 - the Deadeye class and here when we are
20:34 - trying to add the tag we create a new
20:37 - that I tagged and after adding it to the
20:42 - list let's also go into the data IUI and
20:45 - we're going to add tag static and we're
20:47 - going to pass in this tag so we call
20:50 - this and then this one calls this
20:51 - function which insensate s' the tag
20:53 - transform and so on and so forth ok so
20:55 - let's see that in action
20:56 - ok here I am everything is normal now if
20:59 - I press E that is now active now if I
21:01 - click there you go there's the tag
21:04 - position now I click in here and here
21:05 - and yep it is spawning all of the
21:07 - correct positions in the correct point
21:09 - and as you can see they are limited to
21:11 - five tags now as you can also see the
21:14 - position is correct where I click but it
21:16 - is not accompanying when the camera
21:18 - actually moves so we need to update the
21:20 - position on every frame so let's do that
21:22 - so in here let's make an inner class to
21:24 - dealing with each specific UI object
21:31 - then here I'm going to have a
21:33 - constructor and in that constructor I'm
21:35 - going to receive a dead eye dot that I
21:37 - tagged
21:40 - and I'm also going to receive the
21:42 - transform so then let's make a public
21:48 - void update which will update the
21:51 - position of this that I tagged so
21:54 - essentially we're going to copy all of
21:55 - this code instead of running it just
21:57 - when it's in sentient we're going to run
21:58 - it every time ok so now up here when we
22:09 - are adding the time let's create a that
22:11 - I tagged UI object give it thee that I
22:15 - tagged the new only created tag
22:17 - transform so now essentially everything
22:21 - is working exactly the same as
22:22 - previously it is only being updated on
22:24 - start so we need to go up here and make
22:26 - a list we need a private list of that I
22:30 - tagged UI object and here we want to add
22:35 - this to the list and on the main UI we
22:40 - can now do a private void update since
22:42 - this is a mana behavior and in here we
22:45 - simply cycle through all the objects and
22:49 - we call that I object our update ok so
22:53 - on every update we are calling this
22:54 - update function which this update
22:56 - function is doing everything we did
22:58 - previously so it gets the tag position
23:00 - and it converts into world to UI point
23:03 - so let's see if all of our tags are
23:05 - updating their position okay so here I
23:07 - am going to enable that I okay and I'm
23:09 - going to click run on top of this bush
23:11 - and you up there we go if I move the
23:13 - camera you can see that the tag is
23:15 - always on the same position now I click
23:17 - on this one on this one and now I
23:19 - stopped and yep there you go he fired
23:21 - into all the positions ok great and as
23:23 - you can see they are still tracking but
23:25 - obviously Wendy that I is ended that
23:28 - cross should be destroyed so let's do
23:30 - that so here let's make a public static
23:34 - void destroy all times and here I'm
23:38 - going to cycle through all of the tags
23:40 - in my list and I'm going to tell the tag
23:43 - to destroy it so
23:46 - so now let's go down here and make a
23:49 - destroy cell function so all we need to
23:52 - do is to call the destroy into the
23:54 - transform game object and up here and
23:58 - let's also clear the list so clear the
24:02 - UI object list okay so now let's call
24:06 - this over here on the Deadeye when the
24:08 - Deadeye is over and here when it's false
24:10 - we going to then I you wan and call the
24:13 - destroy all tanks okay so let's see so
24:17 - enable that I tagged in here here and
24:19 - here and I'll click II and there you go
24:22 - he fired into all and all the tags are
24:24 - vanish okay great now there is still one
24:27 - thing that we need to do which is if I
24:30 - enable it and I click on this one right
24:32 - here you can see that the tag stays in
24:34 - the position where as in the game itself
24:36 - when you click on top of an enemy the
24:39 - tag actually follows that enemy so in
24:41 - this case if I click on an enemy and
24:43 - then he moves away then I wouldn't hit
24:44 - him
24:45 - so it's dealing with that so over here
24:47 - on the player class when we have that I
24:49 - active we are calling the Deadeye
24:51 - tagging and it's in here that we are
24:53 - adding new tanks so it's in here that we
24:55 - need to check if we are clicking on top
24:57 - of an enemy or not so in order to test
25:00 - that we can simply do physics 2d do an
25:04 - overlap point we're going to test on the
25:06 - target position this function returns a
25:09 - Collider 2d which is a Collider on this
25:14 - position so first thing we need to do is
25:16 - test that the collider is not known then
25:18 - we have actually clicked on something so
25:21 - if we have clicked on something that we
25:24 - want to check if that something is an
25:26 - enemy so in order to do that we can
25:28 - simply use a dummy component to tag our
25:30 - enemies so in here let's make a new C
25:33 - sharp script and call this dead I tagged
25:36 - alone
25:37 - this won't be just a completely empty
25:38 - motor behavior so I have here the enemy
25:41 - prefab which as you can see has a box
25:43 - Collider and then the enemy scripts and
25:45 - I'm simply going to drag this component
25:47 - onto it again it's a component empty
25:49 - component so now using that we can go
25:51 - back into our point class and over here
25:54 - if we do have a Collider
25:55 - we get the coiler that game object
25:57 - getcomponent
25:59 - dead i taggable so if that component if
26:04 - it is not known then that means this
26:07 - Collider the game object that this
26:09 - Collider is on also has that i taggable
26:11 - so we can assume that is our enemy so
26:14 - now that we know that we need to know
26:15 - the unlock composition that we have
26:17 - clicked so define a vector3
26:19 - for the whole contact position so that
26:23 - position is on the collider that
26:25 - transform dot inverse transform point so
26:29 - this converts from world space into a
26:31 - local space and we want to do that using
26:33 - the target position so this will give us
26:36 - a local target position hello come to
26:39 - the enemy transform so if you click
26:42 - exactly on top of the enemy transform
26:44 - then this will be on 0 0 if we can look
26:46 - slightly above then this won't be
26:47 - someone like 0 1 so now all we need is
26:50 - to be able to add a tag that actually
26:52 - updates its position every time so we
26:55 - need essentially to create a fault which
26:57 - will return a vector 3 and this will be
26:59 - the tag position func
27:01 - which will essentially return the
27:05 - transform dot position + V on low
27:08 - contact position so whenever the
27:10 - transform position changes then this
27:12 - whole return value will also change so
27:14 - then we need to be able to send that
27:16 - into our data system so we need to
27:20 - modify it to be able to receive a phone
27:22 - that receives this so over here on the
27:25 - try Italians are receiving the tag
27:27 - position let's receive a funk and that
27:30 - funk is also what we're going to pass
27:31 - into the Deadeye tag so let's go into
27:35 - Deadeye tags are receiving a straight
27:37 - position we receive a funk and do
27:39 - everything and on the that I tagged
27:42 - position we can simply return the return
27:44 - value of this phone
27:45 - so just like that since all of the other
27:48 - code already goes through this function
27:50 - then everything already works perfectly
27:52 - fine so in here we're trying to add a
27:54 - tag using that and we create a new tag
27:56 - object and the rest of the system works
27:58 - with that object so now we can go back
28:00 - into the player and deal with the other
28:02 - options so in here if the collider is
28:05 - known so if we click on nothing then we
28:07 - want to send the same target position as
28:10 - previously so we're going to send in a
28:11 - funk which won't always return the
28:13 - target position and the same thing up
28:15 - here in case we click on something but
28:17 - that's something does not have the
28:19 - Deadite angle then we send the same
28:22 - target position ok so we could click on
28:24 - something we send with a function that
28:26 - will always update whenever the
28:27 - transform changes and when we don't we
28:30 - simply send a fixed value ok so let's
28:32 - see if our tags are moving along with
28:34 - our enemies ok so here I am
28:36 - enemies are moving that enabled Deadeye
28:38 - and now I click in here and there you
28:39 - can see it's static now if I click on
28:41 - that one if there you it is accompanying
28:44 - the enemy and the same thing for the on
28:46 - same thing for that one I click on
28:47 - various positions and I can do it
28:49 - anymore now I click on e first shoot
28:51 - there there there and yep there we go he
28:53 - fired into every position again enable
28:56 - [ __ ] down one down one down and that one
28:58 - boom boom boom boom yep exactly so I can
29:01 - shoot into various empty positions and
29:03 - also with an object that goes on with
29:06 - that object and just like that so there
29:09 - you have it we created the deniability
29:11 - from Red Dead Redemption 2 as always you
29:13 - can download the project files and
29:14 - utilities from Unity code monkey comm if
29:16 - you have any questions post them in the
29:18 - comments and I'll do my best to answer
29:19 - them subscribe for more videos and I'll
29:21 - see you next time

Cleaned transcript:

hello and welcome I'm your code monkey in this video we're going to make the Deadeye ability from red redemption to let's begin okay so here's the scene I have prepared I have a player character I can move around and there are enemies being spawned and I can shoot my weapon and kill them once they get shot they fly away when they are dead okay so this is the base that we're going to use so over here is the player class it is very simple it simply deals with player movement and player shooting you can check out a detailed video on the player movement with the simple character movement video but it's still pretty simple so on the update I simply have a switch on state and right now there is only one state the normal state so on case normal we handle our movement so the function down here simply tests for the keyboard input on the WUSA and D Keys it creates a movement direction using those keys and moves the player accordingly then on the update we are also calling the Hamel aim shooting and this again it's only getting the target position which is the mouse world position it sets the aim target to that target position and when we press the left mouse button if we can fire then we fire and play the animation so that's a very simple setup for the player class over here on this scene I have a postprocessing effect to simulate the Deadeye effect I have setup on the values and now in order to use the effect on we need to do is modify the weight in here so if it is on zero it's come on with disable these are the normal colors and if I increase it up to one then gets the complete effect in order to set up the postprocessing we need is this postprocess volume in here and on the main camera we also have a postprocessing layer and using that layer and so on so again all we need to do is modify the weight to go from zero to one okay so let's begin by making a new C sharp script this will be the Dead Eye class this will handle the effects and the state of the Dead Eye in here let's make this a static function since we don't want to instantiate it so make it static and remove the amount of behavioral references this is going to be a very simple clean class so let's begin with a init function this won't receive the references that we're going to use so in it and in here first let's receive the post process volume that we're going to use to modify the weight so in order to do that we have to go using the Unity engine rendering that postprocessing so now in here we can receive a post processed volume and let's call it the black/white post processed phone it isn't black and white it's more of a sepia but that's a good name for it so in here let's store it so in this class we're going to have two functions want to start the data effect and want to end it so let's begin with a public static void start and then we're going to have a public static void and now in our start let's simply enable the effect so we can see it in action so we simply do the black/white closed process volume and set the weight to one and on the end let's set the weight back to zero okay so that's the effect now let's also make a public static ball is active to test if the effect is active okay so this is our very simple that I class it has everything we need to start testing so now let's go into the player class and up here after we test for the shooting and the movement let's make another function this one will be the handle that I so let's make in here private void handle that I and in here drink test for an input let's say Kiko D so when we press E and let's toggle D that I effect so let's check if that I if it is active then we do that I dot end if it is not active then we do that either start okay so by pressing E we should be able to toggle the data effect and now finally all we need is to go and take the game hammer so in here we have the code that is currently spawning the enemies so let's add another serialize field and here we're going to receive the post processing volume and we're going to initialize that I class and give it this reference okay so just like this we have everything to be able to test okay here's my character everything well it's normal I can shoot and I can kill enemies okay and now if i press e if there go the effect is active and if i press e again yep no it's a day one so enable disable okay great so instead of enabling and disabling the effect instantly and let's add a slight animation so here on let me add a private static void and I'm going to call this the animate black/white effect receive a float for the start float for the N and a float for the animation time so in here we want to increase or decrease the weight starting at start ending at end and taking animate time to do the animation so that's essentially a very simple loop function so let's do that in order to do it I'm going to use the function updater from the code Mach utilities which is always you can grab for free from unity code Maki calm so I go up here using code monkey Dada tones so now I can go down here and use a function updater this essentially lets me trigger an action on every update so this action here on betray run every update so in here we want to set the white white postprocess volume and modify the weight now let's use math F dot work we're going to start going to Evan end and then we need a time value so let's do clear a time which starts at zero and will end at one so in here let's increase it by unscaled out the time since we're also going to modify the normal time scale and we similarly divided by the animate time okay and finally the function of theater can receive an action which returns a boolean and if that bowline is true it destroys it so in here we'll return time bigger than one so essentially if time is very than 1 then the function updater won't destroy itself if not it won't keep running on every update okay so now we can go up here and on start we want to animate we want to start on zero F we want to end on one F and let's say between one second and and we do the same thing so we go from one to zero all right so let's also do the same thing to animate the time scale so in here make animates time scale effect and we're going to modify the time that time scale by that amount so the time scale if you don't know as you can see it is the scale at which the time is passing so essentially normal is that one F but if we want to do some slow motion effects we can simply reduce this value so in here when we activate let's put the game on slow motion at about 20% so we animate the time scale effect let's start that one up at normal time then we're going to slow it down to 20% and again do it over one second okay and here we start at point two and we end at one all right so we can tweak these values but it looks good for now so again what's test okay so here I am I can still move I can shoot enemies everything is fine now if I press E yep there you the effect is animated and after a while it is phone and the same thing for the time effect as you can see everything is on slow motion I can shoot them and everything works now if i press e yep everything goes back to normal after one second okay so we need to make the time scale animation a bit faster but everything else looks good okay so now that we have the officials working let's the only way the Dead Eye tags so essentially in here we want to add a bunch of positions and then we finally shoot towards all of those positions so in order to do that let's first go into the player and in here we want to add another state because we don't want them shooting once the data is active so let's have the state that I active so here let's rename this to handle that I activate and here we are simply going to enable and once we do we set this state to state that that I active okay so now I'm here on the update let's handle the other state so here let's make a function to handle the tag so handle dead i tagging and I mean here we want to capture onmousedown so if input dark yet mouse button down of the left mouse button so button zero and okay so let's grab the target position which is the vector three for the target position which we go into the Utah's class to get the mouse world position so that's the position that we want to tag so in order to do that we have to be able to add tags on the data so in here let's make another function a public static void try add tag and this will receive a vector three for deep tag position we're calling it try a tag so we have a limit so up here let's make a private constant for the tag amount Max and let's say a maximum of five tags then we're going to need a private static list of the vector 3 this will be the tag position listen so in here let's initialize the list and down here when we try to add a tag if the tag position only star count if it is less than the tag amount max then here we can add the tag so add the tag position to the tag position list so now we can go back into the player and here when we press a mouse button we can go into that I class and try to add a tag and this is the time so now we are successfully capturing all the various tag positions with a limit of five now we need the player to receive that list when the data actually ends so in order to do that we're going to modify the DAT I start class and in here we're going to receive an action which is on using system so we're going to receive an action and we're going to call it on that I end and that action will receive a list of vector threes an action is a function so in this case the start will be called with a function on the parameters and that function will receive a list of vector three as a parameter so in order to do that let's store this up here so now on the end after we do all the effects let's call this function using our tag list okay so now we can go back into the player and in here on start it expects a action that receives a list so in here let's make a private void on that I end and we're going to receive a list of vector3 this won't be the tag position lists and this function is what we're going to pass as an argument towards this function okay so essentially when this function is called we receive the tag position list which contains a list of all the positions that were tagged so in here all we need to do is shoot towards everything on one of them so I'm going to do a for and D equals zero going to cycle through the tag position list our count now in hearing at a vector3 for the tagged position so now I want to shoot this tag now obviously I don't want to shoot all the positions at the same time so I want there to be a little delay so in order to do that I'm going to use the function timer which again part of the code monkey utilities so this lets me easily trigger an action after some time so we're going to fire towards a tag using the same pistol fire rate that we use normally so in here let's trigger an action after fire rate multiplied by the index and here we simply do the same thing for the shoot target so we should this tag position after fire rate times I so essentially the first tag position will essentially fire instantly because it won't fire this action at fire rate times 0 which is 0 so it won't execute instantly then the second one won't fire towards the second tag position after if I write x 1 so the fire rate is at 200 milliseconds so it won't fire at the first act position and 200 milliseconds later it won't fire at the second and so on ok so the last thing we need is to actually deactivate the Deadeye to call that I dot n so let's go up here handle dead I end and here let's make a fresh void handle that I N and we're going to do essentially the same thing as in here except instead of start we're going to trigger the end and we're going to bring the state back to normal ok so let's see fun with this is correct ok so here I am walking around I can still shoot I can do everything and now for pricey give there go the effects arts and Sun slow motion now I can click on various positions so click here click here here and here knife repress key yep choochoochoo yep there you go he fired into all the positions exactly as we wanted so again what's going to that I and shoot down and down and now actually there won't be an issue so let's see if there you go he actually fired five or six shots so that's because we are not clearing the list and if you can also see we also have an issue with the animation which is we click here here then we are aiming in there and check out the weapon and there you go the weapon is not working in the correct position so essentially we want to still block the normal aiming and movement until the effect is completed but after that everything is fine okay so first you fix the animation so in here when we press to end the data we check if that I dot is active if it is active then we end it and that's it we don't modify the state instead we modify the state down here or we add another function timer after the fire rate dot count so after every tag position has been shot then we are going to execute an action and that action will set the state back to normal ok so this solves the animation issue now again on the dead eye in here on start we have to reset the attack position list so it's very simple just here dot clear this list ok so let's see if those issues have been sold okay here I am again walking around naming perfectly fine okay now if I press E yeah there you go slow motion everything now I shoot there there and there and click shoot shoot shoot yep there you go the animation of the pistol was correct now it's back to normal so again let's see if it no longer save the previous one so again back into that I I'm going to shoot in here and here and it should only fire two shots one two yep there you go okay great so the effect is pretty much working right now now the only thing we need obviously is to actually see where we are actually tagging so we need to be able to view all the tags that have already been created so let's do that so over here on the antenna class let's create a inner class to deal with each specific that I tagged so in here let's make a public class and let's call this that I tagged this won't represent a single time so in here let's make a constructor and we're going to receive a vector3 for the EPAct position and we're going to store it internally then I would simply have a public vector three to get the position which will return the tag position okay so now we have a nice object that is responsible for each tag so using that we can go up here and essentially clean up our code instead of having a list of tag positions we're going to have a list of data tag so let's rename this to that I tag list so down here when we are adding a tag instead of adding a tag position we're going to add a new that I tagged using this tag position okay and on that I end up here let's calculate a list of vector three for the tag position list since that is what we want to pass back to our player so make any own list and now cycle through all the dead I tanks okay so we have reworked the code to work with a specific that I tagged object but everything else should still be working the player is still receiving a list of vector three okay so now let's see on with making the UI visual so we're here on my canvas I'm going to create an empty game object and I'm going to name this the Deadeye UI and inside I'm going to add a UI image which won't contain the cross image that I have in here so let's just tint it in red and make it a good size okay so this is our cross now let's name this into the cross template this is the template that we're going to duplicate so let's make the script to handle the UI so in here let's make a new C sharp script D dead eye UI and inside we're going to have a function a public static void add tag and this will receive a debt I doubt that I tagged that I tank in order to use a static let's store our instance so private static that UI for the instance so here let's also grab a reference to the transform for the tag template transform so in here on let's section we rename this to add tag static which will do an instance add tag and here we have a private void add tag which will receive the same thing so in here the first thing we want to do is duplicate our template so now we have our duplicated tag transform and now we need to actually position it where it should be so essentially we need to convert our data tag position which is a worm position into a UI position so in here we have a vector3 for the tag world position which is the data tag that get position so this is the position in the world so we take that and we do a camera that main that worm to screen point so we convert that Worman position into a screen position so a vector3 for the screen point now we want to convert the screen point into the UI point so we grab a vector3 for the UI world point which will be the UI camera that's what we're going to need a reference to and do screen to world points of the screen point so here what's at a private camera for the UI camera since we need that reference so now we have the UI world points all we needs to convert into a local point so a vector3 for the UI point which will be the transform dot inverse transform point so we take a world space and put it into a local space so we do that using the work world point and then we simply set the tag transform the local position said welcome position to be at this UI point and since the UI is on a different Z then let's simply reset the Z ok so again the Deadeye tag contains a world position up here on the get position so we get the world position since the camera and the UI camera are different we need to convert the position between one and the other so we convert from a world position into a screen position based on what the main camera is seeing so that gives us a position within somewhere in our screen bounds so taking that screen position then we use the UI camera to convert the screen into a world point using the perspective of the UI camera and then using that one point we convert it into a local point on this transform and that's what we're going to place it okay so now we can go back into the Deadeye class and here when we are trying to add the tag we create a new that I tagged and after adding it to the list let's also go into the data IUI and we're going to add tag static and we're going to pass in this tag so we call this and then this one calls this function which insensate s' the tag transform and so on and so forth ok so let's see that in action ok here I am everything is normal now if I press E that is now active now if I click there you go there's the tag position now I click in here and here and yep it is spawning all of the correct positions in the correct point and as you can see they are limited to five tags now as you can also see the position is correct where I click but it is not accompanying when the camera actually moves so we need to update the position on every frame so let's do that so in here let's make an inner class to dealing with each specific UI object then here I'm going to have a constructor and in that constructor I'm going to receive a dead eye dot that I tagged and I'm also going to receive the transform so then let's make a public void update which will update the position of this that I tagged so essentially we're going to copy all of this code instead of running it just when it's in sentient we're going to run it every time ok so now up here when we are adding the time let's create a that I tagged UI object give it thee that I tagged the new only created tag transform so now essentially everything is working exactly the same as previously it is only being updated on start so we need to go up here and make a list we need a private list of that I tagged UI object and here we want to add this to the list and on the main UI we can now do a private void update since this is a mana behavior and in here we simply cycle through all the objects and we call that I object our update ok so on every update we are calling this update function which this update function is doing everything we did previously so it gets the tag position and it converts into world to UI point so let's see if all of our tags are updating their position okay so here I am going to enable that I okay and I'm going to click run on top of this bush and you up there we go if I move the camera you can see that the tag is always on the same position now I click on this one on this one and now I stopped and yep there you go he fired into all the positions ok great and as you can see they are still tracking but obviously Wendy that I is ended that cross should be destroyed so let's do that so here let's make a public static void destroy all times and here I'm going to cycle through all of the tags in my list and I'm going to tell the tag to destroy it so so now let's go down here and make a destroy cell function so all we need to do is to call the destroy into the transform game object and up here and let's also clear the list so clear the UI object list okay so now let's call this over here on the Deadeye when the Deadeye is over and here when it's false we going to then I you wan and call the destroy all tanks okay so let's see so enable that I tagged in here here and here and I'll click II and there you go he fired into all and all the tags are vanish okay great now there is still one thing that we need to do which is if I enable it and I click on this one right here you can see that the tag stays in the position where as in the game itself when you click on top of an enemy the tag actually follows that enemy so in this case if I click on an enemy and then he moves away then I wouldn't hit him so it's dealing with that so over here on the player class when we have that I active we are calling the Deadeye tagging and it's in here that we are adding new tanks so it's in here that we need to check if we are clicking on top of an enemy or not so in order to test that we can simply do physics 2d do an overlap point we're going to test on the target position this function returns a Collider 2d which is a Collider on this position so first thing we need to do is test that the collider is not known then we have actually clicked on something so if we have clicked on something that we want to check if that something is an enemy so in order to do that we can simply use a dummy component to tag our enemies so in here let's make a new C sharp script and call this dead I tagged alone this won't be just a completely empty motor behavior so I have here the enemy prefab which as you can see has a box Collider and then the enemy scripts and I'm simply going to drag this component onto it again it's a component empty component so now using that we can go back into our point class and over here if we do have a Collider we get the coiler that game object getcomponent dead i taggable so if that component if it is not known then that means this Collider the game object that this Collider is on also has that i taggable so we can assume that is our enemy so now that we know that we need to know the unlock composition that we have clicked so define a vector3 for the whole contact position so that position is on the collider that transform dot inverse transform point so this converts from world space into a local space and we want to do that using the target position so this will give us a local target position hello come to the enemy transform so if you click exactly on top of the enemy transform then this will be on 0 0 if we can look slightly above then this won't be someone like 0 1 so now all we need is to be able to add a tag that actually updates its position every time so we need essentially to create a fault which will return a vector 3 and this will be the tag position func which will essentially return the transform dot position + V on low contact position so whenever the transform position changes then this whole return value will also change so then we need to be able to send that into our data system so we need to modify it to be able to receive a phone that receives this so over here on the try Italians are receiving the tag position let's receive a funk and that funk is also what we're going to pass into the Deadeye tag so let's go into Deadeye tags are receiving a straight position we receive a funk and do everything and on the that I tagged position we can simply return the return value of this phone so just like that since all of the other code already goes through this function then everything already works perfectly fine so in here we're trying to add a tag using that and we create a new tag object and the rest of the system works with that object so now we can go back into the player and deal with the other options so in here if the collider is known so if we click on nothing then we want to send the same target position as previously so we're going to send in a funk which won't always return the target position and the same thing up here in case we click on something but that's something does not have the Deadite angle then we send the same target position ok so we could click on something we send with a function that will always update whenever the transform changes and when we don't we simply send a fixed value ok so let's see if our tags are moving along with our enemies ok so here I am enemies are moving that enabled Deadeye and now I click in here and there you can see it's static now if I click on that one if there you it is accompanying the enemy and the same thing for the on same thing for that one I click on various positions and I can do it anymore now I click on e first shoot there there there and yep there we go he fired into every position again enable [ __ ] down one down one down and that one boom boom boom boom yep exactly so I can shoot into various empty positions and also with an object that goes on with that object and just like that so there you have it we created the deniability from Red Dead Redemption 2 as always you can download the project files and utilities from Unity code monkey comm if you have any questions post them in the comments and I'll do my best to answer them subscribe for more videos and I'll see you next time
