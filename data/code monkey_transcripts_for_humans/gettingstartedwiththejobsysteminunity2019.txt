With timestamps:

00:00 - in this video we're going to learn how
00:01 - to get started working with the job
00:03 - system in unity 2019 we won't cover what
00:06 - our jobs how they are created and just
00:08 - how much performance we can get by using
00:09 - them let's begin
00:14 - [Music]
00:18 - hello and welcome I'm your code monkey
00:20 - and this channel is all about helping
00:21 - you learn how to make your own games
00:23 - with in-depth tutorials made by a
00:25 - professional indie game developer so if
00:27 - you find the video helpful consider
00:28 - subscribing okay so first of all the
00:30 - jump system is one of the pillars of the
00:32 - new unity dots tech stack if you want to
00:35 - learn more about dots check the link in
00:37 - the description for the video where I go
00:39 - over what it is how it works and what
00:41 - are the benefits
00:42 - essentially dots is composed of the
00:44 - c-sharp chopped system the burst
00:46 - compiler and the entity component system
00:48 - I've also done a video covering how to
00:50 - get served working with ecs so check
00:52 - that out after this video now the goal
00:55 - with the job system is to make it easier
00:57 - for you to write multi-threaded code as
00:59 - you know most processors nowadays have
01:01 - multiple cores this means that you can
01:03 - have several pieces of code working at
01:05 - the same time so for example if you have
01:08 - some pathfinding code using a single
01:10 - thread you would calculate the first
01:12 - path then the second and the third and
01:14 - so on whereas with multi-threaded code
01:16 - you can calculate multiple paths at the
01:18 - same time however multi-threaded code is
01:21 - also very tough to write and potentially
01:23 - very error-prone
01:24 - with many issues that are extremely
01:26 - difficult to debug so the Java system
01:28 - handles all of the behind-the-scenes
01:30 - stuff like creating and managing threads
01:32 - and all you need to do is create jobs
01:34 - and schedule them so let's get started
01:36 - playing with the job system first you
01:38 - need to be using unity 2019 and then in
01:41 - here you go into window and open the
01:43 - package manager as of this recording
01:45 - some packages are still in preview so go
01:48 - to advanced and enable show preview
01:50 - packages here are all the packages and
01:53 - for the c-sharp java system you have in
01:56 - here the jobs package also related to it
01:58 - is the mathematics package this is a
02:01 - math library specific with performance
02:03 - in mind and also up here you have the
02:06 - first compiler which works very closely
02:07 - with the job system and we're going to
02:09 - test it out in the end also related is
02:12 - the collections package which allows us
02:14 - to use native collections like for
02:16 - example native listen a VAR a which
02:18 - we're going to use in order to enable
02:19 - parallel jumps and the other package
02:22 - related to dots is the entity component
02:24 - system which is right here on the
02:26 - entities package but in here and let's
02:28 - keep things simple and the own
02:30 - he jumps alright so that's it for our
02:33 - package setup now let's get writing some
02:35 - code
02:36 - so first let's make a simple script
02:38 - around our code so a new c-sharp script
02:40 - this will be our testing let's make a
02:42 - game object to add our script testing
02:46 - and just drag our script okay okay now
02:49 - in here let's first make a private void
02:52 - update for our testing so in here right
02:55 - boy update and for service let's just
02:58 - write a simple function that won't take
03:00 - some time to compute so in here make a
03:02 - prep boy let's call this a really tough
03:05 - task so this represents a tough task
03:11 - like for example some pathfinding in
03:13 - here and let's just do some code that
03:14 - won't take some time to execute okay so
03:23 - what we're doing is running a certain
03:25 - calculation 50,000 times this will
03:27 - ensure that this test takes enough time
03:29 - so we can analyze our code speed and
03:31 - also this is the math library which
03:33 - again is inside using that unity dot
03:36 - mathematics now here on the update let's
03:38 - call this function and let's test how
03:42 - long this function won't take to execute
03:46 - three time dog real time since startup
03:48 - holds e number of seconds since the
03:50 - start of the game so we do that and then
03:53 - we calculate it afterwards so here we do
04:00 - the time minus the start time multiplied
04:02 - by a thousand so we get in milliseconds
04:04 - so we should be able to see how long
04:06 - this task won't take to execute let's
04:08 - see okay here we are and here in our
04:10 - console we can see that it's taking
04:11 - around six point six milliseconds all
04:13 - right so now that we have our symbol
04:16 - testing code and let's convert this into
04:17 - a jump now in order to make a job we
04:20 - need to make a struct struct are
04:25 - different from classes in several ways
04:26 - and the main thing is how a struct is a
04:29 - value type where as a class is a
04:31 - reference type that means that when
04:33 - working with structs we are working with
04:35 - a copy rather than a reference so we
04:37 - have our struct and in order to make it
04:39 - a job we implement
04:41 - the eye job interface which is up here
04:43 - on the using unity jobs okay here we
04:48 - need to implement the execute function
04:51 - and now inside this function we have the
04:56 - code that will be executed by the jump
04:57 - so in this case let's just copy our
04:59 - really tough task and in here you can
05:04 - add whatever fields that job requires so
05:06 - for example if we required a public
05:08 - float for something we would add it in
05:11 - here
05:11 - but in this case we don't need any extra
05:13 - fields okay so now that we have our job
05:16 - defined we need to create and schedule
05:18 - it so we go up here let's make a
05:21 - function that won't do the same but as a
05:23 - job so a prep boy call it's really tough
05:26 - task job and in here we create a new
05:33 - really tough job then we have our job
05:39 - instance and in here we just need to go
05:42 - into job and call schedule this tells
05:45 - the job system to schedule this job to
05:47 - be completed by an available thread when
05:49 - possible then this function returns a
05:51 - job handle which is very important to
05:53 - keep track so let's return the jump
05:55 - handle from this function return a job
05:58 - Hemmer okay so we're doing is creating a
06:01 - new job which is a struct and we
06:03 - schedule it on the job system now in
06:05 - order to execute our job let's go here
06:08 - on our update we call the really tough
06:10 - task job which returns a job handle and
06:18 - then in order to tell the job system to
06:20 - complete our job we call job handle dot
06:23 - complete calling this essentially pauses
06:27 - the main thread until the job has been
06:29 - completed and then the main thread
06:30 - continues okay so that's it for making a
06:33 - very simple job you define a struct that
06:35 - contains all the information and the
06:37 - behavior for the job then you create an
06:40 - instance of that struct you schedule the
06:42 - job on the job system and then you tell
06:45 - the job system to complete that
06:46 - particular job so let's see what
06:48 - benefits we get with this function
06:50 - compared to this function so let's had a
06:52 - really easy way of testing both method
06:54 - up here let's add a Syrah nice feel for
06:58 - a private ball use jobs then here we do
07:04 - an if if we want to use jobs then let's
07:07 - do this and if not let's do the normal
07:11 - function all right that should do it
07:14 - let's test okay so here we are and
07:17 - there's our boolean film as you can see
07:18 - we are not using jobs right now and it's
07:20 - not taking the same six point six to
07:22 - seven milliseconds yeah now if we enable
07:25 - jobs and there you go not much really
07:27 - change now the reason for that is
07:29 - because the whole point of
07:31 - multi-threaded code is to do multiple
07:32 - things at once here all we're doing is
07:35 - just a single task so we're waiting for
07:36 - it to be completed on a separate thread
07:38 - so that has gonna take the same amount
07:40 - of time whether it's on the secondary
07:42 - trial or on the main thread so let's do
07:44 - a more appropriate test to see the
07:45 - actual benefits from jobs so this
07:48 - function is meant to represent something
07:49 - really tough like for example some path
07:51 - finding so up here instead of calling it
07:53 - just once let's assume we are
07:54 - calculating the path for 10 different
07:56 - units so in here on our normal code
07:59 - let's just do a 4 so here we are
08:03 - pretending that we are calculating some
08:04 - path finding for 10 different units and
08:06 - let's also do the same thing on our job
08:10 - however in here we need to make sure
08:12 - that first we create all the jobs and
08:14 - only then we tell them to complete
08:16 - otherwise we will be creating a job and
08:18 - then waiting for it to complete before
08:19 - doing the next one and so on so
08:20 - essentially this would be single thread
08:22 - so what we need to do is first define
08:24 - all of them and then complete ulta so in
08:27 - order to do that let's make a collection
08:28 - to hold all of our job handles so in
08:31 - here we do using unity dot collections
08:34 - this allows us to go down here and use a
08:37 - native list let's make a list of job
08:40 - handles in here for our native list we
08:46 - have to pass in the allocator
08:47 - essentially we're telling what we're
08:49 - going to use this list for in this case
08:51 - we're only going to use it to set up our
08:53 - jobs so we can use temp now in here we
08:57 - create our job we get the job handle
08:58 - then we add it to our list so job list
09:01 - and we add our job Himmel
09:03 - and then we don't come complete here but
09:05 - rather out here we go into
09:07 - the job Hemel to call the static
09:09 - function complete all and we passing the
09:11 - list of all of our jobs so the job hand
09:13 - on list so this does the job system to
09:17 - complete all the jobs on this list and
09:19 - when they are done we go back in here
09:21 - onto the main thread and I mean here
09:23 - when using native arrays or native lists
09:25 - we need to make sure to dispose of them
09:27 - so after this we do Chavan a list and we
09:30 - call dispose all right so now we have
09:33 - set up a more appropriate test we're
09:36 - doing multiple tough tasks in the same
09:37 - frame so in the normal way we simply run
09:40 - this function ten times so one after the
09:42 - other and in this way we create ten jobs
09:45 - and then we tell all those jobs to be
09:46 - completed okay let's see the results so
09:49 - here we are and we are now doing ten
09:51 - tasks so as you can see instead of
09:53 - taking six milliseconds we are taking 67
09:55 - okay now if I enable jobs and there you
09:59 - go all of a sudden it's taking 15
10:00 - instead of 65 milliseconds so right
10:03 - there you can already see a pretty
10:05 - massive performance boost we can open up
10:07 - the profiler to see exactly what is
10:09 - going on so go into window analysis and
10:11 - open the profile here is our profile
10:14 - let's see what is going on without jobs
10:16 - so disabled jobs and as you can see
10:18 - that's how much more other it is taking
10:20 - so let's pause and look at our frame
10:21 - here we have our main thread as you can
10:24 - see it is taking 70 milliseconds on our
10:26 - testing that update and if you open up
10:28 - the jobs you can see that they are all
10:31 - just idle now let's resume and enable
10:34 - jobs and there you go as you can see it
10:37 - went all the way down and now we can
10:38 - stop and inspect one frame and there you
10:41 - can already see that it's occupying much
10:43 - less time only 15 milliseconds and here
10:46 - you can see all the jobs in how are they
10:47 - being assigned you can see each of them
10:49 - is doing its own task and you can see
10:52 - that several of them are being done at
10:53 - the same time how many worker threads
10:56 - unity creates won't depend on your CPU
10:58 - in my case I have an InTown 6700 K which
11:02 - has 18 logic course so in here you can
11:04 - see 6 threads plus whatever else unity
11:06 - needs so just like this you can already
11:09 - see a pre massive performance boost
11:10 - however there's still another thing
11:13 - which provides another huge boost pretty
11:15 - much for free so let's go back to our
11:17 - code and in here we want to use the
11:20 - burst
11:21 - now in order to do that it's extremely
11:23 - simple which you go here using unity
11:25 - burst and then all we need to go is to
11:29 - our job definition right here and before
11:32 - it we add the attribute burst compound
11:35 - and that's it that's only takes in order
11:38 - to enable burst compound on this job so
11:41 - let's see our code so here we are back
11:43 - on the normal code as you can see taking
11:45 - 67 milliseconds
11:46 - now we enable jobs and there you oh now
11:49 - it's taking 15 milliseconds and now for
11:51 - the last one we go in here into jumps
11:53 - burst and enable and let's see how much
11:55 - it goes down and there you go it goes
11:57 - down from 15 milliseconds down 2.0 3
12:00 - milliseconds so as you can see that's a
12:02 - massive performance boost by just taking
12:04 - a box obviously how much of a boost you
12:07 - get will depend on what exactly you're
12:09 - doing but as you can see for
12:10 - mathematical functions this is insanely
12:12 - fast alright so this clearly shows you
12:15 - the massive performance you can get by
12:17 - using jobs to run your code in many
12:19 - threads so now that we have covered the
12:21 - basics of our job system let's see what
12:23 - other interfaces we have so what if the
12:26 - interface is a simple I job and then you
12:29 - also have the I job parallel for this is
12:33 - meant when you have a job that you want
12:34 - to execute on elements inside a list so
12:37 - let's create a simple test we're going
12:39 - to create a bunch of units put them in a
12:41 - list and didn't do a job that runs on
12:43 - elements of that list so let's do that
12:51 - so we're going to instantiate a bunch of
12:54 - zombies and put them on that list we're
12:56 - using this class in order to hold our
12:58 - transform and a move Y speed let's
13:00 - create them
13:17 - okay so here we have some code running a
13:20 - thousand times so we're going to
13:22 - instantiate a thousand zombies put them
13:24 - on a random position and then we add
13:26 - them to the list containing a reference
13:27 - to the transform and a random value for
13:29 - the move Y speed so since we're using a
13:32 - serialize film let's go into the editor
13:34 - and here just drag our prefab and here
13:37 - as you can see the prefab it's extremely
13:38 - simple we just have a simple sprite
13:40 - render so let's run the code and see if
13:42 - all of them are being spawned and if
13:44 - there they are we have a thousand
13:45 - zombies being spun okay now we want to
13:48 - make some code in order to move them up
13:49 - and down so let's see back here in our
13:52 - script let's go into the update and for
13:54 - now let's comment out our previous test
13:57 - and here first let's do it the normal
14:01 - way without using jobs so we cycle
14:04 - through all the zombies and here we want
14:08 - to move the transform based on the move
14:10 - Y then if you get to the top of the
14:16 - screen wanting to move down and if the
14:18 - bottom we want them to move up
14:26 - okay so when we reach atop the screen we
14:29 - set it to negative when we reach the
14:30 - bottom set it to positive okay so we
14:32 - should be able to see the zombies going
14:33 - up and down alright so this is some
14:36 - really simple movement code now in order
14:38 - to test our code speed let's also add
14:40 - our really tough tasks in order to make
14:41 - sure that this symbol function takes
14:43 - some time to compete okay so this is our
14:48 - test let's try it out any up here we
14:51 - have our thousand zombies moving up and
14:53 - down and as you can see it is taking
14:54 - around 140 milliseconds per frame all
14:58 - right so now let's see how we can do
14:59 - this much more efficiently using
15:01 - parallel jobs so here in our code let's
15:04 - make a different job so we create a new
15:07 - struct so a public struck and in here
15:11 - instead of implementing a job we
15:13 - implement I job parallel four so here is
15:17 - the definition as you can see we have
15:19 - our execute function that also receives
15:21 - an index so now let's implement that so
15:26 - here we have our same execute function
15:28 - and essentially each time this function
15:30 - is called it will be called on a
15:32 - different index so now let's copy all of
15:34 - our code down there
15:35 - okay copy this now in here you can
15:40 - obviously already own these errors
15:42 - essentially we need to pass in the data
15:44 - that the job will need to execute and
15:46 - since jobs don't work on the main thread
15:48 - we cannot use the transforms directly so
15:51 - it's here that we need to think of
15:53 - exactly what data are we modifying and
15:55 - the answer is we are modifying a
15:56 - position and a move 1 so we go up here
16:00 - and make a public quote for our move
16:03 - line and then we create a public float 3
16:07 - for our position now the flow 3 is from
16:12 - the super efficient mathematics class
16:13 - which is pretty much just a vector 3
16:15 - here you can inspect the definition and
16:18 - as you can see we have an X a Y and a Z
16:20 - ok so let's use these two variables in
16:23 - our code so here we are using the
16:29 - position and the move line however
16:31 - remember that this is a parallel job the
16:33 - goal is for this job to run on a list of
16:36 - items that is why we have our index in
16:38 - here so instead of receive
16:40 - a single position and a single move why
16:42 - we want to get an array so in here we
16:45 - received a native array of flow three
16:47 - this will be our position all right and
16:50 - also a negative array of floats for our
16:52 - move wine array and now here in the
16:56 - execute we can use our index and just
17:02 - like that so every time these execute
17:04 - with the different index we're going to
17:06 - modify a different position and our
17:07 - array now one more issue that we have in
17:10 - here is you have to remember that jobs
17:12 - do not get run on the main thread so
17:14 - that means we cannot access in or only
17:16 - entity component so in here we cannot
17:18 - access time down to time inside this job
17:20 - that means we have to pass it in when we
17:23 - create the job so in here we make it
17:25 - only code for the down time and this is
17:28 - the one that we're going to use okay so
17:30 - this is our simple parallel job created
17:33 - now we need to create scheduled and
17:35 - completed so let's go up here into our
17:37 - update and first let's do the same thing
17:40 - using an if in order to run our Java
17:42 - bytecode or normal code and now here
17:48 - let's first create our job
17:50 - and here we fill in our job values so
17:53 - for example the Delta time since this
17:55 - code is being run on the main thread in
17:57 - here we passing the time down the time
17:59 - and then we need to pass in the position
18:01 - array so let's create it up here so we
18:10 - are creating a position array in the
18:12 - move array using a native array and on
18:14 - the applicator we're using temp job
18:15 - since we're going to be using these
18:17 - inside a job and now obviously since we
18:20 - are instantiating an array it is
18:21 - completely empty so we need to fill it
18:24 - up with our current data
18:29 - so we cycle through all of our zombies
18:32 - and we pass in the position array with
18:34 - our transform position and move white
18:35 - with our move one so now with those
18:37 - arrays being filmed we can now pass them
18:39 - into our job and just like that our job
18:43 - now has all of its fields so we can now
18:45 - go into the really tough parallel job
18:47 - and call our schedule now in here you
18:50 - can see we need to pass in our array
18:52 - length which in this case it's our
18:54 - zombie let's not count and then we also
18:57 - need to know the size of each job badge
18:59 - so this value is going to depend a lot
19:01 - on what you're trying to do essentially
19:03 - this is how many indexes each job won't
19:06 - be responsible for so in our case we're
19:08 - trying to run our job on a thousand
19:10 - zombies so let's end each job to handle
19:12 - a hundred ok so just like our normal job
19:15 - this returns a job handle so we have our
19:21 - job handle and just like the normal job
19:23 - we can't dot complete so this won't
19:26 - pause the main thread until our parallel
19:28 - jobs has been completed and that's it
19:31 - for our jump we create our arrays we
19:34 - fill it up with whatever variables we
19:36 - need we create a job instance we
19:39 - schedule our job and we tell it to
19:40 - complete now since we are executing our
19:43 - job on a duplicate piece of data that
19:45 - means that after the work has been done
19:47 - we need to update our original values so
19:51 - we do another cycle so after the
19:58 - families have been calculated we update
20:00 - them on our original transform and the
20:02 - original move one now if you are using
20:04 - this sort of code in a specific part of
20:07 - your game you would just create these
20:09 - native arrays once and then use them
20:11 - every time instead of in Senshi ating a
20:12 - new one every time however for this
20:14 - simple example let's stick with this
20:16 - simple approach so we create our
20:19 - temporary arrays and then we update our
20:20 - original values now again since these
20:23 - are native arrays we need to make sure
20:25 - to dispose of them so in here we call
20:27 - the position array call these foes and
20:29 - same thing on the move one all right
20:33 - that should do it
20:34 - so here we have our normal code and here
20:36 - we have our Java byte code it's not that
20:39 - we've done all of this now we can
20:40 - finally view all of our
20:42 - okay so here we are with our thousand
20:45 - zombies just moving around and as you
20:46 - can see 140 milliseconds now let's
20:49 - enable jobs and there you go it goes
20:52 - from 140 milliseconds to just 40
20:54 - milliseconds so if we disable jobs our
20:57 - scene is running at 7 frames per second
20:59 - enable jobs and our scene is running at
21:03 - 25 frames per second so just like that
21:06 - you can see a massive performance boost
21:08 - on moving a thousand entities
21:09 - independent from one another so again
21:12 - like we didn't let's look at the profile
21:14 - so here we have running our code without
21:16 - the job system let's inspect one and as
21:19 - you can see we have just our testing
21:21 - that update and all of our worker
21:22 - threads are completely I don't and now
21:24 - lets enable jobs and here is you can see
21:27 - we have our jobs being invoked on our
21:29 - multiple threads so you can already see
21:32 - some massive performance boost now again
21:34 - let's check out the magical burst
21:36 - compound in order to enable it it's very
21:38 - simple we just need to add our attribute
21:41 - to our job so here we have our scene
21:44 - running our normal code we're taking 140
21:46 - milliseconds okay now enable jobs and
21:49 - there you go go down to 140 down to 40
21:52 - milliseconds per frame and now enable
21:54 - the first compound let's go here burst
21:56 - enable and let's see goes from 40 and
21:58 - here you go down to 4 milliseconds so
22:02 - without jobs 140 milliseconds with jobs
22:06 - plus the burst compiler and it's 4
22:08 - milliseconds so just like that you can
22:10 - see the insane improvements you can get
22:12 - from the job system and the burst
22:13 - component now one last thing let's look
22:16 - at parallel jobs specifically for
22:17 - transforms so for that first we go up
22:20 - here and make sure that we are using
22:22 - Unity engine jobs and now we can go down
22:27 - here to make another job our public
22:29 - struct and in here we can implement I
22:33 - job parallel for transform this is a
22:37 - specific parallel job that works on
22:39 - transforms here as you can see we got
22:44 - our execute function which receives an
22:46 - index and also a transform access and
22:48 - the transform axis essentially
22:50 - duplicates a transform but it does so in
22:53 - such a way that we can use it inside our
22:55 - it's now in here and let's do our code
22:58 - the same as on this job except now we no
23:09 - longer need the position right instead
23:12 - we modify this transform directly and
23:18 - now let's see how we create this new
23:20 - type of job in here instead of having
23:23 - this job let's comment this out and here
23:32 - you can see that this function on
23:34 - schedule we require our transform axis
23:36 - right so we need to film that up so
23:46 - instead of using our original position
23:48 - array we are using a transform axis
23:50 - array and filling it up with our
23:52 - references we schedule it using this
23:54 - transform axis array and after a job
24:03 - completes again the transform is
24:05 - automatically updated so we no longer
24:07 - need the position we just need to update
24:08 - our move one all right so that's it as
24:13 - you can see this is a very specific job
24:14 - for working with normal transforms and
24:18 - finally we need to go into the transform
24:20 - access array and call this pose let's
24:23 - also add the birth compound attribute to
24:25 - make it insanely fast ok let's see so
24:28 - again here we have our normal code
24:30 - everything some words the same 140
24:32 - enable jobs and sound 240 and enable
24:36 - jobs plus the birth compound and we go
24:38 - down to 4 and everything works perfectly
24:40 - fine and we can look at the profiler
24:43 - here we are on the profiler and as you
24:45 - can see our code is running extremely
24:47 - fast the whole thing in just 1 point 3 6
24:49 - milliseconds everything else is the
24:51 - editor loop and you can see here all the
24:54 - workers and all of them doing all of
24:56 - that transform work in here as you can
24:59 - see we have 16 instances and each of
25:02 - them is taking point 0 to 1 milliseconds
25:05 - so in this video we just covered the C
25:08 - sharp job system
25:09 - you can get even more performance by
25:11 - combining the entire dot stack so the
25:13 - job system with the burst compiler
25:15 - working with the entity component system
25:17 - with all of them put together you can
25:19 - get hundreds of thousands of units on
25:20 - screen so make sure you subscribe the
25:23 - channel for upcoming
25:24 - ECS tutorials using the complete dot
25:26 - stack with the job system and the first
25:28 - compound just to see how much
25:29 - performance we can squeeze out of this
25:31 - new awesome tech stack I hope this video
25:34 - helped you understand how to get started
25:35 - making jobs and the massive performance
25:37 - boost you can enjoy as always you can
25:39 - download the project files and utilities
25:41 - from unity code monkey comm if you liked
25:43 - the video subscribe the channel for more
25:44 - unity two terms post any questions you
25:46 - have in the comments and I'll do my best
25:48 - answer alright see you next time

Cleaned transcript:

in this video we're going to learn how to get started working with the job system in unity 2019 we won't cover what our jobs how they are created and just how much performance we can get by using them let's begin hello and welcome I'm your code monkey and this channel is all about helping you learn how to make your own games with indepth tutorials made by a professional indie game developer so if you find the video helpful consider subscribing okay so first of all the jump system is one of the pillars of the new unity dots tech stack if you want to learn more about dots check the link in the description for the video where I go over what it is how it works and what are the benefits essentially dots is composed of the csharp chopped system the burst compiler and the entity component system I've also done a video covering how to get served working with ecs so check that out after this video now the goal with the job system is to make it easier for you to write multithreaded code as you know most processors nowadays have multiple cores this means that you can have several pieces of code working at the same time so for example if you have some pathfinding code using a single thread you would calculate the first path then the second and the third and so on whereas with multithreaded code you can calculate multiple paths at the same time however multithreaded code is also very tough to write and potentially very errorprone with many issues that are extremely difficult to debug so the Java system handles all of the behindthescenes stuff like creating and managing threads and all you need to do is create jobs and schedule them so let's get started playing with the job system first you need to be using unity 2019 and then in here you go into window and open the package manager as of this recording some packages are still in preview so go to advanced and enable show preview packages here are all the packages and for the csharp java system you have in here the jobs package also related to it is the mathematics package this is a math library specific with performance in mind and also up here you have the first compiler which works very closely with the job system and we're going to test it out in the end also related is the collections package which allows us to use native collections like for example native listen a VAR a which we're going to use in order to enable parallel jumps and the other package related to dots is the entity component system which is right here on the entities package but in here and let's keep things simple and the own he jumps alright so that's it for our package setup now let's get writing some code so first let's make a simple script around our code so a new csharp script this will be our testing let's make a game object to add our script testing and just drag our script okay okay now in here let's first make a private void update for our testing so in here right boy update and for service let's just write a simple function that won't take some time to compute so in here make a prep boy let's call this a really tough task so this represents a tough task like for example some pathfinding in here and let's just do some code that won't take some time to execute okay so what we're doing is running a certain calculation 50,000 times this will ensure that this test takes enough time so we can analyze our code speed and also this is the math library which again is inside using that unity dot mathematics now here on the update let's call this function and let's test how long this function won't take to execute three time dog real time since startup holds e number of seconds since the start of the game so we do that and then we calculate it afterwards so here we do the time minus the start time multiplied by a thousand so we get in milliseconds so we should be able to see how long this task won't take to execute let's see okay here we are and here in our console we can see that it's taking around six point six milliseconds all right so now that we have our symbol testing code and let's convert this into a jump now in order to make a job we need to make a struct struct are different from classes in several ways and the main thing is how a struct is a value type where as a class is a reference type that means that when working with structs we are working with a copy rather than a reference so we have our struct and in order to make it a job we implement the eye job interface which is up here on the using unity jobs okay here we need to implement the execute function and now inside this function we have the code that will be executed by the jump so in this case let's just copy our really tough task and in here you can add whatever fields that job requires so for example if we required a public float for something we would add it in here but in this case we don't need any extra fields okay so now that we have our job defined we need to create and schedule it so we go up here let's make a function that won't do the same but as a job so a prep boy call it's really tough task job and in here we create a new really tough job then we have our job instance and in here we just need to go into job and call schedule this tells the job system to schedule this job to be completed by an available thread when possible then this function returns a job handle which is very important to keep track so let's return the jump handle from this function return a job Hemmer okay so we're doing is creating a new job which is a struct and we schedule it on the job system now in order to execute our job let's go here on our update we call the really tough task job which returns a job handle and then in order to tell the job system to complete our job we call job handle dot complete calling this essentially pauses the main thread until the job has been completed and then the main thread continues okay so that's it for making a very simple job you define a struct that contains all the information and the behavior for the job then you create an instance of that struct you schedule the job on the job system and then you tell the job system to complete that particular job so let's see what benefits we get with this function compared to this function so let's had a really easy way of testing both method up here let's add a Syrah nice feel for a private ball use jobs then here we do an if if we want to use jobs then let's do this and if not let's do the normal function all right that should do it let's test okay so here we are and there's our boolean film as you can see we are not using jobs right now and it's not taking the same six point six to seven milliseconds yeah now if we enable jobs and there you go not much really change now the reason for that is because the whole point of multithreaded code is to do multiple things at once here all we're doing is just a single task so we're waiting for it to be completed on a separate thread so that has gonna take the same amount of time whether it's on the secondary trial or on the main thread so let's do a more appropriate test to see the actual benefits from jobs so this function is meant to represent something really tough like for example some path finding so up here instead of calling it just once let's assume we are calculating the path for 10 different units so in here on our normal code let's just do a 4 so here we are pretending that we are calculating some path finding for 10 different units and let's also do the same thing on our job however in here we need to make sure that first we create all the jobs and only then we tell them to complete otherwise we will be creating a job and then waiting for it to complete before doing the next one and so on so essentially this would be single thread so what we need to do is first define all of them and then complete ulta so in order to do that let's make a collection to hold all of our job handles so in here we do using unity dot collections this allows us to go down here and use a native list let's make a list of job handles in here for our native list we have to pass in the allocator essentially we're telling what we're going to use this list for in this case we're only going to use it to set up our jobs so we can use temp now in here we create our job we get the job handle then we add it to our list so job list and we add our job Himmel and then we don't come complete here but rather out here we go into the job Hemel to call the static function complete all and we passing the list of all of our jobs so the job hand on list so this does the job system to complete all the jobs on this list and when they are done we go back in here onto the main thread and I mean here when using native arrays or native lists we need to make sure to dispose of them so after this we do Chavan a list and we call dispose all right so now we have set up a more appropriate test we're doing multiple tough tasks in the same frame so in the normal way we simply run this function ten times so one after the other and in this way we create ten jobs and then we tell all those jobs to be completed okay let's see the results so here we are and we are now doing ten tasks so as you can see instead of taking six milliseconds we are taking 67 okay now if I enable jobs and there you go all of a sudden it's taking 15 instead of 65 milliseconds so right there you can already see a pretty massive performance boost we can open up the profiler to see exactly what is going on so go into window analysis and open the profile here is our profile let's see what is going on without jobs so disabled jobs and as you can see that's how much more other it is taking so let's pause and look at our frame here we have our main thread as you can see it is taking 70 milliseconds on our testing that update and if you open up the jobs you can see that they are all just idle now let's resume and enable jobs and there you go as you can see it went all the way down and now we can stop and inspect one frame and there you can already see that it's occupying much less time only 15 milliseconds and here you can see all the jobs in how are they being assigned you can see each of them is doing its own task and you can see that several of them are being done at the same time how many worker threads unity creates won't depend on your CPU in my case I have an InTown 6700 K which has 18 logic course so in here you can see 6 threads plus whatever else unity needs so just like this you can already see a pre massive performance boost however there's still another thing which provides another huge boost pretty much for free so let's go back to our code and in here we want to use the burst now in order to do that it's extremely simple which you go here using unity burst and then all we need to go is to our job definition right here and before it we add the attribute burst compound and that's it that's only takes in order to enable burst compound on this job so let's see our code so here we are back on the normal code as you can see taking 67 milliseconds now we enable jobs and there you oh now it's taking 15 milliseconds and now for the last one we go in here into jumps burst and enable and let's see how much it goes down and there you go it goes down from 15 milliseconds down 2.0 3 milliseconds so as you can see that's a massive performance boost by just taking a box obviously how much of a boost you get will depend on what exactly you're doing but as you can see for mathematical functions this is insanely fast alright so this clearly shows you the massive performance you can get by using jobs to run your code in many threads so now that we have covered the basics of our job system let's see what other interfaces we have so what if the interface is a simple I job and then you also have the I job parallel for this is meant when you have a job that you want to execute on elements inside a list so let's create a simple test we're going to create a bunch of units put them in a list and didn't do a job that runs on elements of that list so let's do that so we're going to instantiate a bunch of zombies and put them on that list we're using this class in order to hold our transform and a move Y speed let's create them okay so here we have some code running a thousand times so we're going to instantiate a thousand zombies put them on a random position and then we add them to the list containing a reference to the transform and a random value for the move Y speed so since we're using a serialize film let's go into the editor and here just drag our prefab and here as you can see the prefab it's extremely simple we just have a simple sprite render so let's run the code and see if all of them are being spawned and if there they are we have a thousand zombies being spun okay now we want to make some code in order to move them up and down so let's see back here in our script let's go into the update and for now let's comment out our previous test and here first let's do it the normal way without using jobs so we cycle through all the zombies and here we want to move the transform based on the move Y then if you get to the top of the screen wanting to move down and if the bottom we want them to move up okay so when we reach atop the screen we set it to negative when we reach the bottom set it to positive okay so we should be able to see the zombies going up and down alright so this is some really simple movement code now in order to test our code speed let's also add our really tough tasks in order to make sure that this symbol function takes some time to compete okay so this is our test let's try it out any up here we have our thousand zombies moving up and down and as you can see it is taking around 140 milliseconds per frame all right so now let's see how we can do this much more efficiently using parallel jobs so here in our code let's make a different job so we create a new struct so a public struck and in here instead of implementing a job we implement I job parallel four so here is the definition as you can see we have our execute function that also receives an index so now let's implement that so here we have our same execute function and essentially each time this function is called it will be called on a different index so now let's copy all of our code down there okay copy this now in here you can obviously already own these errors essentially we need to pass in the data that the job will need to execute and since jobs don't work on the main thread we cannot use the transforms directly so it's here that we need to think of exactly what data are we modifying and the answer is we are modifying a position and a move 1 so we go up here and make a public quote for our move line and then we create a public float 3 for our position now the flow 3 is from the super efficient mathematics class which is pretty much just a vector 3 here you can inspect the definition and as you can see we have an X a Y and a Z ok so let's use these two variables in our code so here we are using the position and the move line however remember that this is a parallel job the goal is for this job to run on a list of items that is why we have our index in here so instead of receive a single position and a single move why we want to get an array so in here we received a native array of flow three this will be our position all right and also a negative array of floats for our move wine array and now here in the execute we can use our index and just like that so every time these execute with the different index we're going to modify a different position and our array now one more issue that we have in here is you have to remember that jobs do not get run on the main thread so that means we cannot access in or only entity component so in here we cannot access time down to time inside this job that means we have to pass it in when we create the job so in here we make it only code for the down time and this is the one that we're going to use okay so this is our simple parallel job created now we need to create scheduled and completed so let's go up here into our update and first let's do the same thing using an if in order to run our Java bytecode or normal code and now here let's first create our job and here we fill in our job values so for example the Delta time since this code is being run on the main thread in here we passing the time down the time and then we need to pass in the position array so let's create it up here so we are creating a position array in the move array using a native array and on the applicator we're using temp job since we're going to be using these inside a job and now obviously since we are instantiating an array it is completely empty so we need to fill it up with our current data so we cycle through all of our zombies and we pass in the position array with our transform position and move white with our move one so now with those arrays being filmed we can now pass them into our job and just like that our job now has all of its fields so we can now go into the really tough parallel job and call our schedule now in here you can see we need to pass in our array length which in this case it's our zombie let's not count and then we also need to know the size of each job badge so this value is going to depend a lot on what you're trying to do essentially this is how many indexes each job won't be responsible for so in our case we're trying to run our job on a thousand zombies so let's end each job to handle a hundred ok so just like our normal job this returns a job handle so we have our job handle and just like the normal job we can't dot complete so this won't pause the main thread until our parallel jobs has been completed and that's it for our jump we create our arrays we fill it up with whatever variables we need we create a job instance we schedule our job and we tell it to complete now since we are executing our job on a duplicate piece of data that means that after the work has been done we need to update our original values so we do another cycle so after the families have been calculated we update them on our original transform and the original move one now if you are using this sort of code in a specific part of your game you would just create these native arrays once and then use them every time instead of in Senshi ating a new one every time however for this simple example let's stick with this simple approach so we create our temporary arrays and then we update our original values now again since these are native arrays we need to make sure to dispose of them so in here we call the position array call these foes and same thing on the move one all right that should do it so here we have our normal code and here we have our Java byte code it's not that we've done all of this now we can finally view all of our okay so here we are with our thousand zombies just moving around and as you can see 140 milliseconds now let's enable jobs and there you go it goes from 140 milliseconds to just 40 milliseconds so if we disable jobs our scene is running at 7 frames per second enable jobs and our scene is running at 25 frames per second so just like that you can see a massive performance boost on moving a thousand entities independent from one another so again like we didn't let's look at the profile so here we have running our code without the job system let's inspect one and as you can see we have just our testing that update and all of our worker threads are completely I don't and now lets enable jobs and here is you can see we have our jobs being invoked on our multiple threads so you can already see some massive performance boost now again let's check out the magical burst compound in order to enable it it's very simple we just need to add our attribute to our job so here we have our scene running our normal code we're taking 140 milliseconds okay now enable jobs and there you go go down to 140 down to 40 milliseconds per frame and now enable the first compound let's go here burst enable and let's see goes from 40 and here you go down to 4 milliseconds so without jobs 140 milliseconds with jobs plus the burst compiler and it's 4 milliseconds so just like that you can see the insane improvements you can get from the job system and the burst component now one last thing let's look at parallel jobs specifically for transforms so for that first we go up here and make sure that we are using Unity engine jobs and now we can go down here to make another job our public struct and in here we can implement I job parallel for transform this is a specific parallel job that works on transforms here as you can see we got our execute function which receives an index and also a transform access and the transform axis essentially duplicates a transform but it does so in such a way that we can use it inside our it's now in here and let's do our code the same as on this job except now we no longer need the position right instead we modify this transform directly and now let's see how we create this new type of job in here instead of having this job let's comment this out and here you can see that this function on schedule we require our transform axis right so we need to film that up so instead of using our original position array we are using a transform axis array and filling it up with our references we schedule it using this transform axis array and after a job completes again the transform is automatically updated so we no longer need the position we just need to update our move one all right so that's it as you can see this is a very specific job for working with normal transforms and finally we need to go into the transform access array and call this pose let's also add the birth compound attribute to make it insanely fast ok let's see so again here we have our normal code everything some words the same 140 enable jobs and sound 240 and enable jobs plus the birth compound and we go down to 4 and everything works perfectly fine and we can look at the profiler here we are on the profiler and as you can see our code is running extremely fast the whole thing in just 1 point 3 6 milliseconds everything else is the editor loop and you can see here all the workers and all of them doing all of that transform work in here as you can see we have 16 instances and each of them is taking point 0 to 1 milliseconds so in this video we just covered the C sharp job system you can get even more performance by combining the entire dot stack so the job system with the burst compiler working with the entity component system with all of them put together you can get hundreds of thousands of units on screen so make sure you subscribe the channel for upcoming ECS tutorials using the complete dot stack with the job system and the first compound just to see how much performance we can squeeze out of this new awesome tech stack I hope this video helped you understand how to get started making jobs and the massive performance boost you can enjoy as always you can download the project files and utilities from unity code monkey comm if you liked the video subscribe the channel for more unity two terms post any questions you have in the comments and I'll do my best answer alright see you next time
