With timestamps:

00:00 - hello and welcome I'm your Cod Mony
00:02 - let's learn how to get started using n
00:03 - dots this is a technology stack that can
00:06 - provide some insane performance results
00:07 - literally 100x faster in some cases and
00:09 - thankfully learning the basics that is
00:11 - actually pretty simple here let's learn
00:13 - what is a component what is a system and
00:15 - what is an entity then we're going to
00:16 - learn how to create a job and run with
00:18 - the burst compiler for some insane
00:19 - performance and also of course see how
00:21 - to combine both entities and game
00:22 - objects and interact with them back and
00:24 - forth this video actually turned out
00:25 - pretty long because there's so much to
00:27 - cover there's time steps throughout the
00:28 - video I've been re searching all
00:30 - documentation and working on this video
00:31 - for the past two weeks so if you find
00:33 - the video helpful and you're feeling
00:34 - generous go ahead and drop a super
00:35 - thanks on the video or simply hit the
00:37 - Subscribe and the like buttons it's a
00:39 - small thing but it really does help so
00:40 - thanks also huge thanks to Danny from DM
00:43 - do seam who helped me by answering tons
00:45 - of my dots questions so this video could
00:46 - be as accurate as possible now over here
00:48 - on this video this is going to be a
00:50 - technical tutorial on how to start using
00:52 - dots but if you're looking for a hand
00:53 - level overview on the theory behind what
00:55 - is dots what is ECS and so on for that I
00:58 - highly recommend the video from Channel
00:59 - turb makes games that one is a really
01:01 - excellent explainer of all the
01:02 - components that makeup dots as well as
01:04 - the pros and cons and when to use it and
01:06 - when not to use it so go ahead and watch
01:07 - that video for the theory and over here
01:09 - let's learn a technical part on how to
01:10 - actually use it although let me also
01:12 - quickly remind you that you don't have
01:13 - to go full dots or full game objects the
01:16 - ideal workflow is to mix them both so
01:18 - dots is really just another tool in your
01:20 - toolbox it is indeed a little bit more
01:21 - complex compared to game objects as
01:23 - we're going to see in a little bit it is
01:24 - an advanced tool after all although it's
01:26 - honestly not really too complex once you
01:28 - understand the basics and of course that
01:29 - comp actually buys a ton of excellent
01:31 - benefits so even if you're working on a
01:33 - relatively simple game I would still
01:34 - encourage you to watch this whole video
01:36 - to the end just to be aware just to
01:37 - remember that you have this tool at your
01:39 - disposal in case you need some excellent
01:40 - performance at some point in the future
01:42 - you don't have to use it for everything
01:43 - but for some case it is an absolutely
01:45 - excellent tool and also just a question
01:47 - for my own purposes I would love to do a
01:49 - complete dots course in the next few
01:50 - months so let me know in the comments if
01:52 - you would be interested in that and
01:53 - specifically let me know what type of
01:55 - game you'd like to see made now the
01:56 - obvious answers would be a factory game
01:58 - or an RTS but could also be Tower
02:00 - Defense third person shooter vampire
02:01 - survivors like something like that there
02:03 - are plenty of genres where dots makes a
02:05 - lot of sense so do let me know your
02:07 - thoughts in the comments I'm currently
02:08 - working on a complete C course and after
02:10 - that one I plan to work on a dots course
02:12 - or if you're watching this several
02:13 - months in future maybe you hav already
02:14 - done it so check the pen comment and if
02:16 - you use Unity at all then check out my
02:18 - ultimate unity overview course to learn
02:19 - how to make better games faster it
02:21 - features over 70 lectures each covering
02:23 - a different tool or feature of the
02:24 - engine including many of which you might
02:26 - not know about and might be super useful
02:28 - for whatever project you're currently
02:29 - working on okay so let's begin by making
02:31 - the most basic demo possible let's make
02:33 - just a simple Cube rotating now before
02:36 - we do that just some notes in terms of
02:38 - unity version over here I'm using the
02:39 - unity 22 LTS although you can also use
02:42 - the 23 beta if you like it should be
02:44 - pretty much the same and if you're
02:45 - watching this many months or years in
02:46 - the future and using Unity 6 then should
02:49 - still be mostly the same then dots uses
02:51 - a lot of source code generation in order
02:53 - to simplify various things so for that
02:55 - you need to be using an ID that supports
02:57 - that in my case I'm using visual studio
02:59 - 22 to the free community version and
03:01 - then they also recommend that you modify
03:03 - the domain reload setting so for that
03:05 - here in unity let's go into edit and
03:06 - then project settings then on left side
03:08 - go into the editor Tab and over here
03:10 - let's scroll down find here the
03:12 - interplay mode settings and let's enable
03:14 - these and make sure these two are
03:16 - unticked now importantly you should know
03:18 - one side effect of this is that your
03:19 - static fields and events those will not
03:21 - be reset by default meaning if you set
03:23 - some data on a static field then you
03:25 - stop playing and start playing again
03:27 - that data will persist whereas if you
03:29 - have mean reloading enabled if so it
03:31 - will always clear the data before
03:33 - starting so just be aware of that side
03:35 - effect just be aware of what this option
03:36 - does and when working with dots be extra
03:39 - careful about any static fields or
03:40 - events all right so here in the editor
03:42 - let's begin by installing the package so
03:44 - as usual let's open up the package
03:45 - manager up here up top let's go into the
03:48 - entity registry and then over here let's
03:50 - scroll down and find the entities
03:51 - package alternatively if you don't see
03:53 - it you can also insult by name so com.
03:55 - en. entities you would basically go up
03:57 - here on the top left corner add a
03:59 - package by name and put in this name
04:01 - community. entities but as long as you
04:03 - are using a recent version you should be
04:04 - able to see it so let's just go ahead
04:06 - and
04:08 - install okay done now the other one that
04:11 - we need in order to be able to render
04:12 - things is the enties graphics you only
04:14 - need this one if you actually want to
04:15 - render entities meaning you can use just
04:18 - entities without any entities visual but
04:20 - over here in this emo I will indeed be
04:22 - rendering some entities so let's go
04:23 - ahead and install this one as well now
04:25 - one more note related to this NT
04:27 - Graphics this one only works with either
04:29 - urp or hrp it does not work with the
04:31 - built-in rer pipeline so here in my
04:33 - project I have my project set up to use
04:35 - urp the universal R Pipeline and they
04:37 - also recommend that entities rendering
04:39 - be used with forward plus rendering so
04:41 - let's go ahead and set that up so let's
04:42 - go into the render pipeline asset and
04:44 - inside let's go inside the actual render
04:47 - object and over here for rendering path
04:49 - let's put it on forward plus okay that
04:51 - should do it let's also make sure all
04:52 - the other packages related to dots are
04:54 - also installed again remember how dots
04:56 - is really not just one thing it is
04:58 - actually composed of the enti component
05:00 - system or ECS that's the en package that
05:02 - we just installed but then it's also
05:04 - composed of the job system and burst
05:06 - those should both automatically be
05:07 - installed as dependencies so if you look
05:09 - over here burst Yep this one should be
05:11 - installed then the other one is the
05:13 - mathematics Library yep also installed
05:15 - and finally the collections Library yep
05:17 - also installed okay great so we have all
05:19 - the packages that we need all right now
05:21 - let's begin by making our first entity
05:23 - and the way we do that is first we
05:25 - create a subscene so over here on the
05:27 - hierarchy click on the plus icon and
05:28 - let's create a brand new subscene then
05:31 - give it some kind of name so over here
05:32 - entities subscene all right there it is
05:35 - here we have our subscene now this
05:37 - subscene this is an ECS specific thing
05:39 - basically any objects that we place
05:41 - inside of this subscene all of those
05:42 - will automatically be converted into
05:44 - entities so inside for example let's
05:46 - create a new game object and let's go
05:48 - inside 3D and just make a basic Cube and
05:50 - yep look how that one is indeed inside
05:52 - the entity subscene and now this game
05:54 - object this will automatically be
05:55 - converted into an entity if we look on
05:58 - the inspector and down here we can see
05:59 - something for the entity baking preview
06:01 - you can click to expand this and over
06:03 - here basically we can see all the
06:05 - components that won't be baked based on
06:06 - these regular components also one very
06:08 - important thing the system is smart
06:10 - enough to be optimized to only create
06:12 - entities when they are needed so if we
06:14 - create a cube like this with these
06:15 - Vision components then it will indeed
06:17 - create an entity and add all of these
06:19 - components however if I go in the
06:21 - subscene and I create just an empty game
06:23 - object if I do yep nothing shows up here
06:25 - because this one won't actually be baked
06:27 - if the game object has no components
06:29 - nothing at all then it will not actually
06:31 - create an enti so with the cube selected
06:33 - another way that we can see the entty
06:35 - components is on the inspector on the
06:36 - top right corner we have the circle
06:38 - button and if we click on it we can
06:40 - basically tell on the inspector between
06:41 - various modes right now we are seeing
06:43 - the default mode which shows usual game
06:45 - object representation so the usual
06:47 - components you're used to and then if we
06:49 - click on runtime yep now here we can see
06:51 - the entity representation so instead of
06:53 - the normal transform component we have a
06:55 - local to world then we've got a bunch of
06:57 - things to handle rendering render bounds
06:58 - and so on so basically these are all of
07:00 - the entity components that are created
07:02 - automatically by the baking system
07:04 - compared to the regular monom Behavior
07:06 - components by the way here's one quick
07:08 - tip instead of over here constantly
07:09 - jumping back and forth between these two
07:11 - modes we can basically leave this
07:13 - regular inspector as a regular game
07:15 - object inspector and then we can right
07:17 - click on the tab and let's create add
07:19 - new tab add a new inspector Tab and on
07:22 - this one let's go ahead and swap it out
07:23 - into the entities this way we have two
07:26 - inspectors so we can very easily swap
07:27 - back and forth between the two
07:28 - representations now another place where
07:30 - we can see entities is on the entities
07:32 - hierarchy so for that let's go into
07:34 - window and go down into entities and
07:36 - open up the hierarchy and yep in here we
07:38 - can see all of the various entities
07:40 - right now it still looks ex the same as
07:41 - the regular hierarchy but if we now hit
07:43 - on play yep here we see all of the
07:45 - entities that were automatically
07:46 - generated and again if I select the game
07:48 - object the one that has no components
07:50 - like I said this one does not create an
07:51 - entity so if you look in the inspector
07:53 - yep it says this one does not exist
07:55 - anymore because again this one does not
07:56 - get baked because it is completely empty
07:58 - okay so for now let's get rid of the
08:00 - game object and we can actually put the
08:02 - N hierarchy next to the regular
08:03 - hierarchy and for visual just for fun
08:06 - let's attach a different material just
08:08 - to make it easy to see so I'm going to
08:10 - go into the regular inspector again the
08:11 - regular game object inspector with usual
08:13 - components that you're used to and over
08:15 - here I'm going to drag the material and
08:17 - yep and I can move it around and again
08:19 - note how all I'm doing is really just
08:21 - interacting with game objects and then
08:22 - it everything gets automatically
08:24 - converted into entities okay so now that
08:26 - we have our entity next thing we want to
08:27 - create is a component and the way we do
08:29 - that is with a script so let's go ahead
08:32 - right click on the project files and
08:33 - let's create a new C script and for this
08:35 - one let's call it rotate speed now
08:37 - importantly we do not attach it to
08:39 - anything so just create the script and
08:41 - let's open it and over here first let's
08:43 - just get rid of the default functions
08:45 - okay so now we need to do two things
08:47 - first we do not inherit from monob
08:49 - Behavior instead we are going to
08:51 - implement I component data it's this one
08:54 - which exists inside namespace unity.
08:56 - entities so make sure to add the using
08:58 - and Yep this is it it and secondly this
09:00 - is not going to be a class instead it is
09:02 - going to be a struct now if you don't
09:04 - know differences between those two go
09:05 - check out my quick video on it basically
09:07 - strs and classes those are stored in
09:09 - different places in memory and the way
09:11 - that doarts is so insanely fast is
09:13 - really mostly all about memory
09:14 - management so a lot of things in dots
09:16 - are used as structs usually that just
09:18 - involves replacing class with struct but
09:20 - like I said definitely go watch my video
09:22 - on that topic if you're going to use
09:24 - dots you absolutely must know the
09:25 - differences between those two otherwise
09:27 - you will go crazy at some point in the
09:29 - future if you don't know how some things
09:30 - work as copies and some work as
09:32 - references okay so with this we have our
09:34 - component and components are basically
09:36 - just containers for data so over here we
09:38 - can place whatever that we want for
09:40 - example let's just add a public float
09:42 - and just call it value this is going to
09:43 - be our rotation speed now normally I
09:45 - always tell you not to make everything
09:47 - public normally I tell you to make
09:48 - Fields private and if you need to you
09:50 - can make some functions to get and set
09:52 - that field and technically over here on
09:54 - the component you can add functions that
09:56 - is allowed but you really should not do
09:58 - that component comp should really only
10:00 - hold data and no logic so for components
10:02 - you can really just Define a personal
10:04 - rule to always make them public since
10:05 - they only ever hold data kind of similar
10:07 - to the rule that I defined for myself
10:09 - when working with script M objects I
10:11 - also use those only as data containers
10:13 - and I also make those with public Fields
10:15 - okay so this is just our super basic
10:17 - component just one piece of data however
10:19 - just like this we still haven't attach
10:20 - it to our entity if here in the editor
10:22 - we run our code look in the empty
10:24 - inspector and nope we still don't have
10:26 - our custom component and since this one
10:29 - is an ey component data instead of a
10:30 - mono Behavior because that we can simply
10:33 - just drag it this does not work so in
10:35 - order to attach components to entities
10:36 - we have several ways of doing that in
10:38 - order to use the exact same game object
10:39 - workflow that you're used to for that we
10:41 - need to use the baking system and the
10:43 - way we do that is actually super simple
10:45 - we just need to make what is called an
10:46 - authoring component so let's make a UC
10:48 - sh script and for this one let's call it
10:51 - rotate speed authoring now here
10:53 - technically you don't have to append
10:55 - authoring to the name it's really just a
10:56 - nice convention to follow so let's make
10:58 - this script and let's open it and now
11:00 - this one is indeed going to be a regular
11:02 - mono Behavior component and over here we
11:04 - can add whatever films we want so let's
11:06 - add the exact same ones that we had in
11:08 - our component so let's just add a public
11:10 - float for our field now over here in the
11:12 - editor let's select the cube let's go
11:14 - into the regular game object inspector
11:16 - and over here let's just attach the
11:17 - component just like any other component
11:19 - so let's attach it and put the field
11:20 - let's say on three okay great so
11:22 - basically now we have a simple component
11:25 - that just has our value field and we
11:27 - have a simple authoring component that
11:28 - we then attached to our game object what
11:30 - is left is really just our Baker in
11:32 - order to turn one into the other one now
11:34 - the baker is going to be a class and by
11:36 - convention we should put the baker class
11:38 - directly inside the authoring class you
11:40 - don't have to but it just helps to keep
11:41 - things organized so let's make a private
11:43 - class call it Baker again the name also
11:46 - doesn't matter just a nice convention
11:47 - and now what does matter is that we
11:49 - actually extend the baker class this one
11:51 - takes a generic if you don't know about
11:53 - generics check out my quick video on
11:55 - them and then we put in the time for our
11:57 - authoring class so in this case the rot
11:59 - T speed authoring okay so this is what
12:01 - we do and then in order to use this one
12:04 - this one is inside unity. enties so
12:07 - let's make sure to do that and now in
12:08 - order to do this we need to implement
12:10 - this abstract class which requires
12:11 - implementing this bake method okay so we
12:14 - have this and now here is where we
12:15 - basically convert the data from our
12:17 - authoring component into our actual ECS
12:19 - component so we're going to use the
12:20 - function add component now importantly
12:22 - this is the baker add component this is
12:25 - not the regular game object add
12:26 - component and for this one first we
12:28 - require entity reference so for that we
12:30 - can use the function get entity this one
12:33 - requires us to use a transform usage
12:35 - Flags this is an optimization thing
12:37 - basically if you set it as none then the
12:39 - entity won't be converted with no entity
12:41 - transform component so if you never need
12:43 - to move an entity or have a position in
12:45 - the world and there's really no reason
12:46 - to include a transform component but in
12:48 - this case for our demo we do want to
12:49 - transform we want to rotate our Cube so
12:51 - for that instead of none let's go with
12:53 - Dynamic and this going to return an
12:55 - entity reference and then we can simply
12:57 - use this entity reference to add our
12:58 - comp component and then for our
13:00 - component we really just create the one
13:01 - that we just created so the rotate speed
13:03 - component and then we initialize it with
13:05 - our values so in this case the rotate
13:07 - speed value let's go inside the
13:09 - authoring component and grab the value
13:11 - okay so yep that's it in summary we have
13:13 - our rotate speed this is a regular
13:15 - component so I component data just an
13:17 - ECS component and inside we just have a
13:19 - value field but this one cannot be
13:21 - attached to a game object so for that we
13:23 - create an authoring component this one
13:25 - is a mon behavior and this one we do
13:26 - attach to our object we expose it field
13:29 - on this one by convention it should
13:30 - probably be the exact same name as the
13:32 - one on the component but techically it
13:33 - doesn't have to be so here in the editor
13:35 - we added that mod Behavior component and
13:37 - we assign the value then we created a
13:39 - baker class that extends the baker
13:40 - entities class and on this one we need
13:42 - to overwrite this function and basically
13:44 - the ECS system will automatically run
13:46 - this function it will pass in this
13:48 - reference for the authoring component
13:50 - and then over here we get the entity
13:52 - that Baker is currently being run on and
13:54 - we call add component in order to add
13:56 - our custom component and then we just
13:57 - manually assign the value to the exact
13:59 - same value okay so with this let's test
14:01 - all right so here's our en let's select
14:03 - it go into the entities inspector and
14:06 - let's scroll down and seeing and yep
14:07 - here we have our rotate speed component
14:09 - and yep the value is indeed the one that
14:11 - we set all right awesome now just one
14:13 - more note on a possible optimization
14:15 - here if you want you can do it like this
14:17 - so basically having two separate scripts
14:19 - one for just the component and one for
14:21 - just the authoring component or
14:22 - alternatively you can simplify this and
14:24 - just put everything on the same script
14:25 - so over here on the rotate speed I'm
14:27 - literally just going to copy this code
14:29 - and paste it directly inside of this
14:30 - file then over here on the editor just
14:32 - delete the rotate speed script so we
14:34 - just have one file one script and inside
14:37 - that we have both the component the
14:38 - authoring and the baker so yep
14:40 - everything still works exactly the same
14:41 - except now it's all much more compact
14:43 - all in just one script although one note
14:45 - on this method which is that the file
14:47 - name the name for the actual file for
14:49 - the script this one has to match actual
14:51 - authoring component it needs to match a
14:53 - script that we are using over here on
14:54 - the mon Behavior if we rename this file
14:56 - to something different to just the file
14:58 - name of the actual component if we did
15:00 - it would not work because Unity expects
15:02 - the file name to match a mono Behavior
15:03 - class name so if you follow this method
15:05 - of putting everything inside one file
15:07 - one script then just make sure that file
15:09 - name actually matches the authoring
15:11 - monob behavior component Okay so we've
15:13 - already learned about entities and
15:14 - components however just like this we're
15:16 - really just attaching some data to an
15:18 - entity nothing is moving nothing is
15:20 - changing so what we are missing is the s
15:22 - in ECS which are these systems systems
15:24 - are what actually modifies the data in
15:26 - the components so let's begin by making
15:28 - a brand new C script call this the
15:31 - rotating Cube system and again we don't
15:34 - attach it to anything let's just open it
15:36 - and now here again same thing we do not
15:38 - extend mod Behavior instead for a system
15:40 - we have two possible ways of making them
15:43 - one way is to make this a class and
15:45 - extend system base inside unity.
15:47 - entities this is how you make a system
15:50 - that deals with manage types so things
15:52 - like game objects transforms delegates
15:54 - and so on also a note is this needs to
15:56 - be marked as a partial class this this
15:58 - comes back to what I mentioned in the
15:59 - beginning of how dots is very much based
16:01 - on Source generation basically we're
16:03 - marking this as partial and then the dot
16:05 - system will write the rest of the code
16:06 - so this is one way making a system base
16:08 - like I said this one is for managed data
16:10 - and the other way is instead of making a
16:12 - class we make it a struct and set of
16:14 - system base we Implement I system so
16:17 - this one is meant for unmanaged types so
16:19 - strs inss bones and so on which in turn
16:21 - means you can use burst on this one
16:23 - making it much faster basically by
16:25 - default you should probably always try
16:26 - to make an i system unless you spefic
16:28 - spefically need to use a manage type in
16:30 - which case use a system base however
16:32 - also let me make sure one very important
16:33 - thing about systems in general both High
16:36 - system and system base both of them run
16:38 - on the main thread just making something
16:40 - a system does not make it multi- thread
16:42 - for that we need to make a proper job
16:44 - which I'm going to cover later on the
16:45 - video okay so here let's use an i system
16:47 - so it needs to be partial needs to be
16:49 - struct and needs to implement I system
16:52 - then over here on the I system we can
16:53 - Implement three functions we can
16:55 - actually inspect the system definition
16:56 - so let's go ahead right click go to that
16:58 - definition and here we see what we can
17:00 - Implement so we can implement the
17:02 - oncreate function this one happens when
17:04 - the system itself is created we can
17:06 - Implement on Destroy so this one is
17:08 - called when this system is destroyed
17:10 - then of course we have the onupdate and
17:12 - this one runs on every update so pretty
17:14 - much the same thing as the normal mod
17:16 - Behavior update so let's go ahead and
17:18 - Implement our on update method so just
17:21 - go ahead do this our P void on update
17:25 - and now here we want the system to run
17:26 - and do something on some entity
17:29 - right now we really just want to rotate
17:30 - our Cube and the way that we do that is
17:32 - with a 4 each and in this case we want
17:34 - to find entities that have our rotate
17:36 - speed component so we're going to find
17:39 - the rotate speed rotate speed in and
17:42 - then basically do a query for all of our
17:43 - components so for that we go inside the
17:46 - system API and we call query and then we
17:48 - pass in the types that we're looking for
17:50 - so in this case rotate speed now another
17:52 - really important part when working with
17:54 - ECS is being very clear with when we
17:56 - want to write or when you just want to
17:57 - read and the way we do that is by either
17:59 - writing ref RW or ref rro this is a
18:02 - class that use generics once again so
18:05 - don't be confused about the amount of
18:07 - angle brackets over here like I said we
18:09 - have refr W so this one is meant for
18:11 - read WR but if we never need to modify
18:13 - anything then we can use ref for read
18:15 - only this becomes really important later
18:17 - on when scheduling jobs since you can
18:19 - have multiple jobs running concurrently
18:21 - if they're only reading the same data
18:23 - but you can only ever write one job at a
18:25 - time in this case we really just want to
18:27 - read the rotate speed so let's go with
18:29 - ref and of course over here for the
18:31 - parameter instead of just rotate speed
18:33 - we also have ref of type rotate speed
18:35 - although let me also make one note
18:37 - technically like we saw if we erase the
18:40 - refo technically this is valid code we
18:42 - don't have any errors basically like
18:44 - this the default to read only however it
18:46 - also using a copy instead of a point of
18:49 - reference which can cause some
18:50 - performance concerns so even though this
18:52 - is technically valid code you should
18:54 - always explicit mention whether it's
18:55 - refr w or refer okay so basically these
18:58 - we do a for each on all the entities
19:00 - that have our rotate speed component but
19:02 - in order to rotate them for that we also
19:03 - need the transform so over here in our
19:05 - query let's also include the local
19:07 - transform component this one exists
19:09 - inside using unity. transforms so we
19:11 - have this one and for this one we do
19:13 - want to modify the transform in order to
19:14 - actually rotate the object so for this
19:16 - one let's go with ref RW and for our
19:18 - iterator variable instead of having just
19:20 - one put it inside parentheses because
19:22 - over here we have basically a ton so the
19:24 - ref RW for the local transform like this
19:28 - by by the way one note here you can
19:29 - write code like this meaning Define the
19:31 - types and the name for the variables or
19:33 - alternatively you can also just use VAR
19:35 - so just VAR and then just the names of
19:37 - the variables so this also perly valid
19:39 - code now some people like this method
19:41 - the official documentation use this
19:43 - quite a lot although personally I am not
19:45 - a fan of R just because I like to be as
19:47 - explicit as possible so personally I
19:49 - really prefer to define the actal type
19:51 - so just like this but like I said this
19:53 - is just personal preference both ways
19:55 - work so feel free to use the V method if
19:57 - you prefer that one okay okay so here
19:58 - now we have both of our components and
20:00 - this for each the code in here this will
20:02 - cycle through all the entities that have
20:04 - both of these components now here we can
20:06 - just say app rotation so in order to
20:08 - rotate let's go inside the local
20:10 - transform and then first we need to
20:11 - access the underlying component with
20:13 - either read or write in this case we do
20:15 - want to write so let's access the value
20:16 - r w and then on the local transform we
20:19 - can call the function rotate y to rotate
20:21 - on the Y AIS however this function
20:23 - actually rotates a copy instead of
20:25 - modifying the original local transform
20:27 - so we set the value r w equals whatever
20:31 - this function returns and over here for
20:33 - the rotating angle for this let's grab
20:35 - the speed value from the component so
20:36 - rotate speed in this case this is a read
20:38 - only so let's grab the value r o and
20:41 - then we grab the value the one that we
20:42 - Define inside the component and finally
20:44 - as always when doing any movement or
20:45 - rotation we want it to be frame rate
20:47 - independent so over here we need to
20:49 - modify by Delta time and inside the
20:51 - system we get that through system api.
20:53 - time. Delta time now important it's this
20:56 - one when working with entities it's it
20:58 - is supposed to be this one and not the
20:59 - usual time. time basically this has to
21:02 - do with the fact that you can have
21:03 - multiple worlds and multiple systems
21:04 - with different time frames so when
21:06 - working inside of VCS always use this
21:08 - one inside the system API so with this
21:10 - Yep this will indeed rotate it now just
21:12 - one tiny thing like I said over here the
21:13 - rotate y this one doesn't actually
21:15 - modify this value so technically over
21:17 - here we can just read in order to apply
21:19 - the rotation so just make this one an r
21:21 - o and then we actually assign it to the
21:23 - RW again when working in DCS it is
21:25 - important to be very clear about read
21:26 - and write access and just like this
21:28 - everything should be working so
21:30 - basically this system this will work on
21:31 - every single entity that has both a
21:33 - rotate speed and a local transform
21:35 - component then it will run this code on
21:38 - those entities which in turn is going to
21:39 - rotate it on the yv value based on the
21:41 - speed defining the rotate speed okay so
21:43 - let's test and right away we do see our
21:45 - entity rotating and if I click to
21:47 - inspect the cube yep over there we can
21:49 - see the local transform is constantly
21:51 - modifying and if we go down here we can
21:53 - see the rotate speed and of course if we
21:55 - modify this increase it or decrease it
21:57 - and yep it modifies the speed all right
21:59 - awesome now if we want we can try making
22:01 - a bunch more cubes by the way when
22:03 - working with entity subscenes you can
22:05 - also use just regular prefabs so let's
22:07 - rename this to rotating Cube and I'm
22:10 - just going to drag it into my prefabs
22:11 - folder to make a regular prefab so this
22:14 - is a normal game object prefab I'm going
22:15 - to cover how to spawn in prefabs later
22:17 - on in the video right now I'm just
22:19 - making this a cube just so we can
22:20 - duplicate and create a bunch of them so
22:22 - let me create a whole bunch of them and
22:24 - then later on if we want to modify all
22:26 - of these we can just modify the original
22:27 - prefab okay so here we have a whole
22:29 - bunch of cubes and if I head on play yep
22:31 - all of them are rotating because again
22:33 - the system works on all entities that
22:35 - match the query no matter how many they
22:36 - are related to systems we also have the
22:38 - systems window so let's go into window
22:41 - and then over here into entities and
22:42 - systems this window basically shows all
22:44 - the systems that are running how long
22:46 - they are taking to execute and how many
22:47 - entities they are being run on so over
22:49 - here we can find our system by default
22:51 - it's going to be inside the simulation
22:53 - system group and over here we do see our
22:55 - rotating Cube system and Y this one is
22:57 - running on seven entities and taking 001
22:59 - milliseconds also one note on systems is
23:02 - technically they can be created before
23:04 - the main scene is loaded so generally it
23:06 - is actually good practice to make sure
23:07 - they only run if the actual entities
23:09 - that you want if those have already been
23:11 - spawned so to do that it's good practice
23:14 - over here to also implement the other
23:15 - function the oncreate and on this one
23:18 - let's say we want to run the system only
23:20 - when there is at least one entity
23:21 - without our rotate speed component so we
23:23 - do that by accessing the state so this
23:25 - is this system State variable and we
23:27 - call require for update and then pass in
23:30 - the type that we want to require so in
23:31 - this case the rotate speed basically
23:33 - this will make sure that this system
23:35 - this update will only run once we have
23:36 - an entity that has this speed component
23:38 - now technically this isn't absolutely
23:40 - necessary like we saw our code ran
23:42 - perfectly fine without of it that is
23:44 - simply because the query that we are
23:45 - doing here this one is simply returning
23:46 - an empty list before any cubes will
23:48 - respond so if the list is empty the 4
23:50 - each is simply not going to run so
23:52 - there's no problem but for example if we
23:54 - had other logic over here that somehow
23:56 - assume that a cube already exists all
23:58 - the time if so you might get an error
24:00 - whereas by adding the required for
24:01 - update this one matures the update
24:03 - function this one only runs when there
24:04 - is at least one entity with this
24:06 - component okay so far so good now like I
24:08 - said a while ago making something a
24:10 - system does not automatically make it
24:12 - multi-threaded this is all still running
24:14 - just on the main thread we can open the
24:16 - profiler in see so over here let's go
24:18 - into window then analysis and open up
24:20 - the profiler and we can click on a frame
24:22 - and be able to see let's expand this
24:24 - over here on my job look at all my
24:26 - worker threads and none of them are are
24:28 - actually doing the rotate cubes code
24:30 - everything is still happening all the
24:31 - way up here if we find it on the main
24:33 - thread it's really small so it's really
24:35 - hard to see but yep here it is the
24:37 - rotating Cube system this is all running
24:39 - still just over here on the main thread
24:40 - let me just add some dummy Co just to
24:42 - slow this down so we can more easily
24:47 - see okay so here I just wrote some dummy
24:49 - code just to waste some time on the CPU
24:52 - so just a variable that I'm multiplying
24:53 - and dividing a ton of times and then
24:55 - using it over here on the calculation
24:57 - since I'm multiplying and dividing the
24:58 - final result won't be one so it won't
25:00 - affect the actual rotation piece it
25:02 - should just take a bunch of time so
25:03 - let's see and yep now we can much more
25:05 - easily see yep all the code is over here
25:07 - again all of the worker threads all of
25:09 - these are idle all of our code is still
25:11 - running just on the main thread
25:13 - currently taking 7 milliseconds to run
25:15 - just a handful of Cubes now to get those
25:17 - massive performance boosts that dots is
25:18 - famous for for that we need to use the
25:20 - job system and burst which just to
25:23 - clarify those are not exclusive to
25:24 - entities you can make your game
25:26 - internally with game objects and you can
25:28 - still use the job system and burst those
25:30 - are not dependent on entities so first
25:32 - let's just enable burst which is super
25:34 - simple if you don't know the burst
25:36 - compiler is really one of the best
25:37 - things about dots it is basically a
25:39 - magical button that makes your code run
25:41 - orders of magnitude faster in order to
25:43 - enable burst you just go up here onto
25:45 - the jobs menu under burst and just make
25:47 - sure to take enable compilation which by
25:49 - the way right away you might be asking
25:51 - if burst is so good why isn't it always
25:53 - enabled why is it a checkbox and that's
25:55 - because when some error happens it can
25:57 - be tricky to debug if burst is enabled
25:59 - just because of how burst automized the
26:01 - low level code so while developing if
26:03 - you find some errors it might be useful
26:05 - to actually disable burst so you get
26:07 - some proper error messages but when
26:09 - making a proper final bill definitely
26:11 - always make sure to enable it okay so
26:13 - this one really just enables the burst
26:14 - compilation it just enables the
26:16 - potential to use burst but by itself
26:18 - it's really not doing anything just yet
26:20 - for that we need to go to some functions
26:22 - like over here on the onupdate function
26:24 - let's say we want to use burst on this
26:25 - one so for this we add an attribute to
26:27 - this function and we add the attribute
26:29 - burst compile so this one which exists
26:31 - inside using unity. burst so this
26:34 - attribute like this and Y just like this
26:36 - this code will be compounded with burst
26:37 - and will be insanely fast there's no
26:39 - need to do anything else let's just test
26:41 - and you prob away it does work so you
26:42 - can already see the difference
26:44 - previously our system was taking 7
26:45 - milliseconds whereas now just by
26:47 - literally enabling burst now it is
26:49 - taking literally 0.004 milliseconds now
26:52 - actually in this case I think the
26:54 - compiler is way too smart and basically
26:56 - sees that what I'm doing here is not
26:57 - nonsensical so this code makes no sense
27:00 - so I think the compiler is smart enough
27:01 - to pretty much just erase this that is
27:03 - why it's such a drastic speed up in this
27:04 - test but in pretty much every normal
27:06 - scenario just the enabling burst makes
27:08 - insane speed UPS this is really insanely
27:10 - impressive for literally just one button
27:12 - click and also one note sometimes you
27:14 - might see some code that also has the
27:15 - burst compile applied over here into the
27:17 - system struct if you want you can add it
27:19 - doesn't change anything basically the
27:21 - autogeneration the source code
27:22 - generation that one is smart enough to
27:24 - know that if you use burst compile on
27:25 - any method it automatically adds it so
27:27 - you only need to add it on the methods
27:29 - now while burst does indeed work pretty
27:31 - much like magic it does have some
27:33 - limitations the main one being that it
27:35 - only works on unmanaged types so if you
27:37 - use a class inside this function then
27:39 - you cannot make it burst compile this is
27:41 - why ECS is very much based on structs
27:43 - and a data oriented design it's so you
27:45 - can benefit from these massive speed UPS
27:47 - including using burst and to make this
27:48 - truly insanely fast that's where we use
27:50 - the next part dots which is the job
27:52 - system again right now even though we
27:54 - are using burst which made this insanely
27:56 - fast even with that it is still all
27:58 - running just over here on the main
27:59 - thread in order to make it
28:00 - multi-threaded that's where we use the
28:02 - job system so first thing we do is we
28:04 - need to create a job and for that we
28:07 - make a struct so let's put it right in
28:08 - here let's make a public struct call it
28:12 - rotating Cube job if you want you can
28:14 - make it in its own file or really just
28:15 - over here right next to the system this
28:17 - works great so we do this and now we
28:19 - Implement one of the several I job
28:20 - interfaces there's a bunch of them
28:22 - depending on what exactly you're trying
28:24 - to do if you're trying to run some nonn
28:26 - code then you should probably use the
28:28 - iob 4 also by the way there is an iob 4
28:30 - and an iob parallel 4 however you really
28:32 - should not use this one this one is
28:34 - really only here for backwards
28:35 - compatibility reasons instead if you
28:37 - need something not to do with entities
28:38 - you should use I drop 4 and then if you
28:40 - need to make this code parallelized then
28:42 - you can simply call schedule parallel
28:44 - which we're going to see in a little bit
28:45 - but over here we want to do some work on
28:47 - some entities so for that let's use the
28:49 - I job entity okay so we do this one and
28:52 - for this one same thing Source
28:53 - generation so this one also needs to be
28:55 - marked as partial and then like it said
28:57 - says here we need to implement an
28:58 - execute method so let's make public void
29:01 - execute and over here for the parameters
29:03 - for this one we basically add the
29:05 - components that we need just like we did
29:06 - up here on the query so we are going to
29:08 - need the local transform local transform
29:11 - and then we're also going to need the
29:12 - rotate speed rotate speed so we need
29:14 - these two components and then again we
29:16 - have the same considerations we had
29:18 - previously with regards to read write
29:19 - except over here instead of using ref RW
29:21 - and ref instead of that when we want
29:24 - something just read only instead of ref
29:26 - we just set the in keyword this makes it
29:28 - read only and when we want read write
29:31 - for that we are going to add the ref
29:32 - keyword so just like this and then the
29:34 - code inside is going to be exactly the
29:36 - same so I'm just going to copy paste
29:37 - that except we now don't need to go into
29:40 - the value Arrow we just do just like
29:42 - this so just erase these like this and
29:45 - then over here when working inside a job
29:46 - we don't have direct access to the
29:48 - system API so in order to get our Delta
29:50 - time let's pass it over here as a simple
29:52 - field in our job so float for Delta time
29:56 - and then over here here we use this same
29:59 - okay so this is going to do pretty much
30:00 - the same thing so basically this job won
30:02 - be executed on every single entity that
30:04 - has both these two components just like
30:06 - we had the query up here which is going
30:08 - to execute that and for every single one
30:10 - of those entities it is going to run
30:11 - this code so here we have the find our
30:13 - job all that's left is to actually run
30:15 - our job so for that let's go up here
30:17 - onto our on update and right now we are
30:19 - not going to use the system query method
30:21 - so let's just comment this one out so
30:22 - comment out the 4 in instead of doing
30:24 - that we just create a new job so new
30:27 - rotating Cube job and inside we need to
30:29 - pass in the Delta time so let's pass in
30:31 - the same thing go inside the system API
30:33 - in order to grab time. Delta time this
30:36 - is going to return a rotating Cube job
30:38 - this simply creates a job and then after
30:40 - creating the job then we have two
30:42 - options number one is to call run this
30:45 - one will make it run immediately on the
30:46 - main thread so this one can be sometimes
30:49 - useful for debugging but in most case
30:50 - you probably don't want to use this one
30:52 - instead you probably want to use
30:54 - schedule this one will schedule the job
30:56 - to complete at some point in the future
30:58 - it will be completed either by the main
31:00 - thread or any worker thread it really
31:02 - depends on which one is busy this one
31:04 - completes the entire job in just one
31:05 - thread and then finally we have the
31:07 - schedule parallel this one will
31:09 - basically split the job into multiple
31:11 - chunks and create multiple jobs that run
31:12 - on multiple threads all at the same time
31:15 - so first let's actually start with a
31:16 - simple one just a regular schedule so
31:18 - let's do this in test okay so there it
31:20 - is and the cubes are all spinning and if
31:22 - we look and up here we can see there
31:24 - we've got our job and it's actually
31:26 - being handled over here by worker one
31:28 - now depending on what you're doing it
31:30 - might complete in the same frame or in
31:31 - this case it might take two frames to
31:33 - complete if you really want to force a
31:35 - job to complete then over here on the
31:37 - schedule you can pass in the optional
31:38 - state. dependency now this one returns a
31:41 - job handle and if you want to force it
31:43 - to complete you can call complete and
31:45 - Visually then down here you can write
31:46 - some code that assumes that this job has
31:48 - already been completed however you
31:49 - should really avoid this as much as
31:51 - possible instead you should let the job
31:53 - system actually decide when to run jobs
31:55 - and if you need some code to run after
31:57 - some job has completed then you
31:58 - basically should just make that second
31:59 - job a dependency of the first job so
32:01 - ideally you never actually do this you
32:03 - just call schedule and then wait that
32:05 - for the job system to actually complete
32:06 - the job although one important note is
32:08 - how over AE schedule this is actually a
32:10 - shorthand so the source generation then
32:12 - replaces this so basically puts a state.
32:14 - dependency inside of here and sets the
32:16 - new state. dependency equals to this so
32:19 - when you call that short hand it is
32:20 - actually doing this this basically
32:22 - ensures that as you schedule a job it
32:23 - will have the correct dependencies but I
32:25 - should also mention that while the short
32:27 - hand works great if you're doing an i
32:28 - job entity this code will have problems
32:31 - if you use an i job 4 because then it
32:32 - will not pass in the correct
32:34 - dependencies so in doing anything other
32:36 - than an i job entity then make sure you
32:38 - explicitly Define the state. dependency
32:40 - as a dependency of that job instead of
32:41 - using just a Shand okay so like we saw
32:44 - the schedule this one schedules on just
32:45 - one worker thread so over here we have
32:47 - our job running on just this one and the
32:49 - other one that we saw is the schedule
32:51 - parallel this one will run the job on
32:53 - multiple threads however this one
32:55 - actually has a really sneaky thing that
32:57 - confused me quite a lot while
32:58 - researching this video this one
33:00 - supposedly splits this job across
33:01 - multiple worker threads however if we
33:04 - test this and nope everything still
33:06 - looks the same it is still running on
33:07 - just one worker thread and all the other
33:09 - ones these are all idle so this is the
33:11 - part that really confused me it confused
33:13 - me why this one was still running on
33:15 - just one thread I even made a post on
33:17 - the forums asking for some help and
33:19 - thankfully I received some really
33:20 - excellent responses the answer is that
33:22 - apparently this one splits across
33:23 - multiple threads but it is based on
33:25 - chunks so since in My Demo over here I
33:27 - really just have seven entities these
33:29 - are not enough to be split over multiple
33:31 - threads they all fall into the same
33:33 - Chunk meaning they all run the same job
33:35 - on just this one worker thread it does
33:37 - not matter how intensive the job is it
33:39 - is all based on the number of entities
33:41 - if I say I just make a ton of entities
33:43 - so let me just duplicate this a mountain
33:45 - of times okay so I duplicate the prefab
33:48 - a ton of times so now I have a total of,
33:50 - 1500 entities and now if we run the same
33:52 - code again and now if we go ahead and we
33:55 - look and if now it is correctly in the
33:56 - indeed using all of the nice workout
33:58 - threads so that means that this method
34:00 - really isn't suitable for doing super
34:01 - heavy work on just a small number of
34:03 - entities if you have that specific use
34:05 - case then instead of using iob entity
34:07 - instead use the one that I mentioned so
34:08 - the I job parallel 4 and basically
34:10 - handle splitting the logic yourself so
34:12 - just be aware of this one this one
34:13 - confuse me by quite a bit but yep if you
34:15 - do this and you have a certain number of
34:17 - entities this does work you just call
34:19 - schedule parallel and it automatically
34:21 - runs it across multiple worker threads
34:23 - so in here with this many entities with
34:24 - 1500 entities ring the code which has
34:27 - this intentionally wasteful thing with
34:29 - all that in total it is taking 1500
34:31 - milliseconds per frame but we are still
34:33 - getting a handful of frames per second
34:35 - because when the whole thing is combined
34:37 - because of using all of these threads at
34:38 - the same time the whole thing takes just
34:40 - 100 milliseconds so this is how you make
34:42 - code multi-threading and again the best
34:44 - results come from combining both
34:46 - multi-threading the job system with
34:48 - burst so on the job definition let's add
34:50 - the burst compile attribute we only need
34:52 - to add it up here there's no need to add
34:54 - it for the execute function itself so
34:56 - like this if we test
34:57 - and again notice that difference again
34:59 - bur is way too smart and right now I
35:02 - can't even find it I need to zoom in
35:03 - like crazy in order to be able to find
35:05 - anything so here it is I finally found
35:07 - it so previously it was taking 1500
35:10 - milliseconds and now it is taking just
35:11 - 01 by the way quick tip to check if it's
35:14 - using burst or not look at the color
35:15 - over here on the profiler if it's in
35:17 - green then it is indeed using burst
35:19 - again I'm assuming burst is way too
35:20 - smart and it's intentionally identifying
35:22 - that this code is just wasteful this is
35:24 - nonsensical so I'm assuming it is
35:26 - actually identifying this in just
35:27 - deleting this useless cone but still
35:29 - even in regular scenarios and proper
35:30 - scenarios without this kind of testing
35:32 - code even in that burst is an insanely
35:34 - good thing it is a really excellent way
35:36 - to get extra free performance by just
35:38 - following some good data oriented design
35:40 - so when you combine the job system along
35:42 - with bur you can get some really insane
35:43 - results now let's learn about tag
35:45 - components this is a really easy and
35:47 - extremely powerful tool basically it's
35:49 - how you can add a tag to an object to
35:50 - Market as some sort of type like for
35:52 - example the difference between a player
35:54 - and an enemy thankfully tag components
35:56 - are insanely simp simple first let's
35:57 - actually see the problem that they solve
35:59 - so right now we have these rotating
36:01 - cubes now let's say I want to also have
36:03 - a player object so let's go ahead and
36:05 - make a player so inside my entity
36:07 - subscene I'm going to create a new game
36:10 - object this time for a player let's say
36:12 - it's a capsule let's move it a little
36:14 - bit going to give it a different color
36:17 - and inside I'm also going to add a
36:18 - simple Cube just to be able to see where
36:20 - this transform is facing okay so that's
36:22 - my basic player and now let's say that
36:24 - the player will also rotate so let's
36:26 - also uh the usual rotate speed component
36:29 - however we want the player to rotate
36:30 - based on input and not constantly like
36:32 - all the other objects whereas right now
36:34 - if we h on play and nope this is not
36:37 - what we want the player is rotating
36:38 - alongside all the other cubes basically
36:41 - what we want is for this rotating Cube
36:42 - system for this one to only apply to the
36:44 - cubes and not the player meaning that we
36:46 - need some kind of way to identify
36:48 - exactly what is a cube and what is a
36:50 - player so that's where tags come in like
36:52 - I said they are extremely simple we just
36:54 - make a new component as usual so let's
36:55 - create an UC C script call it the player
36:58 - authoring because again we're going to
37:00 - place both the component and the
37:01 - authoring directly inside the same
37:02 - script let's go ahead and attach a
37:04 - player authoring to the same player
37:05 - component and let's open and now over
37:07 - here for our authoring component which
37:09 - is going to be our mon behavior for this
37:11 - one we do not have any fields we have an
37:14 - empty authoring component then let's
37:15 - make a regular component an ECS
37:17 - component so a public this is going to
37:20 - be a struct let's just call it player
37:22 - and this one is an i component data
37:24 - which again exists inside unity.
37:26 - entities now this one also has no fields
37:29 - at all this is a tag component which is
37:31 - really just an empty component and then
37:33 - let's make our Baker so inside our
37:34 - authoring class let's make our usual
37:37 - public class Baker We Implement Baker of
37:39 - type player authoring and on our bake
37:42 - class on this one we're basically just
37:44 - going to add the component so again
37:45 - let's first of all grab the entity get
37:47 - entity and for this player the player is
37:49 - going to move so let's use Dynamic then
37:52 - let's call at component pass in this
37:54 - entity and just do a new player for the
37:56 - new player component so that's it no
37:58 - Fields no data nothing over here
38:00 - inspecting our player if we go into the
38:01 - entities inspector on this one if we
38:04 - look up top we can see a section just
38:05 - for the tags and Y over here we do see
38:07 - our player tag okay so this one is
38:09 - correctly tagged as our player and over
38:11 - here in our rotating Cube system let's
38:14 - go down to our job where we are rotating
38:16 - the cubes and right now this job w't run
38:19 - on every single entity that has both a
38:21 - rotate speed component and a local
38:23 - transform component this includes the
38:24 - player so in order to not include the
38:26 - player we can add a nice attribute to
38:28 - the job that is going to be the one
38:30 - called with none and then basically we
38:32 - add any types that we don't want this
38:34 - shop to run on so in this case let's go
38:36 - type of of our player component
38:38 - basically now with this component this
38:40 - job will run on every single entity that
38:42 - has both a local transform and a rotate
38:44 - speed component but no player component
38:47 - so it should run on everything except
38:48 - the player let's test and Y it does work
38:51 - all the cubes are still rotating but the
38:53 - player is not rotating okay great by the
38:56 - way here we we saw by using this
38:57 - attribute in order to make this job not
38:59 - run on entities that have the player
39:01 - component but over here the other method
39:02 - the4 each we can also do the same thing
39:04 - the way we do it inside of this one is
39:06 - we've got our system query and then
39:08 - after the query so after the parenthesis
39:10 - we can then add pretty much the same
39:12 - thing with none and then we pass in the
39:13 - type of type player and yep just like
39:16 - this now this for each will only run on
39:17 - all entities that have rotate speed
39:19 - local transform but no player and also
39:22 - yet another alternative is obviously we
39:23 - can do the opposite so instead of
39:25 - tagging the player and then writing this
39:27 - with none instead of that we can
39:29 - actually tag the cubes so let's make our
39:31 - rotating Cube tag so as usual C script
39:34 - for the rotating Cube authoring and over
39:37 - here the mono Behavior this one is empty
39:38 - then we've got a public struct for our
39:41 - rotating Cube this one is going to be I
39:43 - component data and inside this one is
39:46 - empty then on this one we've got our
39:47 - usual Baker class and then we simply
39:50 - have to implement our method and over
39:52 - here get the entity and add the
39:54 - component yep just like this and now the
39:56 - rotating cubes a while ago I made them a
39:58 - prefab just so we could easily modify
39:59 - all of them so let's go inside the
40:01 - prefab and let's add the rotating Cube
40:03 - authoring and Yep this one should now
40:05 - tag it as a rotating Cube and now in our
40:07 - system either over here on the 4 each
40:09 - instead of saying with none we can say
40:11 - with all so with all or with any in this
40:14 - case either one will work so with all of
40:16 - the rotating Cube so this works as we'll
40:19 - now only run on the cubes and same thing
40:21 - over here we can use the attribute let's
40:23 - go with with all and same thing the
40:25 - rotating Cube so now this job and this 4
40:28 - in both them will run on things that
40:30 - have the rotate speed the local
40:31 - transform and the rotating Cube
40:33 - component and also just for completeness
40:35 - sake of course the other alternative
40:36 - that you have is instead of using the
40:38 - WID all we could just use a ref RL over
40:40 - here of our rotating Cube that would
40:42 - also work but that would be quite a bit
40:44 - wasteful since we don't really need to
40:45 - access that tag component we really just
40:47 - want to run the cury that has that tag
40:50 - so when working in tags do not include
40:51 - them as a refero instead use the with
40:54 - all either the function over here or the
40:55 - attribute on this one and if we try
40:57 - running this code yep exactly the same
41:00 - result so now that rotating logic that
41:02 - one is only being applied to entities
41:03 - that have the rotating Cube tag so
41:05 - that's how simple tag components are
41:07 - they're literally just empty components
41:09 - which are really great for identifying
41:10 - your objects as being of a specific type
41:13 - so things like the player enemy bullet
41:15 - money and so on whenever you want to
41:16 - identify anything as something make sure
41:19 - you use a tag component next let's learn
41:21 - about aspects however before we do let's
41:24 - actually first see the problem that they
41:25 - are me to solve so for that let's make
41:28 - another simple component in the system
41:29 - to move our cues let's go ahead and make
41:32 - an e Shar script first for the component
41:35 - so movement authoring let's go ahead and
41:37 - add this one to our rotating Cube so
41:39 - let's just add the movement authoring
41:40 - and let's open it and over here let's
41:41 - actually do something fun so let's do so
41:44 - that the authoring component this one is
41:45 - completely empty but then we are going
41:48 - to have a movement Vector in our actual
41:49 - component so let's do a stru for our
41:52 - movement so I component data and on this
41:55 - one we do have something we do have a
41:57 - float 3 which by the way a float 3 is
41:59 - really pretty much exactly the same
42:01 - thing as a vector 3 this one just exists
42:03 - inside the unit mathematics library and
42:05 - this one is optimized to be used with
42:07 - dots and burst but in terms of logic
42:09 - it's literally the exact same thing as a
42:11 - vector 3 meaning if we go inside it we
42:13 - can see this one has an X Y and Z
42:15 - components so we got a flow three and
42:17 - let's call it the movement Vector so we
42:19 - have some data in our component but we
42:21 - have no data in our authoring component
42:24 - now let's go ahead and make our usual
42:25 - Baker class
42:27 - class on this one let's get our entity
42:30 - and then on ADD component let's add a
42:33 - component onto this entity and the
42:35 - component will be our movement component
42:37 - except now we don't have this field to
42:40 - grab directly from our authoring
42:41 - component I didn't do that just to show
42:43 - you how you don't have to you can make
42:45 - some authoring components that do some
42:46 - kind of processing in order to actually
42:48 - generate the final component data so
42:50 - over here for example let's just set it
42:51 - to a random value so we can just set
42:53 - movement Vector equals a new FL 3 like I
42:56 - said this is the same as a vector 3 so
42:58 - we've got an x y and Zed we just need to
43:01 - set these up so let's just put a random
43:03 - Vector which by the way the mathematics
43:04 - Library also has a random but for
43:06 - Simplicity sake I really enjoy using
43:08 - just the simple Unity engine one so
43:10 - let's go inside Unity engine to use that
43:12 - random specifically okay great just like
43:15 - this so when we attach this authoring
43:17 - component to an entity it is going to
43:18 - bait that entity and passing a movement
43:20 - Vector with a random movement Vector now
43:22 - that we have this let's make a system
43:24 - that will both move and rotate our cubes
43:27 - we want to do both of them so let's go
43:28 - ahead create a new C script let's call
43:31 - this the handle cubes system and over
43:34 - here for this one let's go ahead and
43:36 - make it an i system then as always we
43:39 - need to make this a partial
43:41 - struct okay let's write our onupdate
43:44 - method and on this one let's keep it
43:46 - simple and instead of using a job let's
43:48 - just use the regular for each method
43:50 - which actually this is probably what you
43:51 - should do when you first make a system
43:53 - meaning first use the simpler for each
43:55 - method that works just on the main
43:56 - thread get it working like that and then
43:59 - convert into a proper job if you need to
44:01 - so over here let's do a 4 in let's write
44:03 - a query first so system api. query in
44:06 - order to both move and rotate we are
44:08 - going to need the local transform
44:09 - component and we're going to need this
44:11 - one as a ref RW because we are going to
44:14 - actually move then in order to know how
44:16 - fast to rotate we are going to need the
44:17 - rotate speed component that one is just
44:19 - for reading so ref Ro for the rotate
44:22 - speed component next we are going to
44:23 - need to know how fast to move and where
44:25 - to move to so we need the move speed
44:27 - component again just for reading for the
44:29 - movement component and finally we don't
44:32 - want this to run on the player so let's
44:34 - also call with all and pass in the type
44:37 - of of our rotating cubes all right so
44:40 - this is our query so inside our 4 each
44:42 - we just need to use all of these so let
44:43 - me just write all of this okay so we
44:45 - have our query with all of our
44:47 - components then we do the logic so just
44:49 - rotating and moving all of it pretty
44:51 - simple just go into the local transform
44:54 - go inside first of all the value in
44:56 - order to rotate it so rotate it on the Y
44:58 - and let's do the same thing grab the
45:00 - rotate speed grab the value R and grab
45:02 - the actual value multiply it by our
45:04 - time. Delta time inside the system API
45:07 - so the time. Delta time this one is
45:09 - going to rotate but it doesn't actually
45:10 - modify the value so let's go inside the
45:12 - value RW and set it to this one this one
45:15 - rotates then we just need to move and
45:17 - for moving we're going to do the same
45:18 - thing so local transform go inside the
45:20 - value R and this case it's the translate
45:23 - then we need our movement Vector so
45:25 - movement value rrow and grab the
45:27 - movement vector and again make it frame
45:29 - rate independent so system api. time.
45:31 - Delta time okay so that's it some pretty
45:34 - simple logic this going to both rotate
45:36 - and move the component let's also just
45:38 - go ahead and disable our rotating Cube
45:40 - system we can either delete the script
45:42 - or just over here on the update we can
45:45 - just go into the state so that's the
45:46 - system State variable and just set
45:48 - enable equals false and let's return so
45:51 - it never runs once this one basically
45:52 - disabled the system from running so with
45:54 - this let's test and if everything works
45:56 - the cubes are both rotating and moving
45:59 - okay great so everything is working but
46:01 - looking over here at this query it is
46:03 - becoming quite massive with so many
46:05 - components so this is exactly where
46:07 - aspects come in an aspect basically
46:09 - groups multiple components into a single
46:11 - logical unit in order to Define an
46:13 - aspect first we need to define a script
46:14 - so let's create a brand new C script
46:17 - let's call the rotating moving Cube
46:19 - aspect and then inside of this one for
46:22 - this one we are going to implement I
46:25 - aspect which exists inside using unity.
46:28 - entities now this interface has no
46:29 - methods that we actually need to
46:31 - implement it's basically just a tag to
46:32 - mark this script as an aspect then an
46:35 - aspect is not a class instead it is a
46:37 - struct and again this one also needs
46:39 - partial for the source generation to
46:41 - work and one more thing specif to
46:43 - aspects is these need to be marked as
46:44 - read only okay great so now here we can
46:47 - add fields for all the components that
46:49 - make this aspect that make a rotating
46:51 - moving Cube and to add a component let's
46:53 - do the usual so let's make them public
46:56 - then over here we use either refr W or
46:58 - ref and let's begin with the UN local
47:00 - transform that we do want to write so
47:01 - let's go ref RW for the UN locon
47:04 - transform call it the local transform
47:07 - next we also need the rotate speed so
47:09 - for that one ref of the rotate speed and
47:12 - finally we got another one for the
47:14 - movement and as you can see since
47:16 - aspects need to be marked as read only
47:18 - all of these fields also need to be
47:19 - marked as read only so read only on all
47:21 - of these basically this this is the C
47:24 - read only tag basically it makes sure
47:26 - that we can never modify this field
47:28 - directly so after being set we cannot
47:30 - modify it it looks a little bit
47:31 - confusing to have something as marked as
47:33 - both read only and then ref RW for read
47:35 - write so it looks a little bit strange
47:36 - but Yep this is exactly how you write it
47:38 - use a c readon keyword and then ref RW
47:41 - or ref RL okay so we have all the
47:43 - components that we need in order to make
47:44 - this aspect work and then we also need
47:46 - to include the cube tag now suddenly the
47:48 - with all attribute does not work here so
47:50 - adding the with all just like we saw
47:52 - previously this one suddenly does not
47:54 - work on aspects instead said right now
47:56 - in order to add some kind of tag
47:58 - component is we can add it over here as
48:00 - a refero so we can do a read only make
48:03 - it a ref R in this case we need the
48:05 - rotating Cube tag component so this does
48:08 - work however it's a bit wasteful since
48:10 - we never actually need to touch this
48:11 - component so it would be nice if The Wil
48:14 - attribute worked here although there is
48:15 - an alternative that I will mention in a
48:17 - little bit so right now we do have all
48:19 - the components that make up our rotating
48:21 - Cube aspect basally we have the exact
48:23 - same components that we had over here on
48:25 - our system and now that we have defined
48:27 - the aspect now we can simplify this huge
48:29 - query with just a single aspect type so
48:32 - over here instead of all of these refl
48:34 - instead of all this movement so on we
48:36 - can just use the rotating moving Cube
48:38 - aspect and over here same thing now we
48:40 - just need one of them so the rotating
48:42 - moving Cube aspect just like this and
48:45 - yep that's it so as you can see this
48:47 - really simplifies that query now we just
48:49 - have one aspect in set of tons and tons
48:51 - of components also note how over here we
48:53 - do not need to add the refero or ref RW
48:56 - basically the aspect itself this works
48:58 - as a pointer and will already have the
49:00 - access that you define over here in the
49:02 - aspect definition now for the tag
49:03 - alternative that I mentioned like I said
49:05 - adding it here is a little bit wasteful
49:07 - since we never actually need to touch
49:08 - this data so if you need absolute
49:10 - maximum performance just remove it over
49:12 - here from the aspect and set over here
49:13 - on the system use the same thing that we
49:15 - already saw so just add with all and
49:17 - then we can include our rotating Cube Ty
49:19 - component yep just like this so This Way
49:22 - It Is technically slightly more
49:23 - efficient although in terms of
49:24 - readability I think prefer putting it on
49:26 - the aspect itself so I think this one is
49:28 - a little bit easier to read the best way
49:30 - would simply be if they allowed using
49:32 - the with all component the with all
49:34 - attribute over here directly inside the
49:36 - aspect that would be great so maybe they
49:37 - will add that in a future update okay so
49:40 - here we have our query with just our
49:41 - aspect and then over here for the logic
49:44 - now we can access the aspect components
49:45 - and make our changes so go inside the
49:48 - aspect then let's say go inside the
49:50 - local transform then go inside the value
49:52 - RW and so on so you could do this this
49:54 - would work just fine but another great
49:56 - bonus of aspects is that you can add
49:58 - logic directly inside of them so over
50:00 - here in our aspect let's just make a
50:02 - function so a p void move and rotate and
50:05 - over here let's really just copy this
50:07 - code so let's copy this put it in here
50:09 - and the only thing that we don't have
50:11 - the access is to the dth time from the
50:13 - system API so let's just receive it as a
50:15 - simple parameter okay yep just like this
50:18 - and over here in our system let's just
50:20 - go inside our aspect and simply call our
50:22 - function to move and rotate and pass in
50:25 - the system API time. time and yep that's
50:27 - it just like this let's test and yep
50:29 - everything still works so here you can
50:31 - really see how this code is now much
50:33 - much simpler than it was before thanks
50:35 - to using our aspect that is really the
50:36 - power of aspects is allowing you to
50:38 - group several components together into
50:40 - one logical unit next let's learn about
50:42 - something that is crucial to making
50:44 - pretty much any game prefabs and
50:46 - thankfully prefabs in ECS are also
50:47 - really simple right now we manually
50:49 - populated all of these cubes in our
50:51 - world and now instead of doing that
50:52 - let's make them spawn at runtime so
50:54 - let's make a system that spawn them and
50:56 - before we do that first we need to find
50:58 - some way to store a reference to our
50:59 - prefab so let's first make a component
51:02 - to store that and then our system will
51:04 - use that component so let's go ahead
51:05 - create new C script for the spawn cubes
51:09 - config authoring basically this is going
51:11 - to be the config file containing all of
51:12 - the config data for our spawn Cube
51:14 - system and over here in our mono
51:16 - behavior let's add a regular game object
51:18 - field for our Cube prefab so public game
51:21 - object for the cube prefab and then
51:23 - we're going to want to spawn multiple of
51:25 - them so let's also add an INT for the
51:27 - amount to spawn okay great like this
51:30 - then here in the editor let's make an
51:31 - empty gim object inside our entity
51:33 - subscene so let's create it name it
51:35 - spawn cubes config on the regular
51:37 - inspector let's go ahead and attach our
51:39 - authoring component and for the prefab
51:42 - let's drag our rotating CU prefab and
51:44 - for the amount one let's go with five
51:46 - okay so that's our authoring component
51:47 - now we need to convert this into an
51:49 - actual entity component so for that
51:51 - let's go ahead and make our entity
51:53 - components so again let's follow the
51:54 - exact same thing so so let's make it a
51:56 - stroke for spawn cubes config and this
51:59 - one is I component data however on this
52:02 - one instead of making another field of
52:04 - type game object instead of that we're
52:05 - going to make it of type entity so
52:07 - public entity and let's call A Q prefab
52:10 - entity so I have this and then for the
52:12 - end the same thing so the amount to
52:14 - spawn okay great so all we really need
52:16 - to do is convert our regular game object
52:18 - prefab into an entity prefab and we're
52:20 - going to do that on our
52:22 - Baker so let's make our usual Baker CL
52:25 - class we're going to do Baker and extend
52:27 - the spawn cubes config authoring then
52:30 - over here as usual let's pass in add
52:32 - components so that means we need our
52:33 - entity for this entity so let's go ahead
52:36 - get entity and in this case actually
52:38 - since we're using this config component
52:40 - this is really just a data component we
52:42 - don't really want it to exist anywhere
52:44 - so for this one now we can use none in
52:46 - order to make it just a little bit
52:47 - optimized since we don't really need
52:49 - that transform component then let's add
52:51 - a component onto this entity and the
52:52 - component new spawn cubes config and now
52:55 - inside here for the data for the amount
52:57 - of Spawn let's just go into our
52:58 - authoring and grab the amount of Spawn
53:00 - and then for the Q prefab entity the way
53:02 - we convert our game object prefab into
53:04 - an actual entity thankfully that is
53:06 - extremely simple we'll literally just
53:07 - use the same get entity function so get
53:10 - entity and this one has a version that
53:11 - takes in a game object so we can just go
53:14 - inside the authoring component and let's
53:15 - grab the regular game object Q prefab
53:18 - and then usage flag same thing let's go
53:20 - with Dynamic so y That's it really
53:21 - simple we just call get nty and this is
53:23 - going to automatically convert our G
53:25 - object into an entity prefab so with
53:27 - this this is going to work we're going
53:28 - to have our nice config component we can
53:30 - even test it out over here let's go
53:32 - ahead and run our game then look into
53:34 - the entity inspector and if there it is
53:36 - the spawn cubes config and yep we do
53:38 - have our rotating Cube prefab entity
53:41 - also note how on this one we do not have
53:43 - any transform components again that is
53:45 - that little optimization thing if we
53:47 - look into the other components the other
53:48 - entities all these is you have local to
53:51 - local transform and so on but on this
53:53 - one which was optimized this one does
53:54 - not have any transform data okay so
53:57 - great here we have our Q prefab entity
53:59 - now let's simply just
54:00 - insentient to handle that let's go ahead
54:03 - create a new C script let's call the
54:05 - spawn cubes system and then over here we
54:08 - can either make this a system base or an
54:10 - i system let's go ahead and do a system
54:12 - base just to be different from what
54:14 - we've already seen But like I said
54:15 - either one works so a system base just
54:17 - need to mark this as partial and then we
54:20 - need to implement our abstract class so
54:22 - we need to implement at least the
54:23 - onupdate method but then like I said a
54:24 - while you should also implement the
54:26 - uncreate if you have any requirements so
54:28 - over here let's also Implement override
54:31 - void the uncreate and on this one let's
54:33 - call require for update which by the way
54:35 - this is a little bit different from the
54:36 - one that we saw on the system so if we
54:39 - go inside the rotating Cube system on
54:42 - this one on the uncreate when working
54:43 - with an i system we've got a system
54:45 - State over here on the parameter and we
54:47 - go through that and call require for
54:48 - update whereas over here on a system
54:50 - base we can just call require for update
54:53 - and then pass in the component that we
54:54 - need need so in this case it's a spawn
54:56 - cubes config just like this okay so yep
55:00 - with this now the update will only run
55:02 - when there's an entity with the spawn
55:03 - cubes config that's good because we're
55:05 - going to actually need that object to
55:07 - exist in order to run some logic here
55:09 - and now on this logic we really only
55:10 - want to spawn the cubes once so let's
55:12 - just disable this system right after the
55:14 - first update the way we do that on a
55:16 - system base just do this. enable equals
55:18 - false that will make sure that this
55:20 - update is only going to run once and
55:22 - over here in order to get our spawn
55:24 - cubes config for that we can use a super
55:26 - useful function from the system API we
55:28 - just go inside system API and we call
55:30 - get Singleton this one like the name
55:32 - implies gets a Singleton so we just pass
55:34 - in the type so the spawn cubes config
55:37 - and this one is going to return our
55:38 - spawn cubes config now importantly this
55:41 - get single function this one has a whole
55:43 - bunch of really useful safety checks if
55:46 - you have zero entities with this
55:47 - component then it's going to fire an
55:49 - error so again really important that we
55:51 - add the required for update before this
55:53 - update runs and if you have more more
55:55 - than one meaning it's not really a singl
55:56 - ton if so then also fires an error so
55:59 - basically in order to call this get
56:01 - singl ton function in order to do this
56:03 - then this must actually be a Singleton
56:05 - meaning there has to be one and only one
56:07 - entity with this component these are
56:09 - some really great safety checks because
56:10 - they really enforce you to actually
56:12 - implement the proper singl ton pattern
56:14 - so with this we can now easily access
56:16 - the data inside of this component so
56:18 - let's just do a basic cycle through the
56:19 - amount to spawn so just say basic for
56:22 - starting on zero going until the spawn
56:23 - cubes config the am M to spawn i++ okay
56:26 - and now here let's simply spawn and the
56:28 - way that we spawn a brand new NTI prefab
56:30 - is really simple we just need to access
56:32 - the spawn cubes config and inside we've
56:34 - got the Q prefab entity and the way we
56:36 - spawn it is we just go inside the entity
56:38 - manager inside this one we call
56:42 - insentient a regular game object and
56:44 - this one takes a parameter for the
56:46 - source entity which is indeed our Q
56:47 - prefab entity just like this all this is
56:50 - doing is really just copying the source
56:51 - entity since entities are really just
56:54 - data inen ating simply means copying all
56:56 - the data in memory the only special
56:58 - thing that intiate does is how prefab
57:00 - entities they've got a prefab tag
57:02 - component this is a special te component
57:04 - that all the anti queries ignore since
57:06 - normally we don't want to run any logic
57:08 - on the prefabs themselves so when you
57:10 - call intiate it copies all the data from
57:12 - that prefab copies everything except
57:14 - that one prefab component and Y that's
57:16 - it super simple so this will return our
57:18 - spawn entity and then if we want we can
57:21 - initialize it so we can go inside the
57:23 - entity manager and call set component
57:25 - data and we can set any component to any
57:28 - data that we want but at the same time
57:30 - our prefab this one already has a bunch
57:32 - of authoring components these are still
57:34 - going to run when this is converted into
57:35 - an entity so we don't need to manually
57:37 - initialize all of these authoring
57:39 - components so for all this custom data
57:41 - we don't need to do anything else other
57:42 - than just spawn it although actually one
57:44 - real interesting thing is that the bake
57:46 - happens just once for the prefab meaning
57:48 - all of these authoring components they
57:50 - will be converted into the corresponding
57:52 - entity components just once so for
57:54 - example in this scenario we have our
57:56 - movement authoring components and for
57:58 - this one we defined over here on the
57:59 - baker it generates a random movement
58:01 - Factor but like I said this bake will
58:03 - only happen once for the prefab itself
58:05 - will not happen every single time that
58:07 - we instantiate the new entity from that
58:08 - prefab so in this case all of our SP
58:11 - objects they will all have the exact
58:12 - same movement Vector since again this
58:14 - bake only runs once so just something to
58:16 - be aware of the bake only runs once when
58:18 - the prefab is converted and not every
58:20 - time that you spawn an entity from that
58:22 - prefab so right here for set component
58:24 - we don't need to bother with all those
58:25 - custom components let's just put it in a
58:27 - random position so the set component
58:29 - data this one takes an entity so let's
58:31 - go inside our spawn entity and for the
58:33 - component dat in order to put it on a
58:34 - random position let's just modify the
58:36 - local transform this one takes a certain
58:39 - position and the position is a flow
58:41 - three so let's go ahead let's Implement
58:43 - using unity.
58:45 - mathematics and we're going to have our
58:47 - nice flow three again same thing as a
58:49 - vector 3 so XY Z so this is going to
58:52 - spawn it on some random position
58:54 - although actually here here's another
58:55 - thing that confused me quite a little
58:56 - bit when I first was researching this
58:58 - topic I initially just did this in order
59:00 - to spawn all the entities naturally if
59:02 - we test this it does work it will spawn
59:04 - the enties and it will position them on
59:06 - a random position so here let's quickly
59:08 - test and before we do let's actually get
59:10 - rid of the rotating cubes so we just
59:12 - want to spawn them so let's test and
59:14 - look at that nothing is actually visible
59:16 - however if we look in the entity's
59:17 - hierarchy yep all the cubes are indeed
59:19 - being spawned so again this is the thing
59:21 - that confused me a little bit and the
59:22 - reason has to do with the defaults and
59:24 - we can look over here on the local
59:25 - transform and see yep the position is
59:27 - indeed being set correctly but over here
59:29 - the scale the scale is a float and the
59:31 - float by default is going to come out to
59:32 - zero so that is why we don't see
59:34 - anything the entities are all actually
59:36 - there but since they've got a scale of
59:37 - zero they're not visible so technically
59:39 - when spawning a new local transform in
59:41 - setting some data technically you can
59:42 - just insert the ones that you need so in
59:44 - this case just a position but if you do
59:46 - know that everything else is going to
59:47 - default to zero so in order for you to
59:49 - not be confused like I am if you go
59:51 - ahead modify local transform just go
59:53 - ahead and also apply the rotation we can
59:55 - go inside the Quan this is the one
59:57 - inside the unity mathematics library and
59:59 - just use identity for the default
60:01 - rotation and again let's also put on the
60:03 - scale just so this one does not default
60:05 - to zero also another option exactly to
60:07 - solve this sort of problem is how the
60:09 - local transform if we go inside that
60:11 - class local transform this one has all
60:13 - sorts of helper functions similar to the
60:16 - rotate and the translate that we saw a
60:17 - while ago we can use this to
60:18 - automatically create the loal transform
60:20 - with a certain position rotation scale
60:22 - or just position like for example this
60:23 - one so we can use this one with our
60:25 - custom position and then basically this
60:27 - would create a local transform with a
60:29 - certain position and set the scale
60:30 - correctly to one so all of the helper
60:32 - functions inside the AL transform all of
60:34 - these can be quite useful okay so just
60:36 - like this if we test any up here we do
60:39 - see a bunch of Cubes being spawned and
60:41 - yep everything still works so all the
60:43 - same rotating and movement logic all of
60:44 - that is still working the same as
60:46 - previously we can easily go inside our
60:48 - spawning cubes component in order to
60:49 - spawn more or fewer cubes and there you
60:52 - go everything spawns and they all move
60:54 - all right awesome now I should note that
60:56 - there are more efficient methods for
60:58 - spawning entities if that's really the
61:00 - only thing that you want to do and if
61:01 - you want to spawn a ton of them if so
61:03 - then instead of instantiating them like
61:04 - this just literally one by one instead
61:07 - of that you can use the other functions
61:09 - over here for the instantiate so we've
61:11 - got this one that just takes an entity
61:12 - and spawns another entity or
61:14 - alternatively we have for example this
61:16 - one this one takes a source entity and
61:18 - then creates a number of entities that
61:20 - are all place inside a Native array so
61:22 - basically you construct a new native
61:23 - array with a certain size and then this
61:25 - one will inate entities to fill that
61:27 - entire array so if you spawn an array
61:29 - with 100 elements it is going to spawn
61:31 - 100 entities then you would simply cycle
61:33 - through that entire native array and set
61:34 - the component data on all of those
61:36 - entities so just be aware if you want to
61:38 - spawn tons of things it might be better
61:40 - off to spawn all of them at once instead
61:42 - of one by one individually also speaking
61:44 - of Maximum performance so over here this
61:46 - code works but for maximum performance
61:48 - instead of using over here entim
61:49 - manager. set component data instead of
61:52 - this one you can use system api. set
61:54 - component and Yep this will do the exact
61:56 - same thing but this one has some nice
61:57 - performance benefits so in general
61:59 - whenever possible for maximum
62:00 - performance you should prefer using the
62:02 - functions inside the system API since a
62:04 - lot of those will have some nice
62:05 - performance benefits as opposed to using
62:06 - the en manager directly but on a simple
62:09 - system like this one either one works
62:10 - and also another very important thing on
62:12 - spawning entities over here note how we
62:14 - are spawning them directly directly
62:16 - through the entity manager so that's
62:18 - perfectly fine here like I said
62:20 - technically this is not the most
62:21 - performant matter but over here we're
62:22 - only running this update one so really
62:24 - over here we have no concerns when it
62:26 - comes to Performance and there also is
62:27 - not cycling through anything so again
62:29 - also not an issue but for example let's
62:31 - say that our players firing bullets so
62:33 - let me just quickly make a system for
62:35 - the player to manually spawn some
62:36 - bullets let's go ahead and just create a
62:38 - new C script called the player shooting
62:41 - system and then over here let's make
62:43 - this one a system base so system base
62:45 - inside using unity. entities let's make
62:48 - it partial let's go ahead and Implement
62:50 - both these so both the on update and
62:53 - let's also do
62:54 - override void the uncreate and on the
62:57 - uncreate let's call require for update
62:59 - and make sure this one only runs when
63:01 - the player tag component actually exists
63:03 - okay so we have this one and then on
63:05 - update let's go ahead and fire some
63:07 - bullets and for firing bullets let's
63:08 - actually assly spawn a cube so let's
63:10 - consider a cube to be a bullet so let me
63:12 - just copy this and in order to fire it
63:14 - manually let's just check if the player
63:16 - is holding down the space so over here
63:18 - I'm just doing some basic testing code
63:20 - so just get key down so let's says for
63:22 - the space key so if the player is not
63:25 - pressing space if not then let's just
63:27 - return and if the player is pressing
63:29 - space then we're going to run this code
63:30 - then for the bullets instead of going
63:32 - through this amount to spawn instead of
63:33 - that let's cycle through all of our
63:35 - players so let's do for each system API
63:38 - let's first handle the query we're going
63:39 - to need to know the player's position in
63:41 - order to know where to spawn the bullet
63:42 - so let's use a ref rro because we only
63:44 - need to read it for the local transform
63:47 - so this is the only one that we're going
63:49 - to have so we just need the local
63:51 - transform in the query and let's also
63:53 - make sure this one only runs on the
63:54 - player so with all of the player tag
63:56 - component so we CLE through all the
63:58 - players we get the L transform then over
64:00 - here we are going to spawn the cube so
64:01 - that is going to act kind of like a
64:03 - bullet and then for spawning it let's
64:05 - simply spawn it directly on the player
64:06 - position so over here let's just go
64:08 - inside the local transform grab the
64:10 - value RL and let's just grab the same
64:13 - position okay so just a super simple
64:15 - system so when we are pressing space we
64:19 - are going to run this logic we get the
64:21 - singl ton in order to get our prefab
64:22 - reference and we're simply going to
64:24 - spawn a cube directly on top of the
64:26 - player so let's see so here we have the
64:28 - player and if I press on space and if
64:30 - there you go it does indeed spawn a cube
64:32 - directly on top of the player okay great
64:34 - so again we still have the exact same
64:35 - logic that we had previously just
64:37 - spawning it directly so over here we're
64:39 - still using the enti manager.
64:40 - instantiate however one very important
64:42 - thing about dots is that spawning or
64:44 - destroying entities that is what is
64:46 - known as a structural change basically
64:48 - the back end of dots that one is storing
64:50 - a ton of tightly packed arrays for all
64:52 - of the entities and all the components
64:54 - that's really how this system is so
64:55 - insanely performant but of course if you
64:57 - spawn new entity you are going to modify
64:59 - those underlying arrays so while cycling
65:02 - through some arrays while cycling
65:04 - through some entities while doing this
65:05 - you really don't want to modify it so in
65:07 - order to spawn or destroy entities while
65:09 - in a job or in a 4 in in this case you
65:11 - should actually use what is called an
65:13 - enti command buffer now I should also
65:15 - obviously say that this code actually
65:16 - works this is not a problem as we saw it
65:18 - is running perfectly but the reason why
65:21 - it works is because the new prefab
65:22 - entity does not match this at all we're
65:25 - spawning bullets not players so the new
65:27 - spawn entity will not have a player
65:28 - component so it does not match this
65:30 - query however if the instantiated entity
65:32 - archetype if that one did match this
65:34 - query then it would break this code so
65:36 - when that happens for that like I said
65:38 - you should spawn entities using an
65:39 - entity command buffer so let's see how
65:41 - that's done first we need to create a
65:43 - new inty command buffer so let's see new
65:46 - entity command buffer this one requires
65:48 - a certain allocator and over here there
65:50 - are a whole bunch of options depending
65:52 - on how long you want this command buffer
65:54 - to live now in this case we really just
65:56 - want to create it in order to spawn our
65:58 - entities and then we want it to be
65:59 - disposed of so let's use the simplest
66:01 - one the temp allocation this one is
66:03 - going to be created temporarily and then
66:05 - automatically it's going to be disposed
66:06 - of so we don't need to manually dispose
66:08 - it ourselves we do this in order to
66:10 - create a new entity command buffer but
66:12 - of course we don't actually want to
66:13 - create it for every single player we
66:15 - just want to create one and then spawn
66:17 - all kinds of entities so we do this
66:19 - outside of the four okay then we go
66:21 - inside the four and for each enemy and
66:23 - for each player we want to spawn our
66:24 - bullets so over here we go inside this
66:26 - one and we just call the same
66:27 - instantiate function this one as you can
66:29 - see also has all kinds of options we can
66:31 - spawn just one or multiple so for now
66:33 - let's just spawn one so let's literally
66:35 - just replace this exact same code with
66:37 - this one everything else is exactly the
66:38 - same however importantly this isn't
66:40 - actually instantiating The Entity over
66:42 - here over here we are simply adding that
66:44 - command to a command list that will be
66:46 - executing later so we do that in order
66:48 - to record an instantiate command and
66:50 - then same thing over here for the set
66:51 - component data except over here for some
66:53 - reason reason instead of being called
66:54 - set component data it is only called set
66:57 - component I'm not sure why this function
66:59 - is different but it just has a different
67:01 - name and everything else works the same
67:02 - so again this is also going to just
67:04 - register a command it is not actually
67:06 - going to set any component data just yet
67:08 - so we do this and basically over here we
67:10 - are queuing up all kinds of commands and
67:12 - then after our four after our cycle so
67:14 - basically after we are far away from
67:16 - those issues that I mentioned with all
67:17 - of those titly packed arrays after this
67:19 - in order to actually execute those
67:21 - commands we can go here and call
67:22 - playback and this one takes an enti
67:24 - manager that is actually going to spawn
67:25 - the entity so let's just pass in the
67:27 - reference to our entity manager and yep
67:29 - just like this so basically by doing it
67:31 - like this we have no structural changes
67:33 - over here directly inside the 4 each we
67:35 - are just recording some commands and we
67:38 - are only executing those commands after
67:40 - we exit the cycle and if we run the code
67:42 - everything is still going to work
67:43 - exactly the same so if I press space yep
67:45 - there you go it is spawning cubes
67:46 - everything works right so for spawning
67:48 - things usually you have these two
67:49 - options you can use an En command buffer
67:52 - or you can simply use the en manager
67:54 - instantiate and another note on getting
67:56 - maximum performance so here this works
67:58 - it is going to allocate the N command
68:00 - buffer and then dispose of it but in
68:01 - order to get a tiny bit more performance
68:03 - instead of using a temp allocator
68:05 - instead of that you should use the world
68:07 - update allocator this is a special
68:09 - allocator that exists by default it
68:11 - lasts for 1 to two frames and is
68:13 - automatically disposed of and has some
68:15 - nice performance benefits now speaking
68:17 - of structural changes one change is
68:19 - spawning or destroying enties so over
68:20 - here we are instantiating this is a
68:22 - structal change then yet another type of
68:25 - structural change is simply adding or
68:27 - moving components to an enti so if over
68:29 - here I go into the enti manager and I
68:31 - call add component this is going to be a
68:33 - structural change basically it has to do
68:36 - once again with how dots works in the
68:37 - background how the whole thing is based
68:39 - on entity archetypes which are specific
68:41 - groups of components so by adding or
68:44 - removing components you are basically
68:45 - creating a brand new archetype so things
68:47 - need to be moved around in memory so
68:49 - ideally you should avoid adding or
68:51 - removing components as much as possible
68:53 - if you need need to do something like
68:54 - that like for example let's say you need
68:55 - to Define if the player is in some kind
68:57 - of sunun state if so then instead of
68:59 - adding or removing some kind of stun
69:00 - component instead of that you can use
69:02 - what are called enable components which
69:05 - let you enable or disable without
69:06 - triggering a structural change so let's
69:08 - see exactly how that's done so first we
69:11 - build a component as usual so a new C
69:13 - script let's call it stun authoring and
69:15 - over here for the authoring component
69:17 - let's leave it just like this just empty
69:19 - and then let's make the actual empty
69:21 - component so let's go ahead call it just
69:23 - stun
69:24 - and for this one let's Implement I
69:26 - component data as usual but then also I
69:29 - enable component then if you want this
69:31 - can have any fields for any data that
69:33 - you want or it can simply be a simple
69:34 - tag component and then up here in our
69:36 - authoring component let's Implement our
69:38 - Baker class and in this one let's do the
69:41 - same thing so en entity let's call get
69:43 - entity and for this one this is on the
69:45 - player so sure let's pass in as Dynamic
69:48 - then let's add component onto this
69:50 - entity let's add a new stun component so
69:53 - just like this and then we can call the
69:55 - function set component enabled and we're
69:58 - going to modify the one of type stunn
70:00 - and then we can set it to either enabled
70:02 - or disabled first let's pass in the
70:04 - entity and then let's say we don't want
70:06 - the player to start off stun so let's
70:08 - say false okay so that's it super simple
70:10 - so we basically just implement the I
70:12 - enable component and then when adding
70:14 - that component we can optionally set it
70:15 - as enabled or disabled then over here in
70:18 - our game let's go ahead and just add the
70:19 - stun authoring component and then for
70:21 - example over here on the player shooting
70:23 - system on this one we are cycling
70:25 - through all the players in order to
70:26 - spawn all the bullets so we are calling
70:29 - with all to see all the players and in
70:31 - this case we only want to run this query
70:33 - if the player is not stunned so for that
70:35 - we can add the WID disabled so this
70:38 - query will only work if a certain enable
70:41 - component is actually disabled so let's
70:43 - go with our stun just like this so This
70:45 - query this for each will only run on
70:47 - entities that have a local transform
70:49 - component also a player tag and also a
70:52 - sun component that is set to disign
70:53 - disabled and then just for testing let's
70:55 - put up here just a simple testing code
70:57 - just to swap the stunt state so let's
71:00 - test input get key down for some testing
71:03 - Keys let's go with the T key in this
71:06 - case for some testing we know that we
71:07 - only have one player so again just for
71:09 - some simple testing code let's go inside
71:12 - the system API to get the Singleton
71:14 - entity of type player and then we can go
71:17 - The Entity manager and call set
71:19 - component enabled of the stun component
71:22 - on this player entity
71:24 - and when we press T let's set it to yes
71:26 - let's set it to stun and on another key
71:28 - so let's say on a y let's set it to not
71:30 - stun okay just like this let's see all
71:33 - right so here we are and we can actually
71:35 - look at the player so we can select the
71:37 - player and go inside the N inspector and
71:39 - over here yep we do see up here on the
71:41 - tags we do see there's a stun tag and
71:43 - right now if I press on Space yep there
71:45 - you go it is spawning a bullet however
71:47 - now I press on T and yep note how that
71:49 - one became checked and now if I press on
71:52 - Space again and nope it is is not
71:53 - spawning anything because again it is
71:55 - only running that query if the player is
71:57 - not stunned so press on y that one
71:59 - becomes un stunned and space and there
72:01 - you go it's still work so stun un stun
72:03 - everything works all right great now
72:05 - like I said the main benefit is this is
72:06 - not a structural change which makes
72:08 - enabling or disabling these State these
72:11 - enable components makes it super fast so
72:14 - instead of adding or removing this
72:15 - component instead of that we just decid
72:17 - it enable or disable it okay so now
72:19 - let's cover one of the most important
72:20 - things about ECS which is how to
72:22 - interact with the from game objects this
72:24 - is very important because it is the
72:26 - recommend method for working with dots
72:28 - there are many things for which game
72:30 - objects are still excellent so the
72:32 - recommend workflow is mixing both dots
72:34 - and game objects rather than going 100%
72:36 - with either of them so over here I
72:38 - previously prepared this simple game
72:40 - object it's a simple shoot popup so
72:42 - inside I really just have some text just
72:44 - saying shoot and then I've got this
72:46 - simple script so over here really on
72:48 - update it just moves this component
72:49 - upwards and after a certain amount of
72:51 - time just destroys itself again super
72:53 - simple note how this is a regular script
72:56 - absolutely nothing over here on this
72:58 - popup absolutely nothing has to do with
72:59 - either entities or dots this is a
73:01 - regular game object regular mon Behavior
73:03 - component the game object itself again
73:05 - like I said regular game object
73:06 - absolutely nothing to do with any
73:08 - entities what we want is basally spawn
73:10 - this regular game object whenever the
73:11 - player entity spawns a new entity B so
73:14 - let's make some kind of script to handle
73:15 - that let's go ahead create a regular
73:18 - monob Behavior regular C script called
73:20 - the player shoot manager now let's make
73:22 - a regular game object to run the script
73:24 - and again importantly we want a
73:26 - perfectly regular game object so we do
73:27 - not want to create anything inside the
73:29 - entity subscene no just out here and
73:31 - let's create an empty regular game
73:33 - object let's go ahead give it the same
73:35 - name and reset the transform and let's
73:37 - attach our component okay just like this
73:40 - and on this script basically we want to
73:42 - know when the player is actually
73:43 - shooting and when they do then we want
73:44 - to spawn our prefab so over here we have
73:47 - our play shooting system where we are
73:48 - actually spawning our bullets and now
73:50 - while ago I made this a system base and
73:52 - like I said the difference between
73:54 - system Bas and I system is that system
73:56 - Bas is meant for manage components and
73:57 - is system is meant for unmanage and one
74:00 - of the easiest ways for us to connect
74:01 - both game objects and the entity systems
74:04 - when the easiest ways is simply by using
74:06 - an event so over here since we are in
74:08 - system based we can use manage
74:09 - components so let's use a regular
74:11 - managed event handler for handling some
74:13 - regular C events so just super simple
74:15 - public event event handler again super
74:18 - simple event let's call it on shoot
74:21 - event handler is a type of delate which
74:23 - is a manage type now if you don't know
74:25 - about events I covered them in detail in
74:27 - a previous video same thing for
74:28 - delegates okay so basically with this we
74:30 - have our normal event and then down here
74:32 - when we shoot let's simply fire off the
74:34 - event so again really simple just do the
74:37 - exact same thing that we're used to
74:38 - using so just invent let's invoke it
74:41 - with usual standard this event ARS empty
74:44 - also by the way one more quick tip over
74:46 - here when doing system api. query for
74:49 - this one just in case we need to know
74:50 - the enti like for example over here on
74:52 - the event it might be useful to know
74:53 - know which player is actually shooting a
74:55 - bullet for this one one of the many
74:57 - options that we can add over here onto
74:58 - the query one of the many options is
75:01 - with entity access and if we do then our
75:04 - entity over here the tupon that this
75:06 - returns this one is going to have an
75:07 - reference to an entity right over here
75:09 - at the end so for example in this case
75:11 - we can do this in order to over here
75:13 - when we shoot the event we can pass in
75:14 - the entty reference as who is actually
75:16 - shooting this boat okay so just like
75:19 - this pretty simple we've got a regular
75:20 - shooting event and then on our regular
75:23 - game object script let's just lean this
75:25 - up on this one we really just need to
75:27 - hook onto that event and for that that
75:29 - means that we do need to find some
75:30 - reference to this player shooting system
75:32 - and thankfully that's pretty easy since
75:34 - there is only ever one system in a world
75:36 - which means the systems are always
75:37 - Singleton so that makes it really easy
75:39 - to find we can just go over here on the
75:41 - players ship manager let's do a private
75:43 - void start in order to hook onto our
75:44 - event however over here we can't access
75:47 - the system API this one does not work
75:49 - this one only works on systems as we can
75:51 - see you may not use the system API
75:53 - member outside of a system so instead of
75:55 - this the way that we find that is we
75:57 - first need to access the world and we
75:59 - can access the default World by going
76:00 - into world. default game object
76:02 - injection world and over here we can get
76:04 - an existing system and in this case
76:06 - since we are using a system base we need
76:08 - to use the manage version so for this
76:10 - one for the player shooting system and
76:13 - now that we have this one we can go and
76:14 - do the same thing so just listen to the
76:16 - event so just some usual code nothing to
76:18 - do with any entities the only entity
76:20 - thing is over here converting the center
76:22 - into an entity so an entity for the
76:24 - player entity and let's go ahead grab
76:26 - the sender and we need to convert this
76:28 - as an entity so let's go ahead and cast
76:30 - it down into an entity so we have this
76:33 - and now in order to know where to spawn
76:34 - our prefab for that we need to know the
76:36 - position of this player entity which
76:38 - means we need to access this player
76:39 - entity the local transform so for that
76:41 - let's go inside the world default GIC
76:43 - injection world let's grab the nty
76:45 - manager and from that one we can grab
76:47 - the get component data we want the local
76:50 - transform component and the entity that
76:52 - is going to be our our player entity so
76:54 - this is going to return our local
76:55 - transform components then when we have
76:58 - this one we've got the position so this
76:59 - contains the position of the player so
77:01 - now let's just do a regular game object
77:03 - ineni so insen and we just need the
77:06 - reference up here so let's go up here
77:07 - and add it as a regular field so
77:09 - serialized field private game object for
77:12 - the shoot popup prefab so again a
77:15 - regular game object component and then
77:17 - over here let's go ahead let's Spa on
77:19 - this position with no rotation so
77:20 - querian identity and by the way note how
77:23 - even though the position this one is a
77:24 - FL 3 it automatically gets converted
77:26 - into a vector 3 okay so that's it super
77:28 - simple so we basically just go through
77:30 - the default World in order to get the
77:32 - instance of our shooting system and then
77:34 - from that one we hook onto the event
77:36 - just a regular event and then we grab
77:38 - some data from that entity and spawn our
77:40 - regular game object let's test so just
77:43 - over here on the player shoot manager
77:44 - let's just make sure to add the shoot
77:46 - popup and let's test so here we are and
77:48 - if I press on space and yep there you go
77:50 - there it is the shoot popup it does work
77:52 - it does spawn the player and yep
77:54 - everything works great all right Awesome
77:56 - Again note how this popup this is a
77:58 - completely normal game object element
78:00 - the player itself is an entity and it is
78:02 - being controlled by an entity system but
78:04 - this game object this is an entirely
78:06 - game object the popup has absolutely
78:08 - nothing directly related to any entities
78:11 - we've got an entity over here then a
78:12 - game object over here and we simply have
78:15 - a script just a regular manager just a
78:17 - regular monob Behavior component and
78:18 - this one is handling the connection
78:20 - between one and the other so as you can
78:21 - see this is one way for how you can
78:23 - connect a game object onto an entity you
78:25 - can have some kind of entity system that
78:27 - fires off some kind of event and then
78:30 - have some kind of script that listens to
78:31 - that event and does whatever it wants
78:33 - like for example spawning a game object
78:35 - this works so basically over here we
78:37 - have the monob behavior side grabbing
78:38 - some data directly from the N side
78:41 - however alternatively we could also do
78:42 - the opposite we could have our system in
78:45 - order to call some kind of function
78:46 - directly on the mono Behavior so for
78:48 - that the super simple way is pretty much
78:49 - exactly the same thing that we did so we
78:51 - grab the existing system which is going
78:53 - to be a Singleton so you can pretty much
78:55 - just convert this regular am of behavior
78:56 - also into a Singleton so let's use the
78:58 - usual Singleton pattern that I've used
79:00 - in so many videos so for the player
79:02 - shoot manager call it instance make it
79:05 - with a public get and a private set then
79:07 - let's do we private vo awake and on
79:09 - awake let's set the instance equals this
79:11 - okay so we have our nice static instance
79:14 - and now instead of having these events
79:15 - instead of having this mon Behavior go
79:17 - grab data from the other side instead of
79:19 - that let's go ahead and make another
79:21 - function so let's make a public function
79:24 - let's call it player shoot and let's
79:26 - receive Vector 3 for the player position
79:28 - then over here we just do literally the
79:30 - same thing so we call instantiate shoot
79:32 - that one onto this player position just
79:34 - like this and over here on the player
79:36 - shooting system let's go down to where
79:38 - we are doing all this and now we can
79:40 - just go the player shoot manager access
79:42 - the instance and call the player shoot
79:43 - function all right yep just like this
79:46 - let's test so here we are press on space
79:48 - and yep everything still works exactly
79:50 - the same so as you can see there are
79:51 - multiple multiple ways to have our game
79:53 - objects and entities interact with one
79:55 - another you can have the monob behavior
79:57 - side as the ECS side for some data or
80:00 - the other way you can have the ECS side
80:02 - like some kind of system access some
80:04 - kind of mon behavior and tell it to do
80:06 - something or yet another option you have
80:08 - is just know there are ways to store
80:10 - manag data directly inside a component
80:12 - you can use manage components they do
80:14 - have a whole bunch of limitations but it
80:15 - is possible so for example you could
80:18 - have some kind of manage component that
80:19 - holds a reference directly to some kind
80:21 - of game object like for example particle
80:23 - system so you can do that and have the
80:24 - system directly interact with that
80:26 - manage component and do any kind of
80:28 - function any kind of data do anything
80:30 - with that manage component so basically
80:31 - all those options work so there are
80:33 - plenty of ways for you to mix both game
80:35 - objects and entities okay so we already
80:37 - covered a lot of stuff that you need to
80:38 - get St but dots is huge so there's
80:40 - really tons more stuff to learn let me
80:43 - quickly just go through some tiny
80:44 - details like over here on systems when
80:46 - doing a query we already saw a whole
80:48 - bunch of options but there's a whole
80:49 - bunch more you can just search for wi
80:51 - and see all of them so with all this one
80:53 - makes sure that all of the ones CU over
80:55 - here you can actually include more than
80:57 - one type you can include multiple
80:59 - components so if you use with all that
81:00 - one is going to make sure to run this
81:02 - query on all entities that have all of
81:05 - these components alternatively you have
81:07 - the with any so this one you can pass in
81:09 - a bunch of components and it's going to
81:10 - run on entities that have any of those
81:12 - then you also have with none which is
81:14 - going to run on entities that do not
81:15 - have any of those components also by the
81:17 - way over here I said with disabled but
81:20 - if stun was enabled and you only want to
81:22 - run some on players that are sun there
81:24 - is no with enabled instead if you want a
81:26 - component that's enabled that really
81:27 - just counts as a regular component so
81:29 - you just put it over here with all stun
81:31 - and this would only run on things that
81:32 - also have a stunt component and it's
81:34 - also enabled also by the way all of
81:36 - those are also available over here when
81:37 - you use a job on this one you can work
81:40 - with the attributes so again you can see
81:42 - with all with any with the and so on
81:45 - then on aspects for this one you can
81:47 - also have an entity field so you can do
81:48 - public read only entity entity this
81:51 - works and basically as you do some kind
81:53 - of query against this aspect it is going
81:55 - to automatically fill in this entity
81:56 - with that entity then in your jobs if
81:59 - you somehow have some kind of native
82:01 - array component native array or native
82:03 - list or any of these collections if so
82:05 - then the job will basically consider
82:06 - this a read write field meaning if you
82:08 - have multiple jobs working on the same
82:10 - native array it is going to run one
82:12 - after the other instead of running them
82:13 - concurrently if you do know that you are
82:15 - never actually going to write to the
82:16 - same index on multiple jobs if so then
82:19 - you can use the attribute read only that
82:21 - basically says that this ative array
82:23 - this one is only used for reading so you
82:25 - can run multiple jobs with this field
82:26 - concurrently then on systems themselves
82:29 - you also have a whole bunch of
82:30 - attributes the main one is the update
82:33 - before after or in group with these you
82:35 - can basically have some more control
82:36 - over when the systems run for example
82:38 - over here we can look inside the systems
82:40 - window to see all the various systems
82:42 - and note all of these various system
82:44 - groups so by using these like for
82:46 - example update in group you can use this
82:48 - in order to Define in which group you
82:50 - want to run this system on or you can
82:51 - use the update or after to update before
82:53 - or after any of these groups any of
82:55 - these systems then for the systems over
82:57 - here on the system base if we inspect
82:59 - this if we go to definition we can see
83:01 - these have a bunch more functions for
83:03 - example we already saw we can override
83:05 - the on update but there is also one
83:07 - called on start running onop running and
83:10 - so on so for example this is related to
83:11 - how on various on create on various of
83:13 - those we add the required update
83:15 - component meaning the system will not
83:17 - start running until an entity with that
83:19 - component actually exists so you can use
83:20 - these two the on start running and on
83:22 - stop running on the system base and if
83:24 - you are working in an i system for this
83:26 - one you can do the same thing and that
83:28 - exists over here on the I system start
83:29 - stop so you can implement this one in
83:31 - order to have the access to the onart
83:33 - and onstop running also speaking of
83:35 - systems they actually have an entty
83:36 - connected to them so here if we looking
83:38 - the enti Hier key look at how right now
83:40 - it's actually empty and if I start
83:42 - running yep there you go look at all of
83:43 - these entities that were created all of
83:45 - these for a system for example over here
83:47 - the play shooting system this is the
83:48 - entity related to that system this can
83:50 - be really useful to sore some data that
83:52 - is directly related onto a system
83:54 - technically you can also store data
83:56 - directly on the system so over here you
83:57 - can store some Fields but in keeping
83:59 - with the data oriented design you should
84:01 - really store any system data directly on
84:03 - the system entity in order to access
84:05 - that entity for example when you go
84:07 - inside the entity manager when you do
84:09 - for example set component data on this
84:11 - one there is a version which takes an
84:13 - entity but then there's also one that
84:15 - takes a system handle so you do and go
84:17 - through the system state in order to get
84:19 - the system handle and just like that you
84:21 - can access the underlying for this
84:23 - system then something I mentioned a
84:24 - while ago are the native arrays those
84:26 - exist in the collections package so
84:28 - you've got native array you've got all
84:30 - kinds of those and you also have native
84:31 - list this one also exists like name
84:34 - implies these are arrays or lists as
84:35 - usual but they have native memory access
84:38 - meaning they are extremely fast they are
84:40 - burst compatible but you must be very
84:42 - careful to dispose them so for example
84:44 - if I create a native array of type int I
84:47 - can do this native array and then when
84:49 - constructing I give it some kind of size
84:51 - and some kind of allocator so let's say
84:53 - five and then allocator we've got all of
84:55 - these so if you want to persist you
84:57 - would create it for example over here on
84:58 - the syston create and then you would
85:00 - reuse it if you're using it in a job use
85:02 - some kind of temp job if something that
85:04 - you only need to process for pretty much
85:06 - just one frame use temp also importantly
85:08 - is if you use St then the system will
85:10 - basically automatically dispose of this
85:12 - array by itself however if you use the
85:14 - other ones so for example if I use the
85:15 - persistent one if I do this then this
85:17 - memory won't be allocated forever so if
85:20 - you were to do this and spawn one of
85:21 - these arrays directly over here inside
85:23 - an on update then basically you end up
85:25 - with a memory leak so if you work with
85:27 - Native arrays or native list or anything
85:28 - like that if you don't use temp then you
85:30 - need to make sure to call dispose then
85:32 - in terms of holding different sizes of
85:34 - data inside an entity for that you have
85:36 - Dynamic buffers these are basically
85:38 - arrays that you can hold as a component
85:40 - in an entity basically a component
85:42 - usually has a certain number of fields
85:44 - but with a dynamic buffer you can have
85:45 - something that increase or shrinks
85:47 - basically has any size so that's a bunch
85:50 - more things for you to be aware of and
85:51 - to research like I said dots is a
85:53 - massive thing but honestly I think the
85:54 - basics are really not that difficult to
85:56 - learn so I do hope that this video
85:58 - helped with that in learning the basics
85:59 - if you just learned those and you
86:01 - already have access to an extremely
86:02 - powerful tool and if you want to learn
86:04 - more then I highly recommend you look at
86:05 - the documentation it is really detailed
86:07 - and very well written there's a project
86:09 - on GitHub with a whole ton of samples it
86:12 - even includes a bunch of walkth through
86:14 - videos so if you want to continue
86:15 - learning more about dots I highly
86:16 - recommend you go through those basically
86:18 - that's what I did for my own research
86:19 - for these past few weeks if you found
86:21 - this video helpful and you're feeling
86:22 - generous and consider dropping a super
86:24 - thanks on the video or simply please hit
86:26 - the Subscribe and the like buttons it's
86:27 - a small thing but those really do help
86:29 - so thanks and like I mentioned in the
86:31 - beginning I'd love to do a do course I'm
86:32 - planning to do it after I finish my C
86:34 - course so do let me know in the comments
86:36 - if you would be interested in that and
86:38 - if so let me know what gen you'd like to
86:39 - see maybe a factory game or an RTS maybe
86:42 - Tower Defense third person shooter
86:43 - vampire survivors like there's really
86:45 - many things for which dots would be a
86:47 - great tool for so let me know in the
86:48 - comments and if you use Unity at all
86:50 - then check out my ultimate unity over
86:51 - course it features over 70 lectures each
86:54 - covering a different tool or feature of
86:55 - the engine including many of which you
86:57 - might not know about that might be super
86:58 - useful for whatever project you're
86:59 - currently working on okay so I really
87:01 - hope this video helped you get started
87:03 - with DOs thank you for watching and I'll
87:04 - see you next
87:21 - time and

Cleaned transcript:

hello and welcome I'm your Cod Mony let's learn how to get started using n dots this is a technology stack that can provide some insane performance results literally 100x faster in some cases and thankfully learning the basics that is actually pretty simple here let's learn what is a component what is a system and what is an entity then we're going to learn how to create a job and run with the burst compiler for some insane performance and also of course see how to combine both entities and game objects and interact with them back and forth this video actually turned out pretty long because there's so much to cover there's time steps throughout the video I've been re searching all documentation and working on this video for the past two weeks so if you find the video helpful and you're feeling generous go ahead and drop a super thanks on the video or simply hit the Subscribe and the like buttons it's a small thing but it really does help so thanks also huge thanks to Danny from DM do seam who helped me by answering tons of my dots questions so this video could be as accurate as possible now over here on this video this is going to be a technical tutorial on how to start using dots but if you're looking for a hand level overview on the theory behind what is dots what is ECS and so on for that I highly recommend the video from Channel turb makes games that one is a really excellent explainer of all the components that makeup dots as well as the pros and cons and when to use it and when not to use it so go ahead and watch that video for the theory and over here let's learn a technical part on how to actually use it although let me also quickly remind you that you don't have to go full dots or full game objects the ideal workflow is to mix them both so dots is really just another tool in your toolbox it is indeed a little bit more complex compared to game objects as we're going to see in a little bit it is an advanced tool after all although it's honestly not really too complex once you understand the basics and of course that comp actually buys a ton of excellent benefits so even if you're working on a relatively simple game I would still encourage you to watch this whole video to the end just to be aware just to remember that you have this tool at your disposal in case you need some excellent performance at some point in the future you don't have to use it for everything but for some case it is an absolutely excellent tool and also just a question for my own purposes I would love to do a complete dots course in the next few months so let me know in the comments if you would be interested in that and specifically let me know what type of game you'd like to see made now the obvious answers would be a factory game or an RTS but could also be Tower Defense third person shooter vampire survivors like something like that there are plenty of genres where dots makes a lot of sense so do let me know your thoughts in the comments I'm currently working on a complete C course and after that one I plan to work on a dots course or if you're watching this several months in future maybe you hav already done it so check the pen comment and if you use Unity at all then check out my ultimate unity overview course to learn how to make better games faster it features over 70 lectures each covering a different tool or feature of the engine including many of which you might not know about and might be super useful for whatever project you're currently working on okay so let's begin by making the most basic demo possible let's make just a simple Cube rotating now before we do that just some notes in terms of unity version over here I'm using the unity 22 LTS although you can also use the 23 beta if you like it should be pretty much the same and if you're watching this many months or years in the future and using Unity 6 then should still be mostly the same then dots uses a lot of source code generation in order to simplify various things so for that you need to be using an ID that supports that in my case I'm using visual studio 22 to the free community version and then they also recommend that you modify the domain reload setting so for that here in unity let's go into edit and then project settings then on left side go into the editor Tab and over here let's scroll down find here the interplay mode settings and let's enable these and make sure these two are unticked now importantly you should know one side effect of this is that your static fields and events those will not be reset by default meaning if you set some data on a static field then you stop playing and start playing again that data will persist whereas if you have mean reloading enabled if so it will always clear the data before starting so just be aware of that side effect just be aware of what this option does and when working with dots be extra careful about any static fields or events all right so here in the editor let's begin by installing the package so as usual let's open up the package manager up here up top let's go into the entity registry and then over here let's scroll down and find the entities package alternatively if you don't see it you can also insult by name so com. en. entities you would basically go up here on the top left corner add a package by name and put in this name community. entities but as long as you are using a recent version you should be able to see it so let's just go ahead and install okay done now the other one that we need in order to be able to render things is the enties graphics you only need this one if you actually want to render entities meaning you can use just entities without any entities visual but over here in this emo I will indeed be rendering some entities so let's go ahead and install this one as well now one more note related to this NT Graphics this one only works with either urp or hrp it does not work with the builtin rer pipeline so here in my project I have my project set up to use urp the universal R Pipeline and they also recommend that entities rendering be used with forward plus rendering so let's go ahead and set that up so let's go into the render pipeline asset and inside let's go inside the actual render object and over here for rendering path let's put it on forward plus okay that should do it let's also make sure all the other packages related to dots are also installed again remember how dots is really not just one thing it is actually composed of the enti component system or ECS that's the en package that we just installed but then it's also composed of the job system and burst those should both automatically be installed as dependencies so if you look over here burst Yep this one should be installed then the other one is the mathematics Library yep also installed and finally the collections Library yep also installed okay great so we have all the packages that we need all right now let's begin by making our first entity and the way we do that is first we create a subscene so over here on the hierarchy click on the plus icon and let's create a brand new subscene then give it some kind of name so over here entities subscene all right there it is here we have our subscene now this subscene this is an ECS specific thing basically any objects that we place inside of this subscene all of those will automatically be converted into entities so inside for example let's create a new game object and let's go inside 3D and just make a basic Cube and yep look how that one is indeed inside the entity subscene and now this game object this will automatically be converted into an entity if we look on the inspector and down here we can see something for the entity baking preview you can click to expand this and over here basically we can see all the components that won't be baked based on these regular components also one very important thing the system is smart enough to be optimized to only create entities when they are needed so if we create a cube like this with these Vision components then it will indeed create an entity and add all of these components however if I go in the subscene and I create just an empty game object if I do yep nothing shows up here because this one won't actually be baked if the game object has no components nothing at all then it will not actually create an enti so with the cube selected another way that we can see the entty components is on the inspector on the top right corner we have the circle button and if we click on it we can basically tell on the inspector between various modes right now we are seeing the default mode which shows usual game object representation so the usual components you're used to and then if we click on runtime yep now here we can see the entity representation so instead of the normal transform component we have a local to world then we've got a bunch of things to handle rendering render bounds and so on so basically these are all of the entity components that are created automatically by the baking system compared to the regular monom Behavior components by the way here's one quick tip instead of over here constantly jumping back and forth between these two modes we can basically leave this regular inspector as a regular game object inspector and then we can right click on the tab and let's create add new tab add a new inspector Tab and on this one let's go ahead and swap it out into the entities this way we have two inspectors so we can very easily swap back and forth between the two representations now another place where we can see entities is on the entities hierarchy so for that let's go into window and go down into entities and open up the hierarchy and yep in here we can see all of the various entities right now it still looks ex the same as the regular hierarchy but if we now hit on play yep here we see all of the entities that were automatically generated and again if I select the game object the one that has no components like I said this one does not create an entity so if you look in the inspector yep it says this one does not exist anymore because again this one does not get baked because it is completely empty okay so for now let's get rid of the game object and we can actually put the N hierarchy next to the regular hierarchy and for visual just for fun let's attach a different material just to make it easy to see so I'm going to go into the regular inspector again the regular game object inspector with usual components that you're used to and over here I'm going to drag the material and yep and I can move it around and again note how all I'm doing is really just interacting with game objects and then it everything gets automatically converted into entities okay so now that we have our entity next thing we want to create is a component and the way we do that is with a script so let's go ahead right click on the project files and let's create a new C script and for this one let's call it rotate speed now importantly we do not attach it to anything so just create the script and let's open it and over here first let's just get rid of the default functions okay so now we need to do two things first we do not inherit from monob Behavior instead we are going to implement I component data it's this one which exists inside namespace unity. entities so make sure to add the using and Yep this is it it and secondly this is not going to be a class instead it is going to be a struct now if you don't know differences between those two go check out my quick video on it basically strs and classes those are stored in different places in memory and the way that doarts is so insanely fast is really mostly all about memory management so a lot of things in dots are used as structs usually that just involves replacing class with struct but like I said definitely go watch my video on that topic if you're going to use dots you absolutely must know the differences between those two otherwise you will go crazy at some point in the future if you don't know how some things work as copies and some work as references okay so with this we have our component and components are basically just containers for data so over here we can place whatever that we want for example let's just add a public float and just call it value this is going to be our rotation speed now normally I always tell you not to make everything public normally I tell you to make Fields private and if you need to you can make some functions to get and set that field and technically over here on the component you can add functions that is allowed but you really should not do that component comp should really only hold data and no logic so for components you can really just Define a personal rule to always make them public since they only ever hold data kind of similar to the rule that I defined for myself when working with script M objects I also use those only as data containers and I also make those with public Fields okay so this is just our super basic component just one piece of data however just like this we still haven't attach it to our entity if here in the editor we run our code look in the empty inspector and nope we still don't have our custom component and since this one is an ey component data instead of a mono Behavior because that we can simply just drag it this does not work so in order to attach components to entities we have several ways of doing that in order to use the exact same game object workflow that you're used to for that we need to use the baking system and the way we do that is actually super simple we just need to make what is called an authoring component so let's make a UC sh script and for this one let's call it rotate speed authoring now here technically you don't have to append authoring to the name it's really just a nice convention to follow so let's make this script and let's open it and now this one is indeed going to be a regular mono Behavior component and over here we can add whatever films we want so let's add the exact same ones that we had in our component so let's just add a public float for our field now over here in the editor let's select the cube let's go into the regular game object inspector and over here let's just attach the component just like any other component so let's attach it and put the field let's say on three okay great so basically now we have a simple component that just has our value field and we have a simple authoring component that we then attached to our game object what is left is really just our Baker in order to turn one into the other one now the baker is going to be a class and by convention we should put the baker class directly inside the authoring class you don't have to but it just helps to keep things organized so let's make a private class call it Baker again the name also doesn't matter just a nice convention and now what does matter is that we actually extend the baker class this one takes a generic if you don't know about generics check out my quick video on them and then we put in the time for our authoring class so in this case the rot T speed authoring okay so this is what we do and then in order to use this one this one is inside unity. enties so let's make sure to do that and now in order to do this we need to implement this abstract class which requires implementing this bake method okay so we have this and now here is where we basically convert the data from our authoring component into our actual ECS component so we're going to use the function add component now importantly this is the baker add component this is not the regular game object add component and for this one first we require entity reference so for that we can use the function get entity this one requires us to use a transform usage Flags this is an optimization thing basically if you set it as none then the entity won't be converted with no entity transform component so if you never need to move an entity or have a position in the world and there's really no reason to include a transform component but in this case for our demo we do want to transform we want to rotate our Cube so for that instead of none let's go with Dynamic and this going to return an entity reference and then we can simply use this entity reference to add our comp component and then for our component we really just create the one that we just created so the rotate speed component and then we initialize it with our values so in this case the rotate speed value let's go inside the authoring component and grab the value okay so yep that's it in summary we have our rotate speed this is a regular component so I component data just an ECS component and inside we just have a value field but this one cannot be attached to a game object so for that we create an authoring component this one is a mon behavior and this one we do attach to our object we expose it field on this one by convention it should probably be the exact same name as the one on the component but techically it doesn't have to be so here in the editor we added that mod Behavior component and we assign the value then we created a baker class that extends the baker entities class and on this one we need to overwrite this function and basically the ECS system will automatically run this function it will pass in this reference for the authoring component and then over here we get the entity that Baker is currently being run on and we call add component in order to add our custom component and then we just manually assign the value to the exact same value okay so with this let's test all right so here's our en let's select it go into the entities inspector and let's scroll down and seeing and yep here we have our rotate speed component and yep the value is indeed the one that we set all right awesome now just one more note on a possible optimization here if you want you can do it like this so basically having two separate scripts one for just the component and one for just the authoring component or alternatively you can simplify this and just put everything on the same script so over here on the rotate speed I'm literally just going to copy this code and paste it directly inside of this file then over here on the editor just delete the rotate speed script so we just have one file one script and inside that we have both the component the authoring and the baker so yep everything still works exactly the same except now it's all much more compact all in just one script although one note on this method which is that the file name the name for the actual file for the script this one has to match actual authoring component it needs to match a script that we are using over here on the mon Behavior if we rename this file to something different to just the file name of the actual component if we did it would not work because Unity expects the file name to match a mono Behavior class name so if you follow this method of putting everything inside one file one script then just make sure that file name actually matches the authoring monob behavior component Okay so we've already learned about entities and components however just like this we're really just attaching some data to an entity nothing is moving nothing is changing so what we are missing is the s in ECS which are these systems systems are what actually modifies the data in the components so let's begin by making a brand new C script call this the rotating Cube system and again we don't attach it to anything let's just open it and now here again same thing we do not extend mod Behavior instead for a system we have two possible ways of making them one way is to make this a class and extend system base inside unity. entities this is how you make a system that deals with manage types so things like game objects transforms delegates and so on also a note is this needs to be marked as a partial class this this comes back to what I mentioned in the beginning of how dots is very much based on Source generation basically we're marking this as partial and then the dot system will write the rest of the code so this is one way making a system base like I said this one is for managed data and the other way is instead of making a class we make it a struct and set of system base we Implement I system so this one is meant for unmanaged types so strs inss bones and so on which in turn means you can use burst on this one making it much faster basically by default you should probably always try to make an i system unless you spefic spefically need to use a manage type in which case use a system base however also let me make sure one very important thing about systems in general both High system and system base both of them run on the main thread just making something a system does not make it multi thread for that we need to make a proper job which I'm going to cover later on the video okay so here let's use an i system so it needs to be partial needs to be struct and needs to implement I system then over here on the I system we can Implement three functions we can actually inspect the system definition so let's go ahead right click go to that definition and here we see what we can Implement so we can implement the oncreate function this one happens when the system itself is created we can Implement on Destroy so this one is called when this system is destroyed then of course we have the onupdate and this one runs on every update so pretty much the same thing as the normal mod Behavior update so let's go ahead and Implement our on update method so just go ahead do this our P void on update and now here we want the system to run and do something on some entity right now we really just want to rotate our Cube and the way that we do that is with a 4 each and in this case we want to find entities that have our rotate speed component so we're going to find the rotate speed rotate speed in and then basically do a query for all of our components so for that we go inside the system API and we call query and then we pass in the types that we're looking for so in this case rotate speed now another really important part when working with ECS is being very clear with when we want to write or when you just want to read and the way we do that is by either writing ref RW or ref rro this is a class that use generics once again so don't be confused about the amount of angle brackets over here like I said we have refr W so this one is meant for read WR but if we never need to modify anything then we can use ref for read only this becomes really important later on when scheduling jobs since you can have multiple jobs running concurrently if they're only reading the same data but you can only ever write one job at a time in this case we really just want to read the rotate speed so let's go with ref and of course over here for the parameter instead of just rotate speed we also have ref of type rotate speed although let me also make one note technically like we saw if we erase the refo technically this is valid code we don't have any errors basically like this the default to read only however it also using a copy instead of a point of reference which can cause some performance concerns so even though this is technically valid code you should always explicit mention whether it's refr w or refer okay so basically these we do a for each on all the entities that have our rotate speed component but in order to rotate them for that we also need the transform so over here in our query let's also include the local transform component this one exists inside using unity. transforms so we have this one and for this one we do want to modify the transform in order to actually rotate the object so for this one let's go with ref RW and for our iterator variable instead of having just one put it inside parentheses because over here we have basically a ton so the ref RW for the local transform like this by by the way one note here you can write code like this meaning Define the types and the name for the variables or alternatively you can also just use VAR so just VAR and then just the names of the variables so this also perly valid code now some people like this method the official documentation use this quite a lot although personally I am not a fan of R just because I like to be as explicit as possible so personally I really prefer to define the actal type so just like this but like I said this is just personal preference both ways work so feel free to use the V method if you prefer that one okay okay so here now we have both of our components and this for each the code in here this will cycle through all the entities that have both of these components now here we can just say app rotation so in order to rotate let's go inside the local transform and then first we need to access the underlying component with either read or write in this case we do want to write so let's access the value r w and then on the local transform we can call the function rotate y to rotate on the Y AIS however this function actually rotates a copy instead of modifying the original local transform so we set the value r w equals whatever this function returns and over here for the rotating angle for this let's grab the speed value from the component so rotate speed in this case this is a read only so let's grab the value r o and then we grab the value the one that we Define inside the component and finally as always when doing any movement or rotation we want it to be frame rate independent so over here we need to modify by Delta time and inside the system we get that through system api. time. Delta time now important it's this one when working with entities it's it is supposed to be this one and not the usual time. time basically this has to do with the fact that you can have multiple worlds and multiple systems with different time frames so when working inside of VCS always use this one inside the system API so with this Yep this will indeed rotate it now just one tiny thing like I said over here the rotate y this one doesn't actually modify this value so technically over here we can just read in order to apply the rotation so just make this one an r o and then we actually assign it to the RW again when working in DCS it is important to be very clear about read and write access and just like this everything should be working so basically this system this will work on every single entity that has both a rotate speed and a local transform component then it will run this code on those entities which in turn is going to rotate it on the yv value based on the speed defining the rotate speed okay so let's test and right away we do see our entity rotating and if I click to inspect the cube yep over there we can see the local transform is constantly modifying and if we go down here we can see the rotate speed and of course if we modify this increase it or decrease it and yep it modifies the speed all right awesome now if we want we can try making a bunch more cubes by the way when working with entity subscenes you can also use just regular prefabs so let's rename this to rotating Cube and I'm just going to drag it into my prefabs folder to make a regular prefab so this is a normal game object prefab I'm going to cover how to spawn in prefabs later on in the video right now I'm just making this a cube just so we can duplicate and create a bunch of them so let me create a whole bunch of them and then later on if we want to modify all of these we can just modify the original prefab okay so here we have a whole bunch of cubes and if I head on play yep all of them are rotating because again the system works on all entities that match the query no matter how many they are related to systems we also have the systems window so let's go into window and then over here into entities and systems this window basically shows all the systems that are running how long they are taking to execute and how many entities they are being run on so over here we can find our system by default it's going to be inside the simulation system group and over here we do see our rotating Cube system and Y this one is running on seven entities and taking 001 milliseconds also one note on systems is technically they can be created before the main scene is loaded so generally it is actually good practice to make sure they only run if the actual entities that you want if those have already been spawned so to do that it's good practice over here to also implement the other function the oncreate and on this one let's say we want to run the system only when there is at least one entity without our rotate speed component so we do that by accessing the state so this is this system State variable and we call require for update and then pass in the type that we want to require so in this case the rotate speed basically this will make sure that this system this update will only run once we have an entity that has this speed component now technically this isn't absolutely necessary like we saw our code ran perfectly fine without of it that is simply because the query that we are doing here this one is simply returning an empty list before any cubes will respond so if the list is empty the 4 each is simply not going to run so there's no problem but for example if we had other logic over here that somehow assume that a cube already exists all the time if so you might get an error whereas by adding the required for update this one matures the update function this one only runs when there is at least one entity with this component okay so far so good now like I said a while ago making something a system does not automatically make it multithreaded this is all still running just on the main thread we can open the profiler in see so over here let's go into window then analysis and open up the profiler and we can click on a frame and be able to see let's expand this over here on my job look at all my worker threads and none of them are are actually doing the rotate cubes code everything is still happening all the way up here if we find it on the main thread it's really small so it's really hard to see but yep here it is the rotating Cube system this is all running still just over here on the main thread let me just add some dummy Co just to slow this down so we can more easily see okay so here I just wrote some dummy code just to waste some time on the CPU so just a variable that I'm multiplying and dividing a ton of times and then using it over here on the calculation since I'm multiplying and dividing the final result won't be one so it won't affect the actual rotation piece it should just take a bunch of time so let's see and yep now we can much more easily see yep all the code is over here again all of the worker threads all of these are idle all of our code is still running just on the main thread currently taking 7 milliseconds to run just a handful of Cubes now to get those massive performance boosts that dots is famous for for that we need to use the job system and burst which just to clarify those are not exclusive to entities you can make your game internally with game objects and you can still use the job system and burst those are not dependent on entities so first let's just enable burst which is super simple if you don't know the burst compiler is really one of the best things about dots it is basically a magical button that makes your code run orders of magnitude faster in order to enable burst you just go up here onto the jobs menu under burst and just make sure to take enable compilation which by the way right away you might be asking if burst is so good why isn't it always enabled why is it a checkbox and that's because when some error happens it can be tricky to debug if burst is enabled just because of how burst automized the low level code so while developing if you find some errors it might be useful to actually disable burst so you get some proper error messages but when making a proper final bill definitely always make sure to enable it okay so this one really just enables the burst compilation it just enables the potential to use burst but by itself it's really not doing anything just yet for that we need to go to some functions like over here on the onupdate function let's say we want to use burst on this one so for this we add an attribute to this function and we add the attribute burst compile so this one which exists inside using unity. burst so this attribute like this and Y just like this this code will be compounded with burst and will be insanely fast there's no need to do anything else let's just test and you prob away it does work so you can already see the difference previously our system was taking 7 milliseconds whereas now just by literally enabling burst now it is taking literally 0.004 milliseconds now actually in this case I think the compiler is way too smart and basically sees that what I'm doing here is not nonsensical so this code makes no sense so I think the compiler is smart enough to pretty much just erase this that is why it's such a drastic speed up in this test but in pretty much every normal scenario just the enabling burst makes insane speed UPS this is really insanely impressive for literally just one button click and also one note sometimes you might see some code that also has the burst compile applied over here into the system struct if you want you can add it doesn't change anything basically the autogeneration the source code generation that one is smart enough to know that if you use burst compile on any method it automatically adds it so you only need to add it on the methods now while burst does indeed work pretty much like magic it does have some limitations the main one being that it only works on unmanaged types so if you use a class inside this function then you cannot make it burst compile this is why ECS is very much based on structs and a data oriented design it's so you can benefit from these massive speed UPS including using burst and to make this truly insanely fast that's where we use the next part dots which is the job system again right now even though we are using burst which made this insanely fast even with that it is still all running just over here on the main thread in order to make it multithreaded that's where we use the job system so first thing we do is we need to create a job and for that we make a struct so let's put it right in here let's make a public struct call it rotating Cube job if you want you can make it in its own file or really just over here right next to the system this works great so we do this and now we Implement one of the several I job interfaces there's a bunch of them depending on what exactly you're trying to do if you're trying to run some nonn code then you should probably use the iob 4 also by the way there is an iob 4 and an iob parallel 4 however you really should not use this one this one is really only here for backwards compatibility reasons instead if you need something not to do with entities you should use I drop 4 and then if you need to make this code parallelized then you can simply call schedule parallel which we're going to see in a little bit but over here we want to do some work on some entities so for that let's use the I job entity okay so we do this one and for this one same thing Source generation so this one also needs to be marked as partial and then like it said says here we need to implement an execute method so let's make public void execute and over here for the parameters for this one we basically add the components that we need just like we did up here on the query so we are going to need the local transform local transform and then we're also going to need the rotate speed rotate speed so we need these two components and then again we have the same considerations we had previously with regards to read write except over here instead of using ref RW and ref instead of that when we want something just read only instead of ref we just set the in keyword this makes it read only and when we want read write for that we are going to add the ref keyword so just like this and then the code inside is going to be exactly the same so I'm just going to copy paste that except we now don't need to go into the value Arrow we just do just like this so just erase these like this and then over here when working inside a job we don't have direct access to the system API so in order to get our Delta time let's pass it over here as a simple field in our job so float for Delta time and then over here here we use this same okay so this is going to do pretty much the same thing so basically this job won be executed on every single entity that has both these two components just like we had the query up here which is going to execute that and for every single one of those entities it is going to run this code so here we have the find our job all that's left is to actually run our job so for that let's go up here onto our on update and right now we are not going to use the system query method so let's just comment this one out so comment out the 4 in instead of doing that we just create a new job so new rotating Cube job and inside we need to pass in the Delta time so let's pass in the same thing go inside the system API in order to grab time. Delta time this is going to return a rotating Cube job this simply creates a job and then after creating the job then we have two options number one is to call run this one will make it run immediately on the main thread so this one can be sometimes useful for debugging but in most case you probably don't want to use this one instead you probably want to use schedule this one will schedule the job to complete at some point in the future it will be completed either by the main thread or any worker thread it really depends on which one is busy this one completes the entire job in just one thread and then finally we have the schedule parallel this one will basically split the job into multiple chunks and create multiple jobs that run on multiple threads all at the same time so first let's actually start with a simple one just a regular schedule so let's do this in test okay so there it is and the cubes are all spinning and if we look and up here we can see there we've got our job and it's actually being handled over here by worker one now depending on what you're doing it might complete in the same frame or in this case it might take two frames to complete if you really want to force a job to complete then over here on the schedule you can pass in the optional state. dependency now this one returns a job handle and if you want to force it to complete you can call complete and Visually then down here you can write some code that assumes that this job has already been completed however you should really avoid this as much as possible instead you should let the job system actually decide when to run jobs and if you need some code to run after some job has completed then you basically should just make that second job a dependency of the first job so ideally you never actually do this you just call schedule and then wait that for the job system to actually complete the job although one important note is how over AE schedule this is actually a shorthand so the source generation then replaces this so basically puts a state. dependency inside of here and sets the new state. dependency equals to this so when you call that short hand it is actually doing this this basically ensures that as you schedule a job it will have the correct dependencies but I should also mention that while the short hand works great if you're doing an i job entity this code will have problems if you use an i job 4 because then it will not pass in the correct dependencies so in doing anything other than an i job entity then make sure you explicitly Define the state. dependency as a dependency of that job instead of using just a Shand okay so like we saw the schedule this one schedules on just one worker thread so over here we have our job running on just this one and the other one that we saw is the schedule parallel this one will run the job on multiple threads however this one actually has a really sneaky thing that confused me quite a lot while researching this video this one supposedly splits this job across multiple worker threads however if we test this and nope everything still looks the same it is still running on just one worker thread and all the other ones these are all idle so this is the part that really confused me it confused me why this one was still running on just one thread I even made a post on the forums asking for some help and thankfully I received some really excellent responses the answer is that apparently this one splits across multiple threads but it is based on chunks so since in My Demo over here I really just have seven entities these are not enough to be split over multiple threads they all fall into the same Chunk meaning they all run the same job on just this one worker thread it does not matter how intensive the job is it is all based on the number of entities if I say I just make a ton of entities so let me just duplicate this a mountain of times okay so I duplicate the prefab a ton of times so now I have a total of, 1500 entities and now if we run the same code again and now if we go ahead and we look and if now it is correctly in the indeed using all of the nice workout threads so that means that this method really isn't suitable for doing super heavy work on just a small number of entities if you have that specific use case then instead of using iob entity instead use the one that I mentioned so the I job parallel 4 and basically handle splitting the logic yourself so just be aware of this one this one confuse me by quite a bit but yep if you do this and you have a certain number of entities this does work you just call schedule parallel and it automatically runs it across multiple worker threads so in here with this many entities with 1500 entities ring the code which has this intentionally wasteful thing with all that in total it is taking 1500 milliseconds per frame but we are still getting a handful of frames per second because when the whole thing is combined because of using all of these threads at the same time the whole thing takes just 100 milliseconds so this is how you make code multithreading and again the best results come from combining both multithreading the job system with burst so on the job definition let's add the burst compile attribute we only need to add it up here there's no need to add it for the execute function itself so like this if we test and again notice that difference again bur is way too smart and right now I can't even find it I need to zoom in like crazy in order to be able to find anything so here it is I finally found it so previously it was taking 1500 milliseconds and now it is taking just 01 by the way quick tip to check if it's using burst or not look at the color over here on the profiler if it's in green then it is indeed using burst again I'm assuming burst is way too smart and it's intentionally identifying that this code is just wasteful this is nonsensical so I'm assuming it is actually identifying this in just deleting this useless cone but still even in regular scenarios and proper scenarios without this kind of testing code even in that burst is an insanely good thing it is a really excellent way to get extra free performance by just following some good data oriented design so when you combine the job system along with bur you can get some really insane results now let's learn about tag components this is a really easy and extremely powerful tool basically it's how you can add a tag to an object to Market as some sort of type like for example the difference between a player and an enemy thankfully tag components are insanely simp simple first let's actually see the problem that they solve so right now we have these rotating cubes now let's say I want to also have a player object so let's go ahead and make a player so inside my entity subscene I'm going to create a new game object this time for a player let's say it's a capsule let's move it a little bit going to give it a different color and inside I'm also going to add a simple Cube just to be able to see where this transform is facing okay so that's my basic player and now let's say that the player will also rotate so let's also uh the usual rotate speed component however we want the player to rotate based on input and not constantly like all the other objects whereas right now if we h on play and nope this is not what we want the player is rotating alongside all the other cubes basically what we want is for this rotating Cube system for this one to only apply to the cubes and not the player meaning that we need some kind of way to identify exactly what is a cube and what is a player so that's where tags come in like I said they are extremely simple we just make a new component as usual so let's create an UC C script call it the player authoring because again we're going to place both the component and the authoring directly inside the same script let's go ahead and attach a player authoring to the same player component and let's open and now over here for our authoring component which is going to be our mon behavior for this one we do not have any fields we have an empty authoring component then let's make a regular component an ECS component so a public this is going to be a struct let's just call it player and this one is an i component data which again exists inside unity. entities now this one also has no fields at all this is a tag component which is really just an empty component and then let's make our Baker so inside our authoring class let's make our usual public class Baker We Implement Baker of type player authoring and on our bake class on this one we're basically just going to add the component so again let's first of all grab the entity get entity and for this player the player is going to move so let's use Dynamic then let's call at component pass in this entity and just do a new player for the new player component so that's it no Fields no data nothing over here inspecting our player if we go into the entities inspector on this one if we look up top we can see a section just for the tags and Y over here we do see our player tag okay so this one is correctly tagged as our player and over here in our rotating Cube system let's go down to our job where we are rotating the cubes and right now this job w't run on every single entity that has both a rotate speed component and a local transform component this includes the player so in order to not include the player we can add a nice attribute to the job that is going to be the one called with none and then basically we add any types that we don't want this shop to run on so in this case let's go type of of our player component basically now with this component this job will run on every single entity that has both a local transform and a rotate speed component but no player component so it should run on everything except the player let's test and Y it does work all the cubes are still rotating but the player is not rotating okay great by the way here we we saw by using this attribute in order to make this job not run on entities that have the player component but over here the other method the4 each we can also do the same thing the way we do it inside of this one is we've got our system query and then after the query so after the parenthesis we can then add pretty much the same thing with none and then we pass in the type of type player and yep just like this now this for each will only run on all entities that have rotate speed local transform but no player and also yet another alternative is obviously we can do the opposite so instead of tagging the player and then writing this with none instead of that we can actually tag the cubes so let's make our rotating Cube tag so as usual C script for the rotating Cube authoring and over here the mono Behavior this one is empty then we've got a public struct for our rotating Cube this one is going to be I component data and inside this one is empty then on this one we've got our usual Baker class and then we simply have to implement our method and over here get the entity and add the component yep just like this and now the rotating cubes a while ago I made them a prefab just so we could easily modify all of them so let's go inside the prefab and let's add the rotating Cube authoring and Yep this one should now tag it as a rotating Cube and now in our system either over here on the 4 each instead of saying with none we can say with all so with all or with any in this case either one will work so with all of the rotating Cube so this works as we'll now only run on the cubes and same thing over here we can use the attribute let's go with with all and same thing the rotating Cube so now this job and this 4 in both them will run on things that have the rotate speed the local transform and the rotating Cube component and also just for completeness sake of course the other alternative that you have is instead of using the WID all we could just use a ref RL over here of our rotating Cube that would also work but that would be quite a bit wasteful since we don't really need to access that tag component we really just want to run the cury that has that tag so when working in tags do not include them as a refero instead use the with all either the function over here or the attribute on this one and if we try running this code yep exactly the same result so now that rotating logic that one is only being applied to entities that have the rotating Cube tag so that's how simple tag components are they're literally just empty components which are really great for identifying your objects as being of a specific type so things like the player enemy bullet money and so on whenever you want to identify anything as something make sure you use a tag component next let's learn about aspects however before we do let's actually first see the problem that they are me to solve so for that let's make another simple component in the system to move our cues let's go ahead and make an e Shar script first for the component so movement authoring let's go ahead and add this one to our rotating Cube so let's just add the movement authoring and let's open it and over here let's actually do something fun so let's do so that the authoring component this one is completely empty but then we are going to have a movement Vector in our actual component so let's do a stru for our movement so I component data and on this one we do have something we do have a float 3 which by the way a float 3 is really pretty much exactly the same thing as a vector 3 this one just exists inside the unit mathematics library and this one is optimized to be used with dots and burst but in terms of logic it's literally the exact same thing as a vector 3 meaning if we go inside it we can see this one has an X Y and Z components so we got a flow three and let's call it the movement Vector so we have some data in our component but we have no data in our authoring component now let's go ahead and make our usual Baker class class on this one let's get our entity and then on ADD component let's add a component onto this entity and the component will be our movement component except now we don't have this field to grab directly from our authoring component I didn't do that just to show you how you don't have to you can make some authoring components that do some kind of processing in order to actually generate the final component data so over here for example let's just set it to a random value so we can just set movement Vector equals a new FL 3 like I said this is the same as a vector 3 so we've got an x y and Zed we just need to set these up so let's just put a random Vector which by the way the mathematics Library also has a random but for Simplicity sake I really enjoy using just the simple Unity engine one so let's go inside Unity engine to use that random specifically okay great just like this so when we attach this authoring component to an entity it is going to bait that entity and passing a movement Vector with a random movement Vector now that we have this let's make a system that will both move and rotate our cubes we want to do both of them so let's go ahead create a new C script let's call this the handle cubes system and over here for this one let's go ahead and make it an i system then as always we need to make this a partial struct okay let's write our onupdate method and on this one let's keep it simple and instead of using a job let's just use the regular for each method which actually this is probably what you should do when you first make a system meaning first use the simpler for each method that works just on the main thread get it working like that and then convert into a proper job if you need to so over here let's do a 4 in let's write a query first so system api. query in order to both move and rotate we are going to need the local transform component and we're going to need this one as a ref RW because we are going to actually move then in order to know how fast to rotate we are going to need the rotate speed component that one is just for reading so ref Ro for the rotate speed component next we are going to need to know how fast to move and where to move to so we need the move speed component again just for reading for the movement component and finally we don't want this to run on the player so let's also call with all and pass in the type of of our rotating cubes all right so this is our query so inside our 4 each we just need to use all of these so let me just write all of this okay so we have our query with all of our components then we do the logic so just rotating and moving all of it pretty simple just go into the local transform go inside first of all the value in order to rotate it so rotate it on the Y and let's do the same thing grab the rotate speed grab the value R and grab the actual value multiply it by our time. Delta time inside the system API so the time. Delta time this one is going to rotate but it doesn't actually modify the value so let's go inside the value RW and set it to this one this one rotates then we just need to move and for moving we're going to do the same thing so local transform go inside the value R and this case it's the translate then we need our movement Vector so movement value rrow and grab the movement vector and again make it frame rate independent so system api. time. Delta time okay so that's it some pretty simple logic this going to both rotate and move the component let's also just go ahead and disable our rotating Cube system we can either delete the script or just over here on the update we can just go into the state so that's the system State variable and just set enable equals false and let's return so it never runs once this one basically disabled the system from running so with this let's test and if everything works the cubes are both rotating and moving okay great so everything is working but looking over here at this query it is becoming quite massive with so many components so this is exactly where aspects come in an aspect basically groups multiple components into a single logical unit in order to Define an aspect first we need to define a script so let's create a brand new C script let's call the rotating moving Cube aspect and then inside of this one for this one we are going to implement I aspect which exists inside using unity. entities now this interface has no methods that we actually need to implement it's basically just a tag to mark this script as an aspect then an aspect is not a class instead it is a struct and again this one also needs partial for the source generation to work and one more thing specif to aspects is these need to be marked as read only okay great so now here we can add fields for all the components that make this aspect that make a rotating moving Cube and to add a component let's do the usual so let's make them public then over here we use either refr W or ref and let's begin with the UN local transform that we do want to write so let's go ref RW for the UN locon transform call it the local transform next we also need the rotate speed so for that one ref of the rotate speed and finally we got another one for the movement and as you can see since aspects need to be marked as read only all of these fields also need to be marked as read only so read only on all of these basically this this is the C read only tag basically it makes sure that we can never modify this field directly so after being set we cannot modify it it looks a little bit confusing to have something as marked as both read only and then ref RW for read write so it looks a little bit strange but Yep this is exactly how you write it use a c readon keyword and then ref RW or ref RL okay so we have all the components that we need in order to make this aspect work and then we also need to include the cube tag now suddenly the with all attribute does not work here so adding the with all just like we saw previously this one suddenly does not work on aspects instead said right now in order to add some kind of tag component is we can add it over here as a refero so we can do a read only make it a ref R in this case we need the rotating Cube tag component so this does work however it's a bit wasteful since we never actually need to touch this component so it would be nice if The Wil attribute worked here although there is an alternative that I will mention in a little bit so right now we do have all the components that make up our rotating Cube aspect basally we have the exact same components that we had over here on our system and now that we have defined the aspect now we can simplify this huge query with just a single aspect type so over here instead of all of these refl instead of all this movement so on we can just use the rotating moving Cube aspect and over here same thing now we just need one of them so the rotating moving Cube aspect just like this and yep that's it so as you can see this really simplifies that query now we just have one aspect in set of tons and tons of components also note how over here we do not need to add the refero or ref RW basically the aspect itself this works as a pointer and will already have the access that you define over here in the aspect definition now for the tag alternative that I mentioned like I said adding it here is a little bit wasteful since we never actually need to touch this data so if you need absolute maximum performance just remove it over here from the aspect and set over here on the system use the same thing that we already saw so just add with all and then we can include our rotating Cube Ty component yep just like this so This Way It Is technically slightly more efficient although in terms of readability I think prefer putting it on the aspect itself so I think this one is a little bit easier to read the best way would simply be if they allowed using the with all component the with all attribute over here directly inside the aspect that would be great so maybe they will add that in a future update okay so here we have our query with just our aspect and then over here for the logic now we can access the aspect components and make our changes so go inside the aspect then let's say go inside the local transform then go inside the value RW and so on so you could do this this would work just fine but another great bonus of aspects is that you can add logic directly inside of them so over here in our aspect let's just make a function so a p void move and rotate and over here let's really just copy this code so let's copy this put it in here and the only thing that we don't have the access is to the dth time from the system API so let's just receive it as a simple parameter okay yep just like this and over here in our system let's just go inside our aspect and simply call our function to move and rotate and pass in the system API time. time and yep that's it just like this let's test and yep everything still works so here you can really see how this code is now much much simpler than it was before thanks to using our aspect that is really the power of aspects is allowing you to group several components together into one logical unit next let's learn about something that is crucial to making pretty much any game prefabs and thankfully prefabs in ECS are also really simple right now we manually populated all of these cubes in our world and now instead of doing that let's make them spawn at runtime so let's make a system that spawn them and before we do that first we need to find some way to store a reference to our prefab so let's first make a component to store that and then our system will use that component so let's go ahead create new C script for the spawn cubes config authoring basically this is going to be the config file containing all of the config data for our spawn Cube system and over here in our mono behavior let's add a regular game object field for our Cube prefab so public game object for the cube prefab and then we're going to want to spawn multiple of them so let's also add an INT for the amount to spawn okay great like this then here in the editor let's make an empty gim object inside our entity subscene so let's create it name it spawn cubes config on the regular inspector let's go ahead and attach our authoring component and for the prefab let's drag our rotating CU prefab and for the amount one let's go with five okay so that's our authoring component now we need to convert this into an actual entity component so for that let's go ahead and make our entity components so again let's follow the exact same thing so so let's make it a stroke for spawn cubes config and this one is I component data however on this one instead of making another field of type game object instead of that we're going to make it of type entity so public entity and let's call A Q prefab entity so I have this and then for the end the same thing so the amount to spawn okay great so all we really need to do is convert our regular game object prefab into an entity prefab and we're going to do that on our Baker so let's make our usual Baker CL class we're going to do Baker and extend the spawn cubes config authoring then over here as usual let's pass in add components so that means we need our entity for this entity so let's go ahead get entity and in this case actually since we're using this config component this is really just a data component we don't really want it to exist anywhere so for this one now we can use none in order to make it just a little bit optimized since we don't really need that transform component then let's add a component onto this entity and the component new spawn cubes config and now inside here for the data for the amount of Spawn let's just go into our authoring and grab the amount of Spawn and then for the Q prefab entity the way we convert our game object prefab into an actual entity thankfully that is extremely simple we'll literally just use the same get entity function so get entity and this one has a version that takes in a game object so we can just go inside the authoring component and let's grab the regular game object Q prefab and then usage flag same thing let's go with Dynamic so y That's it really simple we just call get nty and this is going to automatically convert our G object into an entity prefab so with this this is going to work we're going to have our nice config component we can even test it out over here let's go ahead and run our game then look into the entity inspector and if there it is the spawn cubes config and yep we do have our rotating Cube prefab entity also note how on this one we do not have any transform components again that is that little optimization thing if we look into the other components the other entities all these is you have local to local transform and so on but on this one which was optimized this one does not have any transform data okay so great here we have our Q prefab entity now let's simply just insentient to handle that let's go ahead create a new C script let's call the spawn cubes system and then over here we can either make this a system base or an i system let's go ahead and do a system base just to be different from what we've already seen But like I said either one works so a system base just need to mark this as partial and then we need to implement our abstract class so we need to implement at least the onupdate method but then like I said a while you should also implement the uncreate if you have any requirements so over here let's also Implement override void the uncreate and on this one let's call require for update which by the way this is a little bit different from the one that we saw on the system so if we go inside the rotating Cube system on this one on the uncreate when working with an i system we've got a system State over here on the parameter and we go through that and call require for update whereas over here on a system base we can just call require for update and then pass in the component that we need need so in this case it's a spawn cubes config just like this okay so yep with this now the update will only run when there's an entity with the spawn cubes config that's good because we're going to actually need that object to exist in order to run some logic here and now on this logic we really only want to spawn the cubes once so let's just disable this system right after the first update the way we do that on a system base just do this. enable equals false that will make sure that this update is only going to run once and over here in order to get our spawn cubes config for that we can use a super useful function from the system API we just go inside system API and we call get Singleton this one like the name implies gets a Singleton so we just pass in the type so the spawn cubes config and this one is going to return our spawn cubes config now importantly this get single function this one has a whole bunch of really useful safety checks if you have zero entities with this component then it's going to fire an error so again really important that we add the required for update before this update runs and if you have more more than one meaning it's not really a singl ton if so then also fires an error so basically in order to call this get singl ton function in order to do this then this must actually be a Singleton meaning there has to be one and only one entity with this component these are some really great safety checks because they really enforce you to actually implement the proper singl ton pattern so with this we can now easily access the data inside of this component so let's just do a basic cycle through the amount to spawn so just say basic for starting on zero going until the spawn cubes config the am M to spawn i++ okay and now here let's simply spawn and the way that we spawn a brand new NTI prefab is really simple we just need to access the spawn cubes config and inside we've got the Q prefab entity and the way we spawn it is we just go inside the entity manager inside this one we call insentient a regular game object and this one takes a parameter for the source entity which is indeed our Q prefab entity just like this all this is doing is really just copying the source entity since entities are really just data inen ating simply means copying all the data in memory the only special thing that intiate does is how prefab entities they've got a prefab tag component this is a special te component that all the anti queries ignore since normally we don't want to run any logic on the prefabs themselves so when you call intiate it copies all the data from that prefab copies everything except that one prefab component and Y that's it super simple so this will return our spawn entity and then if we want we can initialize it so we can go inside the entity manager and call set component data and we can set any component to any data that we want but at the same time our prefab this one already has a bunch of authoring components these are still going to run when this is converted into an entity so we don't need to manually initialize all of these authoring components so for all this custom data we don't need to do anything else other than just spawn it although actually one real interesting thing is that the bake happens just once for the prefab meaning all of these authoring components they will be converted into the corresponding entity components just once so for example in this scenario we have our movement authoring components and for this one we defined over here on the baker it generates a random movement Factor but like I said this bake will only happen once for the prefab itself will not happen every single time that we instantiate the new entity from that prefab so in this case all of our SP objects they will all have the exact same movement Vector since again this bake only runs once so just something to be aware of the bake only runs once when the prefab is converted and not every time that you spawn an entity from that prefab so right here for set component we don't need to bother with all those custom components let's just put it in a random position so the set component data this one takes an entity so let's go inside our spawn entity and for the component dat in order to put it on a random position let's just modify the local transform this one takes a certain position and the position is a flow three so let's go ahead let's Implement using unity. mathematics and we're going to have our nice flow three again same thing as a vector 3 so XY Z so this is going to spawn it on some random position although actually here here's another thing that confused me quite a little bit when I first was researching this topic I initially just did this in order to spawn all the entities naturally if we test this it does work it will spawn the enties and it will position them on a random position so here let's quickly test and before we do let's actually get rid of the rotating cubes so we just want to spawn them so let's test and look at that nothing is actually visible however if we look in the entity's hierarchy yep all the cubes are indeed being spawned so again this is the thing that confused me a little bit and the reason has to do with the defaults and we can look over here on the local transform and see yep the position is indeed being set correctly but over here the scale the scale is a float and the float by default is going to come out to zero so that is why we don't see anything the entities are all actually there but since they've got a scale of zero they're not visible so technically when spawning a new local transform in setting some data technically you can just insert the ones that you need so in this case just a position but if you do know that everything else is going to default to zero so in order for you to not be confused like I am if you go ahead modify local transform just go ahead and also apply the rotation we can go inside the Quan this is the one inside the unity mathematics library and just use identity for the default rotation and again let's also put on the scale just so this one does not default to zero also another option exactly to solve this sort of problem is how the local transform if we go inside that class local transform this one has all sorts of helper functions similar to the rotate and the translate that we saw a while ago we can use this to automatically create the loal transform with a certain position rotation scale or just position like for example this one so we can use this one with our custom position and then basically this would create a local transform with a certain position and set the scale correctly to one so all of the helper functions inside the AL transform all of these can be quite useful okay so just like this if we test any up here we do see a bunch of Cubes being spawned and yep everything still works so all the same rotating and movement logic all of that is still working the same as previously we can easily go inside our spawning cubes component in order to spawn more or fewer cubes and there you go everything spawns and they all move all right awesome now I should note that there are more efficient methods for spawning entities if that's really the only thing that you want to do and if you want to spawn a ton of them if so then instead of instantiating them like this just literally one by one instead of that you can use the other functions over here for the instantiate so we've got this one that just takes an entity and spawns another entity or alternatively we have for example this one this one takes a source entity and then creates a number of entities that are all place inside a Native array so basically you construct a new native array with a certain size and then this one will inate entities to fill that entire array so if you spawn an array with 100 elements it is going to spawn 100 entities then you would simply cycle through that entire native array and set the component data on all of those entities so just be aware if you want to spawn tons of things it might be better off to spawn all of them at once instead of one by one individually also speaking of Maximum performance so over here this code works but for maximum performance instead of using over here entim manager. set component data instead of this one you can use system api. set component and Yep this will do the exact same thing but this one has some nice performance benefits so in general whenever possible for maximum performance you should prefer using the functions inside the system API since a lot of those will have some nice performance benefits as opposed to using the en manager directly but on a simple system like this one either one works and also another very important thing on spawning entities over here note how we are spawning them directly directly through the entity manager so that's perfectly fine here like I said technically this is not the most performant matter but over here we're only running this update one so really over here we have no concerns when it comes to Performance and there also is not cycling through anything so again also not an issue but for example let's say that our players firing bullets so let me just quickly make a system for the player to manually spawn some bullets let's go ahead and just create a new C script called the player shooting system and then over here let's make this one a system base so system base inside using unity. entities let's make it partial let's go ahead and Implement both these so both the on update and let's also do override void the uncreate and on the uncreate let's call require for update and make sure this one only runs when the player tag component actually exists okay so we have this one and then on update let's go ahead and fire some bullets and for firing bullets let's actually assly spawn a cube so let's consider a cube to be a bullet so let me just copy this and in order to fire it manually let's just check if the player is holding down the space so over here I'm just doing some basic testing code so just get key down so let's says for the space key so if the player is not pressing space if not then let's just return and if the player is pressing space then we're going to run this code then for the bullets instead of going through this amount to spawn instead of that let's cycle through all of our players so let's do for each system API let's first handle the query we're going to need to know the player's position in order to know where to spawn the bullet so let's use a ref rro because we only need to read it for the local transform so this is the only one that we're going to have so we just need the local transform in the query and let's also make sure this one only runs on the player so with all of the player tag component so we CLE through all the players we get the L transform then over here we are going to spawn the cube so that is going to act kind of like a bullet and then for spawning it let's simply spawn it directly on the player position so over here let's just go inside the local transform grab the value RL and let's just grab the same position okay so just a super simple system so when we are pressing space we are going to run this logic we get the singl ton in order to get our prefab reference and we're simply going to spawn a cube directly on top of the player so let's see so here we have the player and if I press on space and if there you go it does indeed spawn a cube directly on top of the player okay great so again we still have the exact same logic that we had previously just spawning it directly so over here we're still using the enti manager. instantiate however one very important thing about dots is that spawning or destroying entities that is what is known as a structural change basically the back end of dots that one is storing a ton of tightly packed arrays for all of the entities and all the components that's really how this system is so insanely performant but of course if you spawn new entity you are going to modify those underlying arrays so while cycling through some arrays while cycling through some entities while doing this you really don't want to modify it so in order to spawn or destroy entities while in a job or in a 4 in in this case you should actually use what is called an enti command buffer now I should also obviously say that this code actually works this is not a problem as we saw it is running perfectly but the reason why it works is because the new prefab entity does not match this at all we're spawning bullets not players so the new spawn entity will not have a player component so it does not match this query however if the instantiated entity archetype if that one did match this query then it would break this code so when that happens for that like I said you should spawn entities using an entity command buffer so let's see how that's done first we need to create a new inty command buffer so let's see new entity command buffer this one requires a certain allocator and over here there are a whole bunch of options depending on how long you want this command buffer to live now in this case we really just want to create it in order to spawn our entities and then we want it to be disposed of so let's use the simplest one the temp allocation this one is going to be created temporarily and then automatically it's going to be disposed of so we don't need to manually dispose it ourselves we do this in order to create a new entity command buffer but of course we don't actually want to create it for every single player we just want to create one and then spawn all kinds of entities so we do this outside of the four okay then we go inside the four and for each enemy and for each player we want to spawn our bullets so over here we go inside this one and we just call the same instantiate function this one as you can see also has all kinds of options we can spawn just one or multiple so for now let's just spawn one so let's literally just replace this exact same code with this one everything else is exactly the same however importantly this isn't actually instantiating The Entity over here over here we are simply adding that command to a command list that will be executing later so we do that in order to record an instantiate command and then same thing over here for the set component data except over here for some reason reason instead of being called set component data it is only called set component I'm not sure why this function is different but it just has a different name and everything else works the same so again this is also going to just register a command it is not actually going to set any component data just yet so we do this and basically over here we are queuing up all kinds of commands and then after our four after our cycle so basically after we are far away from those issues that I mentioned with all of those titly packed arrays after this in order to actually execute those commands we can go here and call playback and this one takes an enti manager that is actually going to spawn the entity so let's just pass in the reference to our entity manager and yep just like this so basically by doing it like this we have no structural changes over here directly inside the 4 each we are just recording some commands and we are only executing those commands after we exit the cycle and if we run the code everything is still going to work exactly the same so if I press space yep there you go it is spawning cubes everything works right so for spawning things usually you have these two options you can use an En command buffer or you can simply use the en manager instantiate and another note on getting maximum performance so here this works it is going to allocate the N command buffer and then dispose of it but in order to get a tiny bit more performance instead of using a temp allocator instead of that you should use the world update allocator this is a special allocator that exists by default it lasts for 1 to two frames and is automatically disposed of and has some nice performance benefits now speaking of structural changes one change is spawning or destroying enties so over here we are instantiating this is a structal change then yet another type of structural change is simply adding or moving components to an enti so if over here I go into the enti manager and I call add component this is going to be a structural change basically it has to do once again with how dots works in the background how the whole thing is based on entity archetypes which are specific groups of components so by adding or removing components you are basically creating a brand new archetype so things need to be moved around in memory so ideally you should avoid adding or removing components as much as possible if you need need to do something like that like for example let's say you need to Define if the player is in some kind of sunun state if so then instead of adding or removing some kind of stun component instead of that you can use what are called enable components which let you enable or disable without triggering a structural change so let's see exactly how that's done so first we build a component as usual so a new C script let's call it stun authoring and over here for the authoring component let's leave it just like this just empty and then let's make the actual empty component so let's go ahead call it just stun and for this one let's Implement I component data as usual but then also I enable component then if you want this can have any fields for any data that you want or it can simply be a simple tag component and then up here in our authoring component let's Implement our Baker class and in this one let's do the same thing so en entity let's call get entity and for this one this is on the player so sure let's pass in as Dynamic then let's add component onto this entity let's add a new stun component so just like this and then we can call the function set component enabled and we're going to modify the one of type stunn and then we can set it to either enabled or disabled first let's pass in the entity and then let's say we don't want the player to start off stun so let's say false okay so that's it super simple so we basically just implement the I enable component and then when adding that component we can optionally set it as enabled or disabled then over here in our game let's go ahead and just add the stun authoring component and then for example over here on the player shooting system on this one we are cycling through all the players in order to spawn all the bullets so we are calling with all to see all the players and in this case we only want to run this query if the player is not stunned so for that we can add the WID disabled so this query will only work if a certain enable component is actually disabled so let's go with our stun just like this so This query this for each will only run on entities that have a local transform component also a player tag and also a sun component that is set to disign disabled and then just for testing let's put up here just a simple testing code just to swap the stunt state so let's test input get key down for some testing Keys let's go with the T key in this case for some testing we know that we only have one player so again just for some simple testing code let's go inside the system API to get the Singleton entity of type player and then we can go The Entity manager and call set component enabled of the stun component on this player entity and when we press T let's set it to yes let's set it to stun and on another key so let's say on a y let's set it to not stun okay just like this let's see all right so here we are and we can actually look at the player so we can select the player and go inside the N inspector and over here yep we do see up here on the tags we do see there's a stun tag and right now if I press on Space yep there you go it is spawning a bullet however now I press on T and yep note how that one became checked and now if I press on Space again and nope it is is not spawning anything because again it is only running that query if the player is not stunned so press on y that one becomes un stunned and space and there you go it's still work so stun un stun everything works all right great now like I said the main benefit is this is not a structural change which makes enabling or disabling these State these enable components makes it super fast so instead of adding or removing this component instead of that we just decid it enable or disable it okay so now let's cover one of the most important things about ECS which is how to interact with the from game objects this is very important because it is the recommend method for working with dots there are many things for which game objects are still excellent so the recommend workflow is mixing both dots and game objects rather than going 100% with either of them so over here I previously prepared this simple game object it's a simple shoot popup so inside I really just have some text just saying shoot and then I've got this simple script so over here really on update it just moves this component upwards and after a certain amount of time just destroys itself again super simple note how this is a regular script absolutely nothing over here on this popup absolutely nothing has to do with either entities or dots this is a regular game object regular mon Behavior component the game object itself again like I said regular game object absolutely nothing to do with any entities what we want is basally spawn this regular game object whenever the player entity spawns a new entity B so let's make some kind of script to handle that let's go ahead create a regular monob Behavior regular C script called the player shoot manager now let's make a regular game object to run the script and again importantly we want a perfectly regular game object so we do not want to create anything inside the entity subscene no just out here and let's create an empty regular game object let's go ahead give it the same name and reset the transform and let's attach our component okay just like this and on this script basically we want to know when the player is actually shooting and when they do then we want to spawn our prefab so over here we have our play shooting system where we are actually spawning our bullets and now while ago I made this a system base and like I said the difference between system Bas and I system is that system Bas is meant for manage components and is system is meant for unmanage and one of the easiest ways for us to connect both game objects and the entity systems when the easiest ways is simply by using an event so over here since we are in system based we can use manage components so let's use a regular managed event handler for handling some regular C events so just super simple public event event handler again super simple event let's call it on shoot event handler is a type of delate which is a manage type now if you don't know about events I covered them in detail in a previous video same thing for delegates okay so basically with this we have our normal event and then down here when we shoot let's simply fire off the event so again really simple just do the exact same thing that we're used to using so just invent let's invoke it with usual standard this event ARS empty also by the way one more quick tip over here when doing system api. query for this one just in case we need to know the enti like for example over here on the event it might be useful to know know which player is actually shooting a bullet for this one one of the many options that we can add over here onto the query one of the many options is with entity access and if we do then our entity over here the tupon that this returns this one is going to have an reference to an entity right over here at the end so for example in this case we can do this in order to over here when we shoot the event we can pass in the entty reference as who is actually shooting this boat okay so just like this pretty simple we've got a regular shooting event and then on our regular game object script let's just lean this up on this one we really just need to hook onto that event and for that that means that we do need to find some reference to this player shooting system and thankfully that's pretty easy since there is only ever one system in a world which means the systems are always Singleton so that makes it really easy to find we can just go over here on the players ship manager let's do a private void start in order to hook onto our event however over here we can't access the system API this one does not work this one only works on systems as we can see you may not use the system API member outside of a system so instead of this the way that we find that is we first need to access the world and we can access the default World by going into world. default game object injection world and over here we can get an existing system and in this case since we are using a system base we need to use the manage version so for this one for the player shooting system and now that we have this one we can go and do the same thing so just listen to the event so just some usual code nothing to do with any entities the only entity thing is over here converting the center into an entity so an entity for the player entity and let's go ahead grab the sender and we need to convert this as an entity so let's go ahead and cast it down into an entity so we have this and now in order to know where to spawn our prefab for that we need to know the position of this player entity which means we need to access this player entity the local transform so for that let's go inside the world default GIC injection world let's grab the nty manager and from that one we can grab the get component data we want the local transform component and the entity that is going to be our our player entity so this is going to return our local transform components then when we have this one we've got the position so this contains the position of the player so now let's just do a regular game object ineni so insen and we just need the reference up here so let's go up here and add it as a regular field so serialized field private game object for the shoot popup prefab so again a regular game object component and then over here let's go ahead let's Spa on this position with no rotation so querian identity and by the way note how even though the position this one is a FL 3 it automatically gets converted into a vector 3 okay so that's it super simple so we basically just go through the default World in order to get the instance of our shooting system and then from that one we hook onto the event just a regular event and then we grab some data from that entity and spawn our regular game object let's test so just over here on the player shoot manager let's just make sure to add the shoot popup and let's test so here we are and if I press on space and yep there you go there it is the shoot popup it does work it does spawn the player and yep everything works great all right Awesome Again note how this popup this is a completely normal game object element the player itself is an entity and it is being controlled by an entity system but this game object this is an entirely game object the popup has absolutely nothing directly related to any entities we've got an entity over here then a game object over here and we simply have a script just a regular manager just a regular monob Behavior component and this one is handling the connection between one and the other so as you can see this is one way for how you can connect a game object onto an entity you can have some kind of entity system that fires off some kind of event and then have some kind of script that listens to that event and does whatever it wants like for example spawning a game object this works so basically over here we have the monob behavior side grabbing some data directly from the N side however alternatively we could also do the opposite we could have our system in order to call some kind of function directly on the mono Behavior so for that the super simple way is pretty much exactly the same thing that we did so we grab the existing system which is going to be a Singleton so you can pretty much just convert this regular am of behavior also into a Singleton so let's use the usual Singleton pattern that I've used in so many videos so for the player shoot manager call it instance make it with a public get and a private set then let's do we private vo awake and on awake let's set the instance equals this okay so we have our nice static instance and now instead of having these events instead of having this mon Behavior go grab data from the other side instead of that let's go ahead and make another function so let's make a public function let's call it player shoot and let's receive Vector 3 for the player position then over here we just do literally the same thing so we call instantiate shoot that one onto this player position just like this and over here on the player shooting system let's go down to where we are doing all this and now we can just go the player shoot manager access the instance and call the player shoot function all right yep just like this let's test so here we are press on space and yep everything still works exactly the same so as you can see there are multiple multiple ways to have our game objects and entities interact with one another you can have the monob behavior side as the ECS side for some data or the other way you can have the ECS side like some kind of system access some kind of mon behavior and tell it to do something or yet another option you have is just know there are ways to store manag data directly inside a component you can use manage components they do have a whole bunch of limitations but it is possible so for example you could have some kind of manage component that holds a reference directly to some kind of game object like for example particle system so you can do that and have the system directly interact with that manage component and do any kind of function any kind of data do anything with that manage component so basically all those options work so there are plenty of ways for you to mix both game objects and entities okay so we already covered a lot of stuff that you need to get St but dots is huge so there's really tons more stuff to learn let me quickly just go through some tiny details like over here on systems when doing a query we already saw a whole bunch of options but there's a whole bunch more you can just search for wi and see all of them so with all this one makes sure that all of the ones CU over here you can actually include more than one type you can include multiple components so if you use with all that one is going to make sure to run this query on all entities that have all of these components alternatively you have the with any so this one you can pass in a bunch of components and it's going to run on entities that have any of those then you also have with none which is going to run on entities that do not have any of those components also by the way over here I said with disabled but if stun was enabled and you only want to run some on players that are sun there is no with enabled instead if you want a component that's enabled that really just counts as a regular component so you just put it over here with all stun and this would only run on things that also have a stunt component and it's also enabled also by the way all of those are also available over here when you use a job on this one you can work with the attributes so again you can see with all with any with the and so on then on aspects for this one you can also have an entity field so you can do public read only entity entity this works and basically as you do some kind of query against this aspect it is going to automatically fill in this entity with that entity then in your jobs if you somehow have some kind of native array component native array or native list or any of these collections if so then the job will basically consider this a read write field meaning if you have multiple jobs working on the same native array it is going to run one after the other instead of running them concurrently if you do know that you are never actually going to write to the same index on multiple jobs if so then you can use the attribute read only that basically says that this ative array this one is only used for reading so you can run multiple jobs with this field concurrently then on systems themselves you also have a whole bunch of attributes the main one is the update before after or in group with these you can basically have some more control over when the systems run for example over here we can look inside the systems window to see all the various systems and note all of these various system groups so by using these like for example update in group you can use this in order to Define in which group you want to run this system on or you can use the update or after to update before or after any of these groups any of these systems then for the systems over here on the system base if we inspect this if we go to definition we can see these have a bunch more functions for example we already saw we can override the on update but there is also one called on start running onop running and so on so for example this is related to how on various on create on various of those we add the required update component meaning the system will not start running until an entity with that component actually exists so you can use these two the on start running and on stop running on the system base and if you are working in an i system for this one you can do the same thing and that exists over here on the I system start stop so you can implement this one in order to have the access to the onart and onstop running also speaking of systems they actually have an entty connected to them so here if we looking the enti Hier key look at how right now it's actually empty and if I start running yep there you go look at all of these entities that were created all of these for a system for example over here the play shooting system this is the entity related to that system this can be really useful to sore some data that is directly related onto a system technically you can also store data directly on the system so over here you can store some Fields but in keeping with the data oriented design you should really store any system data directly on the system entity in order to access that entity for example when you go inside the entity manager when you do for example set component data on this one there is a version which takes an entity but then there's also one that takes a system handle so you do and go through the system state in order to get the system handle and just like that you can access the underlying for this system then something I mentioned a while ago are the native arrays those exist in the collections package so you've got native array you've got all kinds of those and you also have native list this one also exists like name implies these are arrays or lists as usual but they have native memory access meaning they are extremely fast they are burst compatible but you must be very careful to dispose them so for example if I create a native array of type int I can do this native array and then when constructing I give it some kind of size and some kind of allocator so let's say five and then allocator we've got all of these so if you want to persist you would create it for example over here on the syston create and then you would reuse it if you're using it in a job use some kind of temp job if something that you only need to process for pretty much just one frame use temp also importantly is if you use St then the system will basically automatically dispose of this array by itself however if you use the other ones so for example if I use the persistent one if I do this then this memory won't be allocated forever so if you were to do this and spawn one of these arrays directly over here inside an on update then basically you end up with a memory leak so if you work with Native arrays or native list or anything like that if you don't use temp then you need to make sure to call dispose then in terms of holding different sizes of data inside an entity for that you have Dynamic buffers these are basically arrays that you can hold as a component in an entity basically a component usually has a certain number of fields but with a dynamic buffer you can have something that increase or shrinks basically has any size so that's a bunch more things for you to be aware of and to research like I said dots is a massive thing but honestly I think the basics are really not that difficult to learn so I do hope that this video helped with that in learning the basics if you just learned those and you already have access to an extremely powerful tool and if you want to learn more then I highly recommend you look at the documentation it is really detailed and very well written there's a project on GitHub with a whole ton of samples it even includes a bunch of walkth through videos so if you want to continue learning more about dots I highly recommend you go through those basically that's what I did for my own research for these past few weeks if you found this video helpful and you're feeling generous and consider dropping a super thanks on the video or simply please hit the Subscribe and the like buttons it's a small thing but those really do help so thanks and like I mentioned in the beginning I'd love to do a do course I'm planning to do it after I finish my C course so do let me know in the comments if you would be interested in that and if so let me know what gen you'd like to see maybe a factory game or an RTS maybe Tower Defense third person shooter vampire survivors like there's really many things for which dots would be a great tool for so let me know in the comments and if you use Unity at all then check out my ultimate unity over course it features over 70 lectures each covering a different tool or feature of the engine including many of which you might not know about that might be super useful for whatever project you're currently working on okay so I really hope this video helped you get started with DOs thank you for watching and I'll see you next time and
