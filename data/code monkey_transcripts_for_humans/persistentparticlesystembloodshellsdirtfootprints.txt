With timestamps:

00:00 - in this video we're going to make a
00:01 - persistent particle system this is a
00:03 - great system for when you want to spawn
00:05 - some particles and have them stay on the
00:07 - map like some blood or footprints let's
00:10 - begin
00:13 - [Music]
00:17 - hello and welcome I'm your code monkey
00:20 - and this channel is all about helping
00:21 - you learn how to make your own games
00:23 - with in-depth tutorials made by a
00:24 - professional indie game developer so if
00:26 - you find the video helpful consider
00:28 - subscribing okay so here's what we want
00:30 - to create over here I have my character
00:32 - I can move them around and when I do you
00:34 - can already see two uses of the
00:36 - persistent particle system when I move
00:38 - you can see dirt being kicked around and
00:40 - vanishing and you can also see some
00:42 - footprints where I went through so as
00:44 - you can see the dirt vanishes but the
00:46 - footprints stay always on the map now
00:48 - another uses with the weapon so whenever
00:51 - I shoot there you go there are some very
00:53 - nice shell particles exiting my weapon
00:55 - and once they stop they stay on the
00:57 - particle system and finally over here I
01:00 - have an enemy and when I shoot him there
01:03 - you go you can see some blood particles
01:04 - and if I shoot him some more he turns
01:06 - into a flying body and leaves behind a
01:08 - nice trail of particles and as you can
01:10 - see once the particles stop moving they
01:12 - remain permanently on the map so these
01:14 - are various uses for the persistent
01:16 - particle system we have particles being
01:18 - spawned they move then they stop in
01:20 - their final destination and they stay
01:22 - there forever alright so this is our
01:24 - goal let's get to it all right so here's
01:27 - our starting scene over here I have the
01:29 - player and I can move them around and
01:31 - shoot and as you can see there are no
01:33 - particles anywhere and over here is an
01:36 - enemy and again I can shoot him but no
01:39 - particles come out and after a while I
01:41 - kill him and there goes the flying body
01:43 - and again no particles ok so this is our
01:45 - starting point now the way we're going
01:47 - to build our system is by making a
01:49 - custom dynamic mesh so if you're not
01:51 - familiar with how to make a custom mesh
01:53 - through code then check out the video
01:54 - linked in the description that video
01:56 - won't teach you everything you need to
01:58 - know about how a mesh is made and what
02:00 - are the elements required to make it so
02:02 - here for our system let's start off with
02:04 - basics and draw a simple quad so first
02:07 - let's make our script a new script let's
02:09 - call this the mesh particle system and
02:12 - here we make a new game object and drag
02:16 - the script on to okay now to make our
02:18 - mesh visible we need to add a mesh
02:20 - filter that's the component that holds a
02:23 - mesh and a mesh renderer which is a
02:26 - component that defines how the mesh is
02:27 - displayed
02:28 - okay so far so good what
02:30 - open up the script okay now in here and
02:32 - let's set up our mesh okay so here's our
02:45 - starting mesh code again if you're not
02:47 - familiar with this then go first check
02:48 - out the mesh video a link in the
02:50 - description
02:50 - once you see that video you won't be
02:52 - able to understand what all this is so
02:53 - essentially we have the vertices the UVs
02:55 - the triangles and all of it makes up our
02:58 - mesh so we create the mesh and we apply
03:00 - it to our mesh filter and if we run this
03:02 - code here with the code running we can
03:05 - see that indeed we have a mesh inside of
03:06 - our mesh filter
03:07 - there you go zero vertices zero
03:08 - triangles but it's in here okay great so
03:11 - now in here let's make a simple quad
03:13 - okay so I've heard a nice function in
03:15 - order to add a quant again in following
03:18 - with what we've learned in the previous
03:19 - video about how a mesh works for quad we
03:22 - need four vertices for UVs and six
03:24 - triangles so here on this function we
03:26 - are modifying these arrays so here we're
03:29 - just setting up the vertices and the
03:31 - triangles so here we define a certain
03:33 - rotation that we want to add into our
03:34 - sprite in this case let's start off
03:36 - simple so at 0 and here we just apply
03:39 - the rotation onto our quad size in order
03:41 - to come up with the all of the corners
03:43 - so by applying the various rotations we
03:45 - can take our quad size and build our
03:46 - quad so in here we are placing the
03:49 - vertex on the lower left corner then we
03:51 - place on the upper left corner then on
03:54 - the upper right corner and finally on
03:55 - the in lower right corner and then we
03:58 - have the triangles which simply connect
03:59 - them so we connect the zero so we're
04:01 - left into the one so upper left and into
04:03 - the two which is on the upper right
04:05 - again if one of this seems some series
04:07 - make sure you check out the previous
04:09 - mesh video and all of this will be clear
04:11 - so let's see this in there it is we have
04:13 - our nice pink square it's pink because
04:15 - we did not add a material nor the UV but
04:17 - if we pass over here with our wireframe
04:20 - enabled you can see our quad is correct
04:22 - so we have our four vertices with our
04:24 - two polygons triangles okay so far so
04:27 - good now in here let's make sure that we
04:29 - take care of our base index
04:31 - automatically so that we can spawn this
04:33 - in order to add a new quad every single
04:35 - time
04:54 - okay so here I've had been in for the
04:56 - current quad index as well as a constant
04:58 - for the max quad amount each mesh is
05:01 - limited to a total of 65,000 vertices so
05:04 - since we are making quads essentially we
05:06 - have a total of 65 thousand divided by
05:09 - four so we have around a total of
05:11 - fifteen thousand maximum quads we can
05:13 - put in a single mesh so with that
05:15 - maximum then we simply update in here if
05:17 - we go past that two meshes phone so
05:19 - let's not do anything we're going to
05:21 - handle this later and then here we
05:23 - simply calculate the vertex index based
05:25 - on the quad index x force since we have
05:27 - four vertices per quad and now the
05:29 - triangle we multiply by six and then at
05:32 - the end of all of this we simply
05:33 - increment the quad index this function
05:35 - also takes in a position which is simply
05:37 - applied into our vertices and finally
05:39 - here when we initialize our vertices we
05:41 - multiply them by the max quad amount so
05:45 - just like that they all have the correct
05:46 - size okay okay so in here we are
05:48 - spawning two quads so we should be able
05:50 - to see two quads let's see and here we
05:53 - are and indeed you can see two different
05:54 - ones and here we can see the two quads
05:57 - being rendered and they are all part of
05:59 - the same mesh okay great
06:01 - so now that we can spawn multiple quads
06:02 - let's deal with the UV okay so here I've
06:10 - added the UV as you can see they use the
06:12 - same indexes as the vertices and in here
06:14 - I just set it to display the entire
06:16 - texture so on the lower left corner we
06:18 - are on 0 0 and on the upper right we are
06:20 - on 1:1 now here back in the editor all
06:22 - we need to do is create a new material
06:25 - and in here we just drag the sprite just
06:28 - like that and we drag the material into
06:31 - our mesh render
06:32 - ok so let's see and if there is we have
06:34 - our UV being applied so we can see our
06:36 - quads using our texture awesome so now
06:39 - let's add a quad every time we fire our
06:41 - weapon so for that I have a script which
06:44 - fires an event so we can use that
06:49 - so I had the serialized filmed for the
06:51 - character aim handler script so here
06:54 - just drag the script reference on to it
06:56 - now in here we can simply go into it and
06:59 - subscribe to the on shoot event so here
07:04 - how this character aim handler is
07:05 - implemented is not relevant to our mesh
07:07 - particle system all we need is to have
07:09 - enough information in order to be able
07:10 - to spawn our particles so just for
07:13 - testing I'm going to add a text pop-up
07:16 - so I'm using this function from the
07:19 - utilities which as always you can grab
07:20 - for free from unity code monkey calm so
07:23 - with this we should be able to see when
07:24 - this event is being fired so let's see
07:26 - and here we are when I shoot yep there
07:28 - you go we have the nice event being
07:29 - fired okay great
07:30 - again always remember to keep your code
07:32 - nice and clean and all your systems
07:34 - decoupled so the mesh particle system
07:36 - doesn't care how this character works
07:38 - all it cares is that it has an event so
07:40 - that it can do its thing so this event
07:43 - passes in a gun endpoint position so
07:46 - let's point a pawn on it so we simply
07:47 - call at wand and we pass in the gun
07:50 - endpoint position let's get rid of these
07:53 - two and just like that and here since
07:55 - we're adding a quad after being in sin
07:57 - she ate every time we modify our local
07:59 - arrays we need to update them on the
08:01 - mesh so let's copy this and add it down
08:03 - here okay so we should be able to see a
08:08 - quad spawned whenever we fire our weapon
08:10 - so here I am looking around and I shoot
08:12 - and there we go there's a nice quad
08:14 - being spawned exactly where it's
08:15 - supposed to so click and click and there
08:18 - you go so I can now spawn as many quads
08:20 - as I want whenever I shoot all right
08:21 - great so now that we have this working
08:24 - let's make our quad move so back in our
08:26 - particle system script let's go down
08:28 - here to make a function so we can update
08:31 - each quad so let's make it a public void
08:34 - and we're going to call this update pond
08:36 - and now in here we will receive an int
08:38 - for the quad index then receive a
08:41 - vector3 for the new position and then we
08:43 - can also receive on the other so it
08:45 - holds for the rotation and if we want a
08:47 - vector3 for the quad size so in order to
08:52 - update it we do exactly the same code we
08:54 - were doing in here so let's copy from
08:56 - here and let's put it in here and now up
08:59 - here on this one we call
09:03 - passing the quad index then the position
09:07 - then a rotation and the quad sighs and
09:11 - then we update our mesh arrays just like
09:16 - that okay so we now have a function to
09:18 - add a new quand so essentially it
09:20 - modifies the current quad index and then
09:22 - increment it and then we have a function
09:24 - to modify whatever quad index we give it
09:27 - so now here just for testing let's make
09:29 - it constantly move so here when we call
09:31 - add quad and let's make sure that it
09:33 - returns the current spawned quad index
09:35 - so this one returns an int and we're
09:38 - going to store an end for the spawn quad
09:40 - index and then we return this so that
09:45 - means that here when we spawn a new quad
09:47 - when the character shoots we can have an
09:49 - int for our spawn quad index then we can
09:56 - use this quad index in order to call our
09:58 - update quad to constantly move our quad
10:00 - so here just we're testing I'm going to
10:02 - use the very useful function updater
10:04 - again from the utilities so this one
10:07 - takes in an action that gets called on
10:09 - every update so on every update let's
10:14 - call update quad we pass in our spawned
10:17 - quad index and then let's simply
10:19 - increase the position all right so with
10:28 - this very simple code we should be able
10:29 - to add a quad whenever we should and
10:31 - then that same quad won't constantly be
10:33 - moving up into the right on every single
10:35 - frame so let's try okay here we are now
10:38 - if I shoot and there you go there's the
10:40 - quality it gets spawned and it's moving
10:41 - up and away and shoot some more and
10:43 - every single one of them is
10:44 - independently being moved away all right
10:46 - awesome now let's play around with the
10:48 - rotation and scaling to make sure that
10:50 - it all works
10:57 - all right so here I just had a two
11:00 - fields one for the quantize and for the
11:01 - rotation and again we're doing the same
11:03 - thing increasing on every frame so let's
11:06 - see if this is working okay here we are
11:08 - and let's shoot any of their yo the quad
11:10 - was in sin she ate it and it is
11:12 - constantly increasing in size and
11:13 - rotating on every single frame awesome
11:16 - and again we can spawn a bunch more and
11:18 - yep each one of them is independently
11:21 - being rotated and increasing in size
11:23 - okay now these shells are actually not
11:25 - supposed to be squares but rather
11:27 - there's some rectangles so let's do that
11:29 - now so here we should also modify the
11:31 - add quad in order to receive a starting
11:33 - point for the rotation and a vector
11:36 - three for the quad size and we simply
11:40 - pass it in here okay so now in order to
11:48 - make it a square let's simply put point
11:51 - five on the X and one on the Y and let's
11:53 - see what this looks like and here we are
12:00 - and click and there you go as you can
12:02 - see it is not correct instead of a
12:04 - rectangle we got a square that is
12:05 - slightly rotated so here when we set the
12:08 - vertex positions we need to do some
12:10 - different math in case the squad size is
12:12 - skewed or not okay so if it is skewed we
12:23 - have to apply the rotation only to our
12:25 - actual rotation and then we multiply it
12:27 - by our quad size impacting for each
12:30 - vertex so minus minus minus plus and so
12:32 - on so I need to do is come true on the
12:34 - skew alright let's test here we are and
12:39 - shoot any of there you go we have our
12:41 - sprite displayed as a rectangle now
12:43 - let's apply rotation and scaling and
12:45 - here we are and shoot any of there you
12:47 - go it is rotating in scale okay awesome
12:50 - now instead of always displaying every
12:51 - single quad as an entire texture let's
12:54 - make sure we add some proper UV for each
12:56 - specific texture so over here in our
12:59 - script let's go up here to the finest
13:01 - truck that we're going to set in the
13:03 - editor
13:06 - so we have a struct for our particle UV
13:09 - pixels and we have two vector two ends
13:12 - one for the zero zero so 11 left
13:14 - coordinate and one for the 1 1 so the
13:16 - upper right corner so essentially we're
13:17 - going to input pixel coordinates for the
13:19 - 11 left and upper right and then to UM
13:21 - be automatically calculated into
13:22 - normalized values so in here let's make
13:25 - a serialized field of an array of
13:28 - particle UV pixels and to make it show
13:33 - up in the editor all we need to do is
13:34 - mark this struct as system dot
13:37 - serializable okay now in the editor in
13:41 - here you can see that we have a field
13:42 - for the particle UV pixels array and for
13:45 - surgeon let's just put 1 so here we have
13:48 - one element Aereo for the UV 0 0 & 1 1 &
13:50 - 4 now let's try displaying the entire
13:52 - texture so here is the bullet shell
13:54 - casing as you can see it's a simple 10
13:56 - by 20 texture so here for 0 0 0 0 0 and
14:00 - for the 1 let's put down 10 by 20 okay
14:03 - that's our field setup so now here our
14:05 - script has all of the UV data inside
14:07 - this array but the mesh works with
14:10 - normalized valves so we need to convert
14:11 - them from pixels into those normalized
14:13 - values so here making a nice internal
14:18 - struct this one contains vector 2 wins
14:21 - for the UV 0 and UV 1 and these won't be
14:23 - the normalized values so now I have a
14:31 - array of UV coordinates so let's fill
14:33 - this out
14:56 - okay so here we have our conversion we
14:59 - go into the mesh renderer in order to
15:01 - grab the material then from that
15:03 - material we grab the texture and with
15:05 - the texture we grab the width and height
15:06 - and then with that we create the new UV
15:09 - chords so we take the values in pixels
15:12 - and divide by the width and height in
15:14 - order to get the normalized bounce so at
15:16 - the end we can set the UV chords array
15:18 - to be this list without - alright
15:21 - alright
15:22 - so essentially with this design here
15:24 - where we have two different struts we
15:27 - have one that is a very nice
15:28 - user-friendly structure that we expose
15:30 - in the editor so we can input pixels
15:32 - which are easy and then we have our
15:35 - internal structure which converts those
15:36 - pixels into normalized values that we
15:38 - can then use to run our code right so
15:41 - with all this now we just need to apply
15:42 - this to our quads so when we add a
15:44 - column let's also receive an int for the
15:47 - UV index okay now we go down here and
15:53 - now instead of showing the entire
15:55 - texture for everyone let's apply it down
15:57 - so you go into the UV court array and
16:00 - access the UV index so this returns a UV
16:03 - chords
16:11 - all right so here we're applying
16:13 - everything so on the lower left corner
16:15 - we have the UV zero zero for the upper
16:17 - right we have the 1 1 and for these we
16:19 - calculate the new movies ok so with this
16:21 - we should now be able to define which
16:23 - part of the texture we show in our quad
16:25 - ok so we should be able to see the phone
16:27 - quad just like previous on let's click
16:29 - and if there is everything some works
16:31 - great all right now let's see the proper
16:33 - use case for all of this
16:34 - here instead of having this material
16:36 - let's make a material of the pod which
16:38 - as you can see is a spreadsheet with
16:40 - various stages so here on let's drag the
16:44 - bullet material and here you can see the
16:46 - texture is 128 by 16 so if we put that
16:50 - value 128 by 16 and we click and again
16:53 - we still see the exact same entire
16:55 - texture but that's not what we want so
16:57 - let's stop and instead let's make it
16:59 - just 16 by 16 and now we shoot and there
17:02 - you go now we can only see the very
17:03 - first particle so here just film it up
17:06 - with all of them alright so I've been
17:17 - put all of the pace on coordinates for
17:19 - all of the various elements and now here
17:21 - for testing let's choose a random UV
17:23 - index ok so you hear around let's shoot
17:29 - and there you go there's one more
17:31 - particle and there's another one and as
17:33 - you can see it's different and that one
17:34 - is different and different and different
17:36 - and different so just like this we can
17:38 - input our UV coordinates and they get
17:41 - calculated automatically and used based
17:43 - on a certain index all right awesome
17:45 - ok so with this working now let's make
17:48 - some scripts to hand on the blood and
17:49 - the shell particles so here let's make a
17:52 - new script call this the shell particle
17:55 - system Handler and now here this one
17:59 - already has all the coordinates for the
18:00 - bullets so let's leave this one and set
18:02 - duplicate this what's going this new and
18:06 - each on particle system Handler and drag
18:08 - this script on to it and drag the
18:10 - correct material all right so here we
18:12 - have this one with the correct
18:13 - coordinates the correct material and
18:15 - this script and for now this other one
18:17 - is disabled we will deal with the pallet
18:19 - later so now in this script we're going
18:21 - to have a logic for every single shell
18:23 - so let's start off with a
18:25 - function to spawn any simple shell let's
18:29 - also make this a singleton class so we
18:31 - can easily call this function alright so
18:40 - now we want to use this function so
18:42 - let's take our testing code away from
18:44 - the particle system and into a proper
18:46 - testing class so here we just make in
18:48 - you see sharp script code our testing
18:50 - let's make a testing game object drag
18:53 - the script onto it okay and now here
18:55 - let's who are testing so let's copy all
18:57 - this ok so now our mesh particle system
19:06 - no longer contains any references to the
19:08 - player or anything other than the
19:09 - particle system and here on the testing
19:12 - we have a reference to the player and we
19:13 - are subscribing to the on shoot event so
19:16 - in here let's s our shell so we go into
19:17 - the shell particle system handler we
19:20 - access the instance and we call spawn
19:22 - shell so here we pass in the position
19:24 - and a direction okay so this simple now
19:28 - let's deal with this here on the shell
19:30 - system handler let's create a class that
19:32 - will handle a single shown not only
19:38 - constructor let's receive the position
19:40 - and direction let's also receive the
19:46 - mesh particle system ok so when we
19:51 - create a single we go into the mesh we
19:53 - call our add quad function so this will
19:57 - return our private in for this quad
19:59 - index
20:08 - all right so we instantiate our quad
20:11 - with our position rotation and quad size
20:13 - and then we're going to have a update
20:15 - function and in here we're going to
20:18 - handle our movement so we update the
20:26 - position updated rotation and update our
20:27 - quad alright so this is our single class
20:30 - which represents a single shell so now
20:32 - we can go back up here into our main
20:34 - class and we're going to have a list of
20:38 - single and now on this one we have a
20:44 - private void update and on our update
20:47 - we're simply going to cycle through all
20:48 - of our shells and we simply call the
20:52 - update function ok that's it now in here
20:56 - all we do is go into the single list and
20:58 - we add a new single and passed in the
21:01 - position direction and the mesh particle
21:03 - system so just like that we have this
21:06 - very nice class which takes care of
21:08 - everything related to the shell
21:10 - particles and all we need to do is call
21:12 - this function which we are doing over
21:14 - here in our testing script so we are
21:16 - spawning shells whenever we shoot with
21:18 - our character and they won't be moving
21:20 - up and to the right so let's test ok so
21:23 - here we are let's shoot and there you go
21:25 - there's a particle it was correctly
21:27 - spawn and it's correctly moving all
21:28 - right all right awesome so now we have
21:31 - everything so working like previously
21:33 - except everything is encapsulated into
21:35 - its own nice class now instead of just
21:37 - making them we go up into the right
21:39 - let's make it based on the rotation of
21:40 - the player
21:50 - okay so here I calculated each direction
21:53 - based on the two values that this event
21:55 - fires so it triggers the shoot position
21:57 - which is where we click and the gun
21:58 - endpoint position so using those who we
22:01 - can get the shoot Direction then here
22:03 - just stop setting it backwards so it
22:05 - doesn't spawn the shell exactly on the
22:07 - gun endpoint position but rather more
22:08 - towards where the weapon should be fired
22:10 - and then we have the shall move
22:11 - direction which we just take the shoot
22:13 - direction and we apply a negative 90
22:15 - degree angle so let's see this so here I
22:18 - am and if I shoot if there you're the
22:20 - particle and left-right from there and
22:21 - went upwards so like this it's going up
22:24 - and then it's going to the left and it's
22:26 - going down just like that
22:27 - right great so now that we have our
22:30 - shells correctly moving away let's make
22:32 - them stop after a while so here just had
22:35 - some slow down speed code okay so here I
22:50 - just had the move speed field then we
22:52 - increase the position by the move speed
22:54 - the same thing with the rotation and
22:56 - then we simply slow down to move speed
22:58 - on every frame so the particle should
23:00 - move quickly and then slow down okay so
23:02 - we are and shoot any of there we go the
23:04 - particle goes away and then stops so
23:06 - shoot a bunch and there you go just like
23:07 - that
23:08 - all right now just add some
23:09 - randomization okay so here we are and I
23:16 - shoot and shoot at same place and there
23:18 - you go I had some randomization on the
23:21 - angles as well as the move speed all
23:23 - right awesome so in here we are spawning
23:25 - shells and we are moving them and now
23:27 - when they're done moving let's update
23:28 - and remove them from our single list so
23:31 - here let's add a public bone is movement
23:35 - complete every similarly return if the
23:38 - move speed is under a certain amount so
23:43 - then we go all the way up here we call
23:45 - update all right and then we ask if the
23:47 - single if the movement is complete then
23:50 - we want to remove it from the list
23:52 - so it's convert this from a 4h into a
23:54 - four
23:57 - all right so we are update we call is
23:59 - moving complete and then if it is
24:01 - complete then we want to remove it from
24:03 - the list so you remove it and then go
24:07 - backwards on the index all right
24:09 - so in here just for testing let's add a
24:11 - debug log on the single list count so
24:15 - you should be able to see this increase
24:16 - once the shell is active and decrease as
24:18 - they stop okay so here we are and on the
24:20 - logs you can see that we have no shells
24:22 - active so now we click there we go we
24:24 - have one and after a while it stops and
24:26 - there you go zero so keep shooting a
24:28 - bunch of them are active and now after a
24:30 - while you have there you go zero active
24:32 - so just like that our code is now
24:34 - spawning and cleaning up after itself
24:35 - awesome so just like this you can
24:38 - already see our very nice particle mesh
24:40 - system so they are ongoing and they
24:42 - spawn and they stay there so I can move
24:44 - over them and they remain in there so we
24:46 - have the code working for persistent
24:48 - particles but we can also use this for
24:49 - particles that disappear so over here I
24:52 - have a nice third spreadsheet so these
24:54 - particles are meant to disappear so here
24:56 - on let's duplicate the shell particle
24:58 - system and this will be our dirt
24:59 - particle system okay so here I have the
25:08 - other particle system handler on a new
25:09 - game object using this script with a
25:12 - dirt material so now here on the system
25:14 - panel let's go into this single and
25:16 - let's add the behavior for the dirt
25:18 - inside of the shell the main thing we're
25:20 - going to remove is the rotation since we
25:22 - don't want the dirt to rotate and just
25:24 - like that okay now on testing so here we
25:27 - can ask the character if it is moving
25:30 - and if it is moving then let's go into
25:33 - the dirt particle system and one access
25:35 - the instance and let's rename that
25:37 - function in order to be not spawn shell
25:39 - so in here just rename this into spawn
25:41 - dirt so we spawn it based on the
25:45 - character position and with direction of
25:48 - the character that I can't move
25:50 - direction x -1 so there it won't be
25:53 - kicking backwards okay so just like this
25:56 - we should be able to see our third
25:57 - sprites being spawned let's see okay
26:00 - here we are and move and there go the
26:02 - dirt particles are indeed being spun now
26:04 - they are way too many since it's going
26:05 - one for each frame so let's reduce that
26:21 - okay so here I've made a nice dolly
26:23 - function we simply store the next spawn
26:25 - time on a float and whenever we spawn we
26:27 - increase that so let's see okay so no
26:31 - particle since we're I don't now move
26:32 - and there you go the particles get
26:34 - spawned and they no longer go exactly
26:36 - one per frame right awesome
26:37 - however again these are guns are not
26:39 - meant to be persistent so let's see on
26:41 - with that in here we have our code for
26:43 - icing on dirt particle okay we check it
26:45 - move incomplete okay and then let's also
26:47 - add a Pollock boy let's call it destroy
26:49 - song and we're going to destroy a
26:52 - particle is actually very simple we
26:53 - simply go into the mesh particle system
26:55 - and we're going to make a function
26:57 - called destroy pond and we pass in the
27:00 - quad in X okay so let's make that
27:02 - function so here we are in the mesh
27:04 - particle system and let's go make a
27:06 - public void destroy quad we receive an
27:08 - int for the quad index in order to
27:11 - destroy it it's actually very simple
27:13 - we simply complete the vertexes so we
27:19 - simply based on the quad we modify all
27:22 - those vertexes in order to go into
27:23 - vector 3 0 so essentially we reduce the
27:26 - entire size of the quad so nothing is
27:27 - visible okay so we have the destroyed
27:29 - quad now back into the third particle
27:31 - system and here we simply need to call
27:33 - this and let's go on the way up here
27:34 - when movement is complete we call the
27:36 - single only to destroy itself and remove
27:39 - it from the way alright so let's see if
27:41 - they vanish ok here we are let's move
27:43 - and there you go there's the particles
27:45 - and after a while if there you go they
27:47 - all start to vanish so after a while
27:49 - when they stop moving
27:50 - think I'm gonna vanish right awesome so
27:52 - we now have disappearing particles now
27:54 - here if we look at the dirt texture you
27:56 - can see that it's actually a spreadsheet
27:57 - it has various frames of animation so
27:59 - let's make sure we add that so first I
28:02 - need to add all of the pixels in here on
28:04 - the mesh particle system
28:14 - all right so I have added all of the
28:16 - pixels for each single fried sheet
28:18 - position on the entire texture and now
28:20 - here the way that we set up our mesh
28:22 - particle system makes it very easy in
28:24 - order to do frame animation in here we
28:26 - already receive the UV index so all we
28:28 - need to do is actually increase it so
28:29 - here on the dirt let's go into our
28:31 - single in order to modify the behavior
28:33 - in here so first we store a private int
28:35 - for the UV index and here we start off
28:39 - at 0
28:55 - all right so here I just added some
28:57 - simple flip book animation so we have a
29:00 - timer and the timer max so in here we're
29:02 - going to run every 10 frames per second
29:04 - so whenever the timer goes past the max
29:06 - we simply reduce the timer so here
29:09 - that one we reduce the timer and we
29:11 - increase the UV index and that's where
29:12 - we pass on the update quad so that's it
29:15 - very simple then let's test okay here we
29:17 - are and move any of there you go as you
29:19 - can see we have our nice dirt particles
29:22 - being spawned and they are being nicely
29:24 - animated on a frame-by-frame basis all
29:26 - right that's the effect awesome so here
29:29 - we are with a small prod and pure
29:31 - particles and there you go there's a
29:32 - nice effect all right awesome now one
29:36 - thing we still need to fix is in terms
29:37 - of performance looking at the stats you
29:39 - can see how it goes out massively every
29:41 - time we increase so just like that the
29:43 - more particles we have the much higher
29:45 - this and we also need to fix over here
29:48 - the bouncer ego once we go up here they
29:49 - are vanished that's because the bounce
29:51 - so let's fix both those things first for
29:54 - the bounds we can simply go into the
29:55 - mesh and set the bounce and here we can
29:59 - simply put a very massive size and just
30:03 - like this if we go all the way up here
30:05 - there yo now the mesh and all other
30:06 - vanishes and works all the time and ever
30:08 - so you can go down here shoot and all
30:11 - the particles are still up there and
30:12 - down there alright great if you want you
30:14 - can calculate this into a proper bounce
30:16 - but for most cases just making it huge
30:19 - won't make it work so now for the
30:20 - performance
30:22 - the biggest issue is whenever we update
30:24 - a quant we are uploading it to the mesh
30:26 - so if we have several quads being
30:28 - updated on the same frame we end up
30:30 - calling this and passing our own welcome
30:32 - arrays into our mesh multiple times per
30:34 - frame that is obviously very wasteful so
30:37 - let's make sure we only do this at most
30:38 - once per frame so for that we can go up
30:41 - here and let's make a red phone and call
30:45 - this update vertices update TV and
30:49 - update triangles okay now let's go down
30:52 - here and make a prayer void update and
30:57 - our update if we have update vertices
31:02 - then I simply updating mashed-up
31:04 - vertices equals our vertices all right
31:08 - just like that do everything for all the
31:10 - others all right there it is now let's
31:15 - also make sure this runs at the end so
31:16 - instead of updating let's put it on late
31:18 - update and now in here whenever we
31:20 - modify something so on destroy pawn
31:22 - let's set the update vertices in to true
31:26 - then here when we update everything
31:28 - instead of calling this lets update the
31:30 - vertices update the UVs then we also
31:35 - update the triangles so just like this
31:39 - we simply set bones if we wanted we
31:41 - could then break this into three
31:43 - separate functions to update the
31:44 - vertices the UVs are triangles but for
31:46 - now let's leave it like this so we just
31:48 - set it to true and then at the end of
31:50 - the frame if it is true then we update
31:51 - them if not then we'll leave it alone
31:53 - all right so just like this we should
31:54 - greatly have improved our performance
31:56 - and here if we look at the stats
31:58 - previously we were going all the way up
32:00 - to eight milliseconds and now if you
32:02 - move there you go only two and we can
32:04 - move and shoot and a whole bunch of
32:06 - particles and there you go it's now much
32:07 - better all right so now I'm just going
32:10 - to add all the other particles the same
32:11 - way that we have these two
33:21 - all right so I have implemented all of
33:24 - the particles so first of all we still
33:26 - got the shells very nice then we still
33:28 - got the dirt and you can already see the
33:31 - footprints so after some time the
33:33 - footprints get spun there you go they
33:34 - stay there and then we have the bond so
33:37 - whenever I shoot them if they're go
33:38 - somewhat particles going out and when I
33:41 - kill him
33:41 - and it spawns a flying body and there
33:44 - you go he flies away and the flying body
33:45 - spawn some more particles so just like
33:48 - this we have a whole bunch of types of
33:50 - them being spawned and after all the
33:53 - movement ends everything stays nice and
33:54 - stable and they stay on the map forever
33:57 - so just like this we have a very cool
34:00 - persistent particle system awesome
34:02 - however in here we still have two slight
34:04 - issues first is simply the amount of
34:07 - quads in here we defined a max what
34:09 - amount of 15000 so as soon as we go past
34:12 - that in here we are no longer going to
34:14 - spawn any more quads we could solve this
34:16 - by dynamically creating a new mesh every
34:18 - time one of them is full and the second
34:20 - problem has to do with sorting so over
34:23 - here you can see someone now it spawned
34:25 - some shell particles so over here is the
34:28 - enemy now behind them I'm going
34:30 - to place a whole bunch of shell
34:31 - particles there's always some footprints
34:34 - and stuff okay so now when I shoot him
34:36 - and there you go over what particles
34:38 - being spawned and just like that you can
34:40 - see that the blood particles which
34:42 - respond afterwards actually show up
34:43 - behind both the shells and the
34:46 - footprints the issue here is because we
34:48 - have various separate meshes so one of
34:50 - them has to be on top of the other so in
34:52 - order to make sure that new particles
34:54 - stay on top of other particles we would
34:56 - need to use a giant texture appleís that
34:59 - contains both the bullets the footprints
35:01 - the blood and anything where we want
35:03 - place them all inside a giant texture
35:05 - Atlas and use a single mesh with that
35:07 - giant texture Atlas to spawn every
35:10 - single one of our particles so if we
35:12 - merged all of this in the same mesh it
35:13 - would solve our sorting issues so those
35:16 - are the two issues that we still have
35:18 - with this class this video is already
35:20 - super long so let me know in the
35:22 - comments if you'd like to see a video
35:23 - covering the solutions to both those
35:24 - problems and expand upon this further
35:26 - now in the future is something that I
35:28 - really want to do is take this whole
35:30 - system and convert all of it into
35:32 - superfast ECS so stay tuned for that as
35:34 - always you can download the project
35:36 - files in utilities from unity code
35:37 - monkey comm subscribe the channel for
35:39 - more unity tutorials post any questions
35:41 - that have in the comments and I'll see
35:42 - you next time
35:46 - [Music]
35:48 - you

Cleaned transcript:

in this video we're going to make a persistent particle system this is a great system for when you want to spawn some particles and have them stay on the map like some blood or footprints let's begin hello and welcome I'm your code monkey and this channel is all about helping you learn how to make your own games with indepth tutorials made by a professional indie game developer so if you find the video helpful consider subscribing okay so here's what we want to create over here I have my character I can move them around and when I do you can already see two uses of the persistent particle system when I move you can see dirt being kicked around and vanishing and you can also see some footprints where I went through so as you can see the dirt vanishes but the footprints stay always on the map now another uses with the weapon so whenever I shoot there you go there are some very nice shell particles exiting my weapon and once they stop they stay on the particle system and finally over here I have an enemy and when I shoot him there you go you can see some blood particles and if I shoot him some more he turns into a flying body and leaves behind a nice trail of particles and as you can see once the particles stop moving they remain permanently on the map so these are various uses for the persistent particle system we have particles being spawned they move then they stop in their final destination and they stay there forever alright so this is our goal let's get to it all right so here's our starting scene over here I have the player and I can move them around and shoot and as you can see there are no particles anywhere and over here is an enemy and again I can shoot him but no particles come out and after a while I kill him and there goes the flying body and again no particles ok so this is our starting point now the way we're going to build our system is by making a custom dynamic mesh so if you're not familiar with how to make a custom mesh through code then check out the video linked in the description that video won't teach you everything you need to know about how a mesh is made and what are the elements required to make it so here for our system let's start off with basics and draw a simple quad so first let's make our script a new script let's call this the mesh particle system and here we make a new game object and drag the script on to okay now to make our mesh visible we need to add a mesh filter that's the component that holds a mesh and a mesh renderer which is a component that defines how the mesh is displayed okay so far so good what open up the script okay now in here and let's set up our mesh okay so here's our starting mesh code again if you're not familiar with this then go first check out the mesh video a link in the description once you see that video you won't be able to understand what all this is so essentially we have the vertices the UVs the triangles and all of it makes up our mesh so we create the mesh and we apply it to our mesh filter and if we run this code here with the code running we can see that indeed we have a mesh inside of our mesh filter there you go zero vertices zero triangles but it's in here okay great so now in here let's make a simple quad okay so I've heard a nice function in order to add a quant again in following with what we've learned in the previous video about how a mesh works for quad we need four vertices for UVs and six triangles so here on this function we are modifying these arrays so here we're just setting up the vertices and the triangles so here we define a certain rotation that we want to add into our sprite in this case let's start off simple so at 0 and here we just apply the rotation onto our quad size in order to come up with the all of the corners so by applying the various rotations we can take our quad size and build our quad so in here we are placing the vertex on the lower left corner then we place on the upper left corner then on the upper right corner and finally on the in lower right corner and then we have the triangles which simply connect them so we connect the zero so we're left into the one so upper left and into the two which is on the upper right again if one of this seems some series make sure you check out the previous mesh video and all of this will be clear so let's see this in there it is we have our nice pink square it's pink because we did not add a material nor the UV but if we pass over here with our wireframe enabled you can see our quad is correct so we have our four vertices with our two polygons triangles okay so far so good now in here let's make sure that we take care of our base index automatically so that we can spawn this in order to add a new quad every single time okay so here I've had been in for the current quad index as well as a constant for the max quad amount each mesh is limited to a total of 65,000 vertices so since we are making quads essentially we have a total of 65 thousand divided by four so we have around a total of fifteen thousand maximum quads we can put in a single mesh so with that maximum then we simply update in here if we go past that two meshes phone so let's not do anything we're going to handle this later and then here we simply calculate the vertex index based on the quad index x force since we have four vertices per quad and now the triangle we multiply by six and then at the end of all of this we simply increment the quad index this function also takes in a position which is simply applied into our vertices and finally here when we initialize our vertices we multiply them by the max quad amount so just like that they all have the correct size okay okay so in here we are spawning two quads so we should be able to see two quads let's see and here we are and indeed you can see two different ones and here we can see the two quads being rendered and they are all part of the same mesh okay great so now that we can spawn multiple quads let's deal with the UV okay so here I've added the UV as you can see they use the same indexes as the vertices and in here I just set it to display the entire texture so on the lower left corner we are on 0 0 and on the upper right we are on 11 now here back in the editor all we need to do is create a new material and in here we just drag the sprite just like that and we drag the material into our mesh render ok so let's see and if there is we have our UV being applied so we can see our quads using our texture awesome so now let's add a quad every time we fire our weapon so for that I have a script which fires an event so we can use that so I had the serialized filmed for the character aim handler script so here just drag the script reference on to it now in here we can simply go into it and subscribe to the on shoot event so here how this character aim handler is implemented is not relevant to our mesh particle system all we need is to have enough information in order to be able to spawn our particles so just for testing I'm going to add a text popup so I'm using this function from the utilities which as always you can grab for free from unity code monkey calm so with this we should be able to see when this event is being fired so let's see and here we are when I shoot yep there you go we have the nice event being fired okay great again always remember to keep your code nice and clean and all your systems decoupled so the mesh particle system doesn't care how this character works all it cares is that it has an event so that it can do its thing so this event passes in a gun endpoint position so let's point a pawn on it so we simply call at wand and we pass in the gun endpoint position let's get rid of these two and just like that and here since we're adding a quad after being in sin she ate every time we modify our local arrays we need to update them on the mesh so let's copy this and add it down here okay so we should be able to see a quad spawned whenever we fire our weapon so here I am looking around and I shoot and there we go there's a nice quad being spawned exactly where it's supposed to so click and click and there you go so I can now spawn as many quads as I want whenever I shoot all right great so now that we have this working let's make our quad move so back in our particle system script let's go down here to make a function so we can update each quad so let's make it a public void and we're going to call this update pond and now in here we will receive an int for the quad index then receive a vector3 for the new position and then we can also receive on the other so it holds for the rotation and if we want a vector3 for the quad size so in order to update it we do exactly the same code we were doing in here so let's copy from here and let's put it in here and now up here on this one we call passing the quad index then the position then a rotation and the quad sighs and then we update our mesh arrays just like that okay so we now have a function to add a new quand so essentially it modifies the current quad index and then increment it and then we have a function to modify whatever quad index we give it so now here just for testing let's make it constantly move so here when we call add quad and let's make sure that it returns the current spawned quad index so this one returns an int and we're going to store an end for the spawn quad index and then we return this so that means that here when we spawn a new quad when the character shoots we can have an int for our spawn quad index then we can use this quad index in order to call our update quad to constantly move our quad so here just we're testing I'm going to use the very useful function updater again from the utilities so this one takes in an action that gets called on every update so on every update let's call update quad we pass in our spawned quad index and then let's simply increase the position all right so with this very simple code we should be able to add a quad whenever we should and then that same quad won't constantly be moving up into the right on every single frame so let's try okay here we are now if I shoot and there you go there's the quality it gets spawned and it's moving up and away and shoot some more and every single one of them is independently being moved away all right awesome now let's play around with the rotation and scaling to make sure that it all works all right so here I just had a two fields one for the quantize and for the rotation and again we're doing the same thing increasing on every frame so let's see if this is working okay here we are and let's shoot any of their yo the quad was in sin she ate it and it is constantly increasing in size and rotating on every single frame awesome and again we can spawn a bunch more and yep each one of them is independently being rotated and increasing in size okay now these shells are actually not supposed to be squares but rather there's some rectangles so let's do that now so here we should also modify the add quad in order to receive a starting point for the rotation and a vector three for the quad size and we simply pass it in here okay so now in order to make it a square let's simply put point five on the X and one on the Y and let's see what this looks like and here we are and click and there you go as you can see it is not correct instead of a rectangle we got a square that is slightly rotated so here when we set the vertex positions we need to do some different math in case the squad size is skewed or not okay so if it is skewed we have to apply the rotation only to our actual rotation and then we multiply it by our quad size impacting for each vertex so minus minus minus plus and so on so I need to do is come true on the skew alright let's test here we are and shoot any of there you go we have our sprite displayed as a rectangle now let's apply rotation and scaling and here we are and shoot any of there you go it is rotating in scale okay awesome now instead of always displaying every single quad as an entire texture let's make sure we add some proper UV for each specific texture so over here in our script let's go up here to the finest truck that we're going to set in the editor so we have a struct for our particle UV pixels and we have two vector two ends one for the zero zero so 11 left coordinate and one for the 1 1 so the upper right corner so essentially we're going to input pixel coordinates for the 11 left and upper right and then to UM be automatically calculated into normalized values so in here let's make a serialized field of an array of particle UV pixels and to make it show up in the editor all we need to do is mark this struct as system dot serializable okay now in the editor in here you can see that we have a field for the particle UV pixels array and for surgeon let's just put 1 so here we have one element Aereo for the UV 0 0 & 1 1 & 4 now let's try displaying the entire texture so here is the bullet shell casing as you can see it's a simple 10 by 20 texture so here for 0 0 0 0 0 and for the 1 let's put down 10 by 20 okay that's our field setup so now here our script has all of the UV data inside this array but the mesh works with normalized valves so we need to convert them from pixels into those normalized values so here making a nice internal struct this one contains vector 2 wins for the UV 0 and UV 1 and these won't be the normalized values so now I have a array of UV coordinates so let's fill this out okay so here we have our conversion we go into the mesh renderer in order to grab the material then from that material we grab the texture and with the texture we grab the width and height and then with that we create the new UV chords so we take the values in pixels and divide by the width and height in order to get the normalized bounce so at the end we can set the UV chords array to be this list without alright alright so essentially with this design here where we have two different struts we have one that is a very nice userfriendly structure that we expose in the editor so we can input pixels which are easy and then we have our internal structure which converts those pixels into normalized values that we can then use to run our code right so with all this now we just need to apply this to our quads so when we add a column let's also receive an int for the UV index okay now we go down here and now instead of showing the entire texture for everyone let's apply it down so you go into the UV court array and access the UV index so this returns a UV chords all right so here we're applying everything so on the lower left corner we have the UV zero zero for the upper right we have the 1 1 and for these we calculate the new movies ok so with this we should now be able to define which part of the texture we show in our quad ok so we should be able to see the phone quad just like previous on let's click and if there is everything some works great all right now let's see the proper use case for all of this here instead of having this material let's make a material of the pod which as you can see is a spreadsheet with various stages so here on let's drag the bullet material and here you can see the texture is 128 by 16 so if we put that value 128 by 16 and we click and again we still see the exact same entire texture but that's not what we want so let's stop and instead let's make it just 16 by 16 and now we shoot and there you go now we can only see the very first particle so here just film it up with all of them alright so I've been put all of the pace on coordinates for all of the various elements and now here for testing let's choose a random UV index ok so you hear around let's shoot and there you go there's one more particle and there's another one and as you can see it's different and that one is different and different and different and different so just like this we can input our UV coordinates and they get calculated automatically and used based on a certain index all right awesome ok so with this working now let's make some scripts to hand on the blood and the shell particles so here let's make a new script call this the shell particle system Handler and now here this one already has all the coordinates for the bullets so let's leave this one and set duplicate this what's going this new and each on particle system Handler and drag this script on to it and drag the correct material all right so here we have this one with the correct coordinates the correct material and this script and for now this other one is disabled we will deal with the pallet later so now in this script we're going to have a logic for every single shell so let's start off with a function to spawn any simple shell let's also make this a singleton class so we can easily call this function alright so now we want to use this function so let's take our testing code away from the particle system and into a proper testing class so here we just make in you see sharp script code our testing let's make a testing game object drag the script onto it okay and now here let's who are testing so let's copy all this ok so now our mesh particle system no longer contains any references to the player or anything other than the particle system and here on the testing we have a reference to the player and we are subscribing to the on shoot event so in here let's s our shell so we go into the shell particle system handler we access the instance and we call spawn shell so here we pass in the position and a direction okay so this simple now let's deal with this here on the shell system handler let's create a class that will handle a single shown not only constructor let's receive the position and direction let's also receive the mesh particle system ok so when we create a single we go into the mesh we call our add quad function so this will return our private in for this quad index all right so we instantiate our quad with our position rotation and quad size and then we're going to have a update function and in here we're going to handle our movement so we update the position updated rotation and update our quad alright so this is our single class which represents a single shell so now we can go back up here into our main class and we're going to have a list of single and now on this one we have a private void update and on our update we're simply going to cycle through all of our shells and we simply call the update function ok that's it now in here all we do is go into the single list and we add a new single and passed in the position direction and the mesh particle system so just like that we have this very nice class which takes care of everything related to the shell particles and all we need to do is call this function which we are doing over here in our testing script so we are spawning shells whenever we shoot with our character and they won't be moving up and to the right so let's test ok so here we are let's shoot and there you go there's a particle it was correctly spawn and it's correctly moving all right all right awesome so now we have everything so working like previously except everything is encapsulated into its own nice class now instead of just making them we go up into the right let's make it based on the rotation of the player okay so here I calculated each direction based on the two values that this event fires so it triggers the shoot position which is where we click and the gun endpoint position so using those who we can get the shoot Direction then here just stop setting it backwards so it doesn't spawn the shell exactly on the gun endpoint position but rather more towards where the weapon should be fired and then we have the shall move direction which we just take the shoot direction and we apply a negative 90 degree angle so let's see this so here I am and if I shoot if there you're the particle and leftright from there and went upwards so like this it's going up and then it's going to the left and it's going down just like that right great so now that we have our shells correctly moving away let's make them stop after a while so here just had some slow down speed code okay so here I just had the move speed field then we increase the position by the move speed the same thing with the rotation and then we simply slow down to move speed on every frame so the particle should move quickly and then slow down okay so we are and shoot any of there we go the particle goes away and then stops so shoot a bunch and there you go just like that all right now just add some randomization okay so here we are and I shoot and shoot at same place and there you go I had some randomization on the angles as well as the move speed all right awesome so in here we are spawning shells and we are moving them and now when they're done moving let's update and remove them from our single list so here let's add a public bone is movement complete every similarly return if the move speed is under a certain amount so then we go all the way up here we call update all right and then we ask if the single if the movement is complete then we want to remove it from the list so it's convert this from a 4h into a four all right so we are update we call is moving complete and then if it is complete then we want to remove it from the list so you remove it and then go backwards on the index all right so in here just for testing let's add a debug log on the single list count so you should be able to see this increase once the shell is active and decrease as they stop okay so here we are and on the logs you can see that we have no shells active so now we click there we go we have one and after a while it stops and there you go zero so keep shooting a bunch of them are active and now after a while you have there you go zero active so just like that our code is now spawning and cleaning up after itself awesome so just like this you can already see our very nice particle mesh system so they are ongoing and they spawn and they stay there so I can move over them and they remain in there so we have the code working for persistent particles but we can also use this for particles that disappear so over here I have a nice third spreadsheet so these particles are meant to disappear so here on let's duplicate the shell particle system and this will be our dirt particle system okay so here I have the other particle system handler on a new game object using this script with a dirt material so now here on the system panel let's go into this single and let's add the behavior for the dirt inside of the shell the main thing we're going to remove is the rotation since we don't want the dirt to rotate and just like that okay now on testing so here we can ask the character if it is moving and if it is moving then let's go into the dirt particle system and one access the instance and let's rename that function in order to be not spawn shell so in here just rename this into spawn dirt so we spawn it based on the character position and with direction of the character that I can't move direction x 1 so there it won't be kicking backwards okay so just like this we should be able to see our third sprites being spawned let's see okay here we are and move and there go the dirt particles are indeed being spun now they are way too many since it's going one for each frame so let's reduce that okay so here I've made a nice dolly function we simply store the next spawn time on a float and whenever we spawn we increase that so let's see okay so no particle since we're I don't now move and there you go the particles get spawned and they no longer go exactly one per frame right awesome however again these are guns are not meant to be persistent so let's see on with that in here we have our code for icing on dirt particle okay we check it move incomplete okay and then let's also add a Pollock boy let's call it destroy song and we're going to destroy a particle is actually very simple we simply go into the mesh particle system and we're going to make a function called destroy pond and we pass in the quad in X okay so let's make that function so here we are in the mesh particle system and let's go make a public void destroy quad we receive an int for the quad index in order to destroy it it's actually very simple we simply complete the vertexes so we simply based on the quad we modify all those vertexes in order to go into vector 3 0 so essentially we reduce the entire size of the quad so nothing is visible okay so we have the destroyed quad now back into the third particle system and here we simply need to call this and let's go on the way up here when movement is complete we call the single only to destroy itself and remove it from the way alright so let's see if they vanish ok here we are let's move and there you go there's the particles and after a while if there you go they all start to vanish so after a while when they stop moving think I'm gonna vanish right awesome so we now have disappearing particles now here if we look at the dirt texture you can see that it's actually a spreadsheet it has various frames of animation so let's make sure we add that so first I need to add all of the pixels in here on the mesh particle system all right so I have added all of the pixels for each single fried sheet position on the entire texture and now here the way that we set up our mesh particle system makes it very easy in order to do frame animation in here we already receive the UV index so all we need to do is actually increase it so here on the dirt let's go into our single in order to modify the behavior in here so first we store a private int for the UV index and here we start off at 0 all right so here I just added some simple flip book animation so we have a timer and the timer max so in here we're going to run every 10 frames per second so whenever the timer goes past the max we simply reduce the timer so here that one we reduce the timer and we increase the UV index and that's where we pass on the update quad so that's it very simple then let's test okay here we are and move any of there you go as you can see we have our nice dirt particles being spawned and they are being nicely animated on a framebyframe basis all right that's the effect awesome so here we are with a small prod and pure particles and there you go there's a nice effect all right awesome now one thing we still need to fix is in terms of performance looking at the stats you can see how it goes out massively every time we increase so just like that the more particles we have the much higher this and we also need to fix over here the bouncer ego once we go up here they are vanished that's because the bounce so let's fix both those things first for the bounds we can simply go into the mesh and set the bounce and here we can simply put a very massive size and just like this if we go all the way up here there yo now the mesh and all other vanishes and works all the time and ever so you can go down here shoot and all the particles are still up there and down there alright great if you want you can calculate this into a proper bounce but for most cases just making it huge won't make it work so now for the performance the biggest issue is whenever we update a quant we are uploading it to the mesh so if we have several quads being updated on the same frame we end up calling this and passing our own welcome arrays into our mesh multiple times per frame that is obviously very wasteful so let's make sure we only do this at most once per frame so for that we can go up here and let's make a red phone and call this update vertices update TV and update triangles okay now let's go down here and make a prayer void update and our update if we have update vertices then I simply updating mashedup vertices equals our vertices all right just like that do everything for all the others all right there it is now let's also make sure this runs at the end so instead of updating let's put it on late update and now in here whenever we modify something so on destroy pawn let's set the update vertices in to true then here when we update everything instead of calling this lets update the vertices update the UVs then we also update the triangles so just like this we simply set bones if we wanted we could then break this into three separate functions to update the vertices the UVs are triangles but for now let's leave it like this so we just set it to true and then at the end of the frame if it is true then we update them if not then we'll leave it alone all right so just like this we should greatly have improved our performance and here if we look at the stats previously we were going all the way up to eight milliseconds and now if you move there you go only two and we can move and shoot and a whole bunch of particles and there you go it's now much better all right so now I'm just going to add all the other particles the same way that we have these two all right so I have implemented all of the particles so first of all we still got the shells very nice then we still got the dirt and you can already see the footprints so after some time the footprints get spun there you go they stay there and then we have the bond so whenever I shoot them if they're go somewhat particles going out and when I kill him and it spawns a flying body and there you go he flies away and the flying body spawn some more particles so just like this we have a whole bunch of types of them being spawned and after all the movement ends everything stays nice and stable and they stay on the map forever so just like this we have a very cool persistent particle system awesome however in here we still have two slight issues first is simply the amount of quads in here we defined a max what amount of 15000 so as soon as we go past that in here we are no longer going to spawn any more quads we could solve this by dynamically creating a new mesh every time one of them is full and the second problem has to do with sorting so over here you can see someone now it spawned some shell particles so over here is the enemy now behind them I'm going to place a whole bunch of shell particles there's always some footprints and stuff okay so now when I shoot him and there you go over what particles being spawned and just like that you can see that the blood particles which respond afterwards actually show up behind both the shells and the footprints the issue here is because we have various separate meshes so one of them has to be on top of the other so in order to make sure that new particles stay on top of other particles we would need to use a giant texture appleís that contains both the bullets the footprints the blood and anything where we want place them all inside a giant texture Atlas and use a single mesh with that giant texture Atlas to spawn every single one of our particles so if we merged all of this in the same mesh it would solve our sorting issues so those are the two issues that we still have with this class this video is already super long so let me know in the comments if you'd like to see a video covering the solutions to both those problems and expand upon this further now in the future is something that I really want to do is take this whole system and convert all of it into superfast ECS so stay tuned for that as always you can download the project files in utilities from unity code monkey comm subscribe the channel for more unity tutorials post any questions that have in the comments and I'll see you next time you
