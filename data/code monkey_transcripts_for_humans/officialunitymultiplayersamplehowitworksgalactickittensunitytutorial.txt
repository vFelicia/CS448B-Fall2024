With timestamps:

00:00 - hello and welcome I'm your code monkey
00:01 - and here let's do a deep dive on one of
00:04 - unity's official multiplayer samples the
00:06 - galactic kittens game this is a very
00:09 - simple 2D Co-op multiplayer game that
00:11 - works great as a learning project for
00:13 - understanding how to make multiplayer
00:14 - games using unity's official multiplier
00:16 - solution called netcode for game objects
00:18 - of the source code is available so you
00:20 - can download it and pick it apart to
00:22 - understand exactly how it works if
00:24 - you've seen my net code for game objects
00:25 - video you shouldn't be able to easily
00:26 - understand how this project works this
00:28 - project is intended to be as simple as
00:30 - possible it is meant to be a Bare Bones
00:32 - multiplayer sample for something more
00:34 - complex afterwards definitely go take a
00:36 - look at the much more advanced simple
00:37 - Kong boss room that one builds upon this
00:40 - base and includes tons of optimizations
00:42 - that you definitely must learn to make a
00:44 - good multiplayer game the reason why I
00:45 - researched this official project is
00:47 - because I'm currently working on my
00:48 - upcoming free multiplayer course I'm
00:50 - hard to work on it and hopefully should
00:52 - be out within the next few weeks so if
00:54 - you're looking for a guide path stay
00:55 - tuned for that and go watch the free
00:56 - single player course to prepare for it
00:58 - also as the unity they officially
01:00 - sponsored this video so if you want to
01:02 - learn more about this Mo project then
01:04 - check the link in the description to
01:05 - download it and inspect it for yourself
01:06 - and if you want to make multiplayer
01:09 - games then Unity also has tons of useful
01:10 - tools in their Unity gaming Services
01:12 - brand so also check that out with the
01:14 - other Link in the description okay so
01:16 - first let's do a quick look and play
01:18 - through the game and then let's open up
01:20 - the project and inspect how everything
01:21 - works so we can learn how we can build
01:23 - multiplayer games
01:25 - now if you download the projects to try
01:27 - it out there is one very important thing
01:28 - with how the game is set up basically on
01:30 - all the scenes there is one scene called
01:31 - bootstrap this scene starts up all the
01:34 - necessary objects so when testing it out
01:36 - for yourself make sure you go onto this
01:38 - scene before ending play otherwise you
01:39 - might see some errors so here in the
01:41 - scene let's hit a play and try out the
01:43 - game alright so here's the game gonna
01:45 - like the kittens and right away we have
01:46 - a nice scene waiting for input to start
01:48 - so I'm going to click with the mouse
01:49 - there you go we've got a very basic main
01:52 - menu so we can host which is to create a
01:54 - host for the multiplier we can join
01:56 - which is we can join as a client to
01:57 - connect to a host or just quit the game
02:00 - okay so let's go ahead and join as a
02:02 - host and right away we go into a nice
02:04 - character select scene so here as you
02:06 - can see this game supports up to four
02:08 - players and each player can use a
02:10 - different type of spaceship so by
02:12 - pressing a or D as we can see the
02:13 - controls down here by pressing that I
02:15 - can swap out which spaceship which
02:17 - character I want to use so let's select
02:19 - one let's go with cat okay so here I've
02:21 - got another build so on the main one I
02:22 - made as a host on this one I can join
02:24 - and if there go it joins connects the
02:26 - brand new player and sets a new
02:28 - character so now again on this one I can
02:30 - also modify my character and yep it
02:32 - synchronizes perfectly over there with
02:33 - the host so I can change whatever
02:34 - character I want so I can wait for some
02:37 - more players to join or I can go ahead
02:38 - press on ready and there you go now this
02:41 - character is set is ready but the other
02:42 - one is still waiting so the game has
02:44 - some logic waiting for all players to be
02:45 - running so as soon as I press ready on
02:47 - this one there you go it starts the
02:48 - timer and both players load and they
02:50 - both load into the control scene and
02:52 - they both wait a bit so the players can
02:54 - see the controls and once again they
02:55 - both load they both synchronize and here
02:57 - it is the main game scene so I've got a
02:59 - bunch of controls and now I'm playing
03:01 - solo so I have to kind of control both
03:03 - at the same time so as you can see I can
03:05 - play with a client down here I can fire
03:07 - a bunch of bullets or up here I can also
03:09 - fire a bunch of balls
03:11 - okay so there you go as you can see a
03:13 - bunch of enemies are being spawned all
03:14 - of them are being synchronized so all of
03:16 - them are in the exact same position on
03:17 - both scenes I can move around the
03:19 - players anywhere and I can pick up some
03:22 - pickups and with another key I can
03:24 - enable a nice shield and again
03:25 - everything is nicely synchronized so I
03:28 - can play around okay I'm probably going
03:29 - to lose one but okay all right so there
03:32 - you go this player down there was hit so
03:34 - the spaceship has been destroying okay
03:36 - now on this one let me try to make it
03:37 - until the boss fight
03:39 - there you go the boss is coming okay so
03:41 - here is the boss
03:43 - and I just have to shoot it and the boss
03:45 - has various stages and again note how
03:47 - everything is still nice and
03:48 - synchronized
03:50 - so the boss is doing a lot of things and
03:53 - I just gotta take him out
03:58 - and I end up losing so we go into a nice
04:00 - fit menu where we've got a bunch of sets
04:02 - so let's try again
04:04 - so here I am on the second try and here
04:06 - comes the boss again so let's see if I
04:07 - can defeat it also knows how the
04:09 - characters the spaceships they have a
04:11 - different Sprite when moving up or
04:12 - moving down so those Sprites are
04:14 - changing and note how it is indeed being
04:16 - synchronized so everything is working
04:17 - perfectly okay so let's see if this time
04:19 - I can actually defeat the boss
04:21 - and okay just a bunch more shots
04:24 - and just a little bit more
04:26 - and there you go the boss exploding and
04:28 - again note how everything is nice and
04:29 - synchronized and up here we go into a
04:31 - nice Victory scene where we can see the
04:33 - scores enemies destroyed and so on all
04:35 - right great
04:37 - so as you can see it's a simple game but
04:38 - this showcase lots of things that are
04:40 - very useful and very need to learn in
04:42 - order to make multiplayer games okay so
04:44 - that's the game as you can see it's
04:46 - pretty simple which is excellent as in
04:47 - learning project it involves lots of
04:49 - multiplayer topics such as scene loading
04:51 - character selection spawning players
04:53 - firing bullets synchronizing the player
04:55 - enemies and boss
04:57 - handling the win and game oversights and
04:59 - so on so now that we've seen how the
05:01 - game actually works let's inspect to see
05:03 - how all of this is built so for starters
05:05 - over here I'm looking at the project
05:06 - window we can see all of the scenes
05:08 - involved in this game like I said the
05:10 - first one is the bootstrap so this one
05:11 - starts all of the necessary Global
05:13 - objects then after that one we go into
05:15 - the menu so this is the main menu with
05:17 - the main buttons then when we create
05:19 - either a host or join as a client we go
05:21 - into the character selection window over
05:23 - here the players can join and select
05:25 - their character then once all of them go
05:27 - into ready we go into the control scene
05:29 - so this is just a basic window just
05:31 - showing the controls for the players to
05:33 - play and after this one is on screen for
05:35 - a little bit then transitions into the
05:37 - gameplay scene and this is where the
05:39 - game actually happens then through the
05:41 - course of the game either the player
05:42 - wins or losses so either goes into the
05:44 - victory or the defeat scene okay so
05:46 - that's the main way as to how this game
05:48 - is structured so let's inspect the
05:50 - bootstrap scene this one like I said
05:52 - creates all of the global objects needed
05:53 - for the game to work we can see that it
05:55 - has primarily a network manager this one
05:58 - is the main script that you need in
06:00 - order to be able to use netcode for game
06:01 - objects again definitely go watch my net
06:03 - Code 4 game objects video If you haven't
06:05 - seen it yet in there I cover all the
06:07 - required components to make this work so
06:09 - this one has the main network manager
06:11 - and over here has all of the network
06:12 - prefabs also note one important thing
06:15 - which is over here there is no player
06:16 - prefab the reason for this is because
06:18 - the player prefab this one is spawned
06:20 - automatically when someone joins but
06:22 - since we're creating the network manager
06:23 - over here and then when connecting we
06:25 - are going to the character selection
06:26 - scene when we go in there we don't
06:28 - really want to spawn the spaceship right
06:30 - away so that is why in this case we are
06:32 - not using the player prefab in order to
06:34 - automatically spawn any kind of prefab
06:35 - for the player we're going to handle
06:37 - that manually As We join both the
06:39 - character selection scene and the
06:40 - gameplay scene so there's no point
06:42 - prefab then over here all of the various
06:43 - Network prefabs so this is basically the
06:45 - prefab list that needs to be added over
06:47 - here for anything you want to spawn
06:48 - dynamically in the game so if you want
06:51 - the bones to be able to spawn and
06:52 - synchronize and they need to be here on
06:53 - this list then down here for the rest
06:55 - all of it is mostly on default so it's
06:57 - using the entrance password okay great
06:59 - and one very very important thing is
07:01 - over here scene management is enabled so
07:04 - this is how you notice how when the host
07:06 - starts a new scene the client
07:07 - automatically unloads it that is because
07:09 - this one is toggled otherwise you need
07:10 - to handle that manually okay so this one
07:13 - is the network manager pretty basic most
07:14 - of it with defaults then we also have a
07:16 - loading manager visually this one really
07:19 - just has a black screen that's it this
07:21 - one is only used for visually fitting to
07:23 - Black and fitting away we can inspect
07:25 - the script to see what it does here it
07:27 - is and first of all it extends something
07:29 - called a Singleton persistent this is a
07:32 - class that they made for this demo
07:33 - basically just creates a new Singleton
07:35 - so a standard static instance
07:37 - and then just adds don't destroy and
07:39 - load to make sure this one is persistent
07:40 - so it never gets destroyed that way the
07:42 - unloading scene manager there will only
07:44 - ever be one and it won't persist so that
07:46 - is why you start from the bootstrap
07:47 - scene over there it starts the unloading
07:49 - scene manager and then just lives until
07:51 - you quit the game then the other object
07:53 - in this scene is the go to menu this one
07:55 - is a super simple script basically just
07:57 - Waits until the unloading scene manager
07:59 - has been created and when that happens
08:01 - it loads the main menu scene however
08:03 - note how over here it is not using the
08:06 - basic unity scene management instead it
08:08 - is going through this script and if we
08:09 - inspect this here we can see what it's
08:12 - doing so it's starting a CO routine in
08:13 - order to do the fade in effect and so on
08:15 - but then the very important thing is
08:17 - this one takes a parameter for is
08:18 - Network session active basically it's
08:20 - going to do two different types of
08:22 - loading depending on if a network
08:23 - connection has been established or not
08:25 - now we're here in the bootstrap over
08:27 - here we don't have a connection so this
08:29 - one is set to false
08:31 - so then over here when this one runs
08:33 - it's going to go with this one as false
08:35 - so it's going to load the scene locally
08:36 - and this one is going to load the scene
08:38 - as normal so just go and use the unity
08:40 - scene manager and just call load scene
08:42 - but afterwards when the connection is
08:44 - established then instead of using this
08:46 - function it's going to use this function
08:47 - and this one over here note how it does
08:50 - not use the regular scene manager
08:51 - instead it goes through the network
08:52 - manager accesses the scene manager on
08:55 - that network manager and then loads that
08:57 - scene this is important like I mentioned
08:59 - this is why the network manager has
09:00 - scene management enabled this way only
09:03 - the host load scenes and then of the
09:05 - clients all of them will load the target
09:06 - scene automatically
09:08 - because again the network manager has
09:10 - seen management enabled so basically for
09:12 - this bootstrap Scene It just sets up
09:14 - everything locally so there's no
09:15 - connection at all here just as the basic
09:17 - setup and then loads the main menu so
09:19 - let's open up the main menu scene here
09:21 - it is on this one again this scene also
09:23 - has nothing to do with any multiplier
09:25 - everything is still local here it just
09:28 - has this mini controller with this many
09:29 - manager script
09:31 - and over here on this script simply on
09:34 - update just as for a key and if so
09:36 - triggers the transition that transition
09:38 - then shows the regular buttons that we
09:40 - saw the host the join in the quit and
09:42 - down here we can see how that is
09:43 - implemented so we've got our click
09:45 - buttons here so for the host when that
09:47 - happens it goes into the network manager
09:49 - and starts the host right away
09:51 - so again example like are covered in the
09:53 - netcode for game objects video then it
09:55 - plays a sound effect and then
09:56 - constellutes in but again remember how
09:59 - the network scene this one is now going
10:01 - to default to true
10:03 - so when it starts the host when it loads
10:05 - the scene it's going to unload the scene
10:06 - through the network manager and also
10:08 - remember how this has the fade in by
10:10 - default so first it's going to fade in
10:12 - it's going to wait until the unloading
10:14 - fade effect is finished when that
10:15 - finishes then it actually loads and then
10:18 - it fades out so that's how the visuals
10:20 - and logic are connected that's how the
10:22 - host Behavior works and then when
10:24 - clicking join to join as a client
10:27 - for this one it's going to start this Co
10:28 - routine so let's see what this one does
10:30 - and this one is actually interesting
10:32 - it's going to run this function the fade
10:34 - on
10:36 - which we can see what this one is doing
10:37 - so it does another core routine
10:39 - and basically this one does the fade in
10:41 - then waits for one second and then Fades
10:43 - out so this go routine is pretty much
10:45 - just going to play that in Mission so
10:46 - fade in wait fade out and then back in
10:49 - the same join function
10:51 - over here it's going to wait until the
10:53 - load effect is on can load which means
10:56 - until it has been fully faded in and
10:58 - when that happens then it's going to go
11:00 - into the network manager to start the
11:01 - client
11:02 - again remember how because of that
11:04 - setting on the network manager to handle
11:06 - the scene management because of that
11:08 - when you change the scene on the server
11:09 - the clients will automatically unload
11:11 - that scene so that is why over here and
11:13 - locally it is first fading and only when
11:15 - the fade has finished then it starts the
11:17 - client which in turn won't load the
11:18 - scene right away okay so after that both
11:21 - of those will enter the character
11:22 - selection scene and this scene is very
11:24 - interesting basically I saw a bunch of
11:27 - people commenting on my netcode for game
11:28 - objects video on how to do a multiplayer
11:31 - character select scene so this sample is
11:33 - super useful
11:34 - here we see we have two very important
11:36 - scripts so the character selection
11:38 - manager and the client Connection
11:39 - Manager note how both of these have a
11:42 - network object component again this
11:44 - scene is now correctly connected so the
11:46 - previous two scenes they were only in
11:48 - single player no connection but when we
11:49 - get to this one we do have a connection
11:51 - active so in order to synchronize things
11:53 - we need to make sure we use the network
11:54 - object you must add this component
11:56 - whenever you want to synchronize
11:58 - anything across the network
11:59 - so let's begin by inspecting over here
12:01 - the client Connection Manager now the
12:03 - purpose of this class is to handle the
12:05 - number of clients for a game you
12:07 - probably want to limit the number of
12:08 - players you probably don't want an
12:10 - infinite number of them
12:11 - but right now if you just use our client
12:14 - it will always join the network so if
12:16 - you want to add some kind of limit to
12:17 - how many players can join you need to
12:19 - handle that logic and that one is
12:21 - handled over here on this script if we
12:22 - scroll down we can see there is a can
12:24 - connect function so here it is and the
12:26 - main thing it does is over here just
12:28 - gets the players connected so it goes
12:30 - into the network manager in order to
12:31 - grab the list of connected clients and
12:33 - checks if it is above maximum if so then
12:35 - it says we are full and if not this one
12:37 - isn't allowed to enter now as to how
12:39 - this one is used if you go over here
12:41 - onto the unloading scene manager script
12:43 - this script is listening to a comeback
12:45 - over here on the network manager when
12:47 - the scene loads so it goes into this
12:49 - function and here this one visibly gets
12:51 - triggered when a scene is finished
12:52 - loading and this one is triggered on a
12:54 - per client basis so that is why over
12:56 - here we've got the client ID so this one
12:58 - is triggered when this client has
12:59 - finished loading then as usual for
13:01 - handling the player connections or
13:03 - non-connections we want to run the logic
13:05 - only on the server so if it is not the
13:07 - server we will return we don't do
13:08 - anything and then it's over here so when
13:11 - the client finishes loading that's when
13:13 - we're going to call this function can
13:15 - connect client and over here this
13:16 - function is going to run down that we
13:18 - just saw if the client can connect if so
13:20 - then it's going to return true so the
13:21 - client can connect but if not if for
13:24 - example the game is already full if so
13:27 - then it's going to run this remove
13:28 - client function and this function over
13:30 - here essentially kicksey client out and
13:32 - the way it does that is using a client
13:34 - RPC again make sure you watch my phone
13:36 - video if you have no idea what is a RPC
13:38 - client or server RPC basically this one
13:41 - takes a client RPC params and over here
13:44 - on the params you can Define what
13:45 - clients will receive this RPC so you can
13:48 - send a client RPC to all of the clients
13:50 - or just a specific one so in this one in
13:52 - order to remove the client it receives
13:53 - the client ID then creates a new client
13:56 - RPC Brands and make sure this message
13:58 - only goes to this client and basically
14:00 - tells this client to shut down and then
14:02 - down here on that function really just
14:04 - triggers the shutdown which means the
14:05 - client goes into net network manager and
14:07 - call shutdown and goes back into the
14:09 - main menu so this is both how you can
14:11 - click a player in any way so you can use
14:13 - a client or PC on their end in order to
14:15 - shut down network manager and this is
14:17 - also how you can simply prevent more
14:18 - players from joining a phone game
14:20 - although I should point out that there
14:21 - is actually another method for handling
14:23 - this kind of logic if you look over here
14:25 - on the network manager and we scroll
14:27 - down there is something called
14:28 - connection approval in the docs you can
14:31 - see how this works basically this lets
14:33 - you do pretty much the same thing the
14:35 - only difference is this way the player
14:36 - doesn't even fully connect like the game
14:38 - is doing right now you can accept them
14:40 - or reject them directly during the
14:42 - handshake process okay so that's the
14:44 - main Logic for limiting how many maximum
14:46 - amount of players you can have the other
14:48 - important Logic on this scene is
14:49 - handling the character selection so
14:51 - first let's see how does a player
14:53 - actually join
14:54 - like we saw that is over here on the
14:56 - unloading scene manager so it listens to
14:57 - this comeback from the network manager
14:59 - and then on this callback it has if the
15:02 - client can connect if now then it kicks
15:04 - it but if it can connect then it grows
15:06 - over here and just calls this scene
15:08 - initialization function this function
15:10 - then receives a client ID and then
15:13 - simply spawns a new network object and
15:15 - importantly it also changes the
15:17 - ownership
15:18 - so the server is going to spawn this
15:20 - prefab object but it's going to
15:21 - immediately give ownership of that
15:23 - object to the client now we're going to
15:25 - see what this player prefab contains in
15:27 - a little bit then afterwards down here
15:29 - the way the game handles all the players
15:31 - is basically on this array so we can
15:33 - inspect this type so here it is it is an
15:35 - array of type player connection state
15:38 - and this state is defined up here
15:39 - basically this is the type of data that
15:42 - you want to store for each player
15:44 - so it has a connection state which can
15:45 - be disconnected connected or ready then
15:48 - it has the player name the player client
15:49 - and they reference to the player object
15:51 - so back into the init function here
15:53 - basically just Cycles through all that
15:55 - array
15:56 - and then checks for the first slot that
15:58 - is pretty much empty so the first one
16:00 - that is disconnected and set it as
16:02 - connected
16:03 - it assigns this player name this length
16:06 - ID and this player object again remember
16:08 - how all this logic this is only running
16:10 - on the server not in any client so only
16:12 - the server is setting this data
16:14 - then for sending the data to the clients
16:17 - for that server uses a client RPC so
16:19 - after the server sets its own same then
16:21 - over here it's going to sync that state
16:22 - onto the clients and it's going to use
16:24 - this line RPC so it's going to tell all
16:27 - the clients which one is the brand new
16:28 - client ID which one is the state index
16:30 - the player State and the player object
16:32 - then the clients are going to receive
16:34 - this line there are PC and in doing so
16:36 - they are going to update their own site
16:38 - then over here we see one another very
16:40 - very important thing which is look at
16:43 - the type used over here on the last
16:44 - parameter this one is a network object
16:46 - reference
16:47 - basically up here when the server is
16:49 - calling it it is passing in a network
16:51 - object this is essentially how you can
16:54 - send some references over the connection
16:55 - like I mentioned in the net code for
16:57 - game objects video in a client RPC you
16:59 - can only use value types you cannot use
17:01 - reference types so you could not make a
17:03 - client RPC and pass in the player object
17:05 - directly but you can pass it in as a
17:08 - network object reference so you do that
17:10 - and then on the other side on the
17:11 - clients they receive that reference and
17:14 - they can use the function try get in
17:16 - order to try to get the network object
17:17 - that relates to that reference so it can
17:19 - get that player object and then simply
17:21 - gets the component that you want and
17:23 - assigns it like that
17:24 - so this is how you can pass in
17:26 - references through client rpcs okay so
17:29 - that's in Logic for spawning the player
17:31 - now let's look at the player prefab here
17:33 - on the script we can find the player
17:35 - selected character reference
17:37 - here is the prefab so let's open it and
17:40 - we can see this is a commonly empty
17:41 - prefab so there's no visual it just has
17:44 - obviously a network object so that it
17:45 - can be synchronized and then has this
17:47 - nice script so let's see okay so here
17:49 - this script basically handles the
17:51 - character selection and the way it does
17:53 - that is using a nice synchronized
17:54 - Network variable so as to how all of
17:57 - this logic flows we can see it has a
17:59 - start but remember that before the start
18:02 - we are going to run the on enable so
18:04 - basically as soon as the player respond
18:06 - when that happens it is going to add
18:08 - some listeners to these events so it is
18:09 - going to listen when the value changes
18:11 - on all of these Network variables so
18:13 - this one is going to run hook onto these
18:15 - listeners and then up here then the
18:17 - start is going to run and on the server
18:19 - the server is going to set the player ID
18:22 - so that each instance of this prefab
18:24 - knows which player it belongs to and in
18:26 - doing so in modifying display ID value
18:28 - this is once again going to trigger this
18:30 - on value changed event so it is going to
18:32 - run this function and this function is
18:34 - pretty much just going to update the UI
18:36 - and again remember how when the server
18:38 - modifies a network variable on the
18:39 - changes are propagated to all the
18:41 - clients so that's how this code is going
18:43 - to end up running on every single client
18:45 - so the server sets and then when it does
18:47 - it also sets the character selected so
18:49 - this is the other network variable and
18:51 - this one once again it is going to run
18:53 - the Compact and update the UI okay so
18:55 - that makes the default selection logic
18:57 - then as to how the player itself
18:59 - modifies their own character
19:01 - the inputs are handled over here on the
19:03 - update so you can see that it listens to
19:05 - the key a or D in order to select the
19:07 - character going left or right that is
19:09 - going to trigger this function so let's
19:10 - see and this one the first thing that it
19:12 - does is some basic validation just to
19:14 - make sure this value is within the valid
19:15 - ranges and then basically use the server
19:18 - RPC in order to tell the server the new
19:20 - selected character so the client runs
19:22 - this logic and then tells the server and
19:24 - the server then receives this and
19:25 - basically updates the network variable
19:27 - and in turn the network variable when
19:29 - that updates that is then synchronized
19:30 - to all the clients which then update on
19:32 - their UI so as you can see the selection
19:34 - logic is super simple locally the player
19:37 - changes something then use a server RPC
19:39 - in order to save what a change to and
19:41 - then the server updates a value which
19:42 - and gets the update to all the clients
19:44 - also there's one very important thing
19:46 - here which is over here right after
19:48 - sending the server RPC right after doing
19:51 - that note how this client this local
19:53 - client automatically updates a UI
19:55 - basically if you didn't do this there
19:57 - would be a delay the message would have
19:59 - to get to the server and then be
20:00 - propagated back in to all the clients
20:02 - see if he didn't do this right away if
20:04 - you didn't update the UI on locally if
20:06 - so then it would take a differently
20:07 - something like 15 milliseconds which is
20:09 - definitely noticeable and would make the
20:11 - game feel quite a bit unresponsive so
20:13 - when making multiplayer games this thing
20:15 - right here is one very very important
20:17 - thing usually you want to tell the
20:19 - server what to do but then locally you
20:22 - want to reflect those changes right away
20:23 - you want to update the game State
20:25 - instead of waiting for a reply from the
20:26 - server
20:27 - so this is a very very crucial thing you
20:29 - need to know with regards to multiplayer
20:31 - games in general in order to make them
20:32 - feel good you have to update the UI
20:34 - right away even if technically the
20:36 - server hasn't yet received that message
20:37 - okay so this is really all there is to
20:40 - it with regards to the character
20:41 - selection it really is that simple the
20:43 - clients change their value use a server
20:45 - IPC and then the heads broadcast it to
20:47 - all the clients one more thing in this
20:49 - update is we can see over here the
20:51 - Escape so this is basically a simple and
20:53 - quit option if so then checks if this
20:56 - one is the host so if there are no more
20:57 - players if so then starts a shutdown and
21:00 - for the shutdown once again the same
21:01 - thing that we already saw previously
21:04 - so it sends a client RPC to all the
21:06 - clients in order to shut down and for
21:07 - shutting down religious goes into
21:09 - network manager shuts down and then
21:10 - loads back the main menu so that's it
21:13 - super simple now the final important
21:15 - logic in this scene is the play Ready
21:16 - setting again here on the player
21:18 - character the selection on the update so
21:20 - we test for A and D in order to change
21:21 - the character and then we also test for
21:23 - the space bar and it is a server RPC in
21:25 - order to tell the server that this
21:27 - character is running
21:28 - so it's going to run this function only
21:30 - on the server and then on this function
21:32 - basically it tries to start the game
21:34 - timer so here we can see what it does
21:36 - basically goes through all the players
21:37 - and if at least one of them is not yet
21:39 - ready if so then Samsung doesn't
21:41 - actually start a timer but if all of
21:43 - them are ready then goes to enable a
21:45 - simple timer we can see here the Tamil
21:47 - logic again just a basic photo timer so
21:50 - just counts down by time.com time note
21:52 - how this timer is only running on the
21:54 - server and nothing else so it counts on
21:56 - a timer and when that is done it
21:57 - triggers this start game function and
21:59 - this function over here triggers a
22:00 - client RPC in order to tell all the
22:02 - clients to fade in because again
22:04 - remember how the unloading happens
22:05 - automatically
22:07 - so it tells all the coins to fade in and
22:09 - then the server automatically loads the
22:12 - next scene
22:12 - send the clients to the fade in as soon
22:14 - as the fade in complaints the scene they
22:17 - receive the message to load the next
22:18 - scene then load it and everything
22:19 - completes okay so with that we arrive at
22:22 - the main gameplay scene and over here we
22:24 - have another really interesting thing
22:25 - right away
22:26 - so first phone was the same pattern so
22:28 - it starts over here from the unloading
22:30 - scene manager so there's this comeback
22:33 - he checks if the client can connect the
22:35 - server and so on and over here it's
22:36 - going to run this initialization
22:37 - function and over here here is the very
22:39 - interesting thing that I mentioned which
22:41 - is that if you were to spawn the client
22:43 - prefab right away apparently you could
22:45 - get some desync issues in case some of
22:47 - the other clients took a bit too long to
22:49 - load so the solution over here in this
22:51 - function is actually quite simple
22:52 - basically when the client connects it
22:54 - adds the client to a connected list and
22:56 - then it checks if this client is the
22:58 - last client if not then return and
23:00 - doesn't do anything but if it is the con
23:02 - less client then that's when it actually
23:04 - spawns all the prefabs so if you use the
23:06 - automatic scene management make sure you
23:08 - pay attention to this one potential
23:09 - sneak issue
23:11 - so make sure everyone is connected
23:12 - already before you start spawning things
23:14 - then over here for spawning it's pretty
23:16 - much the same thing that we saw so it
23:17 - spawns a network object and again
23:19 - changes ownership to the client so the
23:21 - clients own their own spaceships for the
23:23 - prefab that one is stored inside a
23:25 - circle object we can see here under data
23:28 - the scriptable objects containing all
23:29 - the data for all of the various types
23:31 - inside each of them has a different
23:33 - prefab variant so let's inspect this
23:35 - prefab and this one very simple as usual
23:38 - it has a network object then for
23:40 - controlling this one is a co-op game so
23:43 - the clients actually have authority
23:44 - which means they move the transform
23:46 - directly and that is synchronized using
23:48 - the client Network transform so it's
23:50 - just like I showed in the netcode for
23:52 - game objects video this client tells the
23:54 - server where it should be and then down
23:56 - here we can see that these objects are
23:58 - also based on a rigid body so it has a
24:00 - rigid body to the component and then
24:02 - down here a network rigid body 2D in
24:04 - order to make sure everything is
24:05 - synchronized although also note how the
24:07 - body type over here is set as kinematic
24:09 - so that means there are no synchronized
24:11 - physics so it has this and then down
24:13 - here the various player control scripts
24:14 - so let's see this movement script here
24:17 - it is this one is pretty basic if we go
24:19 - down here we can see how it actually
24:21 - works so it handles the keyboard input
24:23 - so just doing some basic key testing in
24:25 - order to calculate an input vector then
24:28 - with that input Vector it runs this
24:29 - function so it takes the input vector
24:31 - and simply moves the transform directly
24:33 - then in turn when the transfer moves
24:35 - that one is synchronized to the client
24:36 - Network transform component so very
24:38 - simple example like I covered in the
24:40 - other video but if you remember from the
24:42 - gameplay the ships also change visual
24:44 - when moving up or down
24:45 - so that part is actually synchronized
24:47 - over here on this function so it just
24:49 - checks if the player is moving up or
24:51 - down and slice the Sprite and then once
24:53 - again use a server RPC in order to sell
24:55 - the server what Sprite it shouldn't load
24:56 - so then the server receives that message
24:58 - and simply broadcasts it to all the
25:00 - clients then the clients receive that
25:02 - message
25:03 - and based on a simple enum because again
25:05 - you cannot transfer objects so you
25:08 - cannot send a Sprite through a client
25:09 - RPC so over here it just defines an enum
25:11 - for all of the possible Sprites and then
25:13 - over here simply set them on only
25:14 - clients and that's really it for the
25:16 - movement as you can see it's super
25:17 - simple then let's take a look at this
25:20 - ship control script this one handles
25:22 - various player logic like for example
25:24 - using the shield so you can see it has
25:26 - for the input and then use a server RPC
25:29 - to turn the server to activate the
25:30 - shield and in this case the server is
25:32 - actually the one that is going to
25:33 - validate the inputs so when the player
25:35 - presses it is always going to trigger
25:37 - This Server RPC and then the server
25:39 - checks if this player can use it so if
25:41 - it has enough specials if so then counts
25:43 - them down and this one as you can see is
25:45 - a network variable so it gets
25:46 - automatically synchronized and then use
25:48 - a calendar PC in order to tell all the
25:49 - clients to activate this Shield
25:51 - then next thing this script does is
25:53 - testing for collisions with the power
25:54 - ups so that one is handled over here
25:56 - using a simple regular ontrigger enter
25:58 - 2D so this one is only going to run on
26:01 - the server so if the server detects a
26:03 - hit if it detects a hit with a power up
26:05 - special
26:06 - if so then validates if the player can
26:08 - handle more and if so once again updates
26:10 - the network variable it does that and
26:12 - also importantly down here it actually
26:13 - destroys the object so it runs this
26:16 - simple function which calls d-spawn on
26:18 - the network object and again this logic
26:20 - only runs on the server so that gets rid
26:22 - of the power up next for the health and
26:25 - damage
26:26 - if we scroll up we can see this script
26:28 - once again has a network variable for
26:30 - the health and down here it has a hit
26:32 - function this one once again is only
26:34 - going to run on the server and when this
26:36 - spaceship gets hit it is going to count
26:38 - down the value by the damage which in
26:40 - turn this network variable is going to
26:42 - synchronize you all the clients then it
26:44 - also use a client RPC in order to tell
26:46 - the clients to play some kind of hit
26:48 - effect and then down here on the server
26:50 - it checks if the health is below zero
26:52 - meaning if the spaceship is dined if so
26:55 - then once again just goes and spawns a
26:57 - VFX prefab and then despawns the actual
26:59 - employer spacer finally it calls this
27:01 - function to say that this line has died
27:03 - and then this function is going to run
27:05 - this client there PC again with the
27:07 - client ID as a parameter
27:09 - and this one is essentially going to
27:10 - make sure that only this client is going
27:12 - to enable the death UI animation so as
27:14 - you can see all the helpful logic is
27:16 - also pretty basic now the next grip over
27:18 - here is the one for the player shoot
27:20 - bullet so this one actually spawns
27:22 - bullets and the way this script does
27:24 - that is once again using a nice server
27:25 - RPC so when the player presses space it
27:28 - triggers this function
27:30 - it is going to get a new bullet which
27:31 - once again is going to spawn a network
27:33 - object prefab it does that although note
27:35 - one important thing which is over here
27:37 - this one is spawned as a server object
27:40 - meaning this one is not going to change
27:41 - ownership to the player that fire the
27:43 - bullet all of the bullets are always
27:45 - owned by the server so you can then
27:46 - inspect this pre-file to see how the
27:48 - Bonnet works so over here we can find
27:50 - the bullet prefab reference so let's
27:51 - open this and on this one once again it
27:54 - has a network object although this time
27:56 - it has a regular Network transform as
27:58 - opposed to the client Network transform
28:00 - again that's because all of the bullets
28:02 - are going to be owned by the server
28:04 - then once again it has a rigid body a
28:06 - rig a kinematic rigid body it also has a
28:09 - simple collider and then a bunch of
28:11 - scripts for movement it has this basic
28:13 - generic movement script really just all
28:16 - it does is it's only going to run the
28:17 - logic on the server and just going to
28:19 - modify this transform that's it then the
28:21 - other logic is over here the bullet
28:22 - controller this one has an enum for the
28:25 - bullet owner so basically the bullets
28:27 - are always going to be the same object
28:28 - for both the player and the enemy
28:30 - bullets and on start use a client RPC in
28:33 - order to set the color for this moment
28:35 - again different colors for player or
28:37 - enemy Bots and then down here some basic
28:39 - collection detection it is going to test
28:42 - for hits with something that can be
28:43 - damaged if it's a player then it's going
28:45 - to increase some stats it's going to
28:47 - deal on damage to that object and once
28:49 - again going to despawn this network
28:50 - object so all of it very basic so back
28:53 - here on the gameplay scene let's inspect
28:54 - the enemy spawner script so here it is
28:57 - the enemy's funnel script and over here
28:59 - on update we've got the spawning logic
29:01 - and again this is only going to run on
29:02 - the server basically just has a handle
29:05 - enemy spawning function and over here
29:07 - pretty simple just handles a photo timer
29:09 - if it goes above a certain maximum then
29:11 - gets a next random enemy prefab it
29:13 - spawns a prefab and then the enemy
29:15 - handles itself automatically
29:17 - same thing for the meteor so for the
29:19 - meteor over here same thing pretty much
29:20 - as spawns one then the important one is
29:23 - down here on the boss so once again that
29:25 - starts off as a simple timer so when the
29:27 - timer ends it starts this co-routine and
29:29 - first like we saw it first plays a
29:31 - warning UI so that is handled over here
29:33 - through a client RPC so all the clients
29:35 - receive this message to enable the
29:37 - warning UI then just Waits a little bit
29:39 - tells the clients to stop showing the
29:41 - warning UI and finally spawns the boss
29:43 - again just wanting a regular Network
29:45 - object just spawns it and initialize the
29:47 - behavior the boss has this script this
29:49 - boss controller which is actually a
29:51 - really nice State machine but in terms
29:53 - of multiplayer logic everything is
29:54 - really all the same it goes through the
29:56 - various stages firing various bullets
29:58 - and so on and the final important thing
30:00 - is when the boss dies so you can look
30:02 - over here on these scripts for the
30:03 - various boss dates so let's look at the
30:05 - both Nest state so when the boss dies it
30:08 - is going to spawn some random explosions
30:10 - then it destroys the network object and
30:12 - goes into this pasta feed function and
30:15 - again as usual this function does the
30:16 - same thing for any kind of loading that
30:18 - we've already seen so it does a client
30:20 - RPC to tell the clients to load
30:21 - something and then loads in this case
30:23 - the victory scene and finally over here
30:25 - on the victory scene we just see a bunch
30:26 - of basic stats and that's it that's a
30:28 - game and that's how it works as you can
30:30 - see it's a pretty simple and simple
30:31 - project which works great for learning
30:33 - it has some of the basics for making a
30:35 - multiplayer game you have a character
30:37 - selecting multiple characters a maximum
30:40 - player count you have moving spaceships
30:42 - bullets enemy spawning collisions a boss
30:44 - fight and a bunch more here we saw how
30:46 - it all works under the hood by using
30:48 - lots of network objects a bunch of
30:49 - server and command rpcs some interesting
30:51 - scene loading and a bunch more and you
30:54 - probably also notice some things like
30:55 - for example slight delay on the
30:57 - collisions the bones firing movement and
30:58 - so on Unity themselves have said that
31:00 - this project is intended to be the most
31:02 - basic working demo possible so all of
31:05 - those extra things all those things like
31:06 - movement prediction and some more
31:08 - responsive visuals those would be added
31:10 - on top of this starting base for those
31:12 - more complex things definitely go take a
31:14 - look at the more
31:15 - that one builds upon this and includes
31:18 - tons of optimizations that you
31:19 - definitely must learn to make a good
31:21 - multiplayer game again remember you can
31:23 - inspect this entire project for yourself
31:24 - download it with the link in the
31:25 - description if you haven't yet seen my
31:27 - complete detailed tutorial on netcode
31:29 - for game objects and definitely go watch
31:30 - it now
31:31 - and check out the other link to learn
31:33 - all about Unity gaming Services Unity
31:35 - has tons of tools to really help you
31:37 - bring your multiplayer games to life
31:38 - things like Matchmaker and Lobby relay
31:40 - and more so definitely go ahead and read
31:42 - about those I've also covered Lobby and
31:44 - really in two other dedicated videos and
31:46 - of course like I mentioned the reason
31:47 - why I researched this game was to
31:49 - prepare for my upcoming free multiplayer
31:51 - course and in preparation for that make
31:53 - sure you go watch my full free single
31:54 - player course alright hope that's useful
31:57 - check out these videos to learn some
31:58 - more thanks to these awesome patreon
32:00 - supporters for making these videos
32:02 - possible thank you for watching and I'll
32:04 - see you next time
32:08 - foreign

Cleaned transcript:

hello and welcome I'm your code monkey and here let's do a deep dive on one of unity's official multiplayer samples the galactic kittens game this is a very simple 2D Coop multiplayer game that works great as a learning project for understanding how to make multiplayer games using unity's official multiplier solution called netcode for game objects of the source code is available so you can download it and pick it apart to understand exactly how it works if you've seen my net code for game objects video you shouldn't be able to easily understand how this project works this project is intended to be as simple as possible it is meant to be a Bare Bones multiplayer sample for something more complex afterwards definitely go take a look at the much more advanced simple Kong boss room that one builds upon this base and includes tons of optimizations that you definitely must learn to make a good multiplayer game the reason why I researched this official project is because I'm currently working on my upcoming free multiplayer course I'm hard to work on it and hopefully should be out within the next few weeks so if you're looking for a guide path stay tuned for that and go watch the free single player course to prepare for it also as the unity they officially sponsored this video so if you want to learn more about this Mo project then check the link in the description to download it and inspect it for yourself and if you want to make multiplayer games then Unity also has tons of useful tools in their Unity gaming Services brand so also check that out with the other Link in the description okay so first let's do a quick look and play through the game and then let's open up the project and inspect how everything works so we can learn how we can build multiplayer games now if you download the projects to try it out there is one very important thing with how the game is set up basically on all the scenes there is one scene called bootstrap this scene starts up all the necessary objects so when testing it out for yourself make sure you go onto this scene before ending play otherwise you might see some errors so here in the scene let's hit a play and try out the game alright so here's the game gonna like the kittens and right away we have a nice scene waiting for input to start so I'm going to click with the mouse there you go we've got a very basic main menu so we can host which is to create a host for the multiplier we can join which is we can join as a client to connect to a host or just quit the game okay so let's go ahead and join as a host and right away we go into a nice character select scene so here as you can see this game supports up to four players and each player can use a different type of spaceship so by pressing a or D as we can see the controls down here by pressing that I can swap out which spaceship which character I want to use so let's select one let's go with cat okay so here I've got another build so on the main one I made as a host on this one I can join and if there go it joins connects the brand new player and sets a new character so now again on this one I can also modify my character and yep it synchronizes perfectly over there with the host so I can change whatever character I want so I can wait for some more players to join or I can go ahead press on ready and there you go now this character is set is ready but the other one is still waiting so the game has some logic waiting for all players to be running so as soon as I press ready on this one there you go it starts the timer and both players load and they both load into the control scene and they both wait a bit so the players can see the controls and once again they both load they both synchronize and here it is the main game scene so I've got a bunch of controls and now I'm playing solo so I have to kind of control both at the same time so as you can see I can play with a client down here I can fire a bunch of bullets or up here I can also fire a bunch of balls okay so there you go as you can see a bunch of enemies are being spawned all of them are being synchronized so all of them are in the exact same position on both scenes I can move around the players anywhere and I can pick up some pickups and with another key I can enable a nice shield and again everything is nicely synchronized so I can play around okay I'm probably going to lose one but okay all right so there you go this player down there was hit so the spaceship has been destroying okay now on this one let me try to make it until the boss fight there you go the boss is coming okay so here is the boss and I just have to shoot it and the boss has various stages and again note how everything is still nice and synchronized so the boss is doing a lot of things and I just gotta take him out and I end up losing so we go into a nice fit menu where we've got a bunch of sets so let's try again so here I am on the second try and here comes the boss again so let's see if I can defeat it also knows how the characters the spaceships they have a different Sprite when moving up or moving down so those Sprites are changing and note how it is indeed being synchronized so everything is working perfectly okay so let's see if this time I can actually defeat the boss and okay just a bunch more shots and just a little bit more and there you go the boss exploding and again note how everything is nice and synchronized and up here we go into a nice Victory scene where we can see the scores enemies destroyed and so on all right great so as you can see it's a simple game but this showcase lots of things that are very useful and very need to learn in order to make multiplayer games okay so that's the game as you can see it's pretty simple which is excellent as in learning project it involves lots of multiplayer topics such as scene loading character selection spawning players firing bullets synchronizing the player enemies and boss handling the win and game oversights and so on so now that we've seen how the game actually works let's inspect to see how all of this is built so for starters over here I'm looking at the project window we can see all of the scenes involved in this game like I said the first one is the bootstrap so this one starts all of the necessary Global objects then after that one we go into the menu so this is the main menu with the main buttons then when we create either a host or join as a client we go into the character selection window over here the players can join and select their character then once all of them go into ready we go into the control scene so this is just a basic window just showing the controls for the players to play and after this one is on screen for a little bit then transitions into the gameplay scene and this is where the game actually happens then through the course of the game either the player wins or losses so either goes into the victory or the defeat scene okay so that's the main way as to how this game is structured so let's inspect the bootstrap scene this one like I said creates all of the global objects needed for the game to work we can see that it has primarily a network manager this one is the main script that you need in order to be able to use netcode for game objects again definitely go watch my net Code 4 game objects video If you haven't seen it yet in there I cover all the required components to make this work so this one has the main network manager and over here has all of the network prefabs also note one important thing which is over here there is no player prefab the reason for this is because the player prefab this one is spawned automatically when someone joins but since we're creating the network manager over here and then when connecting we are going to the character selection scene when we go in there we don't really want to spawn the spaceship right away so that is why in this case we are not using the player prefab in order to automatically spawn any kind of prefab for the player we're going to handle that manually As We join both the character selection scene and the gameplay scene so there's no point prefab then over here all of the various Network prefabs so this is basically the prefab list that needs to be added over here for anything you want to spawn dynamically in the game so if you want the bones to be able to spawn and synchronize and they need to be here on this list then down here for the rest all of it is mostly on default so it's using the entrance password okay great and one very very important thing is over here scene management is enabled so this is how you notice how when the host starts a new scene the client automatically unloads it that is because this one is toggled otherwise you need to handle that manually okay so this one is the network manager pretty basic most of it with defaults then we also have a loading manager visually this one really just has a black screen that's it this one is only used for visually fitting to Black and fitting away we can inspect the script to see what it does here it is and first of all it extends something called a Singleton persistent this is a class that they made for this demo basically just creates a new Singleton so a standard static instance and then just adds don't destroy and load to make sure this one is persistent so it never gets destroyed that way the unloading scene manager there will only ever be one and it won't persist so that is why you start from the bootstrap scene over there it starts the unloading scene manager and then just lives until you quit the game then the other object in this scene is the go to menu this one is a super simple script basically just Waits until the unloading scene manager has been created and when that happens it loads the main menu scene however note how over here it is not using the basic unity scene management instead it is going through this script and if we inspect this here we can see what it's doing so it's starting a CO routine in order to do the fade in effect and so on but then the very important thing is this one takes a parameter for is Network session active basically it's going to do two different types of loading depending on if a network connection has been established or not now we're here in the bootstrap over here we don't have a connection so this one is set to false so then over here when this one runs it's going to go with this one as false so it's going to load the scene locally and this one is going to load the scene as normal so just go and use the unity scene manager and just call load scene but afterwards when the connection is established then instead of using this function it's going to use this function and this one over here note how it does not use the regular scene manager instead it goes through the network manager accesses the scene manager on that network manager and then loads that scene this is important like I mentioned this is why the network manager has scene management enabled this way only the host load scenes and then of the clients all of them will load the target scene automatically because again the network manager has seen management enabled so basically for this bootstrap Scene It just sets up everything locally so there's no connection at all here just as the basic setup and then loads the main menu so let's open up the main menu scene here it is on this one again this scene also has nothing to do with any multiplier everything is still local here it just has this mini controller with this many manager script and over here on this script simply on update just as for a key and if so triggers the transition that transition then shows the regular buttons that we saw the host the join in the quit and down here we can see how that is implemented so we've got our click buttons here so for the host when that happens it goes into the network manager and starts the host right away so again example like are covered in the netcode for game objects video then it plays a sound effect and then constellutes in but again remember how the network scene this one is now going to default to true so when it starts the host when it loads the scene it's going to unload the scene through the network manager and also remember how this has the fade in by default so first it's going to fade in it's going to wait until the unloading fade effect is finished when that finishes then it actually loads and then it fades out so that's how the visuals and logic are connected that's how the host Behavior works and then when clicking join to join as a client for this one it's going to start this Co routine so let's see what this one does and this one is actually interesting it's going to run this function the fade on which we can see what this one is doing so it does another core routine and basically this one does the fade in then waits for one second and then Fades out so this go routine is pretty much just going to play that in Mission so fade in wait fade out and then back in the same join function over here it's going to wait until the load effect is on can load which means until it has been fully faded in and when that happens then it's going to go into the network manager to start the client again remember how because of that setting on the network manager to handle the scene management because of that when you change the scene on the server the clients will automatically unload that scene so that is why over here and locally it is first fading and only when the fade has finished then it starts the client which in turn won't load the scene right away okay so after that both of those will enter the character selection scene and this scene is very interesting basically I saw a bunch of people commenting on my netcode for game objects video on how to do a multiplayer character select scene so this sample is super useful here we see we have two very important scripts so the character selection manager and the client Connection Manager note how both of these have a network object component again this scene is now correctly connected so the previous two scenes they were only in single player no connection but when we get to this one we do have a connection active so in order to synchronize things we need to make sure we use the network object you must add this component whenever you want to synchronize anything across the network so let's begin by inspecting over here the client Connection Manager now the purpose of this class is to handle the number of clients for a game you probably want to limit the number of players you probably don't want an infinite number of them but right now if you just use our client it will always join the network so if you want to add some kind of limit to how many players can join you need to handle that logic and that one is handled over here on this script if we scroll down we can see there is a can connect function so here it is and the main thing it does is over here just gets the players connected so it goes into the network manager in order to grab the list of connected clients and checks if it is above maximum if so then it says we are full and if not this one isn't allowed to enter now as to how this one is used if you go over here onto the unloading scene manager script this script is listening to a comeback over here on the network manager when the scene loads so it goes into this function and here this one visibly gets triggered when a scene is finished loading and this one is triggered on a per client basis so that is why over here we've got the client ID so this one is triggered when this client has finished loading then as usual for handling the player connections or nonconnections we want to run the logic only on the server so if it is not the server we will return we don't do anything and then it's over here so when the client finishes loading that's when we're going to call this function can connect client and over here this function is going to run down that we just saw if the client can connect if so then it's going to return true so the client can connect but if not if for example the game is already full if so then it's going to run this remove client function and this function over here essentially kicksey client out and the way it does that is using a client RPC again make sure you watch my phone video if you have no idea what is a RPC client or server RPC basically this one takes a client RPC params and over here on the params you can Define what clients will receive this RPC so you can send a client RPC to all of the clients or just a specific one so in this one in order to remove the client it receives the client ID then creates a new client RPC Brands and make sure this message only goes to this client and basically tells this client to shut down and then down here on that function really just triggers the shutdown which means the client goes into net network manager and call shutdown and goes back into the main menu so this is both how you can click a player in any way so you can use a client or PC on their end in order to shut down network manager and this is also how you can simply prevent more players from joining a phone game although I should point out that there is actually another method for handling this kind of logic if you look over here on the network manager and we scroll down there is something called connection approval in the docs you can see how this works basically this lets you do pretty much the same thing the only difference is this way the player doesn't even fully connect like the game is doing right now you can accept them or reject them directly during the handshake process okay so that's the main Logic for limiting how many maximum amount of players you can have the other important Logic on this scene is handling the character selection so first let's see how does a player actually join like we saw that is over here on the unloading scene manager so it listens to this comeback from the network manager and then on this callback it has if the client can connect if now then it kicks it but if it can connect then it grows over here and just calls this scene initialization function this function then receives a client ID and then simply spawns a new network object and importantly it also changes the ownership so the server is going to spawn this prefab object but it's going to immediately give ownership of that object to the client now we're going to see what this player prefab contains in a little bit then afterwards down here the way the game handles all the players is basically on this array so we can inspect this type so here it is it is an array of type player connection state and this state is defined up here basically this is the type of data that you want to store for each player so it has a connection state which can be disconnected connected or ready then it has the player name the player client and they reference to the player object so back into the init function here basically just Cycles through all that array and then checks for the first slot that is pretty much empty so the first one that is disconnected and set it as connected it assigns this player name this length ID and this player object again remember how all this logic this is only running on the server not in any client so only the server is setting this data then for sending the data to the clients for that server uses a client RPC so after the server sets its own same then over here it's going to sync that state onto the clients and it's going to use this line RPC so it's going to tell all the clients which one is the brand new client ID which one is the state index the player State and the player object then the clients are going to receive this line there are PC and in doing so they are going to update their own site then over here we see one another very very important thing which is look at the type used over here on the last parameter this one is a network object reference basically up here when the server is calling it it is passing in a network object this is essentially how you can send some references over the connection like I mentioned in the net code for game objects video in a client RPC you can only use value types you cannot use reference types so you could not make a client RPC and pass in the player object directly but you can pass it in as a network object reference so you do that and then on the other side on the clients they receive that reference and they can use the function try get in order to try to get the network object that relates to that reference so it can get that player object and then simply gets the component that you want and assigns it like that so this is how you can pass in references through client rpcs okay so that's in Logic for spawning the player now let's look at the player prefab here on the script we can find the player selected character reference here is the prefab so let's open it and we can see this is a commonly empty prefab so there's no visual it just has obviously a network object so that it can be synchronized and then has this nice script so let's see okay so here this script basically handles the character selection and the way it does that is using a nice synchronized Network variable so as to how all of this logic flows we can see it has a start but remember that before the start we are going to run the on enable so basically as soon as the player respond when that happens it is going to add some listeners to these events so it is going to listen when the value changes on all of these Network variables so this one is going to run hook onto these listeners and then up here then the start is going to run and on the server the server is going to set the player ID so that each instance of this prefab knows which player it belongs to and in doing so in modifying display ID value this is once again going to trigger this on value changed event so it is going to run this function and this function is pretty much just going to update the UI and again remember how when the server modifies a network variable on the changes are propagated to all the clients so that's how this code is going to end up running on every single client so the server sets and then when it does it also sets the character selected so this is the other network variable and this one once again it is going to run the Compact and update the UI okay so that makes the default selection logic then as to how the player itself modifies their own character the inputs are handled over here on the update so you can see that it listens to the key a or D in order to select the character going left or right that is going to trigger this function so let's see and this one the first thing that it does is some basic validation just to make sure this value is within the valid ranges and then basically use the server RPC in order to tell the server the new selected character so the client runs this logic and then tells the server and the server then receives this and basically updates the network variable and in turn the network variable when that updates that is then synchronized to all the clients which then update on their UI so as you can see the selection logic is super simple locally the player changes something then use a server RPC in order to save what a change to and then the server updates a value which and gets the update to all the clients also there's one very important thing here which is over here right after sending the server RPC right after doing that note how this client this local client automatically updates a UI basically if you didn't do this there would be a delay the message would have to get to the server and then be propagated back in to all the clients see if he didn't do this right away if you didn't update the UI on locally if so then it would take a differently something like 15 milliseconds which is definitely noticeable and would make the game feel quite a bit unresponsive so when making multiplayer games this thing right here is one very very important thing usually you want to tell the server what to do but then locally you want to reflect those changes right away you want to update the game State instead of waiting for a reply from the server so this is a very very crucial thing you need to know with regards to multiplayer games in general in order to make them feel good you have to update the UI right away even if technically the server hasn't yet received that message okay so this is really all there is to it with regards to the character selection it really is that simple the clients change their value use a server IPC and then the heads broadcast it to all the clients one more thing in this update is we can see over here the Escape so this is basically a simple and quit option if so then checks if this one is the host so if there are no more players if so then starts a shutdown and for the shutdown once again the same thing that we already saw previously so it sends a client RPC to all the clients in order to shut down and for shutting down religious goes into network manager shuts down and then loads back the main menu so that's it super simple now the final important logic in this scene is the play Ready setting again here on the player character the selection on the update so we test for A and D in order to change the character and then we also test for the space bar and it is a server RPC in order to tell the server that this character is running so it's going to run this function only on the server and then on this function basically it tries to start the game timer so here we can see what it does basically goes through all the players and if at least one of them is not yet ready if so then Samsung doesn't actually start a timer but if all of them are ready then goes to enable a simple timer we can see here the Tamil logic again just a basic photo timer so just counts down by time.com time note how this timer is only running on the server and nothing else so it counts on a timer and when that is done it triggers this start game function and this function over here triggers a client RPC in order to tell all the clients to fade in because again remember how the unloading happens automatically so it tells all the coins to fade in and then the server automatically loads the next scene send the clients to the fade in as soon as the fade in complaints the scene they receive the message to load the next scene then load it and everything completes okay so with that we arrive at the main gameplay scene and over here we have another really interesting thing right away so first phone was the same pattern so it starts over here from the unloading scene manager so there's this comeback he checks if the client can connect the server and so on and over here it's going to run this initialization function and over here here is the very interesting thing that I mentioned which is that if you were to spawn the client prefab right away apparently you could get some desync issues in case some of the other clients took a bit too long to load so the solution over here in this function is actually quite simple basically when the client connects it adds the client to a connected list and then it checks if this client is the last client if not then return and doesn't do anything but if it is the con less client then that's when it actually spawns all the prefabs so if you use the automatic scene management make sure you pay attention to this one potential sneak issue so make sure everyone is connected already before you start spawning things then over here for spawning it's pretty much the same thing that we saw so it spawns a network object and again changes ownership to the client so the clients own their own spaceships for the prefab that one is stored inside a circle object we can see here under data the scriptable objects containing all the data for all of the various types inside each of them has a different prefab variant so let's inspect this prefab and this one very simple as usual it has a network object then for controlling this one is a coop game so the clients actually have authority which means they move the transform directly and that is synchronized using the client Network transform so it's just like I showed in the netcode for game objects video this client tells the server where it should be and then down here we can see that these objects are also based on a rigid body so it has a rigid body to the component and then down here a network rigid body 2D in order to make sure everything is synchronized although also note how the body type over here is set as kinematic so that means there are no synchronized physics so it has this and then down here the various player control scripts so let's see this movement script here it is this one is pretty basic if we go down here we can see how it actually works so it handles the keyboard input so just doing some basic key testing in order to calculate an input vector then with that input Vector it runs this function so it takes the input vector and simply moves the transform directly then in turn when the transfer moves that one is synchronized to the client Network transform component so very simple example like I covered in the other video but if you remember from the gameplay the ships also change visual when moving up or down so that part is actually synchronized over here on this function so it just checks if the player is moving up or down and slice the Sprite and then once again use a server RPC in order to sell the server what Sprite it shouldn't load so then the server receives that message and simply broadcasts it to all the clients then the clients receive that message and based on a simple enum because again you cannot transfer objects so you cannot send a Sprite through a client RPC so over here it just defines an enum for all of the possible Sprites and then over here simply set them on only clients and that's really it for the movement as you can see it's super simple then let's take a look at this ship control script this one handles various player logic like for example using the shield so you can see it has for the input and then use a server RPC to turn the server to activate the shield and in this case the server is actually the one that is going to validate the inputs so when the player presses it is always going to trigger This Server RPC and then the server checks if this player can use it so if it has enough specials if so then counts them down and this one as you can see is a network variable so it gets automatically synchronized and then use a calendar PC in order to tell all the clients to activate this Shield then next thing this script does is testing for collisions with the power ups so that one is handled over here using a simple regular ontrigger enter 2D so this one is only going to run on the server so if the server detects a hit if it detects a hit with a power up special if so then validates if the player can handle more and if so once again updates the network variable it does that and also importantly down here it actually destroys the object so it runs this simple function which calls dspawn on the network object and again this logic only runs on the server so that gets rid of the power up next for the health and damage if we scroll up we can see this script once again has a network variable for the health and down here it has a hit function this one once again is only going to run on the server and when this spaceship gets hit it is going to count down the value by the damage which in turn this network variable is going to synchronize you all the clients then it also use a client RPC in order to tell the clients to play some kind of hit effect and then down here on the server it checks if the health is below zero meaning if the spaceship is dined if so then once again just goes and spawns a VFX prefab and then despawns the actual employer spacer finally it calls this function to say that this line has died and then this function is going to run this client there PC again with the client ID as a parameter and this one is essentially going to make sure that only this client is going to enable the death UI animation so as you can see all the helpful logic is also pretty basic now the next grip over here is the one for the player shoot bullet so this one actually spawns bullets and the way this script does that is once again using a nice server RPC so when the player presses space it triggers this function it is going to get a new bullet which once again is going to spawn a network object prefab it does that although note one important thing which is over here this one is spawned as a server object meaning this one is not going to change ownership to the player that fire the bullet all of the bullets are always owned by the server so you can then inspect this prefile to see how the Bonnet works so over here we can find the bullet prefab reference so let's open this and on this one once again it has a network object although this time it has a regular Network transform as opposed to the client Network transform again that's because all of the bullets are going to be owned by the server then once again it has a rigid body a rig a kinematic rigid body it also has a simple collider and then a bunch of scripts for movement it has this basic generic movement script really just all it does is it's only going to run the logic on the server and just going to modify this transform that's it then the other logic is over here the bullet controller this one has an enum for the bullet owner so basically the bullets are always going to be the same object for both the player and the enemy bullets and on start use a client RPC in order to set the color for this moment again different colors for player or enemy Bots and then down here some basic collection detection it is going to test for hits with something that can be damaged if it's a player then it's going to increase some stats it's going to deal on damage to that object and once again going to despawn this network object so all of it very basic so back here on the gameplay scene let's inspect the enemy spawner script so here it is the enemy's funnel script and over here on update we've got the spawning logic and again this is only going to run on the server basically just has a handle enemy spawning function and over here pretty simple just handles a photo timer if it goes above a certain maximum then gets a next random enemy prefab it spawns a prefab and then the enemy handles itself automatically same thing for the meteor so for the meteor over here same thing pretty much as spawns one then the important one is down here on the boss so once again that starts off as a simple timer so when the timer ends it starts this coroutine and first like we saw it first plays a warning UI so that is handled over here through a client RPC so all the clients receive this message to enable the warning UI then just Waits a little bit tells the clients to stop showing the warning UI and finally spawns the boss again just wanting a regular Network object just spawns it and initialize the behavior the boss has this script this boss controller which is actually a really nice State machine but in terms of multiplayer logic everything is really all the same it goes through the various stages firing various bullets and so on and the final important thing is when the boss dies so you can look over here on these scripts for the various boss dates so let's look at the both Nest state so when the boss dies it is going to spawn some random explosions then it destroys the network object and goes into this pasta feed function and again as usual this function does the same thing for any kind of loading that we've already seen so it does a client RPC to tell the clients to load something and then loads in this case the victory scene and finally over here on the victory scene we just see a bunch of basic stats and that's it that's a game and that's how it works as you can see it's a pretty simple and simple project which works great for learning it has some of the basics for making a multiplayer game you have a character selecting multiple characters a maximum player count you have moving spaceships bullets enemy spawning collisions a boss fight and a bunch more here we saw how it all works under the hood by using lots of network objects a bunch of server and command rpcs some interesting scene loading and a bunch more and you probably also notice some things like for example slight delay on the collisions the bones firing movement and so on Unity themselves have said that this project is intended to be the most basic working demo possible so all of those extra things all those things like movement prediction and some more responsive visuals those would be added on top of this starting base for those more complex things definitely go take a look at the more that one builds upon this and includes tons of optimizations that you definitely must learn to make a good multiplayer game again remember you can inspect this entire project for yourself download it with the link in the description if you haven't yet seen my complete detailed tutorial on netcode for game objects and definitely go watch it now and check out the other link to learn all about Unity gaming Services Unity has tons of tools to really help you bring your multiplayer games to life things like Matchmaker and Lobby relay and more so definitely go ahead and read about those I've also covered Lobby and really in two other dedicated videos and of course like I mentioned the reason why I researched this game was to prepare for my upcoming free multiplayer course and in preparation for that make sure you go watch my full free single player course alright hope that's useful check out these videos to learn some more thanks to these awesome patreon supporters for making these videos possible thank you for watching and I'll see you next time foreign
