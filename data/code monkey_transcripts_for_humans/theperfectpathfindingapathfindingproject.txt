With timestamps:

00:00 - hello and welcome i'm your code monkey
00:02 - and here's the first video in a really
00:04 - interesting new format
00:05 - the asset store is full of awesome
00:07 - assets so i figured i could review and
00:09 - highlight some of the best which can
00:11 - greatly help you when you're making your
00:12 - own games
00:13 - now for this first video in this asset
00:15 - review series i chose to highlight a
00:17 - really special asset for me the a-star
00:19 - pathfinding project
00:20 - this is the one asset that i've used the
00:22 - most and it has already helped me ship
00:24 - several steam games
00:25 - so here's the story back when i was
00:27 - first getting started with unity my very
00:29 - first game survivor squad
00:31 - was a strategy game where i really
00:32 - wanted to have hundreds of units
00:34 - and thankfully i found this asset pretty
00:36 - quickly which really helped me develop
00:38 - that game in a decent time frame
00:40 - if i had tried to make my own custom
00:42 - pathfinding with support for that many
00:43 - units it would have taken me ages
00:45 - whereas this was already set up with
00:47 - multi-threading which made pathfinding
00:49 - insanely quick
00:50 - even for hundreds of units now you might
00:52 - not think that performance is all that
00:54 - important if you just have a handful of
00:56 - characters in your game but it really is
00:58 - the less time your pathfinding takes to
01:00 - complete the more time you have for
01:01 - other things like more objects more
01:03 - effects to really make your game stand
01:05 - out
01:05 - so i can definitely tell from personal
01:07 - experience that this is an excellent
01:08 - asset that will help you greatly to
01:10 - solve all of your pathfinding
01:12 - needs and this asset is now eight years
01:14 - old with non-stop constant updates
01:16 - the change log is massive so you know
01:18 - this has been thoroughly battle tested
01:20 - in just about every scenario
01:22 - as always there's a link to the asset in
01:24 - the description and that's an affiliate
01:25 - link so if you pick it up through there
01:26 - you'll also be helping out the channel
01:28 - and as a bonus you can use that link and
01:30 - then use the coupon code monkey10 to get
01:32 - 10
01:33 - off your order so the a star pathfinding
01:35 - project it's a super fast path finding
01:37 - solution
01:38 - it supports dynamic scenes that are
01:39 - constantly changing procedurally
01:41 - generating worlds works on moving
01:43 - objects easily supports elevation
01:45 - works in both 2d and 3d it's really
01:47 - versatile
01:48 - and just like the name implies the
01:49 - underlying algorithm is a star
01:52 - if you're curious about how the
01:53 - algorithm works i made a nice video
01:55 - going through it step by step
01:56 - you can go watch that to get a better
01:58 - understanding and just by looking at the
02:00 - very simple implementation that i do in
02:02 - that video and comparing it to this one
02:04 - you can see how the performance
02:05 - difference is night and day
02:06 - now i've imported the package here and
02:08 - as usual it contains a bunch of
02:10 - documentation
02:11 - you've got an html file or a pdf and you
02:15 - can also find all of the updated
02:16 - documentation on the website
02:18 - the documentation is extremely detailed
02:20 - so you can really get it to work exactly
02:22 - as you want it
02:23 - and it also comes with a total of 16
02:25 - examples
02:26 - so you can see it in action in pretty
02:28 - much every scenario imaginable
02:29 - you've got simple movement pathfinding
02:31 - on the terrain one with links for
02:33 - jumping or a door that opens and closes
02:35 - another one showing pathfinding in a
02:37 - procedural world another one
02:39 - on a moving object and so on so this
02:41 - video is split in two parts
02:43 - first we're going to look at the demos
02:44 - to see what the asset can do and how
02:46 - they work
02:46 - and then after that i will do a quick
02:48 - step-by-step guide on how to start using
02:50 - it and add it to your own games
02:52 - let's first look at the simplest example
02:54 - possible so over here on
02:55 - example 3 so we have this mod character
02:58 - and it's following the mouse position
03:00 - so i can move the mouse around and it
03:02 - recalculates the path pretty much
03:04 - instantly
03:05 - down here on the console we can actually
03:06 - see what the code is doing
03:08 - so you can see how it's searching for
03:09 - all these paths searching for all of
03:11 - these nodes there you go the path length
03:13 - and you also see how long it's taking so
03:15 - even if i put it really far you can see
03:17 - just how quickly it works
03:18 - so it pretty much always runs down to
03:20 - zero milliseconds
03:22 - so it's path finding so obviously it
03:24 - goes around these objects
03:25 - then it also supports elevations over
03:27 - here we've got a ramp and yep it
03:29 - automatically knows how to get
03:30 - up there and the graph can also update
03:33 - in real time so i can press as it says
03:35 - here press p to place an obstacle and i
03:37 - press and there you go drops a bunch of
03:38 - obstacles
03:39 - and if i put it yep it recalculates and
03:42 - knows exactly where those
03:43 - are all these examples also have these
03:46 - useful messages teaching you how the
03:47 - asset works
03:48 - so for example here it's saying the a
03:50 - star game object has all the settings
03:52 - if we put the game in the scene view
03:54 - side by side we can see what is
03:55 - happening so over there you see a gizmo
03:57 - for the path as it's being calculated
03:59 - and you can see how fast it calculates
04:01 - and just in case you don't see this
04:02 - graph
04:03 - you can select the a star object and in
04:05 - here make sure you have show graph
04:06 - sticked
04:07 - so this a star object contains the
04:09 - pathfinder script this is the main
04:11 - script with all of the parameters
04:13 - the main ones are for the pathfinding
04:15 - area so you can see here the width and
04:17 - depth
04:17 - in terms of voxels and then down here
04:19 - you can see the size
04:21 - so we can just modify this make it
04:22 - smaller hit on scan
04:24 - and there you go to make sure that this
04:25 - area is walkable you can also decrease
04:28 - the cell size
04:29 - so doing that it splits the area into
04:31 - more and more nodes
04:33 - so this allows for more detailed paths
04:35 - obviously the more detailed you go the
04:37 - more time it takes to calculate
04:38 - so you can manually scan by clicking
04:40 - here or it will automatically scan as
04:42 - soon as you enter play mode
04:43 - we can see how it updates in real time
04:45 - so if i spawn a bunch of
04:47 - obstacles if there you go that's what it
04:48 - does so as soon as the obstacle touches
04:50 - the floor
04:51 - you can see yep it updates perfectly so
04:53 - it creates a brand new nav mesh taking
04:55 - these positions into account
04:57 - so you can play around with all these
04:58 - values then you hit on scan
05:00 - and make sure you've got enough of the
05:02 - area covered so next up if you scroll
05:04 - down here you see the settings tab
05:06 - and right away you see one of the most
05:08 - important ones so the thread
05:10 - count you can set it to multi-threading
05:12 - which will run pathfinding pretty much
05:13 - without any performance cost
05:15 - so if you were to use this in a final
05:16 - game you'd probably choose one of these
05:18 - you automatically
05:19 - load or hallowed then you also see a
05:21 - whole bunch of debug settings
05:23 - first up the path logging so you can
05:25 - make it really verbose or only show
05:26 - errors or don't show at all
05:28 - then you've got some graph coloring so
05:30 - you can essentially visualize various
05:32 - different things from the
05:33 - path so for example you can set it to
05:35 - show the gene which is one of the
05:37 - parameters used in the calculation
05:39 - and then up here take it to show the
05:40 - search tree and if we play
05:43 - you look at that now we get a nice
05:44 - visual representation of the path as
05:46 - it's being calculated
05:47 - so there you go really nice really fun
05:49 - to see this in action then you also have
05:51 - a whole bunch of colors that you can
05:52 - customize
05:53 - you can give a bunch of names to the
05:55 - various tags
05:56 - then down here you also have saving and
05:58 - loading so instead of generating the
06:00 - graph and runtime you can generate it
06:02 - right now and then save it onto a file
06:04 - and then you also have a whole bunch of
06:06 - optimizations so these are for more
06:08 - advanced use cases
06:09 - and finally you have the about tab which
06:11 - showcases a whole bunch of information
06:13 - the asset automatically searches for
06:15 - updates and lets you know if there's a
06:17 - new version
06:17 - alright so that's the main pathfinding
06:19 - script the pathfinder
06:21 - now for the other important scripts they
06:23 - are on the player themselves so in this
06:25 - case we have our bot
06:26 - character and right away the first one
06:28 - that we see is the seeker component
06:29 - this is what handles the pathfinding
06:31 - calls and does a bunch of
06:32 - post-processing on the path
06:34 - over here you can define what graphs are
06:36 - traversable by this unit
06:38 - and then you can also specify a bunch of
06:40 - tags see if they are traversable and if
06:42 - they have any panel
06:43 - then you have the ai path component so
06:45 - this is the script that actually follows
06:47 - the path calculated by the seeker
06:49 - for the parameters right away you can
06:51 - see the re-path rate so this is how
06:53 - often the ai won't recalculate the path
06:55 - to the target
06:56 - so the default is at 0.2 so 200
06:58 - milliseconds so 5 times per second
07:01 - if you have a game that changes the
07:02 - pathfinding map a ton you might want to
07:04 - lower this
07:04 - on the other hand if you have a very
07:06 - static pathfinding map you can push this
07:08 - higher to make it even more performant
07:10 - then you have the various movement
07:12 - parameters how it actually moves will
07:14 - depend on what other components you have
07:16 - attached to this object
07:17 - for example in this case it has a
07:19 - character controller so it's going to
07:21 - use that to move
07:22 - if it just had a rigid body it would use
07:24 - that and if it didn't have any of those
07:26 - and it would simply move the transform
07:28 - position directly
07:29 - so all of these parameters are pretty
07:30 - self-explanatory so you've got how fast
07:32 - it moves a bunch of acceleration whether
07:34 - it's in 2d or 3d rotation
07:37 - then how far from the final distance
07:39 - does it start slowing down
07:41 - and how far from the final distance does
07:42 - it stop should it use gravity or not
07:45 - and so on by the way every single one of
07:47 - these components has a detailed
07:48 - explanation in the documentation
07:51 - you can go into edit script so here is
07:54 - the script for the ad path
07:55 - as you can see it's got tons and tons of
07:57 - comments then you can also go
07:59 - into the actual documentation to see
08:01 - even more information
08:03 - so definitely look into that if you want
08:04 - to learn more about a particular
08:06 - component
08:06 - so the ai path is the base movement
08:08 - script but you don't absolutely have to
08:10 - use this one
08:11 - you can write your own script to follow
08:13 - the path generated by the seeker but
08:14 - this is a great starting point
08:16 - and then the post-processing that the
08:17 - seeker does is depend on the modifiers
08:19 - that you add onto this object
08:21 - so in this case it just has the funnel
08:23 - modifier if we disable this and hit play
08:25 - we can see what the original path looks
08:27 - like
08:28 - there you go over there we can see the
08:29 - path as it's being collided and as i
08:31 - move it
08:32 - yep you can see it's very jagging so
08:34 - it's essentially only going down to the
08:36 - center positions of
08:37 - each polygon so that's how the original
08:39 - path is calculated
08:41 - and then if we enable funnel yep now you
08:43 - see the difference now it actually
08:45 - funnels the
08:45 - path and makes it into a proper path so
08:48 - as i put it in there yep there you go a
08:49 - very nice mood path
08:51 - this is just one of the included
08:52 - modifiers you can go into add component
08:55 - and then here go down into pathfinding
08:58 - and go
08:59 - inside the modifiers and up in here
09:01 - you've got all the various modifier
09:02 - algorithms that you can apply
09:04 - and the final thing on this demo is the
09:06 - ai destination setter this one is an
09:08 - extremely simple script
09:10 - all it does is it grabs a reference to
09:11 - the ai path script
09:13 - and then it goes to that one and simply
09:15 - sets the destination directly to this
09:17 - target
09:18 - and the target itself is based on the
09:19 - mouse position and like i said in the
09:21 - second half of this video i will go
09:23 - through a quick getting start guide on
09:24 - how to implement this from scratch
09:26 - all right so that's the simplest example
09:28 - to see this asset in action
09:30 - then over here on example four we have
09:32 - an example using links
09:34 - so this character has the ability to
09:36 - climb up drop down and so on
09:38 - you can double click in order to set it
09:40 - to a certain position so if i put it
09:42 - right in there
09:43 - he's gonna go he's gonna drop down from
09:45 - there then he's gonna make a jump and so
09:47 - on
09:47 - so there are links between these various
09:49 - pathfinding areas
09:51 - and by the way if you find the video
09:52 - helpful consider subscribing and hitting
09:54 - the like button
09:55 - it really helps out the channel and over
09:57 - here on the scene view if we select the
09:58 - a star path we take show graphs and we
10:00 - hit on scan
10:01 - now we can visually see the links so we
10:03 - can see in blue all the walkable areas
10:06 - and over here we can see the various
10:07 - links so this area is linked into that
10:09 - one down into that one and so on
10:11 - as for how the links are set up they are
10:13 - set up in certain objects
10:15 - so in here if you click you go inside
10:17 - the ground inside the link and over here
10:18 - you've got the various cubes
10:20 - so here we got this one so that's that
10:22 - for area
10:23 - and then inside it there's a link game
10:25 - object and this game object contains
10:28 - this animation link component
10:30 - now this is a custom component made
10:31 - specifically for this scenario to play
10:33 - the jump animation
10:34 - but if you go on to add component go
10:37 - down here into pathfinding
10:39 - here you see link link two and link
10:41 - three so these are the three link types
10:43 - that you can add which is always you can
10:45 - go check out the documentation to see
10:46 - how they are different
10:47 - but in order to make your own link types
10:49 - to set up how your units handle various
10:52 - links
10:52 - you just extend one of those types in
10:54 - this case it has this link
10:56 - and then it has a child game object
10:58 - which is the final position on the link
11:00 - so it connects that position onto that
11:01 - one again the documentation is extremely
11:03 - useful if you want to implement your own
11:05 - links then for the bot on this example
11:07 - this one is using the rich ai
11:09 - so this one essentially builds on top of
11:11 - the simpler ai path and that supports
11:13 - for the links that we see here
11:15 - and then for playing the animation it
11:16 - also has a script so this example
11:18 - showcases how you can link various areas
11:21 - together
11:21 - now let's check out over here the
11:23 - example 5 for the point graph
11:25 - this one showcases a different type of
11:26 - graph so instead of a nav mesh we've got
11:28 - a point graph
11:29 - so this is perfect if you have a game
11:31 - where you want the player to only move
11:33 - through
11:33 - some specific areas so if i put the
11:36 - mouse right down there he simply goes to
11:38 - the closest position and never actually
11:39 - goes down into the void
11:40 - so it always stays within the path again
11:43 - we can inspect the path and scan it to
11:45 - see it in action
11:46 - so this one is using a graph of tai
11:48 - point graph and for the root it takes in
11:50 - a transform
11:51 - so for the transformer if we expand this
11:53 - we can see this one and it's in here
11:54 - that it has all the various nodes so all
11:56 - of those nodes are child with this
11:58 - transform
11:59 - then on the settings for the point graph
12:01 - over here we've got a max distance
12:03 - so it will automatically connect all the
12:05 - nodes within that distance
12:07 - and beyond that you can also add some
12:08 - manual links like we saw in the previous
12:10 - example
12:11 - so for example over here this one and
12:13 - this one are too far away so the
12:15 - algorithm will not
12:16 - automatically connect them but if you
12:18 - select on this one as you can see
12:19 - there's a link component and then it has
12:21 - a reference to this one so it's manually
12:22 - linking both of them so this is how you
12:24 - start with the automatic generation and
12:26 - then you can smoothly add the things
12:27 - that you want
12:29 - so this one is an extremely useful graph
12:30 - type for something like an adventure
12:32 - game where the player should only move
12:33 - through a certain path
12:35 - next up over here on example 7 we have a
12:37 - door example
12:39 - this one is showcasing the pathfinding
12:41 - updating a tag which in this case is set
12:42 - for the character to not go through
12:44 - closed doors
12:45 - so if the door is closed and i tell it
12:46 - to go there nope it doesn't go
12:48 - but if i talk on the door as soon as the
12:50 - door opens yep now he goes now i close
12:52 - it again
12:52 - now i don't go back nope and as soon as
12:54 - i open it does over here we can see the
12:56 - graph updating in action
12:58 - the part under the door has a different
13:00 - color so that's the visual
13:01 - representation of the tags
13:03 - on the a-star object if you go down here
13:05 - onto settings
13:06 - onto the debug you can see graph
13:08 - coloring is set to tags so that one is a
13:10 - set as blue so right now it has the open
13:12 - door color and if i tug on the door yup
13:14 - you can see it turns into green so it's
13:15 - showcasing the different tags
13:17 - then on the bot itself it has a seeker
13:19 - component and over here if we expand the
13:21 - tags
13:22 - we can see how it's set up so it's set
13:24 - up for the basic round open door and all
13:25 - the other tanks all those are
13:26 - traversable except for the closed door
13:29 - on this one it is not reversible and
13:31 - then on the door itself
13:33 - it has this door control script it has
13:35 - an open tag enclosed tag id
13:37 - and for the script itself down here that
13:39 - has a simple setstate component
13:41 - and what it does is it creates a graph
13:43 - update object this is how you update the
13:45 - graph
13:45 - you create this with the bounds for this
13:48 - object so that's how it knows what area
13:50 - it should update
13:51 - in this case it's just said to modify
13:53 - the tag set the tag and it's going to
13:55 - set the tag to this tag so either the
13:57 - open or the close tag
13:58 - so you create the graph update object
14:00 - and then you call the a-star path and
14:01 - you call to update graphs and pass in
14:03 - the update object so here it is an
14:06 - action opening and closing and you can
14:07 - see how the tag changes
14:09 - and for the bot right now i tell them to
14:10 - move and can move in here but if i
14:12 - double-click in there nope doesn't go
14:13 - open the door and now it does go
14:15 - so that's how simple it is to update the
14:17 - graph then there's a second door example
14:20 - and this one functionally it works
14:21 - exactly the same way so i try to go
14:23 - there can't go open the door
14:25 - and all of a sudden he goes there if we
14:28 - play the scene we can see the actual
14:29 - difference
14:30 - so in there we visualize the graph mesh
14:32 - and right now you see that it's actually
14:34 - cut so these two areas are separate and
14:35 - as i open it
14:36 - yep there you go you can see how the nav
14:38 - mesh constantly updates so it's closed
14:40 - and now it opens
14:41 - so instead of modifying tags this one is
14:43 - actually modifying the underlying nub
14:45 - mesh so this is a different method and
14:47 - this one is using the nav mesh cut
14:48 - component
14:49 - so here it is constantly cutting the
14:51 - mesh then here is example 8 path types
14:54 - this one showcases all the various path
14:56 - types that you can use
14:58 - so first of all just a simple a to b
15:00 - then you've got a multi-target path
15:02 - so this one finds the point from one
15:04 - position into many
15:05 - then you've got a random path which like
15:07 - the name implies gets a random path
15:08 - within a certain distance
15:10 - then you've got a fleet path which
15:11 - essentially takes in a position and then
15:13 - flees away from that position
15:15 - so very useful for tons of game logic
15:17 - then another one is for identifying all
15:20 - of the nodes within a certain range
15:21 - and then on the flood path you can
15:24 - search for the whole entire graph
15:26 - for every single node searching from a
15:28 - single point
15:29 - if you look in the console you can see
15:31 - that this takes quite a bit of time so
15:32 - it takes 10 milliseconds
15:34 - however if you cache those results then
15:36 - you have pretty much free pathfinding
15:38 - so if you go back into the av path and
15:41 - here as i click
15:42 - if i go towards the edges you can see
15:44 - that it takes between one and two
15:46 - milliseconds
15:47 - however if i use the flat path tracer
15:50 - this one all the paths were already
15:52 - calculated so no matter how far i push
15:53 - it now it's always zero milliseconds
15:55 - so that's the benefit of caching and
15:57 - here you can see you have tons of ways
15:59 - of accommodating different paths
16:00 - then on example nine we see penalties we
16:03 - have two bots
16:04 - one of them absolutely cannot go through
16:06 - the restricted areas
16:08 - and the other one tries to avoid the
16:09 - first area so if i got both my bots in
16:12 - here
16:13 - and i try to move in there there you go
16:15 - one of them goes all the way around
16:16 - and the other one goes through there and
16:18 - tries to avoid touching the restrict
16:20 - there you want as much as possible
16:21 - however if i go in here and i go down
16:23 - there then it does go through the
16:24 - restricted area so there's a penalty but
16:26 - you can still go through it
16:28 - now these areas are set up as tags and
16:31 - they are defined in these two graph
16:32 - update objects
16:34 - so these have the graph update scene and
16:36 - over here you've got a list of all of
16:37 - the points
16:38 - and in this case it's set to modify a
16:40 - tag and set this tag then on this other
16:42 - one it has this different shape and
16:44 - replies different tag
16:45 - and finally on the bots themselves we
16:47 - can see that it's using the same thing
16:48 - so on the seeker
16:49 - this one restricted area has a penalty
16:51 - of 300
16:52 - whereas the other one is simply set to
16:54 - not reversible
16:55 - then on example 10 we see a layered grid
16:57 - graph so this is a grid graph that also
17:00 - supports elevation
17:01 - so a normal grid graph which for example
17:03 - is the one being used here on
17:05 - example 9. on this one if we set it to
17:07 - shutter graphs and head on scan
17:09 - here we can see it's using a grid graph
17:11 - and there's this slight overpass here
17:12 - and you can see what happens so it only
17:14 - identifies the overpass above and it
17:16 - does not identify the area underneath
17:18 - but if we go into example 10 over here
17:20 - we have the same map but if we go in
17:22 - there we enable we scan
17:24 - and yep now this one does identify both
17:26 - areas so that's the layered grid graph
17:28 - then on example 12 we see a procedural
17:31 - generation
17:32 - so here's the bot in a randomly
17:34 - generated path and i can double click to
17:35 - set it to move and as he moves it
17:37 - generates more
17:38 - so here i go and if i move towards the
17:40 - edge of the square
17:41 - as soon as it gets to a certain point
17:43 - then he's going to generate a brand new
17:44 - area and start populating
17:46 - it and so on and if we select the
17:47 - pathfinding we can see enable show
17:49 - graphs
17:50 - and yep we can see how it's constantly
17:51 - updating so there's an area around the
17:53 - bot it's constantly updating so
17:55 - regardless of how the
17:56 - world is generated it's always finding a
17:58 - path you can even set the bar
18:00 - towards an area that does not exist so
18:02 - the bot is going all the way up to a
18:03 - corner there
18:04 - and as soon as he goes and he
18:06 - accommodates the path he sees this one
18:07 - is different different and then it
18:08 - merges with that one and so on
18:10 - so it's constantly updating next up on
18:12 - example 15 we see
18:14 - a 2d example so this one is using the xy
18:17 - plane instead of xz
18:18 - the obstacles themselves they simply
18:20 - have a box converter 2d so as i click he
18:22 - knows exactly how to get there
18:24 - and for the path this one is using a
18:26 - grid graph with 2d physics and collision
18:28 - testing so as i click anywhere
18:30 - he knows exactly how to get there for
18:32 - the ai scripts it uses the exact same
18:34 - seeker
18:35 - and then it can use the exact same
18:36 - movement script here it's using the
18:37 - alert for moving perfectly but you can
18:39 - apply smoothing to the path or use the
18:41 - ai pathfinding from previously
18:43 - alright so we've seen a whole bunch of
18:44 - examples there's quite a lot more this
18:46 - asset is extremely versatile and
18:48 - detailed
18:48 - if i were to go through all of them this
18:50 - video would be one hour long there's
18:51 - tons of stuff there
18:52 - but by now we've seen enough of what the
18:54 - asset can do so we should be able to use
18:56 - it
18:56 - so let's see how you could add it to
18:58 - your own games here is my demo scene
19:00 - with some very simple rts controls
19:02 - i made this from scratch in another
19:04 - video so go check the link in the
19:05 - description
19:06 - i can just select a whole bunch of units
19:07 - and tell them where to move so very
19:09 - simple stuff
19:10 - and on the cursor i just have an
19:11 - animated cursor as just a little bit of
19:13 - fun
19:13 - now as i mentioned in that video this
19:15 - does not contain any pathfinding
19:17 - they just blindly move towards the
19:19 - target position so if i try to grow and
19:21 - grab that item
19:22 - nope they just ram straight towards as
19:23 - well and then there's an enemy down
19:25 - there so as i click on it
19:27 - instead of going all the way around nope
19:28 - they just ran towards the wall
19:30 - so let's use our awesome new asset to
19:32 - solve our problem so the first thing
19:34 - that we need is to make our a star game
19:36 - object so let's make a new game object
19:37 - name it our a-star
19:39 - and let's reset the transform to keep
19:41 - things nice and organized
19:42 - then here let's add component and search
19:44 - for the pathfinder component
19:46 - and here we expand the graphs and now we
19:48 - choose what graph type we want
19:50 - so in this case this is a 2d demo so i'm
19:52 - going to go with a grid graph
19:54 - then go ahead and take on 2d and right
19:56 - away we can see our graph shape
19:58 - now for node size this is the size and
20:00 - units of each specific node
20:02 - naturally this will depend on the unit
20:04 - size that you define for your sprites
20:06 - so in my case i'm going to put it at
20:08 - five then you just need to extend the
20:10 - width and height to occupy the whole
20:11 - area so as i zoom out
20:13 - let's make sure it occupies the whole
20:15 - area okay that's a good size
20:17 - then over here for the connections we
20:19 - can leave it with eight connections for
20:20 - each cell
20:21 - so essentially it's got diagonals as
20:23 - well then make sure you take to the
20:25 - physics
20:26 - then for the collision testing you know
20:28 - let's go with a circle with diameter of
20:30 - two
20:30 - and then for the layer let's select the
20:32 - one layer so all of these
20:34 - wall objects they've got box and letters
20:35 - and they're set to the one layer
20:37 - all right so that's pretty much it and
20:38 - now if i hit scan if there you go now
20:40 - i've got the map and it's fully working
20:42 - so it identifies the walls and it
20:43 - identifies the wonka bone areas
20:45 - alright so it's already working now
20:47 - let's make the units complete and follow
20:49 - a path
20:50 - for that over here is my unit game
20:52 - object now this one is set up using the
20:54 - modular character controller that i made
20:56 - in another video
20:57 - and for the movement it's using this
20:59 - move position direct script
21:01 - so what that does is it calculates the
21:02 - direction straight towards the target
21:04 - and sets the velocity to move towards it
21:06 - so like i said direct movement there is
21:07 - no pathfinding
21:08 - now to use pathfinding we first need to
21:10 - add the seeker component
21:12 - so this is what actually calculates the
21:13 - path everything with defaults should be
21:15 - fine right now i don't want to play
21:17 - around any penalties or any tags so the
21:19 - default is fine
21:20 - then we add the ai path script again for
21:23 - more complex use case you could extend
21:24 - this but in this case this one is more
21:26 - than enough
21:27 - for the read path right here let's put
21:28 - it at 0.1 so it updates quickly
21:30 - then just set these values depending on
21:32 - the size of your sprites so in my case
21:34 - putting max mean and then i do want them
21:37 - to move really quickly so let me put
21:39 - with my acceleration of 500
21:41 - for the orientation this is a 2d game so
21:43 - go with that one for rotation i don't
21:45 - want this game object to be rotated
21:47 - for the next waypoint distance yeah sure
21:48 - a bit more than that should be fine
21:50 - for the slowdown maybe on 10 maybe on 5.
21:52 - now again the values that i'm using here
21:54 - are obviously related to the size of my
21:56 - sprites
21:57 - my 2d characters are about three units
21:58 - tall so if you use different sprite size
22:00 - then naturally you need to play around
22:02 - these values
22:03 - okay so that's pretty much it we've got
22:04 - the seeker to accommodate the path and
22:06 - the ipad to phone with all we need to do
22:07 - is just grab this ai path and then set
22:10 - the destination
22:11 - so for that let's remove the scripts
22:12 - that i'm using to move directly
22:14 - so i'm going to remove this one that
22:15 - completes the direction and this one
22:17 - that sets the rigid body for listening
22:19 - instead i'm going to add this move
22:21 - position a star pathfinding script
22:23 - now this script is pretty much empty all
22:25 - that it matters is that it implements
22:26 - this
22:27 - move position interface so this is just
22:29 - how my basic unit is set to give orders
22:32 - towards the target move position
22:33 - this unit rts script is what listens to
22:35 - the player input
22:37 - and then just goes into whatever script
22:39 - implements that interface and sets the
22:40 - move position
22:41 - so here in order to use pathfinding it's
22:42 - very simple we just need to grab the ai
22:44 - path
22:45 - so let's make a private ai path and now
22:48 - we need
22:49 - the namespace so up here using
22:51 - pathfinding
22:53 - we get that and let's say on awake grab
22:55 - the path
23:00 - and then on the set move position we're
23:02 - simply going to set the destination
23:03 - destination towards the target move
23:05 - position
23:06 - all right and that's it just like this
23:07 - it should already be working let's test
23:09 - so here i am and if i select it and tell
23:11 - it to move here yep there you go it does
23:13 - move towards the target position and now
23:14 - if i go straight towards trying to grab
23:16 - that item
23:17 - and if there you go he does go around
23:18 - the wall alright so we have pathfinding
23:21 - and it is indeed working
23:22 - now if we look in the scene view we can
23:24 - see what's actually happening so we
23:26 - select that one tell it to move there
23:27 - and there you go that's the calculated
23:28 - path
23:29 - so as you can see it's quite jaggy so
23:31 - just like we saw we can apply a modifier
23:33 - so simply go down here and let's add the
23:36 - funnel modifier
23:37 - and now if i click yes there you go now
23:38 - i've got a nice smooth path so as i go
23:40 - there
23:40 - yep nice and smooth so here it is let's
23:43 - take this guy go grab that item you go
23:45 - grab that item and yep it does work
23:47 - and you go down there yep he does go
23:49 - around it he goes towards the enemy and
23:50 - shoots the enemy
23:51 - alright so yep we have all of our logic
23:54 - and all of our pathfinding working
23:55 - all right awesome so there you have it
23:57 - that's how easy it is to add
23:59 - you just had the pathfinding object you
24:00 - set up the grin then on the unit
24:02 - you add the seeker to calculate the path
24:04 - and the script to follow it like the
24:05 - built-in ai path
24:07 - the logic in 3d is exactly the same you
24:09 - just use a different type of graph and
24:11 - change some parameters now you can build
24:12 - upon this and implement all the features
24:14 - that we already saw like the restricted
24:16 - areas
24:16 - updating the path elevation and so on so
24:19 - that's the a-star pathfinding project
24:21 - it's very easy to add extremely fast and
24:23 - works on any scenario
24:24 - if you need a pathfinding solution then
24:26 - this is all you need
24:28 - as i said i've already used this asset
24:29 - to ship successful steam game so i can
24:31 - vouch for
24:32 - its usefulness go get it through the
24:33 - link in the description and as a bonus
24:35 - use the coupon code monkey10 to get 10
24:37 - off your order using the affiliate link
24:39 - helps support the channel and you get an
24:40 - awesome asset to help you in making your
24:42 - games
24:42 - i hope you found this review useful for
24:44 - your own projects let me know in the
24:46 - comments any suggestions for other
24:47 - assets that i should review next
24:49 - thanks to these awesome patreon
24:50 - supporters for making these videos
24:52 - possible
24:53 - thank you for watching and i'll see you
24:54 - next time

Cleaned transcript:

hello and welcome i'm your code monkey and here's the first video in a really interesting new format the asset store is full of awesome assets so i figured i could review and highlight some of the best which can greatly help you when you're making your own games now for this first video in this asset review series i chose to highlight a really special asset for me the astar pathfinding project this is the one asset that i've used the most and it has already helped me ship several steam games so here's the story back when i was first getting started with unity my very first game survivor squad was a strategy game where i really wanted to have hundreds of units and thankfully i found this asset pretty quickly which really helped me develop that game in a decent time frame if i had tried to make my own custom pathfinding with support for that many units it would have taken me ages whereas this was already set up with multithreading which made pathfinding insanely quick even for hundreds of units now you might not think that performance is all that important if you just have a handful of characters in your game but it really is the less time your pathfinding takes to complete the more time you have for other things like more objects more effects to really make your game stand out so i can definitely tell from personal experience that this is an excellent asset that will help you greatly to solve all of your pathfinding needs and this asset is now eight years old with nonstop constant updates the change log is massive so you know this has been thoroughly battle tested in just about every scenario as always there's a link to the asset in the description and that's an affiliate link so if you pick it up through there you'll also be helping out the channel and as a bonus you can use that link and then use the coupon code monkey10 to get 10 off your order so the a star pathfinding project it's a super fast path finding solution it supports dynamic scenes that are constantly changing procedurally generating worlds works on moving objects easily supports elevation works in both 2d and 3d it's really versatile and just like the name implies the underlying algorithm is a star if you're curious about how the algorithm works i made a nice video going through it step by step you can go watch that to get a better understanding and just by looking at the very simple implementation that i do in that video and comparing it to this one you can see how the performance difference is night and day now i've imported the package here and as usual it contains a bunch of documentation you've got an html file or a pdf and you can also find all of the updated documentation on the website the documentation is extremely detailed so you can really get it to work exactly as you want it and it also comes with a total of 16 examples so you can see it in action in pretty much every scenario imaginable you've got simple movement pathfinding on the terrain one with links for jumping or a door that opens and closes another one showing pathfinding in a procedural world another one on a moving object and so on so this video is split in two parts first we're going to look at the demos to see what the asset can do and how they work and then after that i will do a quick stepbystep guide on how to start using it and add it to your own games let's first look at the simplest example possible so over here on example 3 so we have this mod character and it's following the mouse position so i can move the mouse around and it recalculates the path pretty much instantly down here on the console we can actually see what the code is doing so you can see how it's searching for all these paths searching for all of these nodes there you go the path length and you also see how long it's taking so even if i put it really far you can see just how quickly it works so it pretty much always runs down to zero milliseconds so it's path finding so obviously it goes around these objects then it also supports elevations over here we've got a ramp and yep it automatically knows how to get up there and the graph can also update in real time so i can press as it says here press p to place an obstacle and i press and there you go drops a bunch of obstacles and if i put it yep it recalculates and knows exactly where those are all these examples also have these useful messages teaching you how the asset works so for example here it's saying the a star game object has all the settings if we put the game in the scene view side by side we can see what is happening so over there you see a gizmo for the path as it's being calculated and you can see how fast it calculates and just in case you don't see this graph you can select the a star object and in here make sure you have show graph sticked so this a star object contains the pathfinder script this is the main script with all of the parameters the main ones are for the pathfinding area so you can see here the width and depth in terms of voxels and then down here you can see the size so we can just modify this make it smaller hit on scan and there you go to make sure that this area is walkable you can also decrease the cell size so doing that it splits the area into more and more nodes so this allows for more detailed paths obviously the more detailed you go the more time it takes to calculate so you can manually scan by clicking here or it will automatically scan as soon as you enter play mode we can see how it updates in real time so if i spawn a bunch of obstacles if there you go that's what it does so as soon as the obstacle touches the floor you can see yep it updates perfectly so it creates a brand new nav mesh taking these positions into account so you can play around with all these values then you hit on scan and make sure you've got enough of the area covered so next up if you scroll down here you see the settings tab and right away you see one of the most important ones so the thread count you can set it to multithreading which will run pathfinding pretty much without any performance cost so if you were to use this in a final game you'd probably choose one of these you automatically load or hallowed then you also see a whole bunch of debug settings first up the path logging so you can make it really verbose or only show errors or don't show at all then you've got some graph coloring so you can essentially visualize various different things from the path so for example you can set it to show the gene which is one of the parameters used in the calculation and then up here take it to show the search tree and if we play you look at that now we get a nice visual representation of the path as it's being calculated so there you go really nice really fun to see this in action then you also have a whole bunch of colors that you can customize you can give a bunch of names to the various tags then down here you also have saving and loading so instead of generating the graph and runtime you can generate it right now and then save it onto a file and then you also have a whole bunch of optimizations so these are for more advanced use cases and finally you have the about tab which showcases a whole bunch of information the asset automatically searches for updates and lets you know if there's a new version alright so that's the main pathfinding script the pathfinder now for the other important scripts they are on the player themselves so in this case we have our bot character and right away the first one that we see is the seeker component this is what handles the pathfinding calls and does a bunch of postprocessing on the path over here you can define what graphs are traversable by this unit and then you can also specify a bunch of tags see if they are traversable and if they have any panel then you have the ai path component so this is the script that actually follows the path calculated by the seeker for the parameters right away you can see the repath rate so this is how often the ai won't recalculate the path to the target so the default is at 0.2 so 200 milliseconds so 5 times per second if you have a game that changes the pathfinding map a ton you might want to lower this on the other hand if you have a very static pathfinding map you can push this higher to make it even more performant then you have the various movement parameters how it actually moves will depend on what other components you have attached to this object for example in this case it has a character controller so it's going to use that to move if it just had a rigid body it would use that and if it didn't have any of those and it would simply move the transform position directly so all of these parameters are pretty selfexplanatory so you've got how fast it moves a bunch of acceleration whether it's in 2d or 3d rotation then how far from the final distance does it start slowing down and how far from the final distance does it stop should it use gravity or not and so on by the way every single one of these components has a detailed explanation in the documentation you can go into edit script so here is the script for the ad path as you can see it's got tons and tons of comments then you can also go into the actual documentation to see even more information so definitely look into that if you want to learn more about a particular component so the ai path is the base movement script but you don't absolutely have to use this one you can write your own script to follow the path generated by the seeker but this is a great starting point and then the postprocessing that the seeker does is depend on the modifiers that you add onto this object so in this case it just has the funnel modifier if we disable this and hit play we can see what the original path looks like there you go over there we can see the path as it's being collided and as i move it yep you can see it's very jagging so it's essentially only going down to the center positions of each polygon so that's how the original path is calculated and then if we enable funnel yep now you see the difference now it actually funnels the path and makes it into a proper path so as i put it in there yep there you go a very nice mood path this is just one of the included modifiers you can go into add component and then here go down into pathfinding and go inside the modifiers and up in here you've got all the various modifier algorithms that you can apply and the final thing on this demo is the ai destination setter this one is an extremely simple script all it does is it grabs a reference to the ai path script and then it goes to that one and simply sets the destination directly to this target and the target itself is based on the mouse position and like i said in the second half of this video i will go through a quick getting start guide on how to implement this from scratch all right so that's the simplest example to see this asset in action then over here on example four we have an example using links so this character has the ability to climb up drop down and so on you can double click in order to set it to a certain position so if i put it right in there he's gonna go he's gonna drop down from there then he's gonna make a jump and so on so there are links between these various pathfinding areas and by the way if you find the video helpful consider subscribing and hitting the like button it really helps out the channel and over here on the scene view if we select the a star path we take show graphs and we hit on scan now we can visually see the links so we can see in blue all the walkable areas and over here we can see the various links so this area is linked into that one down into that one and so on as for how the links are set up they are set up in certain objects so in here if you click you go inside the ground inside the link and over here you've got the various cubes so here we got this one so that's that for area and then inside it there's a link game object and this game object contains this animation link component now this is a custom component made specifically for this scenario to play the jump animation but if you go on to add component go down here into pathfinding here you see link link two and link three so these are the three link types that you can add which is always you can go check out the documentation to see how they are different but in order to make your own link types to set up how your units handle various links you just extend one of those types in this case it has this link and then it has a child game object which is the final position on the link so it connects that position onto that one again the documentation is extremely useful if you want to implement your own links then for the bot on this example this one is using the rich ai so this one essentially builds on top of the simpler ai path and that supports for the links that we see here and then for playing the animation it also has a script so this example showcases how you can link various areas together now let's check out over here the example 5 for the point graph this one showcases a different type of graph so instead of a nav mesh we've got a point graph so this is perfect if you have a game where you want the player to only move through some specific areas so if i put the mouse right down there he simply goes to the closest position and never actually goes down into the void so it always stays within the path again we can inspect the path and scan it to see it in action so this one is using a graph of tai point graph and for the root it takes in a transform so for the transformer if we expand this we can see this one and it's in here that it has all the various nodes so all of those nodes are child with this transform then on the settings for the point graph over here we've got a max distance so it will automatically connect all the nodes within that distance and beyond that you can also add some manual links like we saw in the previous example so for example over here this one and this one are too far away so the algorithm will not automatically connect them but if you select on this one as you can see there's a link component and then it has a reference to this one so it's manually linking both of them so this is how you start with the automatic generation and then you can smoothly add the things that you want so this one is an extremely useful graph type for something like an adventure game where the player should only move through a certain path next up over here on example 7 we have a door example this one is showcasing the pathfinding updating a tag which in this case is set for the character to not go through closed doors so if the door is closed and i tell it to go there nope it doesn't go but if i talk on the door as soon as the door opens yep now he goes now i close it again now i don't go back nope and as soon as i open it does over here we can see the graph updating in action the part under the door has a different color so that's the visual representation of the tags on the astar object if you go down here onto settings onto the debug you can see graph coloring is set to tags so that one is a set as blue so right now it has the open door color and if i tug on the door yup you can see it turns into green so it's showcasing the different tags then on the bot itself it has a seeker component and over here if we expand the tags we can see how it's set up so it's set up for the basic round open door and all the other tanks all those are traversable except for the closed door on this one it is not reversible and then on the door itself it has this door control script it has an open tag enclosed tag id and for the script itself down here that has a simple setstate component and what it does is it creates a graph update object this is how you update the graph you create this with the bounds for this object so that's how it knows what area it should update in this case it's just said to modify the tag set the tag and it's going to set the tag to this tag so either the open or the close tag so you create the graph update object and then you call the astar path and you call to update graphs and pass in the update object so here it is an action opening and closing and you can see how the tag changes and for the bot right now i tell them to move and can move in here but if i doubleclick in there nope doesn't go open the door and now it does go so that's how simple it is to update the graph then there's a second door example and this one functionally it works exactly the same way so i try to go there can't go open the door and all of a sudden he goes there if we play the scene we can see the actual difference so in there we visualize the graph mesh and right now you see that it's actually cut so these two areas are separate and as i open it yep there you go you can see how the nav mesh constantly updates so it's closed and now it opens so instead of modifying tags this one is actually modifying the underlying nub mesh so this is a different method and this one is using the nav mesh cut component so here it is constantly cutting the mesh then here is example 8 path types this one showcases all the various path types that you can use so first of all just a simple a to b then you've got a multitarget path so this one finds the point from one position into many then you've got a random path which like the name implies gets a random path within a certain distance then you've got a fleet path which essentially takes in a position and then flees away from that position so very useful for tons of game logic then another one is for identifying all of the nodes within a certain range and then on the flood path you can search for the whole entire graph for every single node searching from a single point if you look in the console you can see that this takes quite a bit of time so it takes 10 milliseconds however if you cache those results then you have pretty much free pathfinding so if you go back into the av path and here as i click if i go towards the edges you can see that it takes between one and two milliseconds however if i use the flat path tracer this one all the paths were already calculated so no matter how far i push it now it's always zero milliseconds so that's the benefit of caching and here you can see you have tons of ways of accommodating different paths then on example nine we see penalties we have two bots one of them absolutely cannot go through the restricted areas and the other one tries to avoid the first area so if i got both my bots in here and i try to move in there there you go one of them goes all the way around and the other one goes through there and tries to avoid touching the restrict there you want as much as possible however if i go in here and i go down there then it does go through the restricted area so there's a penalty but you can still go through it now these areas are set up as tags and they are defined in these two graph update objects so these have the graph update scene and over here you've got a list of all of the points and in this case it's set to modify a tag and set this tag then on this other one it has this different shape and replies different tag and finally on the bots themselves we can see that it's using the same thing so on the seeker this one restricted area has a penalty of 300 whereas the other one is simply set to not reversible then on example 10 we see a layered grid graph so this is a grid graph that also supports elevation so a normal grid graph which for example is the one being used here on example 9. on this one if we set it to shutter graphs and head on scan here we can see it's using a grid graph and there's this slight overpass here and you can see what happens so it only identifies the overpass above and it does not identify the area underneath but if we go into example 10 over here we have the same map but if we go in there we enable we scan and yep now this one does identify both areas so that's the layered grid graph then on example 12 we see a procedural generation so here's the bot in a randomly generated path and i can double click to set it to move and as he moves it generates more so here i go and if i move towards the edge of the square as soon as it gets to a certain point then he's going to generate a brand new area and start populating it and so on and if we select the pathfinding we can see enable show graphs and yep we can see how it's constantly updating so there's an area around the bot it's constantly updating so regardless of how the world is generated it's always finding a path you can even set the bar towards an area that does not exist so the bot is going all the way up to a corner there and as soon as he goes and he accommodates the path he sees this one is different different and then it merges with that one and so on so it's constantly updating next up on example 15 we see a 2d example so this one is using the xy plane instead of xz the obstacles themselves they simply have a box converter 2d so as i click he knows exactly how to get there and for the path this one is using a grid graph with 2d physics and collision testing so as i click anywhere he knows exactly how to get there for the ai scripts it uses the exact same seeker and then it can use the exact same movement script here it's using the alert for moving perfectly but you can apply smoothing to the path or use the ai pathfinding from previously alright so we've seen a whole bunch of examples there's quite a lot more this asset is extremely versatile and detailed if i were to go through all of them this video would be one hour long there's tons of stuff there but by now we've seen enough of what the asset can do so we should be able to use it so let's see how you could add it to your own games here is my demo scene with some very simple rts controls i made this from scratch in another video so go check the link in the description i can just select a whole bunch of units and tell them where to move so very simple stuff and on the cursor i just have an animated cursor as just a little bit of fun now as i mentioned in that video this does not contain any pathfinding they just blindly move towards the target position so if i try to grow and grab that item nope they just ram straight towards as well and then there's an enemy down there so as i click on it instead of going all the way around nope they just ran towards the wall so let's use our awesome new asset to solve our problem so the first thing that we need is to make our a star game object so let's make a new game object name it our astar and let's reset the transform to keep things nice and organized then here let's add component and search for the pathfinder component and here we expand the graphs and now we choose what graph type we want so in this case this is a 2d demo so i'm going to go with a grid graph then go ahead and take on 2d and right away we can see our graph shape now for node size this is the size and units of each specific node naturally this will depend on the unit size that you define for your sprites so in my case i'm going to put it at five then you just need to extend the width and height to occupy the whole area so as i zoom out let's make sure it occupies the whole area okay that's a good size then over here for the connections we can leave it with eight connections for each cell so essentially it's got diagonals as well then make sure you take to the physics then for the collision testing you know let's go with a circle with diameter of two and then for the layer let's select the one layer so all of these wall objects they've got box and letters and they're set to the one layer all right so that's pretty much it and now if i hit scan if there you go now i've got the map and it's fully working so it identifies the walls and it identifies the wonka bone areas alright so it's already working now let's make the units complete and follow a path for that over here is my unit game object now this one is set up using the modular character controller that i made in another video and for the movement it's using this move position direct script so what that does is it calculates the direction straight towards the target and sets the velocity to move towards it so like i said direct movement there is no pathfinding now to use pathfinding we first need to add the seeker component so this is what actually calculates the path everything with defaults should be fine right now i don't want to play around any penalties or any tags so the default is fine then we add the ai path script again for more complex use case you could extend this but in this case this one is more than enough for the read path right here let's put it at 0.1 so it updates quickly then just set these values depending on the size of your sprites so in my case putting max mean and then i do want them to move really quickly so let me put with my acceleration of 500 for the orientation this is a 2d game so go with that one for rotation i don't want this game object to be rotated for the next waypoint distance yeah sure a bit more than that should be fine for the slowdown maybe on 10 maybe on 5. now again the values that i'm using here are obviously related to the size of my sprites my 2d characters are about three units tall so if you use different sprite size then naturally you need to play around these values okay so that's pretty much it we've got the seeker to accommodate the path and the ipad to phone with all we need to do is just grab this ai path and then set the destination so for that let's remove the scripts that i'm using to move directly so i'm going to remove this one that completes the direction and this one that sets the rigid body for listening instead i'm going to add this move position a star pathfinding script now this script is pretty much empty all that it matters is that it implements this move position interface so this is just how my basic unit is set to give orders towards the target move position this unit rts script is what listens to the player input and then just goes into whatever script implements that interface and sets the move position so here in order to use pathfinding it's very simple we just need to grab the ai path so let's make a private ai path and now we need the namespace so up here using pathfinding we get that and let's say on awake grab the path and then on the set move position we're simply going to set the destination destination towards the target move position all right and that's it just like this it should already be working let's test so here i am and if i select it and tell it to move here yep there you go it does move towards the target position and now if i go straight towards trying to grab that item and if there you go he does go around the wall alright so we have pathfinding and it is indeed working now if we look in the scene view we can see what's actually happening so we select that one tell it to move there and there you go that's the calculated path so as you can see it's quite jaggy so just like we saw we can apply a modifier so simply go down here and let's add the funnel modifier and now if i click yes there you go now i've got a nice smooth path so as i go there yep nice and smooth so here it is let's take this guy go grab that item you go grab that item and yep it does work and you go down there yep he does go around it he goes towards the enemy and shoots the enemy alright so yep we have all of our logic and all of our pathfinding working all right awesome so there you have it that's how easy it is to add you just had the pathfinding object you set up the grin then on the unit you add the seeker to calculate the path and the script to follow it like the builtin ai path the logic in 3d is exactly the same you just use a different type of graph and change some parameters now you can build upon this and implement all the features that we already saw like the restricted areas updating the path elevation and so on so that's the astar pathfinding project it's very easy to add extremely fast and works on any scenario if you need a pathfinding solution then this is all you need as i said i've already used this asset to ship successful steam game so i can vouch for its usefulness go get it through the link in the description and as a bonus use the coupon code monkey10 to get 10 off your order using the affiliate link helps support the channel and you get an awesome asset to help you in making your games i hope you found this review useful for your own projects let me know in the comments any suggestions for other assets that i should review next thanks to these awesome patreon supporters for making these videos possible thank you for watching and i'll see you next time
