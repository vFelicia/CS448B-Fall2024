With timestamps:

00:00 - hello and welcome I'm your codm so here
00:02 - let's see a highle overview of how to
00:04 - build a game just like Assassin's Creed
00:06 - Mirage I'm going to cover all these
00:08 - mechanics and how I would go about
00:09 - building them I made a page on the
00:11 - website with links to all the tutorials
00:12 - that I'm going to reference it's Link in
00:13 - the description basically this is a new
00:15 - format that I'm trying out going through
00:17 - a game or a specific genre and doing a
00:19 - high level overview of the various
00:20 - mechanics and referencing the various
00:22 - tutorials where I've covered them in
00:23 - detail hopefully if you're trying to
00:24 - build something similar to any of these
00:26 - mechanics then this can be quite useful
00:28 - I simply don't have the time to make
00:29 - super detailed stepbystep course on
00:31 - every single game every single genre
00:32 - imaginable but I think this quick format
00:35 - can be useful to help point you in the
00:36 - right direction as with everything that
00:37 - I do this is just an experiment so do
00:40 - let me know in the comments if you find
00:41 - this format useful like the video and
00:43 - subscribe if you do okay so here let's
00:45 - see a nice high level overview of how to
00:47 - build a game like Assassin Creed Mirage
00:49 - I play the game and I analyze it so here
00:50 - are the mechanics that I'm going to
00:51 - cover personally I always really enjoy
00:53 - these Assassin's Creed games I love
00:55 - historical medieval stuff and I love
00:57 - open worlds with lots of stuff to do
01:00 - traversing that open world is one of the
01:01 - crucial things so speaking of that the
01:03 - main thing you probably think of when
01:05 - you think of Assassin's Creed is the
01:06 - parkour system basically how you can
01:08 - just look at a wall then simply run
01:10 - towards it and the character jumps and
01:11 - grabs onto every hole point and
01:13 - everything looks great and climbs all
01:14 - the way up to the top now this is one of
01:16 - those mechanics where if you're a
01:17 - beginner this might seem impossibly
01:19 - complex but in reality building
01:21 - something like this is actually
01:22 - relatively simple or rather I should say
01:24 - the difficulty in building a mechanic
01:25 - like this is not necessarily in terms of
01:27 - logic complexity the difficulty is
01:29 - simply in the massive amount of work
01:30 - required to build all of the unique
01:31 - animations set up all the home points on
01:34 - every single wall in the entire game
01:36 - doing all of that for a large world is
01:37 - obviously a ton of work a ton of
01:39 - animations a ton of EDG cases a ton of
01:40 - stuff so it is very laborious but in
01:42 - terms of logic it's actually quite
01:43 - simple basically you need to Define what
01:45 - exactly is a home point and then as the
01:47 - player moves pretty much just need to
01:48 - figure out which one is the closest Home
01:50 - point that matches the player's input so
01:52 - for example over here in this scenario
01:54 - this one is marked as a hold point this
01:55 - little right here this is also a hold
01:57 - point this is a home point this one as
01:59 - well as is that one as is up there and
02:01 - so on so all of these are individual
02:03 - hold points that again were marked
02:05 - either manually or automatically through
02:07 - some algorithm in terms of the logic
02:09 - itself they can simply be just letters
02:10 - with a basic script on top maybe that
02:13 - script could then have a reference to a
02:14 - scriptable object that defines all the
02:16 - data on that specific hold Point like
02:18 - saying that this one over here this one
02:19 - is a wire whereas this one is just a
02:21 - little thing coming out then the logic
02:23 - in the player itself the player would
02:25 - simply do a physics query around the
02:26 - player position so right around here it
02:28 - would do some kind of Circle to identify
02:31 - all the hold points near the player
02:32 - position it also takes the player's
02:34 - inputs into account so if the player is
02:35 - going this direction then it's not going
02:37 - to check for physics collisions all all
02:39 - the way over here so it checks for
02:41 - nearby Home points through some kind of
02:42 - physics square like an overlap sphere
02:44 - then it simply finds a closest one
02:46 - although there can be multiple closest
02:48 - ones so over here all of these ones all
02:50 - of these are pretty much around the same
02:52 - position so as I'm going to move and
02:54 - jump he's going to grab pretty much any
02:55 - of these then the system decides to pick
02:57 - which specific animation matches this
02:59 - one so so which specific animation goes
03:01 - from the player being over here on the
03:02 - floor to picking up some bar in here or
03:04 - this one here so in the game itself if I
03:06 - just move forward and I jump and there
03:08 - you go he grabbed straight onto that one
03:10 - I can move down I can go onto this whole
03:11 - point I can go up to that one side to
03:14 - that one and so on and of course one
03:15 - climbing the controls become vertical so
03:17 - the control Vector instead of being down
03:19 - on the XZ plane instead of that now it
03:21 - is up here on the XY so move up or move
03:24 - to the side and for these animations
03:26 - they've got tons of animations but they
03:27 - also have quite a bit of dynamic to them
03:29 - so as you can see it always grabs on the
03:31 - exact same position now they don't have
03:33 - a million animations they've got a
03:34 - couple hundred maybe even a thousand but
03:36 - they definitely don't have millions of
03:38 - animations so to handle Dynamic
03:39 - animations basically how do you handle
03:41 - Dynamic Logic on top of static
03:42 - animations for that you use inverse
03:44 - kinematics Unity actually has a built-in
03:46 - tool to do inverse schematics it is
03:48 - called animation rigging I made a
03:49 - tutorial on it it is super useful super
03:51 - awesome for making your animations a lot
03:53 - more Dynamic another crucial mechanic in
03:55 - these games is Eagle Vision I think the
03:56 - original Assassin's Creed was actually
03:58 - one of the first games to pop poize this
04:00 - mechanic and afterwards the Batman
04:02 - Arkham games and Witcher 3 all of them
04:04 - Implement it's a really interesting
04:05 - thing basically you press a button and
04:07 - the world goes into this special Vision
04:09 - mode where it highlights individual
04:11 - enemies some helper Allied units and a
04:13 - bunch of items so to build something
04:15 - like this basally there are two ways to
04:16 - do it once again you can do a simple
04:18 - physics query around the player then you
04:21 - can locate all the various objects that
04:22 - Implement some kind of interface related
04:24 - to Eagle Vision and then you can
04:26 - basically T those objects in order to
04:28 - highlight themselves so that they would
04:29 - change the material to change the Shader
04:31 - to be more visible and so on or
04:33 - alternatively you can just have the
04:34 - player just the player fire off some
04:36 - event when they enable Eagle Vision and
04:38 - then all of the individual objects all
04:39 - of them have a certain script on them
04:41 - and then that script listens to that
04:43 - event so when the player enables this
04:44 - mode and checks the distance towards the
04:45 - player and if close enough then enables
04:47 - that visual so those are the two main
04:49 - ways you can do something like this in
04:50 - terms of visual for achieving this this
04:52 - is any kind of Shader you want for the
04:54 - postprocessing the black and white so
04:56 - this is just the basic volume system you
04:58 - can just desaturate the entire scene and
05:00 - you would probably add some
05:01 - postprocessing so on these individual
05:03 - objects once in this mode then render
05:05 - them in a different way for example
05:06 - something similar that I did in my own
05:08 - game dinky Gardians all of the objects
05:10 - have a specific Shader and when the
05:11 - player is close enough to them to be
05:13 - able to interact that it simply changes
05:15 - the outline from black to white in order
05:16 - to show this is the active object in
05:18 - terms of the visuals for the
05:19 - post-processing changing from the
05:20 - desaturated into the regular world and
05:22 - so on for that you can simply have two
05:24 - volumes so you can use just the volume
05:26 - system to modify the post processing you
05:28 - can see how to do something like that
05:29 - like in the video where I remade the
05:30 - mechanics from Verdon including the gas
05:32 - system another mechanic related to that
05:34 - one is the Eagle Eye so this is where
05:36 - the player can pretty much just spawn an
05:38 - eagle and the eagle flies and then the
05:40 - eagle can just look around and identify
05:42 - other objects so I can move the cursor
05:44 - in order to tag a bunch of enemies so I
05:46 - can tag that one and that one and so on
05:48 - it can also find some special chests
05:50 - some special objects and so on so once
05:52 - again implementing something like this
05:54 - actually rather simple first you need to
05:56 - be able to tell where exactly the eagle
05:57 - is looking at so as I move the cursor
05:59 - where exactly is the cursor over in the
06:01 - 3D world that is pretty much exactly
06:03 - like I covered in the mouse position in
06:04 - 3D video basically just do a recast from
06:07 - the camera position down to the terrain
06:08 - and figure out where it hits on that
06:10 - position so one way would be to do just
06:12 - do a r cast in order to find the mouse
06:13 - position over there on the floor on top
06:15 - of the castle then in there simply do a
06:17 - sphere cast around that position to
06:19 - figure out if there's anything
06:20 - interactable within that area and over
06:22 - there then yep it would find this enemy
06:24 - and it would simply tag it now for
06:26 - identifying objects the best way is to
06:27 - use an interface that way you can can
06:29 - identify both enemies as well as chest
06:31 - and any other kind of object interfaces
06:33 - are insanely useful and I highly
06:34 - recommend you to learn about them if you
06:36 - don't know them they are so useful in so
06:38 - many scenarios for example I use
06:40 - interface in my own game tons of times
06:42 - all over the place I think pretty much
06:43 - every single object in my game things
06:45 - like the dinky the player all the
06:47 - various buildings machines and so on I
06:49 - think pretty much all of them implements
06:50 - at least one interface basically with an
06:52 - interface you can write code against
06:53 - that interface and then the interface
06:55 - won't allow you to identify any kind of
06:56 - object so it can be a chest it can be an
06:58 - enemy it it can be a special object or
07:00 - anything like that so related to that
07:02 - it's the mechanic about tagging so you
07:04 - can basically tag objects and then I can
07:06 - exit the eagle mode and the objects are
07:07 - still visible so I can still see all the
07:09 - enemies and importantly I can see them
07:11 - actually through the walls again for
07:13 - this one several ways you can do this in
07:15 - terms of the actual UI elements in the
07:16 - world if you want to do that place UI
07:18 - elements in the world then you can make
07:20 - a world space canvas with this you can
07:22 - place UI elements things like texting
07:24 - like images you can place them directly
07:25 - inside the world although they will be
07:27 - hidden by occlusion which over here is
07:29 - not what we want if we want to see them
07:30 - through the walls so to solve that one
07:33 - option would be simply to use that
07:34 - method and then render them with a
07:36 - special material with a special Shader
07:37 - that doesn't actually write the depth so
07:39 - it is always visible alternatively
07:41 - another method is to use a stackable
07:42 - camera so you can make one camera and
07:44 - that camera is standard then you can
07:45 - make another camera and Define that one
07:47 - as an overlay camera and make sure the
07:49 - settings are exactly perfect then you go
07:51 - on to the first camera and you set the
07:52 - second camera as a stackable camera then
07:54 - as long as you make the second camera
07:56 - only render these UI elements that means
07:58 - those UI elements will always live on
07:59 - top of the main World on top of the main
08:01 - camera or of course alternatively you
08:03 - can simply convert all these objects
08:05 - convert them between World position into
08:06 - UI position then simply move some
08:08 - regular UI objects another unique
08:10 - mechanic about these games is the
08:12 - unveiling of the map so basally you
08:14 - climb to the top of these various towers
08:15 - and as you do it unlocks more of the map
08:18 - now for implementing something like this
08:19 - you basically just have two versions of
08:20 - your map you've got one where everything
08:22 - is locked and one where everything is
08:24 - unlocked so you've got two separate
08:26 - textures and then with those two
08:27 - textures you can basically use a
08:29 - separate mask in order to mix both of
08:30 - them in order to figure out which one
08:32 - should show the loock part and which one
08:33 - should show the unlocked part I covered
08:35 - how to do a mask like that in the Rover
08:37 - mechanic simulator cleaning video so in
08:39 - order to build this mechanic you would
08:40 - do the exact same thing when the player
08:42 - gets to the top of the tower and
08:43 - synchronizes it then you basically
08:45 - update the mass texture for that one
08:47 - specific Tower so basically each Tower
08:48 - is going to have a related Mass texture
08:50 - probably through a scriptable object or
08:52 - something like that and in terms of
08:53 - visuals for animating it you could do it
08:55 - through a simple Shader effect could be
08:57 - EXA like I covered in the Hades
08:58 - transition effect video you basically
09:00 - just find a gray scale texture and then
09:02 - basically animate how that one shows the
09:04 - underlying texture and then of course
09:06 - it's the icons themselves so for this
09:08 - you would probably just have the icons
09:09 - plac in the map by default then these
09:12 - icons would simply have a simple script
09:14 - and in that script they would have a
09:15 - reference to a specific Tower then
09:17 - whenever the player unveils whenever it
09:19 - synchronized a brand new tower that
09:21 - action would fire off an event then the
09:23 - icons over here on the map they would
09:24 - listen to that event when that happens
09:26 - they would check the tower that they are
09:28 - linked to again prob with a scripal
09:30 - object check the tower and if that Tower
09:32 - was one that was synchronized then make
09:34 - the icon visible if not just hide it
09:36 - then for something simple like the
09:37 - assassination so this is just a basic
09:38 - interaction system so I approach and if
09:41 - I can interact and I'm closing enough
09:42 - then I can simply do a special animation
09:44 - special interaction there you go pretty
09:45 - simple it works for assassinating
09:47 - enemies and also for interacting with
09:49 - all kinds of objects in the world this
09:50 - is just a basic interaction system kind
09:52 - of like I covered in the how to talk
09:53 - with NPC's video all the various
09:55 - interactable objects they have some sort
09:57 - of collor just so they work with the
09:59 - physics query so this would have a
10:01 - collider this would have a collider and
10:02 - so on then again as usual the same thing
10:04 - so the player does a overlap sphere to
10:06 - find all the interactable objects around
10:08 - all of these objects would Implement
10:09 - some kind of interactable interface then
10:11 - checks which one is the closest in order
10:12 - to show which button to input and when
10:14 - the player Triggs the action then just
10:16 - triggers an interaction with that one
10:17 - object with a system like this you can
10:19 - easily create things like assassinations
10:21 - you can set the blend in interact with
10:23 - objects steal things loot things and so
10:25 - on next up is the stealth a ey so
10:27 - basically the enemies have States they
10:30 - can be idle where they are really just
10:32 - patrolling around then if they spot you
10:34 - doing something bad they will't go
10:35 - towards the player and investigate if
10:37 - they see the player doing something bad
10:38 - for long enough then they go into attack
10:40 - mode in that mode they simply chase the
10:42 - player and attack but then if the player
10:44 - runs and breaks line of sight if so then
10:46 - the guards will investigate the less
10:47 - known player position after some time if
10:49 - they don't find the player then they
10:50 - simply go back into the idle state so
10:53 - all this is really just a super basic
10:54 - state machine this is actually a topic
10:56 - that I've wanted to cover for quite some
10:58 - time it's it's yet another mechanic that
11:00 - looks quite complex but in reality it's
11:01 - actually quite simple I covered a super
11:03 - basic sa machine in a video a very long
11:05 - time ago basically the one this game is
11:07 - using the exact same concept just a bit
11:09 - more complex for seeing if the player is
11:11 - visible by the enemy you can just do a
11:13 - simple Ray cast from the enemy position
11:14 - towards the player or more accurately
11:16 - you can actually use a sphar cast
11:17 - because you never want the accuracy to
11:19 - be depended on pixel on perfect bases so
11:21 - you always want to allow for a little
11:23 - bit something more forgiving but at the
11:24 - same time doing a sphere cast that only
11:26 - tests for direct distance whereas you
11:28 - obviously don't want to detect the
11:29 - player if the player is behind the enemy
11:31 - so to solve that you can also
11:32 - incorporate a vector 3 dot to check the
11:35 - angle I did something like that in the
11:37 - backstab mechanic video where I made
11:38 - sure to make a special attack that only
11:40 - works on a backstab meaning it only
11:42 - works if the player is behind the enemy
11:45 - so if there's no obstruction and the
11:46 - player is in front of the enemy then you
11:47 - increase an alert timer if long enough
11:49 - then just go into the investigate mode
11:51 - and then for losing interact the player
11:52 - that is really pretty much the same
11:54 - thing you would do the same sphere cast
11:55 - to find out if the player is visible and
11:58 - if the player stops being visible then
11:59 - you basically just tracked that position
12:01 - so the last down position where the
12:02 - player was visible and then you simply
12:04 - tell the AI to move to that point and
12:06 - then from there really just move to
12:07 - random points between that area if
12:09 - enough time passes and it still doesn't
12:10 - find the player then simply go back into
12:12 - the at State one more related thing is
12:14 - simply enemies attracting other enemies
12:16 - so for example if this enemy finds
12:17 - something then it would do some kind of
12:19 - sphere cast around its position and
12:21 - simply find all of the other enemies and
12:22 - simply tell them to attack on the same
12:24 - position so you have the stealth enemy
12:26 - eye it's another one of those things
12:27 - that looks pretty complex but in real is
12:29 - actually quite simple like I said this
12:30 - is something that I would like to cover
12:32 - in a dedicated tutorial doing some
12:33 - stealth n Mii so hopefully sometime soon
12:35 - I will have a dedicated video on exactly
12:37 - doing that now for some rapid fire quick
12:39 - ones for viewing the enemies and the
12:41 - objects through the walls for doing that
12:43 - you can use the render objects feature I
12:45 - cover that in detail in one of the many
12:47 - lectures in my ultimate un overview
12:48 - course then for the talking system where
12:50 - the camera is placed dynamically behind
12:52 - the player looking at the Target this is
12:54 - pretty much exactly what I built in my
12:55 - turn-based strategy course the camera is
12:57 - placed dynamically on the shoulder of
12:59 - the shooting enemy whilst pointing
13:00 - towards the target enemy so this really
13:02 - just involves some simple Vector MTH to
13:03 - calulate the point right behind the
13:05 - player shoulder and to the side then for
13:07 - the virtual cursor the game is fully
13:08 - playable with the game pad and whilst on
13:10 - the menu the GamePad uses this really
13:12 - nice virtual cursor that identifies all
13:14 - the objects I actually covered this in
13:15 - detail in a very recent tutorial it is
13:18 - super easy to build when you use the
13:19 - input system and I use the exact same
13:21 - thing in my own steam game dinky
13:22 - Guardians personally I find this sort of
13:24 - thing much better much more intuitive
13:25 - for navigating regular menus as opposed
13:28 - to the old School navigation system
13:30 - which really just moves from button to
13:31 - button personally I really prefer the
13:33 - mouse cursor virtual cursor system but
13:35 - when you're using a mouse inside of a
13:36 - gamad the cursor goes into this custom
13:38 - Hardware cursor this is another thing
13:40 - that is pretty subtle but makes your
13:41 - game look quite a bit more nice so it's
13:43 - say nice little bit of Polish I made a
13:45 - tutorial on this and I even made a
13:46 - full-on asset on how to make this super
13:48 - easy including how to support animated
13:50 - cursors then on the menu for checking
13:52 - out all the skills each one of those
13:53 - skills has a nice accompanying video
13:55 - showing what it actually does and how it
13:56 - actually exists this is another great
13:58 - thing especially in terms of tutorials
14:00 - as the say go show don't tell for
14:03 - implementing this you can easily build
14:04 - it using Unity video player it's a
14:06 - simple component where you can play some
14:08 - kind of video and then render it onto a
14:09 - texture onto a material or so on then
14:11 - during loading there are some hints you
14:13 - can cycle through them and this is
14:14 - really just some text so for storing
14:16 - these hints you can sort them in a
14:17 - simple script B object and in the script
14:19 - B object itself instead of storing just
14:21 - a simple string you can store a
14:23 - localized string so you can use unity's
14:24 - localization system so you can use
14:26 - unity's localization package in order to
14:28 - make all these strings easily localized
14:30 - same thing for the codec and database so
14:32 - storing all of these things all this
14:34 - text all these images and so on all
14:36 - these topics this is something you can
14:37 - store pretty easily in a ton of script
14:39 - objects that is pretty much exact same
14:41 - thing I did in my own game for making
14:42 - the knowledge base okay so that's a high
14:45 - level overview on how to make a game
14:46 - just like Assassin's Creed Mirage like I
14:48 - said this is a new format that I'm
14:49 - trying out basically doing a high level
14:51 - overview of various games and genres
14:53 - I've already covered lots of separate
14:54 - tutorials on lots of things and if you
14:56 - put them all together you can build all
14:57 - kinds of games I really don't have time
14:59 - to make 20-hour courses on every single
15:01 - game every single genre imaginable but I
15:03 - think hopefully this format can help at
15:05 - least point you in the right direction
15:06 - so do let me know in the comments if you
15:08 - find this format useful like the video
15:09 - and subscribe if you do all right so
15:11 - thanks for watching and I'll see you
15:13 - next time

Cleaned transcript:

hello and welcome I'm your codm so here let's see a highle overview of how to build a game just like Assassin's Creed Mirage I'm going to cover all these mechanics and how I would go about building them I made a page on the website with links to all the tutorials that I'm going to reference it's Link in the description basically this is a new format that I'm trying out going through a game or a specific genre and doing a high level overview of the various mechanics and referencing the various tutorials where I've covered them in detail hopefully if you're trying to build something similar to any of these mechanics then this can be quite useful I simply don't have the time to make super detailed stepbystep course on every single game every single genre imaginable but I think this quick format can be useful to help point you in the right direction as with everything that I do this is just an experiment so do let me know in the comments if you find this format useful like the video and subscribe if you do okay so here let's see a nice high level overview of how to build a game like Assassin Creed Mirage I play the game and I analyze it so here are the mechanics that I'm going to cover personally I always really enjoy these Assassin's Creed games I love historical medieval stuff and I love open worlds with lots of stuff to do traversing that open world is one of the crucial things so speaking of that the main thing you probably think of when you think of Assassin's Creed is the parkour system basically how you can just look at a wall then simply run towards it and the character jumps and grabs onto every hole point and everything looks great and climbs all the way up to the top now this is one of those mechanics where if you're a beginner this might seem impossibly complex but in reality building something like this is actually relatively simple or rather I should say the difficulty in building a mechanic like this is not necessarily in terms of logic complexity the difficulty is simply in the massive amount of work required to build all of the unique animations set up all the home points on every single wall in the entire game doing all of that for a large world is obviously a ton of work a ton of animations a ton of EDG cases a ton of stuff so it is very laborious but in terms of logic it's actually quite simple basically you need to Define what exactly is a home point and then as the player moves pretty much just need to figure out which one is the closest Home point that matches the player's input so for example over here in this scenario this one is marked as a hold point this little right here this is also a hold point this is a home point this one as well as is that one as is up there and so on so all of these are individual hold points that again were marked either manually or automatically through some algorithm in terms of the logic itself they can simply be just letters with a basic script on top maybe that script could then have a reference to a scriptable object that defines all the data on that specific hold Point like saying that this one over here this one is a wire whereas this one is just a little thing coming out then the logic in the player itself the player would simply do a physics query around the player position so right around here it would do some kind of Circle to identify all the hold points near the player position it also takes the player's inputs into account so if the player is going this direction then it's not going to check for physics collisions all all the way over here so it checks for nearby Home points through some kind of physics square like an overlap sphere then it simply finds a closest one although there can be multiple closest ones so over here all of these ones all of these are pretty much around the same position so as I'm going to move and jump he's going to grab pretty much any of these then the system decides to pick which specific animation matches this one so so which specific animation goes from the player being over here on the floor to picking up some bar in here or this one here so in the game itself if I just move forward and I jump and there you go he grabbed straight onto that one I can move down I can go onto this whole point I can go up to that one side to that one and so on and of course one climbing the controls become vertical so the control Vector instead of being down on the XZ plane instead of that now it is up here on the XY so move up or move to the side and for these animations they've got tons of animations but they also have quite a bit of dynamic to them so as you can see it always grabs on the exact same position now they don't have a million animations they've got a couple hundred maybe even a thousand but they definitely don't have millions of animations so to handle Dynamic animations basically how do you handle Dynamic Logic on top of static animations for that you use inverse kinematics Unity actually has a builtin tool to do inverse schematics it is called animation rigging I made a tutorial on it it is super useful super awesome for making your animations a lot more Dynamic another crucial mechanic in these games is Eagle Vision I think the original Assassin's Creed was actually one of the first games to pop poize this mechanic and afterwards the Batman Arkham games and Witcher 3 all of them Implement it's a really interesting thing basically you press a button and the world goes into this special Vision mode where it highlights individual enemies some helper Allied units and a bunch of items so to build something like this basally there are two ways to do it once again you can do a simple physics query around the player then you can locate all the various objects that Implement some kind of interface related to Eagle Vision and then you can basically T those objects in order to highlight themselves so that they would change the material to change the Shader to be more visible and so on or alternatively you can just have the player just the player fire off some event when they enable Eagle Vision and then all of the individual objects all of them have a certain script on them and then that script listens to that event so when the player enables this mode and checks the distance towards the player and if close enough then enables that visual so those are the two main ways you can do something like this in terms of visual for achieving this this is any kind of Shader you want for the postprocessing the black and white so this is just the basic volume system you can just desaturate the entire scene and you would probably add some postprocessing so on these individual objects once in this mode then render them in a different way for example something similar that I did in my own game dinky Gardians all of the objects have a specific Shader and when the player is close enough to them to be able to interact that it simply changes the outline from black to white in order to show this is the active object in terms of the visuals for the postprocessing changing from the desaturated into the regular world and so on for that you can simply have two volumes so you can use just the volume system to modify the post processing you can see how to do something like that like in the video where I remade the mechanics from Verdon including the gas system another mechanic related to that one is the Eagle Eye so this is where the player can pretty much just spawn an eagle and the eagle flies and then the eagle can just look around and identify other objects so I can move the cursor in order to tag a bunch of enemies so I can tag that one and that one and so on it can also find some special chests some special objects and so on so once again implementing something like this actually rather simple first you need to be able to tell where exactly the eagle is looking at so as I move the cursor where exactly is the cursor over in the 3D world that is pretty much exactly like I covered in the mouse position in 3D video basically just do a recast from the camera position down to the terrain and figure out where it hits on that position so one way would be to do just do a r cast in order to find the mouse position over there on the floor on top of the castle then in there simply do a sphere cast around that position to figure out if there's anything interactable within that area and over there then yep it would find this enemy and it would simply tag it now for identifying objects the best way is to use an interface that way you can can identify both enemies as well as chest and any other kind of object interfaces are insanely useful and I highly recommend you to learn about them if you don't know them they are so useful in so many scenarios for example I use interface in my own game tons of times all over the place I think pretty much every single object in my game things like the dinky the player all the various buildings machines and so on I think pretty much all of them implements at least one interface basically with an interface you can write code against that interface and then the interface won't allow you to identify any kind of object so it can be a chest it can be an enemy it it can be a special object or anything like that so related to that it's the mechanic about tagging so you can basically tag objects and then I can exit the eagle mode and the objects are still visible so I can still see all the enemies and importantly I can see them actually through the walls again for this one several ways you can do this in terms of the actual UI elements in the world if you want to do that place UI elements in the world then you can make a world space canvas with this you can place UI elements things like texting like images you can place them directly inside the world although they will be hidden by occlusion which over here is not what we want if we want to see them through the walls so to solve that one option would be simply to use that method and then render them with a special material with a special Shader that doesn't actually write the depth so it is always visible alternatively another method is to use a stackable camera so you can make one camera and that camera is standard then you can make another camera and Define that one as an overlay camera and make sure the settings are exactly perfect then you go on to the first camera and you set the second camera as a stackable camera then as long as you make the second camera only render these UI elements that means those UI elements will always live on top of the main World on top of the main camera or of course alternatively you can simply convert all these objects convert them between World position into UI position then simply move some regular UI objects another unique mechanic about these games is the unveiling of the map so basally you climb to the top of these various towers and as you do it unlocks more of the map now for implementing something like this you basically just have two versions of your map you've got one where everything is locked and one where everything is unlocked so you've got two separate textures and then with those two textures you can basically use a separate mask in order to mix both of them in order to figure out which one should show the loock part and which one should show the unlocked part I covered how to do a mask like that in the Rover mechanic simulator cleaning video so in order to build this mechanic you would do the exact same thing when the player gets to the top of the tower and synchronizes it then you basically update the mass texture for that one specific Tower so basically each Tower is going to have a related Mass texture probably through a scriptable object or something like that and in terms of visuals for animating it you could do it through a simple Shader effect could be EXA like I covered in the Hades transition effect video you basically just find a gray scale texture and then basically animate how that one shows the underlying texture and then of course it's the icons themselves so for this you would probably just have the icons plac in the map by default then these icons would simply have a simple script and in that script they would have a reference to a specific Tower then whenever the player unveils whenever it synchronized a brand new tower that action would fire off an event then the icons over here on the map they would listen to that event when that happens they would check the tower that they are linked to again prob with a scripal object check the tower and if that Tower was one that was synchronized then make the icon visible if not just hide it then for something simple like the assassination so this is just a basic interaction system so I approach and if I can interact and I'm closing enough then I can simply do a special animation special interaction there you go pretty simple it works for assassinating enemies and also for interacting with all kinds of objects in the world this is just a basic interaction system kind of like I covered in the how to talk with NPC's video all the various interactable objects they have some sort of collor just so they work with the physics query so this would have a collider this would have a collider and so on then again as usual the same thing so the player does a overlap sphere to find all the interactable objects around all of these objects would Implement some kind of interactable interface then checks which one is the closest in order to show which button to input and when the player Triggs the action then just triggers an interaction with that one object with a system like this you can easily create things like assassinations you can set the blend in interact with objects steal things loot things and so on next up is the stealth a ey so basically the enemies have States they can be idle where they are really just patrolling around then if they spot you doing something bad they will't go towards the player and investigate if they see the player doing something bad for long enough then they go into attack mode in that mode they simply chase the player and attack but then if the player runs and breaks line of sight if so then the guards will investigate the less known player position after some time if they don't find the player then they simply go back into the idle state so all this is really just a super basic state machine this is actually a topic that I've wanted to cover for quite some time it's it's yet another mechanic that looks quite complex but in reality it's actually quite simple I covered a super basic sa machine in a video a very long time ago basically the one this game is using the exact same concept just a bit more complex for seeing if the player is visible by the enemy you can just do a simple Ray cast from the enemy position towards the player or more accurately you can actually use a sphar cast because you never want the accuracy to be depended on pixel on perfect bases so you always want to allow for a little bit something more forgiving but at the same time doing a sphere cast that only tests for direct distance whereas you obviously don't want to detect the player if the player is behind the enemy so to solve that you can also incorporate a vector 3 dot to check the angle I did something like that in the backstab mechanic video where I made sure to make a special attack that only works on a backstab meaning it only works if the player is behind the enemy so if there's no obstruction and the player is in front of the enemy then you increase an alert timer if long enough then just go into the investigate mode and then for losing interact the player that is really pretty much the same thing you would do the same sphere cast to find out if the player is visible and if the player stops being visible then you basically just tracked that position so the last down position where the player was visible and then you simply tell the AI to move to that point and then from there really just move to random points between that area if enough time passes and it still doesn't find the player then simply go back into the at State one more related thing is simply enemies attracting other enemies so for example if this enemy finds something then it would do some kind of sphere cast around its position and simply find all of the other enemies and simply tell them to attack on the same position so you have the stealth enemy eye it's another one of those things that looks pretty complex but in real is actually quite simple like I said this is something that I would like to cover in a dedicated tutorial doing some stealth n Mii so hopefully sometime soon I will have a dedicated video on exactly doing that now for some rapid fire quick ones for viewing the enemies and the objects through the walls for doing that you can use the render objects feature I cover that in detail in one of the many lectures in my ultimate un overview course then for the talking system where the camera is placed dynamically behind the player looking at the Target this is pretty much exactly what I built in my turnbased strategy course the camera is placed dynamically on the shoulder of the shooting enemy whilst pointing towards the target enemy so this really just involves some simple Vector MTH to calulate the point right behind the player shoulder and to the side then for the virtual cursor the game is fully playable with the game pad and whilst on the menu the GamePad uses this really nice virtual cursor that identifies all the objects I actually covered this in detail in a very recent tutorial it is super easy to build when you use the input system and I use the exact same thing in my own steam game dinky Guardians personally I find this sort of thing much better much more intuitive for navigating regular menus as opposed to the old School navigation system which really just moves from button to button personally I really prefer the mouse cursor virtual cursor system but when you're using a mouse inside of a gamad the cursor goes into this custom Hardware cursor this is another thing that is pretty subtle but makes your game look quite a bit more nice so it's say nice little bit of Polish I made a tutorial on this and I even made a fullon asset on how to make this super easy including how to support animated cursors then on the menu for checking out all the skills each one of those skills has a nice accompanying video showing what it actually does and how it actually exists this is another great thing especially in terms of tutorials as the say go show don't tell for implementing this you can easily build it using Unity video player it's a simple component where you can play some kind of video and then render it onto a texture onto a material or so on then during loading there are some hints you can cycle through them and this is really just some text so for storing these hints you can sort them in a simple script B object and in the script B object itself instead of storing just a simple string you can store a localized string so you can use unity's localization system so you can use unity's localization package in order to make all these strings easily localized same thing for the codec and database so storing all of these things all this text all these images and so on all these topics this is something you can store pretty easily in a ton of script objects that is pretty much exact same thing I did in my own game for making the knowledge base okay so that's a high level overview on how to make a game just like Assassin's Creed Mirage like I said this is a new format that I'm trying out basically doing a high level overview of various games and genres I've already covered lots of separate tutorials on lots of things and if you put them all together you can build all kinds of games I really don't have time to make 20hour courses on every single game every single genre imaginable but I think hopefully this format can help at least point you in the right direction so do let me know in the comments if you find this format useful like the video and subscribe if you do all right so thanks for watching and I'll see you next time
