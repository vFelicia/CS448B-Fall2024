With timestamps:

00:00 - hello and welcome i'm your code monkey
00:02 - and here let's build a really nice
00:03 - feature complete camera system we want
00:05 - the ability to move rotate zoom in and
00:08 - out enable edge scrolling and touch drag
00:10 - to pan the camera this is a great and
00:12 - very capable system for just about any
00:14 - game where you want the player to have
00:16 - direct control over the camera you can
00:17 - follow this tutorial and download the
00:19 - final project files we're going to build
00:21 - it in a 3d scene but in the end i'll
00:22 - also quickly show a conversion to make
00:24 - it work in 2d
00:25 - now this video ended up pretty long but
00:27 - it's the only video you need to make a
00:29 - fully complete camera system so if this
00:31 - is something that you need make sure you
00:32 - watch the full video to the end if you
00:34 - prefer a more guided path with step by
00:36 - step lectures then check out my complete
00:38 - courses learn how to make a builder
00:40 - defender game using c-sharp or learn how
00:42 - to make games internally using visual
00:43 - scripting perhaps if you're past the
00:45 - beginner stage and want to make the jump
00:47 - to advanced then check out my turn based
00:48 - strategy course to learn how to manage a
00:50 - more complex project and write some good
00:52 - clean code or learn all about unity with
00:55 - the ultimate unity overview course which
00:57 - contains over 15 lectures each covering
00:59 - a different tool feature of the engine
01:00 - i'm always available in the q and a
01:02 - section answering your questions every
01:03 - single day so check them all out with
01:05 - the link in the description all right so
01:07 - let's build our camera system now of
01:09 - course to do it we are going to be using
01:10 - syn machine if you have never used it i
01:13 - covered it in detail in another video
01:15 - basically syn machine is an excellent
01:16 - unity built-in tool that makes
01:18 - everything related to cameras so much
01:20 - easier we're going to see how we can
01:22 - build a basic camera in just a few
01:23 - seconds as opposed to minutes or hours
01:26 - if we built it all ourselves and for the
01:28 - demo scene that i'm using here this one
01:29 - is from the recently released cynthia
01:31 - ancient empire's pack
01:33 - it's a gorgeous pack with a really
01:34 - awesome roman or greek theme there's a
01:36 - link in the description if you want to
01:38 - get it for yourself all right so let's
01:39 - do it first of all let's create a brand
01:42 - new virtual camera so let's go up into
01:44 - game object then down here find
01:46 - cinemachine and then let's create a
01:47 - standard virtual camera let's rename
01:49 - this the scene machine virtual camera
01:52 - and that's it okay so with this here we
01:54 - already have a nice virtual camera
01:56 - and the way that this system is going to
01:58 - work is we are not going to directly
02:00 - move this object so the virtual camera
02:02 - we're not going to directly move this
02:04 - instead we're going to move another
02:05 - object and then set this virtual camera
02:07 - to follow and look at that object so
02:09 - let's do that let's right click on the
02:10 - hierarchy let's create an empty game
02:12 - object quality camera system let's reset
02:15 - transform to zero zero let's go into the
02:17 - virtual camera and just drag the
02:19 - reference as the follow so if we see on
02:21 - the camera it is currently positioned
02:23 - exactly on top of that object which is
02:24 - on zero zero then let's also add the
02:27 - same object reference as the lookout
02:29 - and now with this actually the camera is
02:30 - already working to test that out let's
02:32 - hit on play
02:34 - so here the game is running and the
02:35 - camera is already working let's just
02:37 - play around with the fields here
02:39 - the goal is for this object the camera
02:40 - system so the target object for that one
02:42 - to be right on the floor and the camera
02:44 - is above it looking down so for that on
02:46 - the virtual camera let's expand the body
02:48 - and over here we've got the phone offset
02:50 - by default it's at 0 0 -10 so we can
02:52 - actually look in the scene view to see
02:53 - what the default looks like
02:55 - so yep there's the object right there
02:57 - the target object and virtual camera is
02:58 - 10 units in the z behind it like i said
03:01 - we want an overhead camera
03:03 - so on the virtual camera let's increase
03:04 - the fall offset by quite a bit let's
03:06 - lift it up on the y so put it something
03:08 - like this
03:09 - then on the z also push it quite a bit
03:11 - more back so a bit lower bit higher
03:14 - something like this
03:15 - okay so just with these basic settings
03:17 - you can already see it working here with
03:19 - the game viewing scene view side by side
03:20 - we can already see the object and if i
03:22 - manually move it yep there you go you
03:23 - can see the camera perfectly follows so
03:25 - this is how we're going to do we're
03:26 - going to move this object and the camera
03:28 - will automatically look at it so let's
03:30 - make a script to do that but before we
03:32 - do before we exit play mode let's make
03:34 - sure to go into the virtual camera and
03:36 - over here make sure we take save during
03:37 - play so we don't lose all the changes
03:39 - that we did so far and also let's push
03:41 - this a bit back so a bit more of a front
03:43 - view okay like this all right so those
03:45 - are the settings that i want make sure
03:46 - save the ring play stick now if we exit
03:48 - play mode if there you go all the
03:50 - changes were saved let's just move the
03:52 - camera system game object moved by
03:54 - default something like this also rotate
03:56 - it we're going to see rotation a bit but
03:58 - just right now it already works all
03:59 - right okay so with this like i said
04:01 - let's make that script so let's right
04:03 - click on the project files create a new
04:04 - c sharp script called the camera system
04:08 - let's select the camera system game
04:09 - object and attach the script alright so
04:12 - here let's just do some basic input
04:14 - logic so let's do it by going into
04:16 - private void update now here let's just
04:18 - add some basic input logic
04:28 - all right so here it is so just testing
04:30 - for wasd
04:31 - now naturally you could easily replace
04:33 - this with new input system which i
04:35 - covered in detail in another video
04:37 - so with this we have a move direction
04:39 - also note how since we're working on a
04:40 - 3d game look at how i define a vector3
04:43 - and when pressing the w or the s key i'm
04:45 - modifying the z not the y
04:48 - that's because we're in 3d so when
04:49 - moving forward we want to go four not up
04:52 - so we have this move direction however
04:54 - here you need to be careful with how you
04:55 - actually move this object you might
04:57 - think that you could just add this move
04:59 - vector straight onto the transform
05:00 - position so just go transform.position
05:03 - plus equals the move direction
05:05 - multiply it by a certain move speed and
05:07 - by time dot all the time to make it
05:09 - frame rate independent so here you could
05:11 - define the move speed
05:13 - and put it at some value so you might
05:15 - think to do this but if we do and let's
05:17 - see what happens
05:18 - so here i am and if i press on w yep it
05:20 - does move forward press on s let's go
05:22 - back press on the go right press on a
05:24 - goes left okay so it does seem like it
05:26 - actually works however if i unmaximize
05:29 - this window now with the scene view side
05:31 - by side let's select the camera system
05:33 - game object and over here let's apply a
05:34 - rotation so let's put it maybe 90
05:37 - degrees so the camera is now rotated and
05:40 - right now if i do the same thing so
05:41 - let's see what happens when i press on w
05:43 - and there you go it moves to the left
05:44 - and now if i press on d yep now it moves
05:47 - forward now s a and so on so this is the
05:50 - issue with this code when i press w i
05:52 - want it to move forward but when i do
05:54 - now it's moving to the left that is
05:55 - because moving into the global forward
05:57 - which in this case with the camera
05:58 - rotation the global forward is still
06:00 - pointing in this direction so when i
06:01 - press on w it still goes there now
06:03 - obviously this is not correct this is
06:05 - not what we want
06:06 - we want to take the rotation of this
06:08 - object into account in order to decide
06:10 - how we should move so back in the code
06:12 - here how we solve this actually pretty
06:14 - simple instead of moving directly by the
06:16 - moved ear what we want to do is to use
06:18 - the super useful transform vectors
06:21 - so let's calculate the final move there
06:23 - so let's actually rename this one so for
06:25 - this one instead of moving let's rename
06:27 - it so the visual studio shortcut this
06:29 - ctrl r
06:30 - let's rename this to the input deer
06:32 - then we calculate the final move there
06:34 - and for this one like i said we're going
06:36 - to use the super useful transform
06:37 - vectors we're going to use transform dot
06:40 - forward so this is the forward vector
06:42 - for this transform so this takes
06:43 - rotation into account so we multiply
06:46 - this one by the input dear.zed
06:49 - and then we add the transform.right
06:51 - again this one is also affected by the
06:53 - rotation of this game object we take
06:55 - this one and we multiply it by the input
06:57 - there dot x
06:58 - so with that now we have the correct
07:00 - move direction based on the object's
07:01 - rotation
07:02 - so we now use this in our movement and
07:05 - if we test it like this
07:06 - here it is with the camera rotated on
07:08 - zero so if i press w s a and d yep sound
07:12 - works perfect now if i rotate the camera
07:14 - so again let's apply a 90 degree
07:16 - rotation now press on w and if there you
07:18 - go does move forward s d and a all right
07:21 - awesome all right so here everything is
07:23 - working correctly we can move in any way
07:25 - we want now at this point we should
07:27 - probably tweak some settings
07:29 - here notice how the camera is indeed
07:31 - moving as we want so move up down right
07:33 - left and so on but since we're also
07:35 - looking at the invisible target in front
07:37 - of here due to the smoothing that we
07:38 - have it creates a bit of an odd result
07:40 - so as i press on w you can see the
07:43 - camera kind of shifts a bit upwards and
07:45 - if i go to the right it kind of has a
07:47 - slight delay
07:48 - now perhaps this is what you want if so
07:50 - then don't bother with the tweaks that
07:52 - i'm going to mention but in most cases
07:54 - you want the camera to pin right away
07:56 - instead of going slightly behind the
07:57 - target thankfully like i said since
07:59 - we're using city machine this is super
08:01 - easy to do so much just like the same
08:03 - machine virtual camera
08:05 - let's expand over here the body and then
08:07 - we've got the x y and z damping if we
08:09 - set all of these back down to zero yep
08:11 - there you go now the camera does move
08:13 - much more snappy
08:15 - again like i said this is personal
08:16 - preference and it kind of depends on
08:17 - what type of game you're trying to make
08:19 - but generally i prefer like this i
08:21 - perform my camera to be much snappier
08:23 - okay so with this the movement is
08:24 - working next up let's in on rotation for
08:27 - this one is also going to be super
08:28 - simple we already saw how we're going to
08:30 - do this since we defined the camera over
08:32 - here with the phone offset with a
08:34 - negative on the z that means the camera
08:36 - is always behind the target object so
08:38 - there's the camera and the target object
08:39 - is down there since the camera is
08:41 - already behind all we need to do is
08:43 - rotate this object so over here on the y
08:45 - rotation all we need to do is play
08:46 - around this and we can easily rotate the
08:48 - camera so here in the code it's super
08:50 - simple again let's do some input
09:00 - so again just using some basic input on
09:02 - q and e in order to rotate so we get the
09:04 - rotate direction
09:06 - then in order to rotate the object we
09:07 - can just modify this transform dot euler
09:10 - angles and let's add it based on new
09:12 - vector3
09:13 - for our 3d camera we only want to rotate
09:16 - around the y axis
09:17 - you can verify what rotation you want if
09:19 - you look over here in scene view
09:21 - so if i rotate around the y yep you can
09:23 - notice that it rotates exactly as we
09:25 - want whereas on the x it does this kind
09:27 - of rotation that's not what we want and
09:29 - the z does this kind of rotation also
09:30 - now what we want so what we want is
09:32 - rotate on the y so over here create new
09:34 - vector 3 0 on the x 0 on the z and let's
09:38 - just put over here on the y and for the
09:40 - y let's use rotate direction multiplied
09:43 - by a certain rotate speed
09:47 - and finally just multiply by time dot
09:50 - delta time
09:51 - all right so that's it some extremely
09:53 - simple logic let's test all right so
09:55 - here we are now for press on e yep there
09:57 - you go rotates press on q and yep it
09:59 - does rotate all right so yep it does
10:01 - work
10:02 - now it's going a bit way too fast so
10:03 - let's actually reduce that and also if
10:05 - you want the opposite so if you want to
10:07 - press e and rotate in the other
10:08 - direction then over here just swap these
10:10 - make this one minus in this one pause
10:12 - but in our case it's working exactly as
10:13 - i wanted let's just lower the rotate
10:15 - speed a bit slower
10:16 - so here press on e any of those rotate
10:18 - press on q and does rotate
10:20 - okay great but we do see the same issue
10:23 - that we saw previously so as i rotate
10:25 - the camera is slightly lagging behind so
10:27 - that does not look very good so once
10:29 - again the solution is the same let's go
10:30 - into the virtual camera now let's expand
10:32 - the aim part and over here we've got the
10:34 - horizontal and vertical damping let's
10:36 - just put both these at zero and now the
10:38 - camera yep perfectly nice and snappy so
10:40 - by moving rotating off it works
10:42 - perfectly okay great now remember make
10:44 - sure you toggle save during play before
10:46 - you exit play mode and here it is the
10:48 - camera working really nice really
10:50 - perfect so we can now move anywhere we
10:52 - can rotate anywhere and everything works
10:54 - right all right so that's it next up
10:56 - let's handle edge scrolling this one is
10:58 - also pretty simple over here in our
11:00 - movement code we are testing for player
11:02 - input
11:03 - but we can also create an input
11:05 - direction based on the mouse position
11:07 - for that we have the input.mouseposition
11:10 - this gives us the mouse coordinates in
11:12 - pixel units so if we do a quick debug
11:15 - download and test this
11:17 - if there it is here in the log i can see
11:19 - and if we look in the stats we can see
11:20 - the size of this window
11:22 - so you can see that i've got this window
11:23 - set up as 1080p so that's because over
11:26 - here i've got full hd selecton and to
11:28 - check out what input.most position
11:30 - returns we can see that if i put the
11:31 - mouse over here on the lower left corner
11:33 - yep it returns pretty much zero zero and
11:36 - if i put over there on the top right
11:37 - corner it returns 1920 by 1080. so
11:40 - input.mouseposition gives me the screen
11:42 - pixel coordinates with this we can just
11:44 - do some basic math all we need is to get
11:46 - the total width of the screen get the
11:48 - total height then check if the mouse is
11:50 - within a certain distance from the left
11:52 - side so for example if it's under 10
11:54 - pixels of the left side then we move to
11:56 - the left if it's within 10 pixels at the
11:58 - right then we move to the right and so
11:59 - on okay so here in the code and let's do
12:01 - that let's first define just an edge
12:03 - strong size so an end edge scroll size
12:07 - maybe 20 units maybe 20 pixels maybe
12:09 - that's enough
12:10 - then we just use some simple logic
12:12 - so if the input.mouseposition.x
12:16 - if this one is under this amount under
12:18 - the edge scroll size then that means the
12:20 - mouse is on the left side
12:22 - if so then let's set the input here dot
12:24 - x to minus one f
12:26 - then we test for the mouse position dot
12:28 - y if it's under that one then we want to
12:30 - move down so that's e z minus one next
12:33 - up we want to test if what's on the
12:34 - right side so for that we're going to
12:36 - test the mouseposition.x
12:39 - and we're going to test if it's past the
12:41 - screen dot width this is how we get the
12:44 - screen width so then when we subtract
12:46 - the edge scroll size so if the mouse is
12:47 - to the right of this point then we want
12:49 - to move on the x by plus 0.1
12:52 - and finally the opposite so this one is
12:54 - on the y let's use the screen dot height
12:58 - and this one we move on the z on plus
13:00 - one
13:06 - all right so that's it really super
13:08 - simple let's test so here we are with
13:10 - the mouse in the middle of the screen
13:11 - now five approaching miles on the left
13:13 - side if there go pens left pins right
13:15 - pans forward and backwards all right
13:18 - awesome everything works now when it
13:20 - comes to edge scrolling some people like
13:22 - it and some people don't so usually you
13:24 - want to add it as an option rather than
13:25 - making it always enabled
13:27 - so for that we can just go up here make
13:29 - a private ball
13:31 - use edge scrolling you can default it to
13:35 - either true or false
13:36 - and if you want you can even make this a
13:38 - serialized film in order to make the
13:39 - default shown in the editor
13:41 - and then over here we just use this
13:43 - logic if this one is true so if use edge
13:46 - scrolling then we do all this and if not
13:48 - then we don't do any of this
13:50 - alright so that's it some super simple
13:52 - logic and obviously you would control
13:54 - this boolean based on the player's
13:55 - options all right now for the final
13:57 - movement method let's add a click and
14:00 - drag
14:01 - so i want to be able to for example
14:02 - place the mouse here use the right mouse
14:04 - button keep it hold down
14:06 - then i move the mouse in this direction
14:08 - and the camera moves in that direction
14:10 - so that's what we want to do okay so
14:12 - here in the code so let's begin by
14:13 - testing out our input like i said i want
14:15 - to use the right mouse button so input
14:17 - dot get mouse button
14:19 - test for the get mouse button down so we
14:21 - want to know when we press it so on the
14:23 - right mouse button so that's on one
14:25 - again of course you could swap this out
14:26 - for touch or any other input i'm just
14:28 - using the mouse just because it's nice
14:30 - and simple so when we do press the mouse
14:32 - let's set a certain volume to true
14:35 - so let's go up here and let's define a
14:37 - private ball call it drag pan move
14:40 - active
14:43 - okay and then down here when we press
14:45 - the mouse button let's set this to true
14:47 - and let's add another one for this one
14:49 - let's use get mouse button up so when we
14:51 - release then we set this back into false
14:54 - okay so we have this nice bully knowing
14:56 - when we should pan or not now with this
14:58 - we're only going to run the drag panel
15:00 - logic while this one is true so after
15:01 - this we do if if this logic is true then
15:04 - we're going to apply the drag pen move
15:06 - okay so in order to pan we need to know
15:08 - the less mouse position so we know how
15:10 - much it moved in the last frame so for
15:12 - that let's store it let's define a
15:14 - private vector 2 since the mouse only
15:16 - has a vector 2 for the last mouse
15:19 - position
15:21 - and then with this one let's go down
15:22 - here as soon as we press let's set it so
15:24 - this one equals input dot mouse position
15:28 - and then down here while it's active so
15:30 - while we still have the last mouse
15:32 - position with the last mouse position
15:34 - with this one we can calculate a vector
15:36 - 2 for the mouse movement delta so this
15:38 - is how much the mouse moves in the last
15:40 - frame
15:41 - so we just take the input dot mouse
15:43 - position exceptionally up here is the
15:46 - mouse position not the mouse on delta so
15:48 - we take this one and we subtract the
15:50 - last mouse position and here for some
15:52 - reason the mouse position actually is a
15:54 - vector 3 not a vector 2 so we can easily
15:57 - just cast this down into a vector 2
15:58 - before doing the math all right so with
16:00 - this we have the mouse movement delta so
16:02 - we handle all of that and then in the
16:04 - end after all the logic then we update
16:05 - it with new value now we can do a debug
16:07 - dialog to see what this shows so we
16:09 - understand how this logic is working
16:11 - so here's the log now if i right click
16:14 - and if i hold still it's zero zero now
16:16 - if i move the mouse right and up so move
16:18 - it yep there you go we've got plus and
16:19 - plus over there and if i right click and
16:21 - i go down and left there you go we've
16:23 - got negative values so this is the
16:25 - amount of pixels that the mouse moved
16:26 - since in last update
16:28 - so with this we can now use this delta
16:30 - in order to directly move the transform
16:32 - for that let's actually put all this
16:34 - logic above before we move the transform
16:37 - we're going to refactor all this code in
16:38 - a bit
16:39 - so we've got this now let's just convert
16:41 - the mouse movement delta into the same
16:43 - as the input direction
16:45 - so here we set the input there dot x
16:47 - equals the mouse movement delta dot x
16:49 - but then we modify the input dear dot z
16:52 - based on the mouse movement delta dot y
16:54 - because over here we're working with a
16:56 - vector 2 but with the input we're using
16:57 - the z okay so that's it except with this
16:59 - it's going to move way too slow
17:02 - so let's define a float for the drag pan
17:04 - speed
17:07 - then we just multiply it by the drag
17:09 - band speed
17:11 - okay so let's test so here we are the
17:13 - camera is static now if i right click
17:15 - and i move the mouse and if there you go
17:16 - it is painting there penning there there
17:18 - and there all right awesome
17:20 - so with this we are directly using the
17:22 - mouse in order to pan the camera
17:23 - anywhere we want we've got that filmed
17:26 - if we feel that this is way too
17:27 - sensitive but yep the logic is working
17:28 - perfectly all right awesome so we
17:30 - already have quite a lot of things
17:32 - working now before we move on to the
17:34 - zoom let's actually refactor our code
17:36 - like i said i want this video to serve
17:38 - as the ultimate camera controller so
17:40 - let's refactor all of this to make the
17:41 - code really nice and easy to read and
17:43 - also really easy to define which
17:45 - features you want to use
17:46 - like perhaps you don't want the drag pan
17:48 - or perhaps you don't want edge scrolling
17:49 - so let's do that so first of all let's
17:51 - make two functions one to handle the
17:53 - movement and want to handle the rotation
17:59 - so for the rotation that's just this
18:01 - code so just copy this and we call this
18:03 - on the update all right
18:05 - and for the movement let's first of all
18:06 - copy all of this so all this in there
18:09 - and on update we call handle camera
18:11 - movement
18:12 - okay so right now everything is done
18:14 - working exam the same as previously but
18:15 - like i said we want to refactor this in
18:17 - order to be able to use or not use edge
18:19 - scrolling same thing for the drag pan
18:21 - so let's actually make separate
18:22 - functions for each of these movement
18:24 - types
18:25 - so let's go down here make another
18:27 - function
18:28 - private void handle camera movement edge
18:30 - scrolling
18:32 - and let's make another one
18:35 - so another private void handle camera
18:37 - movement for this one called drag pan
18:41 - and all we do is just copy all this
18:43 - logic so the use edge scrolling let's
18:45 - copy on to this one
18:47 - and then for the other the drag pen
18:48 - let's copy all of this one
18:50 - and of course we this we need to use the
18:52 - input here since we're reusing it so
18:55 - let's define another input here here and
18:57 - also same thing for this one okay so
18:59 - that works now on these two functions we
19:01 - just need to apply the final movement so
19:03 - that's this logic right here so just
19:04 - copy it apply it to the end here
19:07 - and apply to the end here
19:09 - all right so everything's working no
19:10 - more errors now we can just add all the
19:12 - functions depending on all the features
19:14 - that we want for this
19:18 - and now we can easily either enable or
19:20 - disable these based on boeing so we've
19:21 - got to use edge rolling now for another
19:23 - one use drag pan
19:28 - then let's put the ifs on this one
19:31 - so test for the if in here instead of
19:33 - testing inside this function it's over
19:35 - here let's get rid of this one so that
19:36 - one always runs and then same thing
19:39 - another if on this one
19:44 - all right so that's it now it's super
19:45 - simple all we need to do is modify
19:47 - either these variables and the logic
19:48 - won't work exactly as you want it here
19:50 - is the camera system with all the
19:51 - features enabled so i've got edge
19:53 - scrolling if i go to the sides yep i've
19:55 - got the regular movement i've got the
19:56 - regular rotation and the regular pan
19:58 - movement all right awesome
20:00 - okay so with that the code is working
20:03 - all the logic works
20:04 - now the last thing that we need to
20:05 - handle is the zoom and for that there's
20:08 - actually two ways to zoom a camera
20:10 - one way is to bring the camera in closer
20:13 - so on the virtual camera one way to zoom
20:15 - is to get it closer on the z and also
20:17 - closer on the y so this applies certain
20:20 - zoom
20:21 - another alternative is to simply change
20:22 - the fov so as you lower the fov yep it
20:25 - looks like a zoom so both these
20:26 - approaches work as kind of a zoom
20:28 - they're different so it depends on which
20:29 - one you want let's see how both those
20:31 - work
20:32 - okay so over here let's keep writing
20:34 - some good clean code and call
20:36 - handle camera zoom
20:38 - so let's make this function so down here
20:41 - make a broad void and all the camera
20:43 - zoom all right
20:44 - now here the first thing that we need is
20:46 - some input and for zooming what makes
20:48 - most sense is the mouse chrome wheel so
20:50 - let's handle that we can easily access
20:52 - that with the input dot mouse scroll
20:54 - down
20:55 - now this one as you can see it's a
20:56 - vector 2 because apparently there are
20:58 - some mice that scroll on the x but
21:00 - chances are for a zoom you want to
21:01 - scroll on the y so you've got this one.y
21:04 - if we just do a debug.log on this to see
21:06 - what it does
21:07 - here if i scroll forward yep we do see
21:10 - the value change we do see a plus one
21:12 - and if i scroll the wheel backwards so
21:14 - back to me we do see some negative
21:15 - values okay so these are the values that
21:17 - we can use to run our zoom logic so over
21:20 - here let's try handling the field of
21:21 - view method first now this is actually
21:23 - the more complex part due to how sin
21:25 - machine actually works you might think
21:27 - that you can just access the virtual
21:29 - camera and search for a field of view
21:30 - field so first we need a reference to
21:32 - the virtual camera so let's make one
21:35 - let's make it a serialized field so we
21:36 - can set it in the editor
21:38 - for the syn machine virtual camera and
21:41 - for this we need to add using syn
21:42 - machine so we have this for the same
21:45 - machine virtual camera then here in the
21:47 - editor we can drag the virtual camera
21:49 - reference okay so now here like i said
21:51 - you might think to just go inside this
21:53 - object so let's go inside this one and
21:55 - search for some kind of field of view
21:57 - but nope there's no such thing search
21:59 - for fov nope does not exist looking at
22:01 - the inspector here we need to figure out
22:03 - how to modify this field and thankfully
22:06 - cinemachine has all the source code
22:07 - available so you can just right click on
22:09 - the component and click on edit script
22:11 - and when you do you should be able to
22:13 - see the entire source code for send
22:14 - machine and just in case that doesn't
22:16 - work automatically you can just find it
22:18 - manually so you can go into your project
22:21 - window and over here expand the packages
22:23 - now if this one doesn't work then on the
22:24 - project window on the top right corner
22:26 - there's this little icon with an i if
22:28 - this one is toggled then the packages
22:30 - don't show up but if you untoggle it
22:32 - then all of them show up and here you
22:33 - can find cinemachine then inside you can
22:36 - find runtime and then under behaviors
22:38 - over here you can find the same machine
22:40 - virtual camera so just go ahead and open
22:42 - this
22:43 - here like i said contains all the source
22:45 - code
22:46 - however over here if you search for
22:48 - field of view nope nothing shows up
22:50 - search for fov nope nothing shows up
22:53 - so to get another hint we can again look
22:55 - in the inspector and over here we see
22:56 - that the fov exists inside something
22:58 - called lens so then over here on the
23:00 - script if we search for a lens we do
23:02 - find exactly this an object of type 1
23:05 - settings called m underscore lens
23:07 - then we just need to go inside this lens
23:09 - settings so on the project window we can
23:11 - search for lens settings
23:14 - let's make sure to search in all and
23:15 - here we find the online settings so
23:17 - inside the send machine runtime core
23:19 - line settings and inside this script now
23:21 - if we scroll down yep here we do see the
23:23 - field of view so this method that we
23:25 - just did this is how you can figure out
23:26 - how to find any field in order to modify
23:28 - it through code there's an even more
23:30 - advanced version of this method where
23:32 - you can load all of the packages source
23:33 - code directly into visual studio doing
23:35 - that makes it super easy to find exactly
23:37 - where the field is that you want to
23:38 - change
23:40 - in my ultimate tnt overview course one
23:42 - of the lectures is exactly on this topic
23:44 - how to find any class or any field to
23:46 - modify any of the many tools and
23:48 - features that unity has another example
23:50 - of this is the post-processing effect so
23:52 - how do you modify these various films
23:53 - inside these various effects through
23:55 - code
23:56 - that's one of the things that you can do
23:57 - with this method or the other one that i
23:58 - covered in that lecture also that course
24:00 - teaches you how to use many of the tools
24:02 - and features that unt has so check it
24:04 - out to the link in the description okay
24:06 - so back to our demo here we already know
24:08 - how to get the field of view so now
24:09 - let's do that let's go into the camera
24:11 - system so we've got the send machine
24:12 - virtual camera inside we can access the
24:15 - lens and inside the lens access the
24:16 - field of view now with this we can
24:18 - change it whatever we want so first
24:20 - let's just test it out
24:22 - so let's set it to something like 10 and
24:24 - let's do it when we scroll so if the
24:25 - input dot mouse call delta if the y is
24:28 - bigger than zero so if we scroll upwards
24:31 - then we should be able to see the field
24:32 - of view change let's see
24:34 - so here we are regular zoom nice scroll
24:36 - in and there you go it does zoom in
24:38 - alright awesome okay so all we need now
24:41 - is some logic to use some proper values
24:43 - since the zoom is instant we also need
24:45 - to handle some smoothing logic so here
24:47 - in the code first we need to store a
24:49 - field for the target field of view
24:51 - so a private float
24:53 - call it target field of view
24:56 - we can defound it to sunlight 50.
24:58 - then when we handle the camera zoom when
25:01 - we scroll in the positive for this one
25:03 - let's increase so target field of view
25:04 - increase by a certain amount let's say
25:06 - by maybe five and if we have the
25:09 - opposite so if we scroll the wheel
25:10 - backwards
25:12 - so let's reduce it by five now here you
25:15 - don't need to use delta time because
25:16 - this value the muscle delta this one is
25:18 - based on how often you physically scroll
25:20 - the wheel it is not something that
25:22 - happens on every single frame so you
25:24 - don't need time to download time
25:26 - okay so with this we have our target
25:27 - field of view now with that let's add a
25:29 - clamp to keep it within valid values so
25:32 - target field of view let's do in
25:34 - mathf.clamp
25:35 - let's clamp between a certain minimum
25:37 - and maximum so clamp this value for the
25:40 - minimum and maximum
25:42 - we can define them up here perhaps as a
25:45 - serialized field
25:47 - let's make a float for the field of view
25:50 - max
25:51 - another one for the field of view min
25:54 - let's default the maximum to about 50
25:56 - and the minimum let's say 10.
26:00 - so then with these two down here we just
26:01 - use them so the first one is the min
26:04 - so the field of view min
26:06 - and the field of view max
26:10 - okay so we have the target field of view
26:11 - now just apply it so into the syn
26:13 - machine virtual camera access the lens
26:16 - and let's modify the film the view to
26:18 - the target field of view
26:19 - again right now it sound doesn't have
26:20 - any smoothing but let's just make sure
26:22 - this logic works so here we are and if i
26:24 - scroll backwards yep it zooms in and if
26:27 - i scroll forward yup it zooms out
26:29 - alright great
26:30 - except it actually has the opposite
26:32 - behavior that i want obviously this is
26:33 - personal preference but i find better
26:35 - that if i move the wheel forward i want
26:37 - to zoom in and if i push it back i want
26:39 - to zoom out
26:40 - so very simple just up here just swap
26:42 - these so that's a minus and that's a
26:43 - plus
26:44 - okay so final thing that we need is like
26:46 - you saw it's way too snappy so let's add
26:48 - a nice smoothing and we can do this with
26:50 - a simple lerp i actually cover this in a
26:52 - quick short video it's a super simple
26:54 - way to add smoothing to pretty much
26:56 - anything can be a flow to vector 3 or
26:58 - anything you want so in this case target
27:00 - fill in the view is a float so let's use
27:03 - math f doubler
27:04 - this one takes a current value so the
27:06 - current value won't be the current field
27:08 - of view
27:08 - then the b this is going to be the final
27:10 - one so let's use the target as the
27:12 - target field of view and finally t so
27:14 - time dot dot the time
27:16 - and this is probably way too slow so you
27:18 - float for the zoom speed define it as
27:20 - something
27:22 - and we just multiply
27:24 - so that works that applies the smoothing
27:27 - and we just want it to the final field
27:28 - of view
27:29 - okay so let's test and see if it's nice
27:31 - and smooth
27:32 - so here if i scroll yep there you go
27:34 - nice and smooth going back and back all
27:37 - right great so i can zoom in and out in
27:39 - any way i want all right so here the
27:41 - field of view zoom is working now like i
27:43 - said this is just one of the methods
27:46 - the other one would be to leave the
27:47 - field of view exactly as it is and just
27:49 - move the camera closer
27:51 - so let's handle that second method but
27:53 - let's also keep this one
27:54 - let's rename this function to handle
27:56 - camera zoom this is the field of view
27:58 - method
27:59 - now let's make another one so private
28:00 - void handle camera zoom
28:03 - and for this one let's call it the move
28:05 - forward method
28:08 - okay so now let's go up into our update
28:10 - and over here instead of calling that
28:11 - one let's try out this second method so
28:14 - here we're going to leave the field of
28:15 - view on loan we're not going to touch
28:17 - that one instead what we're going to
28:18 - modify is the follow offset and again
28:21 - we're going to need to use that method
28:23 - because if we try accessing this again
28:25 - and we access the phone nope we just see
28:27 - the follow target we don't see default
28:29 - offset so again we need to look into the
28:31 - package source code to figure out what
28:32 - to change and if you look here into the
28:35 - syn machine virtual camera component on
28:37 - this grip if we look around
28:39 - we can see that the waste and machine
28:41 - works is apparently by some kind of cine
28:43 - machine component base
28:44 - so this system is set up in a way to
28:46 - allow for multiple components we can see
28:49 - we have a function to get all of these
28:50 - machine components and we got another
28:52 - one to get a specifics in machine
28:54 - component and then if we look in the
28:56 - project window under the packages under
28:58 - syn machine under runtime and then
29:00 - components if you look here we can see
29:02 - various interesting class names and if
29:04 - we open one of them we can actually see
29:06 - that the extends in machine component
29:08 - base so these are all of the various
29:09 - components that can be attached to the
29:11 - scene machine virtual camera and if you
29:13 - compare these names with the ones on the
29:14 - virtual camera so over here for example
29:16 - on the body if you scroll you can see
29:19 - we've got do nothing which means no
29:20 - component then we've got third person
29:22 - follow framing transposer regular
29:23 - transposon and so on and if in the
29:25 - scripts yep the same thing third person
29:27 - follow a composer framing transposer and
29:29 - so on
29:30 - so we can see that the body field here
29:32 - is essentially an instance of one of
29:33 - these components so in this case we're
29:35 - using the transposer type so let's open
29:38 - up the syn machine transposer script and
29:40 - over on this one if now we search for
29:42 - follow offset
29:44 - here it is we do find this only field m
29:46 - follow offset and you can see it even
29:48 - defaults to vector3.back times 10
29:50 - meaning it's going to be pulled back
29:52 - minus in the zen so that's exactly what
29:54 - we saw happen so we know this is the one
29:56 - that we want to use so this is what we
29:58 - need to modify let's go back into our
30:00 - regular script and up here let's first
30:02 - get the same machine version on camera
30:04 - then we need to get a syn machine
30:05 - component of that type so let's use that
30:08 - function to get a syn machine component
30:10 - then for the type let's use the syn
30:12 - machine transposer
30:14 - and then from this one now we can modify
30:17 - the m follow offset here it is this one
30:20 - again let's do a quick test so let's set
30:22 - this to some random value so maybe this
30:24 - 10 minus 10
30:26 - and once again let's do this on a scroll
30:31 - okay so let's just test and see if the
30:33 - offset changes so here we are and if i
30:35 - scroll any of there go it does indeed
30:37 - change all right great so this is
30:39 - working we just need to add some
30:40 - external logic
30:42 - so we're going to need to change it
30:43 - based on the scroll wheel and then at
30:45 - the end we actually apply the changes
30:47 - and we're going to want it to be smooth
30:49 - as well so let's go up here and do the
30:51 - same thing that we did
30:52 - so private this is a vector 3
30:55 - for the fall offset
30:59 - okay then with this one down here let's
31:00 - do the same thing so on one of these
31:02 - we're going to move forward on the other
31:04 - one move it back
31:05 - now the question is how do we move it
31:07 - forward for this one we wanted to zoom
31:09 - straight in
31:10 - so we're going to need to calculate a
31:13 - vector 3 for the zoom here
31:15 - and now the way that we calculate this
31:17 - one of the simple ways that we can do is
31:19 - we can just say the current offset
31:21 - so let's set this to the following
31:23 - offset
31:24 - now we just want the direction so we
31:26 - normalize this so with this we have the
31:28 - same direction which will go either
31:30 - forward or backwards so then we can just
31:33 - increase the default offset let's
31:34 - increase it by zoom there
31:37 - and on the other one let's decrease it
31:40 - so minus equals
31:41 - this is on under zero then we need to do
31:44 - a quick test for the minimum and maximum
31:47 - so for that let's go up here let's
31:48 - define another private float
31:51 - for the follow offset min
31:53 - another one for default offset max
31:56 - then we can default this to some values
31:58 - maybe five f and maybe 50 f okay
32:02 - now we can compare those by checking the
32:04 - formula offset
32:06 - check the magnitude
32:08 - so we just do if the magnitude is under
32:10 - the fall offset min
32:13 - if so then we want to set it to some
32:15 - minimum
32:16 - so let's set the font offset equals the
32:18 - zoom direction which again is a
32:19 - normalized value multiplied by the fall
32:21 - offset min okay so this gives us a
32:23 - minimum and then the opposite for the
32:25 - maximum
32:26 - so if it goes past the fall offset max
32:28 - then we set this one
32:30 - so we have this now we just need to make
32:31 - sure that we start off fall offset with
32:33 - something so we can actually start off
32:35 - to the one that it has by default
32:38 - so up here let's make a private void
32:40 - let's make an awake
32:42 - then wait just set the final offset and
32:44 - grab the current one
32:47 - okay so then down here we just need to
32:48 - apply this small offset
32:50 - now the issue of course that this is
32:52 - instant we need to apply some smoothing
32:54 - so let's do the same thing that we did
32:56 - except this time we're working with a
32:57 - vector three so let's use vector three
33:00 - downward and all logic is exactly the
33:02 - same
33:03 - so let's grab the current offset
33:06 - then the target fall offset which is our
33:08 - final offset and finally time time dot
33:09 - delta time
33:11 - and of course you need to multiply it so
33:13 - you float for the zoom speed
33:22 - so we have our alert and then we just
33:24 - assign it
33:26 - so like this
33:29 - okay so let's test so here we are and if
33:32 - i move the scroll wheel if there you go
33:33 - and i zoom in and if i go to the maximum
33:35 - yup can't go further and i zoom out any
33:38 - of them out all right great so it's
33:41 - zooming a bit way too little but logic
33:43 - does work except it's also reverse so
33:45 - let's fix that
33:46 - so here just swap these out so this one
33:48 - is a minus and this one is a plus then
33:51 - for the amount float for the zoom amount
33:54 - let's put it at maybe three f and then
33:57 - the zoom direction we just multiply by
33:59 - this zoom amount
34:02 - okay let's test so here we are and if i
34:04 - zoom in if there you go zoom in and zoom
34:07 - out all right awesome so everything is
34:09 - looking really nice so i can move the
34:11 - camera i can rotate around and here
34:12 - we've got the second zoom method okay so
34:15 - with that done let's actually quickly
34:17 - check out the third zoom method
34:19 - now instead of zooming directly onto the
34:21 - position so this is a direct zoom
34:23 - instead of doing that let's just lower
34:25 - the camera closer to the ground so let's
34:27 - make another zoom method so let's make
34:29 - another function
34:30 - so hand on the camera zoom
34:33 - let's call this the lower y
34:35 - we're going to lower the phono offset on
34:37 - the y
34:38 - and logic here is actually going to be
34:40 - pretty similar to this one so let's copy
34:42 - this
34:43 - except for this one instead of moving
34:45 - according to the zoom direction instead
34:47 - of that what we're going to want to move
34:50 - is the fall offset but only on the y so
34:53 - only on the y that's the only one we
34:54 - want to modify
34:56 - so this one just lower it or increase it
34:58 - by the zoom amount then instead of
34:59 - checking for the magnitude we can just
35:01 - check for the fall offset y
35:04 - so the y equals math.clamp
35:07 - let's clamp the y between a certain
35:10 - minimum and maximum
35:11 - so let's define those up here
35:14 - so let's define the min y
35:17 - let's put it at maybe 10 and then the
35:19 - max y let's put it maybe 50.
35:23 - okay so we've got these two
35:25 - and now down here based on the min y and
35:27 - the max y okay so we clamp that value
35:31 - and then we do the exact same thing so
35:33 - we still use default offset and we did
35:35 - that all right so now let's use this
35:37 - method instead of the other one so over
35:39 - here on our update
35:41 - let's use this method instead of this
35:42 - one okay that's it super simple let's
35:44 - test okay so here we are and if i try
35:47 - zooming in yep there you go now it does
35:48 - this so instead of pushing forward it
35:50 - pretty much just gets the camera closer
35:52 - to the ground so personally i really
35:54 - like this method since it lets you look
35:56 - at objects from a different angle so the
35:58 - other one you always have this view and
36:00 - just getting in closer or further away
36:02 - whereas with this one we can zoom in get
36:04 - a different view of all of our map
36:06 - so personally i really like this method
36:08 - since it gives you a different view but
36:10 - either way here you have three zoom
36:11 - methods so choose whichever one you
36:13 - prefer
36:14 - and with that here is our complete
36:15 - camera system
36:17 - we can move with the keys in the
36:18 - keyboard
36:19 - alternatively we can also move the
36:21 - camera by moving to the edges so we've
36:23 - got edge scrolling enabled yet another
36:25 - method is by clicking and dragging the
36:27 - mouse so we can place the camera
36:29 - anywhere we want and again especially
36:31 - for this method you can easily change
36:32 - this to make it work with the new input
36:34 - system so making this work with touch
36:37 - input would be super simple
36:39 - and then we can also rotate the camera
36:40 - so i can look at anything from any angle
36:43 - and finally i can zoom in using any of
36:45 - three unique methods
36:46 - and over here is the 2d version with all
36:48 - the same features the logic is mostly
36:50 - the same the virtual camera is set up in
36:52 - 2d as is the camera the funnel target is
36:55 - the same and for the zoom there's only
36:57 - one method just changing the camera's
36:59 - orthographic size so that's it and here
37:01 - it is this same system working great in
37:03 - 2d alright so here is a fully featured
37:06 - fully working camera system this is
37:08 - perfect for any game where you want to
37:10 - give the player control over the camera
37:12 - there's a link description to download
37:13 - the project phone so go ahead and use
37:15 - this in your next project there's also a
37:17 - link there for this really awesome asset
37:19 - pack if you want to get it and if you
37:20 - found this video helpful check out my
37:22 - complete courses alright hope that's
37:24 - useful check out these videos to learn
37:26 - some more thanks to these awesome
37:28 - patreon supporters for making these
37:29 - videos possible thank you for watching
37:31 - and i'll see you next time
37:37 - [Music]
37:41 - you

Cleaned transcript:

hello and welcome i'm your code monkey and here let's build a really nice feature complete camera system we want the ability to move rotate zoom in and out enable edge scrolling and touch drag to pan the camera this is a great and very capable system for just about any game where you want the player to have direct control over the camera you can follow this tutorial and download the final project files we're going to build it in a 3d scene but in the end i'll also quickly show a conversion to make it work in 2d now this video ended up pretty long but it's the only video you need to make a fully complete camera system so if this is something that you need make sure you watch the full video to the end if you prefer a more guided path with step by step lectures then check out my complete courses learn how to make a builder defender game using csharp or learn how to make games internally using visual scripting perhaps if you're past the beginner stage and want to make the jump to advanced then check out my turn based strategy course to learn how to manage a more complex project and write some good clean code or learn all about unity with the ultimate unity overview course which contains over 15 lectures each covering a different tool feature of the engine i'm always available in the q and a section answering your questions every single day so check them all out with the link in the description all right so let's build our camera system now of course to do it we are going to be using syn machine if you have never used it i covered it in detail in another video basically syn machine is an excellent unity builtin tool that makes everything related to cameras so much easier we're going to see how we can build a basic camera in just a few seconds as opposed to minutes or hours if we built it all ourselves and for the demo scene that i'm using here this one is from the recently released cynthia ancient empire's pack it's a gorgeous pack with a really awesome roman or greek theme there's a link in the description if you want to get it for yourself all right so let's do it first of all let's create a brand new virtual camera so let's go up into game object then down here find cinemachine and then let's create a standard virtual camera let's rename this the scene machine virtual camera and that's it okay so with this here we already have a nice virtual camera and the way that this system is going to work is we are not going to directly move this object so the virtual camera we're not going to directly move this instead we're going to move another object and then set this virtual camera to follow and look at that object so let's do that let's right click on the hierarchy let's create an empty game object quality camera system let's reset transform to zero zero let's go into the virtual camera and just drag the reference as the follow so if we see on the camera it is currently positioned exactly on top of that object which is on zero zero then let's also add the same object reference as the lookout and now with this actually the camera is already working to test that out let's hit on play so here the game is running and the camera is already working let's just play around with the fields here the goal is for this object the camera system so the target object for that one to be right on the floor and the camera is above it looking down so for that on the virtual camera let's expand the body and over here we've got the phone offset by default it's at 0 0 10 so we can actually look in the scene view to see what the default looks like so yep there's the object right there the target object and virtual camera is 10 units in the z behind it like i said we want an overhead camera so on the virtual camera let's increase the fall offset by quite a bit let's lift it up on the y so put it something like this then on the z also push it quite a bit more back so a bit lower bit higher something like this okay so just with these basic settings you can already see it working here with the game viewing scene view side by side we can already see the object and if i manually move it yep there you go you can see the camera perfectly follows so this is how we're going to do we're going to move this object and the camera will automatically look at it so let's make a script to do that but before we do before we exit play mode let's make sure to go into the virtual camera and over here make sure we take save during play so we don't lose all the changes that we did so far and also let's push this a bit back so a bit more of a front view okay like this all right so those are the settings that i want make sure save the ring play stick now if we exit play mode if there you go all the changes were saved let's just move the camera system game object moved by default something like this also rotate it we're going to see rotation a bit but just right now it already works all right okay so with this like i said let's make that script so let's right click on the project files create a new c sharp script called the camera system let's select the camera system game object and attach the script alright so here let's just do some basic input logic so let's do it by going into private void update now here let's just add some basic input logic all right so here it is so just testing for wasd now naturally you could easily replace this with new input system which i covered in detail in another video so with this we have a move direction also note how since we're working on a 3d game look at how i define a vector3 and when pressing the w or the s key i'm modifying the z not the y that's because we're in 3d so when moving forward we want to go four not up so we have this move direction however here you need to be careful with how you actually move this object you might think that you could just add this move vector straight onto the transform position so just go transform.position plus equals the move direction multiply it by a certain move speed and by time dot all the time to make it frame rate independent so here you could define the move speed and put it at some value so you might think to do this but if we do and let's see what happens so here i am and if i press on w yep it does move forward press on s let's go back press on the go right press on a goes left okay so it does seem like it actually works however if i unmaximize this window now with the scene view side by side let's select the camera system game object and over here let's apply a rotation so let's put it maybe 90 degrees so the camera is now rotated and right now if i do the same thing so let's see what happens when i press on w and there you go it moves to the left and now if i press on d yep now it moves forward now s a and so on so this is the issue with this code when i press w i want it to move forward but when i do now it's moving to the left that is because moving into the global forward which in this case with the camera rotation the global forward is still pointing in this direction so when i press on w it still goes there now obviously this is not correct this is not what we want we want to take the rotation of this object into account in order to decide how we should move so back in the code here how we solve this actually pretty simple instead of moving directly by the moved ear what we want to do is to use the super useful transform vectors so let's calculate the final move there so let's actually rename this one so for this one instead of moving let's rename it so the visual studio shortcut this ctrl r let's rename this to the input deer then we calculate the final move there and for this one like i said we're going to use the super useful transform vectors we're going to use transform dot forward so this is the forward vector for this transform so this takes rotation into account so we multiply this one by the input dear.zed and then we add the transform.right again this one is also affected by the rotation of this game object we take this one and we multiply it by the input there dot x so with that now we have the correct move direction based on the object's rotation so we now use this in our movement and if we test it like this here it is with the camera rotated on zero so if i press w s a and d yep sound works perfect now if i rotate the camera so again let's apply a 90 degree rotation now press on w and if there you go does move forward s d and a all right awesome all right so here everything is working correctly we can move in any way we want now at this point we should probably tweak some settings here notice how the camera is indeed moving as we want so move up down right left and so on but since we're also looking at the invisible target in front of here due to the smoothing that we have it creates a bit of an odd result so as i press on w you can see the camera kind of shifts a bit upwards and if i go to the right it kind of has a slight delay now perhaps this is what you want if so then don't bother with the tweaks that i'm going to mention but in most cases you want the camera to pin right away instead of going slightly behind the target thankfully like i said since we're using city machine this is super easy to do so much just like the same machine virtual camera let's expand over here the body and then we've got the x y and z damping if we set all of these back down to zero yep there you go now the camera does move much more snappy again like i said this is personal preference and it kind of depends on what type of game you're trying to make but generally i prefer like this i perform my camera to be much snappier okay so with this the movement is working next up let's in on rotation for this one is also going to be super simple we already saw how we're going to do this since we defined the camera over here with the phone offset with a negative on the z that means the camera is always behind the target object so there's the camera and the target object is down there since the camera is already behind all we need to do is rotate this object so over here on the y rotation all we need to do is play around this and we can easily rotate the camera so here in the code it's super simple again let's do some input so again just using some basic input on q and e in order to rotate so we get the rotate direction then in order to rotate the object we can just modify this transform dot euler angles and let's add it based on new vector3 for our 3d camera we only want to rotate around the y axis you can verify what rotation you want if you look over here in scene view so if i rotate around the y yep you can notice that it rotates exactly as we want whereas on the x it does this kind of rotation that's not what we want and the z does this kind of rotation also now what we want so what we want is rotate on the y so over here create new vector 3 0 on the x 0 on the z and let's just put over here on the y and for the y let's use rotate direction multiplied by a certain rotate speed and finally just multiply by time dot delta time all right so that's it some extremely simple logic let's test all right so here we are now for press on e yep there you go rotates press on q and yep it does rotate all right so yep it does work now it's going a bit way too fast so let's actually reduce that and also if you want the opposite so if you want to press e and rotate in the other direction then over here just swap these make this one minus in this one pause but in our case it's working exactly as i wanted let's just lower the rotate speed a bit slower so here press on e any of those rotate press on q and does rotate okay great but we do see the same issue that we saw previously so as i rotate the camera is slightly lagging behind so that does not look very good so once again the solution is the same let's go into the virtual camera now let's expand the aim part and over here we've got the horizontal and vertical damping let's just put both these at zero and now the camera yep perfectly nice and snappy so by moving rotating off it works perfectly okay great now remember make sure you toggle save during play before you exit play mode and here it is the camera working really nice really perfect so we can now move anywhere we can rotate anywhere and everything works right all right so that's it next up let's handle edge scrolling this one is also pretty simple over here in our movement code we are testing for player input but we can also create an input direction based on the mouse position for that we have the input.mouseposition this gives us the mouse coordinates in pixel units so if we do a quick debug download and test this if there it is here in the log i can see and if we look in the stats we can see the size of this window so you can see that i've got this window set up as 1080p so that's because over here i've got full hd selecton and to check out what input.most position returns we can see that if i put the mouse over here on the lower left corner yep it returns pretty much zero zero and if i put over there on the top right corner it returns 1920 by 1080. so input.mouseposition gives me the screen pixel coordinates with this we can just do some basic math all we need is to get the total width of the screen get the total height then check if the mouse is within a certain distance from the left side so for example if it's under 10 pixels of the left side then we move to the left if it's within 10 pixels at the right then we move to the right and so on okay so here in the code and let's do that let's first define just an edge strong size so an end edge scroll size maybe 20 units maybe 20 pixels maybe that's enough then we just use some simple logic so if the input.mouseposition.x if this one is under this amount under the edge scroll size then that means the mouse is on the left side if so then let's set the input here dot x to minus one f then we test for the mouse position dot y if it's under that one then we want to move down so that's e z minus one next up we want to test if what's on the right side so for that we're going to test the mouseposition.x and we're going to test if it's past the screen dot width this is how we get the screen width so then when we subtract the edge scroll size so if the mouse is to the right of this point then we want to move on the x by plus 0.1 and finally the opposite so this one is on the y let's use the screen dot height and this one we move on the z on plus one all right so that's it really super simple let's test so here we are with the mouse in the middle of the screen now five approaching miles on the left side if there go pens left pins right pans forward and backwards all right awesome everything works now when it comes to edge scrolling some people like it and some people don't so usually you want to add it as an option rather than making it always enabled so for that we can just go up here make a private ball use edge scrolling you can default it to either true or false and if you want you can even make this a serialized film in order to make the default shown in the editor and then over here we just use this logic if this one is true so if use edge scrolling then we do all this and if not then we don't do any of this alright so that's it some super simple logic and obviously you would control this boolean based on the player's options all right now for the final movement method let's add a click and drag so i want to be able to for example place the mouse here use the right mouse button keep it hold down then i move the mouse in this direction and the camera moves in that direction so that's what we want to do okay so here in the code so let's begin by testing out our input like i said i want to use the right mouse button so input dot get mouse button test for the get mouse button down so we want to know when we press it so on the right mouse button so that's on one again of course you could swap this out for touch or any other input i'm just using the mouse just because it's nice and simple so when we do press the mouse let's set a certain volume to true so let's go up here and let's define a private ball call it drag pan move active okay and then down here when we press the mouse button let's set this to true and let's add another one for this one let's use get mouse button up so when we release then we set this back into false okay so we have this nice bully knowing when we should pan or not now with this we're only going to run the drag panel logic while this one is true so after this we do if if this logic is true then we're going to apply the drag pen move okay so in order to pan we need to know the less mouse position so we know how much it moved in the last frame so for that let's store it let's define a private vector 2 since the mouse only has a vector 2 for the last mouse position and then with this one let's go down here as soon as we press let's set it so this one equals input dot mouse position and then down here while it's active so while we still have the last mouse position with the last mouse position with this one we can calculate a vector 2 for the mouse movement delta so this is how much the mouse moves in the last frame so we just take the input dot mouse position exceptionally up here is the mouse position not the mouse on delta so we take this one and we subtract the last mouse position and here for some reason the mouse position actually is a vector 3 not a vector 2 so we can easily just cast this down into a vector 2 before doing the math all right so with this we have the mouse movement delta so we handle all of that and then in the end after all the logic then we update it with new value now we can do a debug dialog to see what this shows so we understand how this logic is working so here's the log now if i right click and if i hold still it's zero zero now if i move the mouse right and up so move it yep there you go we've got plus and plus over there and if i right click and i go down and left there you go we've got negative values so this is the amount of pixels that the mouse moved since in last update so with this we can now use this delta in order to directly move the transform for that let's actually put all this logic above before we move the transform we're going to refactor all this code in a bit so we've got this now let's just convert the mouse movement delta into the same as the input direction so here we set the input there dot x equals the mouse movement delta dot x but then we modify the input dear dot z based on the mouse movement delta dot y because over here we're working with a vector 2 but with the input we're using the z okay so that's it except with this it's going to move way too slow so let's define a float for the drag pan speed then we just multiply it by the drag band speed okay so let's test so here we are the camera is static now if i right click and i move the mouse and if there you go it is painting there penning there there and there all right awesome so with this we are directly using the mouse in order to pan the camera anywhere we want we've got that filmed if we feel that this is way too sensitive but yep the logic is working perfectly all right awesome so we already have quite a lot of things working now before we move on to the zoom let's actually refactor our code like i said i want this video to serve as the ultimate camera controller so let's refactor all of this to make the code really nice and easy to read and also really easy to define which features you want to use like perhaps you don't want the drag pan or perhaps you don't want edge scrolling so let's do that so first of all let's make two functions one to handle the movement and want to handle the rotation so for the rotation that's just this code so just copy this and we call this on the update all right and for the movement let's first of all copy all of this so all this in there and on update we call handle camera movement okay so right now everything is done working exam the same as previously but like i said we want to refactor this in order to be able to use or not use edge scrolling same thing for the drag pan so let's actually make separate functions for each of these movement types so let's go down here make another function private void handle camera movement edge scrolling and let's make another one so another private void handle camera movement for this one called drag pan and all we do is just copy all this logic so the use edge scrolling let's copy on to this one and then for the other the drag pen let's copy all of this one and of course we this we need to use the input here since we're reusing it so let's define another input here here and also same thing for this one okay so that works now on these two functions we just need to apply the final movement so that's this logic right here so just copy it apply it to the end here and apply to the end here all right so everything's working no more errors now we can just add all the functions depending on all the features that we want for this and now we can easily either enable or disable these based on boeing so we've got to use edge rolling now for another one use drag pan then let's put the ifs on this one so test for the if in here instead of testing inside this function it's over here let's get rid of this one so that one always runs and then same thing another if on this one all right so that's it now it's super simple all we need to do is modify either these variables and the logic won't work exactly as you want it here is the camera system with all the features enabled so i've got edge scrolling if i go to the sides yep i've got the regular movement i've got the regular rotation and the regular pan movement all right awesome okay so with that the code is working all the logic works now the last thing that we need to handle is the zoom and for that there's actually two ways to zoom a camera one way is to bring the camera in closer so on the virtual camera one way to zoom is to get it closer on the z and also closer on the y so this applies certain zoom another alternative is to simply change the fov so as you lower the fov yep it looks like a zoom so both these approaches work as kind of a zoom they're different so it depends on which one you want let's see how both those work okay so over here let's keep writing some good clean code and call handle camera zoom so let's make this function so down here make a broad void and all the camera zoom all right now here the first thing that we need is some input and for zooming what makes most sense is the mouse chrome wheel so let's handle that we can easily access that with the input dot mouse scroll down now this one as you can see it's a vector 2 because apparently there are some mice that scroll on the x but chances are for a zoom you want to scroll on the y so you've got this one.y if we just do a debug.log on this to see what it does here if i scroll forward yep we do see the value change we do see a plus one and if i scroll the wheel backwards so back to me we do see some negative values okay so these are the values that we can use to run our zoom logic so over here let's try handling the field of view method first now this is actually the more complex part due to how sin machine actually works you might think that you can just access the virtual camera and search for a field of view field so first we need a reference to the virtual camera so let's make one let's make it a serialized field so we can set it in the editor for the syn machine virtual camera and for this we need to add using syn machine so we have this for the same machine virtual camera then here in the editor we can drag the virtual camera reference okay so now here like i said you might think to just go inside this object so let's go inside this one and search for some kind of field of view but nope there's no such thing search for fov nope does not exist looking at the inspector here we need to figure out how to modify this field and thankfully cinemachine has all the source code available so you can just right click on the component and click on edit script and when you do you should be able to see the entire source code for send machine and just in case that doesn't work automatically you can just find it manually so you can go into your project window and over here expand the packages now if this one doesn't work then on the project window on the top right corner there's this little icon with an i if this one is toggled then the packages don't show up but if you untoggle it then all of them show up and here you can find cinemachine then inside you can find runtime and then under behaviors over here you can find the same machine virtual camera so just go ahead and open this here like i said contains all the source code however over here if you search for field of view nope nothing shows up search for fov nope nothing shows up so to get another hint we can again look in the inspector and over here we see that the fov exists inside something called lens so then over here on the script if we search for a lens we do find exactly this an object of type 1 settings called m underscore lens then we just need to go inside this lens settings so on the project window we can search for lens settings let's make sure to search in all and here we find the online settings so inside the send machine runtime core line settings and inside this script now if we scroll down yep here we do see the field of view so this method that we just did this is how you can figure out how to find any field in order to modify it through code there's an even more advanced version of this method where you can load all of the packages source code directly into visual studio doing that makes it super easy to find exactly where the field is that you want to change in my ultimate tnt overview course one of the lectures is exactly on this topic how to find any class or any field to modify any of the many tools and features that unity has another example of this is the postprocessing effect so how do you modify these various films inside these various effects through code that's one of the things that you can do with this method or the other one that i covered in that lecture also that course teaches you how to use many of the tools and features that unt has so check it out to the link in the description okay so back to our demo here we already know how to get the field of view so now let's do that let's go into the camera system so we've got the send machine virtual camera inside we can access the lens and inside the lens access the field of view now with this we can change it whatever we want so first let's just test it out so let's set it to something like 10 and let's do it when we scroll so if the input dot mouse call delta if the y is bigger than zero so if we scroll upwards then we should be able to see the field of view change let's see so here we are regular zoom nice scroll in and there you go it does zoom in alright awesome okay so all we need now is some logic to use some proper values since the zoom is instant we also need to handle some smoothing logic so here in the code first we need to store a field for the target field of view so a private float call it target field of view we can defound it to sunlight 50. then when we handle the camera zoom when we scroll in the positive for this one let's increase so target field of view increase by a certain amount let's say by maybe five and if we have the opposite so if we scroll the wheel backwards so let's reduce it by five now here you don't need to use delta time because this value the muscle delta this one is based on how often you physically scroll the wheel it is not something that happens on every single frame so you don't need time to download time okay so with this we have our target field of view now with that let's add a clamp to keep it within valid values so target field of view let's do in mathf.clamp let's clamp between a certain minimum and maximum so clamp this value for the minimum and maximum we can define them up here perhaps as a serialized field let's make a float for the field of view max another one for the field of view min let's default the maximum to about 50 and the minimum let's say 10. so then with these two down here we just use them so the first one is the min so the field of view min and the field of view max okay so we have the target field of view now just apply it so into the syn machine virtual camera access the lens and let's modify the film the view to the target field of view again right now it sound doesn't have any smoothing but let's just make sure this logic works so here we are and if i scroll backwards yep it zooms in and if i scroll forward yup it zooms out alright great except it actually has the opposite behavior that i want obviously this is personal preference but i find better that if i move the wheel forward i want to zoom in and if i push it back i want to zoom out so very simple just up here just swap these so that's a minus and that's a plus okay so final thing that we need is like you saw it's way too snappy so let's add a nice smoothing and we can do this with a simple lerp i actually cover this in a quick short video it's a super simple way to add smoothing to pretty much anything can be a flow to vector 3 or anything you want so in this case target fill in the view is a float so let's use math f doubler this one takes a current value so the current value won't be the current field of view then the b this is going to be the final one so let's use the target as the target field of view and finally t so time dot dot the time and this is probably way too slow so you float for the zoom speed define it as something and we just multiply so that works that applies the smoothing and we just want it to the final field of view okay so let's test and see if it's nice and smooth so here if i scroll yep there you go nice and smooth going back and back all right great so i can zoom in and out in any way i want all right so here the field of view zoom is working now like i said this is just one of the methods the other one would be to leave the field of view exactly as it is and just move the camera closer so let's handle that second method but let's also keep this one let's rename this function to handle camera zoom this is the field of view method now let's make another one so private void handle camera zoom and for this one let's call it the move forward method okay so now let's go up into our update and over here instead of calling that one let's try out this second method so here we're going to leave the field of view on loan we're not going to touch that one instead what we're going to modify is the follow offset and again we're going to need to use that method because if we try accessing this again and we access the phone nope we just see the follow target we don't see default offset so again we need to look into the package source code to figure out what to change and if you look here into the syn machine virtual camera component on this grip if we look around we can see that the waste and machine works is apparently by some kind of cine machine component base so this system is set up in a way to allow for multiple components we can see we have a function to get all of these machine components and we got another one to get a specifics in machine component and then if we look in the project window under the packages under syn machine under runtime and then components if you look here we can see various interesting class names and if we open one of them we can actually see that the extends in machine component base so these are all of the various components that can be attached to the scene machine virtual camera and if you compare these names with the ones on the virtual camera so over here for example on the body if you scroll you can see we've got do nothing which means no component then we've got third person follow framing transposer regular transposon and so on and if in the scripts yep the same thing third person follow a composer framing transposer and so on so we can see that the body field here is essentially an instance of one of these components so in this case we're using the transposer type so let's open up the syn machine transposer script and over on this one if now we search for follow offset here it is we do find this only field m follow offset and you can see it even defaults to vector3.back times 10 meaning it's going to be pulled back minus in the zen so that's exactly what we saw happen so we know this is the one that we want to use so this is what we need to modify let's go back into our regular script and up here let's first get the same machine version on camera then we need to get a syn machine component of that type so let's use that function to get a syn machine component then for the type let's use the syn machine transposer and then from this one now we can modify the m follow offset here it is this one again let's do a quick test so let's set this to some random value so maybe this 10 minus 10 and once again let's do this on a scroll okay so let's just test and see if the offset changes so here we are and if i scroll any of there go it does indeed change all right great so this is working we just need to add some external logic so we're going to need to change it based on the scroll wheel and then at the end we actually apply the changes and we're going to want it to be smooth as well so let's go up here and do the same thing that we did so private this is a vector 3 for the fall offset okay then with this one down here let's do the same thing so on one of these we're going to move forward on the other one move it back now the question is how do we move it forward for this one we wanted to zoom straight in so we're going to need to calculate a vector 3 for the zoom here and now the way that we calculate this one of the simple ways that we can do is we can just say the current offset so let's set this to the following offset now we just want the direction so we normalize this so with this we have the same direction which will go either forward or backwards so then we can just increase the default offset let's increase it by zoom there and on the other one let's decrease it so minus equals this is on under zero then we need to do a quick test for the minimum and maximum so for that let's go up here let's define another private float for the follow offset min another one for default offset max then we can default this to some values maybe five f and maybe 50 f okay now we can compare those by checking the formula offset check the magnitude so we just do if the magnitude is under the fall offset min if so then we want to set it to some minimum so let's set the font offset equals the zoom direction which again is a normalized value multiplied by the fall offset min okay so this gives us a minimum and then the opposite for the maximum so if it goes past the fall offset max then we set this one so we have this now we just need to make sure that we start off fall offset with something so we can actually start off to the one that it has by default so up here let's make a private void let's make an awake then wait just set the final offset and grab the current one okay so then down here we just need to apply this small offset now the issue of course that this is instant we need to apply some smoothing so let's do the same thing that we did except this time we're working with a vector three so let's use vector three downward and all logic is exactly the same so let's grab the current offset then the target fall offset which is our final offset and finally time time dot delta time and of course you need to multiply it so you float for the zoom speed so we have our alert and then we just assign it so like this okay so let's test so here we are and if i move the scroll wheel if there you go and i zoom in and if i go to the maximum yup can't go further and i zoom out any of them out all right great so it's zooming a bit way too little but logic does work except it's also reverse so let's fix that so here just swap these out so this one is a minus and this one is a plus then for the amount float for the zoom amount let's put it at maybe three f and then the zoom direction we just multiply by this zoom amount okay let's test so here we are and if i zoom in if there you go zoom in and zoom out all right awesome so everything is looking really nice so i can move the camera i can rotate around and here we've got the second zoom method okay so with that done let's actually quickly check out the third zoom method now instead of zooming directly onto the position so this is a direct zoom instead of doing that let's just lower the camera closer to the ground so let's make another zoom method so let's make another function so hand on the camera zoom let's call this the lower y we're going to lower the phono offset on the y and logic here is actually going to be pretty similar to this one so let's copy this except for this one instead of moving according to the zoom direction instead of that what we're going to want to move is the fall offset but only on the y so only on the y that's the only one we want to modify so this one just lower it or increase it by the zoom amount then instead of checking for the magnitude we can just check for the fall offset y so the y equals math.clamp let's clamp the y between a certain minimum and maximum so let's define those up here so let's define the min y let's put it at maybe 10 and then the max y let's put it maybe 50. okay so we've got these two and now down here based on the min y and the max y okay so we clamp that value and then we do the exact same thing so we still use default offset and we did that all right so now let's use this method instead of the other one so over here on our update let's use this method instead of this one okay that's it super simple let's test okay so here we are and if i try zooming in yep there you go now it does this so instead of pushing forward it pretty much just gets the camera closer to the ground so personally i really like this method since it lets you look at objects from a different angle so the other one you always have this view and just getting in closer or further away whereas with this one we can zoom in get a different view of all of our map so personally i really like this method since it gives you a different view but either way here you have three zoom methods so choose whichever one you prefer and with that here is our complete camera system we can move with the keys in the keyboard alternatively we can also move the camera by moving to the edges so we've got edge scrolling enabled yet another method is by clicking and dragging the mouse so we can place the camera anywhere we want and again especially for this method you can easily change this to make it work with the new input system so making this work with touch input would be super simple and then we can also rotate the camera so i can look at anything from any angle and finally i can zoom in using any of three unique methods and over here is the 2d version with all the same features the logic is mostly the same the virtual camera is set up in 2d as is the camera the funnel target is the same and for the zoom there's only one method just changing the camera's orthographic size so that's it and here it is this same system working great in 2d alright so here is a fully featured fully working camera system this is perfect for any game where you want to give the player control over the camera there's a link description to download the project phone so go ahead and use this in your next project there's also a link there for this really awesome asset pack if you want to get it and if you found this video helpful check out my complete courses alright hope that's useful check out these videos to learn some more thanks to these awesome patreon supporters for making these videos possible thank you for watching and i'll see you next time you
