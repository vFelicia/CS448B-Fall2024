In part one of our lesson on character arrays and pointers we saw how we can store strings in character arrays and we also saw how we can work with character arrays using pointers in some of the basic scenarios whenever we are working with pointers it's really important that we visualize how things are happening in the memory so the first thing that we will do in this lesson is we will simulate the program that we had written in the previous lesson to print the characters of a string and see what goes where in the memory and we will also look into the concept of string constants and constant pointers so this is where we had left in our previous lesson we have written a function print to print the characters in a string in the main method we have a character array of size twenty but we have stored a string of length five in it we have used a string lateral so null termination is implicit we have talked about this earlier so let us step through this code and see how it is working now once again I have drawn this familiar diagram the memory that is allocated for execution of a program is typically divided into these four parts these four sections one part of the memory stores the instructions in the program we call that the code segment or the text segment one section stores the global variables and stack is where all the information regarding function call execution and all the local variables go whenever we are writing a program than ever we are executing a program we should always visualize what variable goes where or what data goes where and what is the scope of that variable our data okay so let us run through this code and see what is happening in the memory when this program will start executing first the main method main function will be invoked whenever a function is called some amount of memory from the stack is allocated for the execution of that function it's called the stack frame of that function so let us say this stack frame from address 100 to 150 is allocated for the main function stack is one contiguous block of memory so let us say in this stack the memory increases from bottom to top all the local variables of a function go into the stack frame of the function so when we declare a character array 20 bytes from the stack frame will be allocated for this particular character array let's say they are allocated from address 100 to 120 each character is stored in one bite so we need 20 bytes for character array of size 20 apart from local variables there maybe some more information in stack frame so that's why we have some more space and now the control of the program goes to this statement print 'c' as soon as we make a call to another function from a function the execution of that particular function is paused at that particular line and the machine goes on to execute the called function the called function is allocated stack frame on top of the calling functions of print will be allocated as stack frame on top of main function whatever function is at the top of the stack in at any point is executing I mean we'll wait for this function to finish let's say this particular stack frame is from 150 to 170 main is paused and print is executing right now, now print will also have a local variable C but this will be a pointer variable a pointer variable takes four byte of memory in a typical architecture so this will be taking four bytes so let's say starting address 154 in this stack frame we have four bytes for this particular character pointer so this C in main is actually not the same C in print, the C in main and C print are different they have different scopes we could have named this particular variable a or PTR or whatever but all that happens when we make this particular call to print and pass this C here is that the address 100 which is the base address of the array is passed to the print function and the print function keeps it stores it in the pointer variable sometimes it may confuse us when we are using the same local variable name in the calling function and the same argument name in the called function but we must always understand that they're different okay to run through this code further I clear some space here now I'll draw this array C outside the stack here we have an array of size 20 but we are only showing the first six positions in the array from address 100 to 105 and that's why it is extending towards the right the sixth charecter is a null character and the first five characters are the characters of word hello and now we have this another guy which is c of print which is a character pointer at address 154 that stores address 100 so it points to the first element of the array now let's come back to our program execution let's say we are here initially I'll mark the statement that is executing by this green arrow, let's name these two guys this guy is C but ths guy is an array local to main and this is also C but it is a character pointer local to print ok so now here what we're saying is while *C is not equal to the null character when we put this * operator in front of a pointer variable we are looking at the value at that particular address so at this stage when C is pointing to the base address *C is H so this condition is not true we will go to this line print F that will simply print *C which is H let's write down the output here so we have printed H so far and then we say c++; if we understand pointer arithmetic from our previous lessons incrementing a pointer by one unit increments the address by size of the data type that the pointer points to C here is a pointer to character data type and character data type is one byte so C+1, C++ is saying C= C+1 so C now becomes 101 so now C points to the second character in the array and once again we come to where we find this condition in the while loop *C is E here it's not null once again we will go inside the loop and print E and we will keep on going like this till the address in this pointer variable reaches 105 now here the value at this particular addresses is null character so the loop will not execute we will come to this statement to print an endofline and the execution of print function will finish so this particular stack frame for print will be cleared from the stack will be deallocated and now main will resume and finish so with pointers we should always know what's going where in the memory okay so let us now modify in this particular code to learn some more concepts now what I'm going to do in my code is instead of creating a character array of size 20 I'll create a character pointer named C and equate it against a string lateral in a statement like this and if you run this program and the output will be the same what really happens is if you use the string lateral in initialization statement of an array something like this and then the string gets stored in this space that is allocated to the array so in this case it will go into the stack in this character array of size 20 but if you use the string lateral elsewhere in a statement like this are maybe when we do something like passing a string lateral to a function then in these cases the string get stored as a constant during the compiletime and most probably it will be stored in the text segment of the application memory and it cannot be modified so if you write a statement like this let's say you want to change the first character of on this constant string to A running this program will give you an error will cause a crash okay coming back to having a character array, now if we have a character array and we are passing the address of the array to a function that function receive's it in a character pointer now using this pointer we can modify the data in this particular array so if I say something like this we first to change the first character to A and then we are printing the characters and then as you can see it is possible to do so now sometimes we may want a function just to read a string and not write anything to force this kind of behavior we can change our argument to const character pointer and now if run this code this code will give us compilation error we can read whatever is there in the array that is past but we cannot write to any of the positions this code will work fine, pointers are really tricky and even the most experienced programmers write buggy code when they are using pointers I recommend that you get your hands dirty by writing some code yourself that's the best way to learn so this is it for this lesson thanks for watching