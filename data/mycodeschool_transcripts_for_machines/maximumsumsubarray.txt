Hi, Today we are going to solve an interesting problem. Given an array, we have to find a subarray whose sum is maximum among all possible subarray sums. This subarray will be referred to as the Maximum Sum Subarray or the MSS. a over here is an array of size 10. It's indices are marked from zero to nine over here. In this problem the array can have both positive and negative values. A subarray is defined as a continuous part or section of the given array. As you can see, 5, 7, 6 form a subarray. The sum of this given subarray over here would be 8. In this lesson, we consider subarrays to have at least 1 element. The subarray that would give the maximum sum is from 7 to 11 with a sum of 19. Now let me take one more example, to make things more clear. b is an array with all negative values. Therefore it's MSS would be 1 it's highest value. Instead if the array contained all positive values we will have the whole array as our MSS. Now the first approach that we are going to discuss over here is a bruteforce algorithm. We are going to form all possible subarrays, find their sum, and find it's maximum. i.e we are going to form subarrays of size 1, 2 and so on. Let us see this algo in action. We will take a variable called answer (ans). As we iterate through each subarray, we will calculate each of it's sum. Answer will store the maximum of these sums seen so far. i.e each time we calculate the sum of a subarray, compare it with the value in answer. If it is greater, then we update answer with the sum that we just computed. So before we form subarrays and start finding the sum, we initialise answer with a Highly negative value. INT_MIN is a MACRO available under the climits header in the C++ language. This represents the minimum value that can be stored in an integer variable. Different languages have different ways to represent this constant. We start with a high negative value because we want a value which is lesser than all possible sums in answer. For instance if answer was zero and the array was filled with negative values then finally we will have zero in answer and not the real maximum. So first we have subarrays of size 1. We find it's sum and update answer with it's maximum. Then we move on to subarrays of size 2, we find each of it's sum and then update answer with the maximum of answer and the sums. We move on to subarray of size 3 and finally subarrays of size 4. Now that we've seen the algorithm in action, let us see how we can code this. I'll be using C/C++ code throughout this lesson. Maximum_Sum_Subarray is a function which accepts an array and it's size as it's parameters and returns an integer value, the sum of the Maximum sum subarray. First we iterate over all possible subarray sizes. Starting at 1 and ending at n. Then, we iterate over all possible start indices for these subarrays starting from 0 till n1. This condition checks whether the subarray that we've got is a valid subarray. For instance, in the previous example that we saw, if the sub_array_size was 2 and the start_index 3, we will have an invalid subarray and we need to ignore it. Once we get a valid subarray we need to calculate the sum. We iterate from the start index of the subarray, till the last index of the subarray which is [start_index+sub_array_size1]. To calculate the MSS we need to take the maximum value of sum. Answer is initialized to INT_MIN available under the climits header which is a high negative value. In the end answer will contain our MSS which we will return. Now let us calculate the time complexity of this function. If you do not know how to calculate time complexity, please refer to our videos on that. The link is available in the video description. We have 3 loops over here each of time complexity O(n) and since it's nested the overall time complexity is O(n^3). Now we can see how we can improve our algorithm reducing the computations by either using previously calculated values or by changing the order in which we do some specific tasks.Now when we considered subarrays starting at the same index, we were calculating the sum from the start separately for each subarray. This was because we considered subarray size first and then the start index. But if you notice over here the sum of each of these subarrays is it's previous sum plus the last element of the subarray. i.e to calculate the sum of the subarray of size k, we take the sum of sumarray of size k1 at the index i and add the last element to it. For each subarray of size k we save k1 iterations every time saving valuable computation time. So now let us see how we can implement this new approach and how it improves our time complexity. So instead of deciding upon the subarray sizes, we'll decide on the start indices first. We iterate over all possible start indices and then we iterate over all possible subarray sizes. It ranges from 1 to n. And again we have to check if the subarray that we have is a valid subarray or not. Now since we'll be taking the sum of our previous subarray, sum is declared outside the subarray loop. To sum we will add the last element of each new subarray which is basically sub_array_size1 since array_size1 is the last element of any array. Finally we use a variable called answer to take the maximum of all the sums and return it. Now for the time complexity of the given function we have two O(n) loops both of which are nested. Therefore the overall time complexity is O(n^2). So we reduced the time complexity from O(n^3) to O(n^2) by making a simple observation. Next we are going to look at a technique called divide and conquer where we will divide our problem into subproblems and use their results or use their answers to compute our answer for the main problem. Coming back to our previous example, let us divide the array into two. Left Half. And right Half. Now imagine that we know their results already. Now imagine x is the array that we have and y is a subarray of x which is the answer that we need. Now let us figure out what are the possibilities for y's position in x. For our first case, y which is the Maximum sum subarray of x could lie completely in the left half. In that case the answer is already computed. Similarly y could lie completely in the right half of x. In that case also we have our answer computed. The last possibility is that y lies in both left and right half. i.e the start index of y lies in the left half and the end index lies in the right half. So if indeed this was the case, we need to figure out the best possible answer where the start index lies in the left half and the end index lies in the right half. Now we are going to figure out the best possible start and end indices independently. Starting from the rightmost point in the left subarray, we'll figure out what is the best possible sum we can get. Similarly starting from the left most point in the right subarray, we figure out what is the best possible sum in the right. Therefore the sum of the best possible subarray whose start index lies in the left half and the end index in the right is simply the sum of these two variables. At each step we recurse over the left and right half of the array. Now we have reached to a case where we have an array of size one. This will be the base case of our recursion. When there's only one element in the array, the value itself is the MSS of that array. Now we have an array whose left MSS is 3 and right MSS 2 and the best possible subarray through the middle as 1. Therefore the MSS of this array is 3 which is the maximum of all these 3 values. Similarly we have an array whose left MSS is 5, right MSS 1 and the best subarray through the middle as 4. Therefore the answer that we'll get from here is the maximum of these 3 values which is 5. Finally we have the answer as 6, which is the maximum sum subarray for this given array. Let us look at how we can implement this solution. First we take care of the base case condition. When n is 1 the element itself is the answer. Then to divide the array into 2 we calculate m, the size of the left subarray. We recurse over the left half of the array. For that we call the same function with the same array pointer but the size of the left array. Then to recurse over the right half of the array, we increment the array pointer by m, the size of the right half will simply be nm. To calculate the leftsum and rightsum value just like how we saw before, I've declared two variables. Both of them are initialised with the most minimum possible value. Sum will take care of all the intermediate sums. To find the rightsum value we start from the left most point in the right subarray and find sum of all subarrays starting at that point. And then we take the maximum of all those values and store it in rightsum. After reseting the sum variable we start with the rightmost point in the left subarray and do the same to calculate leftsum. Finally the answer will be maximum of left_MSS , right_MSS and sum of leftsum and rightsum. Let us try and analyse the time complexity for the divide and conquer technique that we have used over here. Let T(n) be the time it takes for completion of a program with an array of size n. When n is equal to 1 we have the base case where we do constant number of operations. Then we recurse over the left half and right half each of size n/2 and combining the two loops we do operations proportional to the size of the array. Writing that mathematically we have T(n) equals c when n is equal to 1 denoting constant time operations and when n is greater than 1, we have 2T(n/2) + c'n. On solving this recursion we get that T(n) is equal to cn + c'nlog(n). In the bigo notation it is nothing but nlogn. The recursion over here is very similar to that of merge sort algorithm. If you do not understand how this recursion works, or how we derived this time complexity of this function, please refer to the videos on merge sort for that. We have so far seen 3 techniques for solving this problem. Next we are going to see an approach called Kadane's algorithm. In this algorithm over here we are going to solve this problem in a much more simpler manner. i.e Just by going through the array once, we will calculate what is the MSS of that array. We are going to find the MSS of this given array. Initially we start with an empty subarray and as we keep discovering elements we will try and add it to this subarray. We will also keep track of this subarray. This value will help us determine whether we can add a new value to the subarray or we reset the subarray to the empty subarray that we started with. The original algorithm assumes that there is at least one positive element in the given array. So we can safely initialise the value of sum to 0 which is the sum of an empty subarray. Now when we start iterating, we will add the element to our subarray. If the new sum of the subarray is positive we will keep the element in the subarray and move on. Now since the maximum value of sum will be the MSS of our array we need another variable to keep track of the maximum. Now moving on to the next element, we see that adding that value to our sum, sum becomes negative. In that case we reset the subarray to the initial empty subarray. Moving on adding the next value we get a positive value in sum. So we keep the value in the subarray and update answer to maximum of answer and sum. The next element makes sum negative, therefore we reset the subarray. Now let us quickly look at how this algo works for the rest of the array. Since these two values keep the sum positive we keep adding it to the subarray. As long as sum remains positive we will keep adding the element to the subarray. And when sum falls negative we reset the subarray to the empty subarray that we started with. In an array at an index i, sum will try to calculate the MSS ending at i. i.e Of all the subarrays which end at i, sum will try to calculate which is the best possible MSS. Now since we have the MSS ending at i to form the MSS ending at i + 1, we can add to the MSS ending at i. The MSS ending at i could be both positive or negative. If it was positive I can add my current array value to it and try to get a better answer in the future, but if it was negative, I am always better off by not considering that subarray. That is why when we get a negative value in sum, we reset it to the initial empty subarray that we started with. In all other cases we keep adding it to the subarray. Let us see how we can implement this solution. I start with two variables answer and sum just like how we saw before. Answer will keep track of the maximum values of sum which will finally contain the MSS. We iterate over the array once visiting every element just once. As we saw previously if adding it to the previous sum my sum remains positive i will add the element to the subarray. Here it is just represented by adding the value of the to the variable sum. In the other case we have to reset it to the empty subarray. Here it is represented by resetting the sum value to zero. We take the maximum of sum in answer and finally return the MSS of the given array. Now let us quickly calculate the time complexity of this given function. Since we visit every element in the array just once the overall time complexity is O(n). The original Kadane's algorithm works only if the array contains at least one positive element. So if the array were to contain all negative values, we need to have a separate check, checking if all the values are negative and then return the maximum if that was the case. So having a quick recap we saw four approaches. The first approach was a n^3 approach where we saw all different possible subarrays and took the maximum. We later improvised with a n^2 approach and then we used the Divide and Conquer technique to arrive at a nlogn solution and finally we saw the Kadane's algorithm which runs in O(n) time. All the code that has been shown in this video tutorial will be available in github. The links will be posted in the video description. Thank you.