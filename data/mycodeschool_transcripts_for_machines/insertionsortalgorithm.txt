In our lessons on sorting algorithms so far, we have talked about two of the sorting algorithms selection sort and bubble sort. Now, in this lesson we are going to talk about another sorting algorithm named insertion sort. Insertion sort is not the best sorting algorithm in terms of performance, but its a little more efficient than selection sort and bubble sort in practical scenarios. Insertion sort is also pretty intuitive sorting technique. So, lets see what it is. To explain the logic of insertion sort. i'll once again use the example of cards. So, let's say we have a set of cards in our hand and we want to arrange these cards in increasing order of rank. There are couple of intuitive ways to sort a set of cards in our hand. One of the things that we can do is initially we can keep all the cards in our left hand and we can start taking cards one by one from the left hand and we can start building a sorted arrangement in the right hand. Our first card is 9 and there is no other card in right hand. So, 9 will simply go into the right hand. Now, we will take the next card in our left hand which is 3 in this case. Now, when we will take 3 to the right hand, we will insert it before 9 to make sure that the cards are sorted. At any stage during this whole process, the left hand will be unsorted and the right hand will be sorted. Now, the next card that we will pick is 6. Now, when we will six to the right hand it will have to be inserted between 3 and 9 and now the last card that we will pick will be 4. And 4 will have to be inserted between 3 and 6 in the right hand. And finally we will have a sorted arrangement in the right hand. I have used 2 hands here, but if you see thus can be done i none hand also. The idea is pretty simple. What we are basically doing is, we are dividing the set of cards into two subsets a sorted subset or a sorted part and an unsorted subset or unsorted part. Initially, all the cards are in unsorted subset. And the sorted part is empty. And we are picking up one card from the unsorted part at a time and inserting it into the sorted part. Let's say we have something like this. We have a boundary here and let's say cards to the left of this line, this vertical line are sorted and cards to the right of this vertical line are unsorted. So, initially all the cards are in unsorted part. Now, we will pick up one card at a time and insert it into the sorted part. If there is just one card, we simply move it. Now, we pick up the next card from the unsorted part. It's 3. It will be inserted before 9 in sorted part. Now, we will pick 6 and 6 must be inserted between 3 and 9 and finally we will take 4 and 4 must go between 3 and 6. It should be inserted between 3 and 6. And we are done once our unsorted subset is empty. Now, when we want to write a program to sort a list, we can do something similar to what we did for the cards. So, let's say we want to sort a list of integers given to us in the form of an array, let's call this array A. We have 6 elements in the array, so we have indices from 0 to 5. What we can do is we can start by saying that we will divide the array in to two subsets. Initially, elements till index 0 will be part of sorted subset or sorted half because if you have one element in a set, the set is always sorted and all other elements are part of unsorted subset. And now we will go on picking elements from the unsorted subset and we will keep on inserting them into the sorted subset. So, we will kind of keep expanding the sorted subset till unsorted subset becomes empty. At any stage let's say the cells in blue are part of the sorted subset. Now, at this stage, I'll pick up 2 which is the first element in the unsorted subset. Programmatically, this will mean storing the value in some variable. let's say the name of the variable is value. So, all we have done is we have said something like value = A[1], but for the sake of understanding, lets assume that we have taken out 2 from that position and we have created a hole there at that particular position. Now, what we will do is to insert 2 into the sorted part, into the sorted subset, we will shift all numbers greater than 2 in the sorted part by one position to the right. We have only one element at this stage in the sorted subset 7 which is greater than 2, so 7 will be shifted one position towards right and the hole will go to position 0. And now, we will fill up 2 at position 0. we will fill up 2 in the hole. And now we are sorted till index 1. Now, once again we will pick up the first element from the unsorted part. So, we will create a hole like this. Remember, there is no actual taking out of 4 from this position, we are just filling up 4 in another variable and assuming that there is a hole at that particular position. Now, once again we will shift all the numbers greater than 4 by one position to the right. we will do so one by one. We will start at position 1 and see if the number is greater than 4, 7 is greater than 4, so 7 will be shifted to index 2 and the hole will now move to index 1. Now, we will look at 2, 2 is not greater than 4. So, no more shifting is needed, we will simply put 4 at index 1. And now we are sorted till index 2. And now we will pick 1 from the unsorted part and once again we will start shifting all the elements greater than 1 in the sorted subset one position towards right. 7 is greater than 1, so we will shift it and we will, the hole will now move to index 2. Number 4 is also greater than 1, so it will also shift. number 2 is also greater than 1, so hole will shift to 0, and we do not have any number greater than 1 to be shifted. So, we will move 1 to this hole and now we are sorted till index 3. And we will repeat the same insertion logic for 5 and 3 as well. for 5 we will have to shift only 7 and for 3 we will have to shift 7,5, and 4. So, finally 3 will go at index 2. So, finally we have a sorted list. This particular inplace logic of shifting and inserting elements to sort a list is insertion sort algorithm. And now, let's quickly write pseudo code for this algorithm. I'll write a function named InsertionSort that will take two arguments an array and the number of elements in the array. let's say the name of the array is A and the number of elements in the array is n. Now, initially we are saying that we are sorted till index 0. So, we will pick up elements from 1 till n1 and at each step we will insert the element at its appropriate position in the sorted subset. So, in our code we will run a loop starting index 1 till n1 and first we will create a hole by taking out the value to insert in another variable. So, temporarily, we will keep A[i] in this particular variable. And then, I'll take another variable to mark the position of the hole. At this stage, the hole is at index i and now we need to shift all the elements greater than the value to be inserted one position to the right. While hole is greater than 0 and the element at index hole 1 is greater than value, we will shift the element at index hole1 to the hole. So, now our new hole will be index hole1. When we will find a smaller element than value in the sorted subset, this particular condition will be false, we will exit the while loop or we will exit the while loop when hole will be equal to 0, so there will be no more element to shift and finally when we will come out of the while loop, we will put the value into the hole. And this is our pseudocode for insertion sort. i'll quickly walk you through this particular code and show a simulation with this particular example. So, we are running this code with this particular array. We will start with i = 1, so value will be 2 and hole will be index 1. And now we come to the while loop, hole is not 0, so we can be sure that there is an element before it and we can access the element at index hole 1, hole 1 is 0 and the element there is 7 which is greater than the value 2. I'll mark the hole with this color orange. And now we come here. We will say A[hole] , the element at index hole should be element at index hole1. So, 7 will now be written at index 1 and our imaginary hole will shift to index 0. and now in the while loop, this condition will be false, hole = 0, so we will come here. We will fill up 2 at this particular position at index 0. And now, i will be incremented. So, value will be 4 and hole will be index 2. 7 is greater than 4, so we will shift it and the imaginary hole will go to position 1 and now A[hole1] which is 2 is not greater than value, so we will come out of the while loop and we will write 4 at this particular position. And we will go on like this. For 1, we will shift all the numbers in the sorted subset. So, finally we will have a sorted array. Sometimes, the hole may not shift even by one position. We will not even go inside this while loop. In that case, it will mean just taking out the value and inserting it again into the hole. It will happen when the number to be inserted will already be at its appropriate position. So, this is pseudocode for insertion sort algorithm for you. Let's now try to analyze the time complexity of this algorithm. We can try calculating the running time expression for this algorithm. Simple statements in a program execute in constant time. By simple statements, we mean statements having simple operations like assignment, arithmetic or logical operations like these are simple statements. let's say these statements will take some constant time C1, they'll together take some constant time C1, these two simple statements will together take some constant time C2, and this particular statement will take some constant time C3. Now, for our algorithm, these two lines will always execute n1 times, and how many times will these two lines execute inside the second loop. Well, it depends. it depends upon the input. When we will have a sorted array, then we will not go inside this while loop even once because this particular condition will never hold true and this particular statement with cost C3 will also execute n1 times. So, overall time taken in the best case will be equal to (C1+C3)*(n1). There will be some additional cost to increment counters and all or to do this comparisons inside this condition for loops. Lets assume that they are accounted for in C1 and C2 respectively. This one should be n1 in bracket. So we have a polynomial like an+b where a and b are some constants in terms of C1 and C3 and whenever we have a polynomial like this for the running time, it belongs to the set bigoh of the highest order term in the polynomial. So, this will be O(n). so, insertion sort is O(n) in best case. We will have a worst case when we will have a reverse sorted array something like 5,4,3,2,1. In that case, for i = 1, the statements inside the while loop will be executed once, we will have one shift. For i =2, we will have 2 shifts and we will go on like this for i=3, we will have 3 shifts and for i = n1, we will have n1 shifts. So, overall cost will be something like (C+C3)(*(n1) and {1+2+3+...n1}C2. And if we will evaluate this arithmetic progression, we will get n*(n1)/2 and when we will reduce this whole expression further, we will get a polynomial something like an^2 + bn + c where a,b and c will be some constant, some constants in terms of C1,C2 and C3. And this will belong to the set O(n^2) which is another way of saying that for very high values of n, the rate of growth will be pretty similar to the growth of n^2. These lower order terms will not matter. If you are not aware about time complexity analysis and bigoh notation, we have a complete series on time complexity analysis. You can find a link to it in the description of this video. In average case, for ith position, we will make i/2 shifts and if we will try to calculate the time expression, it will again be some polynomial of form an^2 + bn +c. So, for average case also, we will be O(n^2). Even though insertion sort is also O(n^2) for worst and average case, the number of comparisons and shifts in insertion sort in all practical scenarios is a lot less than selection and bubble sort. So, is considered to be better than selection and bubble sort. So, this was insertion sort and its time complexity analysis. Thanks for watching !