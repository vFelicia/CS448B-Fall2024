In this lesson we will write a program to find the factorial of a positive integer n and we will do so using a very important and powerful concept in programming called Recursion. The prerequisite for this is that you should know about functions in programming. Now, as we know in mathematics factorial of n is defined as the product of all the integers from 1 to n. So, n factorial is written as n * (n1) * (n2) and we go on multiplying with all the integers till 1. Now, we also know that (n1)*(n2) all the way till 1 here, is nothing but (n1) factorial. So, we also say that n factorial is actually n * (n1) factorial. And, this is true for all n greater than 0. Zero factorial is a special case and it is equal to 1. So, we will write something like this. n factorial is n * (n1) factorial if n is greater than 0 and it is equal to 1 if n is equal to 0, and this is nothing but case for 0 factorial. So, we have a function for n factorial here. When we write a function in a simpler form of itself, we call such a function a recursive function. So, for example we have written here n factorial in the form of (n1) factorial. So, this function here is a recursive function. Now, the concept of a recursive function is also valid in the context of a programming language. So, I will write a recursive function to calculate factorial here. So, let's say we write a function that returns an integer and the name of the function is Factorial. It takes an integer as input so, we will say int n is the input. And, the function goes like if n is equal to 0, simply return 1, else return n* Factorial (n1). So, now we can see that within the function or the method factorial, we are calling the method itself, though with a changed argument or a reduced argument. So, when we call a method within itself, we say that such a call is actually a recursive call. Let us now see, how computer understands and executes this particular method. Let's say we want to calculate factorial 4 and we have passed, we have asked for Factorial(4), and I will write F(4) as shortcut for Factorial(4), and I will draw two columns here, and I will come back to why I am drawing these two columns. Now, when the computer tries to calculate F (4) here, it sees that it actually is calling F (3) recursively. So, what it says that "Hey, I will pause the execution of this particular function F (4), and I will go and calculate F (3) first". So, it saves the current state of F(4) into memory, and goes on to calculate F(3). Now, F(3) again makes a call to F(2). So, machine or computer again pauses this execution of F(3) and goes to calculate F(2). Now, F(2) again makes call to F(1), so we pause this again, and we keep going. F(1) again calls F(0), now when we come to F(0), then there is no recursive call further, and if you can see in the left, then this condition holds true. So, n is 0 here, and we simply return here. So, this F(0) was kind of a base condition, and if it was not there, then this particular recursion would have gone endlessly. Now, F(0) simply returns 1 here, and it finishes and computer again resumes F(1). And, because we have got F(0) now, and now it calculates F(1) and now F(1) finishes. And F(2) is resumed, this R here is for Resume, now, F(2) is calculated, and it returns back the value, 2. Now, as F(3) finishes, i am sorry, F(2) finishes, F(3) resumes and it finishes, and finally, we get back to F(4). Now, f(4) finishes and returns back probably to the main method. Now, let us quickly try to see this in an actual compiler in an actual C++ code. Now, I have written a method Factorial, that takes as input n, and returns an integer here. I am using Visual Studio Compiler, and if you use some other compiler or some other syntax of writing C++, you will still get the logic right. So, what I will do here is that, I will take an input n, from the user, so I will ask the user that "Hey, give me an n!" and i will input this n, and then I will have another variable result, that will make a call to, that will store the output after Factorial(n) returns, and we will simply print this result. Now, let us run this and see what happens. So, let's give n=5. And this gives us as output 120, which is Factorial(5). Now, I will try to do something else here, i will first remove this else condition, because it is redundant, we do no need to put this because once we return something, the program does not execute any further in that function. Now, what I will do is that, I will have a variable say f, that will store this particular value, and we will return this F here. Now, I will try to write two statements, one in the beginning. I will say that "I am calculating F(n). And, one, after this recursion is complete, and I have the value in F, I will say that I am done and F(n) is actually equal to F, I will put an endline here. So, basically what I am trying to do here is that when I am entering this function, I am printing something like "I am calculating F(n)", So, if n is 5, we say "I am calculating F(5) and then F(4) and so on". And, when I have this particular value, F, then I am saying that ok, now I have F(5) is equal to this. Let's quickly run this programme, and see what happens, So, let me give an input, and this time again we will give 5. Now, let us see, what we are printing here or rather the program is printing here, It says first that, I am calculating F(5), but it does not say immediately in the same function, that I am done with F(5). It kind of pauses here, and it goes to calculate F(4), similar to what we have shown you earlier, and then again it does not say I am done with F(4), it goes on to calculate F(3), and then F(2) and then F(1), finally to F(0). And, for F(0) we have not printed anything here, that I am done or something, so, first F(0) finishes, then F(1) finishes, and we come back finally like F(2), F(3), F(4) and F(5), and finally F(5) is 120. Now, a very common error while doing recursion is that, when we do not take care of the base condition well ,or rather, the termination condition for the recursion well. So, if you do not write this termination condition well, your recursion could go on endlessly causing your memory to overflow and your program to crash. So, a lot of things happen behind the scene when you write recursion. Recursion is often very simple to write, and easy to read, but it's really really important that we understand all the things that happen behind the scene. In the next lesson, we will show you another implementation of recursion, which is Fibonacci sequence and we will show you what other things to take care of while writing recursion. And why recursion may not be the best thing to write always! So, Thanks for watching!