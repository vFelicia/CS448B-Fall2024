In this lesson, we will solve a very famous programming interview question and the question is that given a sorted list of integers, we want to find out how many times a particular element occurs in this list. So let's say we are given list in the form of an array. Here we have an array of size twelve and the elements are in increasing order. Now how many times does number five occur in this array? 5 occur five times and how many times does number two occurred in this array? 2 does not occur in the array. So we will be given any such sorted array A and a number X and we have to find out how many times this number X exists in this array A. Now we want to solve this problem programmatically. So let us think through the different approaches that we may want to follow. The simplest approach is that they can scan the whole array and count the occurrences of X in the array. So if I have to write a function FindCount() that we will take as argument the array, its size n and element X to be searched for. The element X for which we want to find the count. so the logic would be pretty straightforward, we will take a variable initially, let's say the name of the variable is count. And we initialize it to zero and then we run a loop starting 0 till n1 and if A[i] or the element at index i is equal to element X,we increment count so count becomes count+1 and finally when we come out of this loop, we return count. So we are performing a linear search where we are scanning the whole array to search for element X. We could optimize this algorithm a little bit, something like this because the array is sorted, once we reach the size when A[i] becomes greater than X, we can stop counting but still in the worstcase this loop will run and n times when all the elements in the array are same. then this loop will run n times, so in the worst case this algorithm, the runnning time of this algorithm is proportional to N. In other words the time complexity is be O(n). This is a very simple solution for this problem and if you give this solution in a programming interview, the interviewer would be like "I don't like this!" "Give me something better". So how do we find out a better solution? Whenever in a problem we are given a sorted data or a sorted collection, we should try to think about applying one very famous algorithm that makes the best use of this property that the data is sorted and this algorithm is binary search. So can we make use a binary search in this problem?. One thing that you can do is that using binary search we can find out any occurrence of the number X in the array. So let's say in this example we want to find out count of number 5. So let's say we will find out using binary search in O(logn) time that number 5 exists at index 6. Now because the array is sorted, all occurrences of 5 will be adjacent to this. So we can go towards higher indices, starting this index and look for all the 5 and then we can go towards the lower indices, and look for all occurrences of 5 but once again if the whole array is number 5 only all elements being same still is a sorted array, then we will scan all the elements, we will access all the elements in the array and eventually the time complexity will be O(n) only. The time taken will be proportional to n only in the worstcase. So using binary search kind of does not give us much advantage, if we use binary search in its basic form. O(n) because to perform binary search we will take O(logn) then to find out all the adjacent occurrences of X we will take O(n) in the worst case so for higher values of n log(n) is negligible in comparison to n, so this is eventually O(n). We are not writing, writing pseudo code for this approach. We will that as an exercise for you. With these two approaches we are still O(n) in the worst case. so what do we do?. Well if you'd remember from our previous lessons on binary search, we can write a binary search to find out the first occurrence of an element in an array and similarly we can write a variation of binary search to find out last occurrence of an element in an array. and this forms the basis of our third approach. And I'll clear some of this and make some space. Okay so we can use one variant of binary search to find out the first occurrence of an element in array and we can use another variation of binary search to find out the last occurrence and if we know the last and the first index at which the element occurs then we also know the count of it in the array. So once again we will write a method FindCount() that will take an array A, its size n and element X and let's say we find the first occurrence of the element in the array, using the method. FindFirst() which is a variation of binary search and we will use another method call to another variant of binary search that will give us the last occurence of the element in the array then we can return count as last index first index + 1, and I'm not handling the case here when the element is not present in the array,let's say we will handle it ,well in our actual implementation. Okay, so that first method call if we are using binary search will work in O(logn) and the second method call to find out the last occurence will also work in the O(logn). So overall the time complexity to find out the count of an element in the array would be O(logn). and that's really great. We have described how to find out the first or the last occurrence of an element in a sorted array using binary search. We had written the pseudocode for the algorithm in our previous lesson and there is a link to the previous lesson in the description of this lesson but let us now go and write some real code to solve this problem. I will write a C program.let us first write a simple normal binary search and then they will modify it to find the first or the last occurence, let's say we have a method BinarySearch() that gives me index of element X in the array. In binary search we first define 2 indices low and high to variables low and high initially set to 0 and n1 respectively and then we find the mid element as low+high/2 and then we compared the middle element with the number X and if we if middle element = X, we have found our elements so we simply return the index mid, else if X < middle element because array is sorted, remember array being sorted is a precondition of binary search we set high as mid1 kind of saying that search in the segment left to the middle element and if X is greater than the middle element, we add just low to mid+1 and we keep repeating this process again and again till the time we have a valid segment and a valid segment is still the time low <= high and if we come out of this loop without finding anything then we return 1 to say that X does not exist in it. Problem with this implementation is that as soon as we find any X, We return. So there is no guarantee that we will find the first index or the last index. If there are duplicates in the, duplicates of X in the array. so what we do is we will, what do we do is we will modify the algorithm slightly. We will have another variable initialized to 1 and now when we find X then we do not return an exit, we update that result variable to kind of say that okay this is the lowest index of X so far and then we continue the search so if we want to find out the first occurrence then we adjust high to mid 1. So we update result and go on searching towards lower end, this is lower segment and finally when we come out of this loop then we return this result. If we do not find anything any occurrence of X we will simply return 1 because this was initialized to 1. Now this implementation will give us the first occurrence of X in the array. and what if we wanted the last occurrence?. The only difference would be that we will go on searching towards searching right or higher indices so we will say that low = mid+1. I'll go on searching towards the higher indices Now I want 2 different functions for finding out the first or the last occurrence but if you see there is differense in only one line in these two implementations. So what I will do is I will use the same function to retrieve both first and the last index based upon another argument, a flag. So let's say we have a flag as a boolean parameter. Search first, if it is true we want to search far the first occurrence and if it is false then you want to search for the last occurence So if we want to search for the first occurence then we want to, in the case when A[mid]=X, we want to adjust high = mid 1 else we want to adjust low to mid+1. Okay let us now write the main method. what I will do is , I will first initialize an array and I will ask the user to input a number X. Now we want to find out the count of X so we will first make a call to binary search matter to find out the first index in the array, so we will pass the array A,the number of elements in the array which is 12 and we may also calculate the number of elements using this particular equation, size of A upon size of A[0], size of the number of bytes in the whole array upon the number of bytes in each integer, in each element and we want to search for X and we will pass true because in our method declaration if this flag is passed is true then we search for the first index else we search for the last index. Now if first index is returned as 1 then the element is not in the array, so no need to find the last index we can simply print that the count is 0 else we find out the last index and this time we make the call to the same function BinarySearch() with the only difference that this time we will pass the flag as false. So we say that hey! give me the last index and we will print count as last index first index + one so this is our code , this is our method binary search and we have made call to binary search twice to find out the first and the last index and we decide first and the last index using this flag Let us now run this code and see what happens. Let's say, we want to find out the count of number 3. then this gives us that 3 occurs thrice which is right let's now try number 5 and count of 5 is five and lets give x =2. 2 is not present in that array. so the count will be 0. so this is an optimized algorithm to find out count of an element in a sorted array. This is a classic implementation of binary search In the coming lessons we will see more problems on binary search. So thanks for watching!