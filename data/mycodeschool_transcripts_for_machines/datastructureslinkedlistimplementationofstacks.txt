In our previous lesson, we saw how we can implement stack using arrays, now in this lesson we will see how we can implement stack using linked list. For this lesson, I'm assuming that you already know about both stack as well as linked list. Stack as we know from our discussions so far is called a last in first out data structure. Whatever goes in last in a stack comes out first. It's a list with this restriction that insertion and deletion must be performed only from one end that we call the top of stack and insertion in a stack is called PUSH operation and deletion is called POP. To implement a stack, all we need to do is enforce this behavior in any implementation of the list that insertion and deletion must be performed only from one end and we can call that end TOP of stack. It's really easy to enforce this behavior in a linked list. I have drawn linked list of integers here. This is logical representation of a linked list. A linked list is a collection of entities that we call NODES. Each node contains two fields, one to store data and another to store the address of the next node. Let's assume that these nodes are at addresses 100,200 and 400 respectively, so I will fill up the address part as well. The identity of a linked list is the address of the first node that we also called the HEAD node. A variable stores to address of head node, we often name this variable as head. Unlike arrays linked lists are not of fixed size and elements in a linked list are not stored in one contiguous block of memory. We already know how to create a linked list or insert and delete elements from a linked list from our previous lessons. I'm just doing a quick recap here. To insert an element in a linked list, we first create a new node which is basically blocking some part of memory to store our data. In this example here, let's say for my new node am getting address 350. We can set the data part of the linked list as whatever value I want to add in the list and then I need to modify the address field of some of the existing nodes to link this node in actual list. Now for a stack we want that insertion and deletion must always happen from the same end. We can use a linked list as stack if we always insert and delete a node at same end. We have two options, we can insert or delete from end of the list, what we also call tail or beginning of the list that we call head. If you remember from our previous lessons, inserting a node at end of linked list is not a constant time operation, the cost of both insertion and deletion at end of linked list if we have to talk about the time complexity of it is O(n). Here in the definition of stack we are saying that push and pop operations should take constant time or the time complexity should be O(1), but if we will insert and delete from end time complexity will be O(n). To insert a new node in a linked list at the end, we need to go to the last node and set the address part of that node to make it point to the new node. To traverse a linked list and go to the last node we should start at the head or the first node, from first node we get the address of the second node so we go to the second node and from second node we get the address of the third node, it's like playing treasure hunt, you go to the first guy, ask the address of the second guy and then you go to the second guy, ask the address of the third guy and so on. Now once I have reached this last node in my example here, I can set its address part to make it point to the newly created node. All in all this operation will take time proportional to number of elements in the linked list. To delete a node from end, once again we will have to traverse the whole list. We will have to go to the second last node, break this link, we will set the address field as zero or NULL. and then we can simply wipe off the last node removed from the list from computers memory. Once again the cost of traversal will be O(n). So inserting and deleting at end or tail is not an option for us, because we will not be able to do push and pop in constant time, if we choose to insert and delete from end. The cost of inserting or deleting from beginning however is O(1). It will take constant time to insert a new node at beginning or delete a node from beginning. To insert a node at beginning, we must create a new node. In this example here, once again I have created a new node, let's say the address of new node is 350, I will insert some data in the first field of this node. Okay so to insert this node at beginning, we just need to build two links. First we need to build this link, so we will set the address here as whatever the address of the current head is and then we can break this link and make this guide the new head by setting it's address here in this variable named head. To delete a node in this example here, we will have to first cut this link and build this link which will mean resetting the address in this variable head and then we can free the memory allocated to this particular guy, this particular node. Deletion from beginning once again is a constant time operation, so this is the thing if we will insert at beginning and delete from beginning then all our conditions are satisfied. So linked list implementation of stack is pretty straightforward. All we need to do is insert a node at the beginning and delete a node from beginning. So, head of the linked list is basically the top of stack. I would rather name this variable top here. I will quickly write a basic implementation in C. I'm defining node as a structure in C. I want to create a stack of Integers, so first field in the node is an integer, another field is pointer to node that will store the address of the next node. We have seen this definition of node in all our previous lessons on linked list, the next thing that I'm doing is I'm declaring a variable named top which is pointer to node. and initially I'm setting the address in it as NULL. I'm using variable name top instead of head here, when top is NULL our stack is empty, by initializing top as NULL I'm saying that initially my stack is empty. Now let's write push and pop functions. This is my push function. Push is taking an integer X as argument that must be inserted onto the stack. The first thing that we are doing in push function is that we are creating a node using malloc. Let's say in this example in this logical representation that I'm showing here, I'm performing a push operation so I'm making a call to push function, passing it 2 as argument. So a node is created in memory, is created in what we call the dynamic memory or heap, let's say the address of this node is 100. This variable is basically a pointer pointing to this node, temp is a pointer pointing to this node in the next line we are setting the data field in this node. We are dereferencing temp to do so, then we are setting the link part of this newly created node as existing top. So we are building this link and then we are seeing top equal temp So we are building this link. This is simple insertion at beginning of a linked list we have one complete video in this series on how to insert an node at beginning of linked list. Let's do one more push. Let's say I want to push 5 on to the stack this time. Once again a node will be created, we will set the data and then we will first point this guy to the existing top and then make this pointer variable point to this guy. The new top, let's say the address of this guy is 250, so the address in this variable top will be set as 250. After the second push this is how my stack will look like. Top here is a global variable so, we do not need to pass it as argument to functions, it is accessible to all the functions. In an objectoriented implementation it can be a private field and we can set it as NULL in the constructor. Okay let's now see how push, sorry pop function will look like. This is my pop function. Let's say for this example I'm making a call to pop function. If the stack is already empty we can check for the stack is empty or not by checking whether top is null or not, if top is NULL, stack is empty. In this case we can throw some error and return for this example here stack is not empty, we have two integers in the stack. what we are first doing is we're creating a pointer to node temp and pointing it to the top node and now we are breaking this link we are setting the address in top as address of the next node and now using this pointer variable temp, we are freeing memory allocated to the node being removed from the list. Once I exit the pop function, this is my stack so this pretty much is the core of our implementation. I would encourage you to write rest of the stuff yourself. You can write code for operations like top() and isempty(). Linked list implementation of stack has some advantages. one of the advantages is that unlike array based implementation we do not need to worry about overflow, unless we exhaust the memory of the machine itself. Some amount of extra memory is used in each node to store reference or address but the fact that the use memory when needed and release when not needed is something that makes push and pop operations more craze full. So this is linked list based implementation of stack. In our coming lessons we will solve some problems using Stack. This is it for this lesson. Thanks for watching.