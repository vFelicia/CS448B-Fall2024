So, in our previous lesson "Introduction to pointers", we learnt the basics of pointers. In this lesson we will see how to work with pointers in some real code examples, but before that a quick recap. Pointers are variables that store address of other variables. We declare a normal variable with a syntax like the data type or the variable type followed by the variable name, but we declare a pointer variable with a syntax datatype and an asterisk sign followed by the variable name. We need an integer pointer variable to store the address of an integer. To store the address of, say a character variable we will need a character pointer. So, the same syntax will be used. We put an asterisk sign and let's say the name of the variable is 'P0' So, 'c' is a character variable and 'P0' is a pointer to character And similarly, we can have a pointer to double. And we can also have pointers to a user defined structure, or a user defined class also. And to get the address of a variable, we write a statement like, P = &a (ampersand 'a'). Now, this ampersand works as an operator that gives us the address of 'a', and what happens in the memory is something like this, variable 'P' stores the address of variable 'a'. So in this figure here P's value is 204 which is the address of 'a', so 'P' points to 'a', and using 'P' we can also get the value of 'a'. So let's say if 'a' is 8 and we use a star operator (*) in front of 'P' then *P gives us 8, which is value of 'a'. If we try to print *P, it gives us 8. Let us now try to see some of these things in real code. Ok, so time to see things moving in a real C program. Now, what I will do is I will play a game with you. I will write some print statements and you need to guess, what will be the output? So what I will first do is I will declare an integer variable 'a', and then I will declare another variable which will be pointer to integer and now I will write a print statement where i'll be printing 'p'. Now, what will be the output of this program? Ok, so let's run this program. Oops! this gives us an error. And if it is too small for you to read, then this is giving an error that the variable 'p' is not initialized and we are using it without initializing. So, that's why the program is crashing. So now I will write a statement. p = &a (ampersand 'a') Now ampersand of a (&a) is nothing but address of a. Now lets run this again. Okay so this prints an address. And how do you know that this is the address, or this is the right address that is stored in 'p'. So, I'll write another print statement. and now i am printing *p. Now star operator, when it is put in front of the address, then it gives us the value at that particular address. Okay so what will be the output of the second print statement? So when we run this, the first line gives us the address that 'p' points to and this address is different, than the previous address, because every time the program runs afresh, a new address is allocated, but the value at 'p' is some garbage value, is some integer that I am not sure what it is. This is happening because I have not initialized 'a' and although memories are allocated for 'a', there is some garbage value there that I do not know about. Ok, so let's initialize 'a'. Let's say 'a' is equal to 10. And now the second line prints the value of 'a', and now i will write another print statement, and this time I will print &a (ampersand 'a'). Now what should be the output of this third print statement? And this should be pretty easy to guess. Ampersand operator (&) gives us the address and that's why the third line is also the address of 'a'. Infact that's what we have done here. We have assigned 'p' the address of 'a'. We have used the operator ampersand. Now, what I will do is, I will modify the value in 'a', using the pointer 'p'. And to do so i will write a statement like *p = 12 and this is read as value at address 'p'... Value at address being pointed by 'p' is now 12. This concept is called dereferencing. So now if i try to print 'a', and let's also put one print statement for 'a', before we modify the value, and let's run this. So the first print gives me 10, which is the value that we have initialized 'a' with and the second print gives us a = 12 a = 12 because we modified the value using the pointer. Okay, so one more thing that i'll do here now. I will have another variable 'b', that will have value 20. and now what i will say is *p or value at address 'p' is equal to 'b'. And the question now is that, will the address in 'p' change now to point to 'b'? Well.. No.., unless you explicitly write a statement like, p = &b this reverse operation will not happen. What we are doing here is actually, only putting in the address of 'a', the value that 'b' has, but we are not pointing to 'b' and this will get clear, only if we write some more printf statements. So before writing the statement, I am writing two print statements. one to print the address and one to print the value and after we write the statement, i will write two more print statements trying to print the address and value again so let us see what the output is now. ok, so address of p is intitally three one four four five seven six and value is 10 and after the statement star p equal to b, only value is modified and the pointer still points to a so a now becomes twenty but the address does not change now one more thing sometimes we declare and initialize a variable in the same statement so instead of writing this a equal to ten here we could simply say that int a is equal to 10 so we can do so for the pointer variable as well we could simply say for these two statements one simple statement like int star p is equal to ampersand a and we will not need the statement this one statement is same as saying the earlier two statements the syntax of declaring pointer some people write this asterix sign after int and do not write it in front of the variable name this also works and this is also fine so you can write int star which means pointer to integer and then you can write the variable name and this will also work okay so now we will point uh .. we will talk about a concept we will talk about the concept of pointer arithmetic but before that I will write this ... rewrite this declaration and initialization like before in two statements I like it better this way. It's less confusing now I will write two print statements here in the first statement I will print p and in another statement i will print p plus one Now, is it really possible to do so? can we really increment and decrement a pointer variable Well yes ! we can do so so now let's assume that the address stored in p is something like 2002 so any guesses what p plus one will be Will it be 2003 ? Well no .. (p + 1) will be 2006 this is because if p is an integer pointer increamenting it by one unit takes us to the address of the next integer and because the size of an integer is four bytes so, to go to the next integer address we need to skip 4 bytes. so, p plus one increments p by 4 bytes I'll write another print statement in which I will print size of an integer variable and i will write something like sizeof integer is and we have a function in C, sizeof that gives us the size of the data type so this statement, this print statement will give us the size of integer and let's write in the first and third print statements something like address p is blah and address (p+1) is blah.. so let's now run this and see what happens okay.. so the output is address p is4 586052 which is some address and then we print size of integer is 4 bytes. so, for this particular compiler the size of an integer is four bytes and address (p+1) is four bytes more than address p you can try this thing out for a character pointer or a double pointer or a pointer for some other data type okay so we could also increment this by 2 and what happens if we increament this by 2. well, it will increment the address by 8 So, this will be like 2010 p plus 2 will be 2010 and this 2002 and 2010 is something that i have picked up randomly just for the sake of example ok so now once again what if i want to print the value at this particular address so i am printing two more lines here now. I am printing value at address p and i will print *p. It gives us the value at that address and we will print another line we will say that value at address (p+1) is and this should be *(p+1) we put the star operator in front of the address okay, so now what will be the output okay so the output is that address p is some address and value at address p is 10 which is alright because we had stored the address of variable a in p now next line is size of integer is 4 bytes and and p plus one is four more than the address p and the value at address p+1 is some integer value that I do not know about in fact this is some garbage value because because we do not really have an integer allocated to this particular memory address and this is one dangerous thing about c using pointer arithmetic using pointer manipulation you can reach to to any address and sometimes these kind of operations can bring some unwanted behavior to your program i recommend trying these things out, these snippets of code with other data types like characters or float and the results will be similar. So, this was some playing around with pointers and in the coming lessons we will talk more about pointers and we will talk about pointers in the context of arrays So, thanks for watching !