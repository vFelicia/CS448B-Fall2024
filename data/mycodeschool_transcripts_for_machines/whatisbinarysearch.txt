In this lesson we will talk about one of the most famous, and fundamental algorithms in computer science binary search We find application of binary search in a large number of problems in a large variety of problems in computer science but here let's try to learn it in it's simplest form and to do so, we will define a problem first. And the problem is given a sorted array of integers a sorted array means that the elements in the array are arranged either in increasing order or in decreasing order like in this array here the elements are arranged in increasing order let's say the name of this array is A the size of this array is nine so we have index starting zero till eight now given such an array and a number or an integer x we want to find out whether x exists in this array or not and if x exists in this array, then we want to find out the position at which x exists in this array so for example if x is 81 does 81 exist in the array yes 81 exists in the array A and it exists at index seven Does twenty five exist in the array. No. twentyfive does not exist in the array Does twenty one exist in the array, yes twenty one exists in that area at position three, at index three now what would be the logic to find out whether x exists in this array or not one simplest approach can be that we can scan the whole array to find out the desired number so we start at index zero and compare this element with x if it is equal to x, then we are done with our search, we are, we have found the element in the array if not we go to the next element and we keep on comparing with the next element until either we are finished with the array or we find the number so let's say if we wanted to find sixtythree in this array then our search will be over when we reach index six we start at index zero and our search will be over at index six if we wanted to find out twenty five our search will be over at index eight with the conclusion that twenty five does not exist in the array this approach will work irrespective of whether the array is sorted or not and if i have to write the code for this it will be pretty straightforward let's say i want to write a method Search that takes an array A it's size n and the element sorry, the number x to be searched for and the code would be we will run a loop starting 0 till n1 so for i starting 0 to n1, if the element at index i is equal to x then we return i which means returning the position at which we have found the element x and our search will be over and if we cannot find any such i then we return 1 let's say returning 1 means that we could not find the element we could not find x in the array A Now, with this algorithm, if we are lucky we will find x at the first position itself so in the best case we will make only one comparison and we will we will be able to find the result. In the worst case when x would not even be present in the array, we will scan the whole array, we will make n comparisons with all the elements in the array and then we will be able to give back a result that hey x does not exist in the array so the time taken in the worst case is definitely proportion to the input size of the array sorry, size of the array one in other words we see that this would be bigoh of n in terms of time complexity it's always good to analyze the running time of an algorithm in the worst case and find out the upper bound of the time taken now in this case the time taken grows as a linear function of n so, we also call this search linear search and once again if we are using linear search, we are not using any property like the array is sorted or not whether the array is sorted or not, this will work now let us try to improve this algorithm using the extra property of the array that it is sorted and i will make some space here first let us say we want to find out whether thirteen number thirteen exists in the array A so x is thirteen and we want to find out whether x exists in the array A now we will use a different approach this time, instead of instead of comparing x with the first element as we do in the case of linear search, we will compare it with the middle element in the array Now the size of this array is nine, so the middle element will be at index four Now, there can be three cases here case one can be that x is equal to the middle element if x is equal to the middle element, we have already found x in the array case two can be when x is less than the middle element and case three can be that x is greater than the middle element clearly if x is equal to the middle element, our search is over because we have found x in the array if x is less than the middle element then because the array is sorted it lies before the middle element and we can discard the middle element middle element and all the elements after middle element similarly if x is greater than the middle element it lies after the middle element so we can discard all the elements before the middle element and of course the middle element as well so in case 2 and 3, we discard half the elements from our search space and reduce our search space so in this example when x is 13, initially our search space is the whole array, x can exist anywhere in the array Now, we compare it with the middle element which is thirty six Now, x is less than thirty six, so it exists it should exist somewhere before thirty six, so we discard all the elements after thirty six and thirty six as well so now the problem gets redefined, we need to search x only between index zero to three so how do we keep track of the search space we keep track of the search space using two indices start and end so initially the start would be zero and end would be the last element in the array, in this case the index eight, because initially the whole array is our search space and we calculate mid as start plus end upon 2 now once we find out our reduced search space we adjust start and end accordingly, so in this case after comparing 13 with 36 and discarding half of the array, our end now becomes index three which is nothing ..mm. but one less than the middle element now we again find out the middle element in this reduced search space so here the middle element will be three plus zero by two, if we take only the integral part three plus zero by two would be one point five and if we take the integral part the middle element will be index one once again is it equal to x no, six is not equal to thirteen is x less than the middle element, is it case two? no it is not x is greater than the middle element so this time we discard the middle elemet and all the elements towards its left and this time we shift start to mark our new search space now the new search space is starting at index two and ending at index three now what is the middle element, three plus 2 is five, five by two is two point five and the integral part is two so this is our middle element so x is now equal to middle element. We have found our element So, we are done with our search. this kind of search where we reduce the search space into half at each comparison is called binary search once again, we are able to reduce the search space by two or in other words we are able to reduce the search space into half only because the array is sorted array being sorted is a precondition for binary search Ok, so let us now write code for this algorithm I will write a method binary search that will take as argument an array A it's size n and a number x to be searched for in the array and i will initialize 2 variables start to 0, and end to n1, so start and end define our search space, initially the whole array is the search space now i will write a condition here while start is less than or equal to end and i'll come back to why I am writing this condition so while this is true, start is less than or equal to end we will find out the middle index of the search space as start plus end upon 2 and now we will write three cases if the middle element is equal to x then our search is over we return the index stored in the variable mid and exit from the function if x is less than the middle element then we need to discard all the elements having index greater than or equal to mid so our end of the search space now becomes mid minus one, and in the third condition which will be x greater than the middle element which will be the default condition after these two if and else if we need to discard all the element with index less than or equal to mid so our start becomes mid plus one and if we exit this while loop without returning anything then we return minus one which will mean that we were not able to find the element x in the array now why this while statement here with a condition start less than or equal to end what we are basically doing in our algorithm is that we are reducing our search space recursively by adjusting the start and the end pointer. Now there must be an exit condition to our recursion the exit condition can be, either we find the element in the array, so we return and exit or we exhaust the whole search space when start is equal to end or start is less than..mm.. end then we still have search space. When start is equal to end, then our search space has only one element so when this condition becomes false, we have exhausted our search space, we need to exit the loop and we need to return 1 to tell that the element uh... the number x does not exist in the array now once again in this case in the best case we can find the element x in just one comparison,when the first middle element itself will be the element x in the worst case we will keep reducing the search space till the search space become one element so from n, we reduce to n/2 and from n/2, we reduce to n/4, and we go on till our search space becomes one now how many step does it take let's do some maths here. Let's say it takes k steps to reduce n to 1 by dividing by two at each step so n by two upon k will be equal to one and if you solve this then k will be equal to log of n the base will be 2 so in the worst case binary search will take log n comparisons and so the time taken also in the worst case is proportional to log n, or in other words uh... it is bigoh of log n in terms of time complexity and bigoh of log n is a lot lot more efficient than uh... O(n) algorithm so this was binary search, we will take more problems on binary search in the coming lessons. Thanks for watching !