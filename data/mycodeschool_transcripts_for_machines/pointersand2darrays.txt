In this lesson, we're going to talk about pointers and multidimensional arrays, as we have seen in our previous lessons. The concepts of pointers and arrays go together. We have already talked about pointers in context of onedimensional arrays how we can work with onedimensional arrays using pointers. Now let's see how we can work with a twodimensional array or a threedimensional or a multidimensional array in general using pointers. To understand this concept once again we first need to understand how multidimensional arrays are organized in computers memory, let's first go back to the organization of onedimensional arrays in memory. When we declare a onedimensional array something like this, let's say we are declaring an integer array 'A' of five elements (A[5]) then basically what we're doing is we're creating five different integer variables that we can name A[0], A[1], A[2], A[3] and A[4] as one contiguous block of memory. What I'm showing here is a section of computers memory array 'A' let's say is stored in the section of memory and the starting address of 'A' is 200. As we know each byte in a computer's memory has an address and if we assume that an integer is stored in four bytes which is what it takes in a typical compiler then the block of four bytes starting address 200 will be A[0] as I'm showing here, block of four bytes starting address 204 will be A[1] next block of four bytes starting address 208 will be A[2] and so on. I'll fill in some values here. We have seen this earlier also in our previous lessons if we write a statement like this then this is all right if I just used a variable name 'A' then name of the array in an expression basically returns a pointer to the first element of the array because this is an array of integers so each element will be an integer hence 'A' returns a pointer to integer. Once I have written a statement like int *p equal A. I can use pointer arithmetic and derefrencing to access all the elements in the array. If I would just try to print the address stored in 'P' and I'm not using full printf statement here my output will be 200, if I would simply try to dereference 'P' then output will be 2. If I would try to print something like *(P+2), then output will be 6 because we have an integer pointer adding 1 will take us to the address of the next integer which will be four bytes ahead, adding 2 will take us to the address of next to next which will be 8 bytes ahead if we would be printing (P+2) it will be 208 and if we would de refrence and we would print *(P+2) then it will be value 6. We have already discussed pointer arithmetic in our previous lessons. Now language gives us this flexibility that we can use the name of the array just like a pointer for all the derefrencing so instead of doing all of this printing with P, if we would do all of this with 'A' it will still be the same. Infact *(A+i) is same as A[i], these are alternate syntax and (A+i) is same as &A[i] both will give us the address of the Ith element in the array. Please remember that even though we can use the name of the array just like pointer for all this dereferencing and arithmetic. It's not seem as a pointer variable so we can do something like P equal A like what we have done here so this is all right but we cannot do the other way, we cannot say A equal P, this will give you compilation error. So this is pretty much how we would use pointers with onedimensional arrays. Let's now say we want to create a twodimensional array. I will declare a twodimensional array of integers named B something like this, now what we're doing here is we are creating array of array. We are creating two onedimensional arrays of three elements each. This time B[0] and B[1] are both onedimensional arrays of of three integers each. A onedimensional array of three integers would be 12 bytes if each integer is 4 bytes in size so if I have to show this in memory the first block of 12 bytes starting address 400 will be B[0] and the next block of 12 bytes starting address 412 will be B[1]. As we had set name of the array returns a pointer to the first element in the array, this time each element is not an integer, each element is a onedimensional array of three integers so if I would write a statement like this int *P equal B then this will give me a compilation error because 'B' will return a pointer to 1D array of 3 integers and not just a pointer to integer, the type of a pointer matters not when you have to read the address, it matters when you derefrence or when you perform pointer arithmetic, it's really important that we understand this. We can define a pointer to 1D array of 3 integers like this and now if I'll equate this with 'P' this is all right Equate 'B' with 'P', this time if I would print just 'B' which is same as printing address of B[0] this will be 400. If I will print *B which will be same as B[0] then B[0] this time is variable name for a onedimensional array of 3 integers, so just using the name B[0] will return us pointer to the first integer in B[0] which will be accessed as B[0][0] so I'm putting this '&' sign here in front of B[0][0]. First integer in B[0] will be this block of four bytes its address once again is 400. Okay now I have also created three blocks of four bytes each in both B[0] and B[1] and also filled in some values. Now I'm going to write some prints statements and I want you to guess the output. What will be the output if I'll try to print B+1. I will write the address of each block of four bytes in the 2D array the address of a block is the address of the first byte in the block. Okay so what will be the value of B+1. B this time is returning us a pointer to onedimensional array of 3 integers so if I would do a pointer arithmetic like adding plus 1 we are moving to the next 1D array of three integers so we will be moving to address four hundred plus size of onedimensional array of 3 integers in bytes, so output will be 412 which makes sense because B+1 is same as &B[1] or address of B[1] and address of B[1] is 412. Okay now what if I print *(B+1), when we are putting an astrix signs when we are trying to derefrence this is when the type of pointer becomes important, 'B' is a pointer to onedimensional array of three integers, so B+1 is also a pointer to onedimensional array of 3 integers and when we will derefrence we will get this whole onedimensional array of three integers starting address 412 *(B+1) is same as B[1] so we will get B[1] now printing B[1] means using the name of this onedimensional array B[1] which should return us the pointer to the first integer in B[1], so *(B+1) is basically pointer to this integer at address 412. Once again this output will be 412. All these expressions *(B+1) or B[1] or &B[1][0] are returning us pointer to integer. Okay now you need to gear up because I'm going to give you some tough ones to decode. What will be the output if I will print *(B+1)+2 take some time and think about it. *(B+1) as we saw above will return an integer pointer to first integer in B[1], to the integer at address 412. Adding 2 here is performing pointer arithmetic because *(B+1) is a pointer to integer storing this address 412 adding 2 is basically going to the address of next to next integer which will mean skipping 8 bytes and and going to reference integer at address 420 *(B+1) in this expression can be written as B[1] simply B[1] because they are substitutes for each other, there alternate syntax. So this is a same as B[1]+2 and once again these expressions are returning pointer to integer they are returning pointer this element B[1][2] and that's why we can also &B[1][2]. All these three once again are same. Let's do one more print. If you can get this one right, I can say that you are good working with twodimensional arrays using pointers what will be the output for this expression *(*B+1). What will be the output for this expression. Think about it. Whenever you encounter an expression with pointer arithmetic and derefrencing then you must go step by step. Here 'B' is returning us pointer to onedimensional array of size three, onedimensional array of three integers and derefrencing it will give us the onedimensional array so *B as we know we'll give us B[0] as should be same as B[0], now B[0] in my expression because B[0] is named for a onedimensional array returns me pointer to the first integer in the onedimensional array, so B[0] returns pointer to integer we will get a pointer to this integer at address 400. Now what will happen if you will add 1 to an integer pointer it will take you four bytes ahead to the next integer it will return you pointer to the next integer so we will get a pointer to this integer at address 404. (*B+1) is basically &B[0][1] and with this final derefrencing we can get rid of this '&' so overall expression will be B[0][1] which is three. For a twodimensional array B[i][j] where 'B' is name for my two dimensional array and 'i' and 'j' are some indices can be written as *(B[i]+j), and once again B[i] can be written as *(B+i), so these three expressions are same. I would recommend trying all of this in real code. So far this discussion has been about working with two dimensional arrays using pointers. We will stop here for this lesson. In another lesson, we will play with some real code and we will also discuss how we can work with an array of further higher dimension like a threedimensional array, We will also discuss passing of arrays to functions through pointers. This is it for this lesson. Thanks for Watching!