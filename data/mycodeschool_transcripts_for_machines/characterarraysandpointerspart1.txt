In our lessons so far, we have seen how the concepts of arrays and pointers go together. Now, in this lesson, we are going to talk about character arrays, how we can work with character arrays using pointers Now, when we talk about character arrays in c we basically want to talk about strings strings are group or set of characters and real world data like names phrases and sentences, all of these are strings to us. So, these are some of the examples of strings character arrays become all the more important because we use them to store strings and then perform a lot of operations on strings like modifying a string, copying a string concatenating two strings or finding out properties of strings like finding out the length of a string. To be able to work with strings efficiently in C, there are a couple of things that we need to understand the first thing that we need to understand is how we store strings in character arrays. To be able to store a string in a character array, the first requirement is that the character array should be large enough to accommodate the string and what is a large enough character array? a large enough character array is a character array of size greater than or equal to number of characters in the string plus one. So let's say if our string is a name of four characters, uh... like john then the size of the array should be greater than or equal to five, and now the obvious question would be why do we need space for one extra character? Isn't it that if we declare a character array of size four, we can store all the characters in john. J will go to zero' th index 'O' will go at the 1th index, 'H' and 'N' will go at second and third index respectively So, I am storing all the data, isn't it? let's try to understand it this way Let's say we have a character array of size 8, uh... let's say this is a logical view of our array, C, and we want to store the string john in this particular array, we have indices from zero to seven this is an array of size eight so we can store 'J' at the 0th index, 'O' at the 1th index, 'H' at the 2th index, and 'N' at the 3th index, So, we have stored all the characters of the string 'JOHN' in this array uh... but if you see we have not stored one information uh... we have not stored the information that this particular character 'N' is the last character in the string so the string ends at index three so let's see if we pass this string to a function that has to print this string john or find out the length of the string that we have stored in the array, then how would the function know that the string is only till index 3, even though we have not filled anything in these indices at four five six and seven, there would be some garbage value there, so either we pass this extra information or we do something else. To store this information that this is the end of the string in the character array, this is the used part of the string, and this is the unused part. We use the simple design, and at the end of the string in the next position we put a null character, A NULL character has ASCII value zero, and we can put a NULL character at position four in this example something like this, Within single quotes we put, a forward slash and number zero, this is NULL character. All the functions for string manipulation in C expect that strings will be null terminated, so this is a rule A string in C has to be terminated by a NULL character, and that's why we need one extra space to store this null character. let us try to see some running code that will help us understand this concept better. what i have done here is i have taken a character array of size four, and i have filled in the characters but I have not used any space, to null terminate it, and then I am using the printf function, this %s tells that i want to print a string and then I am passing this array C, uh...let us run this program and see what happens, as we can see there are these bunch of characters that are getting printed after JOHN, and this is happening because we have broken the assumption that for the printf function that my string, that our string will be NULL terminated, so that's why this undefined behavior is coming if we change the size of the character array to five and put a NULL termination something like this at fourth index, and then things will be fine now even if we change the size of the array to twenty, printf function will print till it finds a null character. so it only prints the first four characters in the array, and it's not just the print function there are a bunch of functions we have this library string.h that gives us a bunch of functions for string manipulation, So, all these functions assume that the function will be null terminated, So, this is one contract that we have to follow uh... let's say we want to use the function strlen, string length to find out the length of the string. I will print something like this, lets run this and see. As you can see the output is Length=4, even though uh... the array is of size 20. So, string length function also counts till it sees a null character. In our program instead of writing these characters individually at these positions we could have used string literals. string literals are a group of characters within double quotation marks,so, we could have written something like this and this would have initialized uh... C as this string and the null termination for uh... string literal is implicit. It is always stored with a null termination in memory, Remember that when we declare and initialize a character array like this, this has to happen in one line. We cannot do something like this that we declare in one line and then we go on and modify this in the next line. This will be invalid We could also avoid writing this here, and this would have been fine In this case the size of C will be five units five bytes where one byte stores one character. So, it would be just enough to store the string 'JOHN'. So, if we try to print the size in bytes of Che using this sizeof function, uh... then, size in bytes is five, one character is stored in one byte, so space has been allocated for five characters, but the length is four, because the null connector does not count in the length, if we write something like C[4]= uh... this particular string literal,with four characters, this will give us compilation error, because the compiler will force uh... this particular array, to be of minimum size five There is one more syntax of initialization, we can put all these characters as a comma separated list within these braces, but in this case the null termination will not be implicit. We will have to do it explicitly and the size of the array has to be greater than or equal to the number of characters here so it should be greater than or equal to five. Okay so these are some of the ways to initialise character arrays, the next thing that we need to understand is arrays and pointers are different types, that are used in similar manner. Now, what does it really mean? Let's say we declare a character array C1 of size 6, and initialize it with this string literal, and let us say this is how it gets stored in the memory. Array is stored in one contiguous block of memory, so let's say the first character is stored at address 200, one character is of size one byte,so the next character will be at address 201 and the next will be at 202 and so on. Now, C1 is the variable name for this whole array, now what i will do is, i will declare a variable which is a pointer to character, let's name this C[2]. So, let's say we get this variable C2 somewhere in the memory. A pointer variable in a typical architecture is stored in four bytes So this variable will also have some address, say this variable is at address four hundred. I am just picking up these numbers for example sake. Now, what we can do is we can write a statement like this C2 is equal to C1 not even though C1 is a character array, is a variable name of a character array and C2 is variable which is pointer to character. This particular expression is valid. Just using the name of the array, actually returns the address of the first element in the array.So, what this expression what this statement will do is, it will fill in the address two hundred in C2. So, C2 now points to the first element in the array. Now, we can use this variable C2, which is a character pointer just like C1, to read and write into the array. So, if i write something like print C2[i] let's say we want to print C2[1] then the output will be 'e' and we can even modify the array. Let's say we want to modify the character at 0th index to 'A'. So, the string will be modified and will become this. When we write C2[i] for any position i, it is nothing but *(C2+i) So, C2 is the base address (C2 + i) will take you to the address of the ith element. So, in this case let's say C2+2 will be 202 and if we put this * operator,we are basically dereferencing and finding out the value. So, these two syntax s are alternate syntax s. And, even if it is an array name, we can write these two as substitutes for each other. So, this was all the similarity in how we actually use them use arrays and pointers to read and write. Let us now look at the differences. We cannot modify anarraywith a statement like this C2=C1 is valid but C1 = C2 is not valid. It does not make sense, this will give you compilation error. we cannot even say C1 is equal to C1 plus one. We cannot increment or decrement this variable C1. We can do it for C2 which is a pointer variable. We can say C2++. So, C2 now points toward the next element. With this statement here all that will happen is C2 will become 201. So, instead of pointing here it's now pointing to this particular element 'e'. To traverse an array we run a loop and we use a local variable, lets say i and increment it in the loop. If we have a pointer variable we can just keep on incrementing the pointer and we can traverse the list. We can traverse the array, we will keep doing this C2++. So, we must understand where we have an array and where we have a pointer. What we can do with which one! And now, the next thing that we need to understand is that arrays are always passed to functions by reference. Now when we pass arrays to functions we only pass the base address of the array in a pointer variable, and we do not pass a whole copy of the array. The compiler does not let you do that. We have talked about this in detail in our previous lesson Arrays as function arguments Let us try to look through some code and try to understand this better In my code i have declared a character array of size 20, and i have stored a string of length five in this character array The null termination i implicit if we are using string literal. Now i want to print this string but i do not want to use the library function printf. I want to write my own function print that i want to pass this array to the function and this function should print the string part in the character array uh... the argument to the function we have talked about this earlier, can be something like this to say that we are receiving an array here, but the compiler actually interprets this as this. So, the compiler forces that only the address of the character array or the address of any array be received as argument to the function, because arrays are large in size so it is inefficient to create a copy of the same array for each function Okay, so let's writet the logic now. Now, this print function does not have any idea that this particular array is of size 20. It only knows the base address. So, what we can do is we can have a variable i, initialize it to zero and we can see something like this while C[i] is not equal to null character, we can print the character C[i]. And then we will increment i, and when we find a null character, we can come out of this loop. and print an end of line. Once again this print function does not know that this character array is of size 20. It only knows the base address. and that's why in the printf function when we were not null terminating an array, we were printing all the garbage value even after the array was finished. Because, until we get a null character, we do not know when to stop and we keep on going into unwanted memory locations Now, this code should work! Yes, this is fine! In my code here, I am using %c here, to say that we want to print character and C[i], we can also write 8(C+i) as substitute for C[i] and that will also mean the same! Sometimes you will see this kind of syntax as we talked earlier,both of these syntax, *(C+i) and C[i] are valid, they are the same! There is one more thing in our code that we may do! We may not chose to have this particular variable i We could simply say that while *C is not equal to null, print *C and then increment C itself. And, this code will also work why this code will work, I leave it as an exercise for you to think. In the coming lessons, we will implement more functions for string manipulation. This is it for now! Thanks for watching!