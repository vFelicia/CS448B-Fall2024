Pointer is a very fundamental and important concept in programming, but a lot of beginner programmers find it difficult to understand pointers. So, in this lesson we'll try to demystify pointers. And all you need to know to understand this lesson, is how to write a basic C program, how to declare a variable and how to do simple arithmetic upon those variables. Okay, so let's get started. To understand pointers, we first should understand how various data types or various variables are stored in computers memory. Ok...so let's say, this figure in the right here, is computer's memory and when we talk about computer's memory in context of program execution, we mostly talk about the random access memory or the RAM. We often say that my machine has got 2 GB or 2 Giga bytes of RAM or 4 Giga bytes of RAM. Now, Let's say these segments or partitions that we are showing here in the memory is each one byte of memory. Now in a typical memory architecture, in a typical computer architecture of the memory each byte of the memory has an address. So, let's say uh... the first byte in this memory which we can assume to be, the lowest byte deep down here has an address 0 and address keeps on increasing as we go towards the top. So we go on like 0, 1, 2, and let's assume this particular address is 201, so the next byte would have an address of 202. And we'll go on like 203, 204 and so on. Now, when we declare a varriable in our program, let's say for example if we declare a variable 'a' of type integer then when this program executes, the computer allocates some amount of memory corresponding to this particular varriable. How much memory it allocates, depends upon the datatype and also upon, the compiler, so in a typical modernday compiler an integer is allocated 4 bytes of memory. Character varriable is allocated 1 byte of memory. Float is allocated 4 bytes of memory and we can have other variables as well. Okay, so as soon as the computer sees a declaration, like this, during the program's execution, it knows that this is an integer variable, so I need to allocate 4 bytes of memory. Let's say in our example, it allocates memory starting address 204 to address 207 for 'a'. And the computer has an internal structure, a lookup table where its stores this information that there is a variable 'a', it is of the type integer, and it is located at address 204, which is the starting address of the variable. Now, if we declare another variable, say for example if we declare a variable, name 'c' which is of type character, now once again when the machines sees this declaration it knows that it is a character variable, so it needs 1 byte of memory. So it looks for some free space, let's say in this case uh...it allocates the address 209, the byte 209 for 'c', and once again it keeps an entry for it, in an internal structure, called lookup table, that hey 'c' is a character, and its address is 209. Now, when you perform some operation with these variables, like let's say if we initialize a = 5, and our machine or computer sees such a statement, it looks into the lookup table for this variable 'a', so it finds this variable 'a', that it is an integer and it is at address 204 204, so it goes at address 204, and in these 4 bytes, starting 204, it writes this value 5. Now in reality, the value is written in binary, but for the sake of understanding, we are writing here in decimal form. Now once again let's say we have some statements, and then again after these statements we have another statement which increments 'a'. Now again, when computer sees that, 'a' has to be incremented, it again looks for this address for 'a', goes to the address, and modifies this value at this particular address. So this block of memory allocated for 'a', stores the value 6 now. Now, all of this is really cool but can we know the address of a variable in our program? Or can we operate upon these memory addresses in our program. Well, yes, you can do so in a C or C++ program, using the concept of pointers. Pointers are variables that store the address of another variable. And to make you understand, about this a little better, I'll redraw couple of these things. Let's say, we have a block of 4 bytes, at address 204 that stores an integer variable 'a'. Now, we can have another variable, the type of which is pointer to integer and let's say the name of this variable is 'p'. Now, this variable 'p' can store the address of 'a', and using the properties of 'p', or using some operators upon 'p' we can reach 'a'. Now 'p' also takes some memory so let's say, it is stored at location address 64 and it also takes 4 bytes of memory. We can also modify 'p' to point to another integer, so let's say if we have another integer at address 208 named 'b' and having value 10, and if we change the address in 'p' from 204 to 208 then 'p' now points to 'b'. Let us now see the syntax of pointer variables in C, A normal variable is declared by writing the data type and the variable name so int 'a' means that we have a variable 'a' of type int. If we want to write a pointer variable that should point to another variable all we do is, we put an * (asterisk) sign before the variable. So, 'p' is now a pointer variable that points to an integer. So 'p' is a variable that can store the address of an integer. Now to store the address of 'a' in 'p' we need to use a statement like p = &a (ampersand 'a') now if we put '&' in front of a variable it gives us the address of that particular variable. Infact, it returns a pointer to that particular variable. Okay so let's try to see a simulation of this. Let's say, when we declare the variable 'a', then it was allocated an address 204. Now we declare an.. a pointer to integer 'p'. Let's say it was allocated address 64. Now when we write a statement like p = &a p = &a, then 'p' now has the address of 'a'. And it kind of points to 'a'. Let's initialize 'a' to some value, let's say a =5, so, we fill value 5 into 'a' now. Now what will happen if I print 'p'. What will be the output? Any guesses? Think about it. Okay so if we try to print 'p', then the output will be 204 because 'p' has a value 204. What if we simply try to print &a (ampersand of a)? &a also gives us the address of 'a'. So this will also be 204 204. What if we want to print &p? Now 'p' is also a variable and it is also stored in the memory. So ampersand since it prints the, it gives you the address of that variable, so printing &p should give us 64, which is the address of 'p'. Now there is one more important property of pointer If we put an asterisk (*) sign in front of the pointer, than it gives us the value at the location that it points to. So what will happen if we try to print *p (asterisk of p). Well, it will give us 5. This concept is called as dereferencing, because we have a reference or we have stored the... an address in 'p'. And, we kind of get the value at this particular address using this operator. In fact, we can modify the value at this particular location, by saying something like *p is now 8 (*p=8). *p means value at 'p', and so the value at 'p' is now modified to 8. So what will happen if you print *p or print 'a' now, the output will be 8. By value of 'p' i mean value at address 'p'. So, 'p' is the address and *p is the value at address, that is stored in 'p'. Okay, to just to reiterate uh... we define a pointer variable using... by putting an asterisk (*) sign in front of the variable name and if we put an ampersand (&) sign in front of a variable name, we get the address of it. So if we try to print a pointer variable without asterisk (*) sign, or operate upon it without asterisk (*) sign, we are operating with the address. While if we put the asterisk (*) sign in front of the pointer variable, and operate upon it then we are operating the value at that address. So this was some of the basics of pointers. In the coming lessons we'll some see some code snippets uh...where we'll see some of the common errors that we make while using pointers and we'll also learn pointer arithmetic, and pointers in the context of arrays. So, Thanks for watching!