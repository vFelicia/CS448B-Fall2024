In our previous lessons, we saw what doubly linked list are. Now in this lesson, we're going to implement doubly linked list in C. We are going to write simple operations like insertion, traversal and deletion. In a doubly linked list as we saw in our previous lessons Each node contains three fields. I have drawn logical representation of a doubly linked list. One to store data one to store address of next node and one to store address of previous node. For a linked list of integers node will be defined like this in a C or C++ program. In the logical representation i'll fill in some data in each node. Let's say these node are at address 400, 600 and 800 respectively. I'll also fill in next and previous fields, and we must also have a pointer variable pointing to the head node. Quite often we name this pointer variable head. In my implementation I'm going to write these functions. I'm going to write a function to insert a node at beginning of head of linked list. This function will take an integer as argument. I'll write another function to insert a node at tail of linked list. I'll write one function to print element in a linked list, while traversing it from head to tail. I'll write another one to print the elements in reverse order while traversing the list from tail to head. Reverse print function will validate whether reverse link for each node is created properly or not. Let's now write these functions in a real C program. In my C program here, I have define node as a structure with three fields. first field is of type Integer to store data, second field is of type pointer to node to store a reference of next node and the third field is a pointer to know to store the reference of previous node. I have defined a variable named head which once again is a pointer to node and I have defined this variable in global scope, head is a global variable. When we defined a variable inside a function its called a local variable. The lifetime of local variable is lifetime of a function call, it's created during a function call execution and it's cleared from the memory when function call execution finishes but global variables live in the memory for a whole lifetime of an application, they live till the time program is executing. Global variables can be accessed everywhere in all functions. Local variables are not accessible everywhere unless you access them through pointers. In all our previous implementations, we have mostly declared head as global variable. Okay so let's now write the functions. The first function that I want to write is insert at head. This function will take an integer as argument. The first thing that we want to do here is we want to create a node, we can always declare a node like this, just like declaration of any other variable, we can say struct node and then we can give an identifier or name, and now in this my node that i have created, i can fill in all the fields but the problem here is that when i'm creating a node like this, I'm creating it as a local variable and it will be cleared from memory when function call will finish. A local variable lives in what we call stack section of applications memory and we cannot control its lifetime, it's cleared from memory when function call finishes. We do not want this. Our requirement is that a node should be in memory unless we explicitly remove it. So that's why we create a node in in dynamic memory or what we call heap section of memory. Anything in heap is not cleared unless we explicitly free it. To create a node in heap we use malloc function in C or new operator in C++. All malloc function does is, it reserves some memory in heap and this memory can be used for writing anything any variable any object. Access to this memory always happens through a pointer variable. We have talked about this concept quite a bit in our previous lessons, but I keep on repeating because this is really important concept. So here with this statement i have created a node in dynamic memory or heap, that can be reference through a variable which is pointer to node. I have named this variable temp. Now I can used this pointer variable to fill in values in various fields of the node. I'll have to dereference this pointer variable using asterisk operator, and then I can access various feilds like data, prev or next. There is an alternate syntax for this (*temp).data, we can simply write temp>data and similarly I can access other fields also. So to access prev field, i can say temp>prev. Let's set this as null and let's also set the next field as null. If you want to understand or refresh the concept of stack and heap in memory, then you can check the description of this video for a link to a lesson on dynamic memory allocation. Okay so in my function InsertAtHead, i have created a node in heap section of memory and I'm referencing that node using this pointer variable named temp. Temp is not have a very meaningful name. Let's use a name like newNode or newNode pointer. I would like to separate out this logic of node creation, these lines for node creation in a separate function. I've written a function here, named get newNode that will take an integer as arguement create a node filling in data field as X and setting both previous and next pointers as null. This function will return a pointer to node, so i will return new node from here. I'm writing a separate function because I can avoid duplicate code by using a separate function for creation of node because I'm going to create a node for function in function InsertAtHead as well as in function InsertAtTail that i'll be writing after some time. Now in InsertAtHead function I can simply call this function GetNewNode passing it X. This function is returning a pointer to newly created node that I'm going to receive in this variable which once again is a pointer to node named temp. We can name this variable also as newNode. This newNode in InsertAtHead is different from this newNode in getNewNode. These are local variables, this newNode is local to InsertAtHead and this newNode is local to getNewNode. Now there will be two cases in insertion at head. List could be empty so head will be equal to null. In this case we can simply set head as to address of new node, and return or exit. Things would be clear if i'll show everything in logical view also. Right now my linked list is empty here. In this logical view that I'm showing, let's say I have made a call to InsertAtHead passing it number 2. GetNewNode function will give me a new node. Let's say a new node is created at address 400. With this statement head equal newNode, we are setting the address stored in newNode variable in head. Null is nothing but address zero. As soon as this function InsertAtHead finished this variable newNode will be cleared from memory, but the node itself will not be cleared. If we would have created a node like this, struct node newNode and in this declaration newNode is not pointer to node. Its node, we are not saying struct node* so if we would have created node like this. The node also would have been cleared. Okay coming back to the function here, let's write rest of the logic. To insert a node when list is not empty this is what I'll do. Now I'm making the call InsertAtHead passing at number 4. Once new node is created, I'll first set the previous field of existing existing head node as address of this new node. So I'm building this link, then i'll set the next field of new node as the address of current head and now I can break this link and build this link so I'll set head as address of new node. this is how things will still look like finally. Let's also quickly see how things will actually move in various sections of applications memory. The memory that is allocated to a program is typically divided into these four segments. We have seen this diagram quite a bit in our earlier lessons. Code or text segments stores all the instructions to be executed. There is a segment to store global variables. There is a section that we call stack, that is used just like scratch pad on whiteboard for function call execution. Stack is where all the local variable go and not just local variable, all information about function call execution. Heap is what we also a dynamic memory. I'm showing stack heap and global section separately here. In our program we had to decleared head as a global variable. Initially for an empty list, we will set head as null or zero. Let's say we will do that in main function. Now when a call to insert at head is made at this stage, let's say I'm making the call passing number two as argument. Let's say we are making a call to InsertAtHead from main function. When program starts execution first main function is invoked, whenever a function is invoked some amount of memory from the stack is allocated for execution of that function. That section is called stack frame of that function and all the local variables of that function live inside it's stack frame. When function call execution finishes the stack frame is reclaimed. When main will make a call to InsertAtHead, the execution of main will pause at at the line where it's making a call. A stacke frame will be allocated for execution of InsertAtHead. I am writing shortcut IAH for InsertAtHead because I'm short of space here. All the arguments of insert at had all the local variables will live inside this stack frame. We are creating a variable name newNode named newNode which is a pointer to node as local variable and we are making a call to get newNode function. Execution of InsertAtHead will pause and we will go on to execute getNewNode. We could write GetNewNode like this. Here I'm treating a node on stack. x is a local variable in GetNewNode also. Then i'm creating a node filling in data as the value of X which is 2. i'm setting previous and next feilds as null or zero and then because I need to return a pointer to node, I have used & operator here. Using & operator gives us pointer to a variable, Let's say this new node that we have in the stack frame of GetNewNode, has address 50. With this return when GetNewNode will finish, the value in this newNode of insert at head will be 50. Please note that with this code this newNode in GetNewNode function is of type struct node, while this newNode in insert at head is of type pointer to struct node so there different types. We can return this address 50, that's fine but the stack frame for GetnewNode will be reclaimed once the function finishes. So now even though you have the address 50 there is no node there. We cannot control allocation and the deallocation of memory on stack. It happens automatically that's why we use a memory on heap. If I'm using this code for creation of new node, then what I'm doing is I'm declaring this variable new node, not as strut node but as struct node* that is pointer to node. I'm using malloc to create the actual node in heap section. Let's say i'm getting address 400 for this node. Now for a section of memory in heap for something in heap, we cannot have a direct name. The only way to access some thing heap is through a pointer. If we will lose this pointer we will lose this node. Okay so now what we're doing is using this pointer new node which is local to GetNewNode function. We are accessing this node filling in date, filling in address fields and now the at returning this address 400. Now when GetNewNode is finishing, I'm collecting the return this address for 400 in this variable in this local variable newNode. We are returning back to insert at head function at this line. Head at this stage is null. So now we're saying that set head equal equal newNode. Head is a global variable, it's not going to be cleared for whole life time of application and now we are returning. Stack frame of insert at head will be cleared and this is what we finally have. When we will make another call to insert at head, once again fresh stack frames will be allocated in the execution of functions appropriate links will be created So our linked list will be modified accordingly. I hope all of this is making some sense. With another call to insert at head, when everything will finish and control will return back to main. We can have a picture like this. Let's say I got a node at 600. Right cell is for next node. Right cell is storing the address of next node and left cell is storing the address of previous node. So this will and this is what we will have. Let's now go and write rest of the functions. Print function will be same as printing for singly linked list. We will take a temporary pointer to node initially set it to head, and then we will use this statement temp=temp>next to go to the next node and we will keep on printing. In reverse print we will first go to the end node of to list using next pointer, and then be will traverse backward using this statement temp=temp>prev. So we will use the previous pointer and while traversing backward will print the data. Okay let's now test all these functions that we have written so far. In the main function, i'm setting head as null to say that the list is empty initially, and now I'm writing couple of inserts statements. I'm making couple of calls to InsertAtHead function and after each call i'm printing the list both in forward as well as in reverse direction. Let's run this code and see the output. This is what I'm getting and I think this is as expected. There is one more function insert at tail that i have said i'll write. if you have understood thing so far, it should not be very difficult for you to write this function InsertAtTail. I leave this as an exercise for you. I'll stop here now If you want to get the source code, check the description of this video for a link. In coming lessons we're going to talk about circular linked list and we will see some more interesting problem on linked list. Thanks for watching.