Space complexity analysis of a program is the analysis of how the memory required or the memory consumed by a program grows with the input. So, let's try to analyze the space complexity of recursive implementation of Fibonacci sequence. I will write down the sequence here for you. First two elements in the sequence are 0 and 1 and all other elements are sum of previous two elements and we have seen this quite often in our previous lessons. And lets write down the program to calculate Fibonacci sequence. So, we have a method Fib(n) that gives me an element in the above sequence. And if n is less than or equal to 1, we return n. Else we make two recursive calls to calculate Fib(n1) and Fib(n2), sum them up and return the result. Now, complexity .. space complexity analysis of a recursive program can be really tricky because a lot of things happen behind the scene and we really need to understand that how recursive program executes in the memory to understand and analyze the memory consumption. Now, lets say what we have drawn here in the right is computers memory and these partitions in the memory are basically some units in which the memory is divided. Now, i want to calculate Fib(5), so in a typical program we will have a main method and from this main method, we will call Fib(5). Now, lets roll back a little bit. When a method is executing, it is currently in the memory. So, all the local variables and the information about the method is already in the memory. Now, when this method A makes a call to another method B. So, for example, in this case main makes a call to calculate Fib(5), and I will write F(5) as shortcut for Fib(5) because its easier for me to write, then what the computer says is that hey, I will save the current state of execution of this particular method, kind of pause it in the memory and go ahead and calculate F(5) and once I am done with F(5), then I'll come back to the main method. So, now F(5) is executing and its in the memory and the main method is kind of saved in what we can imagine to be a paused state and this is executing. Now, F(5) is executing and now F(5) makes a call to F(4) and this is a recursive call because the function is calling itself, though with a changed argument or a reduced argument. So, a recursive call is not different from a function A calling another function B except for the fact that here A and B are same. But in terms of execution, separate memory and resources are allocated to the new function call. So, now F(4) is executing and the computer has saved the state of F(5) as well. And lets say this red arrow here points to the currently executing function while rest of the functions are in paused state. Now, F(4) again makes a call to F(3), F(3) again makes a call to F(2). Now, I'll do one thing here, I'll change the color of main method. So, rest of the structure in blue is what we can call the recursion tree corresponding to the call Fib(5). So, now F(2) makes a call to F(1). And now F(1) is executing. So, as we can see here, even though explicitly we have not declared any variable or used any memory in the method Fib(n), behind the scene all the states of these methods are being saved in the memory or these function calls are stacked in the memory and space is getting consumed. We often say that an implicit stack is growing in the memory and we call this function call stack. So, as we can see here that above this main method from F(5) onward, the growth of the stack has been because of the recursive calls of method Fib or F. So, this part of the call stack is kind of the memory consumption by our recursive algorithm. Now, in this recursion, F(1) will not make any further function call, or any further recursive call. it simply returns 1. And now F(1) has finished and it also gets popped from the memory and the control goes back to F(2). Now, F(2) at this stage makes another call to F(0) and F(0) also simply returns 0 and finishes. And I will rather name this stack as function call stack. Now, F(2) adds up these two values 1 and 0 and returns the sum 2 to F(3) and now F(3) resumes again and now F(3) has got F(2), so it makes another call to F(1) and this pushing and popping into the memory goes on. So, now F(4) has resumed again and F(4) has got the two returns, so it simply adds them up and returns to F(5) and now F(5) resumes again and F(5) now has got return from F(4) at this stage. It makes another call to calculate F(3) and F(3) again calls F(2) and now F(2) is executing and F(3) goes in a paused state. F(2) again makes a cal to F(1) and F(0) which simply return 1 and 0 respectively and I am skipping showing these F(1) and F(0) in the stack here. Now F(2) sums up these values and returns to F(3) and F(3) resumes again and F(3) again makes a call to F(1) which simply returns 1. Once again, I am skipping showing push and pop in the call stack and now F(3) sums up these two values and returns to F(5) and F(5) resumes again. F(3) simply finishes and is removed from the memory. Now, F(5) sums up these two values and returns to the main method which is its caller. And finally, main method resumes and this stage, we have the output from the function call Fib(5) and it could print the output or use it for some other calculation. Now, I'll replace this figure here with an actual recursion tree with all the function calls. So, this is our recursion tree. Now, the space consumed by this particular recursion was the memory that it consumed in the function call stack and the maximum growth of this call stack due to this particular recursion was when we were at this particular node, the bottommost node. So, when F(1) was executing, then all these states of F(5), F(4), F(3) and F(2) were saved in the memory and we were consuming kind of 5 units of space in the memory and the call stack did not grow any larger than this. So, this was the maximum space consumed and if you analyze it well, then the maximum space consumed by a recursive program is proportional to the maximum depth of this recursion tree. And the maximum depth of recursion tree is defined as the length of the longest path in the tree, so if this is level 0 in the tree and if we go down by one arrow, then this is L1, which is level 1 and then we go down by another arrow, so it is L2 and we go on like L3 and L4. So, the maximum depth in this case is the path from L0 to L4 which is 4 units in this case. And the number of function calls is 5. And the maximum memory consumed is 5 units. If we would have called the function Fib for any generic value of n, then the maximum depth of the recursion tree would have been n1 units and the maximum space taken would have been n units. So, when we analyze complexity of programs, we often take the upper bound for the time or the space taken. In fact we most often take the upper bound for the time or space taken. So, in this case space or memory consumption is proportional to n and we can also say that this is bigoh of n in terms of space complexity. in general the space complexity of a recursive program would be of the order of max depth of he recursion tree. So, this was space complexity analysis of simple recursive implementation of Fibonacci sequence. Thanks for watching !