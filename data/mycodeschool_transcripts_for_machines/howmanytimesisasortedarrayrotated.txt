in this lesson we will solve another programming interview question and the question is that we are given a sorted array that has been rotated so let's say we have been given a sorted array with these elements the size of the array is six so we have indices from 0 to 5 and let's say we want to rotate this array anticlockwise rotate this array towards the right so each element will shift by one towards the right except the last element which will shift to the first position in the array and the resulting array would be this and this is rotated once and if we rotate the array twice the resulting array would be this and this is of course rotated twice and such an array is often also called circularly sorted array so we have been given such a circularly sorted array and there is one more condition there are no duplicates in the array all the elements in the array are distinct so given such an array we have to find out how many times the array has been rotated so how do we solve this problem one thing that should be pretty evident is that if we know the first element or the minimum element of the sorted sequence in the array then we know how many times the array has been rotated and when we say the number of times the array has been rotated for this problem we mean rotation in anticlockwise direction or rotation towards right the number of rotations of the array would be the number of elements before the smallest element or the minimum element in the array so in this case there is only one element before two which is the minimum so clearly this array is rotated once here we have two elements before the minimum element so this is rotated twice in fact if we see then the number of rotations is equal to the index of the minimum element so our problem is basically finding out the minimum element in the array the index of the minimum element in the array and we are done we know that how many times the array has been rotated so how do we find out the index of the minimum element the simplest approach would be to scan the whole array perform what we alsoo call linear search and the pseudo code will be something like we will have two variables one to store the minimum element and another to store the minimum index let's say initially the first element is the minimum element and then we run a loop from 1 till n minus one where n is the size of the array and if the element at I index is less than the minimum we update the minimum and the minimum index and finally when we come out of this Loop we will have the index of the minimum element clearly the running time of this algorithm would be Big O of n the running time will be proportional to n now this will give us the correct answer this is a correct solution but in this solution we did not make use of the property of the array that it is circularly sorted can we use this property of the array and improve this algorithm improve the time complexity of this algorithm well let us see now we will make use of the property that the array is circularly sorted and we will use a variation a modification of binary search algorithm to solve this problem now what do we do in a normal binary search algorithm let's say we have a sorted array like this we first find out the middle element in the index uh in the array and then we see whether this is the element we are looking for or not if it is not the element that we are looking for we either go searching towards the left or we go searching towards the right BAS based upon whether the element that we are looking for is greater than or less than the middle element so at each step we divide the problem into searching something in half the array at each step we discard half of the elements we discard half of the search space and we keep on going until we find the element now in a circularly sorted list like this our problem is to find out the first element of the sorted sequence this particular element is kind of the pivot or The Junction in the circularly sorted array so now we will use a variation of binary search to find out this PIV element which is also the minimum element in the array what we essentially do in a binary search is we Define a search space a segment within which our desired element is probable to lie by two variables low and high the lower index and the higher index and at each step we either find an element or we reduce the search Space by half by discarding half of the elements in the segment and creating a new segment and now we look at the new segment we kind of divide the problem at each step into half now in this problem for each segment we will look at couple of things there can be a case when the lower the element at lower index is less than or equal to the element at higher index now this will be possible only if the segment is already sorted if the segment is already sorted the minimum element in the segment and that's what we are finding out the minimum element in the array and if we can find out the minimum element in the segment that will be the minimum element in the array as well so we will return simply return the index low because the array is already sorted so the element at lower index is the minimum now if the segment is not sorted we can calculate the middle index and now we try to see if our middle index is the pivot or not now how do we find out the pivot if you see there is a special property of the pivot or the minimum element in the array if we see the next and the previous elements of the pivot element in a circular manner so if it is the last element the next element would be the first element then for the pivot element both next and previous element in the array are greater than it like here 18 and five are both greater than two no other element in the array will have this property except the pivot element let's define this property as pivot property so here we calculate next as mid + 1 modulo n modulo n because if mid is the last index in the array we need to go to the first element so modular operation does that and previous would be mid minus one modul n and we will also add a n here so that mid minus one does not become a negative number so our case two is that a mid is less than or equal to a next and it's also less than or equal to less than or equal to the previous element in the circular array in the circularly sorted array if this is the case once again we have the pivot or the minimum element in the array so we will return the index made so far in these two cases we have found our element straight off and we have not felt the need to divide the array divide the search space search segment now if the middle element is not the pivot then can we use a property where we can say that we can discard the right half or we can discard the left half and we can go to one of the halves to search for the pivot element well yes it is possible to do so if the middle element the element at Mid index is less than or equal to the highest element at high index High then the segment starting the mid index and extending right towards till the high Index this whole segment is sorted and the pivot cannot exist in the right segment so in this case we will say that we need to search for the pivot in the left half so we will adjust high to Mid minus 1 and case 4 would be when the mid element is greater than or equal to the element at lowest index now in this case it is not possible that the pivot is in the left so we will go and search in the right so we will adjust low to mid + one so we keep reducing our segments at each step and try to find out the answer now let us simulate this uh approach this algorithm for this particular example so for this example case one obviously is not true initially so we find out the middle index now the pivot property is not true for the middle index so we look at case three when we look at case three we basically are looking whether this whole part of the sequence is sorted or not including 18 and the whole elements towards the right so 18 is not less than or equal to 8 now we look look for case 4 and when we look for case 4 we mean to to check whether this complete sequence is sorted or not well this is sorted in fact if the array is not sorted then one of these two sequences will always be sorted you can pick up some of examples some examples and try to see and this uh is what forms the basis of our divide and concur approach this is what F the forms the basis upon which we discard half of the elements so now we need to adjust low to mid + 1 so we have discarded these elements from our search space our new search space is starting at two now this array is sorted case one is true for this segment sorry this segment is sorted so we simply return the index of two which is 0 1 2 3 and 4 so we return four here and our search is over now we have found the pivot element so we know that the array is rotated four times equal to the index of the pivot element of things about this algorithm this algorithm will work only if there are no duplicates in the array and that was our initial condition also in the problem if there are duplicates this reduction of search space into half is not possible and let us now write code for this algorithm and see whether it works or not so I will write a method find rotation count that will give me how many times uh a circularly sorted array a is rotated n is the number of elements in the array so we first Define low and high and then while our search space is valid we first see whether the segment is already sorted if it is sorted we return the lower index so this is our case one else we calculate mid as low plus high upon 2 and then we also calculate the next and previous of mid and if mid satisfies the pivot property we return mid else if uh the middle element is less than or equal to the higher element then we discard the right half and we adjust higher index to Mid minus one else if a mid is greater than or equal to a low then we discard the first half the left half if the array is not sorted one of these two conditions will always be true and only one of these conditions will be true not the both of them let's say if we are not able to return anything if we are not able to return anything within the while loop then we return minus one it will be minus one will be returned only for an invalid scenario when maybe the array is not circularly sorted its properties are not true now in the main method I have initialized an array of size 11 and I have called this function find rotation C and I'm trying to print the count let us see what happens if I run the program this says that the array is rotated six times which seems to be correct let's now modify this array let's run this for a test case when the elements are already sorted okay this also looks fine so we are good now I have used four cases to solve this problem uh there are couple of different other uh implementation approaches as well the underlying idea would be the same to use binary search but we can Implement using some different conditions I encourage you to try them out on your own or quickly Google search for code Snippets so this was one interesting problem using uh solve using binary search in the coming lessons we will see more such interesting problems thanks for watching