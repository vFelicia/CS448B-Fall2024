In this lesson, using the example of a very famous mathematical sequence named Fibonacci sequence, we will explain why writing a recursive may sometimes be very intuitive and simple, but it may not be the best thing to do. And the prerequisite for this lesson is that you should know about functions and you should also know about the concept of recursion in programming. Now, Fibonacci sequence is defined by this particular recurrence relation. The first two elements in the sequence are 0 and 1 and all other elements are the sum of previous two elements. So, the third element is 1+0 which is 1 and then we go like 1+1 = 2 , 2+1 = 3 and so on. So, we can also say that this is F(0), and this is F(1) and F(0) and F(1) are calculated by this condition and F(2) onward, we calculate them by this recurrence relation. Now, Albert and Pinto are two students of MyCodeSchool and both have written programs to find out nth element in the sequence and they have both written two different solutions and let us see what these two different solutions are. Albert writes a method Fib that takes n as input and gives F(n) in this above sequence and the program goes like if n is less than or equal to 1, return n, else we will initialize two variables F(1) to 0 and F(2) to 1 and run a loop form 2 to n where I'll have a variable F that will calculate the sum of F1 and F2. F1 and F2 at any point in this loop will have the or rather store the values of the previous two elements. And F at any stage in this loop will have the current element. Now, we need to update F1 and F2, so F1 now will be F2 and F2 now will be F. And finally when we come out of this loop, we can return F. And this gives us pseudocode for Albert's implementation. Now, Pinto also writes a method Fib(n), but Pinto has recently learnt recursion and he says that hey, there is lot more simpler method to solve this problem. So, his program also goes like if n is less than or equal to 1, return n, but else return Fib(n1) + Fib(n2). So, he writes a recursion and this particular condition , if n <=1 is the base condition or termination condition so that the recursion does not go on endlessly. Now, let us quickly try to write these programs in an actual compiler and see what happens. So, I will write a C++ program and this is a Visual Studio compiler open in front of you. So, this is Albert's code where he has written an iterative program where he is iterating through all F(i)s in a loop from 2 to n and I'll come to the main method and have a variable n and ask the user to input an n, so I'll say, hey give me an n. and I'll input this. I'll also have a variable result that will store the return from the function once we pass n and then i'll simply print the result. Now, let us quickly run this program and see what happens. Now, this says give me an n. Let's say i give n = 6 and the output is 8 which is correct. Now, i will run this again and this time for an input 40. And this time output is 102334155 which is a 9 digit number. Now, let us write Pinto's implementation and this time I'll modify this method. So, I'll say that if n is less than or equal to 1 then , return n, else return Fib(n1) + Fib(n2) and we could also write an else here but that would be redundant. So, let's run this and see what happens. So, this time again , let's say we give the input 6 first. And this gives me 8 which is correct. And let's give n = 40 again. And this is not finished yet. This is still executing. And I am waiting. And this is still executing. And Boom !! It finally comes. So, this gives me the correct result, but this time it takes couple of seconds to give me the result. And why is it so. I thought recursion is good. Let us see. Now Albert has written an iterative program and Pinto has written a recursive program. So, what happens with Albert is that to calculate F(n), he already has F(0) and F(1), so to calculate F (n), he goes on to calculate F(2) from F(0) and F(1) , and then he goes on to calculate F(3) from F(2) and F(1) and he goes on till F(n). So, he calculates each of these F(2), F(3) and F(n) exactly once. So, for example, if he wants to calculate F(5), he goes on building it like from F(0), sorry he already has these two values F(0) and F(1), from here he goes to F(2) and then to F(3), F(4) , all the way till F(5). Now, if Pinto has to calculate F(5), he makes a recursive call to F(4) and F(3). So, I''ll go in order in which the functions are called in an actual program. I am using F(4), F(5), all these names as shortcut for Fib(5) and Fib(4). So, now F(4) recursively calls F(3). F(3) recursively calls F(2) and F(2) recursively calls F(1) . F(2) also calls F(0). Now F(0) and F(1) do not make any further recursive calls. They simply return 1 and 0 respectively. This also makes a call to F(1) and we keep on drawing this structure. Now, F(5) also calls F(3). Now this particular structure that we have drawn here is called a recursion tree. Now, we can see here that the value F(2) is actually being calculated thrice. And similarly, F(3) is being calculated twice which is an unnecessary overhead or unnecessary redundancy. So, in the left or the iterative program, while we are calculating each state or each value of F(i) exactly once, in the recursive implementation, we are calculating it multiple times. For example, if n = 5, we are calculating F(2) thrice, when n = 6, we are calculating F(2) 5 times. When n = 8, we calculate F(2) 13 times and if n =40 that we had used in our example, this number is 63245986 which is crazy. And similarly, like F(2) , F(3), F(4) and F(i) for any general i is being calculated a number of time. So, the running time of this program is growing exponentially as the input increases. And you can also write a simple program to find how many times F(2) is being calculated or any other F(i) is being calculated. So, as we can see from this example, recursion can sometimes be very simple and intuitive to write, but it could be expensive in terms of time and space that it takes. In another lesson, we will see how to analyze the time complexity of a recursive program. In yet another lesson, we will also see that how to avoid this overhead of calculating the same state again and again by using a technique called recursion with memoization. So, Thanks for watching !