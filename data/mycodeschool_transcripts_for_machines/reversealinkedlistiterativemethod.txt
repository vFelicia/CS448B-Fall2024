In our lessons on linked list so far, we have implemented some of the basic scenarios like uh... inserting a node in linked list and deleting a node from linked list In this lesson we will write code to reverse a linked list This is one of the most favorite interview questions and this is a really interesting problem so let me first define the problem. Let's say we have been given a link to this list of integers like this so this is our input. We have four nodes in this linked list at addresses hundred, two hundred one fifty and two fifty respectively. I always write these addresses in the logical view because it's really important we visualize how things are in the memory and uh... what is what? Like this first node, that we also call the head node is being pointed by this particular variable named head so this variable is basically storing the address of the head node Now, this variable is only the pointer, this is not the head node itself. And we do not have any other identity of the linked list except the address of the head node. So, given a linked list like this if we have to reverse it and by reversing we do not mean moving around data we cannot move 5 at address 100 2 at address 250 and do something like this we actually have to adjust the links so our output should be something like this, the head pointer should point to this address two fifty and we should go like 250 to 150, 150 to 200 and this node at address 100 should have address 0, or null. In each of these nodes this first field in red is the data part and the second field is the address part. So, this is what we will get when we'll reverse the list. there are two approaches to solve this problem one is an iterative approach where we'll be using a loop We'll traverse through the list and at each step we will revert one of the links. Another solution is using recursion. In this lesson, we will try to understand the iterative solution. So, coming back to our input list the iterative solution is relatively easier to understand what we can do is we can traverse the whole list and uh... as we go to each node we can adjust the link part of that node to make it point to the previous node instead of the next node. So, we will start at the first node At each step we want to reverse the link, so we want to make the node point to the previous note instead of the next node. For the first node there is no previous node, so lets say the previous node is NULL, and now we want to cut this particular link and we want to build this particular link. So, we will simply change the address field to 0 and we have reversed the link part of this particular node. And now, we will go to the next node in the list. We will come to this node. Of course, the question would be how would we go to the next node if we have broken this link here! We will come back to that in the implementation details. Let's say we are able to traverse the list and go to each of the nodes at each step. Let's say we store all the relevant information to do that in some temporary variables. Now, this node again we will reverse the links, it was the link so the address part will be set as hundred here. Now, we will go to the next node at address hundred and fifty,once again to reverse the link, we will set the address as 200 here. So, we will break this link and basically we are building this link, and now we will go to address two fifty, the next node and we will set the address one fifty here so we will cur this link and build this link! And finally, when we have reached the last node, we will adjust the address in the head variable to two fifty. So,this particular variable, this particular pointer will point to this node at address 250. And, our linked list is reversed now! So, let us implement this particular logic in the real C program. I will redraw the original input list, in my C code, i would define node as a structure like this! This is how we have defined a node in our previous lessons. So, there will be two fields, uh... one to store the data which will be of type integer and another to store the address of the next node We will name this field 'next' of type pointer to node, and let's say, head is a global variable,so, head is a pointer to node, head is a variable which is a pointer to node/ And, it is a global variable. So, it is accessible to all the functions. We do not need to pass it around to functions, and now, all I want to do in my code is that,I want to write a reverse function that will reverse the linked list which is pointed to by this particular pointer. As we said, we'll traverse the whole list and at each step we will modify the link field of the node to make it point to the previous node instead of the next node. So, how do we traverse the list? We would traverse the list in our C code, something like this, we will first take a variable which will be pointer to node Let's say we will name it temp uh... then first we will set temp to head By saying this, we will mean temp points to the first node. And then, we will run a loop like this. We will say that while temp is not equal to NULL, take temp to the next address with a statement like temp=temp.next uh... in our problem here, we don't just have to look at what's the list as we traverse the list we have to uh... reverse the links so we have to set the address field of a particular node as address of the previous node instead of the next node. Now in a linked list, we would always know the address of the next node but we would never know the address of the previous node, so as we traverse the list, we will have to keep track of the previous node in another variable. So, what i'll be doing, is something like this. Now, I will also declare a variable named previous and initially set it to NULL, because for the first node or the head node, the previous node is NULL. And now, in my loop, we will have to update both these variables, and the variable temp that will store the current node and the variable prev that will store the address of the previous node and now in my loop i can do something like this At each step, if temp is our current node, we are traversing the list then we will say that temp.next is equal to previous So, we will set the link part of the current node as the address of the previous node. In our example here, at the first step we will say that, temp.next will be 0. NULL is nothing but address 0. So, we will cut this link and we will build this link. Now, we should be able to move temp to two hundred and we should be able to move previous to hundred. Now, in the next step but there is a problem as soon as we adjusted the link of this particular node at address hundred to make it point to NULL, we lost the address of the next node. So how do we move temp to this particular node at address two hundered. We cannot say that temp = temp.next. And now, if we say temp=temp.next, now we will go to NULL. So, this is a problem so at each step in our iteration before we set the link field of the the current node to make it point to the previous node we should store the address of the next node in a temporary variable, in another temporary variable, So, what I will do here is something like this first of all i want to name this particular variable temp as current to mean that this is the current node at each stage in my iteration so we initially set current to head and then we are running the loop as while current is not equal to NULL, and then i have also declared one more temporary pointer variable named next what i will do at each step in my iteration inside the while loop is that first I will say that next=current.next So first I will store the address of the next node in this particular variable next. So in our example here, for the first node initially, things will look, something like this. Now we can set uh... link part of the current node as the address of the previous node with a statement like this So, when we will write the address 0 here, initially we will break this link, and create this link Now, we will not loose the information about the next node, now we can redefine our previous and current so we will first move previous to current and then we will move current to next Please note that this particular variable next is a local variable in the Reverse function and when we say something like current.next we mean the link field in the node, well when we simply say next, we mean this particular local pointer variable, so they're different this is not current.next, actually this is current > next which is an alternate syntax for *(current).next so we use * operator to de reference that address and then we access the next field for the sake of saying we say, current.next or temp.next uh... so with these two lines in our loop we are resetting out current and previous pointers. This is how we are traversing the list. Now, if you see in the next iteration current is 200, not equal to NULL NULL is zero so we will go to this particular statement next is equal to current.next. So, next will now store the address hundred and fifty, and not we will say current.next is equal to previous. So, we will cut this link, uh...previous is hundred right now so we will set hundred here. So basically, we will build this particular link and then we will move then we will first move previous to current and then move current to next. And, we will go on like this. So finally, we will reach a stage like this when current will be equal to NULL, we will come out of the loop, and when we will come out of the loop this particular variable previous, this particular pointer previous will store the address of the last node. And, there is one more thing remaining here.We need to adjust this particular variable head uh... this link at this stage does not exist and in my code I will say head should now be equal to the address in variable previous! So, head is now 250 this is our new head, and now our list is reversed uh... there are a couple of things that i want to point out here one thing is that we must see that our implementation is working for all test cases and so we must also verify it for special or corner test cases. In this case corner test case will be when the list is empty. In that case head will be NULL. or, when the list is having only one node if you see this particular implementation will work for these two scenarios and give it some time and you should be able to figure it out let's not run this code with complete implementation of all the functions to insert and print nodes. In my code here, uh... i have written Reverse function to accep the address of the head node as argument and then return the address of the head node after modification of the list after reversal of the list and then I have written the the main method in which head as a local variable and then i'm using couple of insert functions and making couple of calls to insert function insert function also takes two arguments the address of the head node and the data to be inserted and it returns back the address of the head node it will either be modified or not modified uh...lets say we are inserting this at the end of the list 2 4 6 8 and then we are making call to the print function which we have written to print the elements in the list and then i'm making a call to reverse and finally printing again my logic of the reverse function remains the same except that i've changed the method signature and in the end I am returning head, which will return the address of the head node let's say we have written all the insert and print functions correctly these are the two functions insert and print so let's now run this code and see what happens before the list is reversed the list is two four six eight and after the list is reversed the output is eight six four two uh... let us try for the case the list has only one element in the list so i will remove, i will comment out these three insert insert statements and this also seems to be working.So, this was reversal of the linked list through iteration. In the next lesson, we will write code to reverse linked list using recursion. So, thanks for watching!