In our previous lesson, we introduced you to the concept of data structures and we saw how we can talk about data structures in two ways, one as a mathematical and logical model that we also call, that we also term as an abstract data type or ADT and then we also study data structures as concrete implementations. In this lesson, we will study one simple data structure we will first define an abstract view of it we will first define it as an abstract data type and then we will see uh... the possible implementations and this data structure is list. List is a common real world entity. List is nothing but a collection of objects of the same type. we can have a list of words, we can have a list of names or, we can have a list of numbers so let us first define list as an abstract data type. So, when we define abstract data type, we just define the data that we'll store and then we define the operations available with the type and we do not go into the implementation details let us first define a very basic list. I want a list that can store a given number of elements of a given data type this would be a static list as the number of elements in the list will not change and we will know the number of elements before creating the list We should be able to write or modify element at any position in the list and of course we should be able to read element at a particular position in the list so if i ask you for an implementation of such a list and you have taken a basic course in programming, a basic introductory course then you will be like hey i know this, an array gives us all these features, all these operations are available with an array, we can create an array of any data type. So, let's say if we want to create a list of integers, then we declare the array type as integer and then we can give the size as a parameter in declaration i can write or modify element at a particular position The elements are A[0], A[1] and are accessed something like this we all know about arrays and then you can also read elements at particular position. The element at ith postion is accessed as A[i]. So, array is a data structure that gives us implementation for this list now i want a list and that should have many more features. I want it to handle more scenarios for me so i'll redefine this list here i don't want a static list, a static collection of fixed size. I want a dynamic list that should grow as per my need so the features of my list are that i will call my list empty if there are no elements in the list i'll say the size of the list is zero when it is empty and then i can insert an element into the list and i can insert an element at any position in the list, in an existing list i can remove element from the list i can count the number of elements in the list and i should be able to read or write or rather, read or modify element at a particular position in the list and i should also be able to specify the date type for the list so i should be able to while creating the list i should be able to say whether this is a list of integers or whether this is a list of string or float or whatever. Now, i want a data structure which is implementation of this dynamic list so how do i get it? Well, actually we can implement such a dynamic list using arrays. It's just that we will have to write some more operations on top of arrays to provide for all these functionalities. So, let us see how we can implement this particular list using arrays Let's for the sake of simplicity of design uh... assume that that the data type for the list is integer.So, we are creating a list of, a dynamic list of integers. What we can do is to implement such a list we can declare a really large array We will define some max size and declare an array of this max size. Now, as we know the elements in the array are indexed as A[0], A[1] A[2] and we go on like this uh... so what i'll do is i will define a variable that will mark the end of the list in this array. So, if the list is empty, we can initialize this variable or we can set this variable as minus one because the lowest index possible is 0 so if end is minus one the list is empty at anytime a part of the array will store the list Okay, so let's say initially when the list is empty this pointer end is pointing to index minus one which is not valid which does not exist and now i insert an integer into this array and let's say if we do not give the postion at which the number is to be inserted the number is always inserted towards the tail of the list, towards the end of the list so the list will be like we'll have an element at position zero and now end is index zero So, at anytime end marks the this variable end, marks the end of the list in this array Now, if i want to insert something in the list at a particular position let's say i want to insert number five at index two Then, to accommodate five here at this particular position we will have to shift all the elements one unit towards the right all the elements starting index two we need to shift all the elements starting index two towards the right okay i just inserted some elements into the list let me also write the uh... function call for these let's say we went in this order, we inserted two then we inserted four and then inserted in the end we are inserting five and we will also give the position at which we want to insert, so this insert with two arguments would be the call to insert element at a particular position. So, after all these operations, after all these insertions this is what the list will look like this uh... arrow here marks the end of the list in the array. Now, if i want to remove an element from a particular position. Let's say i make a call to something to the remove function i want to remove the element two so, i will pass the index zero here i want to remove the element at index zero. So, to do so, all these elements after index zero will be shifted one unit towards the left or towards the lower indices and two will go away that this end variable here is being adjusted after each insertion that we are making. So, after each insertion end will be zero after this one, two, three and so on. After this remove, end will be four again. Okay, looks like we pretty much have an implementation of this uh... list in the left that is described as an abstract data type we have a logic of calling the list empty when we have this variable end equal to minus one We can insert element at the particular position in the list. We can remove element it's just that we have to perform some shifts in the array, they can count the number of elements in the list it will be equal to end plus one the value in the variable end plus one. We can read and modify element at a position. Well, this is an array, so we can definitely read or modify element at a particular position uh... if we wanted to choose the data type it was just choosing the array of that particular data type, but this looks like a cool implementation except that we have one problem uh... we said that the array will be of some large size, some max size. But what is a good max size? We can always exhaust the array, the list can grow to exhaust the array, there is no good max size. So,we need to have a strategy for the scenario when the list will fill up the whole array. So, what do we do in that case? We need to keep that into our design. We cannot extend the same array it is not possible to do so. So, we will have to create a new array, a larger array So, when the array is full, we will create a new larger array and copy all the elements from the previous array into the new array and then we can free the memory for the previous array now the question is by how much should we increase the size of the new array this whole operation of creating a new array and copying all the elements from the previous array into the new array is costly in terms of time and definitely a good design would be to avoid such big cost. So, the strategy that we choose is that uh... each time the array is full, we create a new larger array of double the size of the previous array and why this is the best strategy is something that we will not discuss in this lesson so we will create a larger array of double size and copy elements from previous array into this new array. This looks like a cool implementation The study of data structures is not just about studying the operations and the implementation of these operations it's also about analyzing the cost of these operations so let us see what are the costs in terms of time for all these operations that we have in the dynamic list. The access to any element in this dynamic list, if we want to acces it using index for read or write, then this will take constant time because we have an array here and in array, elements are arranged in one contiguous block of memory using the starting address or the base address of the block of the memory of the block of memory and the index on the position of the element can calculate the address of that particular element and excessive in constant time. Big oh notation, that is used to describe the time complexity of operations for constant time,it is written as in terms of big oh, the time complexity is written as Big Oh of one. If we wanted to insert element if we wanted to insert element at the end of the array uh... end of the list then that again will be cost in time but if we would insert element at a particular position in the list then we will have to shift elements towards higher indices. In the worst case we will have to shift all the elements to the right when we will be inserting at the first position, so the time taken for insertion uh... will be proportional to the length of the list let's say the length of the list is n or, in other words, we will say that insertion will be Big Oh of n in terms of time complexity if you do not know about Big Oh notation, do not bother, just understand that, inserting an element at the particular position will be a linear function in terms of the size of the list. Removing an element will again be big oh of n Time taken will be proportional to the current size of the list. n is the size of the list here. ok now, inserting an element at the end we just said that it will happen in constant time it is not so if the array is full then we will create a new array uh... lets call inserting element at the end as adding an element adding an element will take constant time if the list is not full but it will take time proportional to the size of the list, size of the array, if array is full. So, adding in the worst case will be big oh of n again as we said when the list is full we create a new copy double the size of the previous array and when we copy the previous array, elements from previous array into the new array, so primafacy what loooks like the good thing with this kind of implementation Well, the good thing is that we can access elements at any index in constant time which is the property of the array but if we have to insert some element in between and if we have to remove element from the list then it is costly. if the list grows and shrinks a lot then we will also have to create a new array and have all this thing of copying elements from previous array to a new array again and again and one more problem is that a lot of time a lot of the array would be unused. The memory there, is of no use Definitely the use of array as dynamic list is not efficient in terms of memory this kind of implementation is not efficient in terms of memory This leads us to think can we have a data structure that will give us a dynamic list and use the memory more efficiently we have one data structure that gives us good utilization of the memory and this data structure is linked list and we will study about the linked list in the next lesson. So that's it for this lesson. Thanks for watching!