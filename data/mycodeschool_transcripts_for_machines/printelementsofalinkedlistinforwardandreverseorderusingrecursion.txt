In our series on linked list so far, we have implemented some of the basic operations like insertion deletion and traversal. Now in this lesson we will write code to traverse and print the elements of a linked list using recursion. Prerequisite for this lesson is that you should understand recursion as a programming concept well. Recursive traversal of linked list actually helps us solve couple of interesting problems but in this lesson we will keep it simple We will just traverse and print all the elements in linked list using recursion. and we will write one simple variation to print all the elements in reverse order. using recursion. We will actually not reverse the list we will just print the elements in reverse order. So, once again I have taken example of a linked list of integers here we have four nodes, each rectangle here is a Node It has two fields, one to store the data and another to store the address of the next node let's say we have four Nodes at addresses 100 200 150 and 250 respectively. And of course we will also have a variable that will store the address of the head node. Let's name this variable head. Programmatically in our C or C plus plus program Node will be defined something like this We will have a structure with two fields, one to store the data and another to store the address of the next Node. What we want to do in this particular lesson is that we want to write two functions first we want to write a function named print that will take address of the Node as argument. We will first past this function the address of the head node, so let's name this argument head and in this function we will use recursion to print elements in the list so for this particular example here if we want to print a space separated list of all the elements our output will be something like this and we also want to write another function named reverse print. Here also we will take the address of the Node. So we will pass this guy the address of the head node and in this function we will use recursion to print the elements in the list in reversed order. So if we have to print a space separated list for this example our output will be something like this. So let's first implement the print function. in my C code here, I will declare print function like this it will take as argument the address of a node so the argument is of type pointer to Node. Initially we will pass the address of the head node. We can name this argument head or we can name this argument p. we can name it whatever but we must understand that this will be local variable and let's not bother about other infrastructure in the code like how we would create a linked list and how we would insert a node in the linked list. let's assume that they are in place so let's keep the name of this particular argument p. Now recursion is a function calling itself so we have been passed the address of the node initially the head node, so what we can do in our code is first we can print the value at that particular node with a printf statement like this and then we can make another call to the print function and this time we will pass the address of the next node with a statement like this. This next field is also a pointer to node, so this will pass the address of the, this will be the address of the next node Now, there is one more important thing in recursion and that we should never forget and it's the exit condition from recursion. we should not go on making recursive calls infinitely. So in this case if we go from the first node to the second node and from the second node to the third node using recursion, then finally at one stage, p will be equal to NULL in one of the calls. So at this stage we can avoid making a recursive call, we will exit and we will show you a simulation of how things will happen. in memory. Hold on for a while,so once we will reach the end of the list p will be equal to NULL and we will exit. the recursion at that stage. Now I will write the main method, We have already written the insert function here so I'll declare a variable head as NULL in the main method. So head will be a local variable. Once again we could name this particular variable a or b or whatever Just because this variable points to the head node or the first node in the list we name this variable as head and then we will insert some nodes in the linked list by making calls to the insert function that takes the address of the head node as argument. Initially head is set as NULL to say that the list is empty and there should be two arguments to head to the function insert. The address of the head node and the value that needs to be inserted and why is it that this particular function insert is returning a pointer. It's because this head in the main method is a local variable and if we pass it to the function we just pass a copy of the address of the head node. In this head which will be a local variable of the insert function so this guy returns us back the address of the modified head. So, we can update it in the main function. This function inserts a a node at the end of the list. So, initially when head is null head will be modified in the insert function For other cases it will not be modified if we are inserting at the end so we will make four such calls to the insert function to create a linked list of four integers 2, 4, 6, 5 and now we will make a call to print function and pass it the address of the head node. Let us now run this code and see what happens. As you can see we have got this output 2, 4, 6, 5 The print function here in our code which is a recursive implementation to print the lists is working now I'll make one slight change in the print function instead of printing the value in the node and then making making a recursive call I will first make a recursive call and then when the recursive call finishes, I will print the value in the Node and I will not modify anything else in the code. The main method will remain the same And if we run this code, we can see that the elements in the list are printed in reverse order. So we just implemented the reverse print print function that we have talked about Let us now analyse these two recursive implementations in a logical view in our example here if we want to print this particular list we will do something like from the main method we will make a call to the print function passing it the address of the head node so initially this print function it's been called with p equal 100 now in the execution of this function we will come here if p is equal to NULL, NULL is address zero. And our argument is 100 so control will not go inside this if condition. We will come here we will print p> data. p>data means that we will first dereference the address So, we will go to the address 100 and then we will look at the data field there. So, on the console we will print the data field of the data field at address 100 and now the recursive call we will make a call to print function passing it address p>next which is 200 and execution of this particular call will not finish It will finish only after print(200) finishes. We will come back to it now print(200) once again prints the data at address 200 and then makes a recursive call to print function passing address 150 and we will go on like this. In this call to print with address 250 We will first print the data and the address field the value of P>next is 0, what we can also say NULL. We will make a call like this. Now for this call with arguments null we have reached end, the exit condition recursion will not grow further. So we will just print an endofline and return. This particular structure that we have drawn here is called recursion tree so print(NULL) function will finish and control will return back to print(250) there is no statement after this particular recursive call finishes so we will simply exit this function call also and control will return back to print(150). And we will go on like this. Finally we will come back to the main method If you want to see how the recursion will execute in the memory Then i will have to draw a diagram like this. Applications memory, the memory that is allocated for the execution of a program has these two sections. All the details of function called execution and the local variables they're stored in the stack section of the memory and any memory that is allocated using the malloc function or the new operator in C plus plus they go to the heap section The memory for the Nodes in a linked list is allocated from the heap so that's why these four nodes in our example are sitting in the heap. If you want to know in detail about stack and heap, check the description of this video for a lesson on dynamic memory allocation. When the program will start executing first the main function will be invoked anytime a function is invoked some amount of memory from the stack is allocated for the execution of that particular function and is called the stack frame of that function so let's say Main is executing. We have already inserted some nodes in the linked list. We have this variable head in the main function so all the local variables will sit in the stack frame of the function so head will sit here. Now at this stage let's say main makes a call to print function so main was executing and now it makes a call to print function execution of Main will be paused and we will go on to execute the print function. The argument passed to the print function is 100 which is stored in the local area. This argument p is a local variable in the print function Now, print function again makes a recursive call. Now, stack frame is alocated corresponding to each call of a function. So, a function calling itself is not different from a function calling another function. At any time whatever function call is at the top of the stack is executing. Finally when we will reach the exit condition of recursion, stack will be something like this. First this call where p is 0 will finish. We will come back to this particular call and then this will finish and we will go on like this so this is how recursion works. This is how things will happen in the memory. Okay so now I'll clear this diagram of stack and heap in the right and I'll make some change in my print function. What I've done is I have renamed my function Print as ReversePrint and in my function I am first making a recursive call and after coming back from that recursive call I'm writing a print statement and from the main function I'll make a call to reverseprint. Let's write RP as shortcut for ReversePrint and initially I will pass the address of the head node so I'll make a call like this ReversePrint(100). The control will come inside this function. p is 100. It is not equal to null. and I have also drawn the console like before now this particular function call does not print first it just makes a recursive call so this guy will go ahead and make a recursive call to the ReversePrint function passing it address 200 nothing will be written on the console and once again this particular function will make a recursive call like this and once again this particular function will go ahead and make a recursive call like this and finally we will have recursive call where the function is at address null. At this stage we will come to the exit condition in recursion. The recursion will not grow any further. We will simply return, the control will return to this particular call, ReversePrint(250) So we will come here now. To this Printf statement the data field at address 250 is 4. So, 4 will be printed on the console and now this particular function call will finish and now we will go to ReversePrint(150) and now this call will print 5 and exit and we will go on like this. Finally we will return back to the main function with this output on the console, the elements of the list printed in reverse order So, this was a recursive traversal of linked list to print its elements. I must point out here that for normal traversal of the linked list not for the reverse print, for the normal print an iterative approach will be a lot more efficient than the recursive approach because in iterative approach we will just use one temporary variable while in recursion we will use space in the stack section of the memory for so many function calls so there is implicit use of memory there. for ReversePrint operation we will any day have to store elements in some structure so if we use recursion it's still okay. In the coming lessons we will solve more problems, more interesting problems on linked list. So thanks for watching!