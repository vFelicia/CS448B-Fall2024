In our previous lesson, we learnt about binary search and we also implemented binary search, but we implemented an Iterative version of binary search in which we used loop to write our program. Now in this lesson we will write binary search using recursion. Let us first quickly write an Iterative version of binary search. So I will write a method BinarySearch(), that will take as argument, a sorted array A. The size of the array n and an element X that is to be searched for. Then we initialize 2 variables low and high, low to 0 and high to n1 and we say that while(low<=high) calculate middle index as low + high upon 2. It's a better practice to calculate mid as low+(highlow)/2 which is the same thing except that we are not getting low + high. Sometimes low and high individually are within the limit of, within that range of an integer variable, but high + low overflows the range or limit of Integer variable. Now there are three conditions, if x is equal to the middle element we have found X in the array so our search is over,we return the index mid and exit. Else if X is less than the mid element, we add just high to mid1, to say that we discard anything which is on or after mid because X is less than the middle element and the array is sorted. Else if X is greater than a mid, which should be implicit here for the third condition, as the third condition. In this case we set low as mid+1 and if we come out of this while loop without finding anything, we return 1 to say that X does not exist in the array A. What we are essentially doing here is that if we have an array in which elements are in increasing order then we first compare X with the middle element and if X is equal to the middle element it's fine, if x is less than the middle element it must exist before this element in this highlighted section and if X is greater it must exist after the middle element in this particular highlighted section and we keep on repeating this process in the new segment until either we find X or we cannot divide the search space any further. At low = high our search space becomes or rather reduces to size 1 , reduces to only one element. After that we cannot divide it any further. Binary search is a typical example of a divideandconquer algorithm in which at each step we're dividing the problem into half. Let us now write recursive implementation. So once again I will write a method BinarySearch(), that will take a sorted array A and this time the arguments will change a little, we will take two arguments low and high to mark the segment of the array in which X may lie at any stage, X is the element to be searched for and the logic would be something like once again we will calculate the mid index and then we will have 3 conditions. if we find X that's good, we return. The index at which we have found it,if x is less than A mid we call binary search recursively on the range low and I'm running short of space here so create some space here and we will run the we will call binary search recursively. Index low to mid1 so X is now to be searched between index low to mid1. Else if X is greater than A[mid] which will be the third condition anyway we will return BinarySearch() from mid+1 to high so we make a recursive call to search X from index mid + 1 till high when we write recursion we should always look for a basecase, a base condition where we would stop our recursion. In this case we will stop our recursion, if we find the element. So this case will return and exit and we will not make any further recursive call. But what if we do not find the element. what if we do not find X in the array? we have another base condition for that where we need to exit. If low is greater than high then we do not have a valid segment in the array and in this case we can say that we have exhausted our such space so we return 1 to say that X does not exist in the array.I'm short of space here so I'm writing these two statements in the same line so these two are our base conditions that would cause the recursion to stop or exit and this condition low > high is the same condition which were checking here to stop the loop. Let us now quickly simulate this recursion using an example. Let's say we have this array A a sorted array. of size 9 and we want to search for number 63 in this array. so we make a call to the function BinarySearch() and I will write BS here as a shortcut for binary search Okay we pass to the function the array A and lower index should be zero and higher than it should be A to say that initially the number can exist anywhere in the array,from index 0 to 8 and the number to be searched for is 63 now we go inside the function low > high? No, so we go ahead and calculate mid, mid would be calculated as 4, the element at index mid index 4 is 36 and 63 is greater than 36, so we come to this else condition, the third condition and we make a recursive call to search for 63 within range mid+1 would be 5 to 8. Now once again for this function, low > high is not true so we calculate mid, mid would be 6 if we take only the integral part and element at index 6 is 63, so we have found this element, we will return mid so we return 6 here and this method finishes and this method also return six to its caller may be the main method. Let us know say that we want to such for number 25 so we make this call to binary search from the main method. Now once again we calculate the mid now element at index 4 36 is greater than 25 so we make a recursive call to search for 25 from index 0 to three. Okay now is low > high? is 0 > 3 ? No, so we go ahead and calculate mid. Mid would be 1, element at index 1 is 6,25 is greater than 6 so we make a recursive call to search for 25 between indices 2 and 3. now mid would be 2 and this time we will make a recursive call to fine 25 in the range 3 to 3, still a valid range low is not greater than high. Mid would be 3 and now 25 is greater than 21 so we make a recursive call using the 3rd condition to mid+1 would be 4 and high would be 3 still, and this time low is greater than high so we come to this condition where this method simply returns 1 and finishes. Now this method also returns 1 and this gets propagated all the way up and finally this method returns 1 to its caller, the main method. While writing recursion we must be very careful about the base conditions like we have these two base conditions here. If we do not get our base conditions right, our recursion may go on endlessly causing the program's memory to overflow and causing it to crash. The time complexity of this algorithm is O(logn) and the time taken is proportional to logn and this comes from the fact that if we keep dividing the size of the array by 2 at each step then it will take us logn steps to reach array size equal to 1. Now one obvious question which one is better that the recursive implementation, a recursive implementation or an iterative implementation, well anything that you can write using recursion we can write it using iteration and anything we can write using iteration we can write it using recursion. Iteration is a slightly more performant It's better in performance because we do not have to store all these states of all these functions, the extra functions in the memory, but I writing recursion may sometimes be very intuitive and easy to write. For most practical reasons you may choose any of these according to your comfort. So that's not an issue. Okay so this was recursive implementation of binary search for you. Thanks for watching!