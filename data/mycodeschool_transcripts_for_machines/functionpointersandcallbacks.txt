In our previous lesson, we saw what function pointers are and then we wrote a simple program to understand how we can create function pointers in a C or C++ program. But, we did not discuss the real use cases of function pointers, real scenarios where function pointers can be useful. So, in this lesson, we are going to talk about the use cases of function pointers. All the use cases of function pointer are around this concept that function pointers can be passed as arguments to functions. And then a function that would receive a function pointer as argument can call back the function that this pointer will point to. To explain this better, i will have to write some code. First of all, I am going to write a simple function named A. This function takes no argument, returns void and simply print Hello on screen. Now, I will write another function named B. This function takes a function pointer as argument. ptr should point to a function that should take no argument and should return void, a function like A. Now, in B i will simply use this function pointer ptr to call whatever function its pointing to. Or in other words, I can say that i will call back the function passed to me or given to me through ptr. In the main function, I will declare a function pointer and this function pointer should also point to a function that should take no argument and should return void. I will initialize this function pointer p with address of A. And now, I will call this function B passing it this function pointer p. Let's run this program and see what happens. "Hello" is getting printed on screen. So, basically function A is getting executed. A is executed through this callback/. In the main function, instead of writing these two statements, I can simply write a statement like this and this should be good enough because name of a function, we had discussed this earlier also, returns a pointer. So, this one statement is same as previous two statements. When reference to a function is passed to another function, then that particular function is called a callback function. So, A is a callback function here. It can be called back by B through the reference, through the function pointer. This statement where we are calling the function through function pointer is a callback. We are still not doing something very meaningful here. Whats the point in calling A indirectly through B in this code. This is not making much sense. So, lets now look at a scenario where using a function pointer and callback can make our life easier. I have a simple scenario. i have a list of integers in an array and I want to sort this list in increasing order of the value of integers. To do so, i will write my own sort function. I am writing a function named sort that will take an array and number of elements in the array. The function will take an integer array. Here, I can write A and then brackets or I can write *A, these two are alternate syntax. I will use simple Bubble sort algorithm. i have renamed this function as Bubble sort. In Bubble sort, we make multiple passes on an array and in each pass, as we go from left to right, as we go from lower indices to higher indices, we compare adjacent elements and if the element at lower index is greater than the element at higher index while comparing adjacent elements, then we swap the elements. This inner loop is a pass on array. And this outer loop is basically saying that we will make n passes. After first pass, the largest element in the array will bubble up to the highest index and in the next pass the second largest will bubble up to its appropriate position. This will go on and finally in n passes, the complete list will be sorted. If you want to refresh Bubble sort, there is a link to MycodeSchool's lesson on Bubble sort in the description of this video. In the main function, I have called Bubble sort function passing it array A. And then, I am printing all the elements in A and hopefully elements should be printed in increasing order. The output is as expected. We have a sorted list here. Ok, now let's say I want to sort my list in decreasing order of the value of integers. So, what change should go in my code here. Think about it. The only change will be in this comparison logic. In this if statement. While comparing the adjacent elements, now i will say that , if the element in left is smaller, if the element at lower index is smaller, then swap or basically, then push it towards higher index. Comparing adjacent elements and swapping, is basically pushing smallest or highest element towards higher indices. With this condition, with this comparison, we are pushing the smaller number towards higher index. Let's see the output now. As you can see, I am getting the numbers in decreasing order. Now, my list is sorted in decreasing order of the value of integers. Now, lets say i have a requirement like this. Sometimes in my program, I want to sort a list of integers in increasing order and sometimes I want to sort a list in decreasing order of the value of integers. So, what all can I do. Think about it. One thing that I can do is, i can write two sort functions, first sort function to sort in increasing order and another sort function to sort in decreasing order. but if we will do so, there will be a lot of duplicate code. The two functions will be same except just one character, just this less than sign or greater than sign. Writing duplicate code has a lot of disadvantages. So, can we do something better. Another thing that we can do is, we can pass one more parameter to the sort function to say whether we want the list sorted in increasing order or decreasing order. We can have a flag. let's say when flag is one , we will sort in increasing order and when flag is 0, we will sort in decreasing order. Using this approach, we can avoid writing a lot of duplicate code. What I am going to do is, I am going to use a function pointer. Sorting of a list is always done on basis of some ranking mechanism. So, based on some property, we should be able to compare elements and say that this should come first and this should come later. The core logic will always be the same. only the ranking mechanism or comparison logic will change. What I am going to do here is, I am going to decide which element is greater in rank, and which element is lesser through a function. Basically , I will perform this comparison through a function. My function will take a function pointer as argument. My sort function will take function pointer as argument. the callback function or the function that this pointer should point to must take two integers as argument. It should compare the two integers and it should return back an integer. It should return 1 if first element has higher rank, 0 if the elements are equal and 1 if second element or second argument has higher rank. And let's say, the element that has higher rank will go towards the end in sorted array. towards higher indices. these are my assumptions while designing this sort function. Now, I am going to use my callback function for comparison, If A[j] and A[j+1] are now passed as arguments to this callback function and we get 1 , so this condition will be true, we will swap in this condition because A[j] will have to be higher in rank for this comparison function to return 1. So, we will try to push A[j] towards higher indices. Let's now try to use this particular implementation of Bubble sort. I will have to write a callback function first. i have written a function like this. Now, in main, i can just use the name of this function that will return me a function pointer and pass it in this call to Bubble sort. In this comparison function, I have not written a statement to return 0 if elements are equal. Equality doesn't matter in the logic, so for equality also I will return 1. Let's run this program and see the output. This is what I am getting. The numbers are sorted in increasing order. Now, I will change the comparison logic a bit. I will return 1 if A is greater than B. So, basically I have changed ranking mechanism. The element with lower value is now ranked higher and will go towards the end of the array. This is what I am getting upon running the program. The array is now sorted in decreasing order of the value of integers. This is a really good design because now, our sort function can sort a list of integers based on any ranking mechanism. We can have one callback function for each ranking mechanism. I will take one more example. Let's say, we have a list of integers, with both positive and negative values in it, i have modified A here. A now has both positive and negative values, This time I want to sort this array A in increasing order of the absolute value of integers. So, the negative sign will not matter. We will just take a MOD and then compare. This array A upon sorting should rearrange like this. To be able to sort, I will have to write a comparison function. Last time, we had modified the same compare function, but actually we should be writing one comparison function for each sorting scenario. So, I will write a new function this time. I will write a function named absolute_compare. I have included a reference to Math.h library and I will use abs function from this library that will give me absolute value of an integer. If absolute value of A is greater than the absolute value of B, then its ranked higher, i should return 1, else I should return 1. Let's now use this function to sort this array. I have a minor spell error here. Ok, instead of passing this compare function as argument, I will not pass absolute_compare in this call to bubble sort, this basically is passing a pointer to absolute_compare function. Lets now run this program and see what happens. This is what I am getting. The elements are sorted in increasing order of their absolute values. The bubble sort function here can take only an array of integers, but we have a library function that can take any array. So, its further generic. This library function is in stdlib.h library and its named qsort. qsort for Quick sort and to this function, you should pass an array and it can be any array, it can be an array of integers or it can be an array of characters or even a complex datatype, a structure. First argument will be an array, second argument will be number of elements in array. Third argument will be size of the data type. So, if this is an array of integers, I need to pass sizeof(int). size of data type in bytes. sizeof function gives size of any data type in bytes. Last argument should be a function pointer, a pointer to comparison function. Signature of the comparison function should be like this. It should take two constant void pointers as argument and return an integer. Why void pointers? void pointers are generic pointers. We can typecast them to a pointer of any data type. This is the specification of qsort function. It should be passed a pointer to such a function. So, it will be able to call it back. Let's write the comparison function. You can think of this as reference of first element passed as a void pointer. To get the element, if its a list of integers, I'll first have to typecast the void pointer to int pointer and then I'll have to use the asterisk operator to dereference and get the value. We will do the same to get the value of second element. This function must return any positive integer if A is ranked higher, a negative integer if A is ranked lower and 0 if both are ranked same. We can simply return AB and it will mean the same. if A is higher in value, AB will be positive and I am trying to create a simple comparison function here that would rank an integer with higher value as high. So, basically this comparison function can be used to sort the array in increasing order of value of integers. So, like I said, returning positive value means A is ranked higher, returning negative value means, B is ranked higher. With this comparison function, if I would simply pass this to qsort and after the call to qsort, print the value in this array, this is what I will get. As you can see, the list is sorted in increasing order of the value of integers. If I will change this comparison function to return BA, so element with lesser value, integer with lesser value will be ranked higher, the list will be sorted in decreasing order of the value of integers and if I will use absolute value of A minus absolute value of B, this is what I will get. Remember, in this comparison function, the two elements to be compared are being passed through reference, their addresses are being passed through a pointer. The const keyword here means, you cannot modify the address in this pointer variable. We are having to use void pointer because of generic design of qsort function. Remember, qsort can sort any array, not just an integer array. its just that, you will have to give the comparison logic. Ok, so we just discussed one of the use cases of function pointers. This whole idea of callback is used in a lot of interesting design scenarios. One more thing where his concept of callback makes our life easier is something called event handling. If you are curious, you can check the description of this video for some resources on event handling. This is it for this lesson. Thanks for watching !