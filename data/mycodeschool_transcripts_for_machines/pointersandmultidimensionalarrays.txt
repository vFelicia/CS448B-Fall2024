In our previous lesson, we saw how we can work with two dimensional arrays using pointers. Now in this lesson, we will see how we can work with arrays of further higher dimensions like three dimensional arrays using pointers. We will also see how we can pass multidimensional arrays as arguments to functions because that's one scenario where pointers once again will come into picture. I will start with a quick recap of what we have discussed in our previous lesson. Whenever we create a multidimensional array and let's pick up the example of twodimensional array that he had created in our previous lesson. We must think of the multidimensional array as array of arrays. Array basically is a collection of similar things of similar objects, so a multidimensional array is basically a collection of arrays. This array B here is a collection of onedimensional arrays of 3 elements each. We have 2 1dimensional arrays of 3 elements each. What I have tried to show in this figure is how array B will be organized in memory. I have assumed that the starting address of the array is 400. Each cell storing an integer here is a block of four bytes. As we know each byte in computers memory has an address. I'm not drawing all the bytes, partition for all the bytes i'm drawing blocks of 4 bytes each and that's why I am writing only the starting address of each block. You can imagine a block of 4 bytes something like this. The starting address is 400. Let's say each partition here is 1 byte so the next byte has address 401 and the next 1 has address 403 and the next one has a address of 403. Overall this first block of 12 bytes that contains these three integers 2 , 3 and 6 that showing in yellow here is my first one dimensional array that I can call B[0] and this next block of 12 bytes is my second one dimensional array of three integers that I can call B[1]. So we have two onedimensional arrays in our collection. We have two collections of three integers each in our collection and everything is organized in one contiguous block of memory. Now let's look at this, B[0] is from byte address 400 till 411. We have three integers and we have four bytes for each integer. The first integer that we can access as element at zeroth index of B[0] is taking four bytes starting address 400. The next integer that can be accessed as B[0][1], oneth element of B[0] will take next four bytes starting 404 and the next one will be B[0][2] element at index 2 of B[0] and similarly we will have 4 bytes for zeroth element of B[1], 4 bytes for oneth element and 4 bytes for element at index 2 of B[1]. As we had seen in our previous lesson, when we just used to the array name then it returns as a pointer to the first element of the array. Here B is a twodimensional array. It is an array of onedimensional arrays of size 3. So B will basically return us a pointer to onedimensional array of three elements, pointer to one dimensional array of three integers. In this statement, i have declared a variable which is pointer to 1 dimensional array of 3 integer and the name of the variable is P. A statement like this is all right. A statement like this will not be alright because B will not return a pointer to integer. B will return a pointer to onedimensional array of three integers. Now I'm will write 3 print statements that I had also written in our previous lesson. I'm not writing the complete syntax for printf. Okay so once again you need to tell me what will be the output if we would print these three expressions. We have B, *B and B[0]. Well for all these three, output will be four hundred. Here when we say B, just using the array name B will return as a pointer to the first onedimensional array in B. The type of a pointer variable is relevant only when we are trying to dereference or perform pointer arithmetic. But if would just try to print the address stored in the pointer variable it will be the starting address, address of the first byte of a block of memory. So if we have a pointer to this onedimensional array that is storting 2, 3 and 6 then its address is 400. Now when we did an *B which is same as B[0], we dereferenced and now we have got the complete onedimensional at array B[0]. Now if I use B[0] because B[0] is a onedimensional array, we will get to pointer to the first integer in B[0]. So we will get a pointer to B[0][0]. This block of 4 bytes starting address 400. Once again if we would just print the address, then the starting address of this block is 400 that's why the output is 400. Even if I would print &B[0][0] output will be 400. B and *B are both returning us pointers. The difference is that B is returning pointer to a onedimensional array of three integers, while *B is returning pointer to an integer. When we are just printing the address, both these objects the complete onedimensional array B[0] and the first element in B[0] have the same starting address so the same starting address will be printed. The type of pointer play role when you try to dereference or when you try to perform pointer arithmetic. We had also seen at previous lesson that B[i][j] can be return as *(B[i]+j). If B[i] for some value of I is one dimensional array then B[i] will give us an integer pointer, will return us an integer pointer to the first integer in B[i] then adding j is basically performing pointer arithmetic and getting a pointer to integer at index j in one dimension B[i] and then finally this dereferencing is getting the value of that integer. Once again B[i] can be written as *(B+i). B is pointer onedimensional array of 3 integers. So (B+i) will also return us pointer to 1 dimensional array of 3 integers and dereferencing this particular dereferencing will give us the 1 dimensional array and the name of onedimensional array returns us pointer to the first element in the array. So this once again will be pointer to integer. By now if you clearly understand how all the pointer arithmetic and dereferencing is happening in these expressions then it's not very difficult to understand how things will be for say, threedimensional array. Now let's say we have created a three dimensional named C. We have an array of 3 x 2 x 2. A three dimensional array is basically an array or collection of two dimensional arrays. So if I have to show C in memory. I will show it something like this. I have assumed that the starting address of C is byte address 800. The first 16 bytes starting address 800, is my first twodimensional array. I am assuming that each integer will take four bytes so all the cells in yellow are part of the twodimensional array. The next block of 16 bytes starting address 816 is C[1] and the next block of 16 bytes starting 832 is C[2]. We can further break down the twodimensional arrays into onedimensional arrays. The first two integers in C[0] are part of the first one dimensional array C[0][0], and 7 and 9 a part of C[0][1]. The first integer in C[0][0] can be accessed as C[0][0][0] and we can go on like this. Okay once again we will play the same game. I will print statements and you need to guess the output. This time just using the array name C will give us a pointer to twodimensional array of intergers of size 2 x 2. So we can write a statement like this. I have declared a pointer to twodimensional array of integers of size 2 x 2 here. The name of the pointer is P. If I would just print P or C here and I'm not reading the complete printf statement, once again my output will be 800. Now if I will perform are dereferencing and try to print *C then this will be same as C[0] and C[0] is a two dimensional array. So we will get a pointer to the first element in C[0]. All these expressions are returning us pointer to move one dimensional array of integers of size 2 and the address printed will be 800. Remember C is of type pointer to 2d array of 2 x 2 and dereferencing once is giving us pointer to onedimensional array of two integers. C is returning us pointer to two dimensional array of integers. C itself is an array. There is difference between the two types. Okay for C, C[i][j][k] where i, j, k are some indices can be written as *(C[i][j]+k) and now once again, we can write C[i][j] as *(C[i]+j), and the overall expression will look something like thi. and we can go ahead and write C[i] as *(C+i). If you are able to understand how I had to drive these expressions, if you are able to understand all the pointer arithmetic and dereferencing in these expressions and then you are good working with dimensional arrays using pointers. I want a quick answer for this one. What will be the output for this print statement. Well C[0][1] means we're going to this onedimensional arrays that has these 2 elements 7 and 9 and when we are using array name C[0][1] we are getting a pointer to first integer in this onedimensional array. Pointer to this integer 7, adding 1 that we are doing pointer arithmetic to an integer pointer so they will go to nine and dereferencing will give us interger 9. In fact this expression is same as C[0][1][1]. Now what will be the output for this print statement *(C[1]+1). C[1] will return us a pointer to onedimensional array. The first one dimensional array in C[1], this block containing integers 3 and 4. Adding 1 is performing pointer arithmetic and going to the next one dimensional array. It's going to this onedimensional array containing 6 and 1, and now dereferencing is basically getting the onedimensional array from the pointer and if you just used a name of the onedimensional array, you get a pointer to the first element in onedimensional array. So we will get a pointer this integer 6. Output will be 824. This block of 4 bytes storing address storing integer 3 is 816. Next would be next will be at 20 and next will be a 24. We can try out these expressions in the real program. I am writing this simple C program. I have created this threedimensional array C. The data filled in is same as we were showing in the example. In the first printf statement, I am writing, I'm trying to print C, *C C[0] and &C[0][0]. All of these are pointers and if I would just use %d address would be printed. When I'm running this code, as you can see the output far all these for expressions it same. Any guesses for what will be the output for this print if statement. This expression is nothing but C[0][0][1]. The output for first printf is different because this is a different run of the program and in each run, the signed address would change but whatever the address is it will be seen for these for expressions. I would recommend trying out all the different expressions that were decoding earlier in a real program like this. Okay the next thing that I want to talk about is passing multidimensional array as function arguments. I'm going to declare a function and let's name this function Func and I want this function to accept a threedimensional array as argument. So what do I do. If I wanted a onedimensional array as argument, I could have given something like this. But as we had discussed in one of our previous lessons, this syntax is only a syntactical sugar it is interpreted like this by the compiler. A fresh copy of array is not created for function call. Only a reference to it in the form of a pointer is created. So now if in the main function, I have an array a one dimensional array like this and let's say the return type of this function is void. I can make a function call passing B like this and this will be fine. Now let's say we declare 2 dimensional array of 2 x 3 and now the want this function to receive to take a twodimensional array as argument. Now as we discussed, A will return us pointer to integer but B will us a pointer to array of three integers, onedimensional array of three integers for this particular definition of B. So for the function to take this array B as argument. Definition should be something like this. The arguement should be something like this. Either we can write or we can write something like this. Only the first dimension can be left empty. The other dimension has to be specified, and now I can pass B. There is something interesting here. If I would declare a twodimensional array something like this. Let's say I declare twodimensional array X of 2 x 4. Now I cannot pass X to the function because X will return pointer to onedimensional array of 4 teachers while this function is suppose to receive onedimensional array of 3 integers. If X is defined something like this of dimension 5 x 3 then passing X is fine. Now if we want to pass this threedimensional array, then once again we need to see what pointer types C will return. So will basically return a pointer to twodimensional array of 2 x 2 so we can either use a syntax like this or something like this, and then we can pass C. So this is how things will be for any multidimensional array except the first dimension, all other dimensions will be enforced. One common mistake that people do is, for a twodimensional array they try to use pointer to pointer something like this and for a three dimensional array they try to use something like this which just wont work. So this is pretty much what we wanted to talk about pointers and multidimensional arrays. Thanks for watching.