in this lesson we're going to talk about function pointers Function pointers, as the name suggests are used to store address of functions. So far, we have used pointers mostly as variables that would store address of other variables. Basically pointers are data types that can be used to store the address of some data stored in computer's memory or in other words to point to or refer to some data and it doesn't always have to be a variable data could be stored as constant also and we use pointers not just to store the address we can dereference and get the value at whatever address the pointer is pointing to now we are saying that we can have pointers that can store address of functions or in other words can point to functions and we can use a pointer to function to dereference and execute the function and this is really interesting some basic questions would popup. What really would be the address of a function and even if we can have pointers to functions what are the use cases in which we may want to have them there are really interesting use cases of function pointers we will talk about them later let's first try to understand the core logic here. Once again, I have drawn this familiar diagram the memory that is allocated to an application or a program can typically be divided into these four segments we have talked about this quite a bit in our previous session's okay, now a program is basically a set or sequence of instructions that you would give to the computer to perform a task. We can write our program in a highlevel language like C or C plus plus but at lowest level in its architecture computer understands and executes only binary. Any instruction that has to be executed by the computer has to be encoded in binary. Of course there will be some rules for encoding so what we do is we write our program or set of instructions in a highlevel language like C or C plus plus and we pass it to a program called compilers as input and corresponding to the source code compiler generates what we called machine code or executable code which is instructions encoded in binary something like what I'm trying to show here compiler basically takes one or more source files let's say the program that have written here is in a file named program dot c. Now, a compiler for C language will take this file as input and create an executable file that will have the machine code On a Windows machine executable files has extension exe. An executable file will be stored in disk drive or some secondary storage device whenever we say memory, just memory in context of programming we mean that random access memory or RAM that we also called the main memory are primary storage. So whatever application's memory we're talking about here will be a chunk of main memory. A program or application gets a chunk of memory only when it starts execution when the application finishes execution, this memory is claimed back What really happens is that when we run a program when a program started execution, some amount of a memory is allocated to it and that is what we're calling applications memory here. The code or text segment of application's memory is basically the machine code or instructions copied from the executable file instructions are not executed directly from secondary storage they are first copied to main memory and then only they can be executed during program execution we need memory not just to store instructions to be executed but also to store a lot of data that we would work upon in a program these other segments are mostly about storing and managing data what I'm going to do now is I'm going to zoom in to the code or text segment Let's assume that each instruction in machine language takes four bytes. I'm trying to show the section of memory storing the instructions here each partition here is a block of four bytes and actress is increasing from top to bottom so we have instruction 01 at address 200 and the next instruction is at address 204 and the next is at 208 and so on Instructions in a program are executed sequentially Only exception will be when instruction itself will say that hey, go to or jump to this other instruction at this particular address which will happen in case of function calls for example if instruction 01 at address 200 is currently executing by default the next instruction to be executed is instruction02 at address 204 Unless instruction 01 is itself something like go to instruction 05 at address 216 which will happen in case of function calls. A function is nothing but a set of instructions stored in one contiguous block of memory let's say this block containing instructions 5 till 8 is a function. I'll name this function func1. Basically a function is a set of instructions to perform a subtask. In memory a function will be one contiguous block with some instructions. The address of a function what we also call entry point of a function will be the address of the first instruction in the function. In this example here address of func1 is 216 a function call in machine language will basically be an instruction to jump to entry point of some function to jump to first instruction in a function We will not go any deeper into architecture now, this is good enough to understand function pointers when we say function pointers store address of functions we basically mean that function pointers store the starting address or entry point of the block of memory containing all the instructions in a function let's now see how the can create and use function pointers in a C or C plus plus program I'm going to write a simple C program here the first thing that I'm going to do is I'm going to write a function named Add that will take two integers as argument and return the sum of these two integers and now I'm going to create a function pointer that should point to this function Add. The syntax to create function pointer is first type in the return type of the function to which this pointer will point. Add will return int. So, I typed in int then after space within parentheses type in asterisk and then name of the variable so I'm creating a pointer named 'p' and now once again within parentheses type in all the argument types of the function to which this pointer will point argument types in function declaration should be exactly same as in the function to which this pointer will point because both the arguments in Add function are Int we have two ints in the declaration of function pointer also. To initialize function pointer and fill in the address of a function, we can use a statement like this. as we know ampersand operator gives us the address of something this statement p = &Add will give us the address of Add in 'p' so 'p' now points to Add and using 'p', we can execute this function Add. What I'm going to do here is that I'm going to declare an integer variable named 'c' and now I'm going to write a statement like this. What I've done here is first I have used the asterisk operator to dereference and get the function and then i have passed arguments just like I would do with a function name. So, i've passed two integers two and three and if everything is alright the output of this printf statement here should be integer value 5. When I run the program, this is what I get. So this is really cool. We just used a function pointer to refer to a function and then execute the function. One thing about the syntax of function pointer declaration We are putting the identifier or name of the pointer within this parentheses if we would not use the parentheses, then it will mean that we r declaring a function that will return pointer to integer in this case. If I would write something like this, I would write a declaration something like this, then this is declaring a function that would return pointer to integer. We can have an asterisk just before the function name or we can have an asterisk just after int. These 2 syntax are same, but if I would put this within parentheses, then this is declaring a function pointer. Okay, few more things In this initialization here, we are using this ampersand operator even if we do not use this ampersand operator it will mean the same. Just using the function name will also return us address of the function or in other words, an appropriate pointer. To dereference, instead of using this parentheses and asterisk operator with function pointer name, we can simply use the function pointer name and this is good enough. So, we can use function pointer name or identifier just like function name as you can see the output here is as expected so we have two possible syntax for both referencing and dereferencing you can use whichever you like. The second one is more famous One final thing, to be able to point to a function type of the function pointer must be appropriate, so in this declaration of 'p' here if I would change it something like this then this function pointer is meant to point to a function that should take two integers as argument and should return void. Add function is returning int so 'p' cannot point to Add. This will give me compilation error. Once again, if I will change the declaration something like this if I will have only one argument in the declaration of a function pointer, then P cannot point to Add. Okay, now let's use some more functions with different signatures and try to execute them through function pointers. I'm writing this function PrintHello it will simply print "Hello" onscreen. We will have to declare a function pointer like this. and then we can initialize the pointer and fill in the address of this function and now we can execute the function through this pointer Let's see what the output is. this looks alright. now let's say we want to say "Hello" to someone and i'll change the signature of PrintHello To take a string as argument, the declaration of function pointer will also change. and while calling we will have to pass a string upon running this program, this is what I get and this is also looking fine So this is pretty much how we can create and use function pointers in C or C plus plus. Function pointers are used in a program in interesting scenarios, they have interesting use cases. we'll talk about the use cases in next lesson. This is it for this lesson Thanks for watching !