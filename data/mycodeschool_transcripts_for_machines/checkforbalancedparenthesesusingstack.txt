In our previous lesson, we saw one simple application of stack we saw that stack can be used to reverse a list or collection or may be to simply traverse a list or collection in reverse order. In this lesson, we will discuss another famous problem that can be solved using stack. And this is also a popular programming interview question and the problem is, given an expression in the form of a string comprising of let's say constants,variables, operators and parenthesis and when I say parenthesis I also want to include curly braces and brackets and my definition of parenthesis. so my expression or string can contain characters that can be upper or lower case letters, symbols for operators and an opening or closing parenthesis or an opening or closing curly brace on an opening or closing square bracket. Let's write down some expressions here. I'm going to write a simple expression. We have one simple expression with one pair of opening and closing parenthesis. Here in this expression we have nested parenthesis. Now given such expressions we want to write a program that would tell us whether parenthesis in the expression are balanced or not and what do we really mean by balanced parenthesis what we mean by balanced parenthesis is that corresponding to each opening parenthesis or opening curly brace or opening bracket we should have a closing counter part in correct order. These two expressions here are balanced. However this next expression is not balanced.A closing curly brace is missing here This next expression is also not balanced because we're missing an opening square bracket here. This next one is also not balanced because corresponding to this opening curly brace we do not have a closing curly brace and corresponding to this closing parenthesis we do not have an opening parenthesis. if we are opening with a curly brace,we should also close with a curly brace.These 2 count for each other.Checking for balanced parenthesis is one of the tasks performed by a compiler, when we write a program we often miss an opening or closing curly brace or an opening or closing parenthesis. Compiler must check for this balancing and if symbols are not balanced it should give you an error.In this problem here what's inside parenthesis does not matter, we do not want to check for correctness of anything that is inside a parenthesis so in the string any character other than opening and closing parenthesis or opening and closing curly brace or opening and closing square bracket can be ignored. This problem sometimes is better stated like this "Given a string comprising only of opening and closing characters of parenthesis braces or brackets we want to check for balancing". So only these characters and their order is important. While parsing a real expression we can simply ignore other characters. All we care about is these characters and their order. Okay so now how do we solve this problem?. One straight forward thing that comes to mind is that because we should have a closing counter part for an opening parenthesis or opening curly brace or opening square bracket what we can do is, we can count the number of opening and closing symbols for each of these three types and they should be equal. So the number of opening parenthesis should be equal to number of closing parenthesis. and the number of opening curly braces should be equal to number of closings curly braces and same should be true for square brackets as well but it will not be good enough this expression here has one opening parenthesis and one closing parenthesis but it's not balanced this next one is balanced but this one with same number of characters of each type as the second expression is not balanced so this approach won't work. Apart from count being equal that are some other properties that must be conserved. Every opening parenthesis must find a closing counterpart to its right and every closing parenthesis must find an opening counterpart in its left which is not true in the first expression. And the other property that must be conserved is that a parenthesis can close only when all the parenthesis opened after it are closed. This parenthesis has been opened after this square bracket so this square bracket can not close unless this parenthesis is closed. Anything that is opened last should be closed first. Well actually it should not be last opened first closed in this example here this is getting opened last but this guy I that is open previous to this is closed first and it is fine. The property that must be conserved is that as we scan the expression from left to right any closer should be for the previous unclosed parenthesis any closer should be for the last unclosed. Let's scan some expressions from left to right and see how it's true. Let's scan this last one we will go from left to right first character an opening of the square bracket second one is an opening parenthesis Lets mark opening of closed parenthesis in red. Okay now we have a closer here , the third character is a closer. this should be the closer for last unclosed. So this should be the closer for this one, this guy, this opening parenthesis. last unclosed now is this guy. Next character once again is an opening parenthesis. Now we have two unclosed parenthesis at this stage and this one is the last unclosed, the next one's a closure.So it should be closer for the last unclosed. Now the last unclosed once again is the opening of square bracket now when we have a closer it should be closer for this guy. we can use this approach to solve this problem what we can do is we can scan the expression from left to right and as we scan at any stage we can keep track of all the unclosed parenthesis basically what we can do is whenever we get an opening symbol an opening parenthesis an opening curly brace or an opening square bracket, we can add it to a list. If we get up closing symbol it should be the closer for the last element in the list, in case of an inconsistency like if the last opening symbol in the list is not of the same type as the closing symbol or if there is no last opening symbol at all because the list is empty. We can stop this whole process and say that parenthesis are not balanced else we can removed the last opening symbol in the list because we have got its counterpart and continue this whole process. Things will be further clear if I will run through an example. I will run through this last example once again. We are going to scan this expression from left to right and we will maintain a list to keep track of all the opening parenthesis that are not yet closed. We will keep the track of all the unclosed parenthesis opened but not closed. Initially this list is empty, the first character that we have got is an opening of square bracket. This will go into the list and we will move to the next character the next character is an opening parenthesis so one stick, once again it should go to the list. We should always insert at the end in the list. the next character is a closing of parenthesis now we must look at the last opening symbol in the list and if it is of the same type then we have got it's counterpart and we should remove this. Now we move on to the next character this is once again an opening parenthesis, it should go in the list at the end. The next character is a closing of parenthesis so we will look at the last element in the list, it's an opening parenthesis, so we can remove it from the list and now we go to the last character which is a closing of square bracket once again we need to look at the last element in the list we have one element only one element in the list at this stage, its an opening of square bracket so once again we can remove it from the list. Now we're done scanning the list and the list is empty once again if everything is alright if parenthesis are balanced we will always end with an empty list and if list is not empty then some opening parenthesis haven't found its closing counterpart and expression is not balanced. One thing worth noticing here is that we are always inserting and removing one element at a time from the same end of the list in this whole process whatever is coming in last in the list is going out first, there is a special kind of list that enforces this behavior that element should be inserted and removed from the same end and we call it a stack. In a stack we can insert and remove an element one at a time from the same end in constant time. so what we can do is whenever we get an opening symbol while scanning the list we can push it onto the stack and when we get a closing symbol we can check whether the opening symbol at the top of stack is of the same type has the closing symbol, if its of the same type we can pop, if it's not of the same type we can simply say that parenthesis are not balanced I will quickly write pseudocode for this logic I'm going to write a function named CheckBalancedParenthesis() that will take an expression in the form of a string as argument. first of all iI will store the number of characters in the string in a variable and then I will create a stack and I will create a stack of characters and now I will scan the expression from left to right using a loop, while scanning if the character is an opening symbol if it's an opening parenthesis or opening curly brace or opening square bracket we can push that character onto the stack, let's say this function Push() will push up character onto S else if exp[i] or the character at ith position while scanning is a closing symbol of any of the three types. We can have two scenarios if stack is empty, or top of stack does not pair with the closing symbol if we have a closing of Parenthesis then the top of stack should be an opening of Parenthesis. It cannot be an opening of curly brace, in such a scenario we can conclude that the parenthesis are not balanced else we can perform a pop. Finally once a scanning is over we can check whether a stack is empty or not if it's empty Parenthesis are balanced if it's not they are not balanced. so this is my pseudo code let's run through a couple of examples and see whether this works for all scenarios all test cases or not. Let's first look at this expression, the first thing that we're doing in our code is that we're creating a stack of characters, I have drawn logical representation of a stack here. Okay now let's scan this string, let's say we have a zerobased index and a string is just are character array, we are starting the scan and going inside the loop. This is a closing of Parenthesis so this if statement will not hold true so we will go to the else condition and now we will go inside the else to check for this condition whether stack is empty or not or whether the top of stack pairs with this closing symbol or not, the stack is empty, if the stack is empty there is no opening counterpart for this closing symbol. so we will simply return false, returning means exiting the function so we are simply concluding here that Parenthesis are not balanced and exiting. Let's go through this one now, first we have an opening squad bracket so here we go to the first if and push, next one is an opening parenthesis once again it will be pushed next one is a closing square bracket, so the condition for this else if will be true we will go inside this else if, now this time to top of stack is an opening parenthesis it should have been an opening square bracket and then only we would have a pair so this time also we will have to return false and exit. Okay now let's go through this one. First we'll have a push, the next one will also be a push, now next one is a closer of parenthesis which pairs with the top of stack which is opening of parenthesis so we will have a pop, we will go to the next character and this one once again is an opening parenthesis so there will be a push. next one is a closing parenthesis and the top is an opening parenthesis ,they pair so there will be a pop, last character is a closing curly brace so once again we will see whether the top of stack is an opening curly brace or not? do we have a pair or not? yes we have a pair so there will be a pop with this our scanning will finish and finally stack should be empty it is empty so we have balanced Parenthesis here try implementing this pseudo code in the language of your choice and see whether it works for all test cases or not. If you want to look at my implementation you can check the description of this video for a link. In the coming lessons we will see some more problems on stack. This is it for this lesson, thanks for watching!!