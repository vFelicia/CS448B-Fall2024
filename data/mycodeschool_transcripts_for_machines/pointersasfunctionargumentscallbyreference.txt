In our previous lessons, we defined pointer variables and we also saw how to operate upon pointer variable, how to work with pointer variables in c or c++ program but we did not really talk about the real use cases of pointer variables, in what scenarios we may want to use pointer variables So in this lesson we will talk about one of the use cases of pointer variables and the use case is using them, using pointers as function arguments and we also term this as call by reference so let's discuss a scenario Albert is a beginner programmer and he has recently learnt about the concept userdefined functions Now, he tries to apply this concept and he writes a simple C program like this what he is trying to achieve here is that he has an integer variable declared and initialized in the main method and wants to increment the value in this variable by one so instead of writing something like a plus plus, or a equal to a plus one instead of writing a statement like this he writes a function increment that will take an integer a as argument and inside this function he's writing a statement like a is equal to a plus one He calls this function increment from the main method passing a as argument and then he prints the value of a now what he is expecting here is that the value of a will be incremented to eleven and hence the print statement will print a = 11 but when he runs the program, the output of the print statement is a = 10. Now, Albert does not understand why this is happening he has declared a valuable a and then he has initialized this variable to 10 and then he is passing the same a to the function increment and the same a is being incremented by one in this function so why the value of a being printed is not eleven why is it 10 now what Albert does not understand well or what he probably forgot is that whenever we declare a variable inside a function then we call that variable a local variable because as such just using the variable name we can access that variable only inside the same function in which we have declared the variable so these two a this a in the function increment and this a in the function main are actually not the same a the 'a' in the function increment is another 'a' when main calls the method increment and passes this a as argument to the function then only the value of a is copied to this another 'a' which is another variable local to the increment function so what i'll do is, i'll do couple of modifications in this code to show you a better picture I will write two print statements in this code first print statement in the increment method something like this address of variable 'a' in increment is uh... as we know if we put ampersand operator in front of a variable name then we get the address of that variable and i'll comment out this print and i'll write one more print in the main method like this and here i print that the address of variable 'a' in main is ampersand 'a' let us now run this and see what happens uh... let me also put and en of line after we print the statement and the output is address of variable 'a' in increment method is printed as four four five four four six zero and in main it is equal to four four five four six six two these two look similar but they're not the same one is having four four six seven zero in the end and the another is having four four six zero what the values are is not important what the addresses are is not important what's important is that these addresses are different if the 'a' in main method and the 'a' in increment method were same these two addresses would have been same To understand this even better, we will try to understand how things happen in computer's memory when a program executes When a program on an application is started then the computer sets aside the machine sets aside or reserves some amount of memory for the execution of this program the memory that is a set aside for the application is divided into is typically divided into these four parts that we are showing here one part of memory is allocated to store the various instructions in the program the computer needs to keep all these instructions in the memory these instructions that we have in the program like increment or declare these variables all these sequential instructions one part of the memory is one part of the allocated memory is for static or global variables if we do not declare a variable inside a function in c++ or c , then it is a global variable Now global variables can be accessed and modified anywhere in the program unlike local variables which can be accessed and modified within a particular function or within a particular code block now tthe third part of applications memory is called as stack and this is really important this is where all the local variables go and we will mostly be talking about stack in this lesson and the fourth part is heap and we will come to this later in our forthcoming lessons of these four segments of the allocated memory uh... the text segment the global variable segment and the stack segment these three are fixed and they are decided when the program starts executing the application however can keep asking for more memory for its it's heap segment during its execution only we will cover all of these things in detail in our forthcoming lessons, please do not get scared by these terms let us now see what happens when a program executes let us say this is our computer's overall memory the RAM and as we know each byte in the memory is addressable. so, let's say uh... the memory allocated for our program is from address two zero zero to eight zero zero and these are the various segments of our application's memory and of this let's say uh... address three hundred to six hundred is allocated for stack now there is more memory of course in the RAM after uh... address 800 and before address 200 Ok, so from 200 to 800 this part of the memory is assigned for our program let's say this Cprogram that we have in the left Now, when a function is invoked like when the program starts the main method is initially invoked all the information about the method all the information about the method call like its parameters, all the local variables the calling function to which it should return the current instruction at which is executing, all this infromation it's stored in the stack so we will take out from the stack some part for the main method and create a unit which we call stack frame Each function will have a stack frame now we have a variable 'a' now memory is allocated for 'a' from this stack frame and the value of 'a' is 10. now the main method calls increment function what happens when main method calls increment is that uh... machine says that hey i will stop your execution for some time i will stop at this particular instruction. let me go ahead finish this method increment and then i'll come back to the main method once I am done with increment now another stack frame is allocated for the increment method and the parameters in increment method like we have a parameter 'a' so fresh local variables are created corresponding to these parameters and whatever values have been passed are copied to these variables, these parameters now when we say a = a+1 here in this statement then what happens that this 'a' which is local to the increment function, in this particular stackframe this 'a' is incremented they cannot access a variable outside its stackframe and now increment finishes When increment finishes, the control returns to the main method and what the machine does is it clears the stackframe that was allocated for increment and main method resumes again. So, main method was paused at this particular instruction increment so life time of a local variable is till the time the function is executing. Now, the next statement in main method is a call to the function printf printf is not a user defined function. It is a library function the state of execution of main method is kind of paused and printf is executing now we often call this particular structure call stack or function call stack whatever function is at the top of the stack is executing and remember this stack is fixed in size. So, if you have a scenario where one function keeps calling another function indefinitely like in the case of indefinite recursion then the memory of this stack will overflow and our program will crash ok, but that is not relevant for this scenario so now you must be getting a picture of what happens when one function calls another function this 'a' is in the stackframe of the main method main is our calling function and increment is our called function When we call a function in the calling function, the argument is also known as actual argument and in the called function, the argument is known as formal argument all that happens is that actual argument is actually mapped to a formal agreement so when this function call happens 'a' mapped to, 'a' as an actual argument is mapped to another 'a' which is a formal argument instead of 'a' , if we were having a 'x' here so we would have written something like int x is the argument and 'x' is x plus one then 'a' would have been mapped to x so the value of 'a' will be copied to variable 'x' Now,when we make such a function call where we basically have one variable being mapped to another variable, the value in one variable copied to another variable, then such a function call is also called as call by value so this is what Albert was doing making a call by value and that's why he was he was not able to get the desired result but can we get the result that Albert wanted to have Albert wanted to use this variable 'a' which is local to the main method inside the increment function Can we really do so? Well ! yes, we can do so if we use pointers as function arguments. let us now look at this code and I am drawign only the stack here so that i'm able to show the simulation of program execution neatly. Now what we're doing here is that we do not have an argument which is integer in this function increment, we have an argument which is pointer to integer and pointer to integer as we know will store the address of an integer so now what we are doing is that in the increment function, we are passing the address of 'a' so when the program will start executing, the main method will be invoked first. Let's say this is the stackframe of the main method let's say 300 to 350, this address is the stackframe of the main method and of main method there would be a local variable 'a' in this main method, let's say the address at which 'a' is stored is 308 this may not be in proportion but still let's say this is how it is stored Now when main method calls increment then a local variable corresponding to the parameter 'p' is created and this is a pointer to integer and the value that is passed to this particular function the value that gets stored in this particular sorry its not a function, its a variable. the value that gets copied or stored in this particular variable would be 308, the address of 'a'. So. 'p' is pointing to 'a' Now, in this statement here, when we say asterisk 'p' we dereference this address, so we are saying here that *p is value stored in address p so we say that increment the value stored at address p by one the value stored at address 308 gets incremented by one. So 'a' is now eleven so, now when increments initiatives and we come back to the main method and the next line gets executed which is the print statement then a is now 11 if u run this program then what gets printed is a = 11 such a function call in which, instead of passing the value of a variable, we pass the address of the variable, so that we have a reference to the variable and we can dereference it and perform some operations is called call by reference so if we use pointers as function arguments then we are using call by reference. Call by reference can save us a lot of memory because instead of creating a copy of a large and complex datatype if we just use a reference to it and using a reference will also cost us some memory, but very small amount of memory, then we are saved from creating a new copy of a complex datatype in the coming lessons, we will see more of the layout of application's memory and what all things we can do using pointers So, thanks for watching !