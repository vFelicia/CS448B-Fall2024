In our previous lessons, we wrote some basic code for binary search tree but to solidify our concepts we need to write some more code so I have picked this simple problem for you. Given a binary search tree, we want to find minimum and maximum element in it. Let's see how we can solve this problem. I have drawn logical representation of a binary search tree of integers here. As we know in a binary search tree, for all nodes value of nodes in left subtree is lesser and value of nodes in right subtree is greater. This is how we can define node for binary search tree in C C++. We can have a structure with three fields, one want to store data another to store address of left child and another to store address of right child. As we had seen earlier in BST implementation identity of the tree that we always keep with us that we pass to functions is address of the root node. So what I want to do here is I first want to write a function named FindMin that should take address of the root Node as argument and return me the minimum element in the tree, and just like FindMin we can write another function named FindMax that can return us the maximum element in BST. Let's first see how the can find the minimum element. there are two possible approaches here. We can write an iterative solution in which we can use a simple loop to find a minimum the element or we can use the recursion. Let's first see the iterative solution. If we have a pointer to the root node and we want to find the minimum element in BST, then from root we need to go left as long as it's possible to go using the left links because in a BST for all nodes, nodes in left have lesser value and nodes in right have greater value. So we need to go left as long as it's possible. We can start with the temporary pointer to root node. We can name this pointer temp or we can this pointer current to say that we're currently pointing to this node. In my function here, I have declared this pointer to BST node named current and initially I'm setting the address of root in it, and with this pointer we can go to the left child with a statement like current = current>left. We first need to check if there is a left child and then we need to move the pointer. We can use a while loop like this. If the left child of current node is not null, we can move this pointer current to the left child with a statement current = current > left. Here in this example, we are pointing to this node with value 15. It has a left child so we can move to this node with value 10. Once again this node too has a left hand so we can go left again. Now this node with value 8 does not have a left child, so we cannot go towards left any further. We will come out of the while loop and at this point the node we are pointing to has minimum value, so we can return the data in that node. There is one case that we are missing in this function. If the tree is empty, We can throw some error and we can return some value indicative of empty tree. If I know that the tree would have only positive values, I can return something like 1. So here, in my function have added this condition if the root is equal to null, that is if the tree is empty print this error and return 1. One more thing, We do not need to use this extra pointer to BST node named current. Root, here is our local variable and we can use this root itself. So we can write our code like this, while left of root is not equal to null we can go left with the statement root = root > left and finally, we can return root > data which is only an alternate syntax for (*root).data. Modifying this local root is not going to modify my root in main function or whatever function I'm calling this FindMin function from. So this our iterative solution to find minimum element in BST. The logic for finding maximum is similar. The only difference will be that instead of going left, we will have to go right all the time. I leave it for you to implement. Let's now see how we can find minimum element using recursion. If we want to reduce this problem in a recursive manner, in a selfsimilar manner then what we can say is, if the left subtree is not empty then we can reduce the problem to finding minimum in left subtree. If left subtree is empty we already know the minimum because we cannot have a minimum in right subtree. Here is the recursion that we can write. Root being null is a corner case, if root is null that is if the tree is empty, we can throw error else if left child of root is null we can return the data in root, else if left child is not null or in other words if the left subtree is not empty we can to reduce the problem to searching minimum in the left subtree. So we are making this recursive call to FindMin passing it address of the left child, passing it address of the root left subtree. Left child would be the root of left subtree. This second elseif is our base condition to exit from recursion. If you had understood the recursion that we had written earlier to insert a node in BST, then this recursion should not be very difficult for you to understand. So here is our recursive solution to find minimum in BST. To find maximum element, all we need to do is we need to go searching in right subtree. Okay I'll stop here now. In coming Lessons, we will solve some more interesting problems on BST. Thanks for watching.