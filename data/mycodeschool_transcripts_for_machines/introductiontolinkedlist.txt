In this lesson, we will introduce you to linked list data structure In our previous lesson, we tried to implement a dynamic list using arrays and we had some issues there it was not most efficient in terms of memory usage, in terms of memory consumption When we use arrays, we have some limitations To be able to understand linked list well, we need to understand these limitations so i'm going to tell you a simple story to help you understand this let us say this is computer's memory and each partition here is one byte of memory Now as we know each byte of memory has an address We are showing only a section of the memory, that's why it is extending towards the bottom and the top let's say that address increases from bottom to top so if this bike is address 200, the next byte would be address 201 and next byte would be address 202 and so on what I want to do is i want to draw this memory from left to right horizontally instead of drawing it from bottom to top like this uh... this looks better let's say this byte here is address 200 and as we go towards the right the address increases, so this is like 201 and we go on like 202, 203 and so on it doesn't really matter whether we show memory from bottom to top or left to right these are just logical ways to look at the memory so coming back to our story Memory is a crucial resource and all the applications keep asking for it. So, Mr. computer has given this job of managing the memory to one of his components, to one of his guys who he calls the memory manager now this guy keeps track of what part of the memory is free and what part of the memory is allocated and anyone who needs memory to store something needs to talk to this guy Albert is our programmer and he is building an application he needs to store some data in the memory, so he needs to talk to the memory manager He can talk to the memory manager in a high level language like C, let us say he is using C to talk to the memory manager First he wants to store an integer in the memory so he communicates this to memory manager by declaring an integer variable something like this the memory manager sees this declaration and he's says that ok you need to store an integer variable so i need to give you four bytes of memory because integer variable is stored in four bytes in a typical architecture. and let us say in this architecture, it is stored in four bytes so the memory manager looks for four bites of free space in the memory and assigns it or allocates it for valuable x Address of a block of memory is the address of the first byte in the memory so let us say this first byte of memory here is at address 217, so variable x is at address 217 so memory manager kind of communicates it back to Albert that hey I have assigned address 217 for your variable x you can store whatever you want there. and Albert can fillin any data into this valuable now albert needs to store a list of integers, a list of numbers and and he thinks that the maximum number of integers in this list will be 4. so he asks the memory manager for an integer array of size four names 'A' Now, arrays is always stored in memory as one contiguous block of memory. So memory manager is like ok, i need to look for a block of memory of 16 bytes for this variable this array A. so the memory manager allocates this block starting address two zero one and ending address two one six for this variable 'A' which is an array of four integers. uh... because array is stored as one contiguous block of memory and memory manager conveys the starting address of this block whenever Albert tries to access any of the elements in the array Let's say he tries to access, let's say he tries to write the value at the fourth element in the array. which he accesses as A[3], Albert's application knows where to write this particular value because it knows the base address the starting address of the block 'A' the array 'A' and from base address using the index which is 3 here it calculates the address of A[3] so it knows that A[3] is at address two one three. So, to access any of the elements in the array the application takes constant time and this is one awesome thing about arrays that irrespective of the size of the arrays uh... the application,an application can access any of the elements in an array in constant time now let's say Albert uses this array of 4 integers to store his list so i'll fill in some values here at these positions ,let's say this is 8 this is 2 this is 6, this is 5, this is 4 Now Albert at some point feels that ok, i need to have one more element in this list now he has declared an array of size four and he wants to add a fifith element in the array so he asks the memory manager that hey i want to extend my array 'A' is it possible to do so i want to extend the same block and the memory manager is like when i allocate memory for an array, I do not expect that you will expect an extension, so i use whatever memory available adjacent to that block for other variables in some cases I may extend the same block, but in this case, I have an element a variable 'x' ... next to your block.So, i cannot give you an extension so Albert is like what all options do i have Memory manager is like, you can tell me the new size and I can recreate a new block at some new address and we will have to copy all the elements from the previous block to the new block so Albert says that ok, let's do it but the memory manager is like you still need to give me the size of the new block Albert thinks that this time he will give a really large size for the new array or the new block. so that it does not fill up. this new block starting address 224 is allocated Albert asks memory manager to free the previous block. and this is some cost. He has to copy all the elements, all the numbers from the previous block into the new block and now he can add one more element to this list and he has kept his array large this time just in case he needs more numbers in the list The only option that Albert had was to create 'A' as an entirely new block, as an entirely new array and albert is it still feeling bad because if the list is too small he is not using some part of the array and so memory is getting wasted and if the list again grows too much he will again have to create a new array, a new block and he will again have to copy all the elements from the previous block into the new block Albert is desperately seeking a solution to this problem and the solution to this problem is a data structure named linked list so let us not try to understand linked list data structure and see how it solves Albert's problem what Albert can do is that instead of asking the memory manager for an array which will be one large contiguous block of memory he can ask memory for one unit of data at a time for one element at a time in a separate request I'm cleaning up the memory here once again let's say Albert wants to store this list of four integers in the memory what if he requests memory for one integer at a time. So, first he pings memory manager for some memory to store number six memory manager will be like ok you need space to store an integer so you get this block of four bytes at address 204 so Albert can store number six here now Albert makes another reques,t a separate request for number five let's say he gets this blocks starting address two one seven for number five because he makes a separate request, he may or may not get memory adjacent to number 6. higher probability is that he will not get an adjacent memory location so similarly Albert makes uh... separate requests for number four and two so let's say he gets these two blocks at address 232 and 242 respectively for numbers four and two so as you can see when Albert makes separate request for each integer instead of getting one contiguous block of memory, he gets these disjoint noncontiguous blocks of memory so we need to store some more information here we need to store the information that this is the first element in the list and this is the second element in the list so we need to link these blocks together somehow we an array, it was very simple we had one contiguous block of memory, so so we knew where a particular element is by calculating its address using the starting address of the blocks and the position of the element in the array but here, we need to store the information that this is the first block which stores the first element and this is the second block which stores the second element and so on to link these blocks together and to store the information that this is the first block in the list and this is the second block in the list what we can do is that we can store some extra information with each block so what if we can have two parts in each block something like this and in one part of the block, we store the data or the value and in the other part of the block we store the address of the next block. in this example in the first block the address part would be 217, the address of the next block that stores 5 and in this next block or the second block address part would be 232 In the block at address 232 We will store the address 242 the address of the next block that stores number two and the block at 242 is the last block. there is no next block after this so in the address part we can have address as zero, zero is invalid address zero can be used to mark that this is the end of the list there is no link to the next uh... node or next block after this particular block so Albert now actually has to request memory manager for a block of money that will store two variables one an integer variable that will store the value of our element and one a pointer variable that will store the address of the next block the next node in the list in c he can define a type named Node like this he will have two fields in the node, one to store the data this field will be an ineteger and one more field to store the address of the next node on the list so Albert will ask a Node Albert will ask memory for a node from the memory manager and the memory manager will be like, Ok you need a node that needs 4 bytes for an integer variable and four more bytes for the pointer variable that will store the address Pointer variable also in a typical architecture is stored in four bytes so now memory manager gives us a block of 8 bytes. and we call this block a Node Notice that the second field in the node structure is Node star which means pointer to node so this field will only store an address of the next node in the list so if we store the list like this in the memory as these noncontiguous nodes connected to each other but then this is a linked list data structure Logical view of the linked list data structure will be something like this data is stored in these nodes and each node stores the data as well as the link to the next node so each node kind of points to the next node the first node is also called the head node and the only information about the list that we keep all the time is address of the head node or address of the first node so address of the head node kind of gives us access to the complete list the address in the last node is NULL or zero which means that the last node does not point to any other node. now if we want to traverse the linked list the only way to do it is we start at the head we go to the first guy and then we ask the first guy the address the next guy adress of the next node and then we go to the next node and ask the address of the next node and this is the only way to access the elements in the linked list if we want to insert a node in the linked list let's say we want to add number three at the end of the linked list then all we need to do is first create a node in the linked list sorry first ... create a node independently and separately it will get some memory location so we created this node with value 3. Now all we need to do is fill the address properly, adjust these links properly so the address of this particular node will be filled in this node with value 2. And this node the address part can be NULL, so it is the last node, it does not point to any other node let's also show this uh... these nodes in the memory here so i have written the address of each node in brown at top of these notes and i have also filled in this address field of each node let's say uh... the Node for value three gets address 252 so this is how things will be in the memory and this is how the logical view will be the linked list uh... is always identified by the address of the first node and unlike arrays we cannot access any of the elements in constant time in the case of arrays using the starting address of the block of memory and using the position of the element in the list, we could calculate the address of the element but in this case we have to start at the head and we have to ask this element for the next element and then ask the next element who is your next, it's like playing treasure hunt. You go to the first guy and then you get the address for the second and then you go to the second guy and you get address of the third guy. so the time taken to access elements will be proportional to the size of the list let's say the size of the list is n, there are n elements in the list in the worst case to traverse the last element we will go through all the elements, so time taken to access elements is proportional to n or in other words we say that this operation will cost us or rather the time complexity of this operation is bigoh of n insertion into the list we can insert anywhere in the list, we first need to create a node and just adjust these links properly, like say i want 10 at 3rd position in the list so all we need to do is create a Node, store the value 10 in the data part something like this Let's say we get the node at address 310 So, we will adjust the address field in the second node to point to this node at address 310,and this node will point to the node with value 4. Now to insert also, we will have to traverse the list and got to that particular position and so this will be O(n) again in terms of of time complexity the only thing is that uh... the insertion will be a simple operation, we will not have to do all the shifts as we had to do in an array. To insert something in between, we had to shift all the elements by one position towards higher indices similarly to delete something from this list will also O(n) so we can see some good things about linked list that is no extra use of memory in the sense that some memory is unused We are using some extra memory, we are using some extra money to store the addresses but we have the benefit that we create nodes as and when we want and we can also free the nodes as and when we want we do not have to guess the size of the list beforehand like in the case of arrays We will discuss all the operations on linked list and the cost of these operations as well as comparison with array in our next lessons. We will also be implementing linked list in C or C++ so this is all for a basic introduction to linked list Thanks for watching !