In our previous lesson, we saw how we can implement a stack, these are two popular implementations of stack one using arrays and another using linked list. A warrior should not just possess a weapon he must also know when and how to use it. As programmers we must know in what all scenarios we can use a particular data structure. In this lesson, I'm going to talk about one simple use case of stack. A stack can be used to reverse a list or collection, or simply to traverse a list or collection in reverse order. I'm going to talk about two problems. Reversal of string and reversal of linked list and I'm going to solve both these problems using stack. Let's first discuss reversal of string, I have a string in the form of a character array here, I have this string "HELLO". A string is a sequence of characters. This is a Cstyle string. In C a string must be terminated with a null character, so this last character is a null character. Reversal means characters in the array should be rearranged like what i'm showing here in the right. null character is used only to mark the end of string, it is not part of string. Okay there are couple of efficient ways in which we can reverse a string. Let's first discuss how we can solve this problem using a stack and then we will see how efficient it is. What we can do is we can create a stack of characters, I'm showing logical representation of a stack here this is a stack of characters and right now it's empty and now what we can do is we can traverse the characters in the string from left to right and start pushing them onto the stack. So first 'H' goes into the stack then the next character this 'E' then 'L' then we have another 'L' and then the last character is 'O'. Once all all the characters in the string have gone into the stack we can once again start at the 0th index. Now we need to write the topmost character in the stack, at this index we can get the top most character by calling top operation and now we can perform a pop and now we can go to the next index fill in whatever is at top of stack and perform a pop again. We can go on doing this until stack is not empty, so all the positions in the character array will be overwritten. So finally we have reversed a string here. In a stack whatever goes in last comes out first. So if we will push a bunch of items onto a stack and once all items have pushed if we will start popping we will get the items in reverse order. First item pushed onto the stack will come out last. Let's quickly right code for this logic. I'm going to write C++ here. Things will be pretty similar in other languages, so it doesn't really matter. what I'm going to do in my code is am going to create a character array to store a string and then I will ask user to input a string, once I input the string I would make a call to a function named Reverse passing it the array and length of string that I will get by making a call to string length function(strlen in C) and finally I'm printing the reversed string. Now I need to write the reverse function. In reverse function I want to use a stack, a stack of characters, we have already seen how we can implement stack. In C++, we can create a class named stack that would have an array of characters and an integer variable named top to mark the top of stack in array and these variables can be private and we can work up on the stack using these public functions. In Reverse() function we can simply create an object of stack and use it. This class can be an array based implementation of stack or linked list based implementation of stack it doesn't really matter, in C++ and many other languages language libraries also give us implementation of stack in this program I'm not going to write my own stack I'm going to use stack from what we call standard template library in C++. I will have to use this includes statement #include and now I have a stack class available to me to create an object of this class I need to write stack and within angular brackets datatype for which we want a stack, then after space name or identifier with this one statement here I have created a stack of characters. Let's now write the core logic this n in the signature of reverse function is number of characters in string this array as we know array in C or C++ is always passed by deference through a pointer, this C followed by brackets is only an alternate syntax for *C. It's interpreted like this by the compiler. Okay so now what I'm going to do is I'm going to run a loop starting 0 till n1. So I will traverse the string from left to right and as I traverse the string I will push the character onto stack by calling push function I will use a statement like this once push is done and do another loop for pop. I will run a loop with this variable i starting at 0 and going till n1 and I will first set C[i] as top of stack and then I will perform a pop operation. If you want to know more about functions available with stack in STL like their signatures and how to use them, you can check the description of this video for some resources. This is all I need to do in my reverse() function. Let's run discord and see what happens. I need to enter a string. Lets enter "HELLO". this is what I get as output which seems to be correct let's run this again and this time I want to enter mycodeschool this looks alright to so we seem to be good so this function is solving my problem of reversal. Let's now see how efficient it is let's analyze its time complexity we know that all operations on stack take constant time so all these statements within loop, inside loop, will take constant time. The first loop is running n times and then the second look is also running n times, first look will execute in O(n) and the second loop will also execute in O(n). The loops are not nested they are one after another so in such scenario complexity of the whole function will also be O(n). Time complexity is O(n) but we are using some extra memory here for stack. we are pushing all the characters in the string on to stack, the extra space taken in stack will be proportional to number of characters in the string, will be proportional to n. So we can say that space complexity of this function is also O(n), in simple words extra space taken is directly proportional to n. There are efficient ways to reverse a string without using extra space. The most efficient way probably would be to use just two variables to mark the start and end index in the string initially, let's say I am using variables i and j, initially i for this example is 0 and j is 4. While i is less than j we can swipe the characters at these positions. And once we have swapped, we can increment i and decrement j , if i is less than j , we can swap again and once again increment i and decrement j. Now I is not less than j,i is equal to j. At this stage we can stop swapping and we're done. This algorithm has space complexity O(n), we are using constant extra memory here. Time complexity of this approach once again is O(n). We will do n/2 swaps, so time taken will be proportional to n. Definitely because of space complexity this approach is better than our stack approach sometimes when we know that our input will be very small and time and space is not much of concern, we use a particular algorithm for ease of implementation. for it's being intuitive, it's clearly not the case when we're using stack to reverse a string but for this other problem, reversal of linked list that we have said we will discuss using a stack gives us are neat and intuitive solution. I have drawn a linked list of integers here. As we knew linked list are collections of entities as we call nodes. Each node contains two fields, one to store data and other to store address of next node. I have assumed that these nodes in this example here are at address is 100, 150, 250 and 300 respectively. Identity of a linked list is address of the head node. we typically stored this address in a variable named head. In an array, it takes constant time to access any element so whether it's the first element or last element it takes constant time to access it, it is so because array is stored as one contiguous block of memory so if we know the starting address of the array, let's say the starting address of this RS 400 and size of each element in the array, character takes one bite so for this example each element is one byte then we can calculate address of any element. So we know that 84 is at 400+4 or 404 but in a linked list nodes are stored at disjoint locations in memory, to access any nor do we have to start at the head node, so we can do something as simple as having 2 pointers at start and end and accessing the elements. We have already seen in this series, two possible approaches that can be used to reverse a linked list. one was an iterative solution where we go on reversing links as we traverse the list using some temporary variables, another solution was using recursion. The time complexity of iterative solution is O(n). Space complexity is O(n). In recursive solution we do not create a stack explicitly but recursive uses the stack in computer's memory that is used to execute function calls in such a case we say that we are using implicit stack. stack is not being created explicitly but still we are using an implicit stack. I will come back to this and explain in detail. The time complexity of recursive solution once again is O(n). but the space complexity is O(n) this time. Space complexity is also O(n). Now let's see how the can use an explicit stack to solve this problem. Once again I have drawn logical representation of stack here, right now the stack is empty. In a program this will be a stack of type pointer to Node. What I'm going to do now is I'm going to traverse this linked list using a temporary pointer to Node. The temporary variable will initially point to head. When we will go to a particular node we will push the address of that node onto the stack. so first 100 will go to stack and now we will move to the next Node, now 150 will go in stack and now we will go to 250 and then to the last node at 300. They are showing addresses here in the stack but basically the objects that we are pushing are pointers to Node or in other words references to nodes. if Node is defined like this in C++ we will have to use these statements to traverse linked list and push all the references. Let's say head is a pointer to Node which I'm assuming is a global variable that will store the address of head node. I'm using a temporary variable that is pointed to Node, initially am starting the address of head node in this temporary variable and then I'm running a loop and I'm traversing the linked list and as I'm traversing I'm pushing the reference on to stack once all the references are pushed onto stack, we can start popping them and as we will pop them, we will get references to Nodes in reverse order, it would be like going through the list in reverse order. While traversing the list in reverse order we can build the reverse links. The first thing that'll do is i'll take a temporary variable that will be pointer to Node and store the address of address at the top of stack which right now is 300 now I will set head as this address, so head now becomes 300 and then I will pop. I'm running you through this example here as I'm writing code, head and temp right now are both 300 and now I would run a loop like this, like what I have written here. while stack is not empty this function empty() returns true if stack is empty. I'm using stack from standard template library in C++, so while stack is not empty I'm going to say that set temp>next as address at top of stack. Basically I'm using this pointer to Node temp to dereference and set this particular address field right now top is 250 so I'm building this reverse link next statement is a pop() and in the next statement am saying temp = temp>next which means temp will now point to this node at 250 stack is not empty so loop will execute again. we are writing address here now then we should pop and then move to 150 using this statement temp = temp>next. now we are building this link popping and then oops this should have been 150 and with the next temp =temp>next we're going here, even though we have built this link by setting this field here this node is still pointing to this guy because the stack is empty now we will exit the loop,after the loop, after exit from the loop, I have written one more line temp>next = NULL. so I'm setting the last, link part of last node in reversed list as NULL finally this is my reverse function I have assumed that head is a global variable and it's a pointer to Node if you want a complete source code you can check the description of this video for a link. Using the stack in this case is making a life easier reversing a linked list is still a complex problem, try to just print the elements of linked list in reverse order. if you will use our stack it will be really easy. I will stop here for this lesson, if you know, if you want to know what I meant by implicit stack you can once again checked the description of this video for some resources so this is it for this lesson thanks for watching.