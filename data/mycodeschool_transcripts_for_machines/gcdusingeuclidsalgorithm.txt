hi everybody in this video we'll look at a short but very beautiful algorithm known as uids algorithm the algorithm is named after Greek mathematician euklid we're not sure who invented it but it was first documented by uid back in 300 BC in his book called elements so this algorithm is more than 2,000 years old and the reason we still use it is because it is the fastest way to compute the gcd of two numbers gcd or a greatest common divisor is the same concept that you probably learned about in school let's define it in a slightly more formal way given two numbers A and B we'll say that the gcd of A and B is the greatest number let's call it g that divides both A and B so if we had a a as 105 and B as say 350 and we did not know about ID's algorithm how could we compute their GC since GC deals with the common devisers of both A and B one efficient way of doing it would be to First compute all the factors of a 105 and after that we could then see which of these factors also divide divide 350 perfectly at this point we have the common divisors of both 105 and 350 and we can just choose the highest number from the set of common devisers to find the gcd to find out all the factors of 105 we simply need to divide 105 by all numbers up to its own square root this is because the factors of any number occur in pairs where the product of the pair is equal to the number itself and the lower half of the pair is less than or equal to the square root of the number and the higher half of the pair is greater than or equal to the square root of the number to find out more about this concept you can check out our video finding all factors of a number so in the case of 105 its square root is roughly 10 so we will need to perform 10 divisions we'll divide 105 against all numbers from 1 to 10 in order to find out all its devisers if you perform these divisions manually you will end up with a table like this we can see here that 105 has exactly eight divisors and these eight divisors are found in pairs where each pair together has a product of 105 we'll now divide 350 by all eight of these devisers this means we'll need to perform another eight divisions after after performing this eight divisions we'll see that 350 is divisible by exactly four of the divisors of5 so the set of common divisors of 350 and 105 has four numbers so our gcd is the highest of these numbers which is 35 so as you saw our pretty efficient devisor based algorithm took us only 18 divisions in order to compute the gcd of 350 and 105 now let's see how well ukls algorithm performs for the same example in the first step of uids algorithm we take the larger number 350 and we divide it by the smaller number 105 and compute the remainder we get a remainder of 35 for our next step the devisor from our first step 105 becomes the dividend and our remainder from the previous step 35 becomes the divisor Computing the remainder again we get zero for our third step we again follow a similar procedure this time 35 becomes the dividend while the divisor is zero now that our divisor is zero ukids algorithm comes to an end and the gcd is simply the last dividend so our answer to the gcd of 105 and 350 is 35 so as you just saw using ukls algorithm we needed only two divisions to compute the gcd of 350 and 105 compare this with our pretty efficient divisor based algorithm which took 18 division even for the small case you can see how much faster uid algorithm is it was nine times faster in this case now that we have an idea of how ukets algorithm Works let's wipe this out and look at the code for ukets algorithm so we call our function ukl gcd since it computes gcd using ukls algorithm and it takes two integers as input A and B and these are the integers whose gcd will be computed before we perform the first remainder operation we need to set up the dividend as well as the divisor the dividend is the greater value of a and b and we accomplish this using the tary operator so if a is greater than b we choose a otherwise we choose B similarly we use the tary operator to also set up the devisor as long as the devisor is not zero we can compute our remainders and we use the modu operator to do that We Now set up the dividend and divisor for the next division operation so the dividend for the next operation is the divisor of the current operation and the divisor for the next operation is the remainder from the current operation when this Loop exits we know that the devisor is zero and our algorithm is complete and the answer which is the gcd of A and B lies in the last dividend so we can simply return the dividend value that we have that was a quick walkr of the code now let's track the values of the three variables dividend divisor and remainder for an example case to get a better understanding of how the algorithm works so let's take the example where a is 400 and B is uh 124 of course we first execute this instruction which computes the dividend as the greater value of a and b so dividend gets set as 400 and we then compute div divisor as the Lesser value of a and b which is 124 since the divisor is not equal to zero we enter the loop where we compute the remainder for the first time in this case it is 400 modul 124 which is 28 at this point the value of dividend gets reassigned to the current divisor so dividend becomes the current divisor which is 124 and the value of divisor gets reassigned to the current remainder so divisor becomes 28 now we go back to this Loop condition since the divisor is not zero we again enter the loop and this time we compute the remainder of 124 and 28 which is 12 again we reassign dividend and divisor and this goes on until finally the deviser gets assigned a value of zero at this this point this while loop condition check fails and we come out of the loop and we simply return the current value of dividend which is four and this is the gcd of 4124 so in this example case ukets algorithm performed only four divisions to compute the gcd whereas our devisor based algorithm would have taken 17 divisions to compute the same gcd so as you can see this ancient algorithm is quite f however it's not very useful to analyze the time taken for individual cases what is really useful is if we could compute the order of the time taken for the worst case by ID's algorithm this is also known as the worst case time complexity and is represented using the Big O notation if you want to know more about the bigo notation and time complexity analysis in general you can check out our previous video series on time complexity analysis now let's wipe this out and compute the time complexity of ukl algorithm remember that time complexity of any algorithm is always expressed as a function of its input so the time complexity of ukets algorithm must be a function of these two variables A and B if you look at our code above you will see that we have three kinds of operations assignment operations comparison operations and the modulo or division operation if we talk about infinitely large numbers then these operations would take time proportional to the number of digits in the number so for example dividing to three digit numbers would be quite fast but dividing to 300 digit numbers would probably take 100 times that amount of time in this code though we are not talking about infinitely large numbers we are talking about int data type you can see that all the variables in this code have data type of int on a modern machine in typically compiled to 32bit numbers for 32bit numbers on a modern machine there are microprocessor instructions that handle comparison assignment as well as division in constant amount of time this means that all the individual instructions let's assume that a is greater than or equal to B so B becomes our smaller number by using the result proven in the 1840s we can rewrite bigo X as bigo number of digits of B given a number B to compute its number of digits in the decimal representation we can simply take the logarithm of B to the base 10 so we can rewrite big old digits of b as bigo log B to the base 10 since since we're using bigo notation the base of the logarithm is not very important since we can convert logarithms of different bases by multiplying with a constant so we can rewrite this as simply bigo log B so there you have it we have derived the time complexity of ukids algorithm which is bigo log B where B is the smaller number of the two numbers whose gcd is being derived to to understand how fast log B is let's remember the previous algorithm that we used which consisted of computing the devisers first the time complexity of that algorithm is square root of P I won't go into how to derive that you can check out our video finding all factors of a number to see that but if we were to compare square root of P versus log b in a table so let's say B is 1,000 then square root of B is roughly 30 whereas log B even to base 2 is roughly 10 so for values around 1,000 the logarithmic value is 3 times less than the square root value however if we increase B to 1 million square root of B goes up to 1,000 whereas log B to base 2 just doubles to roughly 20 so now the logarithmic value is 50 times lower than the square root value as we increase the value of B this difference just gets more exaggerated that's it for the time complexity analysis of ukets algorithm let's take a quick look at shortening the code of ukets algorithm without affecting its time complexity the first method is to remove the assignment of Maximum value to Dividend and minimum value to divisor in its place we can simply set dividend to a and divisor to B so what what happens if a is less than b let's go back to our old example and instead of a being 400 this time let's make b as 400 and a as 124 so initially the dividend is 124 and the divisor is 400 we enter the loop and since the dividend is less than divisor the remainder is nothing but the dividend itself so remainder is 124 now when divider and diviser get reassigned the divis dividend becomes 400 and the divisor becomes 124 so our algorithm is back to the same state as if we had assigned dividend to the max value of a and b and divisor to the Min value of a and b it is just that the loop takes one extra turn after this the algorithm proceeds as usual to calculate the gcd of 4 we can shorten the code some more by replacing the dividend variable with a itself and replacing the devisor variable with B itself then the code would look like this we can also reduce the code to a single line which is my favorite way if we're ready to use recursion however this way also adds some space complexity of bigo log B and this is what the code looks like that's it for this video I hope you enjoyed learning about the implementation and time complexity of uket algorithm thanks for watching