In our lesson so far we have seen how we can work with pointers in some of the basic scenarios but there are some scenarios where pointers can be really puzzling & one such scenario is when we want to use pointers to pointers. In this lesson we are going to see how we can use a pointer to pointer Let us assume that this is a logical view of computer's memory & each partition here is one byte of memory now we know that each byte of memory has an address, we have drawn the memory horizontally here, let us assume that the address increases as we go from left to right. So if this byte is at address 200, the next byte would be at address 201 & the next byte would be at address 202 & so on Now lets say in my programme I have declared an integer variable named X & maybe I have initialized it as 5. now when the programme will run, some amount of memory will be allocated for this variable x. in a typical architecture in a typical compiler, integer is stored in 4 bytes, so 4 byte will be allocated for x. so, Lets say these 4 bytes at address 225, this block of 4 bytes, starting address 225 is allocated for x & the values stored in this block of 4 bytes for x is 5. now the next thing that I want to do is I want to declare a pointer variable that will store the address of x. now to store the address of an integer we will have to declare a pointer to integer something like this we need to put an * sign in front of the variable name. now what will happen is that some amount of memory will be reserved for this variable p in a typical architecture. Pointer is also stored in 4 bytes so let's say we get this block of 4 bytes at address 215 for p & now I want to write a statement like this so I want to fill in the address of x in p & that's how p points to x & operator gives us the address of a variable now one important thing here, we are able to store the address of x in p because p is of type pointer to integer. If p was of type pointer to character or pointer to some other some other variable, this statement p=&x would not have been valid. so if I have to write down the types of these two variables, then x is an integer & p is pointer to integer or I can also say that p is int star or int asterisk & why pointer variables are strongly typed why do we need a pointer to integer to reference or store the address of an integer it is because we don't just store the address of a variable in a pointer variable we also use the pointer variable to dereference the address & write some value there. So if I write a statement like this, this value here at address 225 , this x is now modified. now can I create a pointer to this variable p, which itself is a pointer to integer Well yes we actually we can do so so let's say we want to create a variable named q, that will store the address of p now what will be the type of this variable we need a pointer of a particular type to store the address of a particular type of variable, so to store a pointer to integer, we will have to say that we want a pointer to pointer. so we will put two ** sign in front of a variable name & now this variable q can store the address of p so with this first line with this int **q we created q. lets say we created q at 205 & now we are saying that q will store the address of p so q points to p & the type of q is int **. We put two *. Simple way to read this is that the type of variable x is integer so to store the address of x we will need a pointer of type int * so we will put a star to say that this is a pointer to that particular type & to store the address of p we will need a pointer to int * so we will put one extra * to say that this is a pointer to int star & we can go on like this lets say we want to declare a pointer to pointer to pointer so int ** is pointer to pointer & we will put one more * we can put these three * immediately after this key word int or we can put it immediately before the variable name like we have done in the case of q here let's say we define r as int *** so lets say r gets this address 230 in the memory now r is of type int *** so it can store the address of int ** so it cannot store the address of x or p the statement something like r =&q will be valid now I have translated my previous rough code into a working c programme. Let us assume that this programme is working as per this memory sketch that we r showing in the right now I will write some print statements and you need to guess the out puts. So basically you have to assume that these variables x p q & r are allocated these addresses what we r showing here in the right so the first print statement that I am going to write is I want to print *p & this one should be simple for you *p would be value stored at address in p so this will be 6 now the next statement that I want to print is *q so *q will be a value at address stored in q address stored in variable q is 215 so this is nothing but the value of p so this will be 225 & now I want to print **q so I want to do de referencing twice first I want to go to *q, *q is this address 225 & now I want to look at the value at address 225 so this one will be 6 we could have avoided writing this parentheses here, we could have said **q only & that would have also that would have meant the same but it's a good practice if we are using this asterisk operator to use parentheses wherever we can do it because some times when we r also using other operators we are not sure about the precedence & we want to avoid unwanted behaviors now what about these two print statements **r & ***r, *r means value in q which will be 215 & then further one more dereferencing will take us to value in p which is 225 & one more dereferencing will take us to value in x which will be 6 if u see this is really interesting from r we r using one * operator & we are able to go to q then we are using the *operator twice & we reach p & then we r using the * operator thrice & we reach x. Lets make some more changes in this code & run this in a real compiler so what I'll do here is I'll write a statement like this & then after this statement I'll print the value in x. If u run this now as you can see *p, **q & ***r all these 3 values are 6 the address will not be same as we had shown in the example for obvious reasons & as u can see we are able to modify x by doing this chain of de referencing using this variable r. if we would write something like **q = let's say something like this. Now *p is also referencing x & **q is also dereferencing x sorry we are dereferencing here so any guesses what will be the output of this last print statement Well if u see, x is incremented by 2 here so this was pointer to pointer I recommend that you write some of this code yourself & play a little bit. In the coming lessons we will use pointer to pointer in some real problem scenarios. So thanks for watching