In this lesson, we're going to solve another interesting problem on binary search tree and the problem is, given a node in a binary search tree we need to find its inorder successor i.e. the node that would come immediately after the given node in inorder traversal of the binary search tree. As we know, in inorder traversal of a binary tree we first visit the left subtree then that root and then the right subtree. Left and right subtrees are visited recursively in same manner. So for each node, we first visit its left subtree then the node itself and then its right subtree. We have already thiscussed inorder traversal in detail in a previous lesson in the series. You can check the description of the video of a link to it. Inorder implementation will basically be a recursive function something like what I'am showing in right here. There are two recursive calls in this function. One to visit the left subtree had another to visit the right subtree. Time complexity of inorder traversal is O(N) where n is number of nodes in the tree. We visit each not exactly once. So time taken is proportional to a number of nodes in the tree. I have drawn a binary search tree of integers here. Binary search tree, as we know is a binary tree in which for each node value of nodes and left his lesser and value of nodes in right is greater. Let's quickly see what will be the inorder traversal for this binary search tree. We will start at root of the tree. Now for any node, we first need to visit all nodes in its left and then only we can visit that node so we'll have to go left. Basically, we will make a recursive calls to go to left child of this node. For this guy once again we have something left, so we will make another recursive call and go to its left child. Now we are at this node with value 8 and they will have to go left one more time and now for this node with value 6 which is a leaf node we have nothing left. So they can simply say that it's left subtree is done and hence we can visit the guy. Visiting for me is reading the data in that node. I'll write to data here and now for this node, there is nothing in right as well so we can simply say that it's right is also done and now we're completely done for this guy. So recursive call corresponding to this node will finish and we will go back to call corresponding to its parent. If we will come back to a node from its left child then it would be unvisited because we can't visit a node until its left is done. So when you coming back to 8, 8 is unvisited so we can simply visit this node that is read the data in this node. When I'll visit a node, I'll paint it in yellow and now there's nothing in right of this node so we can simply say that right is done. Now we are done with this nodes, so call corresponding to this node will finish and we will go back to its parent. Once again we're coming back to the parent from the left, so the parent that is this node with value 10 is unvisited. If we would come back to a node from right then it would already be visited, so I'm visiting 10 and now we can go to right of 10. So far we have visited 3 nodes. We first visited node with value 6 and then be visited node to value 8, so 8 is successor of 6 and then 10 is successor of 8. Now let's see what will be the successor of 10. For nodes with values 6 and 8 there was nothing in right, so we were unwinding and going to the parent but for a node if there would be something in right that is if there would be a right subtree and then its successor would definitely be in its right subtree because after visiting that node we will go right. Now at the stage, we are at this node with value 12. For this guy we will first go left and now we are at node with value 11 which is a leaf node. There's nothing left so we can simply say that left is done and we can print the data that is visit this node so inorder successor of 10 is 11. Now for node with value 11, there is nothing in right. So we will go back to this parent and now we can visit this guy. So after 11, we have 12. There's nothing in right of 12 so called for this guy will finish and we will go to its parent. Now we're coming back to 10 again but this time from right so this guy is already visited. So we need not do anything. We can simply go to its parent and now we are at this node with value 15. We are coming from left. This guy is unvisited so we can visit it and now we can go to its right. We will go on like this.Successor of 15 would be 16 and after 16 we will print 17 and then after 17 we will print 20 then 25 and the last element would be 27. So this is an inorder traversal of this binary search tree. Noticed that we have printed the integers in sorted order. When we perform inorder traversal on a binary search tree then elements are visited in sorted order. Now the problem is that we want to solve this given a value in the tree, we want to find its inorder successor. In a binary search tree, it would be the next higher value in the tree but what's the big deal here. Can't we just perform inorder traversal and while performing the traversal figure out the successor. Well we can do so but it will be expensive. Running time of inorder is O(N) and we may want to do better. Finding next and previous element in some data could be a frequently performed operation and good thing about binary search tree is that frequently performed operations like insertion and deletion and search happen in O(H) where H is height of the tree. So it would be good if we are able to find a successor and predecessor in O(H). We always try to keep a tree balanced to minimize its height. Height of up balanced binary tree is log N to base 2 and O(log N) running time for any operation is almost the best running time that we can have. So can we find inorder successor in O(H). I have redrawn example tree here. Let's see what we can to do in various cases. What node would we visit after this node with value 10. Can we deduced this logically. Well, if you remember the simulation of inorder traversal that we had done earlier and then if we have already visited this node then we are done with its left subtree and we have read the data in this node and we need to go right. Now in the right subtree, we will have to go left as long as it's possible to go and if we can't go left anymore like here, there's nothing left of this node with value 11 then this is the node that I am visiting next. So for a node if there is rightsubtree then inorder successor would be to left most node in its right subtree. In a BST it would be the node with minimum value in its right subtree. I would say this is case one. In this case, all we need to do is we need to go as left as possible in right subtree. In a BST it will also mean finding the minimum in right subtree left most node will also be the minimum in the subtree. Now this is one case our node here has right subtree. What would be the successor if there would be no right subtree. What node would we visit after this node with value 8. This guy does not have right subtree. If we have already visited this guy, then we have already visited its left and this node itself and there is nothing in right, so we can see that right is also visited but we have not found a successor yet. Now where do we go from here. Well, if you remember the simulation that we had done earlier. We need to go to the parent of this node and if we are going to the parent from left which is the case here then the parent would be unvisited. For this node with value 10, we just finished its left subtree and we're coming back. So now we can visit to node. So this is my successor. Let's now pick another node with no right subtree. What would be inorder successor of this node that value 12. What node would be visit next. Now here, once again we donot have a right subtree for this node so we must go back to its parent and see if it's unvisited. But if we're going to the parent from right, if the node that we just visited is the right child which is the case here, then the parent would already be visited because we are coming back after visiting its right subtree. This node must have been visited before going right. So what should we do. Now the recursion will rollback further and we need to go to parent of 10 and now we're going to 15 from left. So this guy is unvisited. So we can visit this node and this is my successor. If the node does not have the right subtree, we need to go to the nearest ancestor for which given node would be in its left subtree. Here for 12 the first went to 10 but 12 is in right subtree of 10 so we went the next ancestor 15 and 12 is in left of 15, so this is the nearest ancestor for a which 12 is in left and hence this is my inorder successor. This algorithm works fine but there is an issue. how do we go from a node to its parent. Well, we can design a tree such that node can have reference to its parent. So far in most lessons, we have defined node as a structure with 3 fields something like this. This is how we would define node in C or C++. We have one field to store data and we have two pointers to node to store reference or addresses of left and right children. Often it makes a lot of sense to have one more feed to store the address of parent. We can design a tree like this and then they will not have problem walking the tree up using parent link. We can easily go to the ancestors but what if there is no link to parent. In this case what we can do is we can start at root and walk the tree from root to the given node. In a BST this is really easy. For 12 we will start at root. 12 is lesser than value in root so we need to go left and now we are 10. Now 12 is greater than 10, so we need to go right and now we are 12. If we will walk the tree from root to the given node. We will go through all the ancestors of two given node. Inorder successor would be the deepest node or deepest ancestors in this path for which given node would be in left subtree. 12 has only two ancestors. We have 10 but 12 is in right of 10 and then the 15 and 12 is in left of 15 so 15 as my successor. Now let's use this technique to find successor of 6. We will first walk down from root to this node. 6 is in left for all the ancestors but the deepest ancestor for which 6 in left is this node with value 8. So this is my successor. Remember we need to look at ancestors only if the is no right subtree. For 6 that is no right subtree. Okay so algorithm looks good. Let's now write code for this. In my C++ code here, I am going to write a function named Getsuccessor that will take address of root node and address of another node for which we need to find a successor and this function will return address of the successor node. We could design this function differently. Instead of taking pointer to the node for which we want to find a successor as argument, we could just take that data as argument and for this data for this element we can find a successor node and return its address and that's why the return type here is struct node* because we will be returning address in a pointer or what we can also do is, we can return the element itself the successor element itself. We can implement with to any of these signatures. Let's implement this one. We will pass the data in current node and we will return back to address of the successor. Now the first thing that we need to do is, we need to search the node with this data. I'm going to make call to a function named Find that will take address of the root node and the data and return me pointer to the node with this data. If this function returns me null that is if the data not found in the tree. We can simply return null else we have address of the current node in this pointer to node that we have named current. Now in a BST this search operation will cost us O(H) where H is height of the tree. Search in a BST is not very expensive. We could have avoided this search if we would have passed address of the current node instead of passing the data as to second argument but let's go with this. Let's now find the successor of this node. If this node has right subtree that is if right subtree is not null, we need to go to the left most node in the right subtree. I have declared a temporary pointer to node here and initially, I have set it to current>right and with this while loop I'll you go to the leftmost node. While there is something in the left keep going and finally when I'll come out of this loop, I'll have address of left most node in the right subtree and I can return this address. This particular node will also be the node with minimum value in right subtree. I'll move this code in another function. I have written this function name FindMin that will return node with minimum value in a tree or subtree. In Getsuccessor function, I'll simply say return FindMin and I'll pass the address of right child of current node. So basically, I'm passing the right subtree here. Okay now let's talk about case 2. If they're is no right subtree, what we need to do is we need to walked the tree from root till current node and we need to find the deepest ancestor for which current node will be in its left subtree. What I'm going to do here is, I'm going to declare a pointer to node named successor and initially I'll set it as null and I'll have another pointer to node named ancestor and initially as set this as root, and with this while loop we will walked a tree till we have not reached the current node. To walk the tree, we will use the property of binary search tree that for each node value of nodes in left is lesser and value of nodes right is greater. If data in current node is less than the data in ancestor then first of all this ancestor may be my inorder successor because the current node is in its left. So what we can do is, we can set the guy as successor and we can go left. While traversing if we will find a deeper node with this property that current node will be in its left subtree then successor will be updated else if the current node lies in right, we simply need to move right. When will come out of this while loop, successor will either been null or it will the address of some node. Not all nodes in the tree will have a successor. Node with maximum value will not have a successor. After coming out this while loop, we can return the successor. So this is my get successor function and I think this should work. You can find link to complete source code and description of this video. Overall time complexity of this function will be O(H) and this is what you wanted. We wanted to find successor in O(H). Here we're already performing the search in O(H). Finding minimum will also take O(H) and walking the tree from root to a node in BST will also take O(H). So, overall this is O(H). If you have understood this code this logic it then it should be very easy for you writing function to find inorder predecessor. I encourage you to write it. I'll stop here. Incoming lessons, we will solve some more interesting problems on binary trees and binary search trees. Thanks for watching.