In the previous lesson, we saw the implementation of binary search in its basic form we solved a problem in which if we have a sorted array of integers something like this and if we want to find out whether a number exists in this array or not so lets say we want to find out whether number 10 exists in this array or not, then our algorithm returns us that 10 exists at index 3 and if we want to search for a number that does not exist in the array, then our algorithm returns us that the number that you're looking for does not exist in the array, so if you want to search for 11 in the array, then our algorithm says that 11 does not exist in the array okay so now i will modify this array. Now, this array is still sorted, but the only difference is that we have three occurrences of number ten in the array now let's say we want to search for the number 10 using binary search, then what will be the index of n that we return We could return 2 also index 2 also, we could return index 3 also or we could return index 4 also the normal binary search implementation that we saw previously exits as soon as it finds out any occurrence of a number in the array, so there is no guarantee that we will find the first occurrence or the last occurrence now in this lesson, we will see two different variations of binary search one variation will always give us the first occurrence of a number in the array and another variation will always give us the last occurrence of the number that we are searching for in the array Ok, so let us first write the basic implementation that we had written previously I will quickly write a method binary search that takes three arguments Array A, its size n and the element to be searched for 'x' and we will initialize two variables, low and high to 0 and n1 to mark the segment of the array in which x is probable to lie. and while low is less than or equal to high we calculate the middle index as low plus high upon two and then we compare x with the middle element and if x is equal to the middle element, then we have found x and our search is over We exit from this method by returning the index mid. So, we are exiting as soon as we found as soon as we find any occurrence of x not necessarily the first or the last occurrence. but any occurrence. if x is less than the mid element, we adjust high to mid minus one to say that x will now, x is now probable to lie before the mid element and the third and default condition is when x is greater than the mid element, so in this case, we adjust low to mid plus one and if we come out of this while loop without finding x then we return 1 to say that we could not find x in the array Ok, let us see a simulation of this for this particular example. simulation of this algorithm for this particular example I'll draw three columns here low high and mid and let's say the number to be searched for is ten. So, x is 10 size of the array is six, so initially low is zero sorry, size of the array is 7 So, initially low is 0, high is 6 now we have started to execute this while loop we calculate mid as (low+high) upon 2, so mid would be 3 Let's also draw a column A[mid] okay this looks better now, A[3] is 10. so is x equal to A[mid] yes it is, so we return 3 we return 3 and we will say that game over because we have found 10 in the array and we return immediately we do not care that there is another 10 at index 2 Now, if we want to find out if we wanted to find out the first occurrence of 10 in the array we should not have said "game over" we should have said that ok, I have found one 10 at index 3, let me go and see towards the left if there is another 10 at any lower index and if it is there, I will return that one so i will modify this algorithm slightly here At the beginning, lets say we take a variable result and initialize it to 1 i'll come back to why I'm initializing it to 1 and i'm short of space here, so i am writing two statements in the same line with a comma now when the condition is that x is equal to the middle element instead of returning and exiting the execution of the function, we modify result to x sorry, we modify result to mid, the index at which x lies and we adjust high to (mid 1) once again, I'm short of space here so i am writing two statements in the same line so these two statements will execute for this condition, if x is equal to the middle element. Now what do i really mean here? What i mean is that if we found x in the array then we have stored the index in the variable result at which we found x and then we modify our segment, we do not stop our search and we modify our search space by adjusting high to mid minus one so we keep on searching for x before this mid element so if we see the simulation now then we do not stop here, we make high as 2 and continue our search now mid would be one A[mid] would be 4 I will also write the value of result at any stage. So, far our result is so far we have found 10 at index 3 so our result is 3 now for this case low = 0 ,high = 2 and mid = 1 we will go to the condition, this one when x is greater than the middle element. So, low becomes (mid+1) so low becomes 2, high is already 2 now mid would also be 2 A[mid] would be 10 now we come to this condition We again came to x equal to the middle element of the segment. So, we now modify result to the new index at which we have found 'x'.so result will be now 2 and high becomes (mid 1) which will be 1, low is 2 now this condition low less than or equal to high fails so we exit while loop here okay there should be one more modification to my code, I will return result here okay so we are seeing here that found 10 at index 2 so this way we have have found the first occurrence of element 10 in the array we're returning result here once we complete the while loop and we are not returning the result inside the loop result is initially 1, so if we do not find any 'x' it is never modified and we return 1 to say that we could not find 'x' in the array and if we find any 'x' in the array and i'll put braces here to mark that these two statements execute for this if condition We store that index in this variable kind of saying that so far this is the leftmost result that i have and then we go on searching towards the left by left i mean towards the lower indices so we modify high to mid minus one if we find another x then this x is left of the previous index. So, we discard the previous result and modify our result okay so this is binary search to find out the occurrence of first element in the array if we want to find out the last occurrence in the array, then there will be only a slight modification to this code When we find 'x', we do not stop the search like we're doing here and we go on searching towards the right, towards the higher indices by modifying our window or the segment, or the search space by adjusting low to (mid+1) by adjusting lower index to (mid +1) and this is the only change that we need to do to find out last occurrence in the array Ok, so let us quickly see simulation for this implementation also So once again we start with low =0, high =6 and we also start with result = 1 1 means that we have not found x in the array so far now mid would be 3 and the mid element would be 10 We are executing the while loop here No, we come here to this condition. X is equal to A[mid] so first we modify our result we found a 'x' at index 3 and then we modify low to mid plus one which will be 4 so earlier our window was the whole array now our window or search space is this and we already have information about the rightmost 10 that has occurred so far Ok, so now, mid would be 5 A[mid] would be 18 Now, we go to this condition, x is less than A[mid] So, now high becomes mid minus 1, so we have this range our window, our searchspace is now this and so far we have found one 10 at index 3 now mid would be (5+4)/2 and if we take only integral part, then it is 4 A[mid] would be 10 so once again we come to the condition when x is equal to A[mid], So we modify result to the new index 4 and we modify low to mid plus one. So low becomes 5 high becomes 5 so far the highest index of 10 that we have found is 4 and our search window is now only index five so mid would also be five and A[mid] would be 18 now 18 is greater than 10 So, we will again, once again go to this particular condition So, low is still 5 and high becomes 4 now now this is not a valid search space this is not a valid segment low less than or equal to high condition fails, so we will exit the loop exit the while loop and our game is over, the result, we return whatever we have in the result so we will kind of say that found 10 at index 4. So, this is binary search to find out the last occurrence of an element in the array in a sorted array the time complexity of this algorithm is O(log n) or in other words we can say that the time taken is kind of proportional to log of n in the coming lessons, we will see more variations of binary search we will see other scenarios in which binary search is applied so thanks for watching !