in this lesson we will write a program to find out prime factorization of a number so what is factorization of a number factorization of a number is writing the number in the form of multiples of its factors so for example if we have a number 24 we can write this number 24 as 2 into 12 now 2 and 12 are both factors of 24 so this is one possible factorization iation and we we can have other possible factorizations for 24 as well we could write 24 as 3 into 8 or even in terms of more than one factors like 2 into 3 into 4 now prime factorization as it should be obvious from the name itself would be writing the number as multiples of its prime factors only so for 24 we can have a prime factorization like 2 into 2 into 2 into 3 where it is written only in the form of multiples of its prime factors so this is prime factorization of 24 there is only one possible prime factorization of a number so even though in this case we could rearrange the factors to write it something like this 3 into 2 into 2 into 2 but the factors and the number of times that they will appear would still be the same so two will always appear three times and three will always appear one times in prime factorization of 24 and we often write prime factorization in the form of exponents so we can write this as 2 ^ 3 into 3 ^ 1 so how do we find out prime factorization and we need to go back to our El Elementary School mathematics uh let's pick up another example this time let's say let's say we have the number 36 to find out prime factorization we try to divide a number by smallest possible number other than one so the smallest possible number other than one that can divide 36 would be two so we write down the divisor here along the vertical line and we write the quotient along this horizontal line so if we divide 36 by 2 the quotient is 18 and anytime we pick up the divisor and the quotient multiplying them gives us the actual number so 36 is 2 into 18 now once again what is the smallest number that can divide 18 can we reduce 18 any further yes we can 2 can divide 18 and that would be the quotient would be 9 and once again if we pick up all the divisors and this last number along the horizontal line and then multiplying them all gives us the actual number so now 36 can be written as 2 into 2 into 9 this is one possible factorization but it is still not the prime factorization uh because we can reduce N9 further now two cannot divide 9 but three can divide 9 so the smallest number that can divide 9 is three and that would be the quotient would be three now the smallest number that can divide three would be three again and we get 1 in the quotient so 36 is nothing but 2 into 2 into 3 into 3 into 1 and we stop as soon as soon as we get one because when one cannot be reduced any further now one is not a prime number the smallest prime number is two so in prime factorization we do not keep one so the prime factorization uh would be 36 is 2 into 2 into 3 into 3 and if we write this in the form of exponents then this is 2 to the^ 2 multiplied by 3 to ^ 2 and let us now write code for this so I will write a function prime factorization that will take an integer n as input and print the prime factorization of n in exponents form and to find out prime factorization in exponents form all we need to know is what all are the prime factors and what are their frequencies like how many times they occur like in this example two occurs twice and three occurs twice so our logic would be something like we will run a loop starting two all the way till n and for each I we will keep on dividing n by I as long as we can so we will say that if I divides n or in other words n modul i is zero as long as we can divide n by I so while n modul i is zero we will keep reducing n to n upon I so we are kind of dividing n by I as long as we can now we also need to know the frequency of I in the prime factorization so we also need to count how many times we are able to divide so I will outside this y Loop I'll initialize a variable count and inside the loop I'll increment count so once we come out of this Loop we know that I is a factor and count is its frequency so after coming out of the while loop I'll print something like I raised to the power count and this is one component in the exponential representation of prime factorization let's for the sake of Simplicity say that we just print the pair I and count so we get to know that I occurs count number of times now one obvious question here would be how can we be sure that we will get only prime factors here we are running the loop for all values of I till n so we may also get a nonprime value of the factor well no we will never get a nonprime value because a nonprime number in this algorithm will never pass this particular condition it will never divide n and we can prove this using contradiction let's say 6 divides n now 6 is a non nonprime number it's a composite number it has two factors two prime factors 2 and three now if at any point 6 can divide n 2 and three can also divide n but before I would be 6 we would already have divided n by I equal 2 and I is equal to 3 in this loop as many times as possible so we definitely can't divide n by two anymore or three anymore so this is a contradiction so only prime numbers will be able to divide n in our approach take some time and think through it it should be easy to get now what will be the time complexity here what will be the running time of the algorithm in the worst case when n is prime the fall Loop will run almost n times and the while loop will run only once so clearly the time taken will be proportional to n in the worst case and when we analyze Al algorithms it is always good to analyze it in the worst case scenario so the time complexity is Big O of n in the worst case can we do something better here well let's see let us simulate this algorithm using an example let's say n is equal to 44 and we want to find out prime factorization of 44 so I will draw one more column here I okay so the for Loop starts with i is equal to 2 and we go on to check you using this if condition if 2 divides 44 yes it does so we initialize a variable count so let's create a column for count so count is zero at this stage and in this while loop we keep on dividing n by two as long as possible so I is still 2 N becomes 22 count becomes 1 we can still divide 22 so I is 2 N is 11 count becomes two we cannot divide n by two anymore so we exit and we come to this print statement so we print let's say 2 comma 2 where 2 is the factor and 2 is its frequency let's say this is substitute for printing 2 to the^ 2 now I becomes three can 3 divide 11 no we do not go inside the if statement count is not initialized and I becomes four and we go on like this because 11 is not divided until we reach I equal 11 okay so now 11 divides 11 11 and N becomes 1 count becomes 1 and now 11 cannot divide 1 so we print 11 and 1 the pair for factor and its frequency and after this state we exit the for Loop because I now becomes greater than n now there is one observation that can help us improve our algorithm once n is reduced to a prime number we know that the only Factor possible now is the number itself for example once n is reduced to 11 is in this particular case and we know that 11 is prime then we know that the only Factor left is 11 and we can stop evaluating afterwards now how do we know that n is reduced to a prime number we have talked about this earlier in our previous lessons as well if a number does not have any Factor till square root of n then it is a prime number so once I becomes greater than square root of n like in this particular simulation and once we reach I is equal to 4 we know that I is now greater than square root of N and it is still not dividing n so we have checked till square root of n there is no factor and the number left out is a prime number so we can exit at this particular stage so I will modify the pseudo code here now I'll only run my Loop till square root of N and we get out of this for Loop once I exceeds square root of n because at this stage we know that n is now a prime number now once we come out of this for Loop n is either one or N is a prime number so if n is not equal to one which will be a special case then we know that N is a prime number so we print n which is the prime factor and its frequency would be one so now this 11 comma 1 is printed after we exit the for Loop in our new algorithm okay writing this pairs is substitute for writing something like 2 ^ 2 into 11 ^ 1 you can modify the algorithm to print something like this I leave that as an exercise for you now the time complexity in this particular case here we are running the loop the for Loop in the worst case close to square root of n times and while loop will not matter in the worst case so in the worst case the time taken is proportional to square root of n so this is Big O of square root of n in terms of time complexity so this was prime factorization there are other interesting algorithms to find out prime factorization it is a very famous problem in number Theory I encourage you uh to study all those we will see more of these problems on number theory in the coming lessons so thanks for watching