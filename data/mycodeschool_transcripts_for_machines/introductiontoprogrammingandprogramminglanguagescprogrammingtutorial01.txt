Hello everyone. In this lesson, and in this series of lessons we are going to introduce you to computer programming through 'C'. 'C' is a computer programming language.These lessons are meant for someone with very little are no prior experience in programming. We are going to keep our assumptions really low, we will start with the basics and carry everyone along. Okay so let's get started unlike most other machines that can perform a finite set of predefined tasks a computer is a general purpose machine that can perform any computational task. All you need to do is you need to give it a program which is nothing but a set of instructions to perform a task. A computer is nothing in itself without programs, all the tasks are performed through programs. A modernday computer would have hundreds and thousands of programs in it. There are programs that manage the hardware resources of the computer we call such programs system programs. And then there are programs that perform your favorite tasks, we call them application programs like a web browser that you use to browse the internet or a text editor that you use to create a document. And if any of these programs cannot perform the task that you want to perform you can write your own program and that's what we're going to learn in this series of lessons, writing and executing your own program. As we saw a program is a set or sequence of instructions that you would give to the computer and the computer would execute those instructions. Now in what language can I give these instructions to the computer. Can I give these instructions in a natural language like English? You must have heard that a computer understand binary, binary is the language of computers. Binary is a number system that has only two digits zero and one. The number system that we use has ten digits from 0 to 9 and we call it decimal number system. So why does computer understand binary or rather why are computers designed to understand binary and the reason is binary is really easy to simulate in actual physical design of things in real hardware. Computer is an electrical device and it's really easy to create the logic of zero and one in an electrical circuit. For example if current is flowing through some wire we can say that it's a 1 and if current is not flowing we can say that it's a 0. If there is some potential difference across a capacitor we can say that it's a 1 and if there is no potential difference we can say that its a 0. In general '1' can correspond to something that exists and '0' can correspond to something that does not exist. '1' can correspond to some condition being true and '0' can correspond to that condition being false. At lowest level in a computer any communication has to happen in binary or any data has to be stored in binary. You can use a bunch of wires together to communicate or signal something or you can use a bunch of capacitors together to store some data. In actual physical design there may be other ways to communicate or store some information but logically it has to be binary, a bunch of one's and zero's put together. If we use only one wire or one capacitor we can signal or store only two possible values zero and one. But let's see if we use two wires or capacitors together we can signal or store four possible combinations or four possible values in binary 00,01, 10 and 11. A binary digit is also called a bit, if you have only one bit you can have two possible values and if you have two bits you can have four possible values each bit can either be 0 or 1. 1 is also called 'set' bit and 0 is also called 'unset' bit. If we have three bits, lets say each cell that I have drawn here in this figure is a bit position then at each position we have two choices.We can either have 0 or a 1 and corresponding to these choices. We will have two choices for the next position and corresponding to a combination of these two positions we will have two choices for the next position. So if we have three bits we can have eight possible binary values. These are eight possible values with three bits, in decimal this is 'zero' this is 'one' this is 'two' and so on. In general if we have n bits we can have two to the power 'n' possible permutations and combinations of zero's and one's. We can have values from zero till two to the power 'n1', for 'n' equal 3 we can have values from 0 to 7 for 'n' equal 4 we can have values from 0 till 15 and we can go on. For more on binary number system and things like how to convert a number from binary to decimal and vice versa you can check the description of this video for some lessons. Now coming back to how computer would understand and execute instructions, core part of the computer that executes all the instructions is called the central processing unit or CPU. Sometimes we simply call it the processor and it's not the big case or box of your desktop computer it's often misunderstood like that. A modernday CPU is a very small integrated circuit that would look something like this, Intel is one of the companies that make CPU's. So CPU is the guy who has to execute your instructions. Now each instruction to the CPU has to be a pattern of bits a pattern of one's and zero's. But an instruction cannot be any random pattern of bits it has to be in a certain format so that the CPU is able to decode and execute it. A set of specifications are laid out for a CPU and your instructions must follow the specifications, for example specification can be that any instruction to perform an arithmetical or logical operation must be in 20 bits. Let's say the cells in the figure that I have drawn here are bit positions in a binary number. Now specification can be and this is just an example that out of these 20 bits first four bits or leftmost four bits must be a binary code for the operation that you want to perform. We typically write shortcut 'opcode' for operation code and operation codes will also be specified. Let's say operation code for 'Add' in four bits is 0001, let's say operation code for subtraction is 0010 and there can be other operations like comparison let's say comparison is 0101. So if we want to have an instruction to add two numbers these four bits must be 0001 and let's say rest of the specification is that the next 8 bits must be the first operand. The numbers upon which you perform operations are called operands. The next eight bits can be the second operand. Let's say you want instruction to add numbers 4 & 5. Then 4 in binary is 100 rest of these bits will be 0 and 5 in binary is 101 and rest of these bits will be zeros, leading zeros will not mean anything. So what you have here in 20 bits is an instruction to add numbers 4 & 5 according to an example specification that I have picked. So here is the deal this is the language that the machine actually understands and executes instructions in binary as per some laid out specifications. The bits in instruction maps to some physical design in circuit and we do not need to go into those details. Such an instruction in binary is often called machine language instruction, machine language because it can be interpreted and executed by the machine or more specifically the CPU. Two CPU's can have entirely different architectures and entirely different specifications for instructions. So machine language instruction for one CPU architecture may not work for another CPU architecture. There was a time when programs where literally written in machine language, it was a very tedious and errorprone process. Think about it, you would constantly have to look at the specifications for binary codes for various operations and commands. The program will not be human readable you will not be able to figure out the logic by just looking at a program. Some improvement came with development of assembly language. In assembly language we can have a more humanreadable representation of a machine language instruction, for example if this is the machine language instruction with one opcode and two operands then in assembly language the same instruction can be written in a more readable form. We can write some keywords for opcode say for example if this is opcode for addition we can write Add and then we can write the operands as well as constants in decimal, operand one is 4 and operand two is 5. One can write an instruction like this in assembly language the improvement that you're getting is instead of writing operation codes and commands in binary you are writing some keywords which will make some sense. Instead of writing 0001 for addition we are writing add keyword and instead of writing constants as binary numbers we're writing constants in decimal. But wait a minute didn't I say that CPU that has to execute all the instructions will understand only machine language instructions. This guy is shouting it out loud here that I can execute only machine level machine language instructions so how can we write program in assembly language or whatever we are talking here. Well you can write your logic in assembly language and then you can pass the assembly language instructions to a program named assembler and this assembler will generate machine language instructions corresponding to the assembly language instructions. So basically someone wrote a program named assembler and with assembler programmers could write a little more readable instructions in assembly language. But there was a problem with assembly language, assembly language is strongly mapped to machine language it's just that some binary codes in machine language become keywords in assembly language. So just like machine language assembly language instructions will also vary from one CPU architecture to another.So if you would try to port your assembly language code from one architecture to another the same program may not run. You may have to rewrite your program according to a new set of specifications. So both assembly and machine language are specific to architecture of machine. Such languages the instructions in which depend upon the architecture of machine or more specifically the architecture of CPU have been called lowlevel languages. There was need for programming languages that would not be specific to architecture of machine, such programming languages were called highlevel languages. A highlevel language is supposed to have more elements of natural language and it's supposed to make the life of a programmer a lot more easier because he will not have to care about all the detailed low level specifications of the machine. And now let's talk about highlevel languages, highlevel languages give you abstraction from machine architecture, so many highlevel languages have been developed till date I would name some of them. We have C finally it took the name of 'C' after so long we have 'C++' we have 'Java' we have 'Python' and couple of old ones like 'FORTRAN', 'Basic' and the list goes on. FORTRAN was the first highlevel language developed by IBM. Now even with highlevel languages we cannot skip the basic rule that finally the instructions that will be executed have to be in machine language. There are two possible execution models for highlevel languages. Some languages are called compiled languages, for these languages we would have a program that we would call compiler. Compiler will be different for different languages. It will also be different for different machine architectures. Compiler will take your program written in a highlevel language. We typically say that it takes your source code written in a highlevel language and generates machine code, set of instructions that can be executed directly by the CPU. C is example of the combined language how it typically works is that to the compiler you would give a file or a group of files containing your program in highlevel language. Let's say app.c is the find that will contain a program in C, the compiler widget generate another file that will be executable on the machine. Let's say it will create something like app.exe, exe files are executable files on Windows machine. The process of generating executable files from source code written in highlevel languages is called compilation basically compiler performs compilation. There is another execution model for highlevel languages. Some languages are called interpreted languages, for interpreted languages we need to use programs that we call interpreters. Unlike compilers interpreters do not generate executable codes that can be executed separately. An interpreter takes source code in a highlevel language analyzes it and runs it within itself, no executable file is created program is executed within the interpreter. We will not go into the details of how it really happens. Python is an interpreted language theoretically any language can be compiled or interpreted but practically languages fall into one of these categories, either they are compiled or interpreted. So there are so many highlevel languages and we are saying that we will learn programming through C. First of all why there are so many languages and which language is good. Actually there is no good or bad language, some languages were written to overcome the limitations in previous languages. Some languages were written to make a certain set of tasks easier but as such basic constructs and primitive are same in most languages and what you can do in one language can be done in another language. There would be very few exceptions. If someone knows one of the programming languages really well it will be very easy for him to pick on another programming language. And now let's talk about C, C was developed around year 1970 by a great computer scientist named Dennis Ritchie. Dennis Ritchie is also the creator of UNIX operating system, in fact UNIX operating system was written in C. C is a highlevel language and it needs compilation. C is still a very famous programming language and most of the other famous programming languages like C++, Java or C sharp derive their basic structure derive their basic constructs from C. So if you know the syntax of C it's really easy to on board these other languages at least for the basics and C gives you a lot of lowlevel control on machine. Some people say that C is somewhere in between a lowlevel language and highlevel language. So working with C will give you a lot of insight into computer architecture and I think it's good for a Computer Science Engineer. So we should be clear in this series of lessons we're going to learn programming through C. To learn any language we should learn some vocabulary some grammar basically we should have some set of rules some syntax some semantics. Of course the rules for a programming language will be much more stricter than rules for a natural language. A programming language cannot be ambiguous like natural language. We will get started with all of these things in our next lesson. We will also write our first C program in next lesson. This is it for this lesson Thanks for watching.