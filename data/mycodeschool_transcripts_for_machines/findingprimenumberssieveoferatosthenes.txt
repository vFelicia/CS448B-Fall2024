In the previous lesson, we saw how to verify whether a given number n is prime or not using trial division method. Now, in this lesson, we want to solve a problem where we want to find out all the prime numbers up to a given number n. So, I want to write a method say FindPrimes that should take an argument n and it should give me all the prime numbers till n. Now, we can do so using the trial division method. What we can do is lets say we start with an empty list A and we can say that for all i from 2 to n, if i is prime, and lets say we want to decide whether i is prime or not by calling a method IsPrime that verifies whether this number i is prime or not using trial division method and if it is prime, we add i to list A. And let us say , IsPrime(x) verifies primality of x through trial division. Ok, so what will be the time complexity of this particular algorithm? Now, as we know in trial division method, we try dividing a number by all numbers till sqrt(n) to test for primality. So, the complexity of this particular method is bigoh of sqrt(n). Now, this method is canned n1 times here in this loop. So, the overall time complexity of this particular function would be bigoh of n*sqrt(n) because the running time of a loop is the number of times the loop runs multiplied by the complexity of the statements inside. And bigoh gives us upper bound of the time taken, so because this loop run almost n times, so this is n*sqrt(n). Ok, so this was one way of finding out all the prime numbers and this was using trial division. Now, there is another algorithm which is simplest and one of the most efficient algorithms to find out all the prime numbers up to a given number and the name of this algorithm is Sieve of Eratosthenes. And this is an ancient algorithm named after a Greek mathematician Eratosthenes. What we do in this particular algorithm is that wee first create a list of all the numbers from 2 to n and initially say that all of them are prime. So, if n is say 15, then we create the list of numbers from 2 to 15 and initially we say that all of them are prime. Now, we start with the first element in the list which is 2. Now, if 2 is prime, all the multiples of 2 cannot be prime. So, what we do is we strike off all the multiples of 2. So, 4,6,8,10,12 and 14 are struck off. They are not prime because they can be divided by 2. Now, we go to the next remaining number in the list which is not struck off. So, we go to 3. Now, 3 is a prime, so all the multiples of 3 cannot be prime, they need to be struck off. So, we strike off 6. It is already struck off, but that's fine, that doesn't matter. So, we strike off 9 now. And we strike off 12 again and 15 goes away as well. Now the next remaining prime number in this list is 5. Multiples of 5 are 10 and 15 which are already struck off. The next remaining number is 7. the only multiple of 7 , 14 is already stuck off. Now, the remaining number is 11 and 11 has no multiple in this range. And 13 also does not have any multiple in this range. Now, all these remaining numbers are prime. And let us now write code for this. And I will clear this in the left. In an actual code, what we will do is, we will first declare an integer array, lets say the name of the array is Primes of size n+1. In C or C++, you cannot keep a variable inside this bracket while declaration, but lets say for the sake of understanding, you know how to declare a dynamic array or you can keep an array of some maximum size and use only n+1 elements in it. So, what we will initially do is, for all indices starting 0 to n, we will set primes[i] = 1. And lets say, if primes[i] is 1, then i is prime and if primes[i] is 0, then i is not prime. So, initially all the numbers, from 0 to n are prime. Now we know that 0 and 1 are not prime. So, initially we will say that, now after we exit this loop, set primes [0] =0 and also set, primes[1] to 0. Ok, now we will run a loop starting 2 to n and now we will write the logic of the striking off that we have done in the right here. So, we will say that if primes[i] is 1, then i is prime. We need to set all the multiples of i as zero which will mean that they are not prime. So, I will write another loop here. Lets say j is the multiplier to i, so in all, the validation should be i*j<=n and we keep incrementing j. So, in the first loop, we will have. Ok, so we will set something like primes[i]*j equal 0. So, in the first loop, in the first execution of the loop, we will set 2*i to 0, and then 3*i to 0 and we will go on incrementing j till the time i*j is less than or equal to n. Ok, so finally when we exit this loop, we will be able to strike off all the nonprimes by setting 0 at their index in this particular array and finally, we will be able to say that if primes[i] is 1, then i is prime and thus we have all the prime numbers up to n. Now, there is one more optimization possible here. As we know and as we had talked about in the previous lessons that if we cannot find a factor of n till sqrt(n), then n is prime. This happens because the factors of a number exist in pairs, so there will always be 2 factors such that, 2 factors a and b such that a*b = n and one of the factors will be less than sqrt(n) and another one will be greater than or equal to sqrt(n). Sorry, one will be less than or equal to square root of n and another will be greater than or equal to sqrt(n). Whats happening here in this algorithm is that a number is being struck off by one of its factors, but if a number is not struck off till square root of itself, then it will not be struck off later. For example, 15 which is the largest number in this case is struck off by 3, the divisor here is 3 which is less than square root of 15. Square root of 15 will be 3 point something. So, this gives us an optimization. We can run this particular loop only till sqrt(n) and that should be enough. n is the highest number in the list and if at all a number has to be struck off, it will be struck off by a divisor less than or equal to its square root. Let us now analyze the time complexity. The time complexity would be contributed by these two loops one loop here which will run n times and second is the running time of this nested loop and rest of the cost will just add up as constant. Now, finding the running time of this nested loop is a little tricky. As we running time of the loop is the running time of statements within the loop. So, we need to see how many times this statement within the second loop executes. For i = 2, we will strike off n/2 elements. So, this statement or the inner loop will execute n/2 times. For i = 3, we will strike off n/3 elements. So, we will have something like the overall number of times this nested loop will run will be something like n/2+n/3+n/5+ all the prime numbers will come in denominator. And we will have a series like this. Ok, so you can search on Wikipedia for time complexity of Sieve of Eratosthenes and you will find a proof that this is equal to bigoh of n*log log n and we are not going into the detail mathematical proof of this here. So, the overall complexity will have this O(n) added as well which will be the complexity of the first loop that we have but since O(n) is a lower order term than this expression O(n*log log n), so overall complexity of Sieve of Eratosthenes is O(n log log n). So, this was Sieve of Eratosthenes for you. Thanks for watching !