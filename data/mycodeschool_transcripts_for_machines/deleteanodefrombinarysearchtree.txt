In this lesson, we're going to write code to delete a node from binary search tree. In most data structures deletion is tricky. In case of binary search trees too, it's not so straightforward. So let's first see what all complications we may have while trying to delete a node from binary search tree. I have drawn a binary search tree of integers here. As we know in a binary search tree for each node value of all nodes in its left subtree is lesser and value of all nodes right subtree is greater. For example, in this tree if I'll pick this node with value 5 then we have 3 and 1 in its left subtree which are lesser and we have 7 and 9 in its right subtree which are greater, and you can pick any other node in the tree and this property will be true else the tree is not a BST. Now when we need to delete a node, this property must be conserved. Let's try to delete some nodes from this example tree and see if we can rearrange these things and conserve the property of binary search tree or not. What if I want to delete this node the value 19. To delete a node from tree we need to do two things, we need to remove to reference of the node from its parent so the node is detached from the tree. Here we will cut this link we will set right child of this node with value 17 as null and the second thing that we need to do is reclaim the memory allocated to the node being deleted. that is wipe off the node object from memory. This particular node with value 19 that you're trying to delete here is leaf node. It has no children and even if we take this guy out by simply cutting this link that is removing its reference from its parent and then wiping it off from memory there is no problem, property of binary search tree that for each node value of nodes in left should be lesser and value of nodes in right should be greater is conserved. So deleting a leaf node, a node with no children is really easy. In this tree, these four nodes with values 1, 9, 13 and 19 are leaf nodes. To delete any of these, we just need to cut the link and wipe off the node that is clear it from memory. But what if we want to delete a non leaf node, what if in this example we want to delete this node with value 15, I can't just cut this link because if I'll cut this link, we will detach not just the node with value 15 but this complete subtree. We have two more nodes in the subtree we could have had a lot more. We need to make sure that all other nodes except the node with value 15 that's been deleted remain in the tree. So what do we do now. This particular node that we're trying to delete here has two children on two subtrees. I'll come back to case of node with two children later because this is not so easy to crack. What we want to discuss first is the case when node being deleted would have only one child. If the not being deleted would have only one child like in this example this node with value 7 this guy has only one child. This guy has a right child but does not have left child. For such a node what we can do is we can link its parent to this only child, so the child and everything below the child we could have some more nodes below 9 as well will remain attached to the tree and only the node being deleted will be detached. Now we're not losing any other node than the node with value 7. This is my tree after the deletion. Is this still a binary search tree. Yes, it is. Only the right subtree of Node with value five has changed. Earlier we had 7 and 9 in right subtree of 5 and now we have 9 which is fine. What if we were having some more nodes below 9. Here in this tree, i can have a node in left of 9 and the value in this node has to be lesser so than 12, greater than 5, greater than 7 and lesser than 9. We are left with only 1 choice. We can only have 8 here, in right we can have something lesser than 12 and greater than 5, 7 and 9 all in our between 9 and 12. Okay so if the original tree was this much after deletion this is how my tree will look like. Okay so are we good now. Is the tree in right a BST. Well yes, it is. When we are setting this node with value 9 as right child of the node with value 5. We are basically setting this particular subtree as right subtree of the node with value 5. Now this subtree is already in right of 5 so value of all nodes in this subtree is already greater than 5 and the subtree itself of course is a binary search tree. Any subtree in a binary search tree will also be a binary search tree, so even after deletion, even after the rearrangement property of the tree that for each node, nodes in left should be lesser and nodes in right should be greater in value is conserved. So this is what we need to do to delete a node with just one child or a node with just one subtree connect its parent to its only child and then wipe it off from memory. There are only two nodes in this tree that have only one child, let's try to delete this other one with value 3. All we need to do here is set 1 as left child of 5. Once again if there were some more nodes below 1, then also there was no issue. Okay so now we're good for two cases, we good for leaf nodes and we are good with nodes with just one child and now we should think about the third case, what if a node has two children, what should be do in this case. Let's come back to this node value 15 that we were trying to delete earlier.With two children we can't do something like connect parent to one of two children. While trying to delete 15 if we will connect 12 to 13. If we will make 13 to right child of 12 then we will include 13 and anything below 13 that is we will include the left subtree of 15 but we will lose the right subtree a 15 that is 17 and anything below 17. Similarly, if we will make 17 the right child then we will lose to left subtree of 15 that is 13 and anything below 13. Actually this case is tricky and before I talk about a possible solution, I want to insert some more nodes here. I want to have some more node in subtrees of 13 and 17 the reason I'm inserting some more nodes here is because I want to discuss a generic case and that's why I want these two subtrees to have more than one node. Okay coming back when I'm trying to delete this node my intent basically is to remove this value 15 from the tree. My delete function will have signature something like this. It will take pointer reference to the root node and value to be deleted as argument. So here, I am deleting this particular node because I want to remove 15 from the tree. what I'm going to do now is something with which I can reduce case 3 to either case 1 or case 2. I'll wipe off 15 from this node and I'll fill in some other value in this node. Ofcourse I can't fill in any random value. What I'll do is, I'll look for the minimum in right subtree of this node and I'll fill in that value here. Minimum in right subtree of this node is 17. So I have filled 17 here. We now have two nodes with value 17 but notice that this node has only one child. We can delete this node because we know how to delete a node with only one child and once this node is deleted my tree will be good. The final arrangement will be a valid arrangement for my BST, but why minimum in right subtree, why not value in any other leaf node or any other node with one child. Well we also need to conserve this property that for each node, nodes left should have lesser value nodes in right should have greater value. For this node if I'm bringing in the minimum from its right subtree then because I'm bringing in something from its right subtree it will be greater and the previous value 17 is greater than 15. So all the elements in left ofcourse will be lesser and because it's the minimum in right subtree, all the elements in right of this guy would either be greater or equal.We will have a duplicate that will be equal. Once the duplicate is removed everything else will be fine. In a tree or subtree if a node has minimum value it won't have a left child because if they're is a left child there is something lesser and this is another property that we're exploiting. Give this some thought. In a tree or subtree node with minimum value will not happen left child, there may or may not be a right child. If we would have a right child, like here we have a right child. So here we are reducing case 3 to case 2. If there was no child we would have reduced case 3 to case 1. Okay so let's get rid of the duplicate. I'll build a link like this and after deletion this is what my tree will look like. So this is what we need to do in case 3, we need to find a minimum in right subtree of targeted node then copy or fill in this value and finally we need to delete the duplicate or the node with minimum value from right subtree. There was another possible approach here and I must talk about it. Instead of going for minimum in right, we could also go far maximum any left subtree. Maximum left subtree would ofcourse be greater than our equal to all the values in left, maximum left subtree of node with value 15 is 14. I'm copying 14 here. Now all the nodes in left a lesser than equal to 14 and because we're picking something from left subtree it will still be lesser than the value being deleted. 14 is less than 15. So all the nodes in this right subtree will still be greater and if we're picking maximum in a tree or subtree then that node will not have right child because if we have something in right we have something greater, so the value can't be maximum. The node may have left child. In this case a node with value 14 doesn't have a left child so we are basically reducing case 3 to case 1. I'll simply get rid of this node. So we are looking good even after deletion. In case 3, we can apply any of these methods and this is all in logic part. Let's now write called for this logic. I'll write c++ and we will use recursion if you're not very comfortable applying recursion on trees then make sure you watch earlier lesson in this series. You can find link to them and description of this video. In my Code here i have defined node as a structure with three fields. We have 1 field to store data and we have 2 fields that are pointers to node to store addresses of left and right children and I want to write a function named delete that should take pointer to root node and the data to be deleted as argument, and this function should return pointer to root node because that root may change after deletion. What we're passing to delete function is only local copy of root's address. If the address is changing we need to return it back. To delete a given value or data to the first need to find it in the tree and once we find the node containing that data, we can try to delete it. Remember only identity of tree that we pass to functions is address of the root node and to perform any action on the tree we need to start at root. So let's first search for the node with this data. First I'll cover a corner case. If the root is null that is if the tree is empty, we can simply return. I can say return root or return null here, they will mean the same because root is null, else if the data that we are looking for is less than the data in root then its in the left subtree. The problem can be reduced to deleting the data are from left subtree. We need to go and find the data in left subtree, so they can make a recursive call to delete function passing address of left child and the data to be deleted. Now the root of the left subtree that is the left child of this current node may change after deletion but the good thing is, the delete function will return address of the modified root of the left subtree. So we can set the return as left child of current node. Now if data that we're trying to delete is greater than the data in root, we need to go and delete the data from right subtree, and if the data is neither greater nor lesser that is if it's equal then we can try deleting the node containing that data. Now let's handle the 3 cases 1 by 1. If there is no child we can simply delete that node what I'll do here is that first wipe off to node from memory and this is how I'll do it. What we have in root right now is address of to node to be deleted. I'm using to delete operator here that's used to deallocate memory of an object in heap. In C you would use free function. Now root is a dangling pointer because object in heap is deleted but root still has its address. So we can set root as null, and now we can return root. Reference of this node in its parent will not be fixed here. Once this recursive call finishes then somewhere in these 2 statement in any of these two statements in any of these two else ifs the link will be corrected. I hope this is making sense. Okay now let's handle other cases. If only the left child is null then what I want to do is I first want to store the address of current node that I'm trying to delete in a temporary pointer to node and now I want to move to root, this pointer named root to the right child, so the right child becomes the root of this subtree and now we can delete the node that has been pointed to by temp. We will use to delete operator. In C we would be using free function. and now they can return root.Similarly if the right child is null, I'll first store address of current root in a temporary pointer to node then I'll make the left child new root of the subtree so we will move to the left child and then I'll delete the previous root whose address I have in temp and finally I'll return root. Actually we need to return root in all cases, so i'll remove this return statement from our all these if and else if and write one return root after everything. Let's talk about the 3rd now. In case of two children what we need to do is, we need to search for minimum element in right subtree of the node that we're trying to delete. Let's say this function findmin will you give me address of the node with minimum value in tree or subtree, so i'm calling this function findmin and I'm collecting the return in a pointer to node named temp. Now I should set the data in current node that i am trying to delete as this minimum value and now the problem is getting reduced to deleting this minimum value from the right subtree of current node. With this much code I think I'm done with delete function. This looks good to me. Let's quickly run this code on an example tree and see if this works or not. I have drawn a binary search tree here. Let's say these values outside these nodes are addresses of the nodes. Now I want to delete number 15 from this tree, so I'll make a call to delete function passing address of the root which is 200 and 15 the value to be deleted. In delete function for this particular call control will come to this line, a recursive call will be made. Execution of this call delete 200 , 15 will pause and it will resume only after this function below delete 350 , 15 returns. Now for this call below we'll go inside the third else in case 3, here we will find with minimum value in right which is 17 which is 400, the value is 17 address is 400. First we will set the data in node 350 as 17 and we are making a recursive call to delete 17 from right subtree of 350. We have only one node in right subtree of 350. Here we have case 1. In this call will simply delete the node at 400 and return null. Remember root will be returned in all calls in the end. Now delete 350 , 15 will resume and in this resumed call, we will set address of right child of node at 350 as null. As you can see the link in parent is being corrected, when the recursion is unfolding and the function call corresponding to the parent is resuming and now this guy can return, and now in this call, we will resume at this line. So right child of node at 200 will set as 350. It's already 350 but it will be written again and now this call can also finish. So I hope you got some sense of how this recursion is working. You can find link to all the source code and code to test the delete function in description of this video. This is it for this lesson. Thanks for watching.