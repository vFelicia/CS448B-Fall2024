In our previous lesson, we talked about level order traversal of binary tree which is basically breadthfirst traversal. Now in this lesson we are going to discuss these three depthfirst algorithms preorder, inorder and postorder. I have drawn a binary tree here datatype filled in the nodes is character now as we had discussed in earlier lessons, in depthfirst traversal of binary tree if we go in one direction then we visit all the nodes in that direction or in other words we visit the complete subtree in that direction and then only we go in other direction. In this example tree that i have drawn here if I'm at 'root' and I'm going left then I'll visit all the nodes in this left subtree and then only I can go right and once again when I'll go right I'll visit all the nodes in this right subtree if you can see in this approach we are reducing the problem in a selfsimilar or recursive mannner, we can say that in total visiting all the nodes in the tree is visiting the 'root' node visiting the left subtree and visiting the right subtree remember by visiting a node we mean reading or processing the data in that node and by visiting a subtree we mean visiting all the nodes in the subtree indepth first strategy relative order of visiting the left subtree, right subtree and the root can be different, for example we can first visit the right subtree then the root and then the left subtree or we can first visit the root and then left subtree and then the right subtree conventionally left subtree is always visited before right subtree we this constraint we will have three permutations, we can first visit the root and then the left subtree and then the right subtree and such a traversal will be called preorder traversal or we can first visit the left subtree then the root and then the right subtree and such a traversal will be called inorder traversal and we can also go leftright and then root and such a traversal will be called post order traversal, left and right subtree will be visited recursively in same manner as the original tree, so in preorder once again for the subtrees we will go root, left and then right in inorder will keep going left, root and then right. The actual implementation of these algorithms really easy and intuitive let's first see code for preorder traversal. I first written the algorithm in words here, in preorder traversal we first need to visit the root and then left subtree and then the right subtree now I want to write a function that should take pointer or reference to root node as argument and print data in all the nodes in preorder let's say visiting a node for us is printing the data in that node in C or C++ my method signature will look something like this this function will take address of the root node as argument, argument type is pointer to Node. I'll define node as a structure with three fields like this, data type in this definition is character and there are two fields to store the addresses of left and right children 55 000315,349 > 000320,609 now in preorder function I'll first visit or print the data in root node and now i'll make a recursive call to visit the left subtree I have made a recursive call here and to this call I'm passing address of the left child of my current root because left child will be the root of left subtree and I'll have another call like this to visit the right subtree there is one more thing that we need to add in this function and we will be done we cannot go into recursion infinitely, we need to have a base condition where we should exit if a tree or a subtree is empty or in other words for any call if root is null we can return or exit. Now with this much of code I'm done with my preorder function. this will work fine in C or C++ actually in C make sure you right struct space node instead of righting just 'node', rest of the things are fine it will be good to visualize this recursion so let's now quickly see how this preorder function will work if this example tree that I'm showing in right here is pass to it I'll redraw this tree and show it like this hear I'm depicting node as a structure with three fields let's say the leftmost cell here is to store the address of left child the cell in middle is to store the data and the right most cell is to store the address of right child Now let's assume some addresses for these nodes, let's say the root node is at address 200 and I'll assume some random addresses for other notes as well and now I can fill in left and right fields for each node and as we know the identity of tree that we always keep with us is reference or address of the root node this is what we pass to all the functions, in our implementation we often use a variable of type pointer to node named root to store the address of root node, we can name this variable anything, we can name this variable root or we can name this variable rootPtr but this is just a pointer this particular block that I'm showing here is for pointer to node and all these rectangles with three cells are nodes, this is how things are organized in memory now for this tree, let say we are making a call to this preorder function I'll make a call to preorder passing it address 200 for this call root is not null so we will not return at first line in this function we will go ahead and print the data in this node at address 200. I'll write output for all print statements here and now this function will make a recursive call execution of this particular function call will pause, it will resume only after this recursive call preorder(150) finishes this second call is to visit this left subtree this call preorder(150) is to visit this left subtree, address of the left child of node at 200 is 150 once again for this call root is not null, so we will go ahead and print the data, data in node at 150 is D and now once again there will be a recursive call with this call preorder 400. We are saying that we are going to visit this subtree once again we will print the data and make another recursive call now we have made a call to visit this particular subtree with just one node for this call we will print the data and now for node at 250 address of left child is zero or null we will make a call preorder(0) but for this call we will simply return because the address in this variable root will be null. We have hit the base condition for our recursion call to preorder(0) will finish and preorder(250) will resume. Now in this particular function call will make another call for right subtree for node at 250, even the right child is null we will have another recursive call passing address 0 but this once again simply will return and now call to preorder(250) will finish and call to preorder(400) will resume. Now in call to preorder(400) we will make another recursive call to preorder(180) with this call preorder(180), we are visiting this particular subtree with just one node for this call first we will print the data and then we will make a recursive call to preorder(0) now preorder(0) will simply return and then we will have another call to preorder(0) for right child of 180, the recursion will go on like this there's one thing that I want to talk about you that's happening in this whole process even though we are not using any extra memory explicitly in our function because of the recursion we are growing the function call stack we have discussed memory management a number of times in our earlier lessons you can check description of this video for link to one of those lessons. As we know for each function call we allocate some amount of memory in what we call stack section of applications memory and this allocated memory is reclaimed when the function call finishes at this stage of execution of my recursion for this example my call stack will look something like this I'm writing P as shortcut for preorder because I'm short of space here let's say we made a call to preorder passing it address 200 from main function, main function will be at bottom of stack at any time only the call at top of stack will be executing and all other calls will be paused, call stack keeps growing and shrinking during execution of a program because memory is allocated for a new function call and its reclaimed when a function call finishes so even though we are not using any extra memory explicitly here we are using memory implicitly in the call stack so space complexity which is measure of rate of growth of extra memory used with input will depend upon the maximum amount of extra memory used in the call stack. I'll talk about space complexity once more later for now let's come back to this recursion that I was executing called to this preorder(0) will finish and preorder(180) will resume memory allocated for execution of preorder(0) will be reclaimed now for preorder(180) both recursive calls have finished so this guy will also finish even for preorder(400) both calls have finished so preorder(150) will resume. Now this guy will make a recursive call to preorder function passing it address 450 address of its right child, memory in the stack will be allocated for execution of preorder(450). Now in this call we will first print the data and then we will make two recursive calls to preorder passing address 'zero' each time because for this node at 450 both children are null, both calls will simply return and then preorder(450) will finish and now preorder(150) will also be done if you can see the call stack will grow on till we reach a leaf node, a node with no children and then it will start shrinking again maximum growth of call stack to do this recursion will depend upon maximum depth or height of the tree. We can say that extra space used will be proportional to height of the tree or in other words space complexity of this algorithm is O(h), where h is height of the tree. Okay coming back to the recursion we are done with preorder(150) so preorder(200) will resume and now we will make a call to visit this particular subtree, in this call we will print J and then we will make a call passing address 60 so now we are visiting this particular subtree, here we will first print "G" and then this guy will make a call to preorder(0) which will simply return and then there will be another call to preorder(500) here we will print "I" 187 001119,160 > 001122,610 and then we will two recursive calls passing address 'zero' every time because node at 500 is a leaf node with no children after this guy finishes preorder(60) will resume, now this guy will also finish and preorder(350) will resume and now we will have a call to preorder(700) which once again is a leaf node, so "K" which is data in this node will be printed and then we will two calls passing address 'zero' which will simply return. Now at this stage all these calls can finish, we are done visiting all the nodes finally we will return back to the caller of preorder(200) which probably would be the main function so this is preorder traversal for you I hope you got how this recursion works, code for inorder and postorder will be very similar in inorder traversal my base case will be the same so I'll say if root is null then return or exit if root is not null I first need to visit the left subtree I'm visiting the left subtree with this recursive call then I need to visit the root so now I'm writing this printf statement to print the data and now I can visit the right subtree so this second recursive call, and this is my inorder function, inorder traversal of this example tree that I have drawn here will be this. This particular binary trees actually also a binary search tree and inorder traversal of a binary search tree would give us elements in the tree in sorted order. Okay let's now write code for postorder. For this function once again the base case will be the same so I'll say if root is null, return or exit if root is not null. I first need to visit the left subtree so I have made this recursive call, then the right subtree so I'll have this another recursive call and now I can visit the root node postorder traversal for this example tree will be this. So this is preorder, inorder and postorder for you you can check the description of this video for link to all the source code. Let's now quickly talk about time and space complexity of these algorithms. Time complexity of all these three algorithms is O(n), if you could see then there was one function call corresponding to each node where we were actually visiting that node, where we were actually printing the data in that node so running time should actually be proportional to number of nodes there's a better formal and mathematical way of proving that time complexity of these algorithms is O(n), you can check the description of this video for link to that space complexity as we had discussed earlier will be O(h), where h is height of the tree, height of a tree in worstcase will be (n1) so in worstcase space complexity of these algorithms can be O(n) and in best or average case height of the tree will be O(log n) so we can say that in best or average case space complexity will be O(log n). I'll stop here now. In coming lessons we will solve some problems on binary tree. Thanks for Watching.