In this lesson, we will learn how to find the merge point of two linked lists. This is actually a very famous question and has been asked in many programming interviews. The prerequisites for this lesson is that you must know the basics of linked list like what is linked list, how to traverse a linked list etc. You can find the links to the lessons in the video description. So, what do we mean by merge point of two linked list. I have drawn a linked list here. we have two nodes and I have assumed that these nodes are at addresses 200 and 250 in memory. Each node has 2 fields, one to store the data and another to store the address of next node. A head pointer points to the first node in the linked list. Linked list grows dynamically. So, we can add a node to the list or delete a node from the list as and when we need it. I am drawing two linked list here. I am giving some random addresses to each of the nodes. I have given addresses to each of the nodes and also filled in the address field of nodes. So, this node contains pointer to the next node which is 140. Similarly this contains a pointer to the next node that is 80. And this node has this zero which indicates that it is the last node of the list. I'll do this for the next linked list as well. I'll also fill in some random integer values to every node. Now there may be situations in which two linked lists start with different data values, but both end with the same common data values. It is a waste of memory to allocate nodes with the same data values to both the linked lists. Rather, the lists can share these common data. So this node with address 140, would also point to this node with address 30 and we no longer need these nodes. So this node with data value 7 and address 30 is actually our merge point. We can draw an interesting real world analogy to this problem. This is a snapshot of the blue line of the Delhi metro.There are two lines one starting at station Vaishali, and ending at Rajiv Chowk. And other starting at station City Center and ending at Rajiv Chowk. Lets say you are hired as a programmer by the Delhi Metro Corporation. You are given these lines in the form of two linked lists where Vaishali forms one head node and City Center forms the other head node. The information of all these stations can be represented using nodes of a linked list. Now there are lots of common stations between these two lines. But we are interested to find only the first common point which is the merge point of the the two linked lists. So here Yamuna Bank is the merge point of the two linked lists. Now there are lots of different approaches to solve the problem. I'll be discussing three of them in this lesson. I'll start with the brute force solution which is the first intuitive idea to solve the problem. Next I'll trade of some memory to optimize the brute force and finally I'll come to the best possible solution to this problem. Now before we move to the solution, let us first see how our function signature would look like. I'll be coding in C++ throughout the lesson. As we know, the nodes of a linked list can be defined using a structure. We have a data field which here I assume to be of integer type and a pointer to store the next node's address. The function find merge point finds the intersection of the given linked lists. We will be given the head nodes of both the lists in parameters as A and B and we will be returning the intersecting node of the given lists. So A is the pointer of head node of list 1 and it has an address 100 while B is the pointer to the head node of list 2 with address 200. I'll be denoting the length of list A with m which is 4 here; while the length of list B with n which is 5 here. So what is the first approach that comes to mind to solve this problem. The brute force approach would be to compare node's address of list A, with every node's address of list B. The first matching node would then be our merge point. So firstly we compare this first node's address that is 100 with the first node's address of B that is 200. We did'nt find a match. Then 100 with 40, 100 with 310, with 30 and finally with 190. We did'nt find any match. We do the same thing with this node. But there is no match. Then we start comparing 30 with each of list B nodes. And finally we reach a matching node. So, this becomes our merge point. Now let us code this brute force solution. We firstly need to find the lengths of both the lists as m and n. To find the length I have written this function which basically traverses through all the nodes of a list and increments a counter every time. Finally we return this counter. I need to check for every node of A whether it is the intersecting node or not for which I have written this for loop. And updating A with its next every time. I need to compare each node of A, with all the nodes of linked list B, for which I have written this for loop. And if there is any matching node, we simply return that node from this function. Now if we do not find any match in one iteration of the i loop, then we need to reset B to the starting node. Like while comparing 100 we would have traversed all the nodes of B, and reached 190 . So we need to bring it back to 200. So that it points to the starting node of the linked list. So what I have done is made a copy of the pointer of the starting node of B, as head2. And update B as head2 for every iteration of the i loop. This code would then find the merge point of it it exists. So what would be the time complexity of this approach. It would take Big O of m time to find the length of A. Similarly, Big O of n time to find the length of B. And then this nested for loops would take Big O of mn time. Therefore, the overall complexity would be Big O of m into n. You can refer to video description, to find our lessons to learn how to find time complexities of algorithms. We can easily modify this brute force approach to improve the time complexity. The technique I will follow, is called timememory trade off. And is a very common thing in programming. What we do is, tradeoff or invest some memory to save us some execution time of the code.If you observe we are iterating over all nodes of B. Instead, we could save all the addresses of linked list B in some kind of a structure, and then give a simple look up here to see if it is present or not. Now we could use different kinds of things for our storage purpose. The only requirement is that it should have fast insertion and retrieval methods. So may be we could have used some sorted array to store all the addresses and do some binary search here. Or may be use some hashing techniques. I'll be using set here. Set is implemented using binary search trees. And it provides insertion and retrieval of its elements in logarithmic time which is actually very fast. Note that sets are built in C++. Here I have declared a set addresses of Node pointers. I will traverse all nodes of linked list B, and include each one of them in the addresses set. Now instead of writing this whole for loop, what I can do is, simply use the find operations in the set, and by writing this condition the addresses dot find A is not equals addresses dot end, we basically check for the presence of this element in the set. If the element is found, we simply return the address. Remember that we pushed all the addresses of linked list B in our set. So if any address of linked list A is already in the set then that has to be the merge point. Hence we can simply return it here. I do not need these references any more , so I can delete them. Let's see how this has improved our time complexity. The insert and find operations in set take logarithmic time and because we are running this statement n times, this section of the code takes n log (n) time. Similarly this section of the code takes m log (n) time. Therefore, the overall time complexity is m log (n) +n log (n). However, the storage of this addresses, takes order of n space too. In the next solution that I am going to show you, we will achieve a better time complexity without using any extra space. Now just for a moment assume that we don't have this particular node with address 200, such that both this linked list have the same lengths prior to this merging node. I am denoting this length using k. What we can do is, advance pointers to these linked lists together, and eventually they will meet at the merging point. So initially we have A pointing to this node with address 100. And B pointing to this node with address 40.Then A points to this node with address 140 and similarly B moves one step forward to point to this particular node. And eventually both A and B, will point to the merging node. So the basic idea is, if we have say, d more nodes in linked list B, then what we can do is walk through these d nodes, such that both the pointers are equidistant from the merge point. And then we can move both the pointers simultaneously, until they reach this intersecting node. So how do we calculate this value of d? You can pause the video and think for a while. As we have seen, both the linked lists have the same length after these, d nodes. Umm, that because they both are k nodes from this merge point. And then they share the same nodes. So if we find out the difference of the lengths of the linked list, that is n minus m here, we will actually be getting the number of extra nodes in linked list B. So in general, d is the difference in the lengths of the linked lists, which is 5 minus 4, that is 1 here. Now that the idea is clear, let us code this solution. Like before, we initially find the lengths of both the linked lists A and B, and store them in m and n respectively. Now we can calculate the value of d, which is n minus m. So we can walk through the d nodes of the longer list, that is B. To do so, we run a for loop d times and in every iteration, make B point to its next. So now, both A and B are equidistant from the merge point. Therefore, we can traverse both the lists, until they both hit NULL. In every iteration we check if A and B point to the same node; which would mean that it is the merge point, and hence we can simply return that node. Otherwise we can simply advance both the pointers to the next node. So right, this code would find the merge point, if it exists. However, there are two cases that we need to handle separately. I call them corner cases. Can you think of them? Ok, so the first one is; what if there is no merge point in the linked lists at all. In that case, this condition would never be true. That is because, both of them do not have any common nodes, and hence, they would never point to the same node. So eventually we will come out of this loop when they both hit null. And then we could return a NULL, to indicate that there is no merge point. The second corner case is, what if A was our linger list? Remember, Here we assumed that B is our longer list?So our code will fail is m is greater than n, and we need to handle it separately. What we could do is, simply swap both the lists. This is the code to swap any two things. What it is does is assigns the value of A to any temporary variable, updates the value of A so that it points to, this first node of the second linked list. And then update the value of B from temp to make it point to this node. I have reflected those changes in this code here. Ok. So what could be the time complexity of this function? Finding the, lengths take Big O of m and Big O of n time. This part of the code is done in order of 1 time. And this part of the code basically traverses both the linked lists. So basically it takes Big O of m plus n time. Therefore, the overall time complexity is Big O of m plus n while the overall space complexity is Big O of 1. Hence, we are able to reduce the time complexity from our previous approach without having any extra space. So this is all in this lesson to find the merge point of two linked lists. I hope you liked it. Thank you for watching.