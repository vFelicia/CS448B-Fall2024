In our previous lesson, we wrote some code for binary search tree we wrote functions to insert and search data in BST .Now in this lesson we will go a little deeper and try to understand how things move in various sections of applications memory. When these functions get executed and this will give you a lot of clarity and this will give you some general insight into how memory is managed for execution of a program and how recursion which is so frequently used in case of trees works. The concepts that I'm going to talk about in this lesson have been discussed earlier in some of our previous lessons, but it will be good to go through these concepts again when we are implementing trees. So, here's the code that he had written. We have this function GetNewNode() to create a new node in dynamic memory and then we have this function Insert() to insert a new node in the tree and then we have this function to search some data in the tree and finally this is the main function. You can check the description of this video for link to the source code. Now in main function here we have this pointer to BSTnode named root to store the address of the root note of my tree and am initially setting it as NULL to create an empty tree and then I'm making some calls to insert function to insert some data in the tree and finally I'm asking user to input a number and I'm making call to search function to find this number in the tree if the search function is returning me true I'm printing found, else I'am printing not found. Let's see what will happen in memory when this program will execute. The memory that is allocated to a program or application for its execution in a typical architecture can be divided into these four segments, there is one segment called text segment to store all the instructions in the program. The instructions would be compiled instructions in machine language. There is another segment to store all the global variables. A variable that is declared outside all the functions is called global variable. It is accessible to all the functions. The next segment stack is basically scratch space for function call execution, all the local variables the variables that are declared within functions live in stack. and finally the fourth section heap which we also called the free store, is the dynamic memory that can grow or shrink as per our need. the size of all other segments is fixed the size of all other segments is decided at compiletime but heap can grow during runtime and we cannot control allocation or deallocation of memory in any other segment during runtime but we can control allocation and deallocation in heap we have discussed all of this in detail in our lesson on dynamic memory allocation you can check the description for a link. Now what I'm going to do here is am going to draw stack and heap sections as these two rectangular containers. I'm kind of zooming into these two sections. Now I will show you how things will move in these two sections of application's memory when this program will execute. When this program will start execution first the main function will be called. Now whenever a function is called some amount of memory from the stack is allocated for its execution. The allocated memory is called stack frame of the function call. All the local variables and the state of execution of the function call would be stored in the stack frame of the function call. In the main function we have this local variable root which is pointer to BSTnode so I'm showing root here in this stack frame. We will execute instructions sequentially. In the first line in main function, we have declared root and we are initializing it and setting it as NULL. NULL is only a map macro for address Zero. So here in in this figure am setting address in root as 0. Now in the next line we are making a call to insert function so what will happen is execution of main will pause at this stage and a new stack frame will be allocated for execution of insert. Main will wait for this insert above to finish and return. Once this insert call finishes, main will resume at line 2. We have these two local variables root and data in insert function, in which we are collecting the arguments. Now for this call to insert function, we will go inside the first if condition here because root is NULL, at this line we will make call to GetNewNode function so once again execution of this insert call will pause and a new stack frame will be allocated for execution of GetNewNode function we have two local variables in GetNewNode data in which we are collecting argument and this pointer to BSTnode named newnode. Now in this function we are using new operator to create a BSTnode in heap. Now let's say we got a new node at address 200 new operator will return us this address 200 so this address will be set here in new node so we have this link here and now using this pointer newNode, we are setting value in these three fields of Node. Let's say the first field to store data so we are setting value 15 here and let's say this second cell is to store address of left child this is being set as NULL and address of right child is also being set as NULL and now GetNewNode() will return the address of new node and finish its execution. Whenever a function call finishes, the stack frame allocated to it is reclaimed. Call to insert function will resume at this line and the return of GetNewNode() address 200, will be set in this the root which is local variable for insert call and now insert function, this particular call to insert function return the address of root.The address stored in this variable root which is 200 now and finish and now main will resume at this line and root of main will be set as 200. The return of this insert call, insert(root, 15) will be set here. Now in the execution of main, control will go to the next line and we have this call to insert function to insert number 10. Once again execution of main will be paused and a stack frame will be allocated for execution of insert. Now this time for insert call root is not NULL. So we will not go inside to first if, now we will access the data field of this node at address 200 by using this pointer named root in insert function and we will compare it with this value 10. 10 is lesser than 15 so we will go to this line and now we're making a recursive call here because recursion is a function calling itself. and a function calling itself is not any different from a function A calling another function B so what will happen here is that execution of this particular insert call will be paused and a new stack frame will be allocated for the execution of this another insert call to which the arguments passed are address 0, in this local variable root, left child of Node at address 200 is NULL. so we are passing 0 and root and in data we are passing 10. Now for this particular insert call control will go inside first if and we will make a call to get new node function at this line so execution of this insert will pause and we'll go to GetNewNode() function here, we are creating a new node in heap. Let's say we got this new node at address 150. Now GetNewNode() will return 150 and finish execution of this call to insert will resume at this line, return of GetNewNode() will be set here and now this call to insert will return address 150 and finish. insert below will resume at this line and now in this insert call left child of this node at address 200 will be set as return of the previous insert call which is 150 so.. now these two node are linked and finally this insert call will finish. Control will return back to main at this line, root will be rewritten as 200 but earlier also it is was 200, it's not changing. Next in the main function may have caused to insert number 20. I'm not going to show the simulation for this one once again allocated memory in stack will grow and shrink and finally when the control will return back to main function after this insert call is over, we'll have a node in heap with value 20 set as right child of this node at 200. Let's say we got this new node with value 20 at address 300 so as you can see the address of right child in node at address 200 is set as 300. Now next one is to insert number 25 this one is interesting let's see what will happen for this one. Main will be paused and we will go to this call to insert, in the root which is local to this call address passed is 200 and we have passed number 25 In data.Now here 25 is greater than the value in this node at address 200 so we will go inside this last else condition we need to insert in the right subtree so another card insert will be made we will pass address 300 as root and data passed will be 25 only. Now for this call once again the value in node at 300 for this call which is 300 is lesser than 25. 25 is greater than 20 so once again we will come to this last else and make a recursive call to insert in the right subtree the right subtree is empty this time so for this insert call at top the address in root here will be 0 so for this call we will go to the first if and make a call to GetNewNode(). Let's say this new node returns us node at address 100. I'm short of space so I'm not showing everything in GetNewNode() stack frame here. we will return back to this insert call at top and now this root is set as 100 address of the newly created node and now this call to insert will finish. We will come back to this insert below and this insert will resume at this line inside the last else and the right child of node address 300 will be set as 100, and now this insert will return back to address 300, whatever is set in it's root and this insert below will resume at this line inside the last else right child of node at address 200 will be set as 300. It was 300 previously also so even after overwriting we will not change and this insert will finish now. Finally main will resume at this line, root of main will be set as return of this insert call. It will only be overwritten with same value. It's really important that this root in main and other links in nodes not properly updated quite often because of bugs in our code, will loose some links or some unwanted links are created. Now as you can see, we are creating all the notes in heap here. heap gives us this flexibility that we can decide the creation of node during runtime and we can control the lifetime of anything in heap any memory claimed in heap has to be explicitly deallocated using free in C or delete operator in C++ else the memory in heap remains allocated till the program is running. The memory in stack as you can see gets Deallocated when function call finishes. The rest of the function calls here in Main function will execute in similar manner I'll leave it for you to see and think about. Right now we have this tree in the heap, logically memory itself is a linear structure and this is how tree which is a nonlinear structure which is logically a nonlinear structure will fit in it. The way I'm showing the nodes at random locations linked to each other in this heap. I hope this explanation gave you some clarity. In coming lessons we will solve some problems on trees. This is it for this lesson thanks for watching.