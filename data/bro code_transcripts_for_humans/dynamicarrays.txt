With timestamps:

00:00 - what the heck is a dynamic array a
00:02 - dynamic array
00:03 - is an array with a resizable capacity if
00:06 - we need extra room for elements we can
00:08 - increase the capacity which we cannot
00:09 - normally do with
00:10 - a standard typical fixed size array
00:13 - dynamic arrays are also known as
00:15 - arraylist in java vectors in c plus plus
00:18 - arrays in javascript and list in python
00:21 - here's an example of a static array and
00:22 - then we'll take a look at a dynamic
00:24 - array a static array has a fixed
00:26 - capacity we determine that capacity at
00:28 - compile time and we can't change it
00:30 - later normally
00:31 - in this example i have a static array
00:33 - with a capacity of six elements
00:35 - and a size of five elements that are
00:37 - currently occupied
00:38 - the last element is open so it's null
00:40 - each element has a memory address
00:43 - obviously these are not real memory
00:44 - addresses but this is how i like to
00:46 - think about things
00:47 - imagine that all of these memory
00:48 - addresses are houses and they're all
00:50 - next to each other
00:50 - now accessing an element is easy because
00:52 - we have index numbers to work with we
00:54 - can randomly access an element in
00:56 - of one constant time the size of our
00:58 - data set doesn't matter
01:00 - however searching for a stored value
01:02 - still takes time because we need to
01:03 - begin at index zero
01:04 - and iterate over our array until we
01:06 - reach our value
01:07 - or the end in case we don't find it this
01:09 - is done in o of n
01:11 - linear time the larger the data set the
01:13 - time to finish will increase
01:14 - linearly and in the case of inserting or
01:17 - deleting
01:18 - that takes a linear time unless done at
01:20 - the end no shifting of elements is
01:21 - required
01:22 - however the closer we need to insert or
01:24 - delete to index
01:26 - 0 we need to shift all elements that
01:28 - follow in order to make room for
01:30 - insertion
01:30 - or close any gaps in the case of
01:32 - deletion so if i need to insert a value
01:35 - at let's say
01:35 - index 0 i have to shift all elements to
01:38 - the right by one
01:39 - to make room for this insertion
01:43 - and then we can insert a value now
01:45 - currently with our static array we're at
01:47 - capacity our array is full our size is
01:50 - equal to our capacity
01:51 - then in the case of deleting an element
01:53 - we need to shift all elements that
01:55 - follow after this index where we're
01:57 - making the deletion
01:58 - and shift everything once to the left so
02:00 - that would look like this
02:05 - and our size is back to five so there is
02:07 - one element that is open
02:08 - a major disadvantage of static arrays is
02:11 - that they have a fixed capacity we can't
02:13 - increase the capacity once the size of
02:15 - the elements reaches capacity
02:17 - in the separate example i have an array
02:19 - with a capacity of
02:21 - five elements and a size of five
02:22 - elements and it's completely full
02:24 - i can't decrease the capacity because
02:26 - the next memory block
02:27 - contains i don't know pictures of cats
02:29 - or something you do you i guess
02:31 - a dynamic array has its own inner static
02:34 - array with a fixed size
02:35 - once the inner static array of our
02:37 - dynamic array reaches capacity
02:40 - our dynamic array will declare and
02:42 - instantiate a newer ray
02:43 - with an increased capacity usually the
02:46 - amount that we increase the capacity by
02:48 - really varies depending on the
02:49 - programming language
02:50 - it's usually between 1.5 and 2. i just
02:53 - picked capacity times 2 for extra
02:55 - emphasis
02:55 - so what we'll do now is copy the
02:57 - elements over to our
02:59 - new array and these have different
03:01 - memory addresses than our original array
03:03 - so that would look something like this
03:08 - we now have a new array with double the
03:11 - capacity but like i said it really
03:12 - depends on the language that you're
03:14 - working with it's usually between 1.5
03:16 - and 2.
03:17 - this array has a size of five elements
03:19 - that are full
03:20 - and a total capacity of ten then if you
03:23 - need to shrink the capacity like if
03:25 - you're not using a lot of elements
03:26 - you can always just do the reverse
03:28 - process of what we did to increase it
03:30 - now with this new inner array the
03:33 - insertion and deletion of elements is
03:34 - really the same as a static array so you
03:36 - just shift all the elements to the right
03:38 - by one to insert a new element
03:40 - or shift all the elements to the left to
03:42 - delete an element
03:43 - what are some of the advantages of
03:45 - dynamic arrays one there is random axis
03:47 - of elements that is done in o of one
03:49 - constant time we can randomly access an
03:52 - element by an index number and retrieve
03:54 - the value
03:54 - two there is good locality of reference
03:57 - and data cache utilization
03:58 - because all of these memory addresses
04:00 - are contiguous
04:02 - they're right next to each other unlike
04:04 - with linked lists you have to jump
04:05 - around a lot because all of the memory
04:07 - addresses are kind of random
04:08 - and three it's easy to insert and delete
04:11 - elements at the end
04:12 - because there's no shifting of elements
04:13 - required and for the disadvantages a
04:16 - dynamic array
04:17 - wastes more memory than a linked list
04:19 - because we need to increase the capacity
04:22 - to accommodate more elements if we need
04:24 - the extra room
04:25 - and we may not necessarily need all of
04:27 - this extra room
04:28 - so a dynamic array wastes more memory
04:31 - than a linked list
04:32 - two shifting of elements is time
04:34 - consuming the closer we need to insert
04:37 - or delete
04:38 - closer to index zero we have to shift
04:40 - all elements that follow afterwards
04:42 - to the right in case of an insertion or
04:45 - to the left in case of a deletion
04:47 - and three expanding or shrinking the
04:49 - array is time consuming
04:51 - because we have to copy all of the
04:52 - elements over to a new array
04:54 - with a different capacity and that's the
04:56 - basics of a dynamic arrays
04:58 - let's create our own dynamic array for
05:00 - practice all right welcome back we're
05:02 - going to create our own dynamic array
05:04 - using java
05:05 - in the future if you ever do need a
05:07 - dynamic array you might as well just use
05:09 - an array list
05:10 - according to the description it's a
05:11 - resizable array implementation of the
05:14 - list
05:14 - interface and it's pre-built so you
05:16 - might as well use it i thought we would
05:17 - create our own dynamic array just for
05:19 - learning purposes and practice but let's
05:21 - take a look at the arraylist class
05:24 - within this class there are a few
05:25 - defined members there's a default
05:27 - capacity
05:28 - set to 10. there are overloaded
05:30 - constructors within this arraylist class
05:32 - we can set our own initial capacity or
05:35 - we can use the defaults by not passing
05:37 - in an initial capacity
05:39 - there is a size to keep track of how
05:41 - many elements are filled within
05:42 - our array list and our array list does
05:45 - have its own
05:46 - inner static fixed size array and if we
05:49 - ever need to expand
05:50 - the size of this array we just copied
05:52 - the elements over to a new
05:54 - inner array so let's begin let's create
05:57 - a new class named dynamic array
05:59 - and i'll get rid of this so file new
06:02 - class and this will be named dynamic
06:05 - array
06:07 - then finish okay let's declare a few
06:09 - members
06:10 - let's create int size int
06:13 - capacity this will be the initial
06:15 - capacity i'll set this to 10 but feel
06:17 - free to pick whatever value that you
06:18 - want
06:19 - as well as an array of objects named
06:22 - array
06:22 - i will declare this but not yet
06:24 - instantiate it so you can make these
06:26 - private
06:27 - however i think that'll make our code a
06:29 - little more complex and difficult to
06:31 - understand
06:31 - although it'd be more secure i'm just
06:33 - going to use the default visibility for
06:35 - these members here
06:37 - all right let's create some overloaded
06:38 - constructors so public
06:41 - dynamic array
06:44 - and within here we will instantiate a
06:47 - new fixed size array
06:49 - this dot array equals
06:53 - new array of objects
06:56 - with a capacity of whatever capacity the
06:59 - default is
07:00 - so it's going to be 10 by default and
07:02 - we'll create an overloaded constructor
07:04 - just in case the user passes in
07:06 - their own capacity that they would like
07:08 - to set so
07:09 - int capacity this
07:13 - dot capacity equals whatever capacity
07:16 - that we pass in
07:18 - okay let's instantiate a new dynamic ray
07:21 - dynamic make sure to spell it right
07:24 - dynamic
07:25 - array i'll call this dynamic array with
07:29 - a lowercase d
07:30 - equals new dynamic
07:34 - array so i'm not going to pass in
07:37 - an initial capacity and let's print
07:39 - whatever the capacity is of our dynamic
07:42 - array
07:42 - dynamic array dot capacity
07:46 - and this should be 10. okay now let's
07:48 - pass in maybe
07:50 - a capacity of five and this should be
07:52 - five
07:53 - yep cool so it seems like that works all
07:55 - right let's head back to our dynamic
07:57 - array
07:58 - and declare all of the methods that
07:59 - we'll need let's create an
08:01 - add method public void add
08:04 - and there will be one parameter of
08:06 - object
08:08 - data next method
08:11 - insert public
08:14 - void insert
08:17 - the two parameters are int
08:20 - index object data
08:24 - okay next method we have delete
08:28 - public void delete
08:32 - there is one parameter of object data
08:37 - then we have search public
08:40 - int we're going to return it index
08:43 - search
08:47 - and we will need object data
08:51 - and let's return negative one for now
08:54 - then we have private void
08:58 - grow to expand the size of our array
09:02 - private void shrink
09:08 - then we'll need an is empty method
09:10 - public
09:11 - we will return a boolean value is
09:16 - empty and we might as well fill this in
09:18 - right away because there's only one line
09:20 - return size is equal to zero
09:23 - if our size is anything but zero we will
09:26 - return false
09:28 - and lastly tostring
09:32 - public string to string
09:37 - and i need to type in something i'm just
09:38 - going to return null for the time being
09:40 - until we return something
09:42 - okay let's begin by filling in the add
09:45 - method
09:45 - first we'll want to check to see if
09:47 - we're at capacity
09:48 - if our size is greater than or equal to
09:52 - our capacity then we better call the
09:55 - grow method
09:56 - to expand the size of our array so if
09:59 - there is room we will take our array
10:02 - at index of size that should be the end
10:04 - of our array
10:06 - equals data then we will increase
10:09 - our size by one now let's head all the
10:12 - way down to the
10:13 - tostring method to display the elements
10:15 - of this array and we just need to
10:17 - iterate over these
10:18 - let's declare a local variable of string
10:21 - string string and i will set this equal
10:24 - to
10:24 - an empty string and we will fill in the
10:26 - elements when we iterate over it
10:28 - so let's iterate over the elements of
10:30 - our array so let's create a for loop
10:33 - for int i equals zero
10:37 - and then i will continue this for loop
10:39 - as long as i
10:40 - is less than our size you can do
10:43 - capacity too if you want to see the
10:45 - entire array but let's begin with size
10:47 - i is less than size and i will increment
10:50 - our index i by one so i'm going to
10:54 - take our string and append it string
10:57 - plus equals our array at
11:00 - index of i that's one i
11:04 - plus maybe i'll add a comma then a space
11:07 - then we should return our string string
11:10 - okay this isn't perfect yet but let's at
11:12 - least test it let's head back to our
11:14 - main java file
11:15 - and add a few elements to our array
11:17 - using the add method
11:19 - so let's use the default capacity of 10
11:21 - so we don't necessarily need to pass in
11:23 - anything
11:24 - so to add to our array we can use
11:26 - dynamic array
11:28 - dot and we declared an add method at the
11:31 - top
11:32 - so let's add maybe some letters i will
11:34 - add
11:35 - the letter a then b then c
11:39 - that should be good so a b
11:42 - and c and then let's call the tostring
11:46 - method
11:46 - system.out.printline and with the
11:48 - tostring method we only have to type in
11:51 - the name of what we would like to
11:53 - display the elements of
11:54 - so dynamic array and we don't
11:56 - necessarily need to type tostring
11:58 - so this should display a b and c
12:01 - now let's format this and clean it up a
12:03 - little bit like i would like to get rid
12:05 - of the last comma here
12:06 - and maybe enclose all of these elements
12:08 - within a set of square brackets
12:10 - so this is what we can do within the
12:12 - tostring method
12:14 - so after the for loop let's check to see
12:17 - if our string does not
12:20 - equal an empty string if that is the
12:23 - case
12:24 - if there are elements to display let's
12:26 - take our string
12:28 - then i'm going to create a substring and
12:30 - get rid of these last two characters
12:32 - the comma and the space so string equals
12:36 - string dot substring and the length is
12:39 - going to be
12:40 - beginning at index 0 and i will continue
12:43 - this
12:44 - until string dot length
12:47 - method minus 2. then after running this
12:50 - one more time
12:51 - the comment space at the end should no
12:53 - longer be there because we created a
12:55 - substring to end at the last element
12:57 - then let's enclose all of these elements
12:59 - within a set of square brackets
13:01 - so i'll use some string concatenation so
13:03 - i'll add
13:04 - a left square bracket
13:08 - and then at the end add a right square
13:10 - bracket
13:13 - and then these should be within square
13:16 - brackets now
13:17 - and that looks a lot better now what if
13:19 - our string
13:20 - is empty let's return it just a set of
13:23 - square brackets using an else statement
13:25 - else we will set our string
13:28 - equal to a set of
13:32 - square brackets and that's it so let's
13:34 - head back to our main java file
13:36 - and comment these lines of code out
13:38 - where we add elements to our dynamic
13:40 - array
13:42 - so let's run this and we should have an
13:44 - empty set of square brackets
13:45 - actually this would be a good
13:46 - opportunity to test our is empty method
13:49 - so let's check that
13:50 - so within a print line statement
13:53 - system.out.printline
13:54 - i will take my dynamic array and
13:57 - use the is empty method
14:01 - then i'm just going to use some string
14:02 - concatenation
14:04 - empty colon space plus dynamic array is
14:09 - empty method
14:10 - and our dynamic array is currently empty
14:12 - that is true
14:14 - then let's fill this with elements a b
14:16 - and c
14:18 - so this should iterate and display the
14:20 - elements of our array and let us know if
14:22 - our array
14:23 - is empty which is false since we're here
14:26 - let's display the size and the capacity
14:28 - of our array too
14:29 - so system.out.printline dynamic array
14:33 - dot size and i'll use some string
14:35 - concatenation here too
14:37 - so size colon space plus
14:40 - dynamic array dot size and the capacity
14:43 - as well
14:44 - so capacity plus
14:47 - dynamic array dot capacity
14:51 - so this dynamic array has a size of
14:54 - three
14:55 - three elements are filled in and a
14:57 - capacity of 10.
14:59 - for fun just to see the entire array
15:01 - let's go to the tostring method and
15:03 - change
15:03 - size to capacity so we can see all of
15:06 - the elements that are filled in and not
15:08 - filled in
15:08 - so after running this we can see our
15:11 - entire array at its full capacity
15:13 - so we have a size of three three
15:14 - elements are filled in but we have a
15:16 - total capacity of ten
15:17 - the rest of the elements are null so if
15:19 - we were to count all of these
15:21 - they should be ten so we have one two
15:23 - three four five
15:24 - six seven eight nine ten nice so you can
15:27 - change that back to
15:29 - size or you can keep it as capacity i'll
15:31 - just keep it as capacity for teaching
15:33 - purposes
15:34 - now let's fill in the insert method
15:36 - there's not a whole lot left to do
15:38 - first let's check to see if our size is
15:40 - greater than or equal to our capacity if
15:43 - so then we'll need to grow
15:44 - our array so size is greater than
15:47 - or equal to our capacity if that is the
15:51 - case
15:51 - call the grow method what we're going to
15:53 - do at this point is
15:54 - shift all of the elements that are
15:56 - filled in to the right in order to make
15:58 - room for the insertion
15:59 - so let's use a for loop and iterate over
16:02 - our filled elements in reverse order
16:04 - i will set into i our index equal
16:08 - to our size and then i will continue
16:11 - this as long as i
16:13 - is less than our index then decrement
16:17 - i by one so i'm going to take our array
16:21 - at i and set this equal to array
16:24 - at index of i minus one this will shift
16:28 - all of the elements over to the right to
16:30 - make room for the insertion
16:31 - so we will take our array
16:34 - at index equals whatever data we want to
16:37 - set
16:38 - then increase our size by one so then if
16:41 - we head back to our main java file
16:43 - we can insert a value at a given index
16:47 - so let's take our dynamic array dot use
16:50 - the insert method
16:52 - let's say at index 0 i would like to
16:54 - insert an
16:55 - x so let's try it cool we have
16:58 - x a b c the size is now 4 and the
17:01 - capacity is still 10.
17:02 - now let's work on the delete method
17:04 - within here we're going to iterate over
17:06 - the elements of our array beginning from
17:08 - left to right so this is fairly easy
17:10 - int i equals 0 we will continue this as
17:13 - long as i
17:14 - is less than our size and increment i by
17:17 - one after each iteration
17:19 - so during each iteration we will check
17:21 - to see if our array
17:23 - at index of i is equal to the
17:26 - data that we pass in as an argument so
17:29 - if that is the case we need to
17:31 - shift all of the elements to the left
17:33 - then so we'll need a nested for loop for
17:36 - that
17:36 - then we will need an index of j because
17:39 - i is already taken we're within a nested
17:41 - for loop
17:41 - int j equals zero and i will continue
17:45 - this nested for loop as long as j
17:48 - is less than our size minus i
17:52 - minus one and then we are going to
17:54 - increment
17:55 - our index j by one during each iteration
17:58 - so basically wherever we make the
18:00 - deletion we're going to shift all of the
18:02 - elements afterwards
18:03 - one spot to the left so we will take our
18:06 - array
18:07 - at index of i plus j
18:10 - and set the sequel to our array at index
18:14 - of i plus j the same as before but add
18:17 - plus one
18:17 - so that will target the next element
18:19 - that comes afterwards
18:21 - so after we escape this for loop we will
18:24 - take
18:25 - our array at index of size minus one
18:29 - and set the sequel to null
18:32 - and then we will decrement our size by
18:35 - one
18:36 - and actually here would be a good place
18:38 - to shrink our array so let's write an if
18:40 - statement
18:40 - and check to see if our size falls below
18:43 - a certain criteria
18:45 - so let's say that if our size is less
18:48 - than or equal to
18:49 - a third of the capacity so capacity
18:53 - divided by three we don't want to shrink
18:55 - too often just because
18:56 - that's time consuming and then you may
18:58 - want to cast this as an int because it
19:00 - may not divide evenly
19:02 - so if our size is underneath a third of
19:05 - the capacity
19:06 - let's call the shrink method and we will
19:08 - shrink
19:09 - our array by maybe half but we'll get to
19:11 - that later
19:12 - so then we want to break to escape this
19:15 - for loop then
19:16 - okay let's try this then so after making
19:19 - the insertion
19:20 - let's delete what about a so dynamic
19:23 - array
19:24 - dot delete and i do not need to pass in
19:28 - an index just the data that i'm looking
19:30 - for
19:31 - all right so a is no longer in here we
19:34 - have x
19:35 - b and c the size is three and the
19:36 - capacity is still ten
19:38 - all right i promise we're almost
19:39 - finished let's fill in the
19:41 - search method next and this one is
19:43 - fairly short so we just need to iterate
19:45 - over the elements of our array beginning
19:47 - at index zero
19:48 - four and i equals zero i will continue
19:52 - this as long as i
19:53 - is less than the size of our array
19:56 - increment
19:56 - i by one if our array
20:00 - at index of i is equal to the data that
20:04 - we're looking for the data that we pass
20:06 - in as an argument
20:07 - then we will return whatever i is
20:10 - our index if we do not find it we return
20:13 - negative one that's kind of like a
20:14 - sentinel value
20:15 - that means we did not find the value
20:17 - that we're looking for
20:19 - okay so let's search for maybe c
20:22 - dynamic array dot search
20:26 - and i will pass in the data that i'm
20:28 - looking for i am looking for c so that
20:31 - should be
20:32 - 0 1 2 assuming we insert and delete some
20:35 - values later
20:36 - and then i'm going to place this within
20:38 - a print line statement
20:40 - so dynamic ray dot search and i am
20:43 - searching
20:44 - for c and our result is that c
20:48 - is at index two zero one two
20:51 - all right we're near the end let's grow
20:53 - and shrink our ray
20:54 - and i'll turn these lines into comments
20:56 - now for the grow method we're going to
20:58 - instantiate a new array but we'll
21:00 - increase the capacity
21:02 - first int new capacity
21:06 - equals our old capacity which is just
21:09 - named capacity
21:10 - and let's say we want to increase the
21:12 - capacity by two
21:13 - and then i will just cast this as an end
21:16 - okay
21:17 - so after we create a new capacity we
21:19 - will instantiate a new array then we
21:21 - need to copy the elements over
21:23 - so we'll have an array of objects named
21:26 - new
21:27 - array equals new
21:30 - array of objects with a capacity of our
21:33 - new capacity and then we need to copy
21:37 - the elements over to our new array and
21:39 - that's kind of time consuming but
21:40 - necessary
21:42 - so we begin at index zero for int i
21:45 - equals zero we will continue this as
21:48 - long as i
21:49 - is less than our size and i will
21:52 - increment this
21:53 - by one after each iteration so we will
21:56 - take
21:56 - our new array at index of i
22:00 - and set this to our old array just named
22:03 - array
22:04 - at index of i and then
22:07 - we will change the capacity to whatever
22:10 - new capacity is then lastly we will set
22:14 - our array to equal our new array
22:18 - then let's test it so i'm going to
22:22 - maybe add a bunch of elements i'll keep
22:24 - that as a comment
22:26 - so let's change the capacity of our
22:28 - array to five i'll pass in five into the
22:30 - constructor
22:31 - so we have less elements to work with so
22:33 - the size is three and the capacity is
22:35 - five i'm going to add another element
22:38 - let's try d so size four capacity five
22:43 - let's add e
22:47 - okay so currently our array is full now
22:49 - let's try to
22:50 - increase the size past the capacity so i
22:53 - will add
22:54 - f and this should increase and grow the
22:57 - size of our array so we have
22:58 - a capacity of 10 now and we have a bunch
23:01 - of empty elements
23:02 - and lastly we just need to shrink this
23:04 - array and this next part is super simple
23:06 - for the shrink method copy everything
23:08 - from the grill method
23:10 - and paste it within the shrink method
23:12 - but change capacity at times to
23:15 - to capacity divided by two now we will
23:18 - call
23:18 - the shrink method automatically when the
23:21 - size
23:22 - falls below a third of the capacity that
23:24 - means we have a lot of wasted memory
23:26 - now let's begin deleting elements so i
23:29 - will type
23:30 - dynamic ray dot delete a then maybe b
23:35 - so when the size is a third of the
23:37 - capacity that's when it should shrink
23:39 - so we're not there yet let's delete
23:41 - maybe one or two more times
23:43 - so let's delete c
23:46 - and there we go so the size is three and
23:48 - the capacity is now five
23:50 - well all right that's a very basic
23:53 - dynamic array
23:54 - if you're using java instead of just
23:55 - building your own dynamic array you
23:57 - might as well just use an array list
23:58 - because it's more efficient and well
24:00 - it's already coded for you but i think
24:02 - this was good practice for us just to
24:04 - understand how dynamic arrays work
24:06 - so if you would like a copy of all this
24:08 - code of course i will post this to the
24:10 - comment section down below
24:11 - if you made it all the way to the end
24:13 - please give this video a thumbs up
24:14 - a random comment down below and well
24:16 - yeah those are dynamic arrays and well
24:19 - computer science

Cleaned transcript:

what the heck is a dynamic array a dynamic array is an array with a resizable capacity if we need extra room for elements we can increase the capacity which we cannot normally do with a standard typical fixed size array dynamic arrays are also known as arraylist in java vectors in c plus plus arrays in javascript and list in python here's an example of a static array and then we'll take a look at a dynamic array a static array has a fixed capacity we determine that capacity at compile time and we can't change it later normally in this example i have a static array with a capacity of six elements and a size of five elements that are currently occupied the last element is open so it's null each element has a memory address obviously these are not real memory addresses but this is how i like to think about things imagine that all of these memory addresses are houses and they're all next to each other now accessing an element is easy because we have index numbers to work with we can randomly access an element in of one constant time the size of our data set doesn't matter however searching for a stored value still takes time because we need to begin at index zero and iterate over our array until we reach our value or the end in case we don't find it this is done in o of n linear time the larger the data set the time to finish will increase linearly and in the case of inserting or deleting that takes a linear time unless done at the end no shifting of elements is required however the closer we need to insert or delete to index 0 we need to shift all elements that follow in order to make room for insertion or close any gaps in the case of deletion so if i need to insert a value at let's say index 0 i have to shift all elements to the right by one to make room for this insertion and then we can insert a value now currently with our static array we're at capacity our array is full our size is equal to our capacity then in the case of deleting an element we need to shift all elements that follow after this index where we're making the deletion and shift everything once to the left so that would look like this and our size is back to five so there is one element that is open a major disadvantage of static arrays is that they have a fixed capacity we can't increase the capacity once the size of the elements reaches capacity in the separate example i have an array with a capacity of five elements and a size of five elements and it's completely full i can't decrease the capacity because the next memory block contains i don't know pictures of cats or something you do you i guess a dynamic array has its own inner static array with a fixed size once the inner static array of our dynamic array reaches capacity our dynamic array will declare and instantiate a newer ray with an increased capacity usually the amount that we increase the capacity by really varies depending on the programming language it's usually between 1.5 and 2. i just picked capacity times 2 for extra emphasis so what we'll do now is copy the elements over to our new array and these have different memory addresses than our original array so that would look something like this we now have a new array with double the capacity but like i said it really depends on the language that you're working with it's usually between 1.5 and 2. this array has a size of five elements that are full and a total capacity of ten then if you need to shrink the capacity like if you're not using a lot of elements you can always just do the reverse process of what we did to increase it now with this new inner array the insertion and deletion of elements is really the same as a static array so you just shift all the elements to the right by one to insert a new element or shift all the elements to the left to delete an element what are some of the advantages of dynamic arrays one there is random axis of elements that is done in o of one constant time we can randomly access an element by an index number and retrieve the value two there is good locality of reference and data cache utilization because all of these memory addresses are contiguous they're right next to each other unlike with linked lists you have to jump around a lot because all of the memory addresses are kind of random and three it's easy to insert and delete elements at the end because there's no shifting of elements required and for the disadvantages a dynamic array wastes more memory than a linked list because we need to increase the capacity to accommodate more elements if we need the extra room and we may not necessarily need all of this extra room so a dynamic array wastes more memory than a linked list two shifting of elements is time consuming the closer we need to insert or delete closer to index zero we have to shift all elements that follow afterwards to the right in case of an insertion or to the left in case of a deletion and three expanding or shrinking the array is time consuming because we have to copy all of the elements over to a new array with a different capacity and that's the basics of a dynamic arrays let's create our own dynamic array for practice all right welcome back we're going to create our own dynamic array using java in the future if you ever do need a dynamic array you might as well just use an array list according to the description it's a resizable array implementation of the list interface and it's prebuilt so you might as well use it i thought we would create our own dynamic array just for learning purposes and practice but let's take a look at the arraylist class within this class there are a few defined members there's a default capacity set to 10. there are overloaded constructors within this arraylist class we can set our own initial capacity or we can use the defaults by not passing in an initial capacity there is a size to keep track of how many elements are filled within our array list and our array list does have its own inner static fixed size array and if we ever need to expand the size of this array we just copied the elements over to a new inner array so let's begin let's create a new class named dynamic array and i'll get rid of this so file new class and this will be named dynamic array then finish okay let's declare a few members let's create int size int capacity this will be the initial capacity i'll set this to 10 but feel free to pick whatever value that you want as well as an array of objects named array i will declare this but not yet instantiate it so you can make these private however i think that'll make our code a little more complex and difficult to understand although it'd be more secure i'm just going to use the default visibility for these members here all right let's create some overloaded constructors so public dynamic array and within here we will instantiate a new fixed size array this dot array equals new array of objects with a capacity of whatever capacity the default is so it's going to be 10 by default and we'll create an overloaded constructor just in case the user passes in their own capacity that they would like to set so int capacity this dot capacity equals whatever capacity that we pass in okay let's instantiate a new dynamic ray dynamic make sure to spell it right dynamic array i'll call this dynamic array with a lowercase d equals new dynamic array so i'm not going to pass in an initial capacity and let's print whatever the capacity is of our dynamic array dynamic array dot capacity and this should be 10. okay now let's pass in maybe a capacity of five and this should be five yep cool so it seems like that works all right let's head back to our dynamic array and declare all of the methods that we'll need let's create an add method public void add and there will be one parameter of object data next method insert public void insert the two parameters are int index object data okay next method we have delete public void delete there is one parameter of object data then we have search public int we're going to return it index search and we will need object data and let's return negative one for now then we have private void grow to expand the size of our array private void shrink then we'll need an is empty method public we will return a boolean value is empty and we might as well fill this in right away because there's only one line return size is equal to zero if our size is anything but zero we will return false and lastly tostring public string to string and i need to type in something i'm just going to return null for the time being until we return something okay let's begin by filling in the add method first we'll want to check to see if we're at capacity if our size is greater than or equal to our capacity then we better call the grow method to expand the size of our array so if there is room we will take our array at index of size that should be the end of our array equals data then we will increase our size by one now let's head all the way down to the tostring method to display the elements of this array and we just need to iterate over these let's declare a local variable of string string string and i will set this equal to an empty string and we will fill in the elements when we iterate over it so let's iterate over the elements of our array so let's create a for loop for int i equals zero and then i will continue this for loop as long as i is less than our size you can do capacity too if you want to see the entire array but let's begin with size i is less than size and i will increment our index i by one so i'm going to take our string and append it string plus equals our array at index of i that's one i plus maybe i'll add a comma then a space then we should return our string string okay this isn't perfect yet but let's at least test it let's head back to our main java file and add a few elements to our array using the add method so let's use the default capacity of 10 so we don't necessarily need to pass in anything so to add to our array we can use dynamic array dot and we declared an add method at the top so let's add maybe some letters i will add the letter a then b then c that should be good so a b and c and then let's call the tostring method system.out.printline and with the tostring method we only have to type in the name of what we would like to display the elements of so dynamic array and we don't necessarily need to type tostring so this should display a b and c now let's format this and clean it up a little bit like i would like to get rid of the last comma here and maybe enclose all of these elements within a set of square brackets so this is what we can do within the tostring method so after the for loop let's check to see if our string does not equal an empty string if that is the case if there are elements to display let's take our string then i'm going to create a substring and get rid of these last two characters the comma and the space so string equals string dot substring and the length is going to be beginning at index 0 and i will continue this until string dot length method minus 2. then after running this one more time the comment space at the end should no longer be there because we created a substring to end at the last element then let's enclose all of these elements within a set of square brackets so i'll use some string concatenation so i'll add a left square bracket and then at the end add a right square bracket and then these should be within square brackets now and that looks a lot better now what if our string is empty let's return it just a set of square brackets using an else statement else we will set our string equal to a set of square brackets and that's it so let's head back to our main java file and comment these lines of code out where we add elements to our dynamic array so let's run this and we should have an empty set of square brackets actually this would be a good opportunity to test our is empty method so let's check that so within a print line statement system.out.printline i will take my dynamic array and use the is empty method then i'm just going to use some string concatenation empty colon space plus dynamic array is empty method and our dynamic array is currently empty that is true then let's fill this with elements a b and c so this should iterate and display the elements of our array and let us know if our array is empty which is false since we're here let's display the size and the capacity of our array too so system.out.printline dynamic array dot size and i'll use some string concatenation here too so size colon space plus dynamic array dot size and the capacity as well so capacity plus dynamic array dot capacity so this dynamic array has a size of three three elements are filled in and a capacity of 10. for fun just to see the entire array let's go to the tostring method and change size to capacity so we can see all of the elements that are filled in and not filled in so after running this we can see our entire array at its full capacity so we have a size of three three elements are filled in but we have a total capacity of ten the rest of the elements are null so if we were to count all of these they should be ten so we have one two three four five six seven eight nine ten nice so you can change that back to size or you can keep it as capacity i'll just keep it as capacity for teaching purposes now let's fill in the insert method there's not a whole lot left to do first let's check to see if our size is greater than or equal to our capacity if so then we'll need to grow our array so size is greater than or equal to our capacity if that is the case call the grow method what we're going to do at this point is shift all of the elements that are filled in to the right in order to make room for the insertion so let's use a for loop and iterate over our filled elements in reverse order i will set into i our index equal to our size and then i will continue this as long as i is less than our index then decrement i by one so i'm going to take our array at i and set this equal to array at index of i minus one this will shift all of the elements over to the right to make room for the insertion so we will take our array at index equals whatever data we want to set then increase our size by one so then if we head back to our main java file we can insert a value at a given index so let's take our dynamic array dot use the insert method let's say at index 0 i would like to insert an x so let's try it cool we have x a b c the size is now 4 and the capacity is still 10. now let's work on the delete method within here we're going to iterate over the elements of our array beginning from left to right so this is fairly easy int i equals 0 we will continue this as long as i is less than our size and increment i by one after each iteration so during each iteration we will check to see if our array at index of i is equal to the data that we pass in as an argument so if that is the case we need to shift all of the elements to the left then so we'll need a nested for loop for that then we will need an index of j because i is already taken we're within a nested for loop int j equals zero and i will continue this nested for loop as long as j is less than our size minus i minus one and then we are going to increment our index j by one during each iteration so basically wherever we make the deletion we're going to shift all of the elements afterwards one spot to the left so we will take our array at index of i plus j and set the sequel to our array at index of i plus j the same as before but add plus one so that will target the next element that comes afterwards so after we escape this for loop we will take our array at index of size minus one and set the sequel to null and then we will decrement our size by one and actually here would be a good place to shrink our array so let's write an if statement and check to see if our size falls below a certain criteria so let's say that if our size is less than or equal to a third of the capacity so capacity divided by three we don't want to shrink too often just because that's time consuming and then you may want to cast this as an int because it may not divide evenly so if our size is underneath a third of the capacity let's call the shrink method and we will shrink our array by maybe half but we'll get to that later so then we want to break to escape this for loop then okay let's try this then so after making the insertion let's delete what about a so dynamic array dot delete and i do not need to pass in an index just the data that i'm looking for all right so a is no longer in here we have x b and c the size is three and the capacity is still ten all right i promise we're almost finished let's fill in the search method next and this one is fairly short so we just need to iterate over the elements of our array beginning at index zero four and i equals zero i will continue this as long as i is less than the size of our array increment i by one if our array at index of i is equal to the data that we're looking for the data that we pass in as an argument then we will return whatever i is our index if we do not find it we return negative one that's kind of like a sentinel value that means we did not find the value that we're looking for okay so let's search for maybe c dynamic array dot search and i will pass in the data that i'm looking for i am looking for c so that should be 0 1 2 assuming we insert and delete some values later and then i'm going to place this within a print line statement so dynamic ray dot search and i am searching for c and our result is that c is at index two zero one two all right we're near the end let's grow and shrink our ray and i'll turn these lines into comments now for the grow method we're going to instantiate a new array but we'll increase the capacity first int new capacity equals our old capacity which is just named capacity and let's say we want to increase the capacity by two and then i will just cast this as an end okay so after we create a new capacity we will instantiate a new array then we need to copy the elements over so we'll have an array of objects named new array equals new array of objects with a capacity of our new capacity and then we need to copy the elements over to our new array and that's kind of time consuming but necessary so we begin at index zero for int i equals zero we will continue this as long as i is less than our size and i will increment this by one after each iteration so we will take our new array at index of i and set this to our old array just named array at index of i and then we will change the capacity to whatever new capacity is then lastly we will set our array to equal our new array then let's test it so i'm going to maybe add a bunch of elements i'll keep that as a comment so let's change the capacity of our array to five i'll pass in five into the constructor so we have less elements to work with so the size is three and the capacity is five i'm going to add another element let's try d so size four capacity five let's add e okay so currently our array is full now let's try to increase the size past the capacity so i will add f and this should increase and grow the size of our array so we have a capacity of 10 now and we have a bunch of empty elements and lastly we just need to shrink this array and this next part is super simple for the shrink method copy everything from the grill method and paste it within the shrink method but change capacity at times to to capacity divided by two now we will call the shrink method automatically when the size falls below a third of the capacity that means we have a lot of wasted memory now let's begin deleting elements so i will type dynamic ray dot delete a then maybe b so when the size is a third of the capacity that's when it should shrink so we're not there yet let's delete maybe one or two more times so let's delete c and there we go so the size is three and the capacity is now five well all right that's a very basic dynamic array if you're using java instead of just building your own dynamic array you might as well just use an array list because it's more efficient and well it's already coded for you but i think this was good practice for us just to understand how dynamic arrays work so if you would like a copy of all this code of course i will post this to the comment section down below if you made it all the way to the end please give this video a thumbs up a random comment down below and well yeah those are dynamic arrays and well computer science
