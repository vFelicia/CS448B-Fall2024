With timestamps:

00:00 - hey everybody so we have finally made it
00:02 - to Python objectoriented Programming
00:05 - this is a very important topic in Python
00:08 - an object is a bundle of related
00:10 - attributes and methods attributes are
00:13 - similar to variables to describe what
00:15 - the object has so look around you right
00:18 - now you are surrounded by different Real
00:20 - World objects next to me I have a phone
00:23 - a cup and a book each of these objects
00:26 - can have different attributes to
00:28 - represent it for example
00:30 - an attribute of the phone next to me
00:32 - could be version number I could set that
00:34 - to be 13 is on could be another
00:37 - attribute is the phone powered on or not
00:39 - that could be true or false or even a
00:42 - price I have a cup next to me what
00:45 - liquid is within the cup in this case
00:47 - coffee what's the temperature of the cup
00:49 - is the cup empty is empty or even a book
00:53 - What's the title of the book that could
00:55 - be a string how many pages does the book
00:58 - have Pages could be another attribute
01:00 - now objects also have the capability to
01:03 - do things they have methods which are
01:06 - functions that belong to an object
01:09 - people mix up functions and methods all
01:11 - the time they're technically different
01:13 - even when teaching I tend to make that
01:15 - mistake calling a method a function and
01:17 - a function a method usually people know
01:19 - what you're referring to though a method
01:21 - is a function that belongs within an
01:23 - object what are some actions these
01:25 - objects can perform with a phone you can
01:29 - make a call or receive a call turn the
01:31 - phone on or turn the phone off those
01:34 - could all be functions with a cup you
01:36 - could fill the cup drink from the cup or
01:39 - empty the cup with a book you can open
01:41 - the book read the book and close the
01:44 - book an object is a bundle of related
01:48 - attributes and methods they can
01:50 - represent real world items to create
01:54 - many objects we'll need to utilize a
01:56 - Class A Class is a type of blueprint
01:59 - used to design the structure and layout
02:02 - of an object we need to design what our
02:05 - objects have their attributes and what
02:08 - they can do their methods we will create
02:11 - a class of car we will create some car
02:14 - objects class
02:18 - car to construct a car object we need a
02:21 - special type of method called a
02:23 - Constructor it works similarly to a
02:25 - function we will Define a function
02:30 - of double underscore init meaning
02:33 - initialize double underscore again and
02:36 - then follow this with a set of
02:37 - parentheses this is our Constructor
02:40 - method we need this method in order to
02:42 - construct objects it's a Dunder method
02:45 - Dunder meaning double underscore that's
02:47 - a future topic I don't want you to be
02:50 - overloaded with information right now
02:52 - all you need to know is that we need
02:53 - this method in order to create objects
02:56 - this method behaves similar to a
02:58 - function we need to set up the
03:00 - parameters self is already provided to
03:03 - us self means this object we're creating
03:06 - right now this car so what are some
03:09 - attributes that a car should have a
03:12 - model that could be a string like a
03:16 - BMW a year that could be a
03:19 - number a
03:21 - color let's add a Boolean of for sale is
03:26 - the car for sale or not that's true or
03:29 - false
03:30 - to assign these attributes we're going
03:32 - to access self self dot the name of the
03:36 - attribute self. model equals the model
03:41 - we
03:42 - receive these are parameters when we
03:45 - receive the name of a model we will
03:47 - assign it to this object let's do this
03:50 - with year self. year equals year self.
03:56 - color equals color self
04:00 - do for sale equals for sale this is an
04:05 - example of a few attributes that a car
04:07 - might have a model year color and if
04:10 - it's for sale or not represented by a
04:13 - Boolean now to construct a car object we
04:15 - need a unique name for this car let's
04:18 - just say car one car one equals take the
04:23 - name of the class add a set of
04:25 - parentheses to invoke The Constructor
04:29 - we're going to do this this almost
04:30 - exactly like a function we have
04:32 - parameter set up we need to send a
04:34 - matching number of arguments self is
04:37 - provided to us behind the scenes
04:39 - automatically we need a model year color
04:42 - and if it's for sale or not so pick a
04:45 - car of you're choosing I'll pick my
04:47 - favorite
04:48 - car the model will be a Mustang for the
04:51 - year I'll go with the recent year of
04:54 - 2024 a color I'll pick red is the car
04:59 - for sale
05:00 - I like this car so no I will set that to
05:02 - be false make sure false is
05:05 - capitalized let's see what happens if I
05:08 - attempt to print our car object of car
05:13 - one what we're given is the memory
05:16 - address of this car object where it's
05:19 - located but I would like one of the
05:21 - attributes located at this memory
05:24 - address instead of printing the object
05:26 - itself we're going to access one of the
05:28 - attributes found within this car we will
05:31 - follow the name of the car with a DOT
05:35 - this dot it's known as the attribute
05:37 - access operator I would like the model
05:41 - of car
05:42 - one that would give me
05:45 - Mustang let's access the year take the
05:48 - name of the car car 1 dot the year
05:53 - 2024 followed by the color car1 docolor
06:01 - red car one is it for sale we'll print
06:07 - that that is
06:09 - false now let's create a second car
06:12 - we're going to reuse this class to
06:14 - create a second car we will create Car 2
06:18 - equals car we'll pass in some different
06:21 - arguments a Corvette the year will be
06:25 - 2025 the color will be blue is this car
06:29 - for sale let's say that is
06:32 - true instead of accessing car 1's
06:34 - attributes let's access car 2's
06:38 - attributes that would give us a Corvette
06:41 - the year is 2025 the color is blue for
06:45 - sale is set to
06:46 - true or even a third car car 3 equals a
06:52 - new car we will pass in a
06:55 - string of charger the year 2026
07:00 - the color will be yellow is this car for
07:03 - sale let's say that is true as well then
07:06 - I will print car 3's
07:12 - attributes the model is charger the year
07:14 - is 2026 the color is yellow for sale is
07:18 - set to True with classes they can take
07:21 - up a lot of space for better
07:23 - organization you can place them within a
07:25 - new python file so let's cut our class
07:31 - and we will create a new python file
07:33 - within our project folder file new
07:37 - python file the name of this python file
07:40 - is going to be all lowercase
07:44 - car then we will paste the class that we
07:48 - cut
07:49 - originally class car which has a capital
07:53 - c so from our main python file we're
07:56 - going to import our car file our car
07:59 - module
08:00 - modle from the name of the module car
08:04 - import the name of the class car then
08:07 - when I run this program nothing should
08:09 - change we should still have access to
08:11 - all of our car
08:14 - objects you could either keep your
08:16 - classes within your main python file or
08:19 - import them if you would like to
08:20 - organize things let's talk about methods
08:23 - methods are actions that our objects can
08:26 - perform within our class we will Define
08:28 - a method
08:30 - of Drive self is going to be provided to
08:34 - us when we invoke the drive function
08:36 - let's
08:37 - print you drive the car what other
08:42 - things can cars do let's
08:46 - stop we will
08:50 - print you stop the
08:55 - car let's take car one access the drive
09:01 - method you drive the car car 2 also has
09:05 - a drive method you drive the car same
09:08 - thing with car 3 you drive the car let's
09:12 - access the stop
09:14 - method car one.
09:18 - stop car 2.
09:21 - stop and car 3.
09:24 - stop these methods are identical for
09:27 - each car object instead of printing the
09:30 - word car let's insert the model of the
09:33 - car I will convert these print
09:35 - statements to F
09:38 - strings instead of the word car let's
09:40 - add a
09:41 - placeholder let's add
09:43 - self.
09:45 - model self is referring to the object
09:48 - we're currently working with use the
09:51 - attribute axis operator followed by the
09:53 - name of the attribute let's also do this
09:56 - with the stop method self
10:00 - do
10:03 - model let's take car one use the drive
10:07 - method you drive the Mustang car
10:11 - one.
10:14 - stop you drive the Mustang you stop the
10:17 - Mustang let's do this with Car
10:19 - 2 you drive the Corvette you stop the
10:23 - Corvette car
10:25 - three you drive the charger you stop the
10:28 - charger
10:30 - now within our F strings let's also
10:32 - insert let's insert the
10:35 - color I'll add a placeholder self. color
10:40 - do this with stop as
10:42 - well
10:44 - self.
10:47 - color you drive the yellow charger you
10:50 - stop the yellow charger car one you
10:54 - drive the red Mustang you stop the red
10:56 - Mustang card two you Drive the blue
10:59 - Corvette you stop the blue Corvette
11:02 - let's add one last
11:04 - method let's create a method to describe
11:07 - our car we'll print the details of the
11:10 - car let's print I'll use an F
11:14 - string add three
11:17 - placeholders let's print self
11:22 - doye followed by self.
11:25 - color then self. model
11:31 - we'll take car 1 use the describe method
11:34 - that we
11:35 - created describe car 1 car 1 is a 2024
11:41 - red Mustang describe Car 2 Car 2 is a
11:46 - 2025 blue Corvette car 3 is a 2026
11:51 - yellow charger all right everybody so
11:54 - those are objects in Python an object is
11:57 - a bundle of related attrib attributes
12:00 - attributes are variables that an object
12:02 - has and methods methods are functions
12:07 - that belong to an object they Define
12:09 - what this object can do and well
12:12 - everybody that is a summary of
12:14 - object-oriented programming using python
12:17 - hey everybody today I got to talk about
12:19 - class variables in Python class
12:21 - variables are shared among all instances
12:25 - meaning objects created from a class
12:28 - instance variables are defined inside of
12:30 - the Constructor class variables are
12:32 - defined outside of the Constructor with
12:35 - class variables they allow you to share
12:37 - data among all objects created from the
12:40 - class with instance variables each
12:43 - object has their own version with a
12:45 - class variable all those objects share
12:48 - one variable here's an example we will
12:51 - create a class of
12:54 - student we also need a
12:56 - Constructor when we create a student
12:58 - object object this Constructor is
13:00 - automatically going to be called but we
13:02 - need to pass in some arguments we are
13:05 - provided with self self refers to the
13:08 - object we're currently working with we
13:10 - will set up a name parameter and an age
13:13 - parameter we will assign self the object
13:17 - we're currently working with set the
13:19 - name attribute to equal the data for the
13:22 - name that we receive from this parameter
13:25 - and self. AG equals age
13:29 - let's construct two student objects we
13:32 - will have student one equals then call
13:36 - the Constructor for
13:38 - student so type the name of the class
13:40 - followed by a set of parentheses to
13:42 - invoke it this will automatically call
13:44 - The Constructor but we have to pass in
13:46 - data for the name and the age for the
13:49 - name let's pass in SpongeBob because
13:52 - basically everybody in the world knows
13:53 - who SpongeBob is I don't know how old
13:56 - SpongeBob is we'll say he's 30 we will
13:59 - create another student object which we
14:01 - will refer to as student 2 we will call
14:04 - the Constructor of our student class
14:07 - pass in data for the name and age
14:10 - student two will be Patrick Patrick will
14:13 - be
14:14 - 35 okay let's make sure this works let's
14:18 - print student
14:20 - 1's name followed by student 1's
14:27 - age and we should get SpongeBob and his
14:31 - age is 30 let's print student 2's name
14:34 - and student 2's age Patrick Patrick is
14:38 - 35 now we'll create a class variable
14:41 - class variables are defined outside the
14:43 - Constructor and they are shared among
14:46 - all objects created from that class each
14:49 - object has their own name and age
14:51 - property these are instance variables
14:54 - but class variables are defined outside
14:56 - the Constructor each object will share
14:59 - this one variable so if we're working
15:02 - with students let's say there is a class
15:07 - variable of class year what is the
15:11 - graduating year of this
15:13 - class
15:15 - 2024 now let's print student 1's
15:19 - graduating
15:21 - year print student
15:24 - one.
15:26 - class year
15:32 - okay so SpongeBob has a class year of
15:35 - 2024 that's when he's graduating let's
15:38 - check student
15:42 - two Patrick is ages 35 his graduating
15:46 - class year is
15:48 - 2024 now with class variables you can
15:52 - access them through any one object such
15:54 - as student one or student 2 it's good
15:57 - practice to access a class variable by
15:59 - the name of the class rather than any
16:02 - object created from the class since
16:04 - we're accessing class year we'll access
16:07 - this class variable by the name of the
16:09 - class of student make sure the S is
16:14 - capital this helps with Clarity and
16:17 - readability if I was looking at this
16:19 - print statement I can tell that class
16:21 - year is a class variable because we're
16:24 - accessing it directly from the class and
16:26 - not any instance from this class
16:29 - without looking at this class I can't
16:31 - tell if class year is an instance
16:34 - variable or a class variable but if I
16:36 - access it via the class name it's more
16:39 - explicit so it's good practice to access
16:42 - a class variable by the class name
16:44 - itself and not any one instance of this
16:47 - class let's create another class
16:51 - variable we'll create a class variable
16:53 - to keep track of how many students we
16:55 - have created this class variable will be
16:58 - num students meaning number of students
17:02 - equals zero So within our Constructor we
17:05 - can write any code that we want this
17:08 - code will always be executed when we
17:10 - instantiate an object I would like to
17:13 - take our number of students and
17:15 - increment it by one each time we
17:17 - construct a new student object so
17:19 - instead of using self self refers to the
17:22 - object we're currently working with if
17:24 - we're constructing student one just
17:26 - imagine we're replacing self with
17:28 - student one or student 2 if we were
17:31 - constructing student two if we're going
17:34 - to be modifying a class variable in
17:36 - place of self we'll use the name of the
17:39 - class student access our class of
17:42 - student get the class variable of number
17:45 - of students then I will increment it by
17:48 - one plus equals
17:51 - 1 we are constructing two student
17:55 - objects I will
17:57 - print X access our class of
18:00 - student get the number of students and
18:03 - print it we're constructing two student
18:06 - objects if I print the number of
18:08 - students that we have it should be two
18:11 - then just to be sure that this is
18:13 - working let's construct a third student
18:15 - object student 3 equals student this
18:20 - student will have a name of Squidward
18:23 - Squidward's age will be
18:26 - 55 now we have three
18:29 - students and for good measure let's
18:31 - construct one
18:33 - more student 4 equals we will create a
18:38 - new student with a name of Sandy sy's
18:42 - age will be
18:44 - 27 the number of students is now four
18:47 - just as an
18:49 - exercise using an F string let's print
18:52 - the student classes class year as well
18:55 - as the number of
18:56 - students I will print use an F string my
19:03 - graduating
19:04 - class of let's add a
19:08 - placeholder access the class of
19:11 - student then access the class
19:14 - Year my graduating class of
19:19 - 2024 has then we need the number of
19:22 - students We'll add a
19:23 - placeholder access the class of
19:26 - student access the number of of
19:29 - students has
19:31 - blank
19:34 - students let's see if this works my
19:37 - graduating class of 2024 has four
19:40 - students now if I were to change 2024 to
19:44 - 2025 my graduating class of 2025 has
19:48 - four
19:49 - students let's print the name of each
19:52 - student these are instance variables
19:55 - student one. name
20:00 - then we need Student two three and
20:05 - four my graduating class of 2025 has
20:09 - four students SpongeBob Patrick
20:11 - Squidward Sandy all right everybody so
20:14 - those are class variables class
20:16 - variables are shared among all instances
20:19 - of a class they are defined outside of
20:22 - the Constructor the benefit is that they
20:24 - allow you to share data among all
20:26 - objects created from that class
20:29 - and well everybody those are class
20:30 - variables in
20:32 - Python what is going on everybody so
20:35 - today I got to talk about inheritance in
20:37 - Python inheritance allows a class to
20:40 - inherit the attributes and methods from
20:42 - another class much like how a child in
20:45 - real life can inherit traits from A
20:47 - parent by having a class inherit
20:49 - attributes and methods from another
20:51 - class this helps with code reusability
20:54 - and extensibility in this example we're
20:56 - going to create an animal class the dog
20:59 - cat and mouse class will inherit
21:01 - attributes and methods from the animal
21:03 - class we will create a class of
21:07 - animal then I will Define The
21:12 - Constructor when we construct an animal
21:14 - object let's pass in a name it's not
21:18 - required but it might be good for this
21:20 - example we will assign the attribute of
21:23 - name equal to the name we
21:25 - receive let's also add an attribute of
21:28 - of is alive whenever we create an animal
21:32 - we will set there is alive attribute to
21:34 - be true and that is a capital
21:38 - T all animals can eat Define eat we will
21:43 - print using an F string add a
21:47 - placeholder self. name the name of this
21:50 - animal is eating all animals should be
21:54 - able to sleep Define sleep
21:59 - print I'll use an FST string insert
22:03 - self. name is sleeping and that is all
22:08 - we need for the animal class let's
22:11 - define class dog for a child class to
22:15 - inherit the attributes and methods from
22:17 - another class after the class name
22:19 - that's going to inherit we need to add
22:22 - an inheritance list with the set of
22:24 - parentheses then list the name of the
22:26 - class we're inheriting from the parent
22:28 - parent the dog class is going to inherit
22:31 - all of the attributes and methods of its
22:33 - parent
22:35 - animal for the time being as a
22:37 - placeholder I'll add pass just to
22:39 - demonstrate this class cat is also going
22:43 - to inherit from
22:47 - animal and class Mouse will also inherit
22:51 - from
22:54 - animal okay I will collapse this for now
22:57 - we'll create a dog object dog equals dog
23:01 - then pass it a name for this dog because
23:03 - we have one parameter set up of
23:06 - name this dog will be
23:08 - named Scooby as in
23:12 - Scooby-Doo cat equals call the cat
23:18 - Constructor this cat will be named
23:21 - Garfield and
23:23 - mouse mouse equals Mouse our Mouse will
23:27 - have a name of
23:29 - Mickey even though there's nothing
23:31 - within this dog cat or Mouse class we
23:34 - should still have these attributes and
23:36 - these methods if you inherit the animal
23:39 - class you should have a name attribute
23:41 - and is alive attribute set to true you
23:44 - can eat and you can sleep let's print
23:47 - our dog's name dog.
23:51 - name
23:54 - Scooby print dog. is
24:00 - alive our dog is alive that is
24:03 - true let's have our dog object use the
24:06 - eat
24:08 - method Scooby is eating and sleep dog
24:12 - dos
24:13 - sleep Scooby is sleeping let's replace
24:17 - dog with
24:21 - cat the name of the cat is Garfield
24:24 - Garfield is alive Garfield is eating
24:26 - Garfield is sleeping and
24:29 - Mouse replace any instance of cat with
24:32 - mouse our mouse's name is Mickey Mickey
24:35 - is alive Mickey is eating Mickey is
24:38 - sleeping even though these children
24:40 - classes are empty we're still inheriting
24:43 - these attributes and methods from its
24:44 - parent of animal this is convenient
24:47 - because you don't need to copy and paste
24:50 - these attributes and methods for every
24:51 - single class for example if I were to
24:54 - copy these attributes and methods and
24:56 - paste them
25:00 - well we have a lot more code to write
25:02 - and as a consequence if I need to make a
25:04 - change to one of these methods I would
25:06 - have to do that to every single instance
25:08 - of this method for example let's replace
25:11 - is sleeping with is asleep well now I
25:15 - need to find every single Sleep Method
25:17 - and change it
25:23 - manually it's not too bad if you only
25:25 - have a few classes but imagine if you
25:27 - have hundreds of classes
25:29 - that's going to take a lot of work it's
25:31 - a lot easier to write the code once and
25:33 - then reuse it and I only need to make
25:35 - that change in one place rather than
25:38 - make that change many times so let's
25:40 - change is sleeping to is asleep and see
25:43 - if that works
25:46 - again Mickey is
25:48 - asleep let's replace Mouse with
25:53 - dog Scooby is asleep not only that but
25:57 - with children classes they can have
25:59 - their own attributes and methods that
26:01 - are different from one
26:02 - another so dogs have all these
26:04 - attributes and methods and they can
26:08 - speak let's create a speak method and I
26:11 - will print a unique message for dogs
26:14 - woof cats will also have a speak method
26:17 - but it's going to be
26:19 - different cats will
26:24 - meow then for our Mouse class they will
26:27 - squeak
26:32 - let's have our dog
26:37 - speak woof let's have our cat
26:41 - speak meow and our
26:44 - Mouse
26:45 - squeak all right everybody so that's an
26:47 - introduction to inheritance inheritance
26:50 - allows a class to inherit attributes and
26:53 - methods from another class much like in
26:56 - real life a child can inherit TR trates
26:58 - from a parent these are also known as
27:01 - sub and super classes which is a topic
27:05 - for another day inheritance helps with
27:07 - code reusability and extensibility if
27:10 - all of these children classes inherit
27:12 - these attributes and methods from
27:13 - another class we only need to write that
27:16 - code once and not copy it for every
27:18 - single class that needs it we can write
27:21 - and change the code in one place for
27:23 - better reusability and extensibility and
27:25 - well everybody that is an introduction
27:27 - to inheritance in Python hey everybody
27:30 - so today we got to talk about both
27:32 - multiple and multi-level inheritance
27:34 - we'll begin with multiple inheritance
27:37 - that's when a child class inherits from
27:39 - more than one parent class for example a
27:42 - class of C can inherit the traits from
27:45 - both class A and B in Python you can
27:48 - have more than one parent multi-level
27:51 - inheritance we'll talk about near the
27:52 - end of this topic so in this example
27:55 - we're going to create two parent classes
27:57 - prey
27:59 - I'll write pass for
28:01 - now and
28:06 - Predator we'll create a class of
28:10 - rabbit a class of
28:15 - Hawk then class
28:21 - fish rabbit Hawk and fish are going to
28:24 - be children classes prey and predator
28:28 - will be parents if one of these classes
28:30 - rabbit hawk or fish inherit from prey
28:33 - they get the ability to flee we will
28:36 - Define a method of flee all we'll do in
28:40 - this example is print the following
28:43 - text this animal is fleeing if you're a
28:48 - predator you get the method to hunt
28:51 - Define
28:53 - hunt we will
28:56 - print this animal is
29:01 - hunting rabbits they will inherit from
29:04 - the prey class they're typically not
29:06 - Predators except that one rabbit and
29:08 - montypython and the Holy Grail that's
29:10 - the exception rabbit will inherit the
29:13 - prey class then it gets access to a flea
29:16 - method Hawks are predators they will
29:19 - inherit the Predator class now fish they
29:23 - will hunt smaller fish and flee from
29:26 - bigger fish you could consider fish both
29:29 - prey and predators so they will inherit
29:32 - both classes we will use multiple
29:35 - inheritance they will inherit everything
29:37 - from the prey class and the Predator
29:40 - class now let's see if this does in fact
29:42 - work now we'll create a rabbit object
29:44 - rabbit equals rabbit there are no
29:47 - parameter setup we don't need to send
29:48 - any arguments to the
29:50 - Constructor Hawk equals
29:53 - Hawk and fish equals
29:56 - fish so so let's take our rabbit object
29:59 - and they should have a flea method
30:01 - rabbit. flea method this animal is
30:04 - fleeing but they do not have a hunt
30:06 - method because they're not
30:09 - Predators rabbit object has no attribute
30:12 - hunt Hawks can
30:14 - hunt they Predators they inherited that
30:18 - method this animal is hunting but they
30:21 - can't flee they're not prey Hawk object
30:24 - has no attribute flea fish can do both
30:28 - they inherit from the prey class and the
30:30 - Predator
30:32 - class fish. flee this animal is fleeing
30:36 - fish.
30:38 - hunt this animal is hunting children
30:41 - classes can inherit from more than one
30:43 - parent which is what we did for fish
30:46 - they are both prey and predators whereas
30:49 - in rabbits are just prey Hawks are just
30:51 - Predators if you need to inherit from
30:53 - more than one parent you just add that
30:56 - additional class to The Inheritance
30:58 - list with multi-level inheritance a
31:02 - parent can inherit from another parent
31:05 - we will create a
31:06 - class of
31:08 - animal and for now I'll write pass prey
31:12 - and Predator are going to inherit from
31:14 - the animal class so we need to add
31:16 - animal to each inheritance
31:20 - list let's say if you're an animal you
31:23 - get a method to eat all animals will eat
31:29 - print this animal is eating and you can
31:34 - sleep Define
31:37 - sleep
31:39 - print this animal is
31:44 - sleeping so think of rabbit Hawk and
31:47 - fish as children classes prey and
31:51 - Predator are those class's parents and
31:54 - animal is the grandparent pray and
31:57 - Predator will inherit everything that
31:59 - the animal class has rabbit Hawk and
32:02 - fish will inherit everything the prey
32:04 - and Predator classes have so now our
32:07 - rabbit Hawk and fish classes should have
32:10 - the ability to eat and sleep and we'll
32:12 - test that rabbit.
32:15 - eat this animal is eating rabbit.
32:19 - sleep this animal is sleeping let's
32:22 - check out fish fish. eat this animal is
32:27 - eating fish do
32:29 - sleep this animal is
32:32 - sleeping okay we're going to expand upon
32:34 - our example a little bit let me zoom out
32:38 - each of our objects is going to have a
32:40 - name our rabbit will have a first name
32:43 - of bugs Hawk will be Tony as in Tony
32:47 - Hawk our fish will be
32:51 - Nemo within our classes we don't have
32:53 - any Constructor set up in which class
32:56 - should we assign the name
32:59 - attribute let's do so within our animal
33:02 - class so we will Define a
33:06 - Constructor to assign these
33:08 - attributes we will receive a
33:11 - name we'll assign self. name equals name
33:17 - now with these other classes if you're
33:19 - not assigning any attributes or if you
33:21 - don't need any other initialization
33:23 - logic you don't need a Constructor we'll
33:26 - implicitly use the Constructor RoR we
33:28 - inherit from the
33:29 - parent let's convert each of these print
33:32 - statements to an F
33:36 - string replace animal with
33:39 - self.
33:49 - name now let's have our rabbit use the E
33:55 - method oh we should get rid of this
34:02 - there we go bugs is eating rabbit. sleep
34:08 - bugs is sleeping rabbit.
34:11 - flee bugs is fleeing let's check out our
34:14 - Hawk Hawks don't have a flea method
34:17 - because they're Predators not
34:21 - prey let's eat Tony is eating let's
34:25 - sleep Tony is sleeping
34:28 - let's
34:29 - hunt Tony is hunting let's check our
34:33 - fish next our fish can eat Nemo is
34:36 - eating our fish can
34:38 - sleep Nemo is sleeping they can
34:42 - flee Nemo is fleeing and
34:46 - Hunt Nemo is
34:48 - hunting okay everybody that is both
34:50 - multiple and multi-level
34:52 - inheritance with multiple inheritance a
34:56 - child can inherit from more than one
34:58 - parent class you just add each
35:00 - additional class to The Inheritance list
35:03 - with multi-level inheritance a child can
35:06 - inherit from a parent which inherits
35:09 - from another parent Class C can inherit
35:12 - from B where Class B inherits from a
35:16 - think of C as the child b as the parent
35:18 - and a as the grandparent c will have all
35:21 - the attributes and methods even
35:23 - available within the grandparent class
35:25 - of a and well everybody that that is
35:27 - both multiple and multi-level
35:29 - inheritance in Python hey everyone
35:32 - welcome back so today I got to talk
35:34 - about abstract classes in Python an
35:37 - abstract class is a class that cannot be
35:40 - instantiated on its own abstract classes
35:43 - are meant to be subclassed they're
35:45 - supposed to be parents to children
35:47 - classes they can contain abstract
35:49 - methods which are declared but have no
35:52 - implementation abstract classes have a
35:55 - few benefits we can't create an object
35:57 - from a class that's abstract abstract
36:00 - classes you could say are incomplete we
36:02 - don't want to create an object that's
36:04 - incomplete also any children that
36:07 - inherit from an abstract class if
36:09 - there's any abstract methods we have to
36:11 - implement them so let me give you a
36:13 - demonstration we're going to create a
36:15 - Class A vehicle for now I'll write pass
36:20 - to work with abstract classes we'll need
36:22 - to import
36:24 - ABC ABC meaning abstract base
36:28 - classes we need import ABC all capital
36:33 - meaning abstract Base
36:36 - Class as well as abstract
36:40 - method so my vehicle class it's going to
36:43 - be an abstract class we will inherit
36:46 - from ABC the abstract based class I
36:50 - don't want myself or any other
36:51 - developers to be able to create a
36:53 - vehicle object I will make this vehicle
36:56 - an abstract class also I can add some
36:58 - abstract methods these methods will be
37:01 - inherited by its
37:03 - children to declare an abstract method
37:05 - we need to use a decorator at abstract
37:11 - method so what should all vehicles be
37:14 - able to do let's say go and stop if
37:17 - you're a vehicle you can
37:21 - go with abstract methods we declare them
37:24 - but we don't Define them we'll Define
37:26 - them within each of the children
37:27 - children classes that inherit from
37:29 - vehicle let's create another abstract
37:32 - method abstract method Define
37:38 - stop if you're a vehicle you can stop
37:41 - all right we have finished our abstract
37:43 - class A vehicle just to demonstrate that
37:46 - we can instantiate an object from this
37:48 - class let's attempt to do so and see
37:50 - what happens I will attempt to create a
37:52 - vehicle object vehicle equals
37:55 - vehicle and then run this
37:59 - type error can instantiate abstract
38:01 - class vehicle with abstract methods go
38:04 - and stop this is good this is what we
38:06 - want our vehicle class is incomplete we
38:09 - don't want to accidentally make a
38:10 - vehicle object if we were it's kind of
38:12 - like the invisible boatmobile from
38:14 - SpongeBob instead we will create some
38:17 - children to inherit from this class so
38:20 - now we will create a class of car which
38:24 - will inherit from vehicle car is the
38:27 - child vehicle is the parent but we are
38:30 - receiving a warning Class Car must
38:33 - Implement all abstract methods what
38:35 - we're saying is hey if you inherit from
38:38 - the vehicle class you need to include
38:40 - these abstract methods so I'm not going
38:42 - to currently let's just see what
38:44 - happens I will attempt to create a car
38:48 - object and run
38:50 - it type error can't instantiate abstract
38:53 - class car with abstract methods go and
38:57 - stop if a class is inheriting from a
39:00 - parent that's abstract and there's
39:02 - abstract methods we have to finish
39:05 - defining those
39:06 - methods So within our car class really
39:09 - I'll just copy this because I'm
39:11 - lazy our method is go we will
39:15 - print you drive the car we also need
39:23 - stop I will
39:26 - print you stop the
39:29 - car okay let's see if this
39:31 - works this has run with no problems I
39:34 - will have my car
39:36 - go then stop we're calling the go method
39:39 - then the stop method you drive the car
39:42 - you stop the car let's create a few more
39:45 - children for the vehicle class class
39:50 - motorcycle will inherit from the vehicle
39:55 - class again we have to implement the
39:57 - abstract methods found within the parent
40:00 - go and
40:06 - stop for go I will
40:10 - print you ride the
40:15 - motorcycle then with
40:19 - stop you stop the
40:23 - motorcycle motorcycle equals motorcycle
40:27 - we're calling the
40:30 - Constructor then I will have our
40:33 - motorcycle
40:35 - go then
40:37 - stop you ride the motorcycle you stop
40:40 - the
40:41 - motorcycle all right last example let's
40:44 - say we create a boat class which will
40:47 - inherit from the abstract class A
40:51 - vehicle I will include a go method where
40:55 - I will print
40:58 - you sail the
41:00 - boat but I will forget to add a stop
41:03 - method because I'm not paying attention
41:06 - let's attempt to create a
41:11 - boat well what the heck is this type
41:13 - eror can instantiate abstract class boat
41:16 - with abstract method stop then I'll look
41:19 - over my code and see oh I forgot to
41:22 - include a stop method with including
41:24 - abstract methods within a parent it acts
41:26 - as a set of checks and balances all
41:29 - vehicles should be able to go and stop
41:32 - if I forget to Define one of these
41:34 - methods well we'll receive a type error
41:36 - if we didn't I may not have noticed that
41:39 - we're missing a method so now we need to
41:41 - include that stop
41:44 - method I will
41:46 - print you anchor the
41:51 - boat this seems to have run with no
41:53 - problems I will have my boat go
41:58 - and
42:00 - stop you sail the boat you anchor the
42:03 - boat all right everybody so those are
42:05 - abstract classes it's a class that can't
42:08 - be instantiated on its own we can't
42:11 - create any objects from this class we
42:13 - don't want to because it's well
42:15 - incomplete they're meant to be
42:18 - subclassed they can contain abstract
42:20 - methods which are declared but we don't
42:23 - finish defining them we Define them
42:25 - within the children classes in this
42:27 - example car motorcycle and boat and well
42:30 - everybody those are abstract classes in
42:32 - Python hey everybody so today I got to
42:35 - talk about the super function in Python
42:38 - super is a function it's used within a
42:41 - child class to call methods from a
42:43 - parent class the child class is the
42:46 - subass the parent class is the super
42:49 - class hence why this function is named
42:50 - the super function using the super
42:53 - function it allows you to extend the
42:55 - functionality of the inherent methods
42:58 - here's an example we'll create a few
42:59 - shape objects we'll need to set up the
43:01 - classes though we'll have class
43:05 - Circle for the time being I'll just
43:07 - write pass we'll fill it in later class
43:13 - square and
43:15 - class
43:18 - triangle for each of these classes in
43:20 - order to instantiate objects we'll need
43:22 - a Constructor we will Define our
43:25 - Constructor our innit method
43:29 - when creating circles what sorts of
43:31 - attributes should a circle have let's
43:33 - say a color what's the color of the
43:36 - circle is it filled or not filled will
43:40 - be another attribute and a
43:43 - radius then let's assign
43:45 - these self. color equals the color that
43:49 - we receive
43:51 - self. fil equals
43:55 - filled self
43:57 - radius equals
44:00 - radius let's do this with the square and
44:02 - Triangle really I'll just copy our
44:04 - Constructor and paste it squares don't
44:08 - have a radius with a square the width
44:11 - and the height are the same let's
44:12 - replace radius with width we'll also
44:15 - keep the color and filled attributes
44:18 - self. width equals width now with
44:23 - triangles again let's copy our
44:25 - Constructor we'll need a width and a
44:30 - height self. height equals
44:34 - height so with programming we try not to
44:37 - repeat ourselves if we don't have to
44:39 - what do all of these classes have in
44:41 - common they all share the attributes of
44:44 - color and
44:47 - filled the ways in which they are
44:49 - different is that Circle has a radius
44:51 - attribute square has a width triangle
44:54 - has a width and a height if we have to
44:56 - make any changes to one of these
44:57 - attributes we would have to do so
44:59 - manually for example let's replace filed
45:02 - with is filed now I need to look
45:05 - throughout my code for any instance of
45:07 - filled and replace it with is
45:09 - filled it's a lot of work and I might
45:12 - make a
45:13 - mistake such as here and here it's
45:17 - better to write your code once and try
45:19 - and reuse it so that's where inheritance
45:21 - and the super function can come in handy
45:23 - we're going to take the attributes of
45:24 - color and is filled and place it within
45:26 - a parent class these children classes
45:29 - will inherit those
45:31 - attributes so class what do they all
45:34 - have in common they're all shapes class
45:37 - shape and for now I'll write pass circle
45:41 - is going to inherit from its parent of
45:43 - shape that also applies with square and
45:46 - triangle we'll set up a Constructor for
45:49 - shape Define
45:54 - init we will pass in the color
45:57 - and is
46:01 - filled then we will assign these
46:04 - attributes self. color equals
46:08 - color self. is filled equals is filled
46:14 - we don't need to manually assign these
46:16 - attributes within each of these
46:17 - Constructors for the
46:19 - children instead what we have to do is
46:22 - within the Constructor for each of these
46:24 - children classes we have to call the
46:26 - Constructor structor for the parent also
46:28 - known as the super class of shape so we
46:32 - will eliminate these two lines of
46:34 - code use the super
46:38 - function dot call The Constructor of the
46:41 - parent that is the dunder init method
46:45 - but we need to pass in the color that we
46:48 - receive and is filled this will be a
46:52 - Boolean and let's do this with the
46:54 - square class
46:57 - and the triangle
46:59 - class we still need radius for the
47:01 - circle width for the square width and
47:04 - height for the triangle we're going to
47:06 - call the super function to take care of
47:08 - whatever our attributes all these types
47:10 - of shapes have in common such as color
47:12 - and is filled now let's see if this
47:14 - works let's construct a few objects we
47:17 - will create a circle named
47:19 - circle called a Constructor for Circle
47:22 - we have to pass in a color a Boolean if
47:25 - it's filled or not and a radius
47:27 - so for the color of the circle let's say
47:31 - red is filled let's say that is true and
47:35 - a radius of five you could even use
47:38 - keyword arguments for better readability
47:40 - although not necessary but for clarity
47:43 - let's say color equals
47:45 - red is filled equals
47:48 - true radius equals
47:51 - 5 let's see if this works I will print
47:56 - our Circle
48:00 - color it is
48:04 - red print our colors is filled
48:08 - attribute the circle is filled that is
48:11 - true and the
48:13 - radius print
48:15 - circle. rius the radius of the circle is
48:20 - five we could even convert this to an F
48:23 - string I'll add a placeholder
48:29 - then add
48:32 - centimeters 5 cm let's construct a
48:35 - square
48:37 - object square equals
48:40 - Square we'll need a color is filled and
48:43 - a width I'll just copy what we have and
48:45 - make a few changes replace radius with
48:49 - width the color will be blue is filled
48:53 - will be false the width will be six we
48:56 - don't need the height because squares
48:58 - have an even width and height if we ever
49:00 - need the height we can assume it's the
49:02 - same as the width in this case six let's
49:05 - check out our square square do color
49:08 - square. is filled Square do
49:13 - width our square is blue it's not filled
49:16 - in the width is 6
49:18 - cm let's create a triangle object
49:22 - triangle equals
49:25 - triangle pass in our
49:28 - arguments the color will be yellow is
49:31 - filled will be true the width will be
49:35 - seven and the height will be
49:39 - eight let's print our triangle's color
49:42 - is it filled its width and its
49:50 - height our triangle is yellow it's
49:52 - filled in the width is 7 cm the height
49:56 - is 8
49:57 - cm so that's how you can use the super
50:00 - function to reuse the Constructor of a
50:02 - parent class we don't need to manually
50:05 - assign each of these attributes within
50:07 - each of the children classes we can do
50:09 - that in just one place when we refer to
50:11 - Super imagine that we're replacing this
50:14 - with the parent class name such as
50:17 - shape that might be a good way to think
50:19 - of
50:21 - it use the Constructor of the parent
50:24 - class of shape and pass these arguments
50:27 - in what you could do as well is extend
50:30 - the functionality of a method So within
50:32 - our shape class let's create a method of
50:37 - describe we will describe the attributes
50:39 - of this shape we will
50:42 - print use an FST string when we want to
50:46 - describe our shape let's say it is at a
50:49 - placeholder self. color what is the
50:53 - color of this shape and is it fill or
50:55 - not and add a placeholder we'll use a
50:59 - tary operator print
51:03 - filled if self. is filled is true else
51:09 - we will
51:11 - print not
51:14 - filled each of these types of shapes
51:17 - circle square and triangle will have
51:19 - access to a describe
51:21 - method let's attempt to use it take our
51:25 - Circle use the describe method that's
51:29 - inherited it is red and filled
51:33 - Square it is blue and not filled
51:37 - triangle it is yellow and
51:40 - filled so then we also have method
51:42 - overwriting what if we create a similar
51:45 - method of describe within circle square
51:47 - and triangle let's do
51:50 - that
51:52 - Define a describe method
51:57 - within our Circle let's calculate the
52:00 - area what's the area of the circle I'll
52:02 - use an F string it is a
52:06 - circle with an area of then we'll
52:11 - calculate the area given the
52:13 - radius to calculate the area of a circle
52:16 - we can take Pi I'll just say 3.14 just
52:19 - to keep it simple times the radius
52:22 - squared self. rius time self. rius
52:27 - if I were to call the describe method
52:30 - will we use the parents version of
52:32 - describe or the
52:35 - child so let's take our Circle use the
52:39 - describe
52:40 - method the
52:42 - result it is a circle with an area of
52:46 - 78.5 I should really add cim squar after
52:50 - that cm
52:53 - squared this is called method
52:55 - overwriting if a child child shares a
52:57 - similar method with a parent you'll use
53:00 - the child's version and not the parents
53:03 - this is Method overwriting if you would
53:05 - like to extend the functionality of a
53:07 - method from a parent you can use the
53:10 - super function not only do I want to use
53:12 - the describe method of the child I would
53:14 - also like to use the describe method of
53:16 - the parent So within this function we
53:19 - will use the super function access the
53:23 - describe method of the
53:25 - parent what we're doing is extending the
53:28 - functionality of the describe
53:31 - method it is a circle with an area of
53:34 - 78.5 cm squared the circle is red and
53:38 - it's
53:39 - filled or you can change up the
53:43 - order let's use the parent classes
53:46 - describe method and extend the
53:48 - functionality with our own print
53:50 - statement it is red and filled it is a
53:53 - circle with an area of 78.5 cm squ
53:57 - let's finish this with the square and
53:59 - triangle classes I'll copy what we have
54:01 - for the described method within the
54:02 - circle
54:03 - class but we'll make a different
54:08 - calculation describe the square it is a
54:11 - square with an area of take self. width
54:16 - times self.
54:19 - width the height and the width are going
54:21 - to be the same if it's a
54:23 - square then describe our triangle
54:30 - it is a
54:32 - triangle with an area of width time
54:35 - height we have a height in this case
54:37 - divid two we've already described our
54:40 - Circle let's describe our
54:43 - Square it is a square with an area of 36
54:46 - CM squar it is blue and not filled let's
54:50 - describe our
54:51 - triangle it is a triangle with an area
54:54 - of 28.0 cm squ it is yellow and
54:58 - filled all right everybody that is the
55:00 - super function it's used in a child
55:02 - class to call the methods from a parent
55:05 - class also known as the super class it
55:08 - allows you to extend the functionality
55:10 - of the inherited methods within a child
55:13 - class you could use it within a
55:14 - Constructor to assign any attributes
55:17 - that all of its siblings have in common
55:19 - such as color or if that shape is filled
55:23 - when used within any other method you
55:25 - can extend the fun functionality of that
55:27 - method not only are we printing this
55:30 - message from the parent we're tacking on
55:32 - another print statement before that and
55:34 - well everybody that is the super
55:36 - function in Python what is going on
55:39 - everybody so today I got to talk about
55:41 - polymorphism in Python polymorphism is a
55:45 - programming concept it's a Greek word
55:47 - that means to have many forms or faces
55:50 - poly means many morph means form in
55:53 - programming an object can take one of
55:56 - many forms there's two ways to achieve
55:58 - polymorphism one is through inheritance
56:00 - an object could be treated of the same
56:03 - type as a parent class there's also duck
56:05 - typing which we'll talk about in the
56:07 - next Topic in this video we're more
56:09 - focused on inheritance what we'll do in
56:12 - this video is create a class of shape
56:15 - we'll write pass as a placeholder we
56:18 - will create a class of circle which will
56:21 - inherit from shape again writing pass
56:25 - class class Square inherits from
56:31 - shape class
56:34 - triangle which inherits from
56:39 - shape if I was to create a circle object
56:42 - Circle equals
56:44 - Circle our Circle identifies as a circle
56:48 - and since our Circle class inherits from
56:50 - the shape class our circle is also
56:52 - considered a shape it has two forms it's
56:55 - a circle and it's a shape but our Circle
56:58 - isn't a square or a triangle that could
57:00 - also apply to our Square
57:02 - class our square is a square our square
57:06 - is also considered a shape but our
57:08 - square is not a circle or a triangle
57:10 - those are two possible forms for our
57:12 - Square it's a square and a shape so
57:15 - let's say we would like to create a list
57:17 - of shapes what do they all have in
57:19 - common well they're all shapes a
57:21 - descriptive name for this list would be
57:24 - shapes equals an empty list
57:27 - I will instantiate a circle object a
57:30 - square
57:31 - object and a triangle
57:34 - object our circle is a circle and a
57:38 - shape our square is a square and a shape
57:41 - our triangle is a triangle and a shape
57:44 - each of these objects has two forms or
57:47 - two faces let's fill in some of these
57:49 - classes let's say that with our shape
57:52 - class we will define an area method
57:55 - Define area I'm going to turn this into
57:58 - an abstract method I'll just write pass
58:01 - to work with abstract classes we need to
58:03 - import that from
58:06 - ABC import Capital ABC as well as
58:11 - abstract method preceding the area
58:14 - method I will add a decorator of
58:16 - abstract method our circle square and
58:19 - triangle classes they're all considered
58:21 - shapes they inherit from this class we
58:24 - need to Define an area method for each
58:26 - since they're all considered a shape
58:28 - every shape has an area with our class
58:31 - of circle let's define a
58:34 - Constructor Define in
58:37 - nit we will pass in one argument a
58:40 - radius what is the radius of the circle
58:43 - assign an attribute of radius equals the
58:46 - radius we receive let's do this with
58:49 - square Define in
58:52 - nit one parameter the length of a side
58:57 - self. side equals side then
59:02 - triangle Define
59:06 - init we have two parameters base and
59:12 - height self. Bas equals base self.
59:18 - height equals
59:20 - height all right now let's finish
59:22 - defining these area methods for each
59:24 - class
59:26 - we will
59:29 - return
59:31 - 3.14
59:33 - time self. rius to the power of
59:37 - two so given a radius that's how to
59:40 - calculate the area of a circle then with
59:43 - our
59:45 - Square Define
59:47 - area we will
59:50 - return
59:52 - self. side to the power of two
59:58 - then with our
60:00 - triangle Define
60:04 - area
60:06 - Return self. base times self. height
60:12 - time
60:14 - 0.5 now we have to pass in some
60:16 - arguments for our Circle we need a
60:18 - radius I'll pick four for the square the
60:21 - length of a side will be five then our
60:24 - triangle the base will be six the height
60:26 - will be seven we're going to write a
60:29 - loop to iterate through our shapes for
60:31 - every shape in
60:34 - shapes then we're going to
60:36 - print for every shape called the area
60:43 - method and that would give me these
60:46 - numbers if you would like you can format
60:48 - the output I'll just use an F
60:54 - string I'll add CM
61:03 - squar much better what if we were to
61:06 - create a class that's completely
61:08 - unrelated to
61:10 - shapes I will create a class of
61:15 - pizza I will Define a
61:19 - Constructor to construct a pizza object
61:22 - we need a
61:24 - topping and a radius what is the radius
61:26 - of the
61:28 - pizza self. topping equals
61:33 - topping self. rius equals
61:38 - radius within my list of shapes I'll add
61:41 - a pizza
61:42 - object but I have to pass in a topping
61:45 - such as
61:48 - pepperoni and what is the radius of the
61:51 - pizza let's say 15 cm so our pizza our
61:55 - Pizza class doesn't have an area method
61:58 - here's what happens when I run
62:00 - this we get an attribute error Pizza
62:04 - object has no attribute
62:06 - area our pizza object is considered a
62:09 - pizza but it is not considered a shape
62:12 - it does not inherit from the shape class
62:14 - at the top here you know what a pizza is
62:17 - circular it could be considered a circle
62:20 - so how about this let's take the pizza
62:22 - class it will inherit from the circle
62:25 - class
62:26 - and within our Circle class we're
62:29 - already assigning the radius to the
62:30 - radius attribute so instead of doing
62:33 - that here within the Constructor for our
62:34 - pizza class let's call the super
62:37 - Constructor super which refers to the
62:40 - parent use its
62:42 - Constructor then passing the radius we
62:45 - receive let's see if this works
62:49 - now that does here is the area of our
62:52 - pizza our pizza is considered a pizza it
62:56 - inherits from the circle class so it's
62:58 - also considered a circle and our Circle
63:01 - class inherits from the shape class our
63:04 - pizza has three forms our pizza is
63:07 - considered a pizza it's also considered
63:09 - a circle and it's also considered a
63:11 - shape it would make sense for it to fit
63:13 - into this list of shapes because our
63:16 - pizza also identifies as a shape so
63:19 - that's polymorphism everybody it's a
63:21 - Greek word meaning to have many forms or
63:23 - faces poly meaning many morph meaning
63:26 - form in Python there's two ways to
63:28 - achieve polymorphism one through
63:30 - inheritance an object could be treated
63:32 - of the same type as a parent and there's
63:35 - also duck typing which we'll discuss
63:37 - more in the next topic stay tuned for
63:39 - that and well everybody that's
63:41 - polymorphism in
63:44 - Python hey everybody so today I got to
63:46 - talk about duck typing in Python duck
63:49 - typing is another way to achieve
63:51 - polymorphism besides using inheritance
63:54 - objects can be treated as if they're
63:56 - type as long as they meet the minimum
63:58 - necessary attributes and methods
63:59 - required of them it follows this adage
64:02 - if it looks like a duck and quacks like
64:04 - a duck it must be a duck as long as an
64:08 - object resembles another it could also
64:10 - be treated of that type so in this
64:13 - example let's create a class of
64:16 - animal we will have a class attribute of
64:19 - a live if you're an animal you will have
64:22 - an attribute of aive you're a living
64:25 - creature
64:26 - let's create a class of dog the dog
64:30 - class will inherit from the animal class
64:33 - they will inherit the alive attribute
64:35 - let's also Define a speak method if
64:38 - you're a dog you gain the ability to
64:40 - speak we will
64:43 - print
64:44 - woof then we'll create a cat
64:47 - class class cat inherits from animal for
64:52 - the speak method we will print meow
64:56 - let's create a list of animals what do
64:58 - these two classes have in common they
65:01 - both could be considered animals let's
65:03 - create a list of
65:05 - animals we will construct a dog object
65:08 - and a cat
65:10 - object if I was to write a for Loop for
65:13 - every animal in my list of
65:17 - animals have each animal use its speak
65:21 - method which will result in the dog
65:25 - going woof the cat going meow they're
65:27 - both
65:28 - speaking what if we add a class that has
65:31 - nothing to do with
65:33 - animals like class
65:36 - car cars will have a horn method that's
65:40 - how they
65:41 - speak when you honk the horn you will
65:45 - print
65:47 - honk within my list of animals let's
65:50 - create a car object it really doesn't
65:53 - belong in here but let's see what
65:54 - happens
65:58 - we have an attribute error car object
66:01 - has no attribute
66:03 - speak our car object doesn't have the
66:06 - minimum necessary attributes and
66:09 - methods when iterating through this list
66:11 - of animals we're calling each animal
66:13 - speak method which our car object
66:16 - doesn't have but it does have a horn
66:19 - method so what if we rename our horn
66:21 - method as speak maybe it's an AI car or
66:25 - something
66:27 - something well this would work the dog
66:30 - goes woof the cat goes meow the car goes
66:34 - honk so our car
66:37 - object it quacks like a duck we could
66:40 - consider it a duck it has the minimum
66:43 - necessary methods to be considered an
66:46 - animal animals inherit this alive
66:48 - attribute let's utilize that after the
66:52 - animal
66:53 - speaks let's print their Al live
66:56 - attribute print my animals Al live
67:00 - attribute my car object doesn't have
67:03 - that attribute we get an attribute error
67:06 - car object has no attribute
67:08 - alive but if I was to add that
67:12 - attribute alive equals
67:17 - false we have true for the dog it's
67:20 - living true for the cat it's living but
67:22 - false for the car it's not living it's
67:25 - not a living
67:27 - creature my car meets the minimum
67:29 - necessary requirements to be considered
67:32 - an animal if I were to set this to be
67:36 - alive well then it would be a living car
67:39 - kind of like the movie Cars so with
67:42 - python duct typing is another way to
67:45 - achieve polymorphism besides using
67:47 - inheritance as long as an object has the
67:49 - minimum necessary attributes and methods
67:52 - you could treat it as a different type
67:53 - of object if it looks like a duck and
67:56 - quacks like a duck it must be a duck and
67:59 - well everybody that is duck typing in
68:02 - Python hey what's going on everybody so
68:05 - in today's video I'm going to explain
68:06 - aggregation in Python aggregation
68:09 - represents a relationship where one
68:11 - object contains references to one or
68:14 - more independent objects one object acts
68:17 - as a container the whole which can
68:20 - contain other objects the parts so what
68:23 - we'll do in this demonstration is create
68:25 - a object that's going to act as a
68:26 - container we'll create a class of
68:29 - library for now a right pass now a
68:33 - library can contain books we will create
68:36 - a class of
68:39 - book we'll be creating book objects
68:41 - which we will add to our library object
68:44 - the library object is going to act as
68:46 - the whole the container the books are
68:49 - the independent Parts a library can
68:52 - exist without its books and the books
68:54 - can exist without the library that's the
68:57 - main difference between aggregation and
68:59 - composition these classes are
69:01 - independent of one another they can
69:03 - exist without each other with our class
69:05 - of book we'll need a Constructor we will
69:09 - Define our
69:11 - Constructor if we create a book we need
69:14 - a title and an
69:17 - author we will Define a title attribute
69:21 - equals the title that we receive and
69:24 - self . author equals the author that we
69:28 - receive that's all we need for the book
69:30 - class now with the library class we will
69:33 - also need a
69:34 - Constructor Define
69:37 - init for our library we need a name for
69:41 - the library for example the New York
69:44 - Public
69:45 - Library self. name equals the name that
69:49 - we receive let's construct our library
69:52 - object first Library equals Li Library
69:56 - we need to pass in a name for this
69:58 - Library let's say New York Public
70:04 - Library so this should run with no
70:06 - problems then we'll create a few books
70:09 - let's say book one equals called the
70:13 - book Constructor we have to pass in a
70:15 - title and an author so pick a few books
70:19 - I will pick Harry Potter Happy Harry
70:25 - Harry
70:26 - Potter and the philosopher stone but I
70:29 - don't want to type the whole title let's
70:31 - just say Harry Potter do dot
70:34 - dot the author of this book is JK
70:39 - rolling okay let's create another book
70:42 - book two equals
70:45 - book for my next book I'll pick the
70:49 - Hobbit the author is J R R our
70:57 - token then book three equals book we
71:02 - need a title and an author I will pick
71:05 - the
71:06 - color of
71:09 - Magic by
71:11 - Terry
71:14 - pratchet we have no problems when
71:16 - running this our library and our books
71:20 - can exist without each other our books
71:23 - are independent so now now where
71:25 - aggregation comes in our library object
71:28 - will contain our book objects one way in
71:30 - which we can handle this is that within
71:32 - the Constructor for our library let's
71:35 - create an attribute of
71:37 - books this will be an empty
71:42 - list we'll need a way to add these books
71:46 - to our list of books we will Define a
71:49 - method of add
71:52 - book but we have to pass in a book
71:54 - object when we call this
71:57 - method we're going to access self. books
72:01 - it's a list list have a built-in append
72:05 - method we will append our book to our
72:08 - list of
72:11 - books let's see if this at least runs
72:14 - we're going to take our
72:16 - library call the add book method that we
72:20 - defined then pass in our book object of
72:23 - book
72:23 - one then let's let's do this with book
72:26 - two and book
72:29 - three and this is run with no problems
72:32 - our books can exist independently of our
72:35 - library our library object is just
72:38 - containing them it's housing these books
72:42 - now if I would like to print all the
72:43 - books in my library I could create a
72:46 - method to do that let's define a method
72:49 - of list books there will be no
72:53 - parameters besid self
72:55 - I'm going to return a list
72:59 - comprehension for every book in self.
73:03 - books remember that books is a list for
73:07 - every book in books Let's return an F
73:11 - string where we display the book's title
73:14 - and the book's
73:16 - author display book. tile the word
73:21 - by bookauthor
73:26 - okay let's see if this works first I'm
73:28 - going to print the library's
73:30 - name print
73:34 - libraryname
73:36 - New York Public
73:39 - Library then I'm going to
73:41 - print access the library objects list
73:46 - books
73:48 - method and here is my list of
73:50 - books although I'm going to reformat
73:53 - this so it looks better I'll use a for
73:56 - Loop for every
73:59 - book in Access our library
74:02 - objects list books method this will
74:07 - return a list we can iterate through it
74:10 - for every book in the list of books
74:13 - print each
74:16 - book all right here is our libraries
74:19 - name and each book in our list of
74:22 - books all right everybody so that's agre
74:25 - ation it represents a relationship where
74:27 - one object the whole contains references
74:31 - to one or more independent objects the
74:34 - books they can exist without one another
74:37 - and well everybody that is aggregation
74:39 - in
74:40 - Python all right everybody so today I
74:42 - got to talk about composition in python
74:45 - as we've discussed in the previous topic
74:47 - aggregation is a relationship where one
74:49 - object contains references to other
74:51 - independent objects they have a has a
74:55 - relationship composition on the other
74:57 - hand is when the composed object
74:59 - directly owns its components which
75:02 - cannot exist independently they have a
75:05 - owns a relationship aggregation has
75:09 - things composition owns things kind of
75:12 - like you're renting or you're owning
75:14 - something in this example we'll create
75:16 - three classes a class of
75:21 - engine a class of wheel
75:26 - and the composed object is going to be
75:28 - Class
75:30 - Car within our car class we will
75:33 - construct some engine and wheel objects
75:36 - we'll begin with our engine class we'll
75:38 - need a Constructor we'll Define that
75:40 - Define in knit let's say that with an
75:44 - engine we need a
75:46 - horsepower what is the power of the
75:49 - engine self. horsepower
75:52 - attribute equals the horsep power that
75:55 - we
75:56 - receive with our class of wheel we need
75:58 - a Constructor Define
76:02 - init let's add a size attribute what is
76:06 - the size of the
76:08 - wheel self. size equal
76:13 - size okay now with our car object now
76:17 - within our car class we need a
76:20 - Constructor we will need a make model
76:25 - the horsepower of the
76:28 - engine and size we'll say wheel
76:32 - size remember that you can rename
76:35 - parameters to something
76:36 - different we will assign these
76:38 - attributes self. make equals
76:41 - make self. model equals
76:46 - model here's where composition comes in
76:50 - we will define an
76:51 - attribute of engine then call the engine
76:56 - Constructor we have one argument to pass
76:58 - in
77:00 - Horsepower we will pass in the
77:02 - horsepower that we receive to the engine
77:07 - Constructor then we have to set up our
77:10 - wheels self. wheels equals now to
77:15 - construct a single wheel object we would
77:18 - call the wheel Constructor then pass in
77:21 - the wheel
77:23 - size however car have four wheels we
77:25 - don't want just one wheel so what we
77:28 - could do is write a list
77:32 - comprehension for every
77:34 - wheel in range four to iterate four
77:38 - times let's call the wheel
77:41 - Constructor and pass in our wheel
77:44 - size this list comprehension will create
77:47 - four wheel objects for
77:49 - us the reason that this is considered
77:51 - composition we're creating engine and
77:54 - wheel objects inside of this class car
77:57 - our class car owns an engine and owns
78:01 - four wheels we're not creating these
78:04 - objects outside of the car
78:07 - class let's create a car object car
78:10 - equals car we need a make model
78:14 - horsepower for the engine and wheel size
78:17 - so for my car let's say
78:20 - Ford Mustang for the horsepower I'll
78:24 - make up something
78:26 - 500 for the wheel size 18 in now just to
78:30 - make this more explicit I'm going to use
78:32 - keyword arguments but you don't have to
78:35 - so make equals Ford Model equals
78:40 - Mustang horsepower =
78:44 - 500 wheel size equal
78:48 - 18 let's create a method to display our
78:51 - car I would like the details Define
78:55 - display car no
78:58 - parameters let's return an F string
79:03 - let's begin with the make and model
79:04 - those will be easy display self. make
79:09 - and self.
79:11 - model let's take our car object use the
79:15 - display car
79:19 - method then I got to print it I
79:22 - forgot because we're returning a a
79:24 - string we're not printing it directly we
79:27 - have a Ford
79:29 - Mustang okay let's display the
79:32 - horsepower there's one additional step
79:34 - we are accessing self this car that
79:37 - we're creating but now we need the
79:39 - engine let's access the engine attribute
79:43 - and now with our engine our engine has
79:45 - an attribute of horsepower we'll use the
79:48 - attribute accessor that dot
79:52 - horsepower 500 I'll add HP meaning
79:59 - horsepower all right now for the wheels
80:01 - I'll add another placeholder access self
80:06 - access our
80:07 - Wheels now our Wheels it's a list I
80:11 - don't need all four wheels I just need
80:14 - one if I was to take my list then access
80:18 - the size this is what it'll give me list
80:22 - object has no attribute size
80:25 - so we need to access one of the elements
80:27 - of our list of Wheels let's just say the
80:30 - first wheels at index0 then give me the
80:34 - size 18 and that's going to be
80:40 - inches all right then let's create a
80:42 - second car object before we finish we
80:45 - have car
80:46 - 1 Car 2 equals
80:49 - car we need a make model horsepower for
80:52 - the engine and wheel size for the Wheels
80:56 - I will pick a
80:58 - Chevrolet Corvette and I'm just going to
81:01 - make up some numbers the horsepower is
81:04 - 670 and the wheel size is
81:07 - 19 let's display Car 2 Car 2 called the
81:11 - display car method we have a Chevy
81:15 - Corvette with horsepower of 670 the
81:18 - wheel size is 19
81:20 - in so our car class it owns some objects
81:24 - it owns an engine and it owns four
81:26 - wheels that's why composition is
81:28 - different from aggregation if I were to
81:31 - delete these two cars this engine and
81:34 - the four wheels would stop existing
81:37 - whereas in our library example in the
81:38 - last video if I was to delete the
81:41 - library object the books would still
81:43 - exist all right everybody so that's
81:45 - composition it's where a composed object
81:48 - our car directly owns its components our
81:52 - car owns an engine and it own phones for
81:55 - Wheels we're creating them within the
81:57 - class and well everybody that's
81:59 - composition in
82:01 - Python hey what's going on everybody so
82:04 - in today's video I got to talk about
82:05 - nested classes in Python a nested class
82:08 - is a class defined inside of another
82:11 - class this has a few benefits we can
82:13 - logically group classes that are closely
82:16 - related we can encapsulate private
82:18 - details that aren't relevant outside of
82:20 - the outer class and also it helps keep
82:23 - our namespace clean it reduces the
82:25 - possibility of naming conflicts so for
82:27 - example let's say we have two classes
82:30 - both named
82:32 - employee within this class I'm just
82:35 - going to print
82:36 - something this is the first
82:40 - class then let's copy our employee class
82:43 - paste it
82:45 - again this is the second
82:48 - class we have a naming conflict we have
82:51 - two classes with the same name if I were
82:53 - to run this program
82:55 - we will execute both this is the first
82:57 - class this is the second class it is
82:59 - fairly noticeable that we have two
83:01 - classes with the same name but with
83:03 - python we do a lot of importing and
83:05 - exporting of large files we may not
83:07 - realize there's a name conflict one
83:10 - concept that'll help us avoid naming
83:11 - conflicts is the use of nested classes
83:14 - let's say we have employees for a
83:16 - company and another set of employees for
83:18 - a nonprofit
83:20 - organization I could write something
83:22 - like this we'll create a class of
83:25 - company within this class of company we
83:28 - will have an in class of
83:30 - employee with our second employee class
83:32 - we will create an outer class of
83:40 - nonprofit this is perfectly fine we can
83:42 - have two classes with the same name as
83:45 - long as they're within different
83:47 - Scopes these two employee classes might
83:49 - have different attributes depending on
83:51 - who they work for if they work for a
83:53 - company they might might have one set of
83:55 - attributes if they work for a nonprofit
83:57 - they might have a different set of
83:58 - attributes so by using nested classes
84:01 - this helps keep the namespace clean we
84:03 - can reuse this employee class because
84:06 - they have different Scopes now what
84:07 - we're going to do in this
84:09 - example what we'll do in this example is
84:11 - create some employee objects that belong
84:13 - to a company object as a placeholder for
84:16 - now I'll write pass within the employee
84:19 - class with our class of company let's
84:21 - define a Constructor do pay attention to
84:24 - the indentation we are within the
84:26 - company class but not the employee class
84:29 - this Constructor is for the company the
84:31 - company object we're going to
84:33 - create if we construct a company object
84:36 - we need a company name such as the
84:40 - Crusty
84:41 - Crab I will assign self. company name
84:46 - equals the company name that we
84:48 - receive we are also going to declare an
84:51 - attribute of employees
84:54 - this attribute will be an empty list we
84:57 - will append employee objects to our list
84:59 - of
85:00 - employees then we will create a method
85:03 - to add
85:07 - employee we will need a name meaning
85:09 - name of the employee and a position
85:13 - what's their job for now I'll write pass
85:16 - we'll get back to this
85:18 - later and I will Define a method of list
85:23 - employees
85:26 - and again I'll write pass okay let's be
85:29 - sure that our company name
85:33 - works I'm going to create a company
85:35 - object company equals company but I have
85:39 - to pass in a company
85:41 - name I will pick the Crusty
85:44 - Crab then just to be sure that this
85:47 - works I will display our company's
85:50 - company name attribute
85:55 - that would give me the Crusty
85:57 - Crab so we know that that
86:00 - works within our employe class let's
86:03 - define a Constructor Define
86:06 - innit we need a name and a
86:11 - position self. name equals
86:15 - name
86:18 - self.pos equals
86:20 - position let's create one more method
86:25 - Define get details we will return the
86:29 - details of an employee all we're going
86:32 - to do is return an FST string add two
86:36 - placeholders we will return self.
86:39 - name and
86:43 - self.pos all right now within our ad
86:45 - employee
86:47 - method we will construct a new employee
86:51 - object equals now if if we're going to
86:54 - access this inner class of employee
86:57 - we're going to prefix
86:59 - self self meaning this company object
87:02 - that we're currently working
87:03 - with we need the class of employee then
87:07 - we'll call The Constructor but we have
87:09 - to pass in a name and a position when we
87:12 - receive a name and a position we will
87:16 - pass that to the employee
87:17 - Constructor once we have our new
87:19 - employee object we're going to take our
87:22 - list of employees
87:24 - self.
87:27 - employees use the append method of lists
87:31 - then add our object of new employee to
87:34 - this empty
87:35 - list let's create a few employee objects
87:38 - we'll take our company use the add
87:41 - employee method that we have created we
87:44 - need a name and a
87:47 - position I will pick Eugene for Eugene
87:51 - Krabs his position is that he is the
87:54 - manager let's create two more take our
87:58 - company object use the ad employee
88:01 - method that we have defined I will pass
88:03 - in a name of this employee as SpongeBob
88:07 - his position is that he is a cook then
88:10 - we have Squidward company. add employee
88:14 - method first name
88:18 - Squidward his position is that he is a
88:21 - cashier so this should run with no
88:23 - problem
88:24 - s now I would like to list all of the
88:27 - employees at this company we'll need to
88:30 - rely on this get details
88:32 - method so when we list our employees we
88:36 - will return a list
88:39 - comprehension for every
88:42 - employee in self.
88:45 - employees this is an attribute it's a
88:48 - list of employee objects it is iterable
88:54 - take each employee that we're iterating
88:57 - through call the get details method and
89:01 - return
89:03 - it now if I was to take my company then
89:07 - call the list employees
89:11 - method whoops I forgot to print
89:16 - it we will print each employees name and
89:20 - their
89:21 - position however I think this would look
89:23 - better if we were to use a for
89:25 - Loop for
89:28 - every
89:29 - employee in take our
89:33 - company call the list employees
89:37 - method during each
89:40 - iteration we will print each
89:49 - employee we have Eugene that's Mr Krabs
89:53 - the manager SpongeBob The Cook and
89:55 - Squidward the cashier to demonstrate the
89:58 - reusability of classes let's create a
90:00 - second company object that has its own
90:04 - employees let's rename company as
90:06 - company
90:08 - one then we will create Company
90:13 - 2 Company 2 equals called the company
90:16 - Constructor my second company will be
90:19 - the Chum
90:21 - Bucket we'll take Company 2 then add two
90:25 - employees company 2. add
90:30 - employee we will pick
90:33 - shelden Sheldon is the
90:40 - manager company
90:42 - 2. add
90:46 - employee Karen will be the
90:51 - assistant for every employee in Company
90:54 - 2 list the employees during each
90:57 - iteration print the current
91:01 - employee we have Sheldon that's
91:03 - Plankton's first name he's the manager
91:06 - and Karen is his assistant all right
91:09 - everybody so those are nested classes
91:11 - it's a class defined inside of another
91:13 - class you have an inner class and an
91:15 - outer Class A few of the benefits is
91:18 - that we can logically group classes that
91:20 - are closely related such as having
91:22 - employee objects within a company object
91:25 - we can encapsulate private details that
91:28 - aren't relevant outside of the other
91:29 - class we may have no need to create
91:31 - employee objects outside of this class
91:34 - and by using nested classes it helps
91:36 - keep the name space clean it reduces the
91:39 - possibility of naming conflicts with
91:41 - another type of organization we could
91:43 - create another inner employee class and
91:46 - well everybody those are nested classes
91:48 - in
91:49 - Python hey what's going on everybody
91:52 - today I'm going to talk about static
91:53 - meth methods in Python a static method
91:56 - is a method that belongs to a class
91:59 - rather than any object from that class
92:02 - any instance instance methods we're
92:05 - already familiar with them they are
92:07 - methods that belong to individual
92:08 - objects created from that class they're
92:11 - best for operations on instances of that
92:13 - class any objects whereas static methods
92:17 - they're best for utility functions
92:19 - within a class that do not need access
92:21 - to class data I'll demonstrate the
92:24 - differences between an instance method
92:25 - and a static method we'll Begin by
92:28 - creating a class of
92:31 - employee we'll need a Constructor let's
92:34 - define
92:36 - that to create an employee object we'll
92:38 - need a name and a job
92:41 - position we will assign self. name
92:46 - equals name self.
92:49 - position equals
92:52 - position we will create an instance
92:55 - method of get info we will return
92:58 - employee
92:59 - info we will return an F string where we
93:04 - will display self.
93:07 - name equals
93:13 - self.pos get info is an instance method
93:17 - each object that we create from this
93:19 - class will have their own get info
93:21 - method to return the information on that
93:23 - object object the object's name and the
93:26 - object's position now we'll create a
93:28 - static
93:29 - method to create a static method we need
93:32 - a decorator of static method static
93:36 - methods are best for General utility
93:39 - functions within a class we'll Define a
93:41 - method to check to see if a job a
93:44 - position is valid which we will name is
93:49 - valid
93:51 - position so static methods they don't
93:54 - have self as the first argument we're
93:56 - not working with any objects created
93:58 - from this class to check to see if a
94:00 - position is valid we will pass in a job
94:02 - position which I will name as
94:06 - position I will create a list of
94:10 - valid
94:13 - positions let's assume that our company
94:15 - is the Crusty Crab what are some valid
94:18 - positions a manager is a valid position
94:21 - a cashier
94:24 - a cook then let's say a
94:29 - janitor then we will return we'll use a
94:32 - membership
94:34 - operator check if position that we
94:38 - receive is in our list of valid
94:45 - positions what we have done is that we
94:47 - have created a static method we don't
94:49 - need to rely on any objects to use this
94:52 - method for example
94:55 - to use a static method we will use the
94:57 - name of the class rather than any object
95:01 - that we create from this class such as
95:04 - this we don't need to do
95:07 - that we type the class name followed by
95:10 - the static method is valid
95:16 - position then I did set this up to
95:19 - accept one argument let's check to see
95:22 - if a cook is is a valid
95:26 - position then I do need to print this
95:29 - what is the
95:31 - output a cook is a valid position what
95:35 - about a rocket
95:37 - scientist that would probably be sy's
95:39 - job that is false a rocket scientist is
95:43 - not a valid position at the K crusty
95:46 - crab this is a static method it belongs
95:49 - to the class not any object created from
95:51 - that class now let's let's create a few
95:54 - employee objects let's say employee 1
95:58 - equals a new
96:00 - employee we have to pass in a name and a
96:03 - job Eugene will be the first name that's
96:06 - Mr Krabs he will be a
96:10 - manager employee
96:12 - 2 equals
96:15 - employee
96:18 - Squidward will be a
96:21 - cashier employee 3
96:25 - equals
96:27 - employee employee 3 will be
96:29 - SpongeBob SpongeBob will be a
96:33 - cook to call an instance method we have
96:36 - to access one of the instances of the
96:38 - class in order to use
96:40 - it if I want to check the info on
96:42 - employee 1 I will access that object
96:45 - that
96:46 - instance use the get info method then I
96:51 - need to print it
96:54 - take employee one get the info Eugene is
96:58 - the manager let's do this with employee
97:01 - 2 and employee
97:05 - 3 Eugene Mr Krabs is the manager
97:09 - Squidward is the cashier SpongeBob is
97:11 - the cook for an instance method you
97:14 - access an object then call the instance
97:17 - method with the static method you only
97:20 - need to access that class you don't even
97:22 - need to create any objects from that
97:24 - class it's a general utility
97:27 - method all right everybody those are
97:30 - static methods they're a method that
97:32 - belongs to a class rather than any
97:34 - objects created from that class they're
97:37 - usually used for General utility
97:39 - functions that do not need access to
97:41 - class data and well everybody those are
97:44 - static methods in
97:46 - Python hey what's going on people so
97:48 - today I got to talk about class methods
97:50 - in Python a class method allow
97:53 - operations related to the class itself
97:56 - they take CLS as the first parameter
97:58 - whereas instance methods will take self
98:01 - self refers to any object created from
98:03 - that class CLS meaning class refers to
98:07 - the class not any objects here's an
98:10 - example we will create a class of
98:14 - student we'll need a Constructor to
98:16 - construct some student
98:18 - objects all students will have a name
98:22 - and a GP
98:25 - self. name equals name self. GPA equals
98:32 - GPA we will also create a class variable
98:35 - for this demonstration of count we will
98:38 - count how many students we
98:41 - create whenever we construct a student
98:44 - object we will access the class of
98:46 - student take our count variable
98:50 - increment it by one whenever we create a
98:52 - student object object increase count by
98:56 - one I will create an instance method of
99:00 - get
99:02 - info instance methods have self as the
99:05 - first parameter we're referring to the
99:08 - object we're currently working with I
99:11 - will return an F string where we will
99:15 - display the students name and their GPA
99:18 - self.
99:20 - name self. GPA
99:24 - I'll add a comment that this is an
99:27 - instance
99:29 - method Now to create a class method to
99:33 - work with class data we will declare a
99:35 - class method with a class method
99:38 - decorator class
99:41 - method what we're going to do is Def
99:43 - find a method to get the count the class
99:47 - variable of
99:48 - count this method will be called get
99:52 - count
99:53 - rather than self as the first parameter
99:56 - we'll be working with a class CLS
99:59 - meaning
100:00 - class I will return an F
100:03 - string total number of
100:08 - students add a
100:10 - placeholder CLS
100:13 - count Let's test this to call a class
100:17 - method you take the name of the class
100:19 - followed by the class method get count
100:23 - and then then we do need to print
100:28 - this what is the count of my current
100:30 - students total number of students is
100:33 - zero let's create a few student objects
100:37 - we will create student one equals called
100:39 - the student Constructor we have to pass
100:42 - in a name and a GPA let's say that the
100:45 - name is SpongeBob SpongeBob has a GPA of
100:49 - 3.2 we'll create two more students
100:53 - student two student three student two
100:57 - will be
100:58 - Patrick Patrick has a
101:02 - 2.0 then Sandy Sandy Smart in fact she's
101:06 - a genius she has a perfect
101:09 - 4.0 now let's count the number of
101:12 - students total number of students is
101:15 - three when we call this class
101:18 - method we can access or modify class
101:22 - data this class variable of count rather
101:26 - than using self we use CLS for the
101:29 - class let's create one more class method
101:33 - this time I'll calculate the total GPA
101:35 - of all my
101:37 - students we'll need a class variable to
101:40 - hold that data let's say total GPA
101:45 - equals
101:46 - z whenever we construct a student object
101:50 - we will access our class of student get
101:53 - the total
101:55 - GPA then add plus equals this student's
101:59 - GPA that we have just created basically
102:03 - speaking the total GPA this variable is
102:06 - going to accumulate all of the GPA of
102:08 - every student and store it as a sum to
102:12 - find the average we're going to divide
102:13 - it by the count the number of students
102:16 - we'll do that within a class method to
102:18 - create a class method again we need to
102:20 - use the class method decorator
102:24 - I will Define a method of get average
102:28 - GPA the first parameter is CLS for
102:32 - class I will check if CLS count the
102:37 - count variable of my
102:39 - class is equal to zero that means if we
102:43 - have no students if that's the case if
102:45 - there's no students we're going to
102:47 - return
102:48 - zero because otherwise we're going to
102:50 - divide by zero and we'll get an error
102:54 - else we're going to return an F
102:57 - string follow this formula we're going
103:00 - to take the total GPA of my class class.
103:04 - total GPA divided by class. count the
103:08 - number students we have that's how to
103:11 - calculate the average
103:13 - GPA after getting the count of the
103:15 - number students to access a class method
103:18 - we take the name of the class student
103:21 - call the class method get average
103:24 - GPA then I will print
103:30 - it total number of students is three the
103:34 - average GPA is 3.06
103:38 - repeating after calculating the average
103:40 - I'm going to add a format specifier of
103:43 - 2f just around to two decimal
103:46 - places and I'll add average GPA colon
103:50 - space then we'll calculate the average
103:55 - all right everybody those are class
103:57 - methods instance methods are best for
104:00 - operations on instances of the class any
104:03 - objects static methods are best for
104:06 - General utility functions which do not
104:09 - need access to class data class methods
104:12 - are best used when we're working with
104:14 - class level data or we require access to
104:17 - the class itself such as when we're
104:19 - working with class variables rather than
104:22 - using self as the first parameter we're
104:24 - going to use CLS meaning class and well
104:27 - everybody those are class methods in
104:31 - Python yo what's going on people so
104:34 - today I'm going to explain magic methods
104:36 - in Python magic methods are also known
104:39 - as Dunder methods meaning double
104:41 - underscore you typically find these
104:43 - within classes we're already familiar
104:45 - with one of them are Dunder init method
104:48 - we have double underscores on the left
104:49 - and double underscores on the right but
104:52 - there are others I'll cover a few of the
104:54 - more beginner friendly ones so what
104:56 - these methods do is that they're
104:58 - automatically called by using some of
105:00 - pythons built in operations such as
105:03 - printing an object seeing if two objects
105:05 - are equal greater than or less than when
105:09 - we use many of Python's built-in
105:10 - operations with objects we can Define
105:13 - and customize the behavior of those
105:15 - objects so in this demonstration I'm
105:18 - going to create a class of book we will
105:21 - construct some book objects
105:23 - we will Define a magic method a Dunder
105:26 - method of init to initialize these
105:29 - objects for a book we need a title an
105:33 - author and the number of pages we'll say
105:37 - num
105:39 - Pages self. tile equals
105:43 - title self.
105:46 - author equals
105:48 - author self. number of pages
105:53 - equals number of pages when we call the
105:55 - class of book we Are automatically
105:57 - calling Dunder init so let's create a
106:00 - book object book one equals
106:04 - book we need a title an author and
106:07 - number of pages so since we're dealing
106:09 - with this topic of magic methods I'll
106:11 - pick some fantasy related books for my
106:14 - first book I'll pick the
106:15 - Hobbit that's the title the author is
106:21 - JRR token the number of pages is
106:25 - 310 so for my next
106:28 - book book
106:30 - two I will
106:32 - pick Harry
106:35 - Potter and the philosopher
106:42 - stone the author is JK
106:46 - Rowling the number of pages is
106:50 - 223 then we have book three
106:55 - for my third book I will pick The
106:58 - Lion the
107:00 - Witch and the
107:04 - Wardrobe the author is CS
107:08 - Lewis the number of pages is
107:12 - 172 okay here are my three book objects
107:15 - when we call the class of book and pass
107:17 - an arguments we will call the dunder
107:20 - init method it's a magic method it's
107:23 - automatically called behind the scenes
107:25 - within this magic method we can Define
107:28 - and customize the behavior of objects
107:30 - and in this example we're just assigning
107:32 - the attributes of title author and
107:35 - number of pages that is one built-in
107:38 - operation of python what would happen if
107:40 - I was to print book one directly to the
107:44 - console here's what happens well we're
107:47 - given a memory address here's book two
107:51 - and book three
107:53 - well we can customize this
107:57 - Behavior we will use the dunder string
108:01 - method double underscore St Str meaning
108:04 - string double underscore again we have
108:07 - one parameter of self instead of
108:10 - returning a memory address we can
108:12 - customize this
108:13 - behavior let's instead return an FST
108:17 - string I'll add two placeholders we will
108:20 - display self. tile the title of the book
108:24 - by self.
108:26 - author and I'll place the title within
108:29 - single
108:30 - quotes now let's print book one we have
108:34 - The Hobbit by JRR
108:36 - tolken let's print book
108:39 - two Harry Potter and the philosopher
108:41 - stone by JK Rowling and book three The
108:45 - Lion the Witch and the Wardrobe by CS
108:48 - Lewis so that is thunder string we can
108:51 - return a string represent a of the
108:53 - object when we print it directly to the
108:56 - console here's another Dunder method we
108:59 - can check to see if two objects are
109:01 - equal I will
109:03 - print is book one equal to book
109:08 - two that gives me
109:11 - false if they were to have the same
109:15 - title the same
109:17 - author and the same number of
109:20 - pages then python would say they're not
109:23 - equal still so let's customize this
109:29 - Behavior we will Define a method of
109:32 - Dunder equals which is just
109:35 - EQ for parameters we have self the first
109:37 - book we're examining in this case book
109:40 - one and other other means the other book
109:44 - we're examining two objects for
109:46 - equality to do that we'll see if the
109:49 - title of two books and the author is the
109:52 - same
109:54 - we'll disregard the number of pages you
109:57 - can have two different versions of the
109:58 - same book they might have different font
110:00 - sizes or the dimensions of the physical
110:03 - Pages might be
110:04 - different so we will return a Boolean
110:07 - value we will examine if self that's the
110:11 - first book is the title
110:13 - attribute equal to our other books title
110:18 - and is the author of the first book
110:21 - self. author
110:23 - equal to our other books
110:25 - author if I were to run this we get
110:28 - false book one does not equal book two
110:32 - but if they have the same title I'm
110:34 - going to replace these and the same
110:39 - author then they would be equal and
110:42 - we'll disregard the number of pages
110:44 - let's say that with this version of The
110:46 - Hobbit they're using a smaller font size
110:48 - so there's less
110:50 - Pages we're using under equals to
110:53 - compare if two objects are
110:55 - equal what if I was to print book two is
111:00 - less than book
111:02 - three like what does that even mean and
111:05 - I'm just going to get rid of these two
111:08 - lines type error less than is not
111:11 - supported between instances of book and
111:14 - book so we can't use less than on two
111:17 - objects but we can customize that
111:19 - behavior by using Dunder less than which
111:22 - is just LT we're examining one book and
111:27 - the other
111:27 - book self and
111:30 - other let's compare the number of pages
111:34 - we'll compare if the pages of book two
111:37 - is less than book three we will return a
111:40 - Boolean
111:41 - value is self. number of pages less than
111:47 - other. number of
111:50 - pages so now this should not give us an
111:53 - error book two does not have less Pages
111:57 - than book
111:58 - three another would be greater then I'll
112:01 - just copy what we have Dunder GT for
112:05 - greater than for our first book of self
112:08 - is it greater than the number of pages
112:10 - of the other
112:15 - book well that's true the number of
112:18 - pages of book two is greater than book
112:21 - three let's let's use Dunder add to add
112:24 - the pages of two books together what
112:26 - would happen if I were to add two books
112:28 - together book two plus book
112:30 - three well we get a type error
112:33 - unsupported operand for book and
112:36 - book well to customize the behavior of
112:39 - addition we will Define Dunder
112:43 - add we have self and other for the other
112:47 - object let's add the pages together of
112:49 - two books maybe we need a summer reading
112:52 - list and we would like to see what the
112:53 - total number of pages is I will return
112:58 - self. number of pages attribute plus our
113:02 - other books number of
113:07 - pages that would give me
113:09 - 395 that's 223 + 172 heck I'll even put
113:14 - this within an F string CU why not
113:23 - then I will add the word
113:24 - Pages 395
113:28 - Pages within an object we can search for
113:31 - a keyword within one of the attributes
113:35 - so let's find the word the lion within
113:37 - book three to do that I would write a
113:39 - statement like this Lion in book
113:45 - 3 Type error argument of type book is
113:49 - not
113:50 - iterable we will Define Define Dunder
113:56 - contains besid self we will pass in a
113:59 - keyword a keyword that we're searching
114:03 - for I will return then we'll use the in
114:06 - membership operator is our keyword in
114:11 - self. tile I'm looking for the word lion
114:14 - that's going to return true if lion is
114:17 - in the title of this book or is our
114:20 - keyword
114:22 - in self. author maybe we're searching
114:25 - for an author let's try that
114:29 - again that returns true lion is in book
114:33 - three however lion is not within book
114:36 - one that's
114:38 - false is rolling in book two that's the
114:43 - author that is true is rolling in book
114:48 - three that is
114:50 - false that is thunder contains
114:53 - we are searching for a keyword in an
114:57 - object now we could search for a key
114:59 - given an object for book one we'll use
115:02 - the index operator and look up an
115:05 - attribute let's get the title of book
115:09 - one the default behavior is that we get
115:13 - a type error book object is not
115:17 - subscriptable so to customize this
115:19 - Behavior we will use Dunder get
115:25 - item besides self we have one parameter
115:28 - of key we're accessing book attributes
115:31 - by indexing with this object return the
115:35 - value at this key what's that
115:38 - attribute we will check if our key that
115:41 - we
115:42 - receive is equal to title which it is in
115:47 - this case we will return self. tile
115:51 - What's the title of the
115:53 - book so that would give me The Hobbit
115:56 - here's book two and book
116:00 - three what if the key is
116:05 - author none we didn't set that up
116:09 - yet if key is equal to
116:13 - author then return self.
116:18 - author the author of book three is CS
116:22 - Lewis two is JK
116:26 - rolling book one is JRR
116:30 - tolken what about number of pages num
116:35 - Pages well we're not set up for that
116:37 - yet I'm going to turn this into an else
116:40 - if
116:41 - statement else if
116:44 - key is equal to
116:47 - num
116:49 - Pages then we will return self.
116:53 - num
116:55 - Pages the number of pages in book one is
116:59 - 310 book two is
117:03 - 223 book three is
117:06 - 172 what if there is no key otherwise if
117:09 - there is no matching key I'll add an
117:11 - else statement let's return an F
117:16 - string key
117:19 - placeholder R key that we pass in as an
117:21 - argument
117:23 - was not
117:25 - found what do books not have well they
117:28 - don't have audio I guess unless it's an
117:30 - audio book is there a key of audio in
117:34 - book
117:35 - three there is not key audio was not
117:38 - found and I'll place that within single
117:42 - quotes much better all right everybody
117:45 - so those are magic methods also known as
117:48 - Thunder methods meaning double
117:50 - underscore they are automatic called by
117:53 - many of Python's built-in operations
117:55 - they allow developers to define or
117:58 - customize the behavior of objects when
118:00 - we use those built-in operations and
118:03 - well everybody those are magic methods
118:05 - in
118:06 - Python hey everybody so in today's video
118:08 - I got to talk about the property
118:10 - decorator in Python the property
118:12 - decorator allows us to define a method
118:14 - as a property we can access it like it's
118:17 - an attribute one of the benefits is that
118:19 - when Reading Writing or deleting
118:21 - attributes we can add additional Logic
118:24 - the property decorator gives us a getter
118:26 - method to read a Setter method to write
118:29 - and a deleter method to delete when
118:31 - working with attributes in this example
118:33 - we'll create a class of
118:36 - rectangle we need a Constructor let's
118:38 - define
118:39 - that when constructing a rectangle
118:42 - object we will need a width and a
118:45 - height we will assign the attribute of
118:49 - width equal to the width that we
118:51 - received when constructing this object
118:54 - self. height equals
118:57 - height let's construct a rectangle
118:59 - object rectangle equals
119:04 - rectangle we need to pass in a width and
119:07 - a height then I will print my
119:10 - rectangle's width rectangle. width and
119:13 - the
119:14 - height rectangle.
119:18 - height with my rectangle the width is
119:20 - three the height is four using the
119:22 - property decorator when reading these
119:25 - attributes of width or height I can
119:27 - write some additional logic let's say
119:29 - that when accessing the width or the
119:31 - height I would like to display one digit
119:33 - after the decimal then add centimeters
119:36 - here's one way in which I can do that
119:39 - for each of these attributes I'm going
119:41 - to create a method we will Define a
119:43 - method of width no parameters beside
119:46 - self for now I'll write
119:49 - pass and Define he height preceding each
119:54 - of these methods I will use the property
119:57 - decorator so at
120:00 - property now when accessing the width or
120:03 - the height will be returned with
120:05 - whatever is Within These methods of
120:06 - width and
120:07 - height but there's one change we're
120:09 - going to make to these attributes we'll
120:11 - set these attributes to be private
120:13 - prefix each of these attributes with an
120:17 - underscore this tells you and other
120:19 - developers that these attributes they're
120:22 - meant to be protected they're internal
120:24 - we shouldn't access the width or the
120:26 - height directly outside of this class
120:29 - technically we could I will access the
120:31 - internal version of width and
120:33 - height we get three and four but we do
120:36 - have a warning access to a protected
120:38 - member width of a class that applies to
120:41 - height as well our width and our height
120:44 - are only meant to be used inside of this
120:46 - class if we need to get the width and
120:48 - the height we will do so through these
120:50 - getter methods provided by the property
120:53 - decorator so when accessing the width
120:56 - let's return an F
120:59 - string I will access
121:02 - self. private
121:04 - width add a format specifier to display
121:08 - one digit after the decimal 1f followed
121:11 - by
121:12 - cenm we'll do this with the height as
121:15 - well we will return self. private height
121:22 - so now when we access the width or the
121:25 - height we will do so using these getter
121:28 - methods if I access these private width
121:30 - and height attributes
121:34 - instead again they will be three and
121:36 - four it's kind of like their raw these
121:39 - attributes are meant to be used
121:40 - internally inside of the class so that's
121:43 - the point of a getter method we can add
121:45 - additional logic when reading one of
121:47 - these attributes when we Tred to get
121:50 - them we can also add Setter methods if
121:53 - we would like to set or write these
121:55 - attributes here's how let's take our
121:58 - width we will create a decorator of at
122:01 - width.
122:03 - Setter when attempting to set the width
122:05 - we will do so using this method we will
122:07 - Define our method name of width we will
122:10 - have one parameter a new width we don't
122:14 - want the parameter name to be the same
122:16 - as the method name that's why we're
122:18 - naming it something
122:20 - different when setting the width let's
122:22 - check to see if the new width is greater
122:26 - than
122:27 - zero if so we will take self. private
122:31 - width equals our new
122:34 - width else let's print something let's
122:40 - print width must be greater than
122:46 - zero and let's do this with the height
122:52 - height. Setter
122:55 - Define height pass in a
122:58 - new height if our new height is greater
123:02 - than zero assign self. private height
123:06 - equals the new height else print height
123:11 - must be greater than
123:13 - zero before printing the width and the
123:16 - height let's take our
123:18 - rectangle width set it to be zero then
123:21 - see what happen
123:22 - s well we get that message width must be
123:26 - greater than zero if I were to set width
123:29 - to be
123:30 - five well that does work our width is
123:33 - now five let's change the
123:36 - height rectangle.
123:39 - height I will set this to be Nega
123:42 - 1 height must be greater than zero and
123:45 - the height hasn't changed what about
123:48 - six six does work when using these
123:51 - Setter methods we can add additional
123:54 - logic when writing or changing one of
123:56 - these attributes these are Setter
123:59 - methods now if you need to delete an
124:01 - attribute here's
124:04 - how there is a delete keyword we will
124:07 - delete our rectangle's
124:09 - width and delete our rectangle's height
124:12 - in this series we really won't be using
124:14 - the delete keyword but you should still
124:16 - know that it
124:17 - exists so we will create a deleter
124:20 - method
124:22 - at take one of the attributes in this
124:24 - example with we will create a deleter
124:27 - method the method name will be width the
124:31 - name of the
124:33 - attribute there will be no parameters
124:35 - besides
124:36 - self we will delete
124:40 - self. private width then let's print
124:44 - something just to confirm that this was
124:47 - deleted width has been
124:50 - deleted same thing applies to
124:54 - height take the attribute of height
124:58 - Define height delete private
125:05 - height height has been
125:10 - deleted when deleting our width or our
125:12 - height we get that confirmation message
125:15 - width has been deleted and height has
125:17 - been
125:18 - deleted all right everybody so that is
125:20 - the property decorator we can define a
125:22 - method as a property meaning it can be
125:25 - accessed as if it was an attribute one
125:28 - of the benefits is that we can add
125:29 - additional logic when we read write or
125:32 - delete attributes the property decorator
125:35 - gives us a getter Setter and deleter
125:37 - method getter methods to read Setter
125:40 - methods to write and deleter methods to
125:44 - delete and well everybody that is the
125:46 - property decorator in Python

Cleaned transcript:

hey everybody so we have finally made it to Python objectoriented Programming this is a very important topic in Python an object is a bundle of related attributes and methods attributes are similar to variables to describe what the object has so look around you right now you are surrounded by different Real World objects next to me I have a phone a cup and a book each of these objects can have different attributes to represent it for example an attribute of the phone next to me could be version number I could set that to be 13 is on could be another attribute is the phone powered on or not that could be true or false or even a price I have a cup next to me what liquid is within the cup in this case coffee what's the temperature of the cup is the cup empty is empty or even a book What's the title of the book that could be a string how many pages does the book have Pages could be another attribute now objects also have the capability to do things they have methods which are functions that belong to an object people mix up functions and methods all the time they're technically different even when teaching I tend to make that mistake calling a method a function and a function a method usually people know what you're referring to though a method is a function that belongs within an object what are some actions these objects can perform with a phone you can make a call or receive a call turn the phone on or turn the phone off those could all be functions with a cup you could fill the cup drink from the cup or empty the cup with a book you can open the book read the book and close the book an object is a bundle of related attributes and methods they can represent real world items to create many objects we'll need to utilize a Class A Class is a type of blueprint used to design the structure and layout of an object we need to design what our objects have their attributes and what they can do their methods we will create a class of car we will create some car objects class car to construct a car object we need a special type of method called a Constructor it works similarly to a function we will Define a function of double underscore init meaning initialize double underscore again and then follow this with a set of parentheses this is our Constructor method we need this method in order to construct objects it's a Dunder method Dunder meaning double underscore that's a future topic I don't want you to be overloaded with information right now all you need to know is that we need this method in order to create objects this method behaves similar to a function we need to set up the parameters self is already provided to us self means this object we're creating right now this car so what are some attributes that a car should have a model that could be a string like a BMW a year that could be a number a color let's add a Boolean of for sale is the car for sale or not that's true or false to assign these attributes we're going to access self self dot the name of the attribute self. model equals the model we receive these are parameters when we receive the name of a model we will assign it to this object let's do this with year self. year equals year self. color equals color self do for sale equals for sale this is an example of a few attributes that a car might have a model year color and if it's for sale or not represented by a Boolean now to construct a car object we need a unique name for this car let's just say car one car one equals take the name of the class add a set of parentheses to invoke The Constructor we're going to do this this almost exactly like a function we have parameter set up we need to send a matching number of arguments self is provided to us behind the scenes automatically we need a model year color and if it's for sale or not so pick a car of you're choosing I'll pick my favorite car the model will be a Mustang for the year I'll go with the recent year of 2024 a color I'll pick red is the car for sale I like this car so no I will set that to be false make sure false is capitalized let's see what happens if I attempt to print our car object of car one what we're given is the memory address of this car object where it's located but I would like one of the attributes located at this memory address instead of printing the object itself we're going to access one of the attributes found within this car we will follow the name of the car with a DOT this dot it's known as the attribute access operator I would like the model of car one that would give me Mustang let's access the year take the name of the car car 1 dot the year 2024 followed by the color car1 docolor red car one is it for sale we'll print that that is false now let's create a second car we're going to reuse this class to create a second car we will create Car 2 equals car we'll pass in some different arguments a Corvette the year will be 2025 the color will be blue is this car for sale let's say that is true instead of accessing car 1's attributes let's access car 2's attributes that would give us a Corvette the year is 2025 the color is blue for sale is set to true or even a third car car 3 equals a new car we will pass in a string of charger the year 2026 the color will be yellow is this car for sale let's say that is true as well then I will print car 3's attributes the model is charger the year is 2026 the color is yellow for sale is set to True with classes they can take up a lot of space for better organization you can place them within a new python file so let's cut our class and we will create a new python file within our project folder file new python file the name of this python file is going to be all lowercase car then we will paste the class that we cut originally class car which has a capital c so from our main python file we're going to import our car file our car module modle from the name of the module car import the name of the class car then when I run this program nothing should change we should still have access to all of our car objects you could either keep your classes within your main python file or import them if you would like to organize things let's talk about methods methods are actions that our objects can perform within our class we will Define a method of Drive self is going to be provided to us when we invoke the drive function let's print you drive the car what other things can cars do let's stop we will print you stop the car let's take car one access the drive method you drive the car car 2 also has a drive method you drive the car same thing with car 3 you drive the car let's access the stop method car one. stop car 2. stop and car 3. stop these methods are identical for each car object instead of printing the word car let's insert the model of the car I will convert these print statements to F strings instead of the word car let's add a placeholder let's add self. model self is referring to the object we're currently working with use the attribute axis operator followed by the name of the attribute let's also do this with the stop method self do model let's take car one use the drive method you drive the Mustang car one. stop you drive the Mustang you stop the Mustang let's do this with Car 2 you drive the Corvette you stop the Corvette car three you drive the charger you stop the charger now within our F strings let's also insert let's insert the color I'll add a placeholder self. color do this with stop as well self. color you drive the yellow charger you stop the yellow charger car one you drive the red Mustang you stop the red Mustang card two you Drive the blue Corvette you stop the blue Corvette let's add one last method let's create a method to describe our car we'll print the details of the car let's print I'll use an F string add three placeholders let's print self doye followed by self. color then self. model we'll take car 1 use the describe method that we created describe car 1 car 1 is a 2024 red Mustang describe Car 2 Car 2 is a 2025 blue Corvette car 3 is a 2026 yellow charger all right everybody so those are objects in Python an object is a bundle of related attrib attributes attributes are variables that an object has and methods methods are functions that belong to an object they Define what this object can do and well everybody that is a summary of objectoriented programming using python hey everybody today I got to talk about class variables in Python class variables are shared among all instances meaning objects created from a class instance variables are defined inside of the Constructor class variables are defined outside of the Constructor with class variables they allow you to share data among all objects created from the class with instance variables each object has their own version with a class variable all those objects share one variable here's an example we will create a class of student we also need a Constructor when we create a student object object this Constructor is automatically going to be called but we need to pass in some arguments we are provided with self self refers to the object we're currently working with we will set up a name parameter and an age parameter we will assign self the object we're currently working with set the name attribute to equal the data for the name that we receive from this parameter and self. AG equals age let's construct two student objects we will have student one equals then call the Constructor for student so type the name of the class followed by a set of parentheses to invoke it this will automatically call The Constructor but we have to pass in data for the name and the age for the name let's pass in SpongeBob because basically everybody in the world knows who SpongeBob is I don't know how old SpongeBob is we'll say he's 30 we will create another student object which we will refer to as student 2 we will call the Constructor of our student class pass in data for the name and age student two will be Patrick Patrick will be 35 okay let's make sure this works let's print student 1's name followed by student 1's age and we should get SpongeBob and his age is 30 let's print student 2's name and student 2's age Patrick Patrick is 35 now we'll create a class variable class variables are defined outside the Constructor and they are shared among all objects created from that class each object has their own name and age property these are instance variables but class variables are defined outside the Constructor each object will share this one variable so if we're working with students let's say there is a class variable of class year what is the graduating year of this class 2024 now let's print student 1's graduating year print student one. class year okay so SpongeBob has a class year of 2024 that's when he's graduating let's check student two Patrick is ages 35 his graduating class year is 2024 now with class variables you can access them through any one object such as student one or student 2 it's good practice to access a class variable by the name of the class rather than any object created from the class since we're accessing class year we'll access this class variable by the name of the class of student make sure the S is capital this helps with Clarity and readability if I was looking at this print statement I can tell that class year is a class variable because we're accessing it directly from the class and not any instance from this class without looking at this class I can't tell if class year is an instance variable or a class variable but if I access it via the class name it's more explicit so it's good practice to access a class variable by the class name itself and not any one instance of this class let's create another class variable we'll create a class variable to keep track of how many students we have created this class variable will be num students meaning number of students equals zero So within our Constructor we can write any code that we want this code will always be executed when we instantiate an object I would like to take our number of students and increment it by one each time we construct a new student object so instead of using self self refers to the object we're currently working with if we're constructing student one just imagine we're replacing self with student one or student 2 if we were constructing student two if we're going to be modifying a class variable in place of self we'll use the name of the class student access our class of student get the class variable of number of students then I will increment it by one plus equals 1 we are constructing two student objects I will print X access our class of student get the number of students and print it we're constructing two student objects if I print the number of students that we have it should be two then just to be sure that this is working let's construct a third student object student 3 equals student this student will have a name of Squidward Squidward's age will be 55 now we have three students and for good measure let's construct one more student 4 equals we will create a new student with a name of Sandy sy's age will be 27 the number of students is now four just as an exercise using an F string let's print the student classes class year as well as the number of students I will print use an F string my graduating class of let's add a placeholder access the class of student then access the class Year my graduating class of 2024 has then we need the number of students We'll add a placeholder access the class of student access the number of of students has blank students let's see if this works my graduating class of 2024 has four students now if I were to change 2024 to 2025 my graduating class of 2025 has four students let's print the name of each student these are instance variables student one. name then we need Student two three and four my graduating class of 2025 has four students SpongeBob Patrick Squidward Sandy all right everybody so those are class variables class variables are shared among all instances of a class they are defined outside of the Constructor the benefit is that they allow you to share data among all objects created from that class and well everybody those are class variables in Python what is going on everybody so today I got to talk about inheritance in Python inheritance allows a class to inherit the attributes and methods from another class much like how a child in real life can inherit traits from A parent by having a class inherit attributes and methods from another class this helps with code reusability and extensibility in this example we're going to create an animal class the dog cat and mouse class will inherit attributes and methods from the animal class we will create a class of animal then I will Define The Constructor when we construct an animal object let's pass in a name it's not required but it might be good for this example we will assign the attribute of name equal to the name we receive let's also add an attribute of of is alive whenever we create an animal we will set there is alive attribute to be true and that is a capital T all animals can eat Define eat we will print using an F string add a placeholder self. name the name of this animal is eating all animals should be able to sleep Define sleep print I'll use an FST string insert self. name is sleeping and that is all we need for the animal class let's define class dog for a child class to inherit the attributes and methods from another class after the class name that's going to inherit we need to add an inheritance list with the set of parentheses then list the name of the class we're inheriting from the parent parent the dog class is going to inherit all of the attributes and methods of its parent animal for the time being as a placeholder I'll add pass just to demonstrate this class cat is also going to inherit from animal and class Mouse will also inherit from animal okay I will collapse this for now we'll create a dog object dog equals dog then pass it a name for this dog because we have one parameter set up of name this dog will be named Scooby as in ScoobyDoo cat equals call the cat Constructor this cat will be named Garfield and mouse mouse equals Mouse our Mouse will have a name of Mickey even though there's nothing within this dog cat or Mouse class we should still have these attributes and these methods if you inherit the animal class you should have a name attribute and is alive attribute set to true you can eat and you can sleep let's print our dog's name dog. name Scooby print dog. is alive our dog is alive that is true let's have our dog object use the eat method Scooby is eating and sleep dog dos sleep Scooby is sleeping let's replace dog with cat the name of the cat is Garfield Garfield is alive Garfield is eating Garfield is sleeping and Mouse replace any instance of cat with mouse our mouse's name is Mickey Mickey is alive Mickey is eating Mickey is sleeping even though these children classes are empty we're still inheriting these attributes and methods from its parent of animal this is convenient because you don't need to copy and paste these attributes and methods for every single class for example if I were to copy these attributes and methods and paste them well we have a lot more code to write and as a consequence if I need to make a change to one of these methods I would have to do that to every single instance of this method for example let's replace is sleeping with is asleep well now I need to find every single Sleep Method and change it manually it's not too bad if you only have a few classes but imagine if you have hundreds of classes that's going to take a lot of work it's a lot easier to write the code once and then reuse it and I only need to make that change in one place rather than make that change many times so let's change is sleeping to is asleep and see if that works again Mickey is asleep let's replace Mouse with dog Scooby is asleep not only that but with children classes they can have their own attributes and methods that are different from one another so dogs have all these attributes and methods and they can speak let's create a speak method and I will print a unique message for dogs woof cats will also have a speak method but it's going to be different cats will meow then for our Mouse class they will squeak let's have our dog speak woof let's have our cat speak meow and our Mouse squeak all right everybody so that's an introduction to inheritance inheritance allows a class to inherit attributes and methods from another class much like in real life a child can inherit TR trates from a parent these are also known as sub and super classes which is a topic for another day inheritance helps with code reusability and extensibility if all of these children classes inherit these attributes and methods from another class we only need to write that code once and not copy it for every single class that needs it we can write and change the code in one place for better reusability and extensibility and well everybody that is an introduction to inheritance in Python hey everybody so today we got to talk about both multiple and multilevel inheritance we'll begin with multiple inheritance that's when a child class inherits from more than one parent class for example a class of C can inherit the traits from both class A and B in Python you can have more than one parent multilevel inheritance we'll talk about near the end of this topic so in this example we're going to create two parent classes prey I'll write pass for now and Predator we'll create a class of rabbit a class of Hawk then class fish rabbit Hawk and fish are going to be children classes prey and predator will be parents if one of these classes rabbit hawk or fish inherit from prey they get the ability to flee we will Define a method of flee all we'll do in this example is print the following text this animal is fleeing if you're a predator you get the method to hunt Define hunt we will print this animal is hunting rabbits they will inherit from the prey class they're typically not Predators except that one rabbit and montypython and the Holy Grail that's the exception rabbit will inherit the prey class then it gets access to a flea method Hawks are predators they will inherit the Predator class now fish they will hunt smaller fish and flee from bigger fish you could consider fish both prey and predators so they will inherit both classes we will use multiple inheritance they will inherit everything from the prey class and the Predator class now let's see if this does in fact work now we'll create a rabbit object rabbit equals rabbit there are no parameter setup we don't need to send any arguments to the Constructor Hawk equals Hawk and fish equals fish so so let's take our rabbit object and they should have a flea method rabbit. flea method this animal is fleeing but they do not have a hunt method because they're not Predators rabbit object has no attribute hunt Hawks can hunt they Predators they inherited that method this animal is hunting but they can't flee they're not prey Hawk object has no attribute flea fish can do both they inherit from the prey class and the Predator class fish. flee this animal is fleeing fish. hunt this animal is hunting children classes can inherit from more than one parent which is what we did for fish they are both prey and predators whereas in rabbits are just prey Hawks are just Predators if you need to inherit from more than one parent you just add that additional class to The Inheritance list with multilevel inheritance a parent can inherit from another parent we will create a class of animal and for now I'll write pass prey and Predator are going to inherit from the animal class so we need to add animal to each inheritance list let's say if you're an animal you get a method to eat all animals will eat print this animal is eating and you can sleep Define sleep print this animal is sleeping so think of rabbit Hawk and fish as children classes prey and Predator are those class's parents and animal is the grandparent pray and Predator will inherit everything that the animal class has rabbit Hawk and fish will inherit everything the prey and Predator classes have so now our rabbit Hawk and fish classes should have the ability to eat and sleep and we'll test that rabbit. eat this animal is eating rabbit. sleep this animal is sleeping let's check out fish fish. eat this animal is eating fish do sleep this animal is sleeping okay we're going to expand upon our example a little bit let me zoom out each of our objects is going to have a name our rabbit will have a first name of bugs Hawk will be Tony as in Tony Hawk our fish will be Nemo within our classes we don't have any Constructor set up in which class should we assign the name attribute let's do so within our animal class so we will Define a Constructor to assign these attributes we will receive a name we'll assign self. name equals name now with these other classes if you're not assigning any attributes or if you don't need any other initialization logic you don't need a Constructor we'll implicitly use the Constructor RoR we inherit from the parent let's convert each of these print statements to an F string replace animal with self. name now let's have our rabbit use the E method oh we should get rid of this there we go bugs is eating rabbit. sleep bugs is sleeping rabbit. flee bugs is fleeing let's check out our Hawk Hawks don't have a flea method because they're Predators not prey let's eat Tony is eating let's sleep Tony is sleeping let's hunt Tony is hunting let's check our fish next our fish can eat Nemo is eating our fish can sleep Nemo is sleeping they can flee Nemo is fleeing and Hunt Nemo is hunting okay everybody that is both multiple and multilevel inheritance with multiple inheritance a child can inherit from more than one parent class you just add each additional class to The Inheritance list with multilevel inheritance a child can inherit from a parent which inherits from another parent Class C can inherit from B where Class B inherits from a think of C as the child b as the parent and a as the grandparent c will have all the attributes and methods even available within the grandparent class of a and well everybody that that is both multiple and multilevel inheritance in Python hey everyone welcome back so today I got to talk about abstract classes in Python an abstract class is a class that cannot be instantiated on its own abstract classes are meant to be subclassed they're supposed to be parents to children classes they can contain abstract methods which are declared but have no implementation abstract classes have a few benefits we can't create an object from a class that's abstract abstract classes you could say are incomplete we don't want to create an object that's incomplete also any children that inherit from an abstract class if there's any abstract methods we have to implement them so let me give you a demonstration we're going to create a Class A vehicle for now I'll write pass to work with abstract classes we'll need to import ABC ABC meaning abstract base classes we need import ABC all capital meaning abstract Base Class as well as abstract method so my vehicle class it's going to be an abstract class we will inherit from ABC the abstract based class I don't want myself or any other developers to be able to create a vehicle object I will make this vehicle an abstract class also I can add some abstract methods these methods will be inherited by its children to declare an abstract method we need to use a decorator at abstract method so what should all vehicles be able to do let's say go and stop if you're a vehicle you can go with abstract methods we declare them but we don't Define them we'll Define them within each of the children children classes that inherit from vehicle let's create another abstract method abstract method Define stop if you're a vehicle you can stop all right we have finished our abstract class A vehicle just to demonstrate that we can instantiate an object from this class let's attempt to do so and see what happens I will attempt to create a vehicle object vehicle equals vehicle and then run this type error can instantiate abstract class vehicle with abstract methods go and stop this is good this is what we want our vehicle class is incomplete we don't want to accidentally make a vehicle object if we were it's kind of like the invisible boatmobile from SpongeBob instead we will create some children to inherit from this class so now we will create a class of car which will inherit from vehicle car is the child vehicle is the parent but we are receiving a warning Class Car must Implement all abstract methods what we're saying is hey if you inherit from the vehicle class you need to include these abstract methods so I'm not going to currently let's just see what happens I will attempt to create a car object and run it type error can't instantiate abstract class car with abstract methods go and stop if a class is inheriting from a parent that's abstract and there's abstract methods we have to finish defining those methods So within our car class really I'll just copy this because I'm lazy our method is go we will print you drive the car we also need stop I will print you stop the car okay let's see if this works this has run with no problems I will have my car go then stop we're calling the go method then the stop method you drive the car you stop the car let's create a few more children for the vehicle class class motorcycle will inherit from the vehicle class again we have to implement the abstract methods found within the parent go and stop for go I will print you ride the motorcycle then with stop you stop the motorcycle motorcycle equals motorcycle we're calling the Constructor then I will have our motorcycle go then stop you ride the motorcycle you stop the motorcycle all right last example let's say we create a boat class which will inherit from the abstract class A vehicle I will include a go method where I will print you sail the boat but I will forget to add a stop method because I'm not paying attention let's attempt to create a boat well what the heck is this type eror can instantiate abstract class boat with abstract method stop then I'll look over my code and see oh I forgot to include a stop method with including abstract methods within a parent it acts as a set of checks and balances all vehicles should be able to go and stop if I forget to Define one of these methods well we'll receive a type error if we didn't I may not have noticed that we're missing a method so now we need to include that stop method I will print you anchor the boat this seems to have run with no problems I will have my boat go and stop you sail the boat you anchor the boat all right everybody so those are abstract classes it's a class that can't be instantiated on its own we can't create any objects from this class we don't want to because it's well incomplete they're meant to be subclassed they can contain abstract methods which are declared but we don't finish defining them we Define them within the children classes in this example car motorcycle and boat and well everybody those are abstract classes in Python hey everybody so today I got to talk about the super function in Python super is a function it's used within a child class to call methods from a parent class the child class is the subass the parent class is the super class hence why this function is named the super function using the super function it allows you to extend the functionality of the inherent methods here's an example we'll create a few shape objects we'll need to set up the classes though we'll have class Circle for the time being I'll just write pass we'll fill it in later class square and class triangle for each of these classes in order to instantiate objects we'll need a Constructor we will Define our Constructor our innit method when creating circles what sorts of attributes should a circle have let's say a color what's the color of the circle is it filled or not filled will be another attribute and a radius then let's assign these self. color equals the color that we receive self. fil equals filled self radius equals radius let's do this with the square and Triangle really I'll just copy our Constructor and paste it squares don't have a radius with a square the width and the height are the same let's replace radius with width we'll also keep the color and filled attributes self. width equals width now with triangles again let's copy our Constructor we'll need a width and a height self. height equals height so with programming we try not to repeat ourselves if we don't have to what do all of these classes have in common they all share the attributes of color and filled the ways in which they are different is that Circle has a radius attribute square has a width triangle has a width and a height if we have to make any changes to one of these attributes we would have to do so manually for example let's replace filed with is filed now I need to look throughout my code for any instance of filled and replace it with is filled it's a lot of work and I might make a mistake such as here and here it's better to write your code once and try and reuse it so that's where inheritance and the super function can come in handy we're going to take the attributes of color and is filled and place it within a parent class these children classes will inherit those attributes so class what do they all have in common they're all shapes class shape and for now I'll write pass circle is going to inherit from its parent of shape that also applies with square and triangle we'll set up a Constructor for shape Define init we will pass in the color and is filled then we will assign these attributes self. color equals color self. is filled equals is filled we don't need to manually assign these attributes within each of these Constructors for the children instead what we have to do is within the Constructor for each of these children classes we have to call the Constructor structor for the parent also known as the super class of shape so we will eliminate these two lines of code use the super function dot call The Constructor of the parent that is the dunder init method but we need to pass in the color that we receive and is filled this will be a Boolean and let's do this with the square class and the triangle class we still need radius for the circle width for the square width and height for the triangle we're going to call the super function to take care of whatever our attributes all these types of shapes have in common such as color and is filled now let's see if this works let's construct a few objects we will create a circle named circle called a Constructor for Circle we have to pass in a color a Boolean if it's filled or not and a radius so for the color of the circle let's say red is filled let's say that is true and a radius of five you could even use keyword arguments for better readability although not necessary but for clarity let's say color equals red is filled equals true radius equals 5 let's see if this works I will print our Circle color it is red print our colors is filled attribute the circle is filled that is true and the radius print circle. rius the radius of the circle is five we could even convert this to an F string I'll add a placeholder then add centimeters 5 cm let's construct a square object square equals Square we'll need a color is filled and a width I'll just copy what we have and make a few changes replace radius with width the color will be blue is filled will be false the width will be six we don't need the height because squares have an even width and height if we ever need the height we can assume it's the same as the width in this case six let's check out our square square do color square. is filled Square do width our square is blue it's not filled in the width is 6 cm let's create a triangle object triangle equals triangle pass in our arguments the color will be yellow is filled will be true the width will be seven and the height will be eight let's print our triangle's color is it filled its width and its height our triangle is yellow it's filled in the width is 7 cm the height is 8 cm so that's how you can use the super function to reuse the Constructor of a parent class we don't need to manually assign each of these attributes within each of the children classes we can do that in just one place when we refer to Super imagine that we're replacing this with the parent class name such as shape that might be a good way to think of it use the Constructor of the parent class of shape and pass these arguments in what you could do as well is extend the functionality of a method So within our shape class let's create a method of describe we will describe the attributes of this shape we will print use an FST string when we want to describe our shape let's say it is at a placeholder self. color what is the color of this shape and is it fill or not and add a placeholder we'll use a tary operator print filled if self. is filled is true else we will print not filled each of these types of shapes circle square and triangle will have access to a describe method let's attempt to use it take our Circle use the describe method that's inherited it is red and filled Square it is blue and not filled triangle it is yellow and filled so then we also have method overwriting what if we create a similar method of describe within circle square and triangle let's do that Define a describe method within our Circle let's calculate the area what's the area of the circle I'll use an F string it is a circle with an area of then we'll calculate the area given the radius to calculate the area of a circle we can take Pi I'll just say 3.14 just to keep it simple times the radius squared self. rius time self. rius if I were to call the describe method will we use the parents version of describe or the child so let's take our Circle use the describe method the result it is a circle with an area of 78.5 I should really add cim squar after that cm squared this is called method overwriting if a child child shares a similar method with a parent you'll use the child's version and not the parents this is Method overwriting if you would like to extend the functionality of a method from a parent you can use the super function not only do I want to use the describe method of the child I would also like to use the describe method of the parent So within this function we will use the super function access the describe method of the parent what we're doing is extending the functionality of the describe method it is a circle with an area of 78.5 cm squared the circle is red and it's filled or you can change up the order let's use the parent classes describe method and extend the functionality with our own print statement it is red and filled it is a circle with an area of 78.5 cm squ let's finish this with the square and triangle classes I'll copy what we have for the described method within the circle class but we'll make a different calculation describe the square it is a square with an area of take self. width times self. width the height and the width are going to be the same if it's a square then describe our triangle it is a triangle with an area of width time height we have a height in this case divid two we've already described our Circle let's describe our Square it is a square with an area of 36 CM squar it is blue and not filled let's describe our triangle it is a triangle with an area of 28.0 cm squ it is yellow and filled all right everybody that is the super function it's used in a child class to call the methods from a parent class also known as the super class it allows you to extend the functionality of the inherited methods within a child class you could use it within a Constructor to assign any attributes that all of its siblings have in common such as color or if that shape is filled when used within any other method you can extend the fun functionality of that method not only are we printing this message from the parent we're tacking on another print statement before that and well everybody that is the super function in Python what is going on everybody so today I got to talk about polymorphism in Python polymorphism is a programming concept it's a Greek word that means to have many forms or faces poly means many morph means form in programming an object can take one of many forms there's two ways to achieve polymorphism one is through inheritance an object could be treated of the same type as a parent class there's also duck typing which we'll talk about in the next Topic in this video we're more focused on inheritance what we'll do in this video is create a class of shape we'll write pass as a placeholder we will create a class of circle which will inherit from shape again writing pass class class Square inherits from shape class triangle which inherits from shape if I was to create a circle object Circle equals Circle our Circle identifies as a circle and since our Circle class inherits from the shape class our circle is also considered a shape it has two forms it's a circle and it's a shape but our Circle isn't a square or a triangle that could also apply to our Square class our square is a square our square is also considered a shape but our square is not a circle or a triangle those are two possible forms for our Square it's a square and a shape so let's say we would like to create a list of shapes what do they all have in common well they're all shapes a descriptive name for this list would be shapes equals an empty list I will instantiate a circle object a square object and a triangle object our circle is a circle and a shape our square is a square and a shape our triangle is a triangle and a shape each of these objects has two forms or two faces let's fill in some of these classes let's say that with our shape class we will define an area method Define area I'm going to turn this into an abstract method I'll just write pass to work with abstract classes we need to import that from ABC import Capital ABC as well as abstract method preceding the area method I will add a decorator of abstract method our circle square and triangle classes they're all considered shapes they inherit from this class we need to Define an area method for each since they're all considered a shape every shape has an area with our class of circle let's define a Constructor Define in nit we will pass in one argument a radius what is the radius of the circle assign an attribute of radius equals the radius we receive let's do this with square Define in nit one parameter the length of a side self. side equals side then triangle Define init we have two parameters base and height self. Bas equals base self. height equals height all right now let's finish defining these area methods for each class we will return 3.14 time self. rius to the power of two so given a radius that's how to calculate the area of a circle then with our Square Define area we will return self. side to the power of two then with our triangle Define area Return self. base times self. height time 0.5 now we have to pass in some arguments for our Circle we need a radius I'll pick four for the square the length of a side will be five then our triangle the base will be six the height will be seven we're going to write a loop to iterate through our shapes for every shape in shapes then we're going to print for every shape called the area method and that would give me these numbers if you would like you can format the output I'll just use an F string I'll add CM squar much better what if we were to create a class that's completely unrelated to shapes I will create a class of pizza I will Define a Constructor to construct a pizza object we need a topping and a radius what is the radius of the pizza self. topping equals topping self. rius equals radius within my list of shapes I'll add a pizza object but I have to pass in a topping such as pepperoni and what is the radius of the pizza let's say 15 cm so our pizza our Pizza class doesn't have an area method here's what happens when I run this we get an attribute error Pizza object has no attribute area our pizza object is considered a pizza but it is not considered a shape it does not inherit from the shape class at the top here you know what a pizza is circular it could be considered a circle so how about this let's take the pizza class it will inherit from the circle class and within our Circle class we're already assigning the radius to the radius attribute so instead of doing that here within the Constructor for our pizza class let's call the super Constructor super which refers to the parent use its Constructor then passing the radius we receive let's see if this works now that does here is the area of our pizza our pizza is considered a pizza it inherits from the circle class so it's also considered a circle and our Circle class inherits from the shape class our pizza has three forms our pizza is considered a pizza it's also considered a circle and it's also considered a shape it would make sense for it to fit into this list of shapes because our pizza also identifies as a shape so that's polymorphism everybody it's a Greek word meaning to have many forms or faces poly meaning many morph meaning form in Python there's two ways to achieve polymorphism one through inheritance an object could be treated of the same type as a parent and there's also duck typing which we'll discuss more in the next topic stay tuned for that and well everybody that's polymorphism in Python hey everybody so today I got to talk about duck typing in Python duck typing is another way to achieve polymorphism besides using inheritance objects can be treated as if they're type as long as they meet the minimum necessary attributes and methods required of them it follows this adage if it looks like a duck and quacks like a duck it must be a duck as long as an object resembles another it could also be treated of that type so in this example let's create a class of animal we will have a class attribute of a live if you're an animal you will have an attribute of aive you're a living creature let's create a class of dog the dog class will inherit from the animal class they will inherit the alive attribute let's also Define a speak method if you're a dog you gain the ability to speak we will print woof then we'll create a cat class class cat inherits from animal for the speak method we will print meow let's create a list of animals what do these two classes have in common they both could be considered animals let's create a list of animals we will construct a dog object and a cat object if I was to write a for Loop for every animal in my list of animals have each animal use its speak method which will result in the dog going woof the cat going meow they're both speaking what if we add a class that has nothing to do with animals like class car cars will have a horn method that's how they speak when you honk the horn you will print honk within my list of animals let's create a car object it really doesn't belong in here but let's see what happens we have an attribute error car object has no attribute speak our car object doesn't have the minimum necessary attributes and methods when iterating through this list of animals we're calling each animal speak method which our car object doesn't have but it does have a horn method so what if we rename our horn method as speak maybe it's an AI car or something something well this would work the dog goes woof the cat goes meow the car goes honk so our car object it quacks like a duck we could consider it a duck it has the minimum necessary methods to be considered an animal animals inherit this alive attribute let's utilize that after the animal speaks let's print their Al live attribute print my animals Al live attribute my car object doesn't have that attribute we get an attribute error car object has no attribute alive but if I was to add that attribute alive equals false we have true for the dog it's living true for the cat it's living but false for the car it's not living it's not a living creature my car meets the minimum necessary requirements to be considered an animal if I were to set this to be alive well then it would be a living car kind of like the movie Cars so with python duct typing is another way to achieve polymorphism besides using inheritance as long as an object has the minimum necessary attributes and methods you could treat it as a different type of object if it looks like a duck and quacks like a duck it must be a duck and well everybody that is duck typing in Python hey what's going on everybody so in today's video I'm going to explain aggregation in Python aggregation represents a relationship where one object contains references to one or more independent objects one object acts as a container the whole which can contain other objects the parts so what we'll do in this demonstration is create a object that's going to act as a container we'll create a class of library for now a right pass now a library can contain books we will create a class of book we'll be creating book objects which we will add to our library object the library object is going to act as the whole the container the books are the independent Parts a library can exist without its books and the books can exist without the library that's the main difference between aggregation and composition these classes are independent of one another they can exist without each other with our class of book we'll need a Constructor we will Define our Constructor if we create a book we need a title and an author we will Define a title attribute equals the title that we receive and self . author equals the author that we receive that's all we need for the book class now with the library class we will also need a Constructor Define init for our library we need a name for the library for example the New York Public Library self. name equals the name that we receive let's construct our library object first Library equals Li Library we need to pass in a name for this Library let's say New York Public Library so this should run with no problems then we'll create a few books let's say book one equals called the book Constructor we have to pass in a title and an author so pick a few books I will pick Harry Potter Happy Harry Harry Potter and the philosopher stone but I don't want to type the whole title let's just say Harry Potter do dot dot the author of this book is JK rolling okay let's create another book book two equals book for my next book I'll pick the Hobbit the author is J R R our token then book three equals book we need a title and an author I will pick the color of Magic by Terry pratchet we have no problems when running this our library and our books can exist without each other our books are independent so now now where aggregation comes in our library object will contain our book objects one way in which we can handle this is that within the Constructor for our library let's create an attribute of books this will be an empty list we'll need a way to add these books to our list of books we will Define a method of add book but we have to pass in a book object when we call this method we're going to access self. books it's a list list have a builtin append method we will append our book to our list of books let's see if this at least runs we're going to take our library call the add book method that we defined then pass in our book object of book one then let's let's do this with book two and book three and this is run with no problems our books can exist independently of our library our library object is just containing them it's housing these books now if I would like to print all the books in my library I could create a method to do that let's define a method of list books there will be no parameters besid self I'm going to return a list comprehension for every book in self. books remember that books is a list for every book in books Let's return an F string where we display the book's title and the book's author display book. tile the word by bookauthor okay let's see if this works first I'm going to print the library's name print libraryname New York Public Library then I'm going to print access the library objects list books method and here is my list of books although I'm going to reformat this so it looks better I'll use a for Loop for every book in Access our library objects list books method this will return a list we can iterate through it for every book in the list of books print each book all right here is our libraries name and each book in our list of books all right everybody so that's agre ation it represents a relationship where one object the whole contains references to one or more independent objects the books they can exist without one another and well everybody that is aggregation in Python all right everybody so today I got to talk about composition in python as we've discussed in the previous topic aggregation is a relationship where one object contains references to other independent objects they have a has a relationship composition on the other hand is when the composed object directly owns its components which cannot exist independently they have a owns a relationship aggregation has things composition owns things kind of like you're renting or you're owning something in this example we'll create three classes a class of engine a class of wheel and the composed object is going to be Class Car within our car class we will construct some engine and wheel objects we'll begin with our engine class we'll need a Constructor we'll Define that Define in knit let's say that with an engine we need a horsepower what is the power of the engine self. horsepower attribute equals the horsep power that we receive with our class of wheel we need a Constructor Define init let's add a size attribute what is the size of the wheel self. size equal size okay now with our car object now within our car class we need a Constructor we will need a make model the horsepower of the engine and size we'll say wheel size remember that you can rename parameters to something different we will assign these attributes self. make equals make self. model equals model here's where composition comes in we will define an attribute of engine then call the engine Constructor we have one argument to pass in Horsepower we will pass in the horsepower that we receive to the engine Constructor then we have to set up our wheels self. wheels equals now to construct a single wheel object we would call the wheel Constructor then pass in the wheel size however car have four wheels we don't want just one wheel so what we could do is write a list comprehension for every wheel in range four to iterate four times let's call the wheel Constructor and pass in our wheel size this list comprehension will create four wheel objects for us the reason that this is considered composition we're creating engine and wheel objects inside of this class car our class car owns an engine and owns four wheels we're not creating these objects outside of the car class let's create a car object car equals car we need a make model horsepower for the engine and wheel size so for my car let's say Ford Mustang for the horsepower I'll make up something 500 for the wheel size 18 in now just to make this more explicit I'm going to use keyword arguments but you don't have to so make equals Ford Model equals Mustang horsepower = 500 wheel size equal 18 let's create a method to display our car I would like the details Define display car no parameters let's return an F string let's begin with the make and model those will be easy display self. make and self. model let's take our car object use the display car method then I got to print it I forgot because we're returning a a string we're not printing it directly we have a Ford Mustang okay let's display the horsepower there's one additional step we are accessing self this car that we're creating but now we need the engine let's access the engine attribute and now with our engine our engine has an attribute of horsepower we'll use the attribute accessor that dot horsepower 500 I'll add HP meaning horsepower all right now for the wheels I'll add another placeholder access self access our Wheels now our Wheels it's a list I don't need all four wheels I just need one if I was to take my list then access the size this is what it'll give me list object has no attribute size so we need to access one of the elements of our list of Wheels let's just say the first wheels at index0 then give me the size 18 and that's going to be inches all right then let's create a second car object before we finish we have car 1 Car 2 equals car we need a make model horsepower for the engine and wheel size for the Wheels I will pick a Chevrolet Corvette and I'm just going to make up some numbers the horsepower is 670 and the wheel size is 19 let's display Car 2 Car 2 called the display car method we have a Chevy Corvette with horsepower of 670 the wheel size is 19 in so our car class it owns some objects it owns an engine and it owns four wheels that's why composition is different from aggregation if I were to delete these two cars this engine and the four wheels would stop existing whereas in our library example in the last video if I was to delete the library object the books would still exist all right everybody so that's composition it's where a composed object our car directly owns its components our car owns an engine and it own phones for Wheels we're creating them within the class and well everybody that's composition in Python hey what's going on everybody so in today's video I got to talk about nested classes in Python a nested class is a class defined inside of another class this has a few benefits we can logically group classes that are closely related we can encapsulate private details that aren't relevant outside of the outer class and also it helps keep our namespace clean it reduces the possibility of naming conflicts so for example let's say we have two classes both named employee within this class I'm just going to print something this is the first class then let's copy our employee class paste it again this is the second class we have a naming conflict we have two classes with the same name if I were to run this program we will execute both this is the first class this is the second class it is fairly noticeable that we have two classes with the same name but with python we do a lot of importing and exporting of large files we may not realize there's a name conflict one concept that'll help us avoid naming conflicts is the use of nested classes let's say we have employees for a company and another set of employees for a nonprofit organization I could write something like this we'll create a class of company within this class of company we will have an in class of employee with our second employee class we will create an outer class of nonprofit this is perfectly fine we can have two classes with the same name as long as they're within different Scopes these two employee classes might have different attributes depending on who they work for if they work for a company they might might have one set of attributes if they work for a nonprofit they might have a different set of attributes so by using nested classes this helps keep the namespace clean we can reuse this employee class because they have different Scopes now what we're going to do in this example what we'll do in this example is create some employee objects that belong to a company object as a placeholder for now I'll write pass within the employee class with our class of company let's define a Constructor do pay attention to the indentation we are within the company class but not the employee class this Constructor is for the company the company object we're going to create if we construct a company object we need a company name such as the Crusty Crab I will assign self. company name equals the company name that we receive we are also going to declare an attribute of employees this attribute will be an empty list we will append employee objects to our list of employees then we will create a method to add employee we will need a name meaning name of the employee and a position what's their job for now I'll write pass we'll get back to this later and I will Define a method of list employees and again I'll write pass okay let's be sure that our company name works I'm going to create a company object company equals company but I have to pass in a company name I will pick the Crusty Crab then just to be sure that this works I will display our company's company name attribute that would give me the Crusty Crab so we know that that works within our employe class let's define a Constructor Define innit we need a name and a position self. name equals name self.pos equals position let's create one more method Define get details we will return the details of an employee all we're going to do is return an FST string add two placeholders we will return self. name and self.pos all right now within our ad employee method we will construct a new employee object equals now if if we're going to access this inner class of employee we're going to prefix self self meaning this company object that we're currently working with we need the class of employee then we'll call The Constructor but we have to pass in a name and a position when we receive a name and a position we will pass that to the employee Constructor once we have our new employee object we're going to take our list of employees self. employees use the append method of lists then add our object of new employee to this empty list let's create a few employee objects we'll take our company use the add employee method that we have created we need a name and a position I will pick Eugene for Eugene Krabs his position is that he is the manager let's create two more take our company object use the ad employee method that we have defined I will pass in a name of this employee as SpongeBob his position is that he is a cook then we have Squidward company. add employee method first name Squidward his position is that he is a cashier so this should run with no problem s now I would like to list all of the employees at this company we'll need to rely on this get details method so when we list our employees we will return a list comprehension for every employee in self. employees this is an attribute it's a list of employee objects it is iterable take each employee that we're iterating through call the get details method and return it now if I was to take my company then call the list employees method whoops I forgot to print it we will print each employees name and their position however I think this would look better if we were to use a for Loop for every employee in take our company call the list employees method during each iteration we will print each employee we have Eugene that's Mr Krabs the manager SpongeBob The Cook and Squidward the cashier to demonstrate the reusability of classes let's create a second company object that has its own employees let's rename company as company one then we will create Company 2 Company 2 equals called the company Constructor my second company will be the Chum Bucket we'll take Company 2 then add two employees company 2. add employee we will pick shelden Sheldon is the manager company 2. add employee Karen will be the assistant for every employee in Company 2 list the employees during each iteration print the current employee we have Sheldon that's Plankton's first name he's the manager and Karen is his assistant all right everybody so those are nested classes it's a class defined inside of another class you have an inner class and an outer Class A few of the benefits is that we can logically group classes that are closely related such as having employee objects within a company object we can encapsulate private details that aren't relevant outside of the other class we may have no need to create employee objects outside of this class and by using nested classes it helps keep the name space clean it reduces the possibility of naming conflicts with another type of organization we could create another inner employee class and well everybody those are nested classes in Python hey what's going on everybody today I'm going to talk about static meth methods in Python a static method is a method that belongs to a class rather than any object from that class any instance instance methods we're already familiar with them they are methods that belong to individual objects created from that class they're best for operations on instances of that class any objects whereas static methods they're best for utility functions within a class that do not need access to class data I'll demonstrate the differences between an instance method and a static method we'll Begin by creating a class of employee we'll need a Constructor let's define that to create an employee object we'll need a name and a job position we will assign self. name equals name self. position equals position we will create an instance method of get info we will return employee info we will return an F string where we will display self. name equals self.pos get info is an instance method each object that we create from this class will have their own get info method to return the information on that object object the object's name and the object's position now we'll create a static method to create a static method we need a decorator of static method static methods are best for General utility functions within a class we'll Define a method to check to see if a job a position is valid which we will name is valid position so static methods they don't have self as the first argument we're not working with any objects created from this class to check to see if a position is valid we will pass in a job position which I will name as position I will create a list of valid positions let's assume that our company is the Crusty Crab what are some valid positions a manager is a valid position a cashier a cook then let's say a janitor then we will return we'll use a membership operator check if position that we receive is in our list of valid positions what we have done is that we have created a static method we don't need to rely on any objects to use this method for example to use a static method we will use the name of the class rather than any object that we create from this class such as this we don't need to do that we type the class name followed by the static method is valid position then I did set this up to accept one argument let's check to see if a cook is is a valid position then I do need to print this what is the output a cook is a valid position what about a rocket scientist that would probably be sy's job that is false a rocket scientist is not a valid position at the K crusty crab this is a static method it belongs to the class not any object created from that class now let's let's create a few employee objects let's say employee 1 equals a new employee we have to pass in a name and a job Eugene will be the first name that's Mr Krabs he will be a manager employee 2 equals employee Squidward will be a cashier employee 3 equals employee employee 3 will be SpongeBob SpongeBob will be a cook to call an instance method we have to access one of the instances of the class in order to use it if I want to check the info on employee 1 I will access that object that instance use the get info method then I need to print it take employee one get the info Eugene is the manager let's do this with employee 2 and employee 3 Eugene Mr Krabs is the manager Squidward is the cashier SpongeBob is the cook for an instance method you access an object then call the instance method with the static method you only need to access that class you don't even need to create any objects from that class it's a general utility method all right everybody those are static methods they're a method that belongs to a class rather than any objects created from that class they're usually used for General utility functions that do not need access to class data and well everybody those are static methods in Python hey what's going on people so today I got to talk about class methods in Python a class method allow operations related to the class itself they take CLS as the first parameter whereas instance methods will take self self refers to any object created from that class CLS meaning class refers to the class not any objects here's an example we will create a class of student we'll need a Constructor to construct some student objects all students will have a name and a GP self. name equals name self. GPA equals GPA we will also create a class variable for this demonstration of count we will count how many students we create whenever we construct a student object we will access the class of student take our count variable increment it by one whenever we create a student object object increase count by one I will create an instance method of get info instance methods have self as the first parameter we're referring to the object we're currently working with I will return an F string where we will display the students name and their GPA self. name self. GPA I'll add a comment that this is an instance method Now to create a class method to work with class data we will declare a class method with a class method decorator class method what we're going to do is Def find a method to get the count the class variable of count this method will be called get count rather than self as the first parameter we'll be working with a class CLS meaning class I will return an F string total number of students add a placeholder CLS count Let's test this to call a class method you take the name of the class followed by the class method get count and then then we do need to print this what is the count of my current students total number of students is zero let's create a few student objects we will create student one equals called the student Constructor we have to pass in a name and a GPA let's say that the name is SpongeBob SpongeBob has a GPA of 3.2 we'll create two more students student two student three student two will be Patrick Patrick has a 2.0 then Sandy Sandy Smart in fact she's a genius she has a perfect 4.0 now let's count the number of students total number of students is three when we call this class method we can access or modify class data this class variable of count rather than using self we use CLS for the class let's create one more class method this time I'll calculate the total GPA of all my students we'll need a class variable to hold that data let's say total GPA equals z whenever we construct a student object we will access our class of student get the total GPA then add plus equals this student's GPA that we have just created basically speaking the total GPA this variable is going to accumulate all of the GPA of every student and store it as a sum to find the average we're going to divide it by the count the number of students we'll do that within a class method to create a class method again we need to use the class method decorator I will Define a method of get average GPA the first parameter is CLS for class I will check if CLS count the count variable of my class is equal to zero that means if we have no students if that's the case if there's no students we're going to return zero because otherwise we're going to divide by zero and we'll get an error else we're going to return an F string follow this formula we're going to take the total GPA of my class class. total GPA divided by class. count the number students we have that's how to calculate the average GPA after getting the count of the number students to access a class method we take the name of the class student call the class method get average GPA then I will print it total number of students is three the average GPA is 3.06 repeating after calculating the average I'm going to add a format specifier of 2f just around to two decimal places and I'll add average GPA colon space then we'll calculate the average all right everybody those are class methods instance methods are best for operations on instances of the class any objects static methods are best for General utility functions which do not need access to class data class methods are best used when we're working with class level data or we require access to the class itself such as when we're working with class variables rather than using self as the first parameter we're going to use CLS meaning class and well everybody those are class methods in Python yo what's going on people so today I'm going to explain magic methods in Python magic methods are also known as Dunder methods meaning double underscore you typically find these within classes we're already familiar with one of them are Dunder init method we have double underscores on the left and double underscores on the right but there are others I'll cover a few of the more beginner friendly ones so what these methods do is that they're automatically called by using some of pythons built in operations such as printing an object seeing if two objects are equal greater than or less than when we use many of Python's builtin operations with objects we can Define and customize the behavior of those objects so in this demonstration I'm going to create a class of book we will construct some book objects we will Define a magic method a Dunder method of init to initialize these objects for a book we need a title an author and the number of pages we'll say num Pages self. tile equals title self. author equals author self. number of pages equals number of pages when we call the class of book we Are automatically calling Dunder init so let's create a book object book one equals book we need a title an author and number of pages so since we're dealing with this topic of magic methods I'll pick some fantasy related books for my first book I'll pick the Hobbit that's the title the author is JRR token the number of pages is 310 so for my next book book two I will pick Harry Potter and the philosopher stone the author is JK Rowling the number of pages is 223 then we have book three for my third book I will pick The Lion the Witch and the Wardrobe the author is CS Lewis the number of pages is 172 okay here are my three book objects when we call the class of book and pass an arguments we will call the dunder init method it's a magic method it's automatically called behind the scenes within this magic method we can Define and customize the behavior of objects and in this example we're just assigning the attributes of title author and number of pages that is one builtin operation of python what would happen if I was to print book one directly to the console here's what happens well we're given a memory address here's book two and book three well we can customize this Behavior we will use the dunder string method double underscore St Str meaning string double underscore again we have one parameter of self instead of returning a memory address we can customize this behavior let's instead return an FST string I'll add two placeholders we will display self. tile the title of the book by self. author and I'll place the title within single quotes now let's print book one we have The Hobbit by JRR tolken let's print book two Harry Potter and the philosopher stone by JK Rowling and book three The Lion the Witch and the Wardrobe by CS Lewis so that is thunder string we can return a string represent a of the object when we print it directly to the console here's another Dunder method we can check to see if two objects are equal I will print is book one equal to book two that gives me false if they were to have the same title the same author and the same number of pages then python would say they're not equal still so let's customize this Behavior we will Define a method of Dunder equals which is just EQ for parameters we have self the first book we're examining in this case book one and other other means the other book we're examining two objects for equality to do that we'll see if the title of two books and the author is the same we'll disregard the number of pages you can have two different versions of the same book they might have different font sizes or the dimensions of the physical Pages might be different so we will return a Boolean value we will examine if self that's the first book is the title attribute equal to our other books title and is the author of the first book self. author equal to our other books author if I were to run this we get false book one does not equal book two but if they have the same title I'm going to replace these and the same author then they would be equal and we'll disregard the number of pages let's say that with this version of The Hobbit they're using a smaller font size so there's less Pages we're using under equals to compare if two objects are equal what if I was to print book two is less than book three like what does that even mean and I'm just going to get rid of these two lines type error less than is not supported between instances of book and book so we can't use less than on two objects but we can customize that behavior by using Dunder less than which is just LT we're examining one book and the other book self and other let's compare the number of pages we'll compare if the pages of book two is less than book three we will return a Boolean value is self. number of pages less than other. number of pages so now this should not give us an error book two does not have less Pages than book three another would be greater then I'll just copy what we have Dunder GT for greater than for our first book of self is it greater than the number of pages of the other book well that's true the number of pages of book two is greater than book three let's let's use Dunder add to add the pages of two books together what would happen if I were to add two books together book two plus book three well we get a type error unsupported operand for book and book well to customize the behavior of addition we will Define Dunder add we have self and other for the other object let's add the pages together of two books maybe we need a summer reading list and we would like to see what the total number of pages is I will return self. number of pages attribute plus our other books number of pages that would give me 395 that's 223 + 172 heck I'll even put this within an F string CU why not then I will add the word Pages 395 Pages within an object we can search for a keyword within one of the attributes so let's find the word the lion within book three to do that I would write a statement like this Lion in book 3 Type error argument of type book is not iterable we will Define Define Dunder contains besid self we will pass in a keyword a keyword that we're searching for I will return then we'll use the in membership operator is our keyword in self. tile I'm looking for the word lion that's going to return true if lion is in the title of this book or is our keyword in self. author maybe we're searching for an author let's try that again that returns true lion is in book three however lion is not within book one that's false is rolling in book two that's the author that is true is rolling in book three that is false that is thunder contains we are searching for a keyword in an object now we could search for a key given an object for book one we'll use the index operator and look up an attribute let's get the title of book one the default behavior is that we get a type error book object is not subscriptable so to customize this Behavior we will use Dunder get item besides self we have one parameter of key we're accessing book attributes by indexing with this object return the value at this key what's that attribute we will check if our key that we receive is equal to title which it is in this case we will return self. tile What's the title of the book so that would give me The Hobbit here's book two and book three what if the key is author none we didn't set that up yet if key is equal to author then return self. author the author of book three is CS Lewis two is JK rolling book one is JRR tolken what about number of pages num Pages well we're not set up for that yet I'm going to turn this into an else if statement else if key is equal to num Pages then we will return self. num Pages the number of pages in book one is 310 book two is 223 book three is 172 what if there is no key otherwise if there is no matching key I'll add an else statement let's return an F string key placeholder R key that we pass in as an argument was not found what do books not have well they don't have audio I guess unless it's an audio book is there a key of audio in book three there is not key audio was not found and I'll place that within single quotes much better all right everybody so those are magic methods also known as Thunder methods meaning double underscore they are automatic called by many of Python's builtin operations they allow developers to define or customize the behavior of objects when we use those builtin operations and well everybody those are magic methods in Python hey everybody so in today's video I got to talk about the property decorator in Python the property decorator allows us to define a method as a property we can access it like it's an attribute one of the benefits is that when Reading Writing or deleting attributes we can add additional Logic the property decorator gives us a getter method to read a Setter method to write and a deleter method to delete when working with attributes in this example we'll create a class of rectangle we need a Constructor let's define that when constructing a rectangle object we will need a width and a height we will assign the attribute of width equal to the width that we received when constructing this object self. height equals height let's construct a rectangle object rectangle equals rectangle we need to pass in a width and a height then I will print my rectangle's width rectangle. width and the height rectangle. height with my rectangle the width is three the height is four using the property decorator when reading these attributes of width or height I can write some additional logic let's say that when accessing the width or the height I would like to display one digit after the decimal then add centimeters here's one way in which I can do that for each of these attributes I'm going to create a method we will Define a method of width no parameters beside self for now I'll write pass and Define he height preceding each of these methods I will use the property decorator so at property now when accessing the width or the height will be returned with whatever is Within These methods of width and height but there's one change we're going to make to these attributes we'll set these attributes to be private prefix each of these attributes with an underscore this tells you and other developers that these attributes they're meant to be protected they're internal we shouldn't access the width or the height directly outside of this class technically we could I will access the internal version of width and height we get three and four but we do have a warning access to a protected member width of a class that applies to height as well our width and our height are only meant to be used inside of this class if we need to get the width and the height we will do so through these getter methods provided by the property decorator so when accessing the width let's return an F string I will access self. private width add a format specifier to display one digit after the decimal 1f followed by cenm we'll do this with the height as well we will return self. private height so now when we access the width or the height we will do so using these getter methods if I access these private width and height attributes instead again they will be three and four it's kind of like their raw these attributes are meant to be used internally inside of the class so that's the point of a getter method we can add additional logic when reading one of these attributes when we Tred to get them we can also add Setter methods if we would like to set or write these attributes here's how let's take our width we will create a decorator of at width. Setter when attempting to set the width we will do so using this method we will Define our method name of width we will have one parameter a new width we don't want the parameter name to be the same as the method name that's why we're naming it something different when setting the width let's check to see if the new width is greater than zero if so we will take self. private width equals our new width else let's print something let's print width must be greater than zero and let's do this with the height height. Setter Define height pass in a new height if our new height is greater than zero assign self. private height equals the new height else print height must be greater than zero before printing the width and the height let's take our rectangle width set it to be zero then see what happen s well we get that message width must be greater than zero if I were to set width to be five well that does work our width is now five let's change the height rectangle. height I will set this to be Nega 1 height must be greater than zero and the height hasn't changed what about six six does work when using these Setter methods we can add additional logic when writing or changing one of these attributes these are Setter methods now if you need to delete an attribute here's how there is a delete keyword we will delete our rectangle's width and delete our rectangle's height in this series we really won't be using the delete keyword but you should still know that it exists so we will create a deleter method at take one of the attributes in this example with we will create a deleter method the method name will be width the name of the attribute there will be no parameters besides self we will delete self. private width then let's print something just to confirm that this was deleted width has been deleted same thing applies to height take the attribute of height Define height delete private height height has been deleted when deleting our width or our height we get that confirmation message width has been deleted and height has been deleted all right everybody so that is the property decorator we can define a method as a property meaning it can be accessed as if it was an attribute one of the benefits is that we can add additional logic when we read write or delete attributes the property decorator gives us a getter Setter and deleter method getter methods to read Setter methods to write and deleter methods to delete and well everybody that is the property decorator in Python
