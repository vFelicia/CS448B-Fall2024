00:00 - feature toggles can improve the workflow of your 
development team, and lead to quicker software  
00:05 - delivery, Frederick osburgh from unleashed 
will show you how feature toggles can help you.  
00:11 - Alright, so I brought with me, a friend of mine 
here today to help to introduce you to feature  
00:17 - toggles. He is a brilliant engineer, and he's 
the creator of unleash, which is the largest  
00:23 - open source solution for feature flagging 
on GitHub. And I'm really excited to have  
00:28 - him here today to help explain feature toggles. 
So welcome, Eva. And thank you for being here.  
00:35 - Thanks for having me. Yeah, it's my pleasure. I 
was curious, just to kick this off. You've been  
00:41 - in the feature toggle game for quite some time 
now. And I just wonder, what prompted you to start  
00:48 - feature toggling? And what was kind of the trigger 
to make this happen and create this? The system?  
00:56 - Yeah, thanks for asking that. Actually, I started 
on the leash or exploring feature toggling concept  
01:02 - back in 2014. And, and my kind of my goal or the 
mission, or the reason for starting with that is  
01:11 - that I deeply care about develop proficiency. And 
I was working as a tech lead and a team back then,  
01:18 - and, and we had already kind of automated how 
we release software to an environment, all our  
01:24 - environments. So we had kind of the deployment 
pipeline all set up, and we could in theory,  
01:29 - release whenever we wanted. And in our team, 
we had also decided to do weekly sprints,  
01:35 - because we wanted to kind of have this 
extreme focus and ship features all the time.  
01:40 - Because it makes sense. And also, we wanted to 
kind of learn all all the time. But I saw that we  
01:47 - often fail to do releases every week, we couldn't 
kind of ship software every week. And it bugged  
01:54 - me a lot, because we ended up with all these 
feature branches, long running feature branches.  
02:00 - And it actually was quite hard to manage 
these feature branches, because there was  
02:05 - a lot of changes. And I was kind of, you know, 
when you're working on a larger feature, take  
02:11 - some time to write that code and get it right and 
test it a bit and get some feedback on it. And,  
02:18 - and it feels like when you're pushing something 
to production, it needs to be like perfect,  
02:23 - because you actually kind of presenting it to real 
users out there. And, and for me, this bugged me  
02:29 - a lot, because they ended up us holding different 
feature branches back in kind of separate kind of  
02:36 - local branches or test environments and stuff 
like that. But they were never merged. And we  
02:41 - kind of postponed a lot of the learning. Right? 
And, and for me this, this was a nightmare. And  
02:49 - I felt like my it was kind of cognitive 
overload. And I thought that there has to  
02:53 - be better ways we should, we should try to 
ship some code all the time in smaller chunks,  
03:00 - but but hide them from the users instead. And this 
was when I started learning more about trunk based  
03:07 - development. And there were certain techniques to 
kind of succeed with trunk based development. And  
03:12 - one of the techniques that a lot of people talked 
about was feature toggles, or feature flags. And  
03:18 - I really loved that idea. And at this time, 
there was a couple of other open source  
03:25 - solutions for this as well. But usually, they 
were kind of tied to a specific framework,  
03:30 - or they were kind of very static, that it 
was just a file in your app. And you could  
03:34 - kind of change the toggle, but there was less 
of a dynamic built into it that I really wanted.  
03:41 - And this is why I started looking into creating 
something like in Asia, I really wanted something  
03:49 - that could allow me to do trunk Base Development 
divider features into smaller chunks. Even though  
03:55 - that complete feature was not releasable. 
The end user still wanted to have the ability  
04:00 - to ship the code to production, just to get some 
learnings like does it really make sense? Does  
04:05 - it work with production data is the firewall open 
all of that kind of things that we developer care  
04:11 - about, but also that then I can know that a small 
portion of the feature is done. And I can start  
04:17 - thinking of the next small portion of the feature 
instead of thinking about everything all the time.  
04:23 - So just curious for the people that don't 
know what is trunk base development. So  
04:29 - trunk base development is a very popular technique 
these days is kind of opposite to more like a Git  
04:36 - flow where you use branches for everything. So 
the idea is that you mainly work on the trunk or  
04:42 - the master branch or the main branch, you try 
to kind of all the time commit directly to that.  
04:49 - That trunk branch is so that you never kind of 
having long running feature branches in parallel.  
04:57 - This means that you you have all have 
developers in the team collaborating  
05:01 - on the same code base instead of having local 
copies of the code base in different states?  
05:07 - Right? Isn't that dangerous, though? Couldn't 
you like easily get something into the master  
05:12 - branch that isn't completely tested? Or 
doesn't work? 100% yet, or Yes, exactly. And  
05:21 - this is why you need feature toggles, because 
then you use a feature toggle to wrap that code  
05:26 - so that you make sure that it's not exposed 
before the code is ready to be exposed.  
05:32 - Right. So tell me a little bit more about that 
kiss. Just curious to know how that works,  
05:38 - actually. Yeah, so so that kind of a feature 
toggle is actually a very simple technique,  
05:45 - when you think about it, it's just kind of a small 
if statement that you've wrapped the new code in.  
05:50 - And only if that feature toggle kind of evaluates 
the true, we should evaluate the new code. If not,  
05:57 - we should use the old code. So basically, you 
can think of it like you're you're replacing  
06:02 - the branches in your repository, 
with branches in your code instead.  
06:09 - And this has, adds a lot of benefits. So it 
means that when you're using a tool like unleash,  
06:16 - you can start then namak, Li changing who gets 
access to a feature based on certain criterias in  
06:22 - a running application in production, so you don't 
have to get the redeploy or anything like that.  
06:31 - Interesting. And this allows you to test early in 
production, you can verify the new thing you're  
06:38 - working on, even though it's not completely 
finished yet, you can test it on yourself,  
06:42 - and only enable it for your user in a 
production environment, tested with real data,  
06:47 - make sure that the little part that you've already 
built actually works the way you intended to work.  
06:54 - Right. So you have something 
that's not completely finished,  
06:57 - and you hide it behind the flag 
so that it's not turned on,  
07:01 - before you're actually ready to turn it on. But 
you're continuously putting that into the master  
07:06 - branch so that you don't end up having multiple 
different states. That could clash in the future.  
07:14 - Exactly. And, and working like this allows the 
team to really collaborate on the code base,  
07:20 - and means that everyone will see your changes 
very fast, because it's safe to kind of  
07:25 - just commit directly to the trunk and have that 
directly in and share between the developers, it  
07:32 - means that you can basically refactor your code. 
And it's hard because there will not be kind of  
07:37 - some new feature on a different feature branch 
that is not yet complete that you have to wait for  
07:43 - before you can do this huge refactoring session. 
So there is a ton of benefit of working this way.  
07:52 - Amazing is what about drawbacks? Like? Nothing 
is completely 100%. Perfect. So just curious,  
08:00 - are there any drawbacks to using 
feature toggles? Yes, of course. And  
08:06 - if you think about like a feature toggle is is 
kind of technical debt by nature, because you are  
08:12 - having different version often of feature or 
the code itself, you have two implementations  
08:18 - of something in your code base. So obviously, you 
would not want to have that for a very long time.  
08:25 - But it really makes sense when you are kind of 
trying out new ideas or working on a new feature,  
08:32 - or something like that, that really makes sense 
to kind of encapsulate that in a feature toggle.  
08:37 - But we should also be a bit careful, because 
if you're just adding feature toggles,  
08:41 - but never taking them away, allowing multiple 
code paths to coexist in the code base, that  
08:47 - can be actually quite dangerous down the road. 
Because usually developers which team they might  
08:54 - quit from your company. And it could be kind of 
like, down the road, you can end up in a situation  
09:00 - where you have a lot of feature toggles, but 
you're not sure if you can turn them off anymore,  
09:06 - will that work? Will your application still 
work? So you're kind of really depend on a  
09:11 - certain state have that toggle. And when it 
comes to that situation, it's really about  
09:16 - time to start cleaning up that and remove the dead 
code and make sure that you only kind of execute  
09:23 - the code that you really want to execute. And 
there is other things there as well. And that is  
09:30 - a will having a lot of features bill also make 
your code a bit harder to test actually because  
09:36 - you will need to kind of test you will have a lot 
of different parts through your application give  
09:43 - based on what what the state of the feature toggle 
will be if it's on or off or maybe it's a certain  
09:50 - variant might not just be on but it could be 
divided between different implementations.  
09:57 - And then you certainly communist that should you 
test All the permutation of all the toggles in  
10:02 - your application, maybe not. But you should at 
least try to test the important ones, at least  
10:10 - with kind of automated tests and make sure that 
what most of your user will, will end up seeing  
10:16 - in production should obviously we are tested 
cobalt, and then there is a discussion if you're  
10:21 - also need to test all the different feature toggle 
states, maybe maybe not, it depends a bit on which  
10:28 - type of application you're working on, I guess. 
Right? So I'm actually curious about this. Because  
10:35 - when we're talking about deploying 
multiple times a day, or, or getting  
10:40 - to a point where we're releasing all the time, 
then obviously, a big part of that is having  
10:45 - automated tests. So you know that the code that 
you release is actually working and functional,  
10:51 - when you push it out to production. But when 
you're relying on a third party program,  
10:56 - and I know that a lot of the feature 
talking solutions that exist today  
11:01 - are like traditional SAS platforms, you 
set up your feature toggles there, and,  
11:06 - and you kind of use them in your code, and 
you have to communicate with them. So you're  
11:10 - kind of have this external dependency. And as you 
mentioned, that could be really hard to test. So  
11:16 - how can you get around that? How can you make 
sure that you can test your code thoroughly,  
11:21 - even when you have a third party that you have 
to rely on? Yeah, and that's actually one of  
11:28 - the benefits of choosing an open source platforms 
such as unleash, because you can, you can actually  
11:34 - just take the unleash open source, and that 
will be 100% protocol compliant with the SDK,  
11:40 - the enterprise will obviously give you some 
more features. But you can take that and run  
11:44 - this as part of your integration testing, if you 
really want to test the interaction with a leash.  
11:49 - And then you can just kind of pre configure that 
open source instance, to be in a certain state so  
11:56 - that you can kind of test all the states that are 
important to you. A lot of our SDK is also allow  
12:02 - you to do testing, for instance, the Java SDK has 
a built in kind of fake ilish implementation where  
12:08 - you can kind of set the toggles in certain states. 
But that's typically more useful in more like  
12:14 - unit test cases where you kind of are building 
unit tests for us more portion of the code.  
12:22 - But usually, that doesn't make sense. When you 
start integration testing or end to end testing,  
12:27 - then you often want to actually have some 
kind of third instance running that is  
12:32 - replicating what you're doing. And that's 
quite easily Tashi, with Alisha would say,  
12:41 - interesting. And anything more you feel like, 
it's important to talk about when we're,  
12:48 - we're talking? Yeah, I think I think there is a 
lot of things. And I'm sure that you will cover  
12:53 - a lot of the important topics in this course. So 
I'm super happy that you're doing this course.  
12:59 - I think in the end, there is obviously 
drawbacks with everything, there is  
13:04 - nothing that comes for free. But as long as 
we kind of handle those drawbacks and take  
13:09 - care of the technical debt, and make sure that 
we have some processes to also clean up that  
13:14 - we set aside maybe a day a month or something 
to kind of validate the toggles were using Are  
13:19 - they still relevant? I think the the benefits 
kind of outweighs the drawbacks. And I see that  
13:26 - teams starting to adopt feature toggles or wanting 
to run with the trunk based development process  
13:33 - seems to gain a lot of value out of using feature 
toggles. And to me it's kind of an eye opener  
13:39 - has seen in in in real life, how it's accelerated 
the learnings from the software we're working on,  
13:46 - and how we can safely release all the time in 
small chunks, get feedback on those changes. Are  
13:54 - they working? Are they doing what we intend them 
to do? And kind of bit by bit building out complex  
14:01 - features, which is a it's an awesome capability to 
have to be honest. Yeah, it's sounds amazing. So  
14:11 - I'm really excited that you're here. And were able 
to give us this kind of introduction to feature  
14:17 - toggling. So I want to thank you for taking time 
to do that. And now hopefully, we're going to be  
14:23 - ready to dive into the code and start implementing 
that on our own, which is going to be exciting.  
14:31 - Thanks for having me. You're welcome. Alright, so 
we heard a little bit about what feature toggles  
14:39 - are and how you can use them. So now we're 
going to get into a little bit more. And I  
14:45 - want to stress them in the most basic form. A 
feature toggle is just an if else statement.  
14:54 - So what you could do is you could have a flag 
in your code that says whether or not something  
14:59 - is are off. And obviously, if you're diligent, 
and you're able to remember to turn this flag  
15:06 - on and off, when you're developing, or you're 
loading it from some kind of configuration file,  
15:12 - that can be enough to just get the ball rolling 
and get started, because it means that you can go  
15:17 - ahead and merge in your code at any point in time. 
So what we'll do is we'll take a look at how we  
15:25 - can perform this and how we can implement it into 
the Free Code Camp code base. So let's get to it.  
15:33 - Alright, so here we have the Free Code Camp 
website. And it's running locally on my machine.  
15:40 - So let's just take a quick moment and go through 
what's here. As you can see, we're at the landing  
15:46 - page right now. And we have this text in the 
middle, and the call to action that says get  
15:51 - started, it's free. And if we scroll down, we have 
an S seen in section, we have an alumni section.  
16:01 - And in the end, here, we have the certification 
section. So that's basically the structure of  
16:10 - the landing page. Now, let's go to the top. And 
we're just going to focus on this part right here.  
16:18 - And what we want to do is want to take this 
section right here, and we're going to swap it  
16:24 - out with a new section. So we'll take a look at 
the code, we'll take a look at the new section.  
16:30 - And then we'll take a look at how we can use a 
flag to toggle this on or off. So here we are  
16:37 - inside of the Free Code Camp code base. And 
we're inside of index js. Now, the landing  
16:45 - top component here is the existing component that 
corresponds to what we just saw on the main page.  
16:53 - And we have this landing top v two here, which 
is the new design that we want to go ahead and  
16:59 - implement. So what we'll do is we'll uncomment 
this. And we'll scroll down a little bit. And we  
17:07 - have a piece of code here that we're also gonna 
comment in. And then we'll comment this out,  
17:15 - just so we can see the changes that 
we make. So if we head back to the  
17:24 - and now we can see that we have the 
new component in place of the old one,  
17:30 - we still have one issue that when we have the 
header up here, that is a universal header.  
17:36 - But we chose to include it in the new 
design in the this component. So what  
17:42 - we'll go ahead and do is we'll go back to 
the code, or find the header components.  
17:50 - And we'll take the universal now. And for now, 
we'll just go ahead and comment that out. And  
17:59 - if we head back to the browser, now, we should see 
it update. And here we have the new landing page.  
18:09 - So what we'll look at now is hiding this behind a 
flag, so that we can easily toggle it on or off.  
18:18 - Let's head back to the code. And the first 
thing we'll do is we'll go ahead and create a  
18:26 - new file and source both flags. Yes. And in here, 
we'll create a constant called new design on and  
18:38 - we'll set it initially to be false. Now, what 
we'll do is we'll go back to our landing page.  
18:48 - And we'll change this because it's not good to 
have a bunch of uncommented code around and we  
18:54 - want this to be flexible, we need to find a way to 
be able to display either this component or this  
19:02 - component based on the flag. So let's go ahead 
and import the new design on flag. And I get some  
19:12 - help there from my auto importer. So now we have 
the new design on imported. And we'll use this  
19:23 - to conditionally render one thing or the other. 
So we'll say const landing page component  
19:31 - or landing top components Be precise. And 
we'll say new design on and if it's on,  
19:41 - we want to render this part right here. Otherwise, 
and we'll denote that with a colon where you want  
19:57 - the old landing page 
components Now we'll put it in.  
20:04 - Right here. Basically, we're saying if it's on, 
give me this part, if it's off, give me this part.  
20:14 - And then we're taking the value there. And we're 
rendering it inside the main container. Let's go  
20:24 - ahead and see what we get. Now in the browser, if 
we head back, now we have the old landing page.  
20:31 - But we're still lacking the universal navigation. 
So let's go ahead and fix that as well.  
20:39 - So we're going to index TSX in the 
header. And we'll comment this back.  
20:46 - And we'll do the same thing 
here. So we'll say new design on.  
20:51 - And we'll use that to render the universal NAB. 
So navigation equals new design on then we want  
21:02 - nothing. Otherwise, we want 
the universal navigation.  
21:11 - So remember that the new design has the navigation 
built in. So we don't want anything in that case.  
21:18 - If it's not on, then we want to render it 
because it belongs with the old components.  
21:26 - So if we hit save on that, 
and go back to the code,  
21:30 - or the browser, we now have the navigation 
back as well. So what this allows us to do,  
21:38 - is we can go back to the code, and we can go 
to our flag. And we can flip this to true.  
21:47 - And now we have one central state that controls 
whether or not we show one component or the other.  
22:00 - Now we're soon getting to the really cool part. 
And the ultimate goal that we're trying to areas  
22:07 - that we want to be able to quickly merge 
things back into the master branch and get  
22:13 - things into production, without having to worry 
about whether or not it's 100% functional,  
22:20 - because we can make the improvements as we go 
along and hide the feature from the user base  
22:27 - until it's 100% complete. Now, what 
we have now, a flag that we can click  
22:35 - on or off in our code, it's gonna work 
but it's a little bit brittle. You know,  
22:42 - if you have a flag that you have to 
have a conscious relationship with,  
22:47 - and you have to know whether or not 
it's on or off, when you push your code,  
22:52 - it adds mental overhead. And it just it's 
it's one more thing to keep track of.  
22:57 - And what could be really dangerous if you actually 
forget that you turn it on, on something that's  
23:03 - not finished. And you inadvertently could push out 
something that's unfinished to your customers or  
23:10 - users of your hobby project or whatever it 
is that you have running in production. So  
23:16 - we need to do something to make sure that that 
can happen. So we'll jump back to the code.  
23:23 - And we'll take a look at how we can make 
this flag a little bit more dynamic.  
23:31 - So right now is set to true. And what I 
want to do is I want to use the process EMV  
23:39 - node environment. And I actually want 
to say that if it is in development,  
23:46 - then I want new design to be on.  
23:51 - And if I hit save on that, we should be able 
to see the new design still, because we are in  
23:58 - development, we are running the node process 
here in development, it's not in production.  
24:05 - So let's go ahead and verify that and say that 
if we want the new design to be on in production,  
24:13 - we have to be running process in production. 
And now you can see we get the old design  
24:20 - or the current design. So that's gonna help us 
because that means that when we actually deploy  
24:29 - this, if we have this set to development, we don't 
have to worry about this making it into production  
24:38 - provided that we are specifying the correct 
parameters when we are running the process.  
24:49 - Alright, so one of the pitfalls and we kind 
of mentioned that when we were doing the  
24:54 - environment variable is that if you're just having 
a fly in your code, it can be quite easy. to risk  
25:02 - not remembering to turn it back off again, 
like you're working on a feature, something's  
25:08 - happening, maybe the babies are crying, or you're 
burning your food, or you have to run your minds  
25:13 - elsewhere, and you come back in, you forget that, 
you put the flag on, and you commit something,  
25:19 - and maybe you, maybe you get it into production, 
like, obviously, you'll have some other gods,  
25:27 - right? You're a good developer, you have people 
reviewing your code, and someone's gonna catch it,  
25:32 - I'm sure. But what if they don't like, it 
can happen, should happens. And you do have  
25:41 - run this risk if you're not using environment 
variables, and you have the flag in your code. But  
25:46 - there are easy ways to get around that. Now, 
another thing that you might experience is that  
25:53 - you actually reduce the benefits of feature 
toggling when you're putting it in the code,  
25:59 - because one of the big benefits is that you can 
actually use the configuration from an external  
26:08 - location to toggle the feature on and off in 
your code without actually doing another deploy.  
26:14 - And like that's the real magic, not the stuff that 
you can actually merge it in. That's good. That's  
26:19 - nice. But the real magic happens when you can 
actually control your application from an external  
26:27 - source. And you don't have to do a new deploy in 
order to, in order to get a new version of your  
26:33 - code out there, you can just flip a switch, and 
there's another version of your code that will run  
26:38 - live in production. So think about that, like 
you have a product manager or something that  
26:43 - is launching a new feature. And he's at home, 
and it's Friday night. And you're trying to  
26:49 - launch a new feature, because you always launch on 
Fridays, right? That's, that's a golden rule. But  
26:56 - what if something goes wrong? Like he has to call 
up his developers, they have to figure out what  
27:01 - went wrong. And then they have to deploy a new 
version? Well, what if he could just push a button  
27:09 - and go on with his weekend, and then on Monday, we 
can go back to trying to figure out what's wrong.  
27:15 - That's the real magic. And that's what we're going 
to take a look at in the next section. Alright,  
27:23 - so what we'll do now is we'll focus 
on taking this flag that we have  
27:27 - inside of our code, and we want 
to move it to an external service,  
27:32 - so that we can toggle the feature on or off, 
and without having to redeploy our code.  
27:39 - Now, the way we'll do that is we'll use a service 
called Jason min, which allows you to host Jason  
27:45 - in the cloud, and you get an API URL that you 
can use to retrieve the Jason configuration.  
27:54 - So let's go ahead and create our Jason 
configuration. And we have the Ben creation  
27:59 - screen in front of this right here. So we'll go 
ahead and put in a Jason configuration here. And  
28:07 - we'll start with the open curly brackets, and a 
key that says new design. And we want the default  
28:14 - value to be false for now. Also, we have to make 
sure that we put this from private to public bin  
28:22 - so that we are able to get the configuration 
without an API key, just for testing purposes.  
28:28 - Of course, if you're running this in production, 
or you want a more robust setup, obviously,  
28:33 - you want to have a proxy in between that can take 
care of hiding your API key on the server side.  
28:40 - But for now, we're going to keep it public so that 
we can easily retrieve the information and then  
28:46 - we'll take a look at how to use a proxy later 
on. So let's go ahead and hit create on that.  
28:55 - And you can see now we have a access URL down 
here in the bottom of the screen. We'll copy that.  
29:02 - And just to make sure that this is working, 
they sit in. And here you can see we have the  
29:09 - Jason configuration. Alright, so now that we 
have that, we can jump into the code and start  
29:16 - putting it together the pieces that we need 
in order to retrieve the configuration.  
29:22 - Alright, so here we are back in the code. And 
we are in a component called default layer,  
29:29 - which is a component that wraps 
all of the other components in  
29:33 - this project. And this is where we'll add 
the logic for retrieving the configuration  
29:39 - and it will use it to supply the configuration 
down to the components that need it. Now this  
29:45 - is something I would normally use hooks for. But 
since we are using class components here, this is  
29:51 - the method that we are going to work with. So to 
begin with, let's go ahead and add a constructor  
30:01 - And we'll go ahead and take some 
props. And we'll say, super props.  
30:08 - None, we'll initialize our state. And we 
want the state to have a ready property.  
30:17 - And we're going to add a new design. 
That's going to be our initial states. Now,  
30:26 - next up, we'll add a fetch feature toggle on 
figuration. And inside of here, we are going to  
30:40 - get the configuration from our Jason 
bin. So let's go ahead and say fetch.  
30:46 - And now we need to go ahead and retrieve 
the URL, we'll go ahead and copy that.  
30:55 - And we'll paste that in here. And then we'll 
say, we'll get the result. And if the result  
31:04 - is okay, so if it's 200, then we want to return 
press Jason. And then we'll take that Jason data.  
31:21 - And we'll say if they get ready, is 
false. And we'll say this set state  
31:33 - ready is true. And new design equals JSON dot 
new design. Otherwise, we'll say this set state.  
31:47 - And we'll make sure we put this in the 
right place. And we want to return here.  
31:56 - So if ready is not false, we will just want to put 
the new design through the Jason new design value.  
32:11 - Let's go ahead and hit save on that.  
32:15 - And then we need to add this here on the 
states. This we're referring to the class.  
32:23 - And let's go ahead and throw 
an error here. If we fail to  
32:30 - get the configuration, and we'll 
just catch and log it out for now.  
32:38 - Alright, so let's go ahead and make sure that we 
call this function. And we'll go ahead and do that  
32:44 - in the component did mounts, they'll say this 
fetch feature toggle configuration. And then I  
32:51 - think we set the new design to be false in the 
adjacent bin. Let's just check that quickly.  
32:57 - We did. Though, we'll clip this to true, just 
to see that we are getting the expected results.  
33:05 - When we retrieve our configuration, we 
can also inspect the network requests. So  
33:13 - let's go ahead and just log out 
the states in our render function.  
33:22 - And then we'll head over to the browser, 
and we'll check out the behavior.  
33:29 - Alright, so let's go ahead and 
open up our developer tools.  
33:37 - And we can see that in our console, we have two 
objects. The first one is the first state. So  
33:44 - we set new design to true and ready to false in 
the initial state. And then we have the updated  
33:51 - state here where a new design is false and red 
is true. So we get new design from the JSON bin,  
33:59 - and we set the property to be false. We can 
also verify this by checking the Network tab.  
34:09 - So let's hit refresh here. And that's 
gonna capture all of the network requests.  
34:18 - And we can see in the top pair that we have 
in the request, it's asking towards this URL,  
34:30 - and the response is the base and then content. 
Alright, so now that we have that, let's focus  
34:38 - on getting this data into the components 
that need it. So we'll head back to the code.  
34:49 - Now we need to pass this state down to the header 
because we need to hide the universal navigation  
34:58 - based on the flag And then we also need to get 
it into the landing page component. So let's  
35:05 - take a look at this render function here. And we 
can see that we have a lot of links, you can see  
35:14 - we have the header here. Let's go ahead and pass 
new design here and say this state new design.  
35:28 - And then we are going to have to do a little 
bit more work in order to get it into the  
35:38 - landing page component because we are rendering 
children here, which is basically the React way  
35:44 - of saying that anything that is put inside of this 
component, when it's rendered, all of its children  
35:52 - are going to be fit inside of here. So we 
can't access the children at the time they are  
36:00 - initialized, which means that we can't actually 
pass the children props, or properties. So what  
36:07 - we need to do is we need to go ahead and recreate 
the children. So we'll do react children map.  
36:18 - And then we'll pass the 
children as the first argument.  
36:22 - And the second argument will be a function. And we 
will receive the first or the child's as the first  
36:33 - argument. And inside of this function, we want 
to take the child and we want to clone it and  
36:44 - decorated with the new parameters that we want 
to pass down. So let's do react, clone element.  
36:55 - And make sure we put return in front of that. 
And we'll say child, and we'll say new design,  
37:04 - this state your design. Alright. So that should 
take all of the children, loop over them.  
37:14 - And take each child make a clone and pass 
it these properties or this property.  
37:22 - So let's go ahead and find the index page 
components. That will do index page. Now  
37:32 - let's go in here in the index TSX part of the 
index page. And that's going to be the child  
37:42 - that we're passing the prop two, 
so need to accept props here.  
37:47 - And since this is a TSX file, we're going 
to be good citizens and create an interface.  
37:55 - And we'll say new design is a Boolean. 
And let's say page is a string.  
38:08 - And let's go ahead and pass the props here. And 
then we'll take the properties which is an object.  
38:18 - And we'll pass them along to the landing 
page here. Let's open up that components.  
38:27 - And we'll accept the parameter here. 
And let's go ahead and log this out.  
38:41 - So now if we head over to the browser, and we open 
up the developer tools, we should be able to see  
38:49 - a console log that says false. And we do right 
down here. So that means that we have successfully  
38:56 - moved the data down to the landing 
page component. So let's go ahead and  
39:03 - go back to our code. And we'll swap out the 
new design on here with the new design property  
39:15 - up here. So we'll do this 
instead of our built in flag.  
39:21 - And we are going to go ahead and do 
the same in the header components.  
39:26 - Let's go ahead and find that which is up here.  
39:32 - And we are going to say instead of new 
design on we'll say this box, new design.  
39:45 - And currently, this is set the poll, so 
we expect our old landing page to return,  
39:53 - which it does. And here we also have the 
header just a little bit slow rendering there.  
40:01 - Alright, so to round up the section, we 
want to make sure that we can use the J  
40:06 - S bin configuration to control which design is 
running on this site. And in order to do that,  
40:16 - we need to make a few final changes to the code. 
So let's go ahead and jump back in. And you can  
40:22 - see we already have built the functionality to 
fetch the configuration and to update the state.  
40:30 - And now we need to make sure that we're able to 
get the new configuration once the configuration  
40:38 - changes in the JSP. And the way we'll handle them 
is we're going to set up an interval. And that  
40:45 - interval is going to refetch the configuration 
every five seconds. So we'll go ahead and set an  
40:53 - interval here. And the function that's going to 
run is this fetch feature toggle configuration.  
41:03 - And as we said, we want that to run every five 
seconds. So with that in place, now, we just need  
41:12 - to go down here, and we need to make a change to 
this URL. Because we want the latest configuration  
41:20 - every time we fetch against this. Otherwise, we 
would get the first version and not the updated  
41:28 - one. So we need to make sure that we put on 
latest at the end here. And since we set up  
41:34 - an interval here, we also want to make sure 
that we go ahead and clear that interval,  
41:39 - should the components are not. There, if we hit 
save on that, we can head back to the browser.  
41:51 - And as you can see, we still have the original 
view here. But if we head over to our J spin,  
41:58 - and we hit edit, and we flip this state to 
true. And we go ahead and update the Ben.  
42:08 - Now if we head back to our website, we have the 
new design in place, because we're now controlling  
42:16 - the feature using the J S bin configuration. And 
there you have it. And honestly, this is easily  
42:25 - one of my favorite things about feature toggling 
having the ability to just flip a flag like this.  
42:35 - And then seeing the changes instantly reflected 
in your website running in production.  
42:43 - I mean, that's incredible. Having the ability 
to release code with the confidence that if  
42:51 - anything goes wrong, you can just turn it off. 
That's incredible. It gives you so much safety.  
42:58 - And it makes you so much more efficient. As a 
developer, of course, you'll still write tests,  
43:04 - you'll still take the precautions that you need to 
take. But just having that safety net, just having  
43:11 - that level of certainty that if something goes 
wrong, you can just turn it off, makes it a joy  
43:19 - to ride and release code because you're 
eliminating the element of risk. And honestly,  
43:27 - that's like magic to me. Alright, so let's talk 
about some of the drawbacks of using this method  
43:36 - of implementation. So earlier, we talked 
about the fact that if you're using built in  
43:42 - feature flags into your code, you miss out on 
some of the benefits of using feature toggles.  
43:47 - Now you can get some of those back 
by using an external configuration.  
43:52 - But if you did, like we did, now, 
you have to be extremely careful,  
43:56 - because when you're working with raw Jason, 
and that's controlling your application,  
44:02 - it can be a little bit brittle, because Jason 
is a data format. And you need to adhere 100%  
44:08 - to the format in order for it to work. So 
there is a very little margin for error. Now,  
44:17 - in Jason bin, luckily, we have some protection. So 
we can't just put in any arbitrary value and hit  
44:24 - update because it will say that it's invalid 
Jason and we won't be allowed to update.  
44:30 - But what we can do is we can put in something 
like this, where we put in a string, which is  
44:37 - valid Jason, but we put in the string false.  
44:43 - So maybe we were doing something quickly, maybe 
we didn't realize that you have to use True or  
44:48 - False without quotes for it to be a Boolean. 
But the result now is that we still have the the  
44:56 - sign that we started with so we didn't actually 
So we make the update that we wanted to, we have  
45:03 - to go back here. And we have to change this now to 
say, balls, and then hit the update button again.  
45:15 - And now we get the result that we expected. 
So you can see that you have to be  
45:22 - very precise in your instructions. And it's not 
something that you would let someone that's non  
45:28 - technical in there. So you would have to 
kind of keep this in the developer family,  
45:36 - which could be fine. But you need to make sure 
that you are being vigilant when you're working  
45:42 - with this stuff. So that's one thing. Another 
thing might be that, as cool as this functionality  
45:51 - that we've implemented is, and as powerful 
as it is, it's still a little bit limiting.  
45:57 - The, you might want to give certain users 
access to the feature in production.  
46:04 - Maybe you want to do a gradual rollout that rolls 
out to percentage of your users maybe want to  
46:11 - have some metrics on who are getting access to 
this feature or not. Or maybe you just want to  
46:19 - be able to connect from different applications 
maybe have more than one application. And they're  
46:24 - in different programming languages. And you have 
to write these bindings for each application.  
46:31 - And that's when you kind of start looking for 
an vendor of these things, because now we're  
46:39 - talking about hours of investing into developing 
something homegrown. And there might be better or  
46:48 - more robust alternatives out there that you can 
use for free. And that's what we're going to look  
46:55 - in to in the next section, we'll look at some paid 
actors, we'll look at some free actors. And then  
47:02 - we'll dive into the product that I'm working 
on, which is called unleash. Right, so we need  
47:08 - want to do more than just basic feature tarwin, 
like rolling out to a percentage of your users  
47:15 - having certain users get access in production, 
getting metrics, connecting multiple applications,  
47:24 - you quickly find yourself wanting to 
look for a vendor. And I firmly believe  
47:30 - that looking for a vendor in these kinds of 
situation is a good idea. Because every line  
47:37 - of code that you write yourself, you're going to 
have to maintain and code is now in my mind, it's  
47:43 - a living product, it lives over time, you're going 
to have to have a conscious relationship to it.  
47:48 - It's not like you write it once, and then 
you're done, you're going to find that you  
47:53 - have to work with this code again and again and 
again. And you have to either add capabilities  
47:59 - that weren't there before, or you're going to have 
to fix something that isn't working as intended.  
48:05 - So with that said, let's take a look at some of 
the vendors that you can use for feature totally.  
48:11 - And there are a number of actors 
in the space that you can utilize.  
48:16 - And I'm not going to go into detail on them 
here, but I will mention them. So you can  
48:19 - make up your own mind. You have platforms like 
LaunchDarkly split, dyo, WVU, VWO, CloudBees,  
48:29 - Optimizely, and harness, which basically, 
they operate this traditional SAS platforms.  
48:35 - And then you have some open source alternatives 
such as GitLab, rollout, flipper, and unleash,  
48:42 - which is the solution that I'm working on. 
Now, which solution should you choose? Well,  
48:48 - I'm not going to tell you that. And first of 
all, because I'm severely biased, and obviously,  
48:54 - I want you to use unleash. But secondly, it really 
depends on your needs. The vendors mentioned here  
49:01 - all have their strengths and weaknesses. And they 
all have their unique development philosophy.  
49:09 - And I will say this, though, when you're choosing 
a vendor, I think it's also important to take a  
49:14 - look at the development philosophy and 
make sure that it matches your own.  
49:19 - So with that said, I'm going to tell you a few 
words about the development philosophy at unleash.  
49:25 - So first and foremost, we are huge fans of 
open source unleashed started as an open  
49:31 - source product, and it still is one today. And 
95% of our code is freely available on GitHub.  
49:37 - And if that serves your use 
case, you can use that for free.  
49:41 - No problem. And what's great about open source is 
that if you have a problem that we can easily fix,  
49:47 - you can submit a issue and if we tell you that 
we can fix the issue because we have other  
49:54 - priorities, you can always submit a pull request 
and fix it yourself. Or you can fork the code and  
50:00 - make your own adjustments as you see fit. And 
in today's development climate, we believe that  
50:07 - this flexibility is a key factor in order 
to succeed in bringing tools to developers,  
50:16 - developers are curious beings, we like to see 
how things work. We'd like to feel in control.  
50:22 - At least I know I do. And, yeah, I think 
that's important. Though. Secondly,  
50:29 - we believe strongly in privacy. We don't 
think that solutions that claim ownership  
50:35 - over organizations data is a sustainable way 
going forward. And this is why most of our  
50:43 - SDKs are extremely privacy focused, we do all 
of the evaluation of feature toggles locally,  
50:49 - to avoid leaking data back to our system. 
So if you're using our paid, hosted version,  
50:55 - none of the data actually leaves your application, 
it all stays in inside of your ecosystem. And if  
51:02 - you're using open source, you control the 
back end anyway. So there's no issue there.  
51:08 - So with that said, I'm going to take you 
through the architecture of unleash. And  
51:15 - we're going to go ahead and 
see how unleash can help you.  
51:21 - Before we get started setting up the unleash 
open source, let's go ahead and take a brief  
51:26 - look at the architecture just we know what we are 
working with. And we'll start by taking a look  
51:32 - at the SDK 's. And SDK stands for software 
developer kit. And what it basically is,  
51:41 - is pre written code in a programming language 
that handles the connection to the Unleashed API.  
51:48 - So you will use the SDK in your own application 
and configure it to talk to the unleash API.  
51:56 - And then the SDK will go ahead and download the 
feature token configuration at a given interval  
52:02 - that you can tune and it will store it locally in 
memory. That means that you don't have to do an  
52:09 - API call every time you want to check if a 
feature toggle this on or off, you're basically  
52:15 - doing the evaluation and the lookup in the cache 
memory of your application. And that gives you a  
52:24 - lot of performance. And it also means that 
none of your user data is ever shared back  
52:31 - with the unloose server, whether or not you're 
using open source or using the hosted solution.  
52:38 - And let's talk about the API. The unleash API 
is split into two parts. You have the Admin API,  
52:45 - which allows you to do changes to feature toggles, 
add new ones, and update the future configuration.  
52:54 - And then you have the client API, which is one 
that serves the unleash SDK case. And this API  
53:01 - is split from the Admin API, because it's 
supposed to be really stable, rarely changed.  
53:08 - And you can create a specific API key, that's read 
only. So that means that if you should lose your  
53:16 - API key for the client API that serves the SDK 
as the attackers won't be able to use that to  
53:24 - actually make changes in the configuration. So 
anything you can do and unleash, you can do via  
53:31 - an API call. So we have an admin interface 
that we'll see later. But if you wanted to,  
53:37 - you could do everything with curl commands, or you 
could wire up your CI pipeline to talk to unleash.  
53:45 - So let's talk about the proxy. So remember 
earlier when we were talking about the J S bin  
53:50 - integration, and we said that we might want to do 
this via a proxy. And one of the reasons for that  
53:57 - is the added security layer. So when you're 
talking to API's, you usually want to limit  
54:04 - who has access to the API. And you do that by 
generating a unique API key that will provide  
54:11 - access to the holder of this key. Now, when we're 
working in the front end, or the client side,  
54:19 - whether it be a web application, or an native 
app, like an Android or iOS application,  
54:25 - you generally want to keep the secrets out of this 
area, because it's not a safe space. So what the  
54:33 - proxy provides is a layer between your client side 
application and the Unleashed server that provides  
54:42 - secure server to server communication, 
where you can safely store your API key.  
54:49 - In addition to the security of the API key, the 
unleash proxy will only return evaluated toggles.  
54:56 - And this is information that's already 
available in your source code. which is  
55:00 - free for everyone to look at, if they have access 
to the developer tools and can inspect your code,  
55:06 - so you are reducing the amount of information 
that's traveling to your front end to safe  
55:14 - information, so to speak. Aside from the added 
security, you also get improved performance by  
55:22 - using the proxy. So the proxy can handle around 
2000 requests per second. And it's really easy to  
55:29 - spin up and scale new instances of the proxy, 
because it's just a stateless Docker container. So  
55:37 - that's going to give you an easy way to scale your 
application by adding more proxies and connecting  
55:43 - them to the same unleash application. With that 
said, let's go ahead and set up a local instance  
55:51 - of unleash and a local proxy, and start exploring 
the possibilities of using feature toggles.  
56:00 - Okay, so now we're going to go ahead and get 
started setting up unleashed open source on  
56:06 - our local machine. And in order to do that, we 
are going to use a software called Docker. Now,  
56:12 - Docker is a way of taking something called Docker 
containers, which are small virtual environments  
56:20 - that have all of the dependencies 
needed to run a piece of software  
56:25 - and run that as a container on your machine. So 
basically, you're running a small computer on  
56:31 - your computer, which has its own operating system, 
and its own dependencies. And it's already bundled  
56:39 - for you so that you don't have to 
set up your machine to replicate  
56:43 - these dependencies. And it's a really powerful 
way to get started just running software,  
56:49 - if you want to try out new software on your 
local machine. So if you don't have Docker,  
56:55 - make sure you go to docker.io. And you hit the 
get started button up in the right hand corner.  
57:02 - And then just follow the instructions to set up 
Docker on your machine. And then you should have a  
57:09 - mand called Docker. Once you're done that you can 
run in your terminal. So when you've done that,  
57:18 - we are going to go ahead and open up the Unleashed 
documentation and go to the deploy and manage tab.  
57:29 - And under Option One will have the option to 
use Docker. So there'll be some commands here  
57:35 - that we are going to use. We modified them 
slightly for this example, because I've already  
57:41 - set up some of this on my machine and I want to 
do it completely from scratch. So we are going to  
57:47 - head over to our terminal and get started running 
these commands in order to set up long leash.  
57:54 - Alright, so here we are in the terminal. And the 
first thing we'll do is we'll go ahead and create  
58:00 - a network for Docker. So we'll write 
Docker network, create unleash nets.  
58:10 - And that's going to give us a hash as a 
confirmation that we created the network. And now  
58:16 - we'll go ahead and set up Postgres. So we'll have 
this command right here, we'll say docker run. And  
58:25 - we are providing some environment variables. So 
obviously, if you're running this in production,  
58:32 - you want to change the password, and make sure 
that you choose something that's really secure.  
58:41 - But for this example, we are just gonna go with 
the defaults here. And we'll start the postgres  
58:51 - on 5432, and we'll map it to 5001 on our local 
machine. So if we start that, we should see the  
59:03 - postgres output, and right here we see that 
it's ready to accept an actions in the bottom.  
59:10 - So now we can go ahead and open 
up a new tab in our terminal  
59:20 - and we will use a Docker command 
to start the unleased server.  
59:27 - So we'll do docker run. And we'll map that 
to 4242 on our local machine, and we want to  
59:36 - make sure that we match the database host. 
And the database port is going to be 5432.  
59:45 - So we hit Enter on that, that's going to start 
up the unleash application. And now we can head  
59:55 - over to our browser and we can open a new 
tab tab here, and visit localhost or 242.  
60:06 - And here we have the first screen that you get 
to when you open up the address in the browser.  
60:11 - And as part of running the Docker container, 
unleash will set up the database. And it will  
60:16 - run some migration and create all the tables. 
And it will also create a default user. So once  
60:23 - you're here, you can go ahead and log in with 
the following credentials. So that's going to be  
60:28 - admin, as the username and unleash for all as the 
password to go ahead and input that and login.  
60:39 - And you're taken to the main application 
interface. Now, there's not much period.  
60:45 - And we'll explore this in a second. But for now, 
we want to continue with the setup. And we still  
60:51 - have to set up the proxy. And in order to do 
that, we need to do a few things in the UI here.  
60:58 - So we'll go to the Configure drop 
down. And we'll open up API access.  
61:05 - So in here, you can create and delete API keys. 
And we also have the API URL readily available  
61:13 - that we need to supply when we are 
setting up the proxy. We'll go ahead  
61:19 - and create our API token now. And we'll hit 
this button in the upper right hand corner.  
61:25 - And that's going to trigger this dialog. And we're 
going to fill out the name here. And we'll call  
61:31 - it proxy key. We're going to keep the token type 
to client, because that means that this key will  
61:37 - be read only. So it's only going to be allowed 
to read data. We'll keep the project settings  
61:44 - as it is and then we'll change the environment 
to development. And once we have that,  
61:50 - we can create the token. And now we have 
everything we need to set up the proxy.  
62:00 - In order to do that, we'll head back to the 
documentation. And in the left hand side menu, we  
62:07 - have under unleash SDKs, the Unleashed proxy tab. 
If we open that up and scroll a little bit down,  
62:15 - then we can see instructions on how to 
run the unleash proxy. And we are going  
62:21 - to use this command right here. But I have 
prepared it a little bit. So let's go and  
62:27 - head over to the terminal. And here we have 
the command that is going to start the proxy.  
62:34 - So what we've done here is we've taken the API 
token that we just created. And the way we did  
62:41 - that was we went to the UI. And we hit copy 
on this to copy the token to our clipboard.  
62:49 - And then we went back to the terminal and we put 
the token in here. That's the API token that we  
62:58 - created. Now, the unleash URL points to the local 
instance of unleashed running on my machine.  
63:07 - And since I'm on Mac, I have to use host 
Docker internal for the proxy to access this  
63:14 - port through the virtual environment. If 
you're on Mac, sorry, Linux or Windows,  
63:22 - it's going to be slightly different. But I'm going 
to include documentation on how to get that done.  
63:28 - So that you can follow along. In the top, we 
have something called unleash proxy secret,  
63:35 - which is just a very thin layer of security. 
Like I said before, anything that's exposed on  
63:44 - the client side is not really a secret. So the 
main security of the proxy comes from the fact  
63:51 - that it takes the API key, and it hides it in 
server to server communication. And it doesn't  
64:00 - give any other data out other than evaluated 
toggles and information that already exists  
64:06 - in your source code. So while you 
will put up a secret here that will  
64:12 - allow the clients that are connecting to the proxy 
to read from the proxy, if they have the secret,  
64:19 - the main security is within the proxy itself. So 
with that said, you can go ahead and start it.  
64:27 - And it's going to say that it's now listening 
on port 3000. And if we want to go and check  
64:34 - if this is working, we can take this curl command 
here and copy that and head back to the terminal.  
64:43 - paste this in a new terminal window, 
and you can see that we get response  
64:51 - with an empty toggles array, 
which is what we expect.  
64:55 - Okay, so now that we have the proxy running, let's 
go ahead and take a quick tour of the application,  
65:01 - and then we'll create our first feature 
toggle. So we're currently in the main view,  
65:06 - we will navigate to the project section. And here 
we have the default project, which is the project  
65:12 - that we get for free when we start up. And this is 
the only project that we have in the open source  
65:18 - version. But it should be enough for our use 
case. If you open that up, we have a view that  
65:25 - gives you a little bit more information about 
the project. And we're not going to go through  
65:29 - everything. But I want you to take note of 
the environment section. If we head over here,  
65:35 - you can see that we have the default 
enrollment enabled. And then we have  
65:38 - development and production as disabled. And this 
will be more important later when we start to  
65:44 - do more advanced segmentation. And we want to 
decide who gets access to a feature. And we can  
65:51 - segment that on environments as well. So 
for now, we're just going to turn this on.  
65:59 - And we're going to head back to the overview here. 
And we'll go ahead and we'll create our first  
66:05 - feature toggle. So in order to create a pitch 
toggle, we just need to give it a unique name.  
66:12 - And we'll go ahead and hit create. And 
then we are taken to the total overview.  
66:19 - Now, there's a lot of information here. But I 
want us to focus on this part in the middle.  
66:24 - So see this traffic section right here. Notice 
how it corresponds to the environments that we  
66:30 - turned on in the project. So since we turned on 
production and development, we now have the option  
66:37 - to see traffic from those environments. And if 
we scroll a little bit further down, we have a  
66:43 - strategy section. And this is an important concept 
in unleash because strategies are really rules  
66:51 - that determine whether or not a feature should 
be on or off. And you can add these rules to any  
66:58 - environment, and they will only be active in that 
environment. So let's take a look at an example.  
67:05 - We'll go to the strategies section. And we want 
to navigate to the development environment,  
67:13 - we don't want to add one to the default 
environment. And I'll explain why in a second.  
67:18 - But let's go ahead and add the gradual 
rollout to the development environment.  
67:24 - So what we see here is the configuration of 
the strategy. And we can adjust this to be 25%.  
67:32 - And you can see that's reflected 
in the execution plan here.  
67:36 - And it says that 75% of your user base 
is included. So if we save the strategy,  
67:43 - now we can see that we have one strategy in the 
development environment, but the environment is  
67:50 - still disabled. So in order for a strategy to 
be executed, we need to turn on the environment.  
67:59 - And the difference between doing this and what 
we just did in the Project Settings is that  
68:05 - when we set it in the project, we set a project 
by setting or all of the feature toggles that  
68:10 - we create, that gives all feature toggles access 
to these three environments. But what we're doing  
68:17 - here is we're saying, for this feature toggle, 
we want the strategies in this environment  
68:23 - to execute. So it's a handy way to turn on 
or off an environment or a feature toggle.  
68:31 - Now, what we can do is we can head over to our 
terminal. And we can try the command again to  
68:36 - call against the proxy. And you can see that 
we're getting the page toggle in the first call,  
68:45 - then we're getting in the emptier in the second. 
And then we're getting the feature toggle again in  
68:49 - the subsequent calls. So what's going on? Well, 
if we take a look at the configuration here,  
68:57 - we've set the strategy execution to be 75%. 
Which means that three out of four calls, we  
69:04 - should get the feature toggle. And that's exactly 
what's happening. So if we bump this up to 100%.  
69:11 - And we hit save, and we head back to the 
terminal again. Now if we go ahead, and we  
69:21 - try to get the feature configuration, we should 
get it every time. Alright, so how does this work?  
69:30 - How does the proxy now that we want to fetch the 
configuration from the development environment?  
69:36 - Well, if you remember back to when we initialize 
the proxy, remember the API token part here. Or in  
69:44 - here, we've specified the development environment 
as part of the API token. And actually,  
69:50 - we configured that when we created the token. So 
if we head back to the UI, and we go to the API  
69:57 - Access section, when you hit Create API token, you 
have the ability here to change the environment.  
70:05 - So that determines which environment it's 
going to fetch the configuration for.  
70:13 - Alright, so now we know enough to 
implement this in a real application.  
70:20 - Alright, so we're back to the component that we 
started with. And now we've taken it out of the  
70:26 - Free Code Camp codebase. And we moved it into a 
create react app project, just to reduce some of  
70:33 - the mental clutter and overhead when we're working 
with this. And we've done some modifications that  
70:39 - will use a feature toggle to turn on and off. 
And we'll go ahead and take a look at that now.  
70:46 - So in the app js file, you can see what's 
currently being rendered to the screen. And inside  
70:53 - of app, we have a conditional render component. 
And based on the condition that is given, it's  
71:01 - either rendering the applet chatbot component, or 
the app without chatbot component. So currently,  
71:08 - it's rendering this last component here. And you 
can see these are defined in the same file. So  
71:16 - let's see what happens when we flip this to 
true just to get the visual confirmation here.  
71:23 - And you can see now we have this chat 
button in the bottom of the screen,  
71:28 - we can click that. And we can 
type into the message box here.  
71:35 - And this is what we want to feature toggle. 
So this is our feature. And we want to turn  
71:40 - it on for a subset of our users. So in 
order to do that, let's go to the unleash  
71:51 - instance here. And we'll create a new 
feature total. We'll call that chatbots.  
72:01 - And we'll go to the strategy section. And we'll 
add a bungee to the development environment.  
72:14 - So we'll set it to be a gradual 
rollout of 0% to begin with.  
72:21 - And then we will turn on the environments here.  
72:26 - From here, we can go ahead and start 
connecting our application to unleash.  
72:31 - And we'll do that by using the unleash proxy 
client or react. So we just need to follow the  
72:42 - instructions here. And we'll start by adding 
the unleash proxy client to our project.  
72:49 - So open this up and add the proxy clients. 
And then we can repair a little bit by taking  
73:00 - this part right here. And going back to 
our project, and then we can paste this  
73:05 - in. And now we need to make sure that the conflict 
is correct. So we'll swap this out with localhost  
73:15 - 3000. And make sure we're on HTTP, the proxy key 
is going to be let's go ahead and check that.  
73:29 - Some secrets are put that in as well. We'll 
set the refresh interval to be five seconds.  
73:38 - And we'll change the app name to FCC play. 
Though the environment here is not related to  
73:46 - the strategies that we talked about earlier, 
this was actually in place before we added  
73:51 - strategy support. But the only thing 
that affects where you are patching,  
73:56 - or which configuration you are fetching is the API 
key and the configuration of that API key. Okay.  
74:05 - So with that said, we now have a config 
that we are supplying to this flag provider.  
74:12 - And we should be able to add into our app 
component and start using our feature flags.  
74:20 - So in here, we're going to grab a 
few things from the proxy files.  
74:25 - So we'll import the use flag and use flags status.  
74:35 - And what we can do now is we can say enabled 
equals US flag and then we need to pass the  
74:44 - digital name here. So let's 
go ahead and make sure that  
74:47 - this is the actual name of the future tutorial.  
74:52 - And we can see that here. So that should be fine. 
If we now head back, we can go ahead and See  
75:03 - his flag status  
75:08 - and want to grab bags ready from this object. So 
if not bags ready, we are going to return a loader  
75:28 - just a simple loader now. Otherwise we'll use the 
enabled flag to render the correct version. Let's  
75:37 - log this out as well after the flags ready 
just to make sure we are triggering that  
75:44 - events. So if we go back to the browser, 
and now we can open up our application.  
75:54 - And if we refresh here, we expect to see the 
loading flash, and we expect to see the Boolean  
76:00 - load down in the console. And we do so the SDK 
has successfully been wired up. And it's set up  
76:09 - a polling in the background. So we go to unleashed 
now. And we change this gradual rollout to be  
76:17 - 100%. That should be reflected, and we go back 
here, we should be able to see that the new  
76:29 - components is being loaded, because this has been 
put to true. The now the conditional render is  
76:35 - reloading the right component. So if we hit here, 
we open the Chatbot. And we can interact with it.  
76:45 - And we can also go back to 
unleash and turn this off again.  
76:52 - And that should propagate and remove the Chatbot. 
Nice. So I never get tired of seeing that. Even  
77:01 - though this is just localhost. When you're doing 
this in production, it just feels like magic. And  
77:09 - now we've seen how it behaves when you have that 
0%. And when you have that 100%, which is what  
77:15 - we expect. It's either 100% on or 100% off. 
But let's try changing the gradual rollout to  
77:23 - 50%, for example. And we'll hit Save. 
And let's go ahead and refresh this page.  
77:34 - And we'll refresh just a couple of times here. 
Because we would expect the chatbot to turn up 50%  
77:41 - of the time, right, because that's 
what we set the gradual rollout to,  
77:45 - but it seems like it doesn't. So there's 
something going on here. Let's copy this URL.  
77:51 - And we'll open up a new incognito window. And 
we didn't get it there. Let's try this again.  
78:03 - And not there either. So 
maybe third time's a charm.  
78:10 - And not there either. So that's interesting, 
because it is a 50% chance. And there we have it.  
78:19 - So here it turns up. And the reason that 
it turns up here, and if we refresh this,  
78:27 - it's going to stay here. Because 
we are using the session ID  
78:36 - to ensure that we get the same experience. 
So if we take a look at this call here,  
78:42 - you can see that the session ID is sent as a 
parameter to the proxy. And as long as you stay  
78:49 - within the same session, you will get the same 
experience. Because we don't want this to change  
78:55 - just randomly, right, we want the users to have 
the same experience even if they reload the page  
79:01 - in the same session. That's why in our 
other tab, we don't get the Chatbot,  
79:07 - because we already received a version of the 
site that does not have the Chatbot turned on.  
79:15 - And even though the percentage is set to 50%, 
we are now in the category that will not receive  
79:22 - the feature. And this is quite useful, because we 
want to be able to keep a consistency in the way  
79:28 - that the user experiences the site. Now, session 
ID that's quite limiting because the user might  
79:36 - turn off their computer, they might go on their 
phone, they might visit a friend's house and use  
79:41 - their computer and then the session ID can't 
be used in order to determine whether or not  
79:47 - the user should get the same version because the 
session ID will be different from time to time.  
79:54 - And maybe there's a way we can look at where 
we can actually keep it consistent. Even If  
80:00 - the user changes their device, and to do that, 
we need to take a look at the English context.  
80:08 - So, English context is used for a couple of 
things. It's used for strategy, standardization.  
80:15 - It's used for stickiness. And it's also used 
to pass properties to custom strategies if  
80:20 - you implement those. So there's a few fields here, 
like dynamic context fields that you can populate.  
80:28 - And one is the user ID. Another is the session 
ID. And then we have the remote address.  
80:36 - And finally, we have the properties, which is a 
map that you can very can put anything you want.  
80:44 - Now, remember back to when we talked about the 
architecture, we said that when the SDK does the  
80:51 - evaluation, it receives the configuration 
from the unleash server. And then it takes  
80:58 - the context that it receives. And it merges the 
two together, and makes a decision on whether or  
81:04 - not this is on or off. So to illustrate that, 
we're going to take a look at the code here.  
81:12 - And this is the Node js SDK, which is 
basically what the proxy builds upon,  
81:18 - it wraps around this SDK. And this here is 
the is enabled call for a feature toggle.  
81:26 - So you received the feature toggle name. And 
you can see we received the context as well.  
81:33 - And what is happening here is we're taking the 
feature from the internal repository of the SDK.  
81:41 - So that means that the SDK has already fetched 
the configuration from the unleash server.  
81:48 - And it will use that configuration together with 
the context and make a decision on whether or not  
81:55 - this feature is enabled. And this is also why 
we recommend self hosting the proxy because the  
82:02 - user data or context that you send from the 
client application, that's going to be used,  
82:09 - as we just discussed, to evaluate the toggle in 
the proxy. And that's where the data flow stops.  
82:15 - So the user data does not go to the Unleashed 
API. So if you self host the proxy, you have 100%  
82:22 - control over your data. Alright, so now we've 
seen a little bit about the unleash complex,  
82:30 - let's go ahead and implement this and see 
if we can use that to get a consistent  
82:35 - experience for our users. So we'll open 
up the unleash proxy client documentation.  
82:44 - And we'll scroll to the bottom and check 
the documentation here for the context.  
82:50 - And it looks like we can take the use and least 
context hook and get a function here. So that's  
82:59 - what we're going to do. If we open up our code, 
we can add the use and which context here.  
83:10 - And we'll say Update context, 
equals use unleash context.  
83:16 - And then we are going to add a use effect 
here. So we'll add that to the Import up top.  
83:26 - And we'll say use effects.  
83:32 - And we only want this to happen on nouns. 
And then we want to update the context  
83:39 - with a user ID. And let's call this user one 
for now. And this should be enough for us to  
83:49 - be able to provide a steady experience 
for the user regardless of the device.  
83:55 - Because if we have back to the Alisha instance, 
and check out the gradual rollout strategy here,  
84:02 - you can see that we have the 
stickiness set to default.  
84:06 - And the default actually checks for a user ID in 
the context first, then the session ID. And if  
84:13 - it can't find either of those, it's going to be 
random. And you can explicitly choose user ID or  
84:20 - session ID here. But the default is going to look 
for first the user ID and then the session ID.  
84:27 - So this should be enough for us to get a sticky 
experience. So let's check it out. If we go to  
84:34 - our application, and we open up the developer 
tools, and we can now see that the costs that  
84:42 - are being sent to the proxy, include the user 
ID here. So this means that no matter how many  
84:52 - windows, we open up, we should get 
the same experience to remember  
84:59 - when we did this before, it was a 50% chance that 
we would get another experience. But now you can  
85:07 - see that the experience is the same no matter 
how many times I will open this new window.  
85:20 - Let's try one more time, just to make sure we 
are completely sane. And we can see that we  
85:27 - still have the same result. Now, let's jump 
back to the code. And notice that the value  
85:33 - use a one here is hard coded. Now, this doesn't 
really make sense, because that means that every  
85:41 - single user that visits your site will use this 
value to hash and get the same result, every time,  
85:49 - what you typically want to do is you want to get 
this value from an API. And that's going to be a  
85:55 - unique identifier for each user. And this will 
ensure that every user gets a different result.  
86:03 - Alright, so we've taken a look at the gradual 
rollout strategy. And we've also been through  
86:09 - the unleash context. And now we can also take 
a look at some of the other strategies that we  
86:15 - have available to us. So before we start, let's 
go ahead and put the gradual rollout to serum.  
86:22 - And we can go ahead and add a user ID strategy. 
Now, a user ID strategy is typically a strategy  
86:31 - you want to use while you're developing something, 
because it will allow you to ask a set of user IDs  
86:38 - that will get access to the feature. So you could 
have this behind a feature flag in production. And  
86:44 - you could give access to a specific set of users, 
which could be the developers or maybe a product  
86:51 - manager, or a tester or another stakeholder in 
the organization. So if we put in user one here,  
87:01 - and we add this, now, we will see that 
the execution plan is updated. So 0%  
87:07 - of the user base is included, and will give access 
to one user. So if we go back to the application,  
87:18 - now we can see that we have access to the 
feature here. So we can go ahead and open up  
87:24 - the Chatbot again. And now we can do exactly 
the same as we did with the gradual rollout,  
87:32 - we can go ahead and either remove this strategy 
entirely. Or we could just remove the user.  
87:41 - And if we now head back to the application, now 
we don't have access to the feature anymore. So  
87:48 - that's completely based on the values that are 
sent into the context that we just discussed.  
87:55 - So since I have user one, as a value here, I 
will get access to this feature if my user ID  
88:03 - is defined in the strategy. So if I go ahead and 
go back to the strategy here and put user two,  
88:11 - that's not going to work, because my user ID is 
user one. So if we go back to the application,  
88:19 - we can see that we don't have access here. 
But if we go back to the strategy again,  
88:25 - and add our user ID, and hit save, you should be 
able to see that the teacher now shows up again.  
88:36 - And we can once again open up and 
interact with each other. Alright,  
88:42 - so now that you've seen how to use the user 
ID strategy to give access to certain users,  
88:49 - let's jump back to the Unleashed instance. And 
we'll have a look at the strategy is section here.  
88:55 - Because what's really cool is that you can 
have as many strategies as you want. And as  
89:01 - long as the environment is on, they will all be 
evaluated. And if any one of them return true  
89:07 - for the given context, then the feature 
will be on for that user. So that means that  
89:15 - if you have a gradual rollout set to zero, like 
we have here, then it will be on or no users.  
89:21 - But we will also go ahead and check the user 
ID strategy. And since my user ID is user one,  
89:28 - and I passed that in, I still get access to 
the feature. So every strategy is evaluated.  
89:37 - And that makes it really flexible. Because 
you can add as many strategies as you want  
89:41 - that constraint on different properties. And 
you can even create your own custom strategies  
89:47 - and provide the implementation in code so that 
you can create strategies that don't really  
89:53 - exist in the system out of the box, but that you 
need in the complex that you're operating in.  
89:59 - So if we open up the sidebar here, we can 
take a look at the built in strategies.  
90:04 - And we've already been through two of them. And 
the IP and host strategy work very similarly to  
90:10 - the user ID strategy. So if we add the IP 
strategy, we need to provide an IP here.  
90:20 - And once we've added that, and we saved the 
strategy, we can see that the execution plan  
90:26 - is updated. But now we need to take this IP, and 
we need to add it to our code. So let's go ahead  
90:34 - and remove our user ID, because we want to see 
that we don't have access to the feature anymore.  
90:41 - If we jump back to our application, now 
we don't have access to the Chatbot.  
90:47 - But if we go ahead and take this IP 
address, and we head back to the code,  
90:54 - now we can add a remote address property 
here. And we put in the IP address.  
91:01 - And let's go back to the browser. And now we 
once again have access via the remote address  
91:08 - strategy. So all of the strategies have been 
evaluated. And this final one return true.  
91:16 - So we get access to the feature because our IP 
address matches the value that is put in here.  
91:23 - Alright, and now we've gotten our feet a little 
bit better with feature toggles. And we've  
91:28 - seen how we can use branches to target different 
segments of the user base. So what I want to focus  
91:35 - on next is experimentation. And sometimes, as 
developers, we want to develop different versions  
91:42 - of a feature, and try it out. So we can determine 
which one performs better. And that's a process  
91:52 - that keeps the users close to us. And that's 
important, because we don't want to just take  
91:58 - a feature and run with it and develop something 
that we think is right, we want to continuously  
92:04 - validate that we're actually building something 
that gives real value to our users. And in order  
92:12 - to do that experimentation, and a B testing can be 
quite powerful tools that we can use to figure out  
92:19 - which one performs better. And I'm going to show 
you how to do this in unleash. But before I do,  
92:26 - I just want to mention quickly how we think 
about working with other services because  
92:31 - we don't have any built in analytics in release. 
And one of the reasons for that is actually back  
92:37 - to our philosophy. Because we believe that 
there's a lot of software being written today.  
92:43 - And there's a lot of great work that others 
do. And, for example, analytics, you have great  
92:50 - providers that provide a world class analytics 
experience. And we believe that it's our job to  
92:58 - make as many integration points and 
provide as flexible as system as possible.  
93:05 - So that you can use the great work of 
others, and combine services to gain a  
93:11 - better experience. So we're not really focusing 
on implementing analytics in the traditional sense  
93:19 - when it comes to experimentation, we instead focus 
on giving you the option of taking some provider  
93:28 - that you're probably already using today. And 
pairing that with data from unleash. And then  
93:34 - you can send that off to your analytics provider 
and do the necessary analysis on the data.  
93:42 - So with that said, let's jump into it and see how 
we can do some A B testing with unleash. Okay,  
93:50 - so here we are back in the unleash application. 
And we've done a little bit of cleanup on the  
93:56 - Chatbot pitch toggle. As you can see, we removed 
some of the strategies that were here before. And  
94:04 - what we're left with is the gradual rollout 
that's rolling out to 100% of our users.  
94:11 - So we're going to use this feature toggle and 
set up an ad experiment. And in order to do that,  
94:19 - we'll need to learn about a new concept and 
unleash old variants. So we'll navigate to  
94:24 - the variants tab. And we'll go ahead 
and add a couple love variant a here  
94:35 - and then we'll add another one.  
94:40 - And now we basically have the setup that 
we need. We still need to do some work on  
94:46 - the code side of things. But before we do, let's 
try and understand the weight distribution here.  
94:52 - You can see that each variant has a weight 
distribution of 50%. And this means that  
94:58 - if the percent of the year users that are visiting 
our site and that get access to this feature  
95:04 - will get variant A, and 50% will get variant B. 
So let's take a very concrete example and say we  
95:12 - have 100 users visiting, we have a gradual rollout 
that says that everyone visiting will get access,  
95:18 - that means that 50 users will get variant A and 
50 users will get variant B. But let's change the  
95:26 - strategy just to see how that affects the weight 
distribution. So we'll change this now to 50%.  
95:37 - And we'll head back to the variance. 
Now, let's take the same example. Again,  
95:43 - we have 100 users visiting our site, we only have 
50% rollout. So that means that we only have 50  
95:52 - users that get access to the Chatbot feature. 
And since we have a 5050 weight distribution,  
95:58 - that means that of those 50 users 25 users will 
get variant A and 25 users will get varying B.  
96:06 - So it's all relative to the amount of people that 
get access to the feature toggle. So you can think  
96:12 - of strategy's sort of like a gatekeeper that lets 
people through or not. And then the variants can  
96:18 - be thought of as pathways that we send the people 
that get through the gates, on after they are  
96:25 - led through. So currently, we have variant a and 
variant B, which means that there are two possible  
96:31 - pathways for the people that are lit through. And 
we could easily add more pathways if we wanted to.  
96:38 - But hopefully that makes sense. And we'll now 
go ahead and implement the code side of this.  
96:46 - So before we jump to recode, 
let's head back to the  
96:49 - strategies. And we'll make sure that we 
set the gradual rollout back to 100%.  
96:58 - And with that, we can check that we 
propagate this to the application.  
97:04 - And we do so let's head into the code now. And 
we'll grab the use variant hook from the unleash  
97:13 - proxy client library. And then we'll do variants 
equals use variant. And we'll put in the feature  
97:24 - toggle name. So with that, we can go ahead and 
log this out here. And we'll open up the console.  
97:38 - And we can see here that B got the variant A, 
which corresponds to the variant name that we  
97:44 - added for one of the variants. You see. Here, 
we have the variant a here, so we automatically  
97:53 - got one of the variants that we defined. 
Now, we also have the enabled true here,  
98:00 - which means that we don't really 
need to use the US flag hook anymore,  
98:05 - because we get both of the data properties 
in this object. So we'll go back to the code.  
98:12 - And we'll remove the enabled. And 
then we'll say, aren't enabled here.  
98:21 - And we'll pass the variant as a prop 
here to this app with chatbot component.  
98:31 - And let's accept it here. So what we 
want to do now, based on this variance,  
98:40 - we are going to render a different welcome 
message in the chat bot. So in order to do that,  
98:48 - let's create a new function inside of the 
configuration here. And we will create a  
99:03 - config method which is going to take a 
welcome message and it's going to return  
99:16 - the configuration that we put in here  
99:23 - but the initial message is going to be the welcome 
message. So we'll export the complete function.  
99:37 - And then we'll head back to app 
J S. And we will rename this  
99:48 - Okay, so let's remove the use flag here since 
we're not using that anymore. And we'll scroll  
99:55 - down to our app with chatbot component where 
we are accepted In the variant as a parameter,  
100:03 - now we're gonna do config equals yet conflict. 
And then we want to paste in the message here.  
100:10 - And I've already prepared that. So we skipped 
some typing. But what we want to do is we want  
100:16 - to check the variant name, like we're doing here. 
And if the variant name is variant A, then we  
100:25 - want to have this folk message. Otherwise, 
we want to have this welcoming message.  
100:32 - So we'll hit Save. And we'll pass this into our 
git config. And we are passing the config here.  
100:41 - So everything is as it should be. So with that, 
we can go ahead and open up the browser again.  
100:50 - And you can see that we get the welcome 
message here. And if we refresh,  
100:56 - and we open up the Chatbot. Again, there we 
have the same message. So that's working fine.  
101:03 - So let's see if we can trigger this message here 
as well, because right now we have been given  
101:11 - a variant. And that variant is not going to 
change because we have passed in the User ID here.  
101:20 - And that will ensure that the variant is sticky 
as well. So we'll get the same experience  
101:27 - whenever we open the website. 
But what we could do in order to  
101:34 - trigger or force a change is we can take this 
user ID here. And we can go back to our unleash  
101:44 - application. And inside of variant B, we can go 
ahead and add an override. And you see here we  
101:53 - have a context field called User ID. Let's put our 
user in there. And we'll hit Save. And you can see  
102:01 - now we have an override on this variant. If we 
go back to our application now, and we refresh.  
102:12 - Now we can see that we have another message. 
And that's in fact, the message that we  
102:19 - provided as an alternative. Cool. So here, 
we use invariants, to change the messaging  
102:26 - in the chat bot when we launched it. But that's a 
simple example. And if we take a look at the code,  
102:33 - all we're really doing is we're checking the 
variant name, and then doing something based  
102:39 - on that. So here we're changing the text. But it 
could easily be rendering a different component,  
102:46 - or changing something within another 
component. It's really up to you,  
102:52 - and what your experiment entails and how you 
want to go about it. But it's as flexible as  
102:58 - it needs to be to cover the use cases that you 
could have. And here we only have two variants,  
103:04 - but you could easily have three or four or 
five. And that's up to you and your your  
103:14 - now let's talk about analytics. I mentioned 
briefly before that we prefer to defer to  
103:20 - world class analytics providers. In order to 
allow you to integrate with providers that you  
103:28 - most likely are already using today, 
I wanted to show you how we can use  
103:34 - unleash together with your analytics provider and 
create a trail that makes it so that you can track  
103:42 - a given variant through your application. So I'm 
going to show an example with Google Analytics.  
103:50 - And I've already installed the React 
Google analytics package here. So  
103:56 - let's go ahead and initialize it. And then 
we'll take a look at how we could do this.  
104:03 - So what we'll do is we'll import react 
GA from react, da. And then we'll go  
104:16 - ahead and initialize it. So inside of our 
application, we can put it in a use effect.  
104:27 - We initialize it with the following 
parameters, and then this would be your  
104:35 - unique Google Account Key. Alright, 
so let's see a few more changes.  
104:42 - First of all, we'll create a variable for our 
user ID. And we'll put the user ID in here.  
104:51 - And then we will paste that in here. And 
we'll replace the value here as well.  
105:01 - And then what we'll do is we'll 
go down to our ackward Chatbot.  
105:09 - And we'll go ahead and add a use factor as well. 
And we'll make it dependent on the variant.  
105:20 - And we'll see if variants 
name and variant enabled.  
105:29 - Let's do react, da. And we'll use an event here.  
105:35 - And then we can send an event to Google Analytics, 
you can see the label application loaded.  
105:47 - And let's go ahead and add the variants. 
That's going to be the variant name.  
105:56 - And then we'll give it an action. This required 
property, we'll say location loaded with a  
106:06 - with the variant name. And we'll 
also want to give the user ID here.  
106:15 - That means we need to go up in our parent 
component, we need to pass in the User ID here.  
106:29 - And we'll accept that as a parameter. 
And now, I have the ability to send  
106:37 - an event to Google Analytics. And that event 
includes the user ID and the variant name. And  
106:45 - that means now you have your baseline, because 
you have the user ID, and you know that which  
106:51 - variant that user ID loaded up with. So if you're 
tracking more actions on your sites, for example,  
107:00 - if you want the user to convert, or in this case, 
let's say we wanted to check whether or not the  
107:05 - user is interacting with the Chatbot, based on 
the message, we could go ahead and add more events  
107:11 - with the user ID and the variant name in other 
places of the application where it makes sense.  
107:17 - And we know that the action has been taken by 
the user with this variant, okay. So that's  
107:24 - the way we can track the user across the 
application, if that's what you want to do.  
107:31 - Alright, so I want to show you a 
little bit about the metrics as well,  
107:35 - because one of the coolest things about 
feature toggles systems, you can see  
107:39 - the updates live. And you can see who is getting 
access to what feature or how many people are  
107:45 - getting access to a feature. So when you wire up 
the SDKs, and you put up the API key, you'll start  
107:52 - sending metrics based on the environment that that 
API key is configured for. So I currently have a  
107:59 - script running that's calling against the API with 
an API key that's enabled for development. And  
108:07 - we currently have the strategies set to 100%. 
So we have the gradual rollout that to 100%. So  
108:15 - everyone who is asking against this API is getting 
enabled back for this feature. So let's go ahead  
108:24 - and update this. We'll set the gradual rollout 
to 50%. And we had back to our application. Now,  
108:37 - we're going to be able to see as this updates 
that more and more people are getting denied  
108:44 - the access to the feature, and it's going to 
creep back towards the 50% mark over time.  
108:51 - And that's how you can be sure that 
when you're setting a gradual rollout,  
108:55 - or you're setting his strategy configuration 
that you expect is going to be enabled for a  
109:03 - subset of your users, you could use the metrics 
to verify that that is, in fact happening. And  
109:09 - now we can see that we're slowly making our 
way towards the 50% mark. And more and more  
109:15 - of the users are asking for access towards the 
API or getting denied, which is what we expect.  
109:23 - Right? So we talked about metrics a little bit. 
And besides that, there are some other methods  
109:28 - for monitoring that you can do in Unleash. And 
if you remember, we talked to a bar earlier about  
109:34 - technical depth. And we take it really seriously 
because you have to be able to clean up your code  
109:40 - and remove feature flags as you go along to have 
a sustainable workflow, and you're working with  
109:46 - pitch dollars. So I'm hearing the demo instance 
because it has a lot more feature flags available.  
109:53 - And I want to show you the health dashboard that 
we built, which is sort of a work in progress, but  
110:00 - We have an early version of it ready. And we can 
add on to the project. And this is a demo instance  
110:07 - that anyone can log in and use. So there'll 
be a lot of projects here and a lot of data.  
110:14 - Because it's kind of a sandbox that anyone can 
use some trial unleash. So if we head over to  
110:21 - the health section here, you see we have a 
health rating, and we have a toggle report.  
110:28 - And then we have all of the feature toggles 
in this project down in the overview here.  
110:33 - And you get some information here, basically, 
the name of the toggle when it was last seen,  
110:40 - which is when did we last register and SDK 
asking for this feature toggle. And so it's  
110:48 - if it's never seen, then you've never connected up 
in SDK and started to use this feature toggle. But  
110:53 - if you do have a value here, and then you know 
that it's a base, since this last was in use,  
110:59 - which might indicate that it was used in a local 
environment, and not in a production environments,  
111:06 - because if you're in production, you 
would expect it to be continuously  
111:11 - asked for. And then you have like, you can see 
some more information when it's created. And  
111:18 - there is an expired column, which basically, based 
on the type of each table you create, we use some  
111:25 - internal data to calculate when it's expired. 
And for release toggle, that's about 40 days.  
111:33 - Because that's what the research indicates that 
should be the lifetime or life expectancy of  
111:40 - Tableau like that. So you can use this dashboard 
to get an overview over toggles that might  
111:48 - be ripe for cleaning up, and it can help you 
in the effort to clean up your troubles and  
111:57 - get rid of some of the technical depths. 
Alright, that's it for the course. And I  
112:04 - want to thank you so much for tuning in giving 
me the opportunity to explain this concept. And  
112:10 - I hope it's been a valuable lesson in terms of 
understanding how to work with feature toggles,  
112:15 - and how we can use them to simplify your 
workflow and run experiments within your code.  
112:22 - Now, if you're wondering where you can find on 
leash, we're on social media, obviously, but the  
112:27 - most important part is the code that's on GitHub. 
We are after all, an open source organization. And  
112:33 - you can go to the unleash repository, and you can 
browse through all the code. And if you want to  
112:40 - contribute, there are opportunities for that as 
well. If you have any other questions, you can  
112:45 - tune into our open Slack channel, or we'll 
be happy to help you along if you want to get  
112:51 - started using feature toggles. Now, if you want 
to know where you can reach me, I'm on Twitter  
112:56 - under at F Allsburg. Or you can find me at 
my YouTube channel, which is called Frederick  
113:03 - Osbourne recording lessons here on YouTube. And 
with that, I hope you have a really great day