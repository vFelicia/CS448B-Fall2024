00:00 - Jack Harrington is an excellent teacher. And he's 
about to teach you how to develop web apps with  
00:04 - micro front ends. I'm Jack Harrington, I was a 
principal engineer at Nike and also at Walmart  
00:10 - Labs. And I'm here to talk to you about what micro 
front ends are and get you up to speed on that. So  
00:16 - why do you want to do that? Well, lots of fortune 
500 companies are very interested in a topic of  
00:22 - microfinance. And there's a good reason for that. 
So in this video, I'm going to walk you through my  
00:27 - girlfriend's all the way from tip to tail. But as 
anybody who has watched my channel before, which  
00:33 - is linked to in the description, they'll know that 
I like to entertain as much as I like to educate.  
00:39 - So I'm going to do a good action movie trope and 
jump you right into the heart of the action before  
00:45 - backtracking and laying the foundation. So let 
me get you excited about my girlfriend's first  
00:50 - and then I'll talk to you about what comes next. 
So don't worry in this first section, if you get  
00:54 - confused, it'll all be clear by the end. So let's 
jump right in to VS code. Right now. I'm over in  
01:02 - VS code, and I'm going to bring up the terminal 
actually, I'm gonna bring up two terminals.  
01:08 - And we're going to go build two apps. So in 
this first terminal, I'm gonna run P MPX.  
01:13 - And then create MF app. So P MPX is like 
MPX. If you have MPX, just use that.  
01:21 - And create MF app is for create model Federation 
app. So in this case, I'm going to pick the name  
01:26 - of my host, I'm going to call this one home 
because this is going to be the home page app,  
01:30 - my chooses an application on port 3000. I'm 
gonna use React and JavaScript and also tailwind.  
01:38 - Now this other terminal to do exactly the same 
thing, but to do PMP x again and create MF app.  
01:46 - And in this case, I'm going to call the 
application PDP or an E commerce world product  
01:51 - detail page, an application and this one's going 
to go on 3001 Because it can't have it on the same  
01:56 - port. Again, it's gonna be react JavaScript and 
tailwind. And again, I'm going to go into that  
02:02 - directory and do exactly the same thing. I'm gonna 
yarn. And if that's successful, then yarn start.  
02:10 - Okay, my homepage is running, let's go 
back over to my browser. And it shows  
02:14 - me that I now have an app, it's called home, 
the framework is react language, JavaScript,  
02:20 - and it's tailwind for the CSS. And there's exactly 
the same thing on Port 3001, except that it's PDP.  
02:26 - So let's say that we are the homepage team. 
These are managed by two different teams.  
02:31 - And we are going to take on the task 
of building the header. So I'm going  
02:34 - to create a file here called header dot 
JSX. I'm going to import react from react.  
02:43 - And I'm going to export a 
default function called header.  
02:51 - And it's going to return some HTML on there. And 
it's going to have a div that's got some tailwind  
02:58 - on it, let's see has got some padding, it's got 
a background that's blue, some text that's white  
03:03 - and large, and it's in bold font. And I'm 
going to call this fidget spinner world.  
03:10 - Because our app is going to be selling fidget 
spinners. Alright, so let's go back over here  
03:14 - and create a new file called footer dot JSX. 
And do pretty much exactly the same thing.  
03:21 - And we're gonna put into here, only the 
best spinners, because that's our motto,  
03:25 - we only sell the best spinners. And we'll say that 
that's the footer. And now let's go into an app.  
03:31 - And let's bring these components in just as you 
would any normal React components. So header,  
03:35 - we're gonna bring in from that header file. And 
footer, we're gonna bring in from the footer file.  
03:43 - And I'm just going to drop these down 
here, header, and then footer. And in here,  
03:50 - I'm just going to say that we have the homepage 
content. So we'll start off with a class name,  
03:55 - or you get a little margin vertically. 
We'll say that this is the homepage content.  
04:04 - And wrap that div up mostly good luck. Yeah, 
okay, looks good. I'm gonna remove the little top  
04:12 - margin there. And wow, beautiful page. 
Okay, so now the PDP team is like, Okay,  
04:19 - we're going to start implementing, but we really 
don't want to actually redo the header, we want to  
04:24 - use your header. So can we do that quickly? Well, 
absolutely, we can, because we can turn our header  
04:31 - on this homepage and the footer into micro front 
ends, and we can share them with the PDP page  
04:38 - really simply. So let's give that a try. So I'm 
going to go into a file here Webpack config.  
04:43 - So this is the web pack configuration. I'm gonna 
scroll down here to the module Federation plugin.  
04:49 - And I'm going to say that this 
application, which is named home  
04:53 - exposes the header in the footer, so 
we're going to give it the name header,  
04:57 - and this is a object where you give it the key 
which is the expose name, and then the location  
05:05 - of the module or the file in this case that you 
want to expose. So then so we're doing the header,  
05:11 - and then we're doing the footer, that's a 
good idea to keep the names obviously the  
05:14 - same between those two. Don't confuse anybody. 
Great. So the only thing we need to do now  
05:20 - is just restart home. So now I'm on the home 
terminal, and I'm going to restart that. So  
05:26 - I'm gonna say yarn start again, because we need 
to reload that Webpack configuration. But once  
05:32 - we run it, we can see that it works just fine. 
But there is something new that's been added.  
05:37 - And that is a remote entry file. So in localhost 
3000, there's also a remote entry dot j s. And  
05:43 - that is a manifest of all of the modules that are 
exposed by the homepage application. So I'm going  
05:49 - to copy that link. And then I'm going to go over 
to our PDP application into the web pack config,  
05:57 - and scroll down here. And I'm going to say that 
we have a remote and that remote is home. And its  
06:04 - URL is well home at and then I 
give it that remote entry URL.  
06:09 - Now, why home? Well, that's the same home as 
defined in this web pack config as the name  
06:14 - right here. And the only requirements on this 
is it has to be a valid JavaScript variable  
06:19 - name. So you can't use things like dashes can't 
be homepage, it could be home underscore page,  
06:24 - that's fine, because it's a valid JavaScript 
variable. So we're going to use home.  
06:29 - And now this is going to allow us to access 
any of the exposed components from home.  
06:37 - But of course, we have to restart the 
server again. So let's go over here to PvP.  
06:40 - And then we'll restart the server just to 
get that web pack configuration loaded.  
06:46 - And now if I go over here to our 
homepage and Grab app like that,  
06:51 - and copy out this because I'm kind of lazy 
and I don't want to retype all that stuff.  
06:56 - I'm going to go over here to our PDP and go to 
the app, which looks almost identical because  
07:01 - it came out of this the same template and paste 
that in there. And let's say PDP page content,  
07:07 - and I'm gonna hit save and well that work, huh, 
let's try it out. Okay. Okay, so can't resolve  
07:12 - the header and the footer, obviously. Okay, so 
there's no local header and footer. But if I do  
07:17 - home here, and I save, and I go back in here, 
we can see in our serving the PDP page content,  
07:26 - and we have our header and our footer, the 
exact same header and footer that came out of  
07:31 - the homepage. Awesome. And even better, check 
this out. So you go to header here and I say,  
07:38 - fidget spinner world to 
the fidget spinner warning.  
07:43 - And I do refresh here. Awesome, I get that as 
I would expect, and I go to PDP and without any  
07:51 - restart, or refresh or code change or anything 
other than hitting refresh in the browser,  
07:56 - I get the updated content. So that's a runtime 
connection between these two applications. Okay,  
08:03 - so let's have a look at our completed application 
that you will have by the end of this video. And  
08:08 - of course, all of the code is available to you on 
GitHub. And let's talk about why micro fees are  
08:14 - so important and why companies are really invested 
in them. So first off, this is our application,  
08:19 - you can see that this is the completed homepage. 
This is on Port 3000, as we started before,  
08:25 - and it's got our all of our fidget spinners and 
it's got our header, it's now a cart link on it,  
08:30 - it's got a way to log in. There's a product 
detail page that shows the detail around one of  
08:37 - our spinners. And there's a cart page that shows 
you all of the products that are in your cart. So  
08:42 - the reason that big companies are interested in 
microphones is the same reason that big companies  
08:46 - are interested in micro services when it comes 
to the back end. So on the back end used to have  
08:51 - monolithic API servers. And that meant that a 
bunch of teams were working on a single code base  
08:56 - that had a single deploy cycle. And the micro 
service revolution allowed that to change.  
09:02 - So now, every team could manage his own server 
and update independently, micro front ends,  
09:10 - bring that same methodology to the front end, 
meaning that every one of these applications  
09:15 - homepage PDP and cart are managed by separate 
teams. And now they can go and deploy  
09:22 - independently. And then if they Venn down any 
micro front ends that are consumed by other teams,  
09:29 - those are automatically updated when they deploy. 
So for example, in this case, the cart team  
09:36 - manages this little cart drop down over here. 
And whenever the cart application deploys,  
09:42 - that cart gets updated, updated along with 
it. And all of the other applications, we use  
09:48 - that cart and so it's done dynamically. So not 
only can the teams manage their own applications,  
09:55 - but they can actually manage smaller pieces of 
the UI. So Now the question becomes, when do you  
10:02 - decide what is a microfi? And what is not? Well, 
let's jump back over here to the atomic design  
10:07 - methodology. So the atomic design methodology, 
pioneered by Brad Frost basically defines how  
10:13 - you eyes are structured. So you start with atoms, 
which in this case would be things like a button,  
10:19 - or a label, or something very small like an 
image. And then there's molecules, which are  
10:27 - slightly larger components that use a bunch 
of those atoms, for example, a label input,  
10:34 - which may use a label as a text, and then an input 
as well. And it manages the relationship between  
10:39 - those usually just stateless Li, and then there's 
organisms. And in this case, an organism would be  
10:46 - something like this cart drop down over here. So 
it's a self contained piece of UI that manages its  
10:53 - own state and understands how to bring together 
all of the molecules and atoms to get something  
10:58 - done. So in this case, that would be these text 
fields are here, that clear cart and the checkout.  
11:03 - And it's this unit of UI, the organism that 
I think is most appropriate for sharing as  
11:08 - a microphone. And I don't think that you should 
run time share atoms and molecules, that's just  
11:13 - my personal opinion. But that's where I kind 
of draw the line. Now, there's also templates  
11:20 - and pages. Those don't really categorize for me 
as microfiche, but they are things that you can  
11:25 - share. In fact, when we talk about my girlfriend's 
more in this video, and as we go along,  
11:31 - we'll be talking about the underlying technology 
here, which is module Federation. And module  
11:35 - Federation actually allows you to share a lot more 
than just micro friends. In fact, we'll actually  
11:40 - start off by sharing some functions, and then 
we'll get into components and then we'll get into  
11:44 - sharing full page contents, and routings. It's 
really exciting stuff. Okay, I've introduced you  
11:50 - to the world of micro front ends and why they're 
important to companies. Let's now talk about  
11:54 - module Federation, and what it is and why it's 
different from other techniques of sharing code.  
12:00 - So model Federation is a feature that's built into 
Webpack. Five, it's absolutely free. And it is  
12:06 - part of the standard Webpack five deployment now. 
So anything that's built on top of Webpack, five,  
12:12 - can use module Federation, and he saw from that 
PNP X, I've actually got it set up so that you can  
12:18 - use Wow, 10 different view templates right now. 
And there's also Angular and other frameworks,  
12:24 - they can also use model Federation. So model 
Federation can be applied to pretty much every  
12:30 - popular view framework, it's great stuff. So 
let's talk a little bit about why it's different  
12:35 - from other methodologies of sharing. And to 
do that, I'm going to close out these and I'm  
12:40 - gonna get us into the kind of architectural 
box layer, we're gonna do that together.  
12:46 - So we're gonna do file here, and it's gonna be 
called architecture. Do, I have a Visual Studio  
12:53 - extension draw.io extension, allows me to kind of 
draw diagrams and go all full architecture mode,  
13:00 - right inside my VS code. Let me just drop in 
here what we started with, right, so we got  
13:04 - the homepage app that currently is at one Dotto 
and we got the PDP app over here. And inside the  
13:09 - home app, we had the header and the footer. Now, 
let me go and build out the NPM version of this,  
13:15 - I'm going to create a new page, I'm going to call 
this NPM. And I'll paste these two in. And then I  
13:21 - bring in a box for the NPM library, right. So this 
is going to be our NPM library, and it's kind of  
13:28 - kind of sits somewhere between these two. And then 
we're going to take the header and the footer,  
13:35 - and we're going to put it into our NPM library. 
And we're going to arrange it to bring it to the  
13:40 - front. So it all makes sense. Looking good. Okay, 
great. So now we have extracted our header and our  
13:46 - footer into our NPM library. Now we got to reuse 
those. So I'm going to go and draw a link between  
13:51 - the homepage app and the NPM library. And I'm 
gonna do the same thing with the PDP app. Alright,  
13:58 - so drop that in there. Those are looking good. I 
want to move this around a little bit to get these  
14:04 - arrows nicely lining up. Okay, cool. So 
let's say now that we are a developer  
14:08 - on the homepage app. And as part of the homepage 
team, our job is also to maintain the header and  
14:14 - the footer in this shared NPM library. And so I 
get a JIRA ticket saying, hey, we need to go and  
14:20 - change this text or whatever. Now I've got to go 
and jump from where I'm normally working, which  
14:26 - is the homepage app working on features in that 
app. And I got to jump over to this NPM library,  
14:31 - which may have not been worked on in a long time 
because the header doesn't update all that often.  
14:36 - And I've got to go and do that change. 
And then I'm going to bump that version  
14:41 - to 1.0 point one and publish that out to our 
local archive repository. And on the homepage,  
14:49 - I'm then going to bump that to 1.0 point one which 
is going to then grab the NPM library and release  
14:58 - to production kind of a hassle, same sort of thing 
over here. And that then have to go and talk to  
15:04 - the PDP team and say, Hey, there's a new version, 
the header, please use it, and then they would go  
15:08 - and bump it. And there you go. But now from the 
customer perspective, right, I'm on the homepage,  
15:15 - and I click into a product, I'm actually now going 
to get an older version of the header on the PDP  
15:21 - page app, which may actually not be great at all, 
in a black friday situation at a major e commerce  
15:30 - company, they're going to be making changes all 
over the place all the time. And so when they make  
15:36 - a change the header, they're going to want to see 
that happen immediately between these two pages.  
15:41 - So how are we going to solve that requirement? 
Well, let's go back over here and see what we  
15:46 - can do and talk about some solutions that I've 
seen in the industry. And one of the most popular  
15:51 - is to use something along the lines of an asset 
store. So we'll call this the Asset Store option.  
15:57 - And again, we'll start off with our 
one point lm 1.0, as we had before,  
16:01 - kind of bring these down a little bit and 
widen out the space because I need some space.  
16:07 - And so now we're going to bring 
in this header footer project.  
16:11 - And the idea of the header, the footer 
project, is to contain that header and  
16:16 - that footer. And we'll bring those to the front 
so we can see them. Again, oh my gosh, got to  
16:21 - make some more space here. All right over here, 
boy drawing diagrams, the bane of architecture.  
16:29 - And what this one's gonna do this header footer 
project is it's going to build some s3 artifacts,  
16:33 - it's probably going to build a static version 
of the HTML, and it's going to build the J S,  
16:39 - and then those are basically going to be injected 
onto the page. So we've now even removed react  
16:45 - from the equation here, right? This is just 
maybe react that is rendered as static HTML,  
16:52 - and then some helper JavaScript and 
actually add some dynamic behavior.  
16:56 - And that is then put up on s3. So we'll draw an 
arrow between those two things, this, this thing  
17:02 - is going to create that s3 artifact. In order 
to consume that to make it easy on ourselves,  
17:07 - we're going to go make a shim library and drop 
that in here. And its job is to go and fetch  
17:15 - that content from s3. And its job is to return to 
the homepage app and the PDP page app, some HTML  
17:23 - or some references that are grabs from s3, the 
homepage and PDP app, then inject into their page  
17:30 - templates to drop the header onto the page. So 
these guys need a connection to that shim library.  
17:39 - And then the advantage with this one is that this 
header and footer can update those s3 artifacts  
17:43 - at any time that shim library is designed to make 
sure that you always are getting the most recent  
17:49 - copy. And that gives you your dynamic behavior. So 
this header footer project, what when those late  
17:55 - requests come in from product to update the header 
immediately, the Header Footer project and then  
18:01 - deploy to s3. And all of those changes will show 
up on the homepage and PDP page automatically,  
18:07 - as long as they're not caching those results. You 
can see there's a lot going on here. And there's a  
18:11 - lot of custom work. There's a lot of custom CICD. 
These are very custom pieces of work, very DIY,  
18:18 - that are company specific. And of course, 
having any developers move from the homepage  
18:23 - and start making changes on the Header Footer 
project because it's so alien and maybe  
18:28 - entirely written in a different view framework. 
That's a big change. So there's a lot of context  
18:33 - switching, see, and having a team is dedicated 
to that probably a Header Footer project. It's  
18:37 - really just a large company object. Okay. 
So what does module Federation bring the  
18:43 - party. So module Federation, let's go 
for the module Federation approach here.  
18:51 - And we'll start again with our homepage and PDP 
page app. And in this case, we have the Home app,  
18:57 - and we have got the header in the footer, and 
all the PDP beige app needs to do is just connect  
19:02 - directly to the header and the footer, just 
like that. And so you get the dynamic behavior,  
19:10 - whenever the homepage application pushes. So it 
goes up to 1.01, the PDP page automatically gets  
19:19 - the new code, you're not changing development 
environments, those Header and Footer components  
19:25 - are still written in React. And as long 
as the PDP page is also written in React,  
19:30 - then they work right away. So there's no issue 
there with changing frameworks or different  
19:37 - packaging or whatever. And also, the work is 
done in context, meaning that as a homepage,  
19:42 - app developer, I just work on the header directly. 
And I just work on the footer directly. And  
19:47 - there is some risk there and we'll talk about that 
in just a minute. But it's much lower in terms of  
19:54 - context shift cost when it comes to development. 
So you can see why have these three method ologies  
20:00 - module Federation is the most attractive when 
it comes to sharing component code. Alright,  
20:07 - let's put away our architecture 
tools for a bit. And let's talk about  
20:10 - some of the questions that I get most often when 
it comes to Module Federation. And the first one  
20:15 - is around asynchronous stuff. So how do I 
actually include the header, for example,  
20:19 - asynchronously? So let's do that. Let me just show 
as opposed to tell. I'm gonna bring in suspense  
20:26 - from react. And here, I'm gonna say const. 
header equals and then do react lazy.  
20:36 - And I'm going to give it a function that's 
going to import the header. It's gonna do a  
20:42 - dynamic import. This is absolutely standards 
and asynchronous, dynamic important. It's  
20:47 - works in React, but it also works on any other 
technology you have any type of library you have  
20:53 - the special Saucier, isn't this react lazy. And 
then we're going to wrap the header in a suspense.  
21:07 - And we're going to get a fallback 
saying that, while we're waiting,  
21:12 - we should put in a div, which says, for example, 
loading, that's a classic fallback div. And so  
21:17 - now let's restart our servers. So we're gonna go 
back over here to our home, and then start that  
21:26 - and then go to the PDP page and start that,  
21:29 - as we go through this, by the way, keep a keen 
eye on this tab over here, it's really nice that  
21:34 - that actually has the names of the directory 
in there, we're gonna actually have five  
21:40 - running applications by the end of this. So we're 
gonna be doing a lot of jumping around here.  
21:45 - Alright, so here is our PDP page. And as we can 
see, fidgets better world is running just fine.  
21:50 - So that is a synchronously loaded, but if 
we kind of want to prove it to ourselves,  
21:55 - let's go and make that stateful. So 
I'm going to go and return this here.  
22:01 - And then do use state. And we're going to 
say, okay, so we have some mistakes in here  
22:08 - for showing the header. And we'll use state 
for that. And we will only show the header  
22:17 - if we are true. And then I'm gonna go 
make a button that says, show the header.  
22:28 - I'm gonna make it large. And give it 
some padding, just so we can see it.  
22:35 - Okay, cool. Alright, so the first thing we 
need to do is start that off as false. Right,  
22:39 - we don't want to show the header by default. And 
then if we get a click here, we're gonna turn that  
22:43 - to true. So unclick, Set Show header to just true, 
really, I can toggle that. There we go. Alright,  
22:52 - so we haven't shown the header so far. So let's 
go over here to our inspector and take a look  
22:56 - at our network and see what we got going on. So 
I'm gonna refresh this. And we're gonna see that  
23:03 - if I scroll down here, we have loaded the footer. 
But we have not yet loaded the header. And when I  
23:08 - click on show the header over here, we get the 
header. And actually, let's go take a look at  
23:13 - the size on that it came in at 1.1 kilobytes. So 
that's another really important point to Module  
23:20 - Federation. So if I look back over here, at the 
Webpack, config, we can see that there's another  
23:26 - key down here that I haven't talked at all about, 
which is the shared key. And this is all of the  
23:32 - libraries that are shared out of this homepage. 
So what I'm doing here is it's grabbing all the  
23:37 - dependencies by just looking at the package 
json, and then getting the dependencies.  
23:41 - So it's gonna share them all out. And then it's 
also going to share as part of that react and  
23:47 - react DOM. But it's going to override those to say 
that they're shared in singleton mode, which means  
23:52 - that there can only be one react on the page at 
a time. And that's actually really important for  
23:58 - react because react does have some data that's 
managed at the library level. And it is singleton  
24:04 - in nature. And so if you have multiple instances 
of react on the same page, it kind of freaks  
24:08 - out a little bit and breaks. So you don't want 
that. So Webpack shares and manages that sharing  
24:15 - for you, which is really awesome. And that's 
why that header only comes in at 1.1 kilobytes.  
24:24 - All it's doing is just bringing in just the 
component code for the header. Now if there  
24:30 - were any other dependencies that header needed, 
like moment or whatever, you would bring those  
24:36 - in as well but only in the case where you 
imported header, so that's really handy.  
24:41 - Okay, so now I'm not going to do this this 
way. So I'm going to go and unroll all this  
24:50 - and we'll just go back to plain old header  
25:01 - And we'll talk about the next question that I 
get when it comes to Module Federation, which is,  
25:05 - what happens when the app goes down? And 
the reason that I get this question a lot  
25:10 - is because this is the way that I demonstrate 
model Federation, I run it in apps. But that's  
25:15 - not the way that you deploy model Federation. So 
let's go into that. Let's actually take down home.  
25:21 - And we'll go over here to PDP and we'll see Yeah, 
it blows up. Absolutely. 100%. No question. Yeah,  
25:28 - blows up. Let's see. script loading error, 
couldn't load Header Footer on upset. Absolutely.  
25:33 - So true. If my demo app goes down, right, that's 
not going. So true. If my demo app goes down, then  
25:43 - the sharing system goes down. That's true. 
But that is not actually the way that you're  
25:46 - going to Deploy Module Federation. And that's why 
this is not really an issue. But there is another  
25:53 - related issue that we'll get into in a second. 
So the way that you deploy model Federation  
25:57 - is you build and deploy it to a static asset 
store like s3, because you want to get that  
26:04 - aka my our CDN, the style caching and all that 
kind of goodness. So let's first build it.  
26:12 - And let's create a local directory called Dist. So 
let's go in there and take a look at what that is.  
26:18 - And it's got a bunch of J. S 
files. So there's really nothing  
26:21 - unique to this, you don't 
actually have a server in here,  
26:24 - some of these MPX, and a module called server to 
run this application on Port 3000, which imitates  
26:32 - a static asset store, right? server 
doesn't know anything other than just  
26:35 - serve these static files. So it's just like s3 in 
that case. So now we got 3000, back and running.  
26:43 - And I'm going to do refresh and you're good to 
go. So as long as s3 in your static asset store  
26:49 - don't go down, then you're not going to have an 
issue when it comes to the code not being there.  
26:56 - So that's not the risk that you should be worried 
about. The risk that you should be worried about  
27:00 - is that a developer on the homepage team may 
change the API contract of header and make it  
27:07 - work in home, but not actually tell the PDP 
page team that the API contract is changing,  
27:14 - that is the risk that you've got to worry about. 
So let's try that out. And see how this actually  
27:20 - can blow up. So first, I need to get out 
of my sharing of the compiled dist there,  
27:26 - and then go back and do yarn start. And 
then our sharing the live code again.  
27:37 - So now we'll go into header. And I'm going to 
do app in here, because the feature request was  
27:43 - to put the app name into the header. So this is 
gonna say, app dot name. And my save, and I'm  
27:48 - gonna refer refresh the homepage and boom, 
what's the issue? Well, the issue is that  
27:56 - we cannot read name because the app is 
undefined, right? There's no property,  
28:01 - we didn't put a property called App on there. So 
as the developer on this Jira, I'm going to go and  
28:06 - then say, Okay, well, I need to fix that. Right. 
So I'm gonna say app. Name is. Done, okay? JIRA,  
28:18 - close, PR reviewed, done. redeployed. Wave is 
excellent. Next year, please. Right. So okay,  
28:26 - but over on the PDP team, we're just swimming 
along doing our stuff and we refresh the page and  
28:32 - blowing up, right. So why is that? Well, we didn't 
make the corresponding change on our side. So  
28:41 - yes, of course, I can make the change on the PDP 
page side and do all that choreography. But how  
28:46 - do we actually protect ourselves from that, so 
that this might potentially never happen? Well,  
28:51 - the trick there is to use error boundaries, 
or some equivalent in whatever view framework  
28:56 - you're doing. But in React World, we're gonna use 
an error boundary, I'm gonna create a new file  
29:01 - called Safe component. And we're gonna bring in 
React. And unfortunately, an error boundary has  
29:09 - to be a class. So we are going to extend save 
component from a React component, that error  
29:17 - boundaries are actually the one case I know of 
where you absolutely have to use a class in React.  
29:23 - Now we're gonna have a constructor, and it's 
going to set the state so that there's a state  
29:28 - value on this. And it's basically going 
to tell us whether an error has occurred.  
29:33 - And then we're going to add the two methods 
that are specific to a an error boundary.  
29:38 - The first is component did catch which gets 
thrown when the component cashed, and then  
29:43 - given the error, we return that our new state 
is has error. True, right? We can do a lot more  
29:48 - here. We can specify what the type of error is. We 
can console log it, we can send it to, you know,  
29:54 - Splunk or whatever. You can do all that stuff. I'm 
not gonna do that right here. I'm just gonna go  
29:59 - and render out something safe. So let's go make 
that render method. And basically say, Well, if  
30:05 - we've had an error, then we're gonna do something 
when otherwise, we're gonna, it's gonna return  
30:11 - the children. Okay, so now let's go back over 
to our PDP page and import our safe component  
30:18 - from that save component file, and then we're 
going to wrap our header in that save component.  
30:26 - And go over to here and we refresh. And yes, 
something went wrong. Great. So now our page still  
30:33 - runs. But it doesn't render the header. Now there 
is a fallback methodology that I've talked about  
30:40 - in a video on my channel, where you can use both 
module Federation and NPM. So that in the case,  
30:46 - when something blows up, you actually fall back 
on an older version, that you got an NPM. That's  
30:52 - a great strategy to hear really depends on how 
far you want to go with this protection. So  
30:57 - let's go back over into our homepage and actually 
fix the bug and see that it works. So we're going  
31:02 - to remove the app here. And then go and remove 
the necessity for the app over and header  
31:12 - takedown or two, and you go, everything looks 
great. Alright, so I've introduced you to the  
31:19 - world of micro front ends, we've gone and 
built two different applications. Already,  
31:22 - we've talked about why micro front ends are 
important, what module Federation is how to handle  
31:28 - asynchronous loading, and how to handle error 
states. Let's now actually start building out our  
31:33 - application and learn more about model Federation 
as we do. So now to do that, we need to actually  
31:39 - go and build our API server that's going to have 
our products and it's going to have our cart. Now,  
31:44 - yes, I'm going to go and create a monolithic 
single server for this, I didn't want to have  
31:48 - six tabs running. But yes, in the real world, you 
probably have multiple servers with multiple data,  
31:55 - you know, you'd have a product server, and you'd 
have a cart server and user server and all of that  
32:02 - stuff. But in this case, we're just going to have 
one server. Alright, so let's go back over into  
32:08 - our terminal and create yet another terminal. 
Yep, we're gonna have five by the end of this.  
32:19 - And again, I'm going to do pm px. Now, why pm 
dx, by the way, it's a Windows thing. Turns out,  
32:25 - I'm on Mac. But it turns out that P MPX 
is the way to go on Windows. Who knew.  
32:32 - And if you're on Windows, you know, like, 
no MPX works just fine, let me know.  
32:35 - But I'm doing this for my, my friends and 
Windows world. So let's do create MF app.  
32:43 - And in this case, I'm going to make it server. 
And instead of application, we're going to go  
32:48 - down here to API server, I'm going to put it 
on Port 8080, you know, as I guess, as usual,  
32:53 - when it comes to API servers, and what we're going 
to use as a template is nest J S with off. So this  
33:00 - one is going to use nest J S as our API server, 
it's going to be a REST server. And we're going  
33:06 - to use j DVT, or jaunt based authorization. And 
that's the template for that one. So now I'm going  
33:13 - to go into server. And I'm going to yarn it get 
that all going. So let's take a look at what's  
33:19 - in the server, we've got a public directory that 
has all the assets that we want to put in there.  
33:25 - And you're gonna be able to find those on 
GitHub, but I'm just going to add them locally.  
33:28 - So this is going to have a fidget one dot jpg, 
nice, cool. Wagon Wheel looking fidget spinner,  
33:35 - friend of mines all in a fidget spinner. 
So I figured this would be a fun,  
33:38 - fun demo data piece. And we'll delete 
that. And then if we go, yarn start here.  
33:47 - We can bring up localhost 8080. And then go to 
fidget one dot jpg, and awesome. So now we know  
33:55 - that we are getting this set of static assets. 
That's good. So now the next thing we need to  
34:01 - do is ensure that we can get the list of products. 
So over here, we've got our auth stuff, we're not  
34:06 - going to touch that that is the JDT Mandrin. We're 
not going to touch users. But I will show you that  
34:11 - there's two users that are kind of baked into 
this. There is Sally, there's a password of 123.  
34:17 - Maria, who has a password of 123. You 
can add as many users as you like,  
34:21 - obviously, this is just demo stuff. You can hook 
this up to a real back end if you ever want to.  
34:27 - So in modules, we've got two modules. We've 
got authorized and unauthorized. So let's take  
34:34 - a look at our unauthorized controller. And what 
it's telling us is that we've got a controller  
34:39 - that's camping on unauthorized and if I get it 
I'm going to return true just a single return  
34:45 - true value. So I'm going to do localhost 8080 
And then do unauthorized and it's going to turn  
34:55 - true, fabulous. Okay, so what we want to do is 
to Change this code so that instead of being  
35:02 - unauthorized, it's products. So first we're 
gonna change anything, it says unauthorized  
35:07 - to products. And I'm gonna make that 
lowercase. And this is gonna break up  
35:12 - all kinds of stuff. So I'm gonna go over here 
to unauthorized, change all that products.  
35:24 - I'm gonna change this directory name to products, 
and change these file names to products.  
35:39 - And finally, I'm going to go into app 
module and change this to products.  
35:47 - Do the lower casing. Alright, let's 
take a look. I'm gonna do yarn start  
35:55 - Dev, I think. Yeah. So this is gonna 
continuously watch the server for updates.  
36:00 - I didn't start in that the first time. 
All right, let's do this. localhost 8080.  
36:08 - Products. Okay, cool. returning true. That's 
great. Awesome. Okay, so now I've got my routing  
36:15 - set up properly, I've got the products, 
unauthorized route, because we want to be able  
36:20 - to get products without actually being logged in. 
In this system, we are going to have to be logged  
36:25 - in to add items to our cart, we're not gonna allow 
for anonymous carts, you can do that if you want.  
36:31 - But beyond the scope of this. So the next 
thing we need to do is hit our product list.  
36:37 - So that root level over here under source, I'm 
going to create a new file called products.ts. I'm  
36:43 - going to paste in our product definitions. Again, 
all of this is available to you on GitHub. But  
36:48 - let's talk about a little bit about what a product 
is. So it's got an ID, it's got a name, a price,  
36:52 - a description and image, which is the URL to the 
localhost, and then the long description. By the  
36:59 - way, I had some fun with GPT, three to build 
out these long descriptions. So if there's some  
37:03 - insane stuff in there, you can blame GPT three 
for that. Alright, so let's go back over here to  
37:09 - our products module, and controller, and then over 
in here, we're going to import those products.  
37:17 - As well as the definition of a product. 
And it's not going to be from product data,  
37:22 - it's going to be from products. Cool. And 
this is going to return an array of products,  
37:30 - which is going to be from products. So let's 
save that out. And refresh and awesome. So fast.  
37:37 - I love it. Next, Jas is actually really 
cool. If you get into server work,  
37:42 - I strongly recommend checking out nest Yes, of 
course, Graph QL. Alright, so let's go back over  
37:47 - here to Visual Studio code and then add another 
method. So this is going to be able to get by a  
37:53 - particular ID. So in SGS world, you give it this 
decorator for the route that you want. So in this  
37:59 - case, it's cold ID basically gonna map that 
Id onto the parameter, it's gonna be a string,  
38:05 - we're then going to go in through 
the list of products and find  
38:10 - that product ID. And we're going to 
parse out that string to a number. Okay.  
38:17 - So let's go back over here and do instead of 
products, we're going to do products, one,  
38:21 - and that just pairs down to the one product and 
see product ID is 10. There you go golden silver  
38:26 - gears at $9.99. Awesome. Excellent. So that's 
pretty much all we need to do for the server at  
38:32 - this point. Let's jump back over into the client 
and get that going. Alright, so let's close down  
38:37 - that window, close on server, go over to home. 
And then here, we're gonna create a new file  
38:42 - called products, dot j s, and we're gonna specify 
our API server is going to be localhost 8000.  
38:48 - And then we're just going to use Fetch to go and 
get the list of products. So it's going to fetch  
38:54 - off of add slash products. And then it's just a 
return a promise, which has the JSON out of it.  
39:02 - So that's going to give us back our 
list of products. But while we're here,  
39:05 - let's go and add another one for getting a 
particular product by ID. So get product by ID,  
39:09 - and that's going to be used by the PP page. So 
when they want to get data on their product,  
39:15 - they just have a particular product in mind, 
right? They've got slash products slash one,  
39:19 - they're gonna go and give us the ID and then we're 
going to get back the data that's specific to them  
39:23 - by calling that by ID endpoint that we created. 
And then because I'm a big fan of reusing code,  
39:29 - I'm also gonna bring in a currency converter, 
which is uses intell. And we're going to use  
39:33 - the US US Dollars currency so that when we format 
the prices nicely, you know, make it look right.  
39:40 - Alright, so let's go over to our app page. And 
we're gonna do this a little bit differently. So  
39:44 - I'm going to create a homepage content component, 
and I'm gonna bring it in to this homepage content  
39:49 - area, and there's good reason for that. It's 
always good to not have mega components anyway.  
39:54 - So I'm going to do a new file here and say home 
content, dot JSX. And I'm going to bring in the  
40:02 - usual react and use state and use effect. And then 
I'm also going to bring in products. By the way,  
40:09 - if you're wondering how I'm getting that 
awesome hinting that's actually GitHub co pilot,  
40:13 - and then I'm going to start our home 
content component, it's going to have  
40:18 - our product list and use date. And then to 
go get that I'm going to use a use effect.  
40:25 - Use effect takes a function, which is 
the effect that you want to effect,  
40:29 - and then takes a dependency array. So in 
this case, the dependency rate is empty,  
40:33 - because we want to have this run only once. 
And then I'm going to get products. And once  
40:39 - I get that value back, because then it's 
a promise, I'm going to set that products.  
40:44 - Alright, so let's start off on our JSX. So 
I'm going to put some JSX in there that's got  
40:51 - it's got some white padding on it. And it's like 
grid layout, so it's going to have four across.  
40:56 - So that's my grid calls for with a little gap in 
between each one. I love tailwind, so expressive.  
41:02 - And then with each of the products, I'm going 
to run a map and put the key on there for the  
41:09 - product ID. And then let's try it out. 
So we're gonna go in over into our app,  
41:14 - and we're going to bring in our home content  
41:18 - from that home content file. And then I'm 
gonna put it in there for the homepage content.  
41:27 - And I don't need that extra wide padding. They've 
already got that. So let's have a look. Let's hit  
41:33 - refresh. Hey, cool. Let's making the connection 
to our API server. And putting up our beautiful  
41:41 - fidget spinners. I really should be getting into 
these like, more than I look at them. I spent  
41:46 - multiple days with this example. And I'm like, Oh, 
wow, maybe reward myself with a fidget spinner.  
41:52 - Alright, let's continue on. So let's go back over 
nor home content. And I'm going to paste in here  
42:01 - that we want to Flexbox and that 
Flexbox is going to have a name on it.  
42:05 - Let's take a look. Nice, 
adding in our name looks good.  
42:10 - And let's go add the price in there and make 
that the next element in our flex box. And it's  
42:14 - going to use our currency formatter to 
format our product price into US dollars.  
42:19 - So let's take a look. Pretty nice. Okay, cool. 
And I think the last thing we need to do is  
42:26 - just add a description, so the customer knows 
what they're buying. Let's drop that in there.  
42:33 - Yeah, looks pretty good. Text is 
a little large, but that's okay.  
42:37 - Alright, so our teams are in the mode of sharing. 
And our PDP page wants to reuse our Git product  
42:43 - by ID function to get the product by ID. And 
that's one of the great things about module  
42:50 - Federation is that not only can you use it to 
share components, but you can use it to share  
42:55 - any type of JavaScript could be constants, it 
could be encoded JSON, it could be functions,  
43:03 - it can be components, it can be whatever 
kind of JavaScript you want. So in this case,  
43:07 - we're also going to share out our 
products library, I guess file module  
43:15 - from our Home app. So let's go back over here to 
Webpack config, and scroll down again to exposes,  
43:21 - and all we need to do is just add in products, 
and then say that its products dot j s.  
43:32 - Alright, let's say that out, and again, I have 
to reboot home because the Webpack configuration  
43:37 - has changed. And now over on the PDP side, 
we can start doing the same thing. So I'm  
43:44 - going to go and close out these files. And 
I'm gonna go over here into the PDP content.  
43:51 - And I'm going to create a new file, and 
we're going to call this PDP content  
43:56 - dot JSX. And into that, I'm going to also bring 
you state and use effect because they're gonna  
44:01 - do pretty much exactly the same thing. We're 
going to hard code right now that our product is  
44:06 - one. And let's go over here to our 
app and bring in that PDP content  
44:13 - from that PDP content file, and let's go 
and pop that down in there for its content.  
44:19 - Let's take a look. There we go product one, as 
you'd expect. Okay, so let's start bringing in the  
44:26 - code to get that product. We'll go back over here 
to our PDB content. We'll bring in our get product  
44:33 - by ID and also our currency for matter from home 
but instead of header or footer, in this case,  
44:37 - we're just going to use products like we did 
before. So let's save and if this doesn't work,  
44:42 - it's going to blow up right now. So let's know 
it looks like it's going to be good. Okay, great.  
44:48 - Alright, so let's change this to ID and then I'm 
gonna drop in here some state so we're gonna say  
44:53 - that this is going to be the the product 
we actually gotten and put in here ID at  
44:59 - the moment So we're just gonna say if we don't 
have a product, then we're going to return no.  
45:08 - And so right now it's going to turn 
nothing. And so we're empty in there.  
45:12 - And so now we need to bring in a use effect. 
So we're going to bring in a use effect,  
45:16 - we're gonna say, okay, so if we have an ID, 
which is specified as ones, we're gonna have one,  
45:21 - then we're going to go and get that product by 
that ID. And with that product, we're going to  
45:24 - set that product. So in fact, let's simplify this 
code even a bit more, we'll just say set product.  
45:29 - Alright, take a look. That looks like you're 
good. Okay, so I think we probably got the  
45:33 - data. In fact, I probably just do at this 
point product name. Yeah, we'll spend are  
45:38 - good to go. So let's start laying out our nifty 
UI in here, we'll just replace all of this.  
45:44 - And we'll have a two column layout, 
this time with a little gap in between.  
45:50 - And then we'll have our product image in the 
left hand side. So let's hit Save. And there  
45:55 - you go. Looking pretty good, so far, cool. So 
let's get to get in on that right hand side,  
46:01 - and we're going to bring in a div, this got a 
flex box, and it's going to have our product  
46:09 - name that's expandable unless the flex grow 
and it's gonna be nice and big. And then at  
46:16 - the end of whatever that is, we're gonna have 
the currency formatted for the currency price.  
46:20 - That looks good 599 Are you out of your 
mind. And let's bring in the description.  
46:30 - Pretty good. And then let's bring in the long 
description generated by GPT three. All right,  
46:35 - here we go. I just you know, I'm not a good 
copywriter like that. Our wheel spinner is fun,  
46:41 - functional, actually looks really good. It's 
amazing how much DBT three was able to deduce  
46:47 - just from like a wheel. fidget spinner that spins 
was a baby, I gave it that. And it gave me this,  
46:52 - which is crazy. Okay, so next thing we want 
to do is allow for us to do like product  
46:58 - one like that. Now, the Webpack configs are 
actually set up to go take a look at them.  
47:06 - With History API fallback to true which basically 
means that any route that isn't served from some  
47:13 - sort of static asset is going to just render 
the same application in the dev server remote.  
47:18 - So that's why you can basically give this any 
URL you want, you know, any URL, and it's just  
47:24 - going to go and give you the same page over and 
over and over again. So that's why we can use  
47:28 - something like React Router DOM to actually select 
out different products. So what we want is, we  
47:34 - want to be able to save, you know, 10, for example 
here and get 10 as opposed to our hard coded one,  
47:40 - which is we have now. So let's go and stop our 
PDP server. And now we're going to go add React  
47:50 - Router DOM. And I'm going to do a yarn start 
again. And then over in our app, I'm going to  
47:58 - go and bring in our React Router DOM stuff, let's 
get rid of suspense there, we no longer need that.  
48:05 - We're no longer suspenseful. And we're 
gonna wrap this whole thing in router.  
48:15 - And I'm not gonna do the Save component 
stuff, that's fine, it's safe as is  
48:20 - not planning on blowing anything up. And now 
inside here, you're gonna put the switch.  
48:26 - So this is where we're going to change out 
the content. And in React Router DOM world,  
48:30 - use a switch for that. And then inside of that 
you've got a route. And we're going to say that  
48:37 - the path is going to be something along the lines 
of slash product, and then an ID and then the  
48:44 - component that is going to be rendered if we have 
that is the PDP content component. So let's hit  
48:52 - save there, and see if this works. Let's go I'm 
gonna close out that you don't need that anymore.  
48:57 - And yeah, it works fine. But if we go to like, 
for example, just slash right, that doesn't match  
49:03 - this path pattern here. So you're not going 
to get anything. So let's go back to product  
49:07 - 10. And that works fine, because that matches 
slash products slash ID. So how do we go and  
49:12 - get that ID, let's go back over here to our PDP 
content. And I'm going to go bring in US params  
49:20 - from React Router, Dom. Alright. And that's 
actually pretty easy. So I'm just going to put  
49:28 - in their ID and then use use params. That because 
use pram you can have multiple parameters. So this  
49:34 - is gonna return you an object which we want to 
D structure and get out the ID. So there you go.  
49:39 - Save that out. Oh, that is pretty. That may 
be the one I get. So I've got our homepage.  
49:46 - We've got our product detail page we're showing 
the customer has a bunch of these fidgets spinners  
49:50 - but now we want to be able to sell the customers 
and fidget spinners. We've got an E commerce  
49:54 - app after all, so we want to do some commerce. So 
that means that they need to have a way to log in  
49:59 - and have a way to add and remove and view 
their cart. So why am I doing all this on  
50:06 - E commerce stuff. And using this example? Well, 
this is going to allow us to explore how to share  
50:11 - state between the host and the remote. So let's 
talk a little bit about the nomenclature there.  
50:17 - So when it comes to our header, for example, 
the homepage is the remote. And then the PDP  
50:25 - page is the host. So the PDP page is hosting the 
header that is remote to it. And it's remoted in  
50:33 - essentially, from the homepage, so I want 
to talk about host and remote. That's that  
50:38 - relationship. And in this case, we want to talk 
about exploring how to share state between the  
50:45 - host page and the remote that's coming in. So 
we're gonna have a way to log in to our server to  
50:54 - get a job back the JBT or JSON web token, not sure 
why it's pronounced jot as opposed to whatever.  
51:02 - But that's going to be our authentication. And 
we're going to want to share that between the host  
51:07 - page, which is going to want to know if it should 
add like for example, the add to cart buttons,  
51:11 - and the cart MFP, which is going to show you your 
cart. So The MFE is going to want to know that you  
51:17 - have a jaunt. And the homepage is going to want to 
know that you want to have a job. And you're also  
51:22 - going to be able to share the cart items between 
the different parts of the system. So we're going  
51:27 - to explore using this shared state. Okay, so let's 
jump in and start working on building out our  
51:33 - cart. And that means going back to our server, 
and working on that. So over on our server, we  
51:40 - have modules, and we got this authorized module. 
And if we go down and we look at the the readme,  
51:46 - we can see some documentation on how to use 
the authorization part of this. So for example,  
51:55 - I'm going to create yet another terminal. And 
I'm going to follow this example here, this  
51:59 - example is to do curl, and hit up this localhost 
8080 authorized route, which means that I need  
52:07 - to have some authentication details to hit that 
route. I don't yet. So that's going to give me  
52:13 - 401 message on authorized. So what I can do is I 
can post to login with the username and password,  
52:22 - and I'm going to get back a jot. So I'm gonna copy 
and paste this again, this is just in the readme  
52:28 - and paste that in there. And that gives us back 
an access token. And that is our job. How's that  
52:35 - work? Well, this J S has a whole section in its 
documentation on how to do authorization. And he  
52:41 - pretty much just follow that. And it'll give you 
this auth login. And then you can specify some  
52:47 - users, of course, you can go get them anywhere, 
but again, I've gone put in there, Maria,  
52:52 - and 123. And that's what we're passing in here 
and marine 123. And that gives you back this job.  
52:57 - Alright, so then let's go back into our readme 
again, and see what I can do with that job. Well,  
53:02 - I can scroll down. And I'm going to copy this 
line, which is starts off with the same thing  
53:08 - we did before with authorized but now we're going 
to give an additional header. And the header is  
53:12 - going to say authorization, and it's going to give 
a bearer. And then I'm going to just paste that.  
53:20 - And I'm going to copy the job that we got 
back all the way up to but not including the  
53:27 - quote and paste that in there and paste in 
putting the quote there. And we're going to  
53:32 - get back that we're our user ID is two. And so 
why are we getting that back? Well, let's go  
53:36 - take a look at our authorized route here. So we'll 
go into the controller. And we'll see that when we  
53:43 - get we use a guard. And that's basically saying, 
okay, guard this method by applying that John J T,  
53:52 - and that particular off guard. And that's going to 
give us a request when we get run and we pass that  
53:58 - jaunt. And from that job, we're going to get 
the user and the user ID. So that's pretty easy,  
54:03 - right? Okay, so the first thing we need to do is 
kind of we did with products, but now we need to  
54:08 - do with authorized so we're gonna need to change 
all that stuff that says authorized to cart cart,  
54:13 - here cart, their cart here and everywhere. 
And we'll change the name to cart  
54:20 - directory and we'll change the file names 
to cart. And we'll change this to cart.  
54:28 - Okay, looks pretty good.  
54:32 - Couple more carts in here. Seems to be Okay, at 
this level. Let's go back up to our app module.  
54:37 - That's the last place that actually see I'm 
going to change authorized to cart and then  
54:46 - lowercase that cart and hit Save. And let's see 
I can actually test this out my going up here  
54:54 - and doing exactly the same thing as before, 
except instead of authorized I'm going to do  
54:59 - cart If I've made all the changes correctly, 
yes, that's good. Okay, so now we're working  
55:06 - on the cart route. That's great. So we changed 
the route successfully. And now we just need  
55:11 - to kind of upgrade this cart controller with 
our cart functionality, because obviously,  
55:16 - returning a user ID is is not what we want, right, 
we have the John functionality, we can now log in,  
55:22 - we need to actually maintain a cart. So I'm going 
to start by bringing in the list of products,  
55:28 - as well as the interface for a cart. So a cart is 
going to have multiple cart items, it's gonna have  
55:34 - array of CART items. And those cart items are 
going to extend the product, they're going to  
55:38 - be an exact replica of the product data. But with 
an additional quantity, how many of the fidgets  
55:45 - spinners Do you want. And so the cart is basically 
going to have everything that you need to know,  
55:49 - to render out the contents of the cart, it's gonna 
have all the product information plus the quantity  
55:56 - that you want. And then I'm going to bring in a 
little helper function here called initial cart.  
56:01 - And this is going to take a 
list of indices. So this is the  
56:05 - references into the products that we want to kind 
of preload the carts for our particular users. So  
56:12 - we're going to give Maria some stuff in her cart 
already in Sally some stuff in her cart already,  
56:16 - just so this a little bit easier to test. 
And we're going to store that down here in  
56:21 - our cart controller as a private member 
variable, it's gonna be called carts.  
56:25 - And Sally has ID number one, and she's going to 
have an initial cart that has items 02, and four,  
56:31 - and and, and Marie is going to have items one 
and three. Okay, so the first thing we need to  
56:35 - do is return what's in a cart. So we're going to 
use this Get method, and we're just gonna return  
56:42 - whatever's in the cart of that particular user 
ID. So again, Sally's number one, so that's going  
56:46 - to map to there. And reason number two is going to 
have to there, we're not going to return a number,  
56:51 - we're going to return a cart, or in turn a 
promise to return a cart. So let's try this again.  
56:58 - And there you go. Cool. Okay, so now I've tried 
it again, with the job that we got back before,  
57:04 - which has a long expiration, it's got a 24 
hour expiration on it, so it's not going to  
57:08 - go anywhere, and it's returning to us the contents 
of that person's cart. That's a pretty good start,  
57:15 - we're doing great. So now the next thing we 
need to do is have a method where you can post  
57:19 - to the endpoint and add an item to the 
cart, and then also a delete and delete  
57:24 - an item from the cart results go back in here. 
And so we're going to create a post method.  
57:34 - And we need to bring in post from our next js. 
And that's great, you're learning full stack at  
57:39 - the same time that you're learning about all this 
microfi stuff. So there's so many good things to  
57:43 - learn here about Jonathan occation, and all the 
rest of it. Okay, so we have a now post method,  
57:50 - same idea. So you just post to that same endpoint, 
again, it's going to be off guarded with the Jot,  
57:56 - I'm going to get that request that's coming 
in before but this time, we're gonna say that  
57:58 - our body contains an ID, and that's the ID 
of the product that we're wanting to add.  
58:04 - And then it's going to return the new cart, the 
updated cart. So first, we need to get your cart.  
58:11 - And we use the same thing we did here with this 
carts and give it the user ID. And then we need  
58:16 - to see if you already have an item in your cart, 
because we're just going to update the quantity.  
58:21 - If you have that item. Otherwise, we're 
gonna add a new item to your cart.  
58:25 - So we have a cart item, we're just 
going to add update the quantity.  
58:29 - Otherwise, we are going to add on to 
your cart items by pushing the product  
58:36 - and then a quantity one. Right, cool. And 
then we're just gonna return that cart.  
58:42 - Easy peasy lemon squeezy. And the 
next thing we need to allow is the  
58:46 - removal of the cart. And for this, I have 
personally decided to use the delete method  
58:51 - on that, you know, is that the right thing 
to do? I don't know. I mean, that's really  
58:57 - up to you. But I'm going to just use delete for 
that. And again, it's going to be off guarded.  
59:02 - Because we need one to know these already. And 
of course, we want everybody's car to remain  
59:07 - their own and secure. And all we're going to do is 
just basically if you get a delete on an endpoint,  
59:12 - we're going to look to get the user ID, and we're 
going to set the card to an empty card and return  
59:17 - it just like that. Okay, we're pretty good. So 
I think our cart functionality is going great.  
59:23 - So now the next thing we need to do is actually 
have a cart app, the third app here to connect  
59:28 - this to. So I'm gonna go back over into our 
terminal. And I'm just going to reuse this  
59:34 - terminal even playing around with to do another 
one of these PNP axes, would that create MF app.  
59:41 - And I'm going to call this one 
cart. And it's also going to be  
59:45 - a React app. So I'm gonna call this one cart. It's 
going to be an application that sits on port 3002.  
59:52 - And it's my react JavaScript and tailwind. 
And we can talk a little bit about why I'm not  
59:58 - using create react app or next year. As for this 
obvious, I'm using React. So why am I not using  
60:03 - one of those? Well create react app, and next have 
very complex setups, everything's in there with  
60:11 - a really complex Webpack configuration, and es 
lint and testing, and prettier and all the rest  
60:19 - of it. And that's great. It's a great starting 
point. But it's a lot of extra clutter and bloat,  
60:24 - that distracts from what I want to do with create 
MFM, which is give you a way to make proof of  
60:30 - concept and test applications. So you can test out 
how model Federation and my graphes are going to  
60:37 - work in your environment without actually going 
and making all the adjustments to those things  
60:41 - yourself. So each one of the apps that it creates 
is the smallest possible thing that I can think  
60:46 - of, it's basically just Webpack, and X Webpack, 
and react Webpack and view Webpack, and lid,  
60:52 - Webpack. And all of the different, there's 10 
different templates that you can use. So, you  
60:57 - know, it's very, very simple and lightweight, and 
it's all there for you to try and play with. Okay,  
61:04 - so it looks like we've installed properly. So 
the next thing I'm going to add to our client,  
61:09 - is I'm gonna add RX js, what is RJs? And why 
am I adding it. So RSDs is a set of reactive  
61:19 - objects and functions, it's a very elaborate 
system for creating observable streams. So  
61:29 - in our case, we're just gonna use it really 
simply, we're going to create a behavior subject,  
61:33 - which is a type of observable, that's going 
to hold our jot, our JDBC, or JSON web token,  
61:39 - and another one that's going to hold our cart. And 
the nice thing about it is you can always get the  
61:44 - current value, and you can subscribe to it so that 
when it changes, you get to see it. And the other  
61:50 - nice thing about RX js is it's not bound to any 
view framework. So we are going to use a different  
61:56 - view framework here pretty soon coming up. And 
if I'd chosen something that was bound to react,  
62:02 - then that would be a problem. Whereas 
in this case, anything that can run a  
62:07 - subscribe method on an object is going to be 
able to listen to the job and be able to listen  
62:12 - to the cart. And that means it could be anything 
could be vanilla JS could be solid, it could be  
62:18 - Inferno, it could be all kinds 
of different things. So okay,  
62:21 - so looks like we're good. We've added our 
RX js. So now I'm going to start up our app.  
62:28 - Okay, great. So just like we had before, very 
simple vanilla startup with the tailwind stuff,  
62:33 - and makes it easy to put some nice styling 
on it. Okay, so we're gonna go over here  
62:39 - to our cart into a source and migrate a new 
file, and it's gonna be called cart.js. And  
62:44 - this is going to manage in much the same way that 
products manage our connection to the products  
62:49 - portion of the server, this is going to manage our 
connection to the cart and authentication side of  
62:55 - the server. So we're going to bring in RX J. S, 
we're going to give ourselves that constant API  
63:00 - servers can point to the API server, and 
we're going to create that behavior subject  
63:04 - for the data t. So that's going to have, if I do 
j dt dot value, it's going to tell me what the  
63:08 - current value of that jot is, which in this case, 
you can be null. And if I do subscribe, on this,  
63:18 - and I put in their token or something like that, 
and I say, you know, console dot log token,  
63:24 - it's going to get called every time that a new 
value goes into John. And the way that a new value  
63:30 - goes in there is you say Do do T dot next, and you 
give it the new value, like that. So it's a pretty  
63:36 - simple API service here, you do next, to give it 
to publish a value to give it a new value, you do  
63:43 - subscribe to listen to changes, and then you can 
do value at any time to get the current value. So  
63:48 - very, very simple way of sharing state now, on my 
channel, in my module Federation playlist, there's  
63:55 - coverage of Redux and a whole bunch of different 
state managers when it comes to doing this with  
64:00 - model Federation. But I want to keep it really 
simple. And this one, so it's RX js. So what's  
64:05 - the first thing we need to do? Well, we need to 
go and login. So let's go and bring in our login.  
64:10 - And our login is going to take a username 
and a password, it's going to do a fetch  
64:14 - a little bit more elaborate this time, because 
it's gonna post as opposed to get it's got some  
64:19 - headers, and it's going to need to send along the 
username and the password. And then it's going  
64:25 - to get back the response, we're gonna assume that 
it's okay, I'm not gonna do any, any error routes  
64:30 - on this, but of course, you wouldn't need to. And 
then that JDT that next is what I'm going to call  
64:35 - when I get back the access token from the payload 
because we saw when the curls ourselves that the  
64:42 - access token is the key that we get back from the 
server that has that jot in it. Okay, so let's  
64:47 - start building out our UI. We're going to actually 
go and login at this point. So let's go and close  
64:53 - this out. And I'm going to go over to our web 
pack config. And of course, we need the header  
64:56 - and the footer. And for this one, I'm just 
going to add all of these apps together.  
65:00 - So I'm going to have a route for home, I'm going 
to have a route for PDP, and I'm going to have a  
65:04 - route for myself. So I can be self referential 
on cart. So if I internally use cart slash,  
65:10 - it's just going to loop back onto myself. 
And module Federation happily supports that.  
65:16 - So the next thing we need to do is 
create a new file called cart content,  
65:20 - dot JSX. And into that, I'm going to create 
a cart content, it's gonna be a similar thing  
65:26 - to what we had before. So it's going to have 
some state that's gonna have that token on it.  
65:31 - And we're going to do that login. But before you 
get there, let's go make sure that that actually  
65:36 - works. So I'm gonna bring in the header and the 
footer from home, I'm gonna bring in our content.  
65:41 - And then I'm just going to place our body content 
with pretty much the same thing as we've had in  
65:45 - all the other apps, which is the wrapper, and 
then the header and the footer, and then our cart  
65:52 - content. Alright, so let's take a look at what it 
looks like. And it looks like we're blown up. And  
65:56 - that's because we can't resolve home header. So 
what's the solution? Give me there, a solution is  
66:01 - going to be that we need to restart our web 
pack, right, so we didn't repack, we didn't  
66:05 - restart web pack. And that's why I can't resolve 
that. So let's go and do yarn, start again.  
66:15 - And I'll refresh. And we're good. 
And jadibooti is currently empty,  
66:20 - because we haven't actually tried to login yet. 
So let's go and login and see we get. So let's  
66:25 - go and bring in the login and the JDI T from cart. 
And then down here in the US effect I'm going to  
66:32 - try to log in. But I'm also going to subscribe to 
that job. And that, again, that's going to take  
66:39 - that value. And it's going to set that token 
to that value or if the value is undefined to  
66:44 - nothing. And the cool thing here about subscribe 
in RCS is that it returns an unsubscribe. How cool  
66:53 - is that? And it just so happens, the use effect 
is expecting that we return a cleanup function,  
66:59 - and it just happily maps to the unsubscribe that 
we get back from the job like that. Cool. Okay,  
67:05 - so let's try it out and see what we get. Hey, 
there you go. Okay, so we're successfully  
67:11 - doing the login. Let's go and actually test that 
and see if it works over in our network panel.  
67:19 - And we can look at our fetch, and we can see that 
we have a login. And we are sending the Sally 123  
67:26 - payload. And we are getting back the response of 
the access token looks pretty good. And of course,  
67:31 - we're seeing it over in the code over there. So 
thumbs up, good to go. So now we're going to do  
67:38 - is we're going to build out the UI that's going 
to go into the header over here, it's not gonna  
67:42 - go there yet, we're gonna go and build those 
kind of locally within cart. And we're gonna  
67:46 - share those out with the header, the homepage team 
that's manages that header, and then they're going  
67:50 - to consume those and put those in the header. 
And it's all going to turn into one nice,  
67:55 - complete system. So to make it nice, I'm going to 
go and add some icons. So we need going to add in  
68:03 - remix icons, that's what I'm going to use for 
these applications. And I'm actually adding  
68:08 - to all of them. So I'm going to stop this guy, 
and I'm gonna yarn add remix icon to that one.  
68:16 - I'm gonna grab that. And then I'm going to go 
over to homepage, and I'm gonna do the same thing  
68:20 - there, I'm going to go to a PDP, I'm going to do 
the same thing there. And the reason I'm doing  
68:26 - it on this side is that CSS is not something you 
can share across module Federation, it has to be  
68:34 - either CSS and JS or J S. So that's not the 
case in either of these cases, I don't think.  
68:40 - So. This is, so I need to add that dependency to  
68:45 - all of these applications. So next 
thing to do is restart everything.  
69:00 - Alright, look, I'm pretty good. We 
got a homepage, you got a cart page.  
69:03 - That's good enough for now. And the 
next thing we need to do is make sure  
69:08 - that you have the icons in every place, 
I'm going to go to the app dot JSX file  
69:11 - in all of our applications and add the CSS for 
the remix icons. So back over here in again.  
69:25 - And again, okay, cool. Now we have nice 
icons we can use in any application.  
69:30 - So let's start building out our login UI. And 
one thing we're gonna do is we're going to  
69:34 - share a custom hook around us logged in so we can 
build that now. So we got our cart file in cart,  
69:42 - dot j s, and I'm going to bring in React. And 
then down here, I'm going to define that we have a  
69:51 - user logged in, and it's going 
to return that login state.  
69:56 - And then it's going to set up a 
subscription using us effect to that job.  
70:03 - So first is going to set the value of login 
to whatever the current value is of that job.  
70:08 - And this little nice double exclamation point, 
basically coerces it into a Boolean. And then  
70:14 - I'll do the exact same thing I did with a 
subscribe over here. And there you go. Okay,  
70:19 - so let's go back over to our cart content. And 
I'm actually going to remove this auto login,  
70:24 - because we don't want it to automatically 
login, because the first thing we're gonna build  
70:28 - is our login screen. So when I remove that, 
and then I'm going to go over here and create  
70:33 - a new file, we're gonna call this login 
dot JSX. And we're going to bring in you  
70:38 - state and that login and the US login from our 
cart. And then we're gonna create our login.  
70:51 - And we're gonna start off by getting the 
login state, and already managed some state  
70:55 - around whether we want to show or hide this 
little pop up there, we're going to create  
71:00 - the need some state manager username and 
login. So we create some state for that. So  
71:04 - got username and set username, password, and set 
password as you generally do in these situations,  
71:10 - I'm going to say if we're not logged 
in, then we're going to return no,  
71:14 - don't show anything. But if we are logged in, 
we are going to show a fragment. So we're going  
71:20 - to start off with a little fingerprint icon, 
that's where you click on it to go and fire up  
71:25 - your login. And that's going to be a span that has 
within it a icon to assume reasoning I the italic  
71:34 - tag to make become an icon as we always do. And 
I'm going to add a ID here, because we're gonna  
71:39 - do some test automation, at the end of this show 
you how to test this really cool stuff. And then  
71:45 - if we click on that, we're going to get on the set 
that show login, so we can hide and show something  
71:50 - we're gonna have like a drop down. And so the 
drop down is going to switch based on show login.  
72:01 - And it's, this is gonna be basically 
kind of relative positioned. So you know,  
72:07 - eventually we'll move it into the right spot. But 
this is for testing, we don't want off the side of  
72:11 - the screen some comment this out currently. And 
then we need an input for our username. So I'm  
72:17 - gonna pop that in there, that input is going to 
have a type of text and a placeholder username,  
72:22 - it's gonna have a value of username, and then 
when it changes, it's gonna set the username is  
72:27 - absolutely regular react type stuff, 
and it's gonna have some nice looking  
72:34 - tailwind on it to make it look pretty. We do 
the same thing for password, then this case,  
72:38 - we're gonna give it a type a password, the 
value, password and also set password. And again,  
72:42 - make it nice and pretty tailwind style. And 
then finally, we're going to have a button,  
72:46 - that's going to be our login button, and also an 
ID on that so that we can automate it later. And  
72:51 - that's just going to call login with the username 
password, the same login that we have here from  
72:55 - cart. So let's take a look and give this a try. 
So the next thing we need to do is important login  
73:01 - into our cart content. And 
let's try that out log in from  
73:05 - login. And let's put it in there. So 
I'm going to put a div around the John  
73:14 - for them and drop that login in 
there since I got in the pace buffer.  
73:18 - Cool. Let's take a look. Oh, okay. Okay. All 
right. So I need to say if I'm logged in,  
73:24 - then return null. Here we go. Okay, cool. So 
looking good. Because I don't know that is there,  
73:29 - because I should remove that use effect from 
before. So let's go and figure that out. So  
73:34 - I'm going to go and rebuild that use effect 
that we have before to go and set the token.  
73:39 - But I'm not going to auto login. So now let's 
login. And yeah, cool. So we know we're good.  
73:46 - We got the govt and that's great. 
Okay, so next thing we need to do  
73:50 - is build out that little mini cart. So when 
I'm not showing the login, that means I am  
73:55 - logged in. And I want to show a little cart icon 
that shows me the number of items in the cart,  
74:01 - and brings up a little pop up that gives you some 
details about what's in the cart and allows you to  
74:05 - check out and clear the cart and all that kind of 
good stuff. But to build that we need to add more  
74:10 - stuff to our cart, we need to manage the cart much 
the same way actually do the job. So I'm going  
74:15 - to go and create a new behavior subject for the 
cart. And then we're going to add some functions  
74:20 - to get the cart and add an item to a cart 
and clear the cart. So let's start off with  
74:27 - getting that cart. So we have a function 
here, get cart, and it does a fetch just  
74:34 - super straight get from the cart, just the way 
we did before. And again, application JSON,  
74:40 - but this time we're adding in that bearer, so 
that'd be the bearer token with a dot value. And  
74:45 - that's going to first offset the value of the card 
by using cart dot next. So it's again a behavior  
74:50 - subject like we had with Jaat and then it's going 
to turn the contents of the cart as well. So if  
74:56 - you want to get it that way, that's fine too. 
Kind of nice, nice dual purpose. function there.  
75:01 - Of course, now we want to go and enable this 
get cart down here. So once we've logged in,  
75:05 - we want to automatically go and get your cart and 
make sure that that's up to date. But of course,  
75:10 - we want to make some money. So let's figure 
out how to add an item to a cart. And  
75:14 - that just takes an ID. And in this case, xoma is 
exactly the same thing, we're going to do a post  
75:20 - in this case, because that was the route that 
we created on the server side was a post. And  
75:25 - then into that we give it the ID, but it also 
takes the same bearer token as we had before.  
75:31 - That gives it its shot. And that gives your your 
identity. So then we take the return value, which  
75:36 - is just a response, we get the JSON out of it, and 
we're successful. So we want to go back and get  
75:42 - a new cart, you know, we could take the value 
that we got returned, now it'd be the card, but  
75:46 - it's fine, we can just make two requests. And 
then finally, we need to do exactly the same thing  
75:52 - one more time for clear cart. So again, same 
idea, but in this case, we're going to use a  
75:57 - delete method, as opposed to the POST method. And 
again, we're just going to go and get the cart.  
76:03 - So now we got a basic set of functions that 
allow us to manage a cart, let's go put a UI  
76:07 - on it by creating something called the mini cart.  
76:15 - So we'll bring in our usual react use effect, 
and you state all that good hook stuff. And we're  
76:21 - going to bring in our cart stuff. So in this case, 
that cart is going to be our subscribable value,  
76:26 - as well as the clear cart function they're going 
to need to use when they click on that, clear the  
76:30 - cart button or really check out to yeah, whatever. 
And then we're going to get currency, which is  
76:34 - going to format currency, but we're going to get 
that from home. So we're going to use that module  
76:39 - Federation stuff to pull in currency dynamically 
from home. Okay, so let's start building out  
76:45 - our minicard. So, we'll start off by having our 
list of items. And we'll get that from our cart.  
76:52 - And we'll have a flag for showing and hiding 
that cart because it's going to have that little  
76:57 - icon there and you click on the icon, see, 
then the carton, click on the icon again,  
77:02 - goodbye, cart. And so we need to subscribe to 
that cart. So I'm going to use use effect in  
77:07 - here. Of course, you could go and wrap that in 
a custom hook if you wanted to. But this one is  
77:13 - just gonna do the same thing as we have before. So 
it's going to go and get the cart items, and then  
77:17 - subscribe. This little nice optional chaining here 
allows us to say, Well, if the cart value is no,  
77:22 - then don't dereference that to cart items. So 
it protects us from the value of CART being No,  
77:28 - in the beginning, really nice. Of course, 
we don't have any cards that we want to say  
77:33 - nothing. So let's start returning out our JSX. And 
again, we're gonna do a fragment, because we're  
77:40 - gonna have that icon and then we're going to have 
the content. So we'll start off with our icon.  
77:46 - And we'll have that unclick, they're just 
going to show and hide that cart state,  
77:50 - it's going to have an ID on it. Because again, 
we're going to do the automation stuff, it's going  
77:53 - to have a shopping cart icon as opposed to the 
fingerprint. And it's going to have next to it the  
78:00 - length of items in the cart. So that's just gonna 
tell you how many items you've got in that cart.  
78:07 - You know, this actually sounds like a good spot 
to try it out. So I'm going to go over here to  
78:12 - cart content. So I'm going to go and import mini 
cart from the mini cart file, and then I'm going  
78:19 - to go and use that down here mini cart. And let's 
see how we do. Okay, cool. So we're not logged in,  
78:25 - it's not persisted like that. So I 
need to log in. And there we go. So  
78:29 - Sally has three items in the cart. Awesome. And if 
we try again, and we use Maria, in here, Maria has  
78:36 - two items in the cart, though. Thank you Chrome. 
I'm good. Okay, so it looks like our cart icon  
78:41 - is doing well. And we got the cart count going. So 
thumbs up to that. So let's continue on, and allow  
78:46 - us to show and hide the detail of what's actually 
in the cart. So I'll go and create a show card.  
78:56 - Again, here, we're gonna have a kind of pop 
up thing, this is gonna be in a fragment.  
79:04 - And we're gonna have a four column 
layout. Because we want the quantity,  
79:08 - the image, the name and the price, that's gonna be 
the four columns. And then we're going to iterate  
79:14 - through all those. So use a map for that. So for 
the items, I'm going to take each item, create  
79:20 - yet another fragment. And the reason for that 
is because of grid layout, you want these to be  
79:24 - at the same level, all with each other. So that's 
why the rack rack fragment in there, but we need  
79:29 - the ID. So that's why it's react fragment and 
not the React fragment placeholder. And then the  
79:34 - quantity, the image, the name and the currency. 
That's unformatted. So let's go take a look.  
79:40 - Alright, again, we'll log in Sally 
cool. And there you go. Nice. Okay,  
79:45 - so Sally has a dragon wheel spinner wheel spinner. 
Gentlemen, spinner. Very cool. Alright, so of  
79:51 - course he wants to know what the grand total is, 
how much money am I spending? So we're gonna add  
79:58 - some more we're gonna go and add Three placeholder 
divs, and then essentially the grand total. And  
80:05 - to get the grand total, we're going to give it 
a reduced function, which is going to take the  
80:10 - current reduce value, which is gonna start 
at zero, and then add on every round the  
80:15 - quantity times the price. So let's try that 
out and see how we do for the grand total.  
80:21 - Yeah, looking good, okay, which apparently she 
owes us. 20 bucks for Three Spinners. Okay,  
80:26 - cool. So now we need a clear button and a checkout 
button. So to wrap those, create a flex box.  
80:37 - And then within that, our first side of the 
Flexbox is going to have our Grow div on it. And  
80:43 - in there, we're gonna have our clear cart. So and 
again, we're gonna have that on an ID. So we can  
80:48 - automate that. And this is gonna it's gonna 
have some nice tailwind formatting here,  
80:52 - I think we're just going to put a border on that 
one, let's go take a look. Yeah, that's kind of  
80:58 - nice. I like that. And we can actually clear the 
cart at that point. And now if I log in, again,  
81:03 - we can see Sally has nothing in the cart. That's 
cool. That means that our server is persisting  
81:09 - the state of the cart properly. Awesome. If we 
wanted to go and reset this car, we just need to  
81:14 - reboot that server because it's all in memory. 
Okay, so now we need to put at the end of this,  
81:20 - we need to put our checkout button which is 
basically gonna do the same thing. You know,  
81:24 - if you want to make a full ecommerce system out 
of this, then I guess you'd go to Shopify or  
81:29 - whatever. Okay. So it save there. And then let's 
try one more time. And it looks like we're good.  
81:36 - You know, obviously, don't have the cart there, 
because I cleared it the first time, but I think I  
81:40 - think we're okay. Alright, so now the next thing 
we want to do is integrate this back into the  
81:44 - header, so that we get a coherent experience for 
the customer. And we get that shared experience  
81:49 - on every single page. So really cool. So the next 
thing we need to do is go back over into our web  
81:56 - pack config. So let me close out a few of these 
files. And we'll zoom in on that web pack config.  
82:02 - That's part of the cart, right. And so now the 
cart needs to expose a couple things, it needs  
82:08 - to expose the cart functions that it had before 
so that I can subscribe to the Jaunt and the cart.  
82:14 - And these two, expose the UI components that are 
the login and the mini cart. So cool, or exposing  
82:21 - kind of both functions and microfi components 
here. So now we will reboot our cart server.  
82:34 - And I'm going to copy these because I need really 
all of the applications now to be pointing each  
82:38 - other. So go over to home and change the Webpack 
config there so that now home can look at itself.  
82:46 - It can look at PDP and it can look at cart. And 
PDP is also going to have the same things. I might  
82:52 - as well just replace it all in one, one fell 
swoop. And let's see, so I'm going to reboot  
82:58 - home. And I'm going to reboot PDP I made changes 
to both of those as well. Okay, cool. Yeah,  
83:09 - the only hassle about all this is really the fact 
that the browser just keeps popping up every time.  
83:14 - But otherwise, it's a really nice workflow. Okay, 
so let's go back up to home, because now we want  
83:21 - to bring in those microfiche from the cart, and 
embed that in the header. So let's bring in mini  
83:27 - cart and login from cart. And let's make sure 
that it works by going over here to home. And  
83:33 - as long as things don't blow up, you're generally 
speaking Okay. And now I'm going to wrap this one  
83:38 - in a Flexbox. So I'm gonna wrap the content here 
in a flex box. And the first item in that flex box  
83:44 - is going to be our our home title or title of our 
app. And then I'm going to have a flex end item  
83:54 - which is going to have our 
mini cart and our login in it.  
84:00 - I don't think it matters, the ordering. 
They're pretty sure it doesn't matter.  
84:03 - So let's try it out. Hey, okay, cool. And now 
we'll log in. And looks great. Oh, cool back.  
84:12 - And it's so awesome. I love it. Okay, great. So 
let's change the CSS a little bit so that we can  
84:19 - make it look pretty. So I'm going to go back over 
here to our cart and our login let's see mini  
84:25 - cart. And there was a little bit of justification 
that I got rid of there the left and the cart.  
84:32 - Login. Yeah, that looks good. Bring in the 
left. You know, I don't like like to make  
84:36 - things look nice. So here we go. So ups. I think 
it's no problem. Okay, so it's over there. Now.  
84:42 - Let's go and go back over to our 
header and make sure this is relative.  
84:50 - Oh, look at that. So nice. Okay, awesome. So now 
we need to be able to add items to the cart, right  
84:57 - of course. So we're going to use that add to cart 
function Over here in our homepage content to give  
85:03 - us some a way to add items to the cart. And that 
John function and that use login to let us know  
85:10 - if we want to show those add cart ones because we 
are logged in at this point, we should be able to  
85:15 - add items to the cart. So let's go over back into 
our content for home content. We're gonna bring  
85:24 - in some stuff from the cart, we're gonna bring 
in add to cart and also that use login hook.  
85:30 - And I'll use us login. And we're going to use 
that to toggle whether we're going to show  
85:35 - our Add to Cart buttons. Okay, so down here below 
description, we're going to check to see if we're  
85:42 - logged in. And if we are, then we are going to 
align on the right hand side, a little padding  
85:47 - on the top, a nice little button, we're going 
to add some automation ID to that so that we  
85:51 - can automate it later, where you can add to the 
cart. Alright, let's refresh the page. And we're  
85:56 - not logged in. So let's login. And oh my gosh, 
okay, cool. I'm gonna add the cards. Haha. Oh,  
86:04 - yes. All right, here we go. And look at that. 
And so now check it out. We are sharing state,  
86:11 - we're sharing the John state. So the host page 
in this case, which has that home content,  
86:16 - is looking at the job and seeing whether it's 
logged in or not, and showing these buttons. And  
86:21 - then when it needs add item to the cart then calls 
the add to cart function, which then fires off to  
86:29 - the server, and then updates again, that RSDs, 
which then updates that view. So in fact, check  
86:36 - this out, this is even cooler, I can go over here 
to Rainbow flames. And it automatically updates.  
86:41 - So the whole thing is reactive, because you have 
that RX JS subscribe mechanism. So whatever state  
86:47 - manager you choose, I strongly recommend that you 
make sure that it's reactive somehow. And that,  
86:52 - you know, all of them are really at some level, 
but things like mob X, and Val Shio, Jo time,  
86:58 - these are all very reactive mechanisms. Of 
course, redox reacts a bit more elaborate,  
87:03 - I would recommend using Redux toolkit if you're 
gonna do that. But they all work, which is really  
87:08 - important part, because context also works. I'm 
not going to do that here. But context does work  
87:14 - in these systems. Okay, so of course, our car page 
is ugly. So we want to make sure that we have a  
87:19 - complete cart page. So let's go back over into 
our cart and update our cart content. Alright,  
87:25 - so starting from the top here, I don't need any 
of that anymore, I'm going to bring in cart and  
87:30 - clear cart from the car, we're basically going to 
redo the mini cart, but just kind of writ large,  
87:35 - I mean, create some state around the items 
and have a use effect where we subscribe  
87:40 - to that value. And of course, I'm going to use 
that nice optional chaining on there to make  
87:44 - sure that we have card items. And if we don't, 
then we have an empty array, which allows us  
87:48 - to safely render an array map. All right, then 
down in here, I'm going to start with a fragment.  
87:55 - And into that, I'm going to use the top of the 
page to be a grid of all of the cart items,  
88:00 - and it's gonna be a four column grid layout. I'm 
not gonna adjust the sizes like I did before.  
88:05 - And then I'm gonna go over to my mini cart. 
And I'm just gonna grab pretty much all of  
88:10 - this centrally, exactly the same thing. And drop 
it in there. Cool. Let's take a look at our cart.  
88:19 - So we haven't logged in, let's go log in. And 
ooh, and check it out. It's the same data.  
88:24 - I added that rainbow flames before 
and there. How cool is that?  
88:28 - Okay, so looks like we need a little 
bit of getting all my sun aligned.  
88:35 - Yeah, okay, good. And then we need to add the 
buttons down here for clear cart and checkout.  
88:41 - So let's go back over here and make sure that if 
we have some items that we can show that UI, we're  
88:48 - gonna start off again, with a Flexbox to allow 
us to put one button on one side and one button  
88:52 - on the other side. And then you know, I'm just 
going to go and grab clear cart stuff, because  
88:56 - that's basically exactly the same code. So let's 
go over here. And let's see, is that the balance?  
89:02 - That's the balance. Yep. Okay, cool. And pop that 
in there. And let's take a look. Okay, refresh.  
89:11 - Cool. Awesome. All right, and I can clear current. 
Yep, I can. Hey, cool. All right. So let's go have  
89:18 - a look at product. I'm gonna go over here 
to localhost 3001. And then do product ID,  
89:24 - you know, to sure whatever, solid rainbow I like 
that one. It's it's solid, and rainbow. So what I  
89:30 - want to do is I want to show you how to do micro 
RFPs, across different view platforms. So the way  
89:36 - I'm going to do that is I'm going to create an 
Add to Cart button. It's going to go in here,  
89:40 - because one mule, the add to cart from the product 
detail page, but for some reason or another,  
89:44 - the folks on the Add to Cart button team who 
decided to use solid J S, which is a framework  
89:51 - I love by the way, so it's a cool choice to do the 
Add to Cart button and not react. So the question  
89:57 - is can we get these two view frameworks react and 
solid as to talk together. And I'm guessing the  
90:02 - fact that I'm talking to you right now is, the 
answer is yes. So let's try this out. And this  
90:08 - is going to give us our fifth application 
and our last tab. So let's go and create yet  
90:16 - the last terminal. And here, cart. And I'm going 
to do again, P MPX. Create MF app. And this time,  
90:31 - I'm going to call it add to cart. And I'm 
gonna pick application and we'll see 3003.  
90:38 - And we're gonna pick solid JS in this time. 
And JavaScript and tailwind, don't worry,  
90:44 - if you don't know, solid J S, it's 
fine. So we'll go into Add to Cart.  
90:50 - Very easy. If you're familiar with React, 
actually, solid J S is very close to react. And  
90:56 - I think there's a lot of cool reasons to look into 
it on its own. So something you might want to look  
91:01 - into on your own. Okay, so here we go. So we're 
gonna yarn, start that up. And there we go. So  
91:08 - it's kind of similar layout, as we had with the 
React stuff, except that the only difference here  
91:12 - is that the framework in this case is solid 
J S, and not react. And that's actually the  
91:16 - way every single create MF app runs exactly the 
same way and gives you the exact same output,  
91:21 - so that it's pretty easy to compare these 
different frameworks. So now, of course,  
91:26 - this Add to Cart needs to be able to get access 
to that shared jot and the add to cart function.  
91:32 - So we're going to go down here to the remotes, 
and we're going to give it the remote of cart.  
91:38 - And I'm going to restart that server. And into 
this directory, I'm going to create a new file  
91:45 - called Add to Cart dot JSX. And you define a 
component in solid much the same way you do in  
91:50 - React. So in this case, it's just a function, 
and it takes properties and returns some JSX.  
91:56 - Now, there are no classes in this case, that's 
not something that solid yet supports. So it  
92:00 - has to be a function. So in solid J S, there's 
a signal, which is the equivalent of a US state,  
92:08 - although it can be global, it can be 
anywhere, it's actually really cool.  
92:11 - And then there's a an effect, same kind of 
idea, but it's like use effect. And then you  
92:17 - have a declarative style when it comes to hiding 
and showing stuff. And a tag to hide that tag to  
92:24 - show is called shows, we're gonna bring in those 
from solid js. And then from module Federation,  
92:30 - and the cart, we're gonna bring in the 
John, and we're gonna bring in add to cart,  
92:35 - then we're going to create a signal for login. 
So looks really similar, right? I mean, this,  
92:40 - you could imagine that to be used eight, 
but it's called Create signal, in this case,  
92:44 - a really cool thing about solid is that it's 
gonna actually be out here, it's really just a  
92:49 - question of where you want to store your state. 
And it works the same way in both cases. So you  
92:54 - when it comes to state managers, solid jazz, most 
of that's actually built into the core of stage  
92:58 - of solid, so you don't need a custom state 
manager really cool. So let them do a create  
93:04 - effect. And that's going to do that same jaunt 
subscribe thing. And when the subscribe fires  
93:11 - telling us that we're logged in, then we set that 
signal. And then for the JSX, we are going to  
93:17 - return a show hide tag, essentially, that has 
within it a button. That button has the same  
93:24 - kind of tailwind stuff as we had on before. In 
this case, when you click it, it's going to do  
93:30 - add to cart. So there you go, that is our the 
complete sum total of our assala js component.  
93:37 - Okay, so let's go over here to app dot JSX. 
And let's see how this is actually done. So  
93:41 - the way that you render something in solid J 
S, as you bring in render from solid JS web,  
93:46 - and then you render the component. So in this 
case, that's that app that we had before.  
93:50 - So if we wanted to bring in our component that we 
could import that here, the only thing is we're  
93:55 - not bringing in a header, so we're not going to be 
authenticated. So it'll be difficult to test. So  
94:00 - I'm not going to do that. But what we need to do 
is basically get this somehow, so that it works in  
94:05 - a React context. So I'm going to do that I'm going 
to create a function and expose that. And that  
94:10 - function is going to take two arguments. The first 
is the element that you want to attach it to.  
94:15 - And then the second is the product ID, which 
is going to go into ID here. So I'm gonna copy  
94:21 - and paste this and I'm going to create a 
new file called place Add to Cart dot j s.  
94:29 - And we're not gonna bring in index dot 
css, we're not gonna bring in this,  
94:33 - but we are going to export a default 
function called please add to cart,  
94:40 - it's gonna take an element, it's gonna take 
an ID and it's going to render into element.  
94:50 - And what it's going to render 
is Add to cart with that ID.  
94:55 - Cool, right? Okay, so let's go 
and expose this. So we'll go  
94:58 - back over to our web pack config And you 
know what we'll just also expose Add to Cart.  
95:09 - And also, of course, place Add to Cart, 
which is what we're really going to use.  
95:18 - That's J S. Let's see is that JS Dojo dojo? Yep, 
it is cool. All right. So let's go here to add  
95:26 - to cart, and restart it because we need to 
update that exposes and get everything going.  
95:34 - And I'll see that it's got 
a remote entry on there.  
95:40 - And it does is going to tell us that we've 
exposed the add to cart, and also the place  
95:46 - Add to Cart. So let's go back over to our PDP 
app and import that. So go close out these files,  
95:55 - and go to PDP down to Webpack. Config. 
And we're gonna bring in add to cart.  
96:06 - And it's called Add to Cart. 
And it's on that remote entry  
96:11 - on 3003. Cool. So now let's go back over to our 
PDP content page. And we're going to bring that in  
96:19 - and bring in place Add to Cart from Add to Cart.  
96:30 - And let's go make sure that I get the name right, 
and the car went back big. There we go. Cool. And  
96:37 - we'll just refresh to make sure everything's fine. 
But of course, you can't find Add to Cart and why?  
96:42 - Because we haven't restarted the server. 
So let's go again to PDP and restart.  
96:53 - And we'll refresh. And looks good. So fingers 
crossed, things look good. All signs point to  
97:00 - things being good. So we're going to do is going 
to mount this on a ref. So we need an element.  
97:06 - So we need to create a ref by using use ref. And 
we're going to put that well put that down here.  
97:15 - ref is add to card. And let's make sure that 
that works. Yeah, seems to be going okay  
97:22 - doesn't have any problems with that. So let's 
add a use effect. Where if we have a current  
97:28 - on Add to Cart, meaning that that component is 
mounted, we have an unique element, then we're  
97:34 - going to do place add to cart with that current 
element and then give it the ID. So is it save?  
97:41 - Okay, looks like we have an error. So let's go in 
look at the console and see what that error is.  
97:46 - Go over here to console scroll up. And it looks 
like I messed up in my solid jazz code. I just  
97:50 - forgot to import Add to Cart, my solid jazz. 
So let's go save that. And go over here to  
97:57 - add to cart go into add place Add to Cart. Yep, 
absolutely. So let's go and import Add to Cart.  
98:04 - can't really use something until you've imported 
that Jack. So let's say save there and run and  
98:10 - we haven't logged in. So we're probably okay so 
far. Cool. Got it. Yeah. That is so cool. How  
98:20 - awesome is that. So now we've got a React app 
hosting a solid js component because that's the  
98:27 - what we decided to use for that particular one. 
And let's see, do we make a good choice. Let's  
98:33 - take a look and see over our network. Take 
a look at the size of the payloads here.  
98:40 - So wow, we're bringing a lot but see place 
add to cart was 2.7 kilobytes, that's a,  
98:47 - that's pretty nice. We're bringing in not a 
lot for bringing that add to cart. And that's  
98:52 - one of the really nice things about solid Jas 
is actually creates very, very small bundles.  
98:58 - Alright, so coming up next, we are going to take 
a look at how to do routing in micro front ends  
99:03 - and module Federation. But before we do that, 
if you are a Git kind of person Source Code  
99:08 - Control being all that I strongly recommend at 
this point to commit we currently have because  
99:15 - it's gonna get real here real fast. So we're gonna 
do some pretty cool stuff to address an issue that  
99:22 - I want to talk about right now. So we've got 
our three apps, we got one on 3001, we got one  
99:28 - on 3002 and one on 3001. So let's go put those 
kind of in the right order, I guess 3000 3001  
99:35 - 3002 Right. So let's say I want to go and test out 
how my homepage connects to my cart as an example,  
99:43 - right? So I'm logged in here, and I'm adding 
stuff to my cart. If I go over to 3002 right now,  
99:53 - and then I see that I'm not actually logged in 
anymore because I'm not actually storing the state  
99:58 - and I'm getting a whole new page Refresh 
is not actually a single page application.  
100:03 - So is there a way we can actually turn these apps 
into a single coherent single page application.  
100:10 - And this is a big deal, because what happens 
is, when you fracture one of these monolithic  
100:15 - applications into a set of smaller applications, 
yes, they become a lot easier to deploy.  
100:22 - But first, you run into the Header 
Footer problem that we had before. So  
100:26 - you have to be able to share components, 
ie my graphes, like the header and footer  
100:31 - between applications. But also, they become harder 
to test, right? If you want to do a coherent test,  
100:37 - where you start at the homepage, you add something 
to the cart, you may navigate to another page,  
100:42 - eventually, you'll end up on the cart page 
and go through checkout, right. In order to  
100:47 - get that done. You have to stage your whole system 
somewhere and then put in your code for say, cart,  
100:56 - as an example. But keep all of the code for 
the existing apps, and it just gets very hairy  
101:02 - and hard to manage. Whereas if you had all of 
them as essentially single page applications,  
101:07 - where any of these applications could vend 
all of the pages for the other experiences,  
101:13 - then, for example, if you're working on a cart, 
and you want to make a change to the cart, but  
101:17 - you want to run a smoke test that ran through the 
entire system, you could do that. Is it possible?  
101:24 - Yes, it is. So let's go check it out. And 
that's what I'm saying. We're going to make some  
101:27 - pretty significant changes here, although we 
have set ourselves up nicely for this. So in  
101:33 - each one of these applications, so cart, home and 
PDP, we have implemented the interior of the app  
101:43 - as content. So there's cart content, there's 
PDP content, and there's home content.  
101:48 - And it might have seemed a little bit weird in 
the moment. But I had a plan like the Cylons. So,  
101:55 - over here, in Webpack, config, we're going to go 
and expose cart content in the cart app. So I'm  
102:01 - going to put in here cart content. And then I'm 
going to get that from cart content, dot JSX.  
102:12 - Say that out, and we will go and 
restart cart. So we're exporting that.  
102:20 - And that seems to be okay. So that's good. So 
now I'm going to do the same thing over in,  
102:27 - let's see what is next home. 
Okay, so we've got home contents,  
102:30 - I'm gonna go to web pack config there, and 
home is going to export the home content.  
102:36 - So I'll just replace our cart with home just like 
that. And again, save and now go to home. And  
102:42 - I'll stop it and start it. Now that looks good, 
great. And then finally, let's go over to PDP and  
102:50 - go to its web pack config. And again, we're 
going to expose out of PDP, the PDP content.  
103:01 - And we'll go down to PDP and restart that one.  
103:04 - And that looks good. So here's an undo 
I'm going to go over to the app for PDP.  
103:13 - Since it has React Router baked into it already, 
and I am going to copy some of this code,  
103:19 - I'm gonna copy all of it actually. And I'm gonna 
take it over to home. And then we create a new  
103:24 - file in here called main layout, that JSX paste 
that in there. And we'll call this one main  
103:31 - layout. And we'll get rid of that react 
render Dom, you don't need that anymore.  
103:38 - But what I do need now in home is React 
Router DOM. And so we don't have that.  
103:42 - So let's go over to home here and stop that 
server and then yarn, add React Router DOM.  
103:51 - And then I'm going to start that server again.  
103:57 - And now we start getting to the point where 
we need content, right, so we have PDP content  
104:02 - from PDP. We've got home content from home. 
And we've got cart content from the cart.  
104:17 - And now let's go take this main 
layout, and then go over here to app.  
104:22 - I'm going to bring that in as the one 
thing that we're going to bring in.  
104:26 - And you know, I'm just gonna render it right 
here. We're not even going to have an app anymore.  
104:33 - Save that out and we're gonna see how 
we go. This is basically a test to see  
104:36 - that all the connections are okay. Looks like we 
haven't exported main layout. So let's go over and  
104:43 - to let's just go make this an exported function  
104:52 - and then return this router.  
104:58 - Okay, cool. And now at least we're getting a page. 
And that's good. But we don't have a home path. So  
105:07 - we're going to add a route for the home. So I've 
just be slash now we're going to put in exactly  
105:11 - in there. So it needs to be that exact path. And 
that's going to be the home content. So let's save  
105:17 - that out. And refresh, and eight. That's pretty 
cool. And if I do slash product, slash one,  
105:28 - how cool is that I'm actually getting the PDP 
out of the same app. This is 3000. This is the  
105:34 - Home app, but it's serving the content for 
PDP has really cool, okay, so one more than,  
105:40 - let's go and bring in cart. So I'm gonna do 
slash cart. And we're gonna do cart content.  
105:48 - Okay, cool. Now, let me refresh. 
And now I'm gonna do cart.  
105:53 - There you go. Awesome. Very cool. So it's not 
quite a spa yet, because we still need to do the  
106:00 - linking component of it. So you so in order 
to get our spawn app going, we need to use  
106:04 - link from React Router DOM. So let's go over 
to the header and add the appropriate links.  
106:09 - So I'm going to paste in React Router 
DOM, and I'm going to bring in link.  
106:15 - And I'm going to put a link around fidget 
spinner world. And that's going to go to slash.  
106:30 - And let's see, I'm going to 
add a little diviner there.  
106:35 - And then I'm going to go make another 
link to cart. And we'll call that cart.  
106:43 - Let's take a look. Cool. And so they 
click on card. So I click on this,  
106:47 - I go to the homepage, and I click on this, I go 
to the cart, and even better, so I log in here.  
106:53 - I click on cart, the login is retained, it 
is a full spa. Now how awesome is that? That  
107:00 - is really cool. Okay, so another thing I want 
to do is just make sure that I have an ID here  
107:06 - for the cart. And that's just to make sure that 
our automation works properly. But I'm gonna go  
107:10 - because I'm a little bit of a stickler here, I'm 
just going to go and add a little bit of padding  
107:15 - and margin on the X around that. Just make 
it nice. And that'd be a Flexbox. Yeah,  
107:22 - that looks good. Okay, cool. So now if we want 
to click on one of these, right, we're going to  
107:27 - go and use a spa link to get to our product detail 
page. So let's go and change our home content to  
107:35 - point at that product. So I'm going to go and link 
in here to that lecture, it looks pretty good.  
107:48 - And is wrapped the product name in that, and 
also going to do the same thing for the image.  
107:57 - So if I log in, and then I click on solid rainbow, 
I'm still logged in, everything is great. So I  
108:04 - have a spa coherent spawn AV, across the app. 
So that's awesome. And yes, that seemed fast,  
108:10 - right. But at the same time, we were pretty 
much set up from the get go to allow for that.  
108:15 - So now let's answer one of the biggest questions 
that I get when it comes to Module Federation.  
108:19 - And like Raffys, which is how to test this stuff. 
And we'll start off by looking at unit testing.  
108:25 - So I'm going to close out all these files. And 
what we're going to do is we're going to add a  
108:30 - test to the homepage that will require the card 
information. So we will need a mock the cart.  
108:38 - So I'm going to first go to home. And then I'm 
going to stop the server and I'm going to add  
108:44 - the testing library for React hooks because 
we're going to basically create a hook that  
108:48 - depends on the cart count. And then I'm going 
to set up the jest environment by creating a  
108:52 - new file called jest dot config dot j s. And I'm 
going to say that our environment is the j s DOM.  
108:59 - So now we're going to go and create our use card 
count. So create a new file, we'll call that use  
109:04 - cart count. And I'm going to bring in use a use 
effect from react, I'm going to bring in the cart  
109:09 - as you would, and then I'm going to export 
use cart count. And that's going to set up  
109:14 - some state that has the initial cart items length 
in it. And then I'm going to return that count.  
109:20 - And in the meantime, I'm going to also do a use 
effect with no dependency array. So it's only  
109:25 - going to run on startup. And then I'm going to 
subscribe to the cart and get that cart items.  
109:37 - And then set the count to the length of those cart 
items. So that's pretty simple one All I want is  
109:42 - the number of items in the cart. Pretty simple. 
So how am I going to test this? So I'm going to  
109:47 - go and create a new file called use cart count dot 
spec dot j s and I'm going to bring in the testing  
109:55 - library with React hooks. And it's going to allow 
us to render a hook and then To call functions on  
110:01 - it if we want to, but we're going to use this 
to basically trigger that subscribe. And then  
110:06 - we're going to bring in our hook. And then we're 
going to create our first test. So we're going to  
110:11 - describe use car count. And we're going to say 
that it should return a car count. And we're  
110:15 - going to just get the result from use car count. 
And we're going to expect that to be zero, since  
110:19 - there's no cart currently, and we're going to mock 
the cart count. So how are we going to do that?  
110:24 - Well, let's just do just mock and then give it 
cart cart, which is what we're looking for over in  
110:31 - use card count. So is that going to work? 
Let's give that a try. So let's do yarn jest.  
110:41 - And we see that it can't find that 
module cart cart. So so the way that  
110:46 - we can trick it into believing that there's 
that module is to create a new manual mock.  
110:53 - For the cart, so I'll create a folder called 
mocks inside that a folder called cart.  
111:01 - And then within that a new file called cart 
dot j s, where we will export a default,  
111:07 - essentially just an empty object. Let's give 
it a try. And there you go, ran and passed.  
111:14 - So we're going to have another test 
where we essentially bump the cart count.  
111:17 - So we'll add that in. So use that cart count hook. 
And that's going to basically send us a callback,  
111:24 - in that use effect. And then we're going to call 
that back and say that we have a new set of CART  
111:28 - items. So we need to store that callback 
somewhere. So I'm going to put that up  
111:32 - here. And then I'm going to replace 
this subscribe with a function that  
111:37 - takes a callback and then sets that callback 
value. So let's try this, see if it works.  
111:45 - All right, two passes. Okay, cool. So that's unit 
testing. So you can mock out these remote modules,  
111:54 - that's not a problem. So now let's talk about IE 
testing. So the way that I'm going to do that is  
112:00 - I'm going to use Cypress. So the first thing I 
need to do is add Cypress. And then I'm going  
112:05 - to open Cypress by doing yarn run Cypress open. 
And so what it's done is it's gone over here, and  
112:11 - it's created a cypress directory, and in there, 
there's a bunch of tests, we're gonna do all the  
112:15 - integration tests and all that sort of stuff, we 
don't need any of that. So we're just going to  
112:18 - get rid of that. I'm going to create a new file in 
here, and we're going to call it Ed spec dot j s.  
112:26 - And I'm going to describe my first EDI test. So 
now we have to record a test. So I'm going to go  
112:33 - and create yet another terminal, where I'm going 
to run home. So I'm going to jump back into home,  
112:38 - and yarn started. And I'm going to bring up the 
Cypress recorder, which is a extension on Chrome,  
112:45 - and I'm gonna do start recording, then I'm going 
to log in, then I'm going to show the cart,  
112:50 - I'm going to clear the cart, I'm going to 
go and add an item to the cart. And then I'm  
112:55 - gonna go to the cart page. Now let's go take a 
look at what our test has. Alright, that looks  
113:01 - pretty good. So I'm going to stop recording. 
And I'm going to copy that to the clipboard  
113:09 - and go over here and I'm going to say 
it should add an item to the cart.  
113:22 - Alright, so let's go over and look at our Cypress.  
113:26 - And I'm going to run our ED spec, 
that's gonna bring up Chrome.  
113:33 - Alright, and it didn't contain that localhost. 
I'm not sure why that happened. So I'm going to go  
113:37 - over and get rid of this. I don't think that's the 
case anyway. So let's stop and then restart it.  
113:51 - Alright, looks pretty good. Okay, so now what we 
want to do is we want to test to make sure that we  
113:56 - get this 599 value at the very end. So we're gonna 
need an ID on that. So let's go back over to our  
114:03 - cart page and make sure that we have an ID on that 
grand total. So good on the cart content. And I'll  
114:09 - scroll down here and we'll make sure that we need 
an ID on this. All that grand underscore total.  
114:17 - Excellent. Okay, let's go take a look at this. 
And research to be able to say see, why'd I get  
114:23 - get the grand total? And I'm going to say that 
should Yep, contain and what was the number we  
114:29 - wanted again? 599. So let's take a look and 
do 599 here and see if we get a passing test.  
114:41 - Awesome. light is green. And that's an end 
to end test over multiple independently  
114:48 - deployed applications. That is just super cool. 
All right, so let's talk about what to look for  
114:54 - next when it comes to learning module Federation 
and my graphes and one area in particular I think  
115:00 - you should have a look at is single spa. So single 
spa fits on top of module Federation. And it  
115:07 - gives you a way of making your components cross 
platform. So as I did with place Add to Cart,  
115:14 - that's a pretty simple hacky way to do it single 
spa does it the right way and actually goes  
115:19 - and wraps all of the different platforms and 
wraps their components in kind of a uniform  
115:25 - parcel. And then you can deploy those using 
either a system js or using module Federation,  
115:30 - which I think is very easy. And then you can 
consume those in any other application. So you  
115:35 - could parcel up a view component and then reuse 
it in a React component. It makes it super simple.  
115:42 - Another thing I think you should keep an eye on is 
bit. This is a company that has been doing micro  
115:47 - Fe slash share component work for a long time. 
And they've been looking at auto Federation.  
115:53 - So there might be some interesting synergy is 
going on there. So definitely keep an eye out  
115:58 - for my graffitis when it comes to bit. And then 
I often get asked, like, have you actually seen  
116:04 - this in the wild yet, and a friend of mine was 
working over at Lowe's. And they've actually used  
116:10 - the model Federation and Mike Griffeys to create 
this really cool paint finder. So they've got a,  
116:17 - an app, and they embedded this paint finder in 
it. And now these two things are independently  
116:22 - deployable, which is really really cool. So it is 
out there in the wild and that's great. All right,  
116:28 - well, I hope you enjoyed this look into Microsoft 
fees and you got a lot out of it. Be sure to put  
116:32 - any questions you have in the comment 
section down below. And of course,  
116:36 - hit that like button if you liked the video. 
Alright, enjoy your future in my graphes