00:00 - Dr Charles Severance is one of the
00:01 - world's most popular programming
00:03 - instructors in this course he'll teach
00:06 - you C programming and object orientation
00:09 - With a Little Help from the classic
00:11 - cbook from kinghan and Richie this is
00:14 - definitely the place to start if you
00:16 - want to learn C welcome to C programming
00:18 - for everybody my name is Charles sance
00:20 - and I'm your instructor for this course
00:23 - this course and website is dedicated to
00:25 - learning the classic version of C
00:26 - programming language from the 1978 book
00:29 - written by Brian W kernigan and Dennis M
00:32 - Richie this book places the reader in
00:34 - the middle of the 1970s transition from
00:36 - a hardware centered computer science to
00:39 - a focus on writing portable and
00:41 - efficient software C was used to develop
00:44 - operating systems like Unix Minix and
00:46 - Linux programming languages like Pearl
00:49 - python Java and JavaScript and Ruby are
00:52 - all written in C software like early
00:54 - tcpip networking stack implementations
00:57 - that made the internet possible were
00:58 - written in C and the first web browsers
01:01 - and web servers were written in C
01:04 - writing software in C enabled major
01:06 - advances in computer architecture and
01:08 - performance operating systems compilers
01:11 - and utilities could be recompiled to
01:13 - work on a new hardware platform once we
01:15 - had a c compiler for the new hardware so
01:18 - much software has been written in C over
01:20 - the past 40 years that there's a very
01:22 - good chance that much of the software
01:24 - that you use every day was either
01:26 - written in C or written in a programming
01:29 - language that was was written in C so we
01:32 - study C less as a programming language
01:34 - to use on a daily basis and more as the
01:36 - foundation of modern software and
01:38 - Computing in many ways C is the
01:40 - technology equivalent of the Rosetta
01:42 - Stone in that it provides a connection
01:44 - between the programming languages of the
01:46 - past and the programming languages of
01:48 - the present the name cc4 in
01:52 - www.cc.com refers to the original Unix
01:55 - command CC which was the command that
01:58 - you used to compile your C program CC
02:01 - stood for C compiler and it is featured
02:04 - on the first page of the first chapter
02:06 - of the KRC book programmers like me from
02:09 - the 1970s and 1980s typed CC on unic
02:13 - systems like the AT&T 3bw to compile and
02:16 - run their first hello world program in C
02:21 - this material is being presented under
02:22 - fair use as we are making use of
02:24 - material from a copyrighted work that is
02:25 - out of print and not broadly available
02:27 - in any format the book is also not
02:29 - available in any accessible format we
02:32 - are making use of this material in a
02:33 - teaching and research context with a
02:35 - focus on studying its contribution to
02:37 - Computing history the material is a
02:40 - available for free and online to anyone
02:42 - who wants to learn about the history of
02:43 - the sea language Computing and computer
02:46 - architecture welcome to the course
02:51 - [Music]
03:01 - welcome to C programming for everybody
03:03 - my name is Charles sance and I'm your
03:05 - instructor for this course this course
03:07 - in website is dedicated to learning the
03:09 - classic version of C programming
03:10 - language from the 1978 book written by
03:14 - Brian W kernigan and Dennis M Richie
03:16 - this book places the reader in the
03:18 - middle of the 1970s transition from a
03:21 - hardware centered computer science to a
03:23 - focus on writing portable and efficient
03:25 - software C was used to develop operating
03:28 - systems like Unix NX and Linux
03:31 - programming languages like Pearl python
03:34 - Java and JavaScript and Ruby are all
03:36 - written in C software like early tcpip
03:39 - networking stack implementations that
03:41 - made the internet possible were written
03:42 - in C and the first web browsers and web
03:45 - servers were written in C writing
03:48 - software in C enabled major advances in
03:51 - computer architecture and performance
03:53 - operating systems compilers and
03:55 - utilities could be recompiled to work on
03:57 - a new hardware platform once we had a c
03:59 - comp filer for the new hardware so much
04:02 - software has been written in C over the
04:04 - past 40 years that there's a very good
04:06 - chance that much of the software that
04:08 - you use every day was either written in
04:11 - C or written in a programming language
04:13 - that was written in C so we study C less
04:16 - as a programming language to use on a
04:18 - daily basis and more as the foundation
04:20 - of modern software and Computing in many
04:23 - ways C is the technology equivalent of
04:25 - the Rosetta Stone in that it provides a
04:27 - connection between the programming
04:29 - languages of the past and the
04:31 - programming languages of the present the
04:33 - name cc4 in
04:36 - www.cc.com refers to the original Unix
04:39 - command CC which was the command that
04:42 - you Ed to compile your C program CC
04:45 - stood for C compiler and it is featured
04:48 - on the first page of the first chapter
04:50 - of the KRC book programmers like me from
04:53 - the 1970s and 1980s typed CC on unic
04:57 - systems like the AT&T 3bw to compile and
05:00 - run their first hello world program in C
05:05 - this material is being presented under
05:06 - fair use as we are making use of
05:08 - material from a copyrighted work that is
05:09 - out of print and not broadly available
05:11 - in any format the book is also not
05:13 - available in any accessible format we
05:16 - are making use of this material in a
05:17 - teaching and research context with a
05:19 - focus on studying its contribution to
05:21 - Computing history the material is a
05:24 - available for free and online to anyone
05:26 - who wants to learn about the history of
05:27 - the sea language Computing and computer
05:30 - architecture welcome to the
05:32 - [Music]
05:44 - course hello and welcome to C
05:47 - programming for everybody this lecture
05:49 - is putting C in a bit of a historical
05:52 - context now if you're watching this
05:54 - lecture you're probably familiar with
05:55 - some of my other classes I just want to
05:57 - kind of let you know that I've been been
05:59 - building a lot of classes most of you
06:01 - probably took python for everybody
06:02 - available on corsera ATX and many other
06:05 - platforms but I have a whole series of
06:07 - classes that are designed what I call
06:09 - the path of the master programmer where
06:12 - I try to start people that no matter
06:15 - where you start I want you to be able to
06:17 - learn to be a really good programmer and
06:18 - follow along as far as you want these
06:21 - are all my materials they're all 100%
06:22 - free open and online and they're really
06:26 - aimed at teaching everybody how to
06:28 - program I mean I started doing doing
06:29 - this back in 2012 with
06:33 - corsera and I have dedicated myself to
06:36 - making all my materials free and to
06:39 - create a path that anyone can take
06:41 - anywhere in the world regardless of
06:43 - economic uh challenges or other things
06:45 - in your life I want everybody to have an
06:48 - opportunity to be a professional
06:50 - developer so I encourage you and and and
06:52 - frankly if you haven't taken python yet
06:54 - like my python for everybody class this
06:56 - this course is going to be a little bit
06:58 - uh difficult so let's start with a
07:00 - history of sea the book we're looking at
07:03 - the kigan and Richie
07:05 - uh C A C programming language by Brian W
07:10 - kernigan and Dennis M Richie uh was
07:13 - published in
07:14 - 1978 and the the key thing is is that it
07:17 - it is a moment in history where
07:20 - everything
07:21 - changed and and so we're looking at this
07:24 - textbook and the text in this textbook
07:26 - and the language itself in the context
07:28 - of how it is impacted history the C
07:31 - programming language itself has a long
07:33 - history there was a language called B
07:35 - and they were using it at AT&T of bell
07:37 - labs to build utilities and operating
07:39 - system stuff um but it was a little too
07:42 - word oriented and so they the language C
07:46 - was as new uh computer hardware came out
07:50 - that supported bite addressing and the
07:52 - ability to load a string of bites and
07:55 - send store a string of bites rather than
07:56 - a set of words words being lger than a
07:59 - bite and more than one character were
08:01 - packed into a words and kind of like the
08:03 - 60s and early' 70s um C wanted to make a
08:08 - character a sort of core uh low-level V
08:13 - kind of data that the language would
08:15 - happen and from like like the the mid
08:17 - early and mid 70s the C and Unix kind of
08:20 - co-evolved they wanted to build
08:23 - something that would uh make Unix work
08:25 - well on a PDP
08:27 - 1120 and at the same time uh make it so
08:31 - they could Port Unix to other systems
08:33 - but really um it was about the PDP 1120s
08:37 - uh cool memory architecture having to do
08:38 - with bite addressability and what
08:41 - happened was is they were they were
08:43 - carefully rewriting Unix in C but then
08:46 - fixing C laying the groundwork for uh
08:49 - Unix portability and so by 1978 the this
08:53 - KRC book was published and at that point
08:56 - you could think of it as a um a summary
08:59 - of over a decade of research in how to
09:03 - build a portable programming language
09:05 - and then use that portable programming
09:06 - language to build a portable operating
09:10 - system C in Unix of
09:12 - course um by uh
09:15 - 1989 the C had become popular and there
09:17 - was a need to standardize it so there's
09:19 - a variant of C called c89 that is the
09:22 - ANC and then that same version was
09:25 - called C90 as ISO ISO the international
09:28 - organization of standards also
09:30 - standardized that and so that was our
09:32 - first uh version of the sea that we
09:35 - could all agree on uh the the ancy did
09:38 - not intend to go too far away from what
09:40 - we call KRC it but instead it just you
09:44 - know sort of nailed down a few things
09:46 - that by then were important to nail down
09:49 - um and C has continued to evolve from
09:52 - sort of 1990 to the present and there's
09:55 - a number of major revisions but the key
09:57 - thing that these revisions don't do in
10:00 - the modern version of C is they do not
10:02 - attempt to make C uh easy to use
10:05 - language say like python or JavaScript
10:07 - and they C is knows its place in the in
10:11 - the panoply of languages and does a good
10:14 - job of
10:16 - that so if we look at sort of what's the
10:20 - future C is a difficult language to use
10:23 - as a general purpose language python is
10:25 - a is a great general purpose language
10:27 - but it's not a great systems programming
10:29 - language
10:30 - and the two things that are missing from
10:32 - C are the lack of really solid dynamic
10:35 - memory support in the core types and
10:37 - libraries and then there is no safe
10:39 - string type strings are not there's no
10:41 - string in C it's character arrays and
10:44 - arrays have sizes and if you start
10:46 - putting stuff beyond the boundary of
10:48 - that array things just blow up and C++
10:52 - is to me not the the sort of future
10:56 - version of C it's really a more powerful
10:58 - inter
10:59 - and flexible version of C for
11:02 - programmers who are doing really
11:04 - professional intricate systems
11:06 - applications writing good C++ in some
11:09 - ways is more difficult than writing good
11:12 - C the the languages that sort of take on
11:17 - in C's mantle in the general purpose are
11:19 - things like Java JavaScript CP or python
11:23 - the key thing with these languages is
11:25 - they don't give you sort of strings as
11:29 - just raw bite arrays and they they give
11:32 - us a simple objectoriented layer that
11:34 - keeps us away from the metal the goal of
11:36 - C is to get close to the hardware close
11:38 - to the metal and so Java JavaScript C
11:42 - python are all great languages and
11:43 - they're great for what we use them for
11:46 - they're just not well suited for writing
11:48 - an operating system
11:50 - kernel the most likely language that is
11:54 - like C like the next C is probably rust
11:59 - the idea of rust is that it stays close
12:01 - to the metal um but then gives us some
12:04 - simple and safe core data types and
12:08 - recently Linux is starting to accept
12:10 - some Rust in Linux and so that means
12:14 - that rust has to be mature it means that
12:16 - rust can't be like evolving rapidly um
12:20 - I've seen situations where operating
12:23 - systems like Mac OS like decide to
12:25 - depend on python so there's parts of Mac
12:27 - OS that depend on python 2 but then they
12:30 - can't really upgrade to python 2 because
12:31 - their operating system blah blah blah so
12:34 - to for an operating system to depend on
12:36 - a programming language like rust it
12:38 - really has to be mature and even more
12:42 - importantly stable you can't have clever
12:45 - Innovations in the programming language
12:48 - causing regressions in an operating
12:49 - system say like clinics so I look look
12:52 - look for
12:53 - rust now C is has been around a long
12:57 - time um before C we call C starting in
13:01 - 72 the book is published in 78 before c
13:05 - most of us would write Assembly Language
13:08 - or Fortran some people WR wrote pl1
13:11 - that's not on here uh Fortran is not
13:14 - really a general purpose programming
13:16 - language you wouldn't write uh command
13:19 - like cat in Fortran Fortran was really
13:22 - for scientific computations and the
13:24 - earliest of computers in the 50s 60s
13:28 - were either sort of really specialized
13:31 - toward like payroll and HR systems or
13:34 - they were really specialized to doing
13:36 - computations and the ones that
13:38 - specialized were science the science
13:40 - ones were uh used for Trend because it
13:43 - was just the right language for those
13:44 - computers that were aimed at doing
13:46 - scientific
13:47 - calculations c as a language was kind of
13:51 - none of the above in that it was aimed
13:53 - at writing system code a kernel an
13:57 - operating system and the utilities
13:59 - around it including like other languages
14:03 - and so C is kind of the mother tongue of
14:06 - all kinds of other derivative languages
14:09 - and things like The Bash shell Pearl
14:12 - python PHP C++ JavaScript Java and C sh
14:16 - and Objective C just kind of were
14:18 - derivatives of this beginning of c and
14:21 - that's why you see a lot of patterns in
14:24 - these other languages that are similar
14:26 - and that's because JavaScript and Java
14:29 - both inherited their for Loop syntax
14:31 - from
14:33 - C so I've got a couple of videos in this
14:35 - section this is Brian kernigan and uh
14:38 - talking about the C programming language
14:40 - and it's a short video I didn't produce
14:42 - this video but it's a great little video
14:44 - um another video is from the creator of
14:47 - C++ Barn strrip this was an interview
14:50 - that I did with itle e computer Magazine
14:53 - on top of this history of the sea
14:54 - language we can look at a brief history
14:56 - of computers and I have a whole
15:00 - course called internet history
15:02 - technology and security that really
15:04 - starts in the 1940s with a focus more on
15:07 - communication rather than computation
15:09 - even though Comm communication and
15:11 - computation were very much connected
15:13 - throughout the 40s through the even
15:16 - today in the early 1950s computers were
15:19 - you best think of them as like a
15:21 - multi-million doll strategic asset every
15:24 - single computer and a lot of them were
15:26 - custombuilt the first computer uh
15:29 - Michigan State University where where I
15:31 - went to undergrad was built by the
15:32 - electrical engineering students of that
15:34 - University based on some designs that
15:36 - they' borrowed I think from Iowa and so
15:40 - things like the programming language the
15:42 - operating system you didn't have a lot
15:46 - of generalization you didn't have a lot
15:47 - of
15:48 - sharing you tended to write code and put
15:51 - it on a paper tape or later a magnetic
15:53 - tape and load it and run it and so you
15:55 - were just pretty happy if the code
15:58 - worked you didn't need an operating
16:00 - system these weren't multiprocessing
16:01 - computers and so the software
16:04 - environment was very
16:05 - minimalist but in the late 50s and early
16:08 - 60s you saw companies like IBM and
16:11 - digital equipment corporation began
16:13 - selling general purpose computers they
16:15 - just could make them um and they and
16:18 - they started selling them and they still
16:19 - were expensive and they were only in
16:21 - like a business would have a couple of
16:23 - computers to help them do payroll
16:25 - perhaps or something like that something
16:27 - that was really really important because
16:29 - the computers were expensive but in the'
16:32 - 60s there we we really got to the point
16:35 - where the computer componentry the chips
16:37 - Etc were becoming Commodities you could
16:41 - just go to a place and buy chips and
16:43 - then you could make a computer by buying
16:44 - a bunch of chips and putting those
16:46 - things together and and because you
16:48 - weren't building everything from scratch
16:50 - the cost got a lot lower the other thing
16:53 - that these uh these less expensive
16:55 - computers were is they were a little
16:56 - slower but by the end of the 1960 there
16:59 - was a lot of computers there were some
17:01 - you know super expensive weird oneof you
17:06 - know small production computers there
17:08 - were computers that had had there was
17:10 - like the previous generation of mini
17:12 - computer where there were lots of them
17:13 - laying around old computer science
17:15 - departments or businesses that they
17:17 - weren't sure what they did with them to
17:19 - do with them they wanted to buy a new
17:20 - one and then there were just Innovative
17:23 - new lowcost computers coming out and in
17:27 - the' 70s in the this millu of just lots
17:31 - of new and old computer hardware the
17:34 - question was is is there a way we can do
17:37 - things with all of this old hardware and
17:40 - is there sort of one solution and that's
17:43 - where Unix andc uh came and certainly
17:47 - after the 70s we look at the 80s and
17:49 - that's where microprocessors and
17:51 - personal computers and so we went from
17:53 - computers that were sizes of
17:54 - refrigerators or or desks to the size of
17:58 - a a computer could be on a single chip
18:01 - and in the beginning those personal
18:03 - computers like the IBM PC or Commodore
18:06 - pet they had really bad performance but
18:08 - that performance once you could get
18:10 - everything on a single chip that
18:12 - performance could get faster very
18:14 - quickly and because personal computers
18:17 - became a mass Market item a lot of money
18:19 - could be invested in personal
18:21 - computers by the 1990s personal
18:24 - computers continued to grow right and um
18:28 - but the to communicate and and talk and
18:31 - exchange information became important
18:33 - and so in the 1990s we saw really an
18:35 - increasing focus on connecting computers
18:38 - with the internet and other kinds of
18:39 - networks and the performance of these
18:41 - computers and the price kept going down
18:43 - the performance kept going up and then
18:45 - by the time we get to the 2000s Amazon's
18:48 - AWS was founded in 2002 and it used
18:52 - personal computer microprocessors like
18:54 - from Intel and produced Computing as a
18:57 - commodity right and so and you don't
18:59 - even buy computers anymore you just go
19:01 - to Amazon and say I'll rent a computer
19:03 - for $7 a month and so we see in 1978 we
19:09 - see this moment where the we going from
19:13 - uh the computers were were becoming more
19:15 - common they're going down in price and
19:17 - there's getting to be more and more of
19:18 - them and there was a diversity of
19:20 - computers these days there's actually
19:22 - less
19:24 - diversity if we go back in history and
19:27 - you take a look at my internet history
19:28 - class you you can see the I go to
19:29 - Bletchley Park and show you some of the
19:31 - earliest uh computations from the 1940s
19:34 - in World War II we go to uh Computer
19:38 - History Museum in California and visit
19:41 - with Gordon Bell and talk about the the
19:43 - pdp1 and he talks a lot about um buying
19:47 - the components and putting the
19:48 - components together and how how sort of
19:50 - the mass availability of relatively
19:53 - lowcost components really allowed for a
19:56 - rapid innovation in computer
19:57 - architecture
19:59 - uh a computer that I used in my uh
20:01 - computer science degree was the Control
20:03 - Data CDC 6500 and I have a video where
20:06 - we visit the living computer Museum in
20:09 - Seattle Washington and here card readers
20:12 - work and card punches and if uh if we
20:15 - ever get to the point where everything
20:16 - opens back up again it's a it's a
20:18 - tremendous visit to go see uh all the
20:21 - technology that really Through The Years
20:23 - except that it in the living computer
20:24 - Museum they like to have everything
20:26 - running and then you can take a look at
20:28 - a more modern smaller the Raspberry Pi
20:31 - which the Raspberry Pi is actually not
20:32 - an Intel based system the Raspberry Pi
20:35 - is based on uh arm the processor that
20:39 - really became popular as a result of the
20:41 - cell phone Revolution and so they the
20:43 - Raspberry Pi is to take what the the
20:46 - technology was Advanced both um low
20:50 - power and high performance technology
20:52 - that was Advanced because of mobile
20:54 - phone Innovations the Raspberry Pi came
20:57 - out and was a good single board computer
20:59 - so let's take a look at the operating
21:00 - system munix is the operating system
21:02 - that is uh connected with C in the 1960s
21:06 - there was a multi-user operating system
21:08 - called multics um and then in the 1970s
21:12 - they they wanted to come up with yet
21:14 - another operating system and they called
21:15 - it eventually called it Unix and the
21:17 - deck PDP 1120 which was one of these new
21:21 - uh commodity PE part-based
21:24 - computers um that was coming into the
21:27 - marketplace
21:29 - and so in 1973 Unix was Rewritten in C
21:32 - but it only was there on the pdp11
21:35 - although they had laid the groundwork
21:38 - for portability from the beginning they
21:41 - they knew they wanted to H have
21:43 - everything be portable they just
21:45 - couldn't make it all portable the first
21:47 - version they just had to make it run on
21:49 - the pdp11 and then by 1978 the Unix the
21:53 - second computer that Unix had run on was
21:55 - an inata 832 and that was quite a
21:57 - different computer and so it was good
21:59 - and so they really learned a lot about
22:01 - making Unix a portable bit of
22:04 - software from in the early 1970s C was
22:07 - evolving in a way so that the Unix could
22:10 - be ported right so it's like let's we
22:13 - got this problem between let's just say
22:15 - the pdb1 and the inner data and how can
22:18 - we fix this and we can both change how
22:21 - the operating system works we can change
22:23 - the operating system code and we can
22:24 - change the C compiler and then we can
22:26 - rewrite the operating system code
22:29 - to get less and less Assembly Language
22:31 - and more and more C language and so the
22:33 - idea was to get to the point where uh
22:35 - there was a very very small amount of
22:38 - Assembly Language in Unix and over the
22:40 - years that's gotten lower and
22:42 - lower Unix was Rewritten a number of
22:46 - versions came out in the 70s having to
22:48 - do with their portability so by 1978 the
22:51 - Unix version 7 could also run on a whole
22:54 - new architecture from deck called the
22:55 - VAC systems um uh the University of
22:59 - California Berkeley had their own
23:01 - distribution of Unix called BSD the
23:04 - Berkeley software distribution and that
23:06 - was really cool because uh universities
23:09 - often pushed things like networking
23:11 - tcpip arpanet BSD Unix was the first
23:15 - place some of us saw
23:17 - tcpip 1982 a company based solely on
23:21 - Unix called Sun Microsystems was found
23:25 - uh sun was some work at Stanford some
23:27 - work at Berkeley based on Unix and they
23:29 - created what in effect was the Unix
23:31 - workstation Marketplace at this point
23:34 - you could imagine that the world was
23:36 - about to just adopt Unix Unix was the
23:39 - greatest thing ever computer science
23:42 - departments were um teaching Unix in
23:46 - their operating systems classes in the
23:48 - in the mid 80s the problem became AT&T
23:52 - had never come up really with a business
23:54 - plan for what the purpose of Unix was
23:57 - and so there was
23:59 - some fits and starts as to how they
24:01 - could monetize this extremely popular
24:04 - thing
24:06 - and they they didn't do a great job and
24:10 - it took them a long time to figure out
24:12 - what was going to be successful and by
24:15 - the time AT&T sort of figured things
24:22 - out the market had moved on and
24:26 - so minex is an operating system system
24:28 - that was developed in the Netherlands by
24:30 - Andrew Tannon bomb and he he built a
24:32 - completely free and open- Source
24:34 - operating system that was used for
24:36 - Education he he built a textbook around
24:38 - it and it was very popular but uh he
24:42 - didn't want commercialization at least
24:45 - not at that point in time so he sort of
24:48 - he sort of held on to it too tightly
24:50 - again kind of an intellectual property
24:52 - mistake and in 19911 a program called
24:55 - lonus Torvalds decided he was going to
24:58 - build a fresh groundup implementation of
25:01 - the Unix kernel that was 100% free so he
25:04 - wasn't going to use Unix he wasn't going
25:06 - to use Minix he wanted to create another
25:08 - thing and originally it was just like a
25:10 - hobby I'm going to try to see how far I
25:11 - can go by 1992 Linux started to work and
25:15 - it adopted this license called the the
25:17 - GPL which is called the ganu public
25:19 - library license which is a strongly open
25:22 - source license in the way that it's
25:24 - difficult to take uh Linux out of Open
25:27 - Source with which meant that people
25:29 - could then invest in Linux and so Linux
25:33 - has become Unix right Linux in the
25:37 - modern world is the Unix like system and
25:40 - Unix tried to hold on for a while but
25:42 - they really really couldn't and so the
25:45 - uh the the remaining Unix distributions
25:47 - are a a tiny tiny fraction of the
25:51 - marketplace and Linux is the marketplace
25:55 - so we can see some of this in some of
25:56 - the videos that I've got like Andrew
25:58 - tanom will tell us the story of how
26:00 - Minix was created and how Minix be how
26:02 - Minix kind of begat Linux and so that
26:05 - there's some interesting stuff here
26:07 - okay so I'll lay on top of all this
26:10 - remember that 1978 is this moment in
26:12 - history where I claim like everything
26:14 - changed now I've been a computer
26:15 - scientist for a very long time I started
26:18 - in
26:19 - 1975 and in
26:21 - 19775 I learned things like Fortran on a
26:25 - computer that CDC 6500 computer it ran a
26:28 - special operating system called scope
26:30 - Hustler I knew how to do assembly I knew
26:32 - to Fortran and even
26:34 - Pascal so Pascal in the 70s was one of
26:37 - these languages um that and I've got a
26:40 - video for Pascal as well one of these
26:42 - languages that was sort of like saying
26:44 - look here's the future now Pascal was
26:47 - really aimed at teaching and so I used
26:49 - Pascal in educational
26:51 - context and I as I became a professional
26:54 - programmer in the 1980s I was using a
26:56 - bunch of stuff Assembly Language
26:58 - Cobalt little bit Unix and see here it
27:01 - wasn't like by the early 80s Unix was
27:03 - everywhere at least not in the
27:05 - professional world because the PC
27:07 - Revolution was happening so we had Doss
27:09 - we had early Windows versions I used
27:11 - things like dbas and turbo Pascal um I
27:15 - taught classes of the IBM 360 and I
27:18 - taught Assembly Language I use the deck
27:20 - vax and I use the VMS not Unix operating
27:22 - system in Fortran and I also then taught
27:25 - in the mid 80s on AT&T West I think it's
27:28 - called Uh a g8t 3B 2 I taught Unix I
27:33 - taught C and I taught Fortran and so
27:35 - even though we can trace back to like
27:38 - 1978 is the moment that everything
27:40 - changed it's not like the market changed
27:44 - the the thing that happened in the 1990s
27:47 - though is that all these older computers
27:50 - all and the older computer vendors like
27:52 - burough and Unisys and IBM and cray and
27:57 - control data um as microprocessor speeds
28:02 - increased all these little companies
28:04 - would create Unix workstations that were
28:06 - faster and faster and faster and because
28:09 - they could build new hardware that was
28:12 - fast and then grab the Unix operating
28:14 - system um and make their operating
28:18 - system work on their new hardware it
28:20 - allowed for some amazing Innovation so I
28:23 - was using Sun ardan Stellar these are
28:25 - all gone now IBM RS 6000 convex C2 2400
28:29 - I had a next on my desk I used C but TCP
28:32 - IP Windows HTTP the web you know and
28:36 - Windows and Mac OS were all kind of in
28:39 - the mix but the Innovation was really
28:42 - happening most rapidly in the Unix
28:45 - space but by the
28:48 - 2000s everything that I touched really
28:51 - had some aspect I'm not a Windows person
28:53 - so everything I touched had some aspect
28:55 - of Unix in it Mac OS still has Unix in
28:58 - Linux and my languages were sort of
29:01 - narrowing back down to Java PHP and
29:05 - JavaScript and then in 2010s right Linux
29:09 - Mac OS python PHP JavaScript so things
29:13 - really have settled into a world that my
29:17 - own software development where I'm
29:19 - pretty much using Unix like systems all
29:22 - the time and C based or C derived
29:26 - languages because python Java p HP and
29:28 - JavaScript are all based on C and that's
29:31 - why it's so important to understand C
29:34 - I'm not writing c as a profession
29:36 - professional in any way but I am using
29:39 - all my C knowledge every single
29:41 - day and so that's a a sort of a picture
29:44 - of me in my office that's an IBM PS2 in
29:47 - my office I I was registering in 1989 I
29:51 - was registering with Punch Cards when I
29:54 - first started I was using a line printer
29:56 - and punch cards and so so there there's
29:58 - my
29:59 - history now I think it's important to
30:02 - acknowledge that as I've shown you all
30:05 - these history documents and the videos
30:07 - and the oral histories that I've done is
30:09 - there is a preponderance of old white
30:13 - males in here and I I think that it is
30:16 - important to talk a bit
30:18 - about that and why that is perhaps and
30:22 - so I would encourage you to take a look
30:26 - at an article it's so article it's
30:28 - actually a you can listen to it about
30:31 - what happened to computer science the
30:33 - title of the article is when women stop
30:34 - coding yeah all the way up to 1980
30:36 - computer science was just another field
30:39 - and then it you know kept going up to
30:41 - sort of 1985 but then it went down and
30:45 - so you know all these other fields have
30:47 - a pretty good uh gender mix and the
30:49 - computer science uh does not have a
30:52 - gender and so I would encourage you to
30:55 - listen to this
30:56 - article uh another another area that you
30:59 - can learn something about um the
31:01 - diversity in computer science is uh this
31:04 - book by Jane margalis called unlocking
31:06 - the clubhouse the essence of the book is
31:09 - really talking about how uh social
31:12 - pressure advertising pressure in the
31:15 - early 80s uh made it seem as though
31:18 - Computing was a guy thing and in
31:21 - particular uh it made it so that uh
31:24 - young men even in high school would go
31:26 - fiddle around with computers as a hobby
31:28 - and by the time they got to college they
31:30 - were pretty skilled and if you weren't
31:32 - skilled the college classes were
31:35 - designed for people who already knew
31:37 - what programming was and if you were a
31:39 - woman and you hadn't played with
31:40 - computers in 1980 when you were like 14
31:44 - years old you'd came to college at a
31:46 - distinct disadvantage and this is what
31:48 - led to this falloff where colleges
31:52 - tended to teach to programmers who
31:54 - already knew how to program and uh that
31:57 - really meant that that the hobbyists
31:59 - people who are in their youth before
32:00 - they went to college and played with
32:02 - programming as a hobby uh had a
32:04 - tremendous
32:06 - Advantage now Jane did her work in the
32:09 - 80s late 80s and 90s um I myself I'm
32:14 - older than that and I think that to some
32:17 - degree this notion of the social
32:20 - pressure uh that said that uh Computing
32:23 - was really for young men and not young
32:26 - women uh it it's actually as much a
32:30 - symptom as it is the cause because I
32:32 - grew up in a time in the mid '70s where
32:35 - there were women everywhere um and this
32:38 - is a person who's who who who had a
32:41 - really large impact in my life her name
32:43 - is Helen Spence she was a professor at
32:45 - Michigan State University and I show you
32:47 - a URL to look at her oral history um she
32:51 - taught me operating systems so in 1977
32:55 - or 1978 I don't remember when Helen was
32:58 - my operating systems teacher uh the
33:00 - interesting thing about how Helen taught
33:02 - operating systems was she made it fun I
33:07 - it was really fun uh I encountered my
33:09 - first Auto grader in Helen's class she
33:11 - had made a piece of software that she
33:14 - called the HMS 5050 which itself is both
33:18 - Helen Spence and uh I think it's her
33:21 - majesty ship at the same time and what
33:23 - she did was she built a operating system
33:25 - simulator in Fortran and and our job as
33:29 - uh taking the class was to build
33:33 - functions and sub routines that would
33:34 - implement the tasks and the algorithms
33:37 - that operating systems need to do so
33:39 - you'd run your program over and over and
33:41 - over again until you had written a
33:43 - successful operating system and she
33:45 - wrote a autog grader that would do
33:48 - things to your program and then measure
33:50 - whether or not you knew how to build an
33:52 - operating system it was just a natural
33:55 - thing to have females as fast faculty
33:58 - members uh you know and and it was just
34:00 - a there was a lot more fun in the field
34:03 - um and I I have my own theories that I
34:06 - think complement uh Jane's theories as
34:08 - well but I'll leave it here that that's
34:11 - a TED Talk for another day as to uh
34:15 - gender and Computing right now I'm just
34:17 - acknowledging it and giving you some
34:19 - resources to uh to to read and U and
34:22 - reach your own conclusions if you look
34:24 - at everything I've done since 2012 in
34:27 - the free online education in Muk space
34:30 - you'll notice that every course I've
34:32 - ever created has the words for everybody
34:34 - and that's not just a marketing thing
34:37 - that's because it's my philosophy if
34:38 - you've taken some of my classes like
34:40 - python for everybody or jangle for
34:41 - everybody web applications for everybody
34:43 - postgress for everybody and now see
34:45 - programming for everybody I try to build
34:48 - a course where I spend time thinking
34:51 - about how not to create the clubhouse
34:54 - that Jane talks about and that is I want
34:57 - you in the club I want everybody in the
35:00 - club I don't want it just to be a club
35:02 - for the super Geniuses and so part of
35:05 - why I'm building an entire curriculum is
35:09 - to perhaps just make a new club and that
35:13 - is programming for everybody club and I
35:16 - think once you become a great programmer
35:18 - I think that's a good time to study
35:19 - computer science and so perhaps after we
35:21 - teach everybody programming then we can
35:24 - teach everybody computer science but
35:26 - again that's a TED Talk talk for another
35:29 - day so on to the course C programming
35:32 - for everybody I'll just say that c is
35:34 - the most important programming language
35:36 - you're going to ever learn it should
35:38 - never be the first programming language
35:40 - taught to any
35:41 - students you will likely never write a
35:44 - line of C in a professional context in
35:48 - your
35:49 - career I'm not teaching you C so that
35:51 - you can go be a professional C
35:53 - programmer I'm teaching you C so you can
35:55 - be a professional Java programmer really
35:58 - but if you learn see at the right time
35:59 - in your Learning Journey it's a
36:02 - necessary step on the path to becoming a
36:04 - master programmer but it's important
36:06 - step because I can't teach you Java if I
36:10 - hadn't already taught you
36:12 - C I have to explain how Java Works in
36:16 - terms of what you're going to learn in
36:18 - this class so this class is not just
36:21 - like get a c certificate and go make
36:23 - lots of money CU I don't think that this
36:26 - certificate's going to make you a lot of
36:28 - money but I do think this certificate is
36:30 - going to unlock the future of you as a
36:33 - programmer
36:35 - so please be patient with this material
36:39 - do not rush it's an online class I
36:43 - guarantee that you can search for
36:44 - solutions to every programming exercise
36:46 - that I create I don't change them that
36:48 - much so the solutions are out there and
36:51 - if your goal is to game it and just
36:53 - search for solutions to programming go
36:55 - ahead finish the class congratulations
36:58 - but you you have just taken the
37:00 - opportunity to learn from yourself right
37:04 - you didn't you didn't trick me I didn't
37:06 - lose anything by you searching for and
37:09 - just pasting in solutions to programs
37:12 - each
37:13 - exercise from beginning to end is trying
37:16 - to take you a little tiny step further
37:19 - down your understanding and the easy
37:22 - exercises in the beginning even if I
37:24 - have a bunch of them they're there to
37:26 - prepare and strengthen strengthen you
37:27 - for something much more challenging in
37:29 - the course if you start pasting in
37:32 - Solutions in the beginning of the course
37:34 - you have no chance in the end of the
37:36 - course and you're just going to be
37:38 - pasting in Solutions and when you do
37:40 - that you'll have only wasted your
37:44 - time
37:46 - so I look forward to you taking the rest
37:49 - of this course I of course I look
37:51 - forward to you telling me if uh if I'm
37:54 - right in my instinct about how important
37:56 - this is for you uh especially after you
37:59 - take a few more classes and then uh find
38:02 - your way to being a professional
38:11 - [Music]
38:46 - that b abbs bunch of smart people I call
38:50 - it 1,200 PhD level people in Murray Hill
38:54 - in basically one giant building and so
38:57 - that's a lot lot of people rubbing up
38:58 - against each and they're all doing
38:59 - technical kinds of things and and the
39:02 - environment did not tell people what to
39:05 - do it was go do your thing and once a
39:07 - year one side of one piece of paper tell
39:09 - us what you did and that'll determine
39:10 - how much money you get next year but it
39:12 - was a very long cycle the one extra
39:15 - thing is that it was a problem Rich
39:17 - environment and so there were things
39:20 - that you could work on and there was
39:22 - this I think very gentle gravitational
39:25 - drift towards doing something that
39:28 - somebody else might care about now lots
39:30 - of people you know who cares what other
39:31 - people think I'm going to do my stuff
39:33 - but I think most people got some reward
39:36 - you know psychic reward from I do
39:39 - something I give it to you and you say
39:41 - that was great and then you say but and
39:44 - you tell me all the things that aren't
39:45 - yet great but but that kind of thing was
39:47 - very common at the labs because AT&T at
39:50 - that time basically supplied telephone
39:52 - service to most of the United States
39:55 - million people all kinds of in problems
39:58 - in and around Communications and so no
40:00 - matter what you were interested in
40:01 - there' be some part of AT&T that could
40:04 - probably make use of that so that was
40:07 - part of it but then there was the
40:08 - external world as well the research
40:10 - Community Bill Labs was just part of the
40:12 - academic research community so they're
40:14 - both outlets and the labs was perfectly
40:16 - happy to have people do either and so
40:18 - all of that I think worked out really
40:21 - very well um and it helped to have
40:23 - stable funding because basically at that
40:26 - point if you made a a longdistance phone
40:28 - call in the United States remember the
40:30 - concept of longdistance right if you
40:31 - made one of those calls a tiny slice of
40:34 - the revenue of that finance bill Labs
40:37 - with the charter of make the service
40:39 - better and don't we won't worry about
40:42 - the details of how you do that so at the
40:44 - time there was a lot of interest in
40:46 - programming languages this all came out
40:47 - of the multics experience right where
40:49 - where people at Bel labs and of course
40:52 - the folks at MIT were had realized that
40:54 - writing things in a highle language made
40:56 - sense
40:57 - and then the question is what's what's
40:59 - the high level language and they started
41:01 - with pl1 which in the abstract sounded
41:05 - like a good idea and in reality was a
41:06 - horrible idea because it was a horrible
41:08 - language and and so Martin Richards from
41:13 - uh Cambridge University of Cambridge um
41:15 - had this language called bcpl and he had
41:17 - spent if I understand it correctly a
41:19 - sabatical year at
41:21 - MIT planted the language in some sense
41:24 - and it was much simpler much cleaner
41:26 - much better suited to system programming
41:29 - kinds of things than any version of pl1
41:31 - would have been and so the people at
41:33 - Bell Labs Ken Thompson Dennis Richie and
41:36 - so on had gotten some experience with
41:39 - high level languages as suitable for
41:41 - writing lots of different
41:43 - things bcpl wasn't a suitable thing for
41:46 - modern machines because it was typeless
41:49 - and newer machines clearly were coming
41:51 - on stream that would have types like
41:53 - btes and integers and maybe bigger
41:55 - things and so
41:58 - so at some point Ken did a lot of
42:01 - experimenting this is Ken Thomas did a
42:02 - lot of experimenting with simpler
42:05 - versions even of bcpl in particular one
42:07 - called B which was an interpreted
42:09 - language no compiler um and that was
42:13 - again expressive enough that people
42:14 - started to like it and that's sort of
42:16 - where I started in on this I mean I'd
42:18 - written bits of pl1 it was awful I'd
42:21 - written Fortran better um but the B was
42:26 - sort of
42:27 - nicer to use but it was still
42:29 - typeless and an interpreter as well so
42:32 - it wouldn't be terribly efficient um but
42:34 - with the pdp1 in the offing and I don't
42:37 - remember the exact timing here U it was
42:40 - clear that a version of something that
42:41 - was felt sort of like B but which had
42:44 - some mechanism to include types so that
42:48 - you could talk about characters or
42:49 - integers was going to be the way to go
42:52 - and that's where Dennis picked up and
42:54 - started developing the C language and
42:57 - the compiler to go with it and so on
42:59 - portability was very much on people's
43:00 - minds at that time because although the
43:03 - core Unix work was done on the pdp1
43:05 - there were other machines at the time
43:08 - that were you know in the same
43:09 - equivalence class uh inata had a couple
43:13 - 732 832 numbers like that and I think
43:18 - there were probably HP machines as well
43:20 - and ETA um and the other thing that was
43:23 - in some ways harder was that there was
43:26 - the big big Mainframe kind of computerss
43:28 - that were used by the local computer
43:30 - center and these were fundamentally
43:32 - stripped down versions of the multic
43:34 - machines there were
43:35 - g635 kind of things and so those were
43:38 - big clunky word oriented machines they
43:40 - were you know effect IBM 794 is cleaned
43:43 - up a bit and getting something that
43:46 - would compile sensibly for those
43:49 - machines that really didn't have
43:51 - characters in a language which had
43:54 - become what it was so it could
43:55 - manipulate characters I think there was
43:57 - a bit of a strain there but that
43:59 - portability how do you get the same
44:02 - language to work on different computers
44:04 - and Dennis's original compiler really
44:06 - was targeted at the pdp11 and Steve
44:09 - Johnson came along with the portable C
44:11 - compiler which basically separated the
44:14 - front end okay let's recognize the
44:16 - language let's build some intermediate
44:18 - structure and then let's generate code
44:21 - for different kinds of
44:23 - machines I had written a tutorial on B
44:26 - because you know I thought it was
44:27 - interesting maybe I can tell other
44:28 - people how to use it um and so when C
44:32 - started to be used and I became somewhat
44:35 - better at using it then I basically
44:37 - repurposed the B tutorial brought it
44:39 - forward in in and made the c tutorial
44:41 - out of it uh and so I used C4 all this
44:45 - essentially all the software that I was
44:47 - writing at that time and you know kind
44:51 - of liked it it was good it was a nice
44:52 - match for the way people think about
44:54 - Computing I think but also a very nice
44:56 - match for the actual Hardware of the
44:58 - time you could imagine what the compiler
45:00 - was doing all of it was clear so
45:04 - efficient expressive and you know nicely
45:06 - matched to everything around it um and
45:10 - then somewhere in probably
45:13 - 1977 earlyish um I coerced Dennis into
45:18 - writing a book about it first edition
45:19 - came out in 78 and at that point the
45:21 - language was pretty reasonable the book
45:24 - I think it was right on the cusp of we
45:27 - structures were fully part of the
45:28 - language or not a bit of overhang there
45:31 - and I don't remember but I think
45:33 - probably they were not quite but awful
45:35 - close and since Dennis was doing both
45:37 - compiler and book I it was at least a
45:41 - consistent Viewpoint question can you
45:42 - pick up a structure as a unit and pass
45:44 - it around or do you have to do something
45:46 - special um so I think but that's a
45:49 - milestone and then the next one is
45:51 - probably the 1988 book and the
45:54 - development of the ANC C standard the
45:56 - first stand which is essentially again
45:58 - about the same time um and so I think
46:04 - those are the ways I measured and at
46:06 - that point call it 1988 give or take
46:09 - just before you encountered it um C was
46:12 - probably just fine for anything you
46:14 - might reasonably want to do and this is
46:18 - probably heresy or something but I don't
46:19 - think that the changes in evolution
46:22 - since then have
46:23 - bought enough in some sense
46:27 - [Music]
46:45 - welcome to C programming for everybody
46:48 - my name is Charles sance and this is my
46:51 - reading of the 1978 C programming book
46:53 - written by Brian kernigan and Dennis
46:55 - Richie at times I add my own
46:57 - interpretation of the material from a
46:59 - historical
47:01 - perspective chapter zero introduction C
47:05 - is a general purpose programming
47:06 - language it has been closely associated
47:09 - with the Unix System since it was
47:10 - developed on that system and since Unix
47:13 - and its software are written in C the
47:15 - language however is not tied to any one
47:17 - operating system or machine and although
47:20 - it has been called a system programming
47:22 - language because it is useful for
47:24 - writing operating systems it has been
47:26 - used equally well to write major
47:28 - numerical text processing and database
47:31 - programs C is a relatively low-level
47:34 - language this characterization is not
47:36 - perjorative it simply means that c deals
47:39 - with the same sort of objects that most
47:41 - computers do namely characters numbers
47:44 - and addresses these may be be combined
47:47 - and moved about with the usual
47:49 - arithmetic and logical operators
47:51 - implemented by actual machines C
47:54 - provides no operations to deal directly
47:56 - with composite objects such as character
47:59 - strings sets lists or arrays considered
48:02 - as a whole there is no analog for
48:05 - example of the pl1 operations which
48:08 - manipulate an entire array or string the
48:11 - language does not define any storage
48:12 - allocation facility other than static
48:15 - definition and the stack discipline
48:17 - provided by the local variables of
48:18 - functions there is no Heap or Garbage
48:21 - Collection like that provided by alol 68
48:25 - finally C itself Prov provides no input
48:27 - output facilities there are no read or
48:30 - write statements and no wired INF file
48:33 - access methods all of these higher level
48:36 - mechanisms must be provided by
48:38 - explicitly called
48:40 - functions I would note that the lack of
48:42 - a heap or Garbage Collection feature in
48:45 - C is both one of the great strengths of
48:47 - the language and at the same time is
48:49 - likely the reason that the average
48:51 - programmer will never develop or
48:53 - maintain a major C application during
48:55 - their career C provides a simple feature
48:59 - using Malo and free functions that allow
49:01 - a programmer to request a certain amount
49:03 - of memory be allocated dynamically use
49:06 - the memory and then return the memory to
49:08 - the C runtime library for reuse for
49:11 - example to convert a jpeg image to a PNG
49:14 - image our application will read the jpeg
49:17 - data into memory then convert the image
49:19 - into a PNG image in memory and then
49:21 - write the PNG data out to a file we
49:24 - don't know how large the images will be
49:26 - in ADV advance so we request whatever
49:29 - size we need from C and then give it
49:31 - back when we're done the term Heap
49:34 - refers to the memory that c manages on
49:36 - our behalf when we need to borrow a bit
49:38 - of memory and give it back later there
49:41 - are a couple of issues with a simple
49:43 - Heap
49:44 - implementation first if we forget to
49:46 - call free when we are done with a memory
49:49 - we have created a memory leak and our
49:51 - program will eventually run out of
49:53 - memory and aboard C places the onus of
49:56 - giving back any dynamically allocated
49:58 - memory on the
49:59 - programmer modern languages like Java
50:02 - JavaScript and python keep track of when
50:05 - we stop using dynamic memory using a
50:07 - dynamic memory layer that can
50:09 - automatically reclaim the
50:11 - memory the more difficult problem is
50:14 - after a series of calls to malakin free
50:17 - the Heap space becomes fragmented and
50:19 - some cleanup is needed this cleanup is
50:21 - called garbage collection efficient
50:24 - memory allocation and garbage collection
50:26 - has been the subject of Decades of
50:28 - computer science
50:30 - research the Java language has built an
50:33 - number of increasingly effective garbage
50:35 - collection approaches over the years
50:38 - kernigan and Richie in one simple
50:40 - paragraph Define most of the problem as
50:42 - out of scope for the ca language which
50:44 - makes it a bit challenging for us to
50:46 - make good use of dynamic memory
50:48 - allocation in C but when we do it
50:50 - properly it performs very well if you
50:54 - are currently using a language like Java
50:57 - python or PHP every time you create a
51:00 - new string through concatenation without
51:02 - thinking about memory allocation
51:04 - remember to appreciate the Decades of
51:06 - work by computer scientists that made it
51:08 - easy for you kernigan and Richie knew
51:11 - that garbage collection was difficult so
51:14 - they left it out of the C language and
51:16 - put it into a runtime
51:18 - Library back to chapter zero similarly C
51:22 - offers only straightforward singlethread
51:25 - control flow constructions tests Loops
51:28 - grouping and subprograms but not
51:30 - multi-programming parallel operations
51:33 - synchronization or code routines though
51:36 - the absence of some of these features
51:37 - may seem like a grave deficiency you
51:40 - mean I have to call a function to
51:42 - compare two character strings keeping
51:44 - the language down to modest Dimensions
51:46 - has brought real benefits since C is
51:49 - relatively small it can be described in
51:51 - a small space and learned quickly a
51:54 - compiler for C can be simple and compact
51:56 - compilers are also easily written using
51:59 - current technology one can expect to
52:01 - prepare a compiler for a new machine in
52:03 - a couple of months and to find that 80%
52:06 - of the code of a new compiler is common
52:09 - with existing ones this provides a high
52:11 - degree of language Mobility because the
52:14 - data types and control structures
52:16 - provided by C are supported directly by
52:18 - most existing computers the runtime
52:20 - Library required to implement
52:22 - self-contained programs is Tiny on the
52:25 - pdp1 for example sample it contains only
52:28 - the routines to do 32-bit multiplication
52:30 - and division and to perform sub routine
52:33 - entry and exit sequences of course each
52:36 - implementation provides a comprehensible
52:39 - compatible library of functions to carry
52:41 - out input output string handling and
52:43 - storage allocation operations but since
52:46 - they are only called explicitly they can
52:48 - be avoided if required and they can also
52:50 - be written portably in C itself again
52:54 - because the language reflects the
52:55 - capabilities of current computers C
52:58 - programs tend to be efficient enough
53:00 - that there is no compulsion to write
53:02 - Assembly Language instead the most
53:05 - obvious example of this is the Unix
53:07 - operating system itself which is written
53:09 - almost entirely in C of 13,000 lines of
53:13 - system code only about 800 lines at the
53:16 - very lowest level are an assembler in
53:19 - addition essentially all of the Unix
53:21 - application software is written in C the
53:24 - vast majority of Unix users including
53:27 - one of the authors of this book do not
53:29 - even know the pdp1 Assembly
53:33 - Language I would note that in this
53:35 - preface the authors are carefully
53:37 - explaining the fact that many of the
53:39 - wellestablished programming languages of
53:42 - the 1960s and 1970s like Fortran Cobalt
53:46 - Pascal alol and pl1 were solving many of
53:49 - the use cases that were needed by us
53:51 - programmers by adding syntax to the
53:54 - languages the creators of CN Unix for
53:56 - advocating for a more minimal set of
53:58 - programming language constructs and more
54:00 - Reliance on calling function in provided
54:03 - runtime libraries to meet programmer use
54:06 - cases it may have seemed a strange
54:08 - approach for experienced programmers in
54:10 - the 1980s but over time it has allowed C
54:13 - to expand to meet a very wide range of
54:16 - programmer needs without requiring major
54:19 - revisions to the core language or
54:21 - compiler back to chapter zero although C
54:25 - matches the capability of many computers
54:27 - it is independent of any particular
54:29 - machine architecture and so with a
54:31 - little care it is easy to write portable
54:34 - programs that is programs which can be
54:36 - run without change on a variety of
54:38 - Hardware it is now routine in our
54:41 - environment that software developed on
54:42 - Unix is transported to local Honeywell
54:45 - IBM and inata systems in fact the C
54:48 - compilers and runtime support on these
54:50 - four machines are much more compatible
54:53 - than the supposedly ansy Standard
54:55 - Version of Fortran the Unix operating
54:58 - system itself now runs on both the pdp1
55:01 - and the interdata
55:03 - 832 outside of programs which are
55:06 - necessarily somewhat machine dependent
55:07 - like the compiler assembler and debugger
55:10 - software written in C is identical on
55:12 - both machines within the operating
55:15 - system itself the 7,000 lines of code
55:18 - outside of the Assembly Language support
55:20 - and the io device handlers is about 95%
55:24 - identical as a note note before Unix and
55:27 - C if you were running the vendor
55:29 - operating system and writing in the best
55:31 - language for systems like the pdp11 and
55:33 - in dat 732 the user experience was
55:37 - completely different today we take for
55:39 - granted that we expect to be able to
55:41 - download the same application for
55:43 - Windows Mac OS or a Linux system even in
55:47 - the 1970s those that were using Unix
55:50 - andc could write code once and move it
55:52 - between two Hardware platforms and
55:55 - expect that it would work with no or
55:57 - relatively few
55:59 - changes back to chapter zero for
56:02 - programmers familiar with other language
56:04 - it may prove helpful to mention a few
56:06 - historical Technical and philosophical
56:09 - aspects of C for contrast and
56:11 - comparison many of the most important
56:13 - ideas of C stem from the considerably
56:16 - older but still quite vital language
56:18 - bcpl developed by Martin Richards the
56:21 - influence of bcpl on C proceeded
56:25 - indirectly through the language B which
56:27 - was written by Ken Thompson in 1970 for
56:30 - the first Unix system on the PDP 7
56:33 - although it shares several
56:35 - characteristic features with bcpl C is
56:37 - in no sense a dialect of it bcpl and B
56:41 - are typeless language the only data type
56:44 - is the machine word and access to other
56:47 - kinds of objects is by special operators
56:49 - or function calls in C the fundamental
56:52 - data objects are characters integers of
56:55 - several sizes and floating Point numbers
56:57 - in addition there is a hierarchy of
56:59 - derived data types created with pointers
57:01 - arrays structures unions and functions C
57:06 - provides the fundamental control
57:08 - constructions required for well
57:09 - structured programs statement grouping
57:12 - decision- making with if looping with
57:14 - termination test at the top using for
57:16 - and while or at the bottom using do and
57:19 - selecting one of a set of possible cases
57:22 - switch all of these were provided in
57:24 - bcpl as well though with somewhat
57:27 - different syntax that language
57:29 - anticipated the Vogue for structured
57:31 - programming by several years C provides
57:35 - pointers in the ability to do address
57:36 - arithmetic the arguments to functions
57:38 - are passed by copying the value of an
57:40 - argument and is impossible for the
57:42 - called function to change the actual
57:44 - argument in the caller when it is
57:46 - desired to achieve call by reference a
57:49 - pointer may be passed explicitly and the
57:51 - function may change the object to which
57:53 - the pointer points array names are
57:55 - passed as the location of the array
57:57 - origin so array arguments are
57:59 - effectively called by reference any
58:02 - function can be called recursively and
58:04 - its local variables are typically
58:06 - automatic or created a new with each
58:09 - invocation function definitions may not
58:11 - be nested but variables may be be
58:13 - declared in a block structured fashion
58:16 - the functions of a c program may be
58:18 - compiled separately variables may be
58:21 - internal to a function external but
58:23 - known only within a single source file
58:25 - or complet completely Global internal
58:28 - variables may be automatic or static
58:30 - automatic variables may be placed in
58:32 - registers for increased efficiency but
58:34 - the register declaration is only a hint
58:37 - to the compiler and does not refer to
58:39 - specific machine
58:42 - registers C is not a strongly typed
58:44 - language in the sense of Pascal or algo
58:46 - 68 it is relatively permissive about
58:50 - data conversion although it will not
58:51 - automatically convert data types with
58:53 - the wild abandon of pl1 existing
58:56 - compilers provide no runtime checking of
58:59 - array subscripts or argument types etc
59:02 - for those situations where strong type
59:04 - checking is desirable a separate version
59:06 - of the compiler is used this program is
59:08 - called lint apparently because it picks
59:11 - up bits of fluff from one's program lint
59:14 - does not generate code but instead
59:17 - applies a very strict check as to many
59:20 - aspects of the program as can be
59:22 - verified at compile and load time it
59:24 - detects type mismatches inconsistent
59:28 - argument use unused or apparently
59:30 - uninitialized variables potential
59:33 - portability difficulties and the like
59:35 - programs which pass unscathed through
59:37 - lint enjoy with few exceptions freedom
59:40 - from type errors about as complete as do
59:43 - for example algol 68 programs we will
59:46 - mention other lint capabilities as the
59:49 - occasion arises I would note that
59:52 - separately checking for things that
59:53 - might be wrong into the lint program
59:56 - keeps the C compiler simple and easy to
59:59 - port to a new computer the lint program
60:02 - was naturally a very portable text
60:04 - processing application well there's some
60:07 - overlap between a lint program and a
60:09 - compiler over time there's quite
60:11 - distinct research and expertise in how
60:14 - to lint versus how to compile modern
60:17 - lint programs look at programs in far
60:19 - more detail than most compilers
60:22 - separating concerns of lint and the C
60:24 - compiler also allow ow lint programs to
60:28 - use more memory and take more time to
60:30 - execute than compilers since the typical
60:33 - developer might use the compiler many
60:34 - times per day and run lint less often it
60:37 - was nice for the compiler to run quickly
60:39 - and make light use of Computer Resources
60:42 - we call this idea of building two
60:44 - smaller complimentary programs that each
60:47 - specialize in one task separation of
60:49 - concerns and it is an important
60:51 - principle in computer science by keeping
60:54 - each component simple and focused
60:56 - we can more easily build test and verify
60:59 - each component Unix and C showed the
61:02 - benefits of taking many small components
61:05 - approach to solve an overall set of
61:08 - problems back to chapter zero finally C
61:12 - like any other language has its
61:14 - blemishes some of the operators have the
61:16 - wrong precedence some of the syntax
61:19 - could be better there are several
61:21 - versions of the language extent
61:23 - differing in minor ways nonetheless has
61:26 - proven to be an extremely effective and
61:28 - expressive language for a wide variety
61:30 - of programming
61:32 - applications the rest of this book is
61:34 - organized as follows chapter one is a
61:36 - tutorial introduction to the central
61:38 - part of C the purpose is to get the
61:41 - reader started as quickly as possible
61:43 - since we believe strongly that the only
61:45 - way to learn a new language is to write
61:47 - programs in it this tutorial does assume
61:50 - a working knowledge of the basic
61:52 - elements of programming there is no
61:54 - explanation of computers of compilation
61:57 - nor the meaning of an expression like
61:59 - nals n plus one although we have tried
62:02 - where possible to show useful
62:04 - programming techniques the book is not
62:06 - intended to be a reference work on data
62:08 - structures and algorithms when forced to
62:10 - make a choice we have concentrated on
62:12 - the
62:13 - language chapters 2 through six discuss
62:16 - the various aspects of C in more detail
62:18 - and rather more formally than does
62:20 - chapter 1 although the emphasis is still
62:22 - on working examples of complete useful
62:25 - programs rather than isolated fragments
62:28 - chapter 2 deals with da basic data types
62:30 - operators and expressions and chapter
62:33 - three treats control flow if else while
62:36 - for ETC chapter four covers functions
62:39 - and program structure external variables
62:41 - scope RS and so on chapter five
62:44 - discusses pointers and address
62:46 - arithmetic and chapter six contains the
62:48 - details of structures and unions chapter
62:51 - 7 describes the standard CIO Library
62:54 - which provides a common interface to the
62:56 - operating system this IO library is
62:59 - supported on all machines that support C
63:01 - so programs which use it for input
63:03 - output and other system functions can be
63:06 - moved from one system to another
63:08 - essentially without
63:10 - Change chapter 8 describes the interface
63:13 - between C programs and the Unix
63:16 - operating system concentrating on input
63:18 - output the file system and portability
63:21 - although some of this chapter is UNIX
63:22 - specific programmers who are not using
63:24 - Unix system should still find useful
63:27 - material here including some insight on
63:29 - how one version of the standard library
63:31 - is implemented and suggestions on
63:33 - achieving portable code appendix a
63:36 - contains the C reference manual this is
63:38 - the official statement of the syntax and
63:40 - semantics of c and except for one owns
63:44 - compiler the final Arbiter of any
63:46 - ambiguities and omissions from earlier
63:48 - chapters since C is an evolving language
63:51 - that exists on a variety of systems some
63:53 - of the material in this book may not
63:55 - correspond to the current state of
63:57 - developments for a particular system we
64:00 - have tried to steer clear of such
64:02 - problems and warn of potential
64:04 - difficulties with in doubt however we
64:07 - have chosen generally to describe the
64:09 - pdp11 Unix System since that is the
64:11 - environment of the majority of C
64:13 - programmers appendix a also describes
64:16 - implementation differences on the major
64:18 - C
64:22 - systems this recording of chapter zero
64:24 - of the 1978 C programming book written
64:27 - by Brian kernigan and Dennis Richie is
64:29 - part of my C programming for everybody
64:31 - course where I teach C from a historical
64:34 - perspective my name is Charles sance and
64:37 - I'm the teacher of the
64:38 - [Music]
64:47 - course hello and welcome to C
64:49 - programming for everybody I'm Charles
64:50 - Severance and I'm your professor for
64:52 - this course in this lecture we are going
64:55 - to do a very rapid translation from
64:59 - python to C so as I've shown you in our
65:02 - earlier lecture she C is kind of like
65:05 - the mother tongue of advanced
65:07 - programming languages python itself was
65:09 - written and still is written in C and
65:11 - python is deeply influenced by C even
65:14 - though the syntax looks very different
65:16 - right um and if you've taken all my
65:19 - other classes you will have seen PHP
65:22 - you'll have seen uh JavaScript and to
65:24 - some degree even see SS takes some of
65:27 - its inspiration from uh the syntax of
65:30 - c and so I'm not intending for this to
65:33 - be your first programming class I intend
65:35 - for you to be an expert in Python well
65:37 - not expert but certainly I'm not going
65:39 - to tell you what a if statement is I'm
65:41 - not going to tell you what a variable is
65:43 - I'm going to just tell you how to use
65:44 - variables in C and I'm going to tell you
65:45 - how to use if statements in C and so
65:47 - that's why a solid foundation of python
65:50 - not wizard but solid foundation of
65:51 - python is essential and frankly I would
65:54 - rather that you learned a bit of PHP
65:56 - some JavaScript and all this other stuff
66:00 - before you come I see that c I think a C
66:03 - programming is not the first class that
66:04 - you should take but instead it is your
66:08 - gateway to the advanced work that you're
66:10 - going to do and so I think C is very
66:11 - very important I just don't think it's
66:13 - your first programming
66:14 - class so you might think Python and C
66:18 - are not very different although python
66:21 - is written in C python has Whit space
66:25 - that is part of its syntax c whes space
66:28 - is ignored I I do like C better in that
66:31 - python is very object Orient if you read
66:34 - an article I wrote on quora you'll see I
66:37 - I rank all my languages and I I put
66:39 - Javascript and python is the most object
66:42 - Orient languages Java is a little less
66:44 - objectoriented and C is like the least
66:47 - unob oriented C is not objectoriented at
66:50 - all python has wonderfully convenient
66:54 - data structures in the form of list and
66:55 - dictionaries PHP has arrays and um
67:00 - JavaScript has objects the all beautiful
67:03 - beautiful stuff Fair object R structures
67:05 - Python A C does not it's fast it's
67:08 - efficient it's powerful it's got strs
67:10 - and pointers and by goly you will use
67:13 - them and they're not they're not
67:15 - convenient but they are scorchingly fast
67:18 - and by the time we're done with all this
67:21 - we will see how to use strs and pointers
67:24 - to build lists and dictionaries and that
67:27 - really is we will follow down the path
67:30 - of building python so you'll see a a
67:32 - common three theme throughout this class
67:34 - of how python achieves what it's trying
67:38 - to achieve by writing
67:40 - C python has automatic memory management
67:43 - to the point where if you've been a
67:44 - python programmer a PHP programmer a
67:46 - Java programmer or JavaScript programmer
67:49 - you probably don't even know what memory
67:50 - management is well you're going to by
67:53 - the end of this class and by the end of
67:55 - this class you're going to be able to
67:58 - see how
67:59 - python automates memory management for
68:02 - you right python is written in the 80s
68:04 - and C was written in the 70s in in many
68:06 - ways I see python as a convenience layer
68:10 - that was built on top of C just C
68:14 - programmers look at C it's like it's
68:16 - great it's great it's great if we just
68:18 - had this layer of easiness on top of it
68:21 - then things would be better and so um
68:25 - that's what python is now python also
68:27 - introduced things like quite different
68:29 - syntax to make it uh
68:32 - indentation you know required because
68:35 - they thought it was a good idea so we we
68:37 - could argue one way or the other I mean
68:40 - I I'll tell you when I'm writing a
68:41 - million lines of code I white white
68:44 - space is not to me a good way to have
68:46 - syntax so we're going to look at C
68:48 - through a python lens and we're going to
68:51 - learn by example now most of the time I
68:54 - tell you you
68:57 - um don't copy and paste
69:00 - don't cheat don't look for
69:04 - Solutions this lecture is the exception
69:07 - to that rule I've written this lecture
69:09 - as a Rosetta Stone it's just a little
69:12 - tiny bit of connection to what you
69:14 - already know in Python to what you're
69:16 - going to do in C and so I'm not
69:20 - intending at this point for you to build
69:22 - your own stuff based on reading a book I
69:25 - actually just want you and if I give you
69:27 - assignments to do these particular
69:29 - things I really do want you to just
69:31 - watch this lecture grab the PowerPoint
69:33 - and feel free to cut and paste from my
69:35 - PowerPoint into my assignments because
69:39 - this
69:39 - is I don't know if you've ever seen it
69:42 - where the mama tiger is teaching a baby
69:43 - tiger how to hunt and the mama tiger
69:46 - goes out and gets a something or other
69:48 - and brings it back and puts it near the
69:49 - baby tiger and lets the baby tiger Chase
69:51 - it well that's kind of what I'm doing
69:53 - I'm the mama tiger and I'm giving you
69:55 - some C code and I'm putting it right in
69:57 - front of you and then I want you to take
69:58 - that c code and I want you to run it and
70:00 - play with it and understand it so I'm
70:02 - not expecting in this lecture that
70:04 - you're going to derive it that you're
70:07 - going to sort of somehow read the
70:09 - textbook look at a problem and solve the
70:11 - problem that's later that is that's
70:13 - absolutely later so this is the
70:16 - beginning this is trying to make
70:17 - connections conceptual connections to
70:20 - the complex knowledge you have about
70:22 - python to little places where you can
70:24 - hook things on to in C and so the idea
70:27 - is to go through it quickly
70:31 - so I do assigned some of these as
70:34 - programming exercises it's intended for
70:36 - me my intent is that you'll watch the
70:38 - lectures and just work on the code at
70:40 - the same time I'm not trying to test
70:43 - what you learned I really want you to
70:46 - watch and listen and type that's how we
70:50 - learn right you could cut and paste it
70:52 - or you could type it and you could type
70:54 - it one piece at a time and the mere Act
70:56 - of you typing even though you're just
70:58 - looking at a slide and typing it in at
71:00 - this point in the course that is the
71:03 - learning objective is this lecture now
71:06 - that whole rule of just typing code in
71:08 - that you're looking at some from someone
71:09 - else don't don't do that forever later I
71:13 - want you to do things like synthesize
71:15 - what you learn in the book synthesize it
71:17 - struggle through it and figure things
71:18 - out and do the assignment yourself so
71:20 - don't go searching if you want to gain
71:22 - maximum benefit if you're just in the
71:23 - biggest hurry of all just go ahead and
71:25 - search but please if you want benefit
71:28 - from this class don't cheat
71:30 - yourself there's a lot of similarities
71:33 - that I'm not going to cover you can go
71:34 - read the textbook like the plus minus
71:38 - asterisk slash and percent hey probably
71:41 - when you were learning python you're
71:42 - like whoa what's this percent thing and
71:43 - why did they choose percent the answer
71:45 - is that's what C chose and so modulo is
71:47 - just percent and all these other
71:49 - languages because they flipped a coin in
71:51 - C and decided percent was
71:53 - modulo the comparison operators the
71:56 - assignment operators is equal sign which
71:58 - means that the the equality operators
72:00 - got to be double equals exclamation
72:02 - equals less than greater than less than
72:04 - equal all that stuff's the
72:06 - same variable naming rules the same you
72:08 - start with a letter underscore and then
72:10 - numbers letters and underscores and case
72:12 - matters both languages while Loops the
72:15 - concept of break and continue which you
72:17 - know some people get all worried about I
72:20 - love break and continue if you've taken
72:22 - my other courses and you'll see when we
72:23 - talk about it in see I love breaking
72:25 - continu in
72:26 - c2o maybe because that's I learned C
72:29 - first and I I just love breaking and you
72:32 - okay enough about that I love breaking
72:34 - okay enough about that uh
72:36 - constants uh about the only thing that's
72:39 - really different in constants is like
72:42 - strings and characters and booleans and
72:44 - strings and characters are like the
72:46 - biggest thing in the beginning both have
72:49 - int and float and Char and bite now
72:53 - again bite and string and Char and not
72:55 - the same thing C has no stir class which
72:58 - is the string class list or dictionary
73:01 - and python has no concept of struct or
73:03 - double and in a sense you could think of
73:05 - um Python's float is really sees double
73:08 - right and so by the time python was
73:11 - written the notion of shorter floating
73:14 - Point numbers is less less critical
73:17 - there are some differences a lot of this
73:19 - I think was in the design of python
73:21 - trying to be a little less obtuse and a
73:23 - little more convenient uh for me it's
73:25 - annoying I write the C versions of The
73:28 - Operators like and double Amper sand not
73:31 - is exclamation point we call that bang
73:33 - or double vertical bar and in Python
73:37 - they're all convenient we use the word A
73:39 - and D but okay whatever um so there in C
73:44 - we have a for Loop but it's it's an
73:46 - indeterminant Loop if you remember the
73:48 - definition from python for everybody
73:50 - indetermined Loop is one that you have
73:51 - to examine to see if it's got infinite
73:53 - Loop whereas in the in Python if you say
73:56 - 4X in some list you're going to go
73:59 - through the whole list it's a
74:01 - determinant Loop it only runs until that
74:03 - list is exhausted C does not have such a
74:06 - thing right it just every Loop has got a
74:09 - condition to finish it now we write
74:11 - Loops like 4 I equal 1 to 100 or 0 to 99
74:15 - we write them and you can look at them
74:17 - and say yeah that's not an infinite loop
74:18 - it's just technically you have to look
74:20 - at the Loop to make sure that you
74:22 - haven't
74:23 - inadvertently made it infinit Loop
74:25 - there's no predefined true and false I
74:27 - find this really like wow couldn't they
74:29 - they got eoff capital eof for IND defil
74:32 - Andy none and null are similar Concepts
74:35 - but quite different none in Python is
74:39 - its own
74:40 - type null is the number
74:43 - zero that's cast to be a pointer to
74:46 - nothing and
74:49 - so none is like specially marked empty
74:54 - null is a
74:56 - zero we'll get there we'll get there um
75:00 - strings and character arrays for a while
75:03 - you can kind of pretend that character
75:05 - arays in C are mostly like strings like
75:08 - when you throw a constant and you pass
75:09 - it to a function they kind of look the
75:12 - same but like once we start working with
75:14 - them you'll see they're very very
75:16 - different and that's that's kind of the
75:18 - first fun part of the first part of this
75:20 - class is like strings are now your
75:23 - responsibility there's
75:25 - there's no help right um and C of course
75:29 - has no list or dictionary and python has
75:31 - no concept of like tightly packed data
75:34 - which is what strs are and uh and
75:36 - doubles and floats so here we go let's
75:40 - get started let's see if my pen is
75:41 - working here yeah so what we're going to
75:44 - see is on one side we're going to see
75:45 - some Python and other side we're going
75:47 - to see some C and so this is just
75:49 - talking about output this is Python 3 of
75:52 - course and so we have a print function
75:55 - and it takes any number of parameters
75:57 - one of the things you'll notice about
75:58 - the print function is like hello space
76:00 - World well that's part of this constant
76:03 - but answer comma 42 puts a little space
76:06 - in between answer and 42 and the output
76:08 - so if you want to suppress that kind of
76:11 - automatic addition of spacing you have
76:13 - to maybe concatenate things together or
76:16 - or some other trick um the print
76:19 - statement automatically knows if it's
76:20 - got a string or a float or an integer
76:23 - and it just does things kind of all
76:25 - automatically and so if you want to see
76:26 - something usually you just print it okay
76:30 - so let's take a look at the uh compare
76:32 - and contrast so first off you pretty
76:34 - much you're going to have to start every
76:35 - one of your C programs with pound
76:36 - includes standard i.h comments are
76:42 - different python comments are pound
76:44 - signed to the end of the line uh C
76:46 - comments are SL star across multiple
76:51 - lines to Star slash so everything in
76:52 - between there that can be multiple lines
76:55 - later versions of C also add the What's
76:57 - called the C++ style of comments and
76:59 - JavaScript uses those as comments which
77:01 - is the double slash so when you're
77:04 - writing you probably can use double
77:06 - slash in the C that you're using but I'm
77:08 - kind of being kind of strict and so I'm
77:10 - pretending I'm in 1978 so I'm not using
77:13 - that uh C++ style comment again that
77:17 - came from C++ it didn't come from
77:19 - JavaScript some of you have taken python
77:21 - classes where there's this like uncore
77:23 - uncore Main and it calls this thing and
77:25 - it makes a function and calls it and
77:26 - indents everything one Tab and they're
77:29 - really imitating C in that respect and I
77:32 - think I don't like that style I think
77:35 - those people who do that in Python I'm
77:38 - sure they have a good reason but I think
77:41 - they're just like wishing it was C
77:44 - because the definition of c is code a
77:47 - program starts it when it starts running
77:50 - it searches for a function named Main
77:53 - and later we'll see that this function
77:54 - can actually have arguments and it
77:57 - returns an integer as to the success or
77:59 - failure so really main is a function and
78:02 - so that first line there int main open
78:05 - print Clos print open curly brace that
78:07 - is the definition of a function that
78:10 - happens to be named
78:12 - Main and then we have print
78:15 - F now again if we if you I don't know if
78:18 - you learned python 2 but in Python 2
78:20 - there was a print
78:22 - statement in Python 3 there is a print
78:25 - function and so here we're using a
78:27 - Python 3 print function and um C never
78:32 - did the statement so C decided as we'll
78:35 - talk about later to not have any input
78:39 - output any reading or writing in the
78:42 - language itself but instead put them in
78:44 - standard libraries and that's what this
78:46 - pound includes stdio.h is saying okay
78:49 - I'm going to do some IO here input
78:51 - output here and so include the C input
78:54 - output Library okay and so print F takes
78:58 - as its first parameter a
79:01 - string the other thing you see in C is
79:04 - you can't use single quotes for long
79:06 - strings later we'll see single quotes
79:08 - but in C there's a major difference
79:10 - between single quotes and double quotes
79:13 - single single quotes are single
79:15 - characters and double quotes are a
79:17 - character
79:19 - array not a string character array the
79:22 - other thing is things like the end of
79:24 - line so in Python the new line is added
79:28 - implicitly in C you have to add it
79:31 - explicitly and so that's basically
79:33 - saying print hello world and then go to
79:35 - the beginning of the next line now this
79:38 - first parameter is actually not just a
79:40 - string it's a string with embedded
79:42 - format codes that start with percent
79:46 - percent D says there is a
79:50 - corresponding integer number and I want
79:53 - you to conver convert that into a string
79:56 - and print it out I guess I should
79:58 - probably just re erase some of this so
80:01 - it says answer and then a
80:04 - number and so you can have more than one
80:07 - of these things and then they match so
80:10 - that says there's an integer as another
80:12 - parameter so you can have one parameter
80:15 - two parameters Etc so for Beyond one
80:18 - parameter like in this one X per. onef
80:23 - that corresponds to this first flow
80:24 - voting Point number and this percent D
80:26 - corresponds to the integer one okay so
80:29 - you have these percent things now we
80:32 - will learn that these percent things
80:34 - have um a language unto themselves in
80:37 - chapter 8 and uh this is basically
80:41 - saying please print me a floating Point
80:43 - number with only one digit of precision
80:46 - right so percent. onef says print a
80:50 - floating Point
80:51 - number and then if we want a string it's
80:54 - percent s but this really Sarah here
80:57 - double quote Sarah double quote is a
80:59 - character array and it's
81:02 - actually not five characters but six
81:05 - because there is always a terminating
81:07 - zero character at the end and so percent
81:10 - s says the parameter needs to be a
81:13 - character
81:14 - array and properly terminated by an end
81:17 - of string indicator which is a zero
81:19 - character
81:21 - so so that's this right it's pretty
81:25 - simple but I we got a lot of stuff to
81:27 - cover here and this is the Rosetta Stone
81:31 - it's more complex than C you have you
81:32 - have more control you're doing things
81:34 - the more
81:35 - explicitly um and and it's not doing it
81:38 - for you
81:39 - automatically so let's take a look at a
81:41 - simple number input and you'll see that
81:44 - some of these things come from my uh my
81:48 - python for everybody class this is the
81:49 - famous US floor to European floor um
81:53 - elevator can inverter so we we're going
81:56 - to print something out now one thing
81:59 - about C is that you've got to declare
82:02 - all your
82:03 - variables python is sort of a typeless
82:06 - language it's increasingly getting more
82:08 - typy um but it's but it's a typeless
82:11 - language so we have to declare that
82:14 - we're going to have two variables USF
82:15 - and euf and they're going to be integers
82:17 - we print the statement about the diff
82:20 - only difference there is we have to put
82:21 - the backs slash n in otherwise it won't
82:23 - automatically do that and then we have
82:25 - this IO routine again coming from
82:28 - stdio.h called scanf and its first
82:31 - parameter much like printf is actually a
82:33 - formatting string and what this says is
82:35 - this says read four a lot little ways
82:39 - find me a number as long as it seems
82:41 - like a number keep reading and turn that
82:42 - into an integer and give it back to me
82:44 - and so it actually has got some scanning
82:46 - built into
82:47 - it and it reads until it finds a
82:50 - non-digit and then stops and says that's
82:52 - the number so it turns out in C the way
82:55 - you could type a lot of different things
82:57 - here we won't go into that too much
82:59 - detail we'll hold that until chapter 8
83:01 - but the the idea is it doesn't work
83:03 - exactly the same although this input in
83:06 - Python reads a line now again I got this
83:09 - little note here if you recall if you
83:12 - recall in Python 2 there was an input
83:15 - and a raw input and raw input was what
83:17 - read a line which I tended to use when I
83:19 - was teaching python
83:21 - 2 input was a weird thing that had some
83:24 - kind of scanning thing going on and it
83:26 - scanned and threw stuff away and it
83:28 - grabbed something it might go from to
83:30 - multiple
83:31 - lines and it was totally inconsistent
83:35 - and it was worse than scan F so I was
83:38 - really glad when they just got rid of it
83:40 - in Python 3 and then they changed the
83:43 - name what used to be python 2's raw
83:45 - input became input in Python 3 so the
83:48 - old input from python 2 is kind of like
83:52 - homage to scan F in C but it's not
83:55 - exactly the same and the reason it's not
83:58 - the same
84:01 - is the input in Python 2 was was
84:05 - deriving the type of the data from what
84:07 - it encountered so it might give you back
84:09 - a string it might give you back a
84:10 - floating Point might go like oh that's
84:12 - dangerous right and and that's because
84:14 - the type of USF in Python here is
84:17 - determined it it it you can it's not
84:20 - preclarus
84:25 - and by the way both the input and the
84:28 - scan F we can write stuff that confuses
84:30 - it badly and causes it to blow up but
84:32 - we're not we're not worrying too much
84:33 - about that right now we're just kind of
84:36 - getting the basics done so we have a we
84:38 - read an integer we subtract one we print
84:40 - it out right we read an integer oh I
84:44 - forgot to say this Amper sand call by
84:47 - reference and call by value so in Python
84:51 - this is coming back as a function return
84:52 - so it's really easy to assign it into
84:54 - USF whereas in C we put these parameters
84:59 - on the scan F call and we have to say oh
85:03 - and by the way I want you to change it
85:05 - because ultimately if we don't put
85:07 - Ampersand on it's what's called call by
85:10 - value not call by reference and ampers
85:12 - USF is a way to tell C to actually give
85:16 - it the address of the USF variable
85:19 - rather than the value in the USF
85:22 - variable and in that is a the whole
85:25 - chapter that we will cover like uh I
85:27 - think four and five will be all about
85:29 - the Amper sand and call by reference
85:32 - call by I'm we we're way ahead because I
85:34 - don't think chapters one through four
85:35 - would all they ever do is mention call
85:37 - by reference and then say Oh that's in
85:40 - the future so I'm going to just say oh
85:42 - that's in the future I will tell you
85:44 - that that Amper sand is really important
85:46 - and the code doesn't work without it
85:48 - because it is the way that c does call
85:51 - by reference for simple variables like
85:53 - integers and
85:55 - floats as you're going to see on the
85:57 - next slide there's always an
86:01 - exception string
86:03 - input okay so here we're going to this H
86:05 - my hello Sarah thing right we say enter
86:08 - your name and then we say name input now
86:10 - the beauty is here in Python is input
86:12 - gives us a whole line okay and then we
86:15 - just print hello name and you'll notice
86:17 - that there's like this little space that
86:19 - comes out automatically so switching
86:21 - over to C we have our included the
86:23 - library we have the in main which is the
86:27 - and then we have to precare a character
86:29 - array there is no like make it a string
86:32 - If This Were python we could say hey
86:34 - let's make a string but you can't and
86:37 - what's even more important is you got to
86:39 - tell it how long which means that we
86:42 - could type too much stuff in here and
86:43 - blow our program up and that's one of
86:45 - the difficulties of C is the fact that
86:48 - arrays including character arrays have
86:50 - fixed length then they don't Auto extend
86:52 - there is no Auto there is no DOA pend in
86:56 - C you can't like say oh name DOA pend
86:59 - you can't do it python it's an object
87:02 - it's not an actual array python it's an
87:05 - object name is a string object here name
87:08 - is a character array with 100 elements
87:10 - and if you put 20 in you'll be fine if
87:12 - you put 80 in you'll be fine if you put
87:14 - 101 in it's going to blow up ah well
87:17 - that's okay that's why C is fast we'll
87:21 - get to all that we'll get to all that so
87:23 - we print out a prompt and we say scan F
87:25 - and we say in this case percent s give
87:28 - me a string and you can put a limit on
87:30 - it so we're saying look only read up to
87:32 - a 100 characters and you'll notice there
87:36 - is no Amper sand on name and that is
87:38 - because name is an
87:40 - array and so when you put name in with
87:43 - no square brackets no index operator
87:46 - then you're passing the address of the
87:48 - beginning of the
87:50 - array and so that is in a sense an Amper
87:53 - sand that is the location of the
87:54 - beginning of a 100 character array we're
87:57 - going to scan up to 100 characters into
87:59 - it and so it really is roughly
88:01 - equivalent to the input and then we just
88:04 - again say hello percent s and then name
88:08 - is the corresponding thing and so it
88:10 - says hello Sarah now a lot of what we
88:13 - did in the python for everybody is read
88:15 - whole lines of input and we tended to
88:16 - use string parsing of those lines like
88:19 - we would trim the stuff off the end and
88:20 - then we'd split it and all these things
88:22 - there's there's no good split see so we
88:25 - won't be doing too much of that but it
88:27 - does help to understand how to read a
88:28 - whole line of input so now we're going
88:30 - to read something that doesn't have it
88:32 - it has lots of spaces we're going to
88:33 - read the whole line and we're just going
88:35 - to Echo the whole line right enter line
88:37 - read the Line Print the line so now
88:39 - we're going to have
88:41 - again we have to declare how big of a
88:43 - string we're willing to take Char line
88:46 - with a thousand characters in it the
88:49 - prompt by now should be pretty easy and
88:52 - we have a really weird look
88:56 - percent square bracket carrot back sln
89:00 - close square bracket
89:02 - 1000s
89:04 - well if you took python for everybody
89:07 - and you remember chapter 11 regular
89:09 - Expressions that should look familiar to
89:11 - you open bracket carrot back sln close
89:15 - bracket says match any character that's
89:17 - not a new
89:19 - line so that says scan up to the end of
89:22 - a line
89:24 - or until you hit a th characters that's
89:27 - what percent open square bracket carrot
89:30 - back sln close square bracket 1000s
89:34 - means as the first parameter to scan F
89:37 - read a whole line but stop at 100 stop
89:40 - at a thousand characters and then of
89:42 - course line is just the parameter and
89:44 - then we print that thing out okay and so
89:46 - a lot of C programmers probably never
89:48 - written this particular line of code but
89:51 - it gives you a sense that um there's a
89:53 - lot of of sort of programmability and
89:55 - things like regular Expressions that we
89:58 - you know that python had well those are
90:01 - kind of an old concept those are seven
90:03 - 1970s Concepts this C language had that
90:06 - Concept in it in
90:10 - 1970 there's another way that's a little
90:13 - safer to do this and these are the exact
90:15 - same thing where this command fgs so fgs
90:19 - says put it into the up to a thousand
90:22 - characters looking for a new line and
90:25 - reading from what's called standard
90:26 - input so in C there are three basic
90:29 - files one is the standard input which
90:31 - usually is read through to up to eof
90:33 - standard output which is where print f
90:34 - is going and then there's a thing called
90:36 - standard error which is where you send
90:38 - errror messages that you don't just go
90:40 - want to go to the output so the input
90:42 - and the output like if you're going to
90:43 - make a program to do uppercase you would
90:47 - read your input you would uppercase it
90:50 - and then send it out but if for example
90:53 - um um you encountered a character that
90:55 - you didn't want to copy and you want to
90:57 - send an airor says I'm I'm not going to
90:58 - copy you wouldn't just send it to
90:59 - standard output you actually send it to
91:01 - standard err when you're
91:03 - running um just on a terminal like in
91:06 - your command line standard input is your
91:08 - keyboard standard output is your screen
91:10 - and standard error is your screen so you
91:12 - can see both the error messages and the
91:13 - output of the program but if you're
91:16 - running sort of with redirecting input
91:18 - and output you do tend to still see the
91:20 - error message on your screen and it
91:22 - doesn't end up hidden in some stand
91:23 - standard output but in this case we're
91:27 - using fgs which is part of the standard
91:30 - library and we are saying read this from
91:34 - standard input now you'll see in a
91:35 - second when we read a file fgs can read
91:38 - a file and that third parameter is the
91:40 - file handle but there are three
91:42 - predefined file Handles in C programs
91:45 - standard in standard out and standard
91:47 - err they're all named stdin that's their
91:50 - name their predefined constants in the C
91:54 - the C standard SDI Doh Library okay so
91:58 - now we're going to read a file we do
91:59 - this a lot in Python we go get a file
92:02 - handle it reads it this might fail of
92:04 - course if the file doesn't exist then we
92:06 - got add a a nice determinant Loop
92:08 - remember we talk about iner loops and
92:10 - this for in it's so Python and it's so
92:12 - awesome and it's like so expressive I
92:15 - love it I miss it okay and then uh line.
92:20 - strip which takes the new line off um
92:23 - and so that's going to read you know
92:24 - just reads reads the little file writes
92:26 - it out so we uh we have to create a
92:29 - variable we'll call it a thousand
92:31 - characters we now we are and and in in
92:34 - Python we could have any length of
92:36 - characters in our file and it would work
92:38 - but in C now we're going to have to
92:40 - actually say we can only handle up to a
92:42 - th characters because we've declared the
92:44 - line that we're going to use the line
92:46 - variable we're going to read this in has
92:48 - a
92:49 - thousand there is a equivalent to the
92:51 - handle file is a type it's it's defined
92:54 - in stdio.h starand which means it's a
92:57 - pointer to a file
92:59 - object and a hand equals fopen romeo.
93:03 - text R so that's two character arrays
93:07 - romeo. txt and R and actually the open
93:12 - in Python is inspired by the F open in
93:17 - um in in C and that's because again when
93:20 - they were writing python they were
93:21 - writing it in C why don't we take an
93:23 - open and all the did was made the open
93:25 - in python be a little
93:27 - easier so we don't have any kind of a
93:31 - io4 in so we have to write our own y
93:34 - Loop here so we're going to call F gets
93:37 - line give me up to a th000 characters
93:40 - from the file handle named hand and fgs
93:45 - returns null which is a constant that's
93:47 - defined in
93:48 - stdio.h if it reaches end of file so
93:51 - this basically is a loop that says re
93:53 - everything up till end of file very
93:55 - similar to this four line in hand and
93:58 - then we're printing it now I don't have
94:00 - to strip it because F gets actually
94:02 - takes the new line that is the end of
94:05 - each line so in Python you would get
94:09 - double spacing if you didn't strip the
94:11 - new line at the end of each one of these
94:12 - little things right each line whereas
94:15 - the the F gets is nice enough not to
94:18 - give us a new line so there we go
94:23 - so a counted Loop now this honestly is
94:27 - not one of my favorite things in P in
94:29 - Python but this range is a generator
94:31 - that's going to generate the numbers 0o
94:33 - through four 4 I in range this is
94:35 - effectively kind of a a dynamically
94:38 - generated set and then we're going to
94:40 - print it so we're going 0 1 2 3 4 in C
94:42 - we of course have to declare the I is
94:45 - going to be an INT and the for Loop has
94:47 - three pieces separated by semicolons
94:50 - there's the initialization piece now PHP
94:53 - and JavaScript are the exact same thing
94:55 - so if this looks familiar to you that's
94:57 - because you took those classes
94:59 - congratulations so for I equal Z is the
95:02 - initialization that says before the loop
95:03 - starts set I to zero then there is the
95:06 - middle part is the test whether or not
95:08 - the loop should run or continue to run
95:10 - it's a top tested Loop and so I less
95:13 - than five must be true or The Loop won't
95:15 - run at all but given that I is zero at
95:17 - the beginning it's less than five so
95:19 - it's going to run at least once and then
95:20 - each time through the loop at the bottom
95:22 - after the loop is run we're going to add
95:24 - one to I with a i++ a post increment
95:27 - operator and again that line of code PHP
95:31 - JavaScript Java all look the same except
95:34 - PHP has dollar signs for variable
95:36 - prefixes which yeah bothers me but it is
95:38 - what it is and of course we have a a
95:42 - block curly brace open curly brace and
95:44 - close curly brace denote the block and
95:46 - then we simply print the variable out
95:48 - and both both bits of code produce the
95:51 - exact same output so if we get a little
95:53 - bit trickier we're going to do a uh take
95:57 - an example from my python for everybody
95:59 - class and look at the max and Min and
96:02 - because we need to Prime the loop we're
96:04 - going to set our Max Val to none and the
96:06 - Min Val to none and we're going to do an
96:08 - a middle tested infinite Loop while
96:11 - true we're going to read the input line
96:14 - each line like 5 29 we're going to strip
96:18 - it just because we're going to check to
96:20 - see if it's the string done if it is
96:22 - we're going to break out of the loop
96:24 - right and then we're going to convert it
96:26 - to an integer and we're going to check
96:28 - to see if Max Val is none or the Val
96:31 - value we read is greater than Max Val
96:33 - we're going to reme remember it and if
96:35 - Minal is none or the value we just read
96:37 - is less than minval we're going to
96:38 - remember it and when the loop finally
96:40 - reads all the way through we're going to
96:43 - print out the maximum and the minimum so
96:45 - this is pretty much the same code except
96:47 - we're using scanf with a percent D
96:49 - format input format and scanning into
96:51 - the V integer variable and using
96:54 - Ampersand to indicate that it's called
96:56 - by reference and to replace the current
96:59 - V and then the rest of it the same right
97:01 - if uh if it's the first one or we've got
97:04 - a larger one we keep it if it's the
97:06 - first one or we got a smaller one we
97:07 - keep that one as well we Loop through
97:09 - and it all goes now one thing that if
97:11 - we're using scanf as I mentioned before
97:14 - scanf doesn't sort of stop at the end of
97:17 - lines it keeps on going and so the if I
97:21 - have 5 to and nine and again we have to
97:24 - use contrl D or eof here to to finish
97:26 - this or we have to five space two five
97:29 - Space 9 and then eof it it does the same
97:32 - because scanf is just looking for an
97:34 - integer it start it's really it's
97:37 - algorithm we'll see this in chapter 8
97:38 - but the the thing that it does it's like
97:40 - get me an integer which means throw away
97:42 - stuff that's not an integer so um away
97:45 - you go so that's a slightly more cthonic
97:49 - version of uh this min max using uh scan
97:53 - f and it doesn't suffer from the problem
97:55 - of using uh get us and having to worry
97:58 - about the size of the
98:00 - arrays that's character arrays here's a
98:03 - guessing game it's one of my favorite
98:05 - applications so we have a a infinite
98:07 - Loop the ultimate non-determinate Loop a
98:10 - loop that you got to examine to know
98:12 - that it's going to finish and in this
98:14 - particular one we're just looping to eof
98:16 - you're using try and accept why because
98:19 - line doesn't give you any return
98:20 - indication that it's hit into files so
98:23 - we just have to like have it blow up and
98:25 - then do an accept and then jump
98:27 - out oh well so we throw away the new
98:30 - line and then we convert the line to an
98:33 - integer and we say if guess is 42 nice
98:37 - work and then break which gets out of
98:39 - the loop the break affects the loop not
98:41 - the if and then LF guess less than 42
98:45 - too low else print too high so this is a
98:48 - classic multi-way if where we can have
98:50 - an if you can have kind of as many lfs
98:52 - as you want dot dot dot and then an else
98:55 - we do the same thing in C uh we're going
98:58 - to use the scanf pattern waiting till we
99:00 - uh see eof um if the guess is
99:04 - 42
99:06 - um we print nice work and then break now
99:10 - we have to have curly braces here
99:12 - because that is a two statement block
99:15 - and so if you're having more than one
99:16 - statement you've got to do uh curly
99:20 - braces and then else this else matches
99:23 - up with that if else if guess less than
99:25 - 42 print F now modern programmers would
99:29 - tend to put curly braces even though
99:31 - this is only one line but this print f
99:33 - is the statement connected to the if and
99:36 - it does not need curly braces because
99:38 - what comes after an if is a
99:40 - statement or block of statements with
99:42 - curly braces and the same is true of its
99:45 - else the print f is the single statement
99:47 - so you would You' not seeing curly
99:48 - braces here and I I'm I would write this
99:52 - with curly braces but because the
99:54 - authors of the book are really very
99:56 - succinct they tend to not put curly
99:58 - braces in so I'm calling your attention
100:00 - to
100:02 - that now a really important thing to
100:05 - call your attention to is the difference
100:07 - between else space if and L if now the
100:12 - high level
100:13 - is what we're doing in C is not really a
100:17 - multi-way if what we're doing in Python
100:20 - is truly a multi-way if this if and L if
100:24 - and else are really part of the same
100:26 - block of
100:27 - code but this else if is two keywords
100:32 - and so if you look at the the the first
100:35 - if the first if has one block of
100:38 - code which is the print F nice work and
100:41 - the break and then the else Clause of
100:44 - the first if is this entire block of
100:46 - code here which is if guess less than 42
100:49 - print F yada yada and then another else
100:52 - and so this is a block so this is a
100:55 - block if and in the else Clause there is
100:57 - another block if and so if you look at
101:01 - this really the
101:03 - indentation of this stuff ought to be in
101:06 - in this like the El If part in the else
101:09 - that indentation should be further
101:11 - in now by convention we don't de indent
101:15 - we don't add that indentation even
101:17 - though it's technically correct because
101:18 - this is an else and then there's one
101:20 - statement and that statement is the if
101:22 - okay
101:23 - and so
101:26 - it's we use this idiomatically all the
101:29 - time it looks like a
101:31 - multiway if else if else but it's not
101:35 - it's actually a further and further
101:37 - deeply nested
101:39 - elseif an else with an if inside the
101:42 - else and then another else with an if
101:43 - inside the else we just don't indent it
101:46 - we indent it by Convention as if it were
101:49 - a multi-way
101:51 - if you don't need to know this precisely
101:55 - when you are writing code but I just
101:59 - want to point that out in case like in
102:02 - the back of your mind you're like why
102:04 - does python called LF which is one
102:06 - reserved word and why does c not have an
102:09 - LF but instead has an LF I think when
102:13 - the gido invented python he said look
102:16 - that's a cool convention let's make it
102:19 - actually part of the language rather
102:20 - than a idiomatic use of the language
102:23 - okay enough of that enough of that okay
102:26 - calling by value functions this is
102:28 - pretty easy right there's no defa key
102:31 - word um you have the return value the
102:33 - name of the function and the parameters
102:35 - and then of course before the curly
102:37 - braces you have to have the type of the
102:39 - parameters those are not the type of the
102:40 - variables in the function those are the
102:42 - type of the parameters in Python you
102:44 - don't need to tell it what type they are
102:46 - python is kind of a flexible typeless
102:49 - language the type of a variable goes
102:51 - right along with it any you could be
102:53 - inside my mol and say what kind of a
102:55 - thing is a and then a could be an
102:57 - integer it could be a float it could be
102:59 - whatever could be a string right because
103:01 - that's an object and an object can have
103:03 - a type whereas a is just a number and
103:07 - you have to tell it in C uh that number
103:09 - that's coming in it is an integer and if
103:12 - someone miscalls it in C like put 6.0
103:15 - here it just blows up doesn't work right
103:18 - I mean it might do something it's just
103:21 - unexpected right so there's no
103:23 - cleverness now there might be some
103:25 - checking you might get a compiler
103:27 - warning that says how come it's an
103:29 - integer here and it's a floating Point
103:31 - here that will be dangerous but it won't
103:33 - fix it for you and it doesn't
103:35 - automatically convert it whereas if you
103:37 - did this in Python it would
103:38 - automatically convert so you have a far
103:40 - greater responsibility
103:43 - to match your types up and see uh things
103:47 - like return statement pretty much
103:49 - functions the same it was you know the
103:52 - python return state statement is an
103:53 - imitation of the C return statement you
103:55 - do have to declare your variable types
103:57 - that are going to be used temporary
103:59 - inside the function scope wise right
104:02 - this C is not outside we will see later
104:05 - when we get to the functions chapter
104:07 - about external values and static values
104:09 - Etc but the default scoping is that any
104:12 - variable that you declare inside of a
104:13 - function only lives inside the function
104:16 - there is no a b or c in the main code
104:19 - any and that's the same as how python
104:22 - works
104:24 - that's a lot of Rosetta Stone we talked
104:28 - about input output we talked about
104:29 - looping we talked about reading a file
104:31 - we've talked about strings which are
104:32 - really character arrays we've talked
104:34 - about um float and later later later
104:38 - later later we're going to learn a lot
104:40 - and chapters five and six are the crazy
104:43 - chapters but we're going to play with
104:45 - how would P how would we Implement some
104:47 - of the things that python strings lists
104:50 - and dictionaries handle and before this
104:52 - course is is over we're going to come
104:55 - back and get inside the mind of what it
104:59 - would take to build python using the C
105:02 - language so we'll see how Alec
105:06 - structures pointers Etc character Rays
105:10 - can be used to build string object list
105:14 - object and dict object and that to me is
105:16 - the learning objective of this course is
105:18 - not so
105:19 - much how to code C because it's your job
105:23 - but what in C is necessary to make a
105:26 - higher level language like python or
105:28 - JavaScript or Java or C work and we'll
105:32 - get to that before the end of the course
105:34 - it is a long course um and again this
105:39 - was a long
105:40 - lecture this takes some time to absorb
105:44 - and and just zooming through
105:47 - this you you you achieve nothing if you
105:51 - just do the homework without
105:52 - understanding so take your time I put
105:55 - the lines in this lecture the lines of
105:57 - code are there very much on purpose
106:00 - every single one is trying to teach
106:02 - something so I hope you'll take the time
106:04 - to learn all this material
106:08 - [Music]
106:18 - cheers hello and welcome to chapter one
106:22 - of K en Richie my name is Charles Sant
106:24 - and of course I'm your professor for
106:26 - this course that's about history so
106:29 - welcome to this course it's really part
106:32 - of a learning path um I don't think that
106:36 - c should be your first programming Lang
106:38 - language and I don't think it should be
106:39 - your last programming language I have a
106:41 - whole series of courses that are all
106:43 - free and available online both just on
106:45 - the web on places like free code camp
106:47 - and corera and at X and the place that
106:50 - you're at in my learning path is a
106:53 - uh that you're at right now is C
106:54 - programming and we're not learning C
106:57 - programming to learn C programming we're
106:59 - learning C programming to take a
107:01 - historical look at how computers work
107:04 - and lead into uh computer architecture
107:07 - I'm not trying to teach you coding in C
107:09 - but I am going to explain how computers
107:11 - work and things like how Java Works
107:14 - using C as kind of like the it just
107:18 - gives me a way to explain Java to you so
107:21 - the outline of the textbook is a kind
107:24 - pretty typical computer science textbook
107:26 - where it uh it starts off easy and then
107:29 - whoo everything goes pretty crazy so
107:31 - chapters 1 through 4 and we're on
107:34 - chapter one right now is mostly syntax
107:36 - and it's just another programming
107:38 - language and especially if you've know a
107:40 - little bit of Java or a little little
107:42 - bit of PHP or a little bit of JavaScript
107:44 - some of that syntax is going to be like
107:46 - whoa of course this is familiar and the
107:47 - answer is well that's because all those
107:49 - languages came from C so it's kind of
107:51 - feels like just another programming
107:53 - language except that arrays are not
107:56 - lists and character arrays are not
107:59 - strings and character arrays kind of
108:02 - look like strings but they don't work
108:04 - like strings and you can get in all
108:05 - kinds of trouble but other than that
108:07 - once you sort of stop worrying about how
108:10 - long things are pretend it's okay which
108:14 - is dangerous of course when you write
108:15 - code chapters 1 through 4 feel a lot
108:18 - like you're just any other programming
108:19 - language but then chapters 5 and six are
108:21 - the valuable chap chter of this book but
108:24 - they also become a lot more difficult so
108:26 - don't don't give chapters 1 through 4
108:28 - short shrift because five and six are
108:30 - going to just go woo um and then seven
108:33 - and eight is just sort of filling in
108:34 - detail and seven and eight are not so
108:37 - critical um you know it just kind of
108:40 - fills in all the gaps so that's that's
108:43 - the outline of the book just expect that
108:45 - 1 through four is going to be smooth and
108:47 - then five and six are going to be like
108:49 - now we're really getting somewhere okay
108:51 - so looking at chapter one one again
108:53 - chapters sections 1 through 15 looks not
108:56 - that different than any other
108:57 - programming language that you've learned
108:59 - it's chapter one section 1.6 is
109:02 - arrays static allocation arrays you you
109:06 - have to know how big they are when you
109:08 - declare them and you can't resize them
109:10 - until chapter 5 at which point we'll
109:12 - start talking about dynamic memory and
109:13 - pointers and resizing chapter 1.7 and
109:17 - 1.8 functions and parameters and it's
109:19 - all called by value in this early phase
109:22 - called by by reference is in chapter 5
109:25 - because we need to know about pointers
109:26 - before that we talked about chapter 5
109:28 - even though they use a little pointer
109:29 - syntax here and there in chapter one and
109:32 - section 1.9 is character Rays read this
109:35 - one closely because there is no string
109:38 - object in C there's no objects at all in
109:40 - C and in section 1.10 they talk about
109:44 - variable scoping between functions and
109:45 - that feels kind of similar to to other
109:48 - languages and part of it is because
109:49 - other languages took their inspiration
109:51 - from C
109:53 - so if we just take a quick look at C
109:55 - character arrays we must understand that
109:57 - the size of the character array is at
110:01 - allocation time and there is nothing
110:03 - Auto extended and if you write a for
110:04 - Loop that goes off the end of the loop
110:07 - like I've got where you know I have a
110:09 - character array that's 10 long and I
110:11 - write a loop That's goes up to a
110:12 - thousand storing data in it eventually
110:15 - the program will blow up and you can see
110:17 - like I mean in Python you just make you
110:20 - just add characters whereas in C if you
110:22 - add characters beyond what where is
110:24 - allocated the system blows up and you
110:28 - probably heard me say more than once
110:30 - that the C language is probably
110:32 - responsible for 90% of the security hole
110:35 - significant security holes in all of
110:37 - computing and this kind of code where
110:39 - you allocate an array and then you
110:41 - wildly go beyond it ends up making it so
110:44 - that people can inject things into
110:46 - operating systems and routers and all
110:49 - kinds of things so this is why we don't
110:51 - use C to to write programs I mean here
110:53 - we are in the first page the example one
110:55 - of chapter one is why we don't write C
110:59 - very often or if we do we have to be
111:01 - really careful at reviewing it and
111:03 - making sure that it's right it's really
111:04 - fast but it's also
111:06 - dangerous uh string constants and
111:09 - character
111:11 - constants strings and characters in most
111:14 - languages Java is a little different but
111:16 - PHP Python and JavaScript treat single
111:18 - and double quotes roughly the same and
111:20 - they create string constants and that's
111:22 - a multicar thing that has a
111:26 - length C doesn't have a multi character
111:28 - thing has a length it has an array of
111:30 - characters that has a zero character at
111:32 - the end of it in C single quotes are a
111:35 - single character and double quotes are a
111:37 - character array so a
111:41 - single a double quote with one character
111:44 - in it is actually two bytes because it's
111:47 - the character and the string ending
111:50 - whereas in Python A String has a length
111:52 - it doesn't really have an ending
111:54 - character there's a special character
111:55 - that we use for an ending in c a
111:58 - character is a bite which is a short
112:00 - integer usually eight bits in in in most
112:03 - computers and so we you got to be real
112:07 - careful you you got double quote things
112:08 - and single quote things and single quote
112:11 - things in in C are far more like
112:14 - integers and far less like strings and
112:17 - so in in in Python you just use them
112:21 - interchangeably single quotes and double
112:24 - quotes character sets the Char in C is
112:29 - like a number it's a tiny number it's
112:32 - eight bits long so you can go from 0 to
112:35 - 255 and the character representations
112:37 - depend on the character set but quite
112:40 - often they're asky and so you can just
112:43 - go look up at an asky chart and figure
112:45 - out what the numeric representation of
112:48 - the letter a is and in Python we can
112:51 - actually see the ordinal position of a
112:54 - by using the or function but that's the
112:57 - or function of a single character string
112:59 - which pulls the ORD of the very first
113:00 - character and we find it it's 65 and if
113:03 - you look up in the asky chart it's 65
113:05 - but in python python 3 Python 3 are
113:10 - multi-te characters that represent
113:12 - Unicode and unicode is much larger than
113:15 - 8 Bits I think Unicode is 32 bits uh
113:18 - utf8 is a way to represent Unicode and
113:22 - unicode is a 32bit character set and so
113:24 - if you say what is the character the
113:27 - integer equivalent of the character
113:29 - Smiley phase you see that it's
113:32 - 128,50 122 and that's in a space of
113:36 - 32bit it's a 32-bit integer and that's
113:39 - the character Point within that 32-bit
113:41 - integer that represents smiley face in C
113:45 - there is no smiley face you can't
113:47 - represent well unless you put a bunch of
113:49 - libraries into it but the normal out of-
113:51 - the box seed can't can't represent a
113:53 - smiley face it can represent an
113:55 - uppercase a and you can say what is the
113:58 - A and you'll notice we're printing it
114:00 - out with a percent c and a percent D and
114:03 - and it's the same thing if you print a a
114:05 - a a character out as a a character it's
114:08 - an A and if you print it out as an
114:10 - integer it's an a we don't even need an
114:11 - Ord function because character constants
114:15 - are really integer constants in the asy
114:18 - character set okay
114:22 - just understand that every time you see
114:24 - single quote a single quote think of it
114:27 - as an integer as a number that happens
114:30 - to be conveniently looked up for you by
114:32 - the C
114:33 - compiler and you can take a look at the
114:35 - asy character set and you can go look at
114:37 - uppercase a and you see that its decimal
114:40 - equivalent is 65 you also see in this
114:42 - table that its heximal is 41 and its
114:45 - octal is
114:47 - one1 and it's it's binary its actual
114:50 - bits are one bunch of zeros and a one
114:54 - now the reason we like octal and and hex
114:57 - as programmers is it's easier to convert
114:59 - directly one without having converting
115:03 - from decimal requires like divisions and
115:04 - modulo and stuff like that um but
115:07 - converting from octal or hex to Binary
115:10 - is Direct on a on a digit by digit basis
115:13 - so I can convert an octal digit to a
115:16 - binary set of binary digits just by
115:20 - looking at each digit in succession so
115:22 - when we're printing out and we want to
115:23 - be able to understand what the raw bit
115:25 - pattern is of some data we tend to print
115:27 - it out in HEX or in octal so that we can
115:30 - quickly figure out what bits are set
115:32 - inside that uh
115:34 - value strings in C are not strings they
115:38 - are arrays of characters and there is no
115:41 - length so you can ask python what the
115:44 - length of a string is and the string
115:46 - knows its length but in C that you can
115:49 - ask what the length of a string is but
115:51 - it turns into a for Loop that scans
115:52 - until it finds the end of the string and
115:55 - the end of the string is a special
115:56 - character which is quote back sl0 quote
116:01 - which is zero I mean it's literally the
116:03 - integer zero so you have characters that
116:05 - are nonzero and then you have a zero
116:06 - character and the length is how many
116:08 - characters are in this array up to the
116:10 - end now that is different than the
116:13 - allocation so you can have in this case
116:16 - I have a an example of a six character
116:20 - array and I put six things in it it's
116:23 - all full I could have terminated it like
116:25 - you notice I say x sub3 equal 0 it's no
116:31 - it still got six characters in the array
116:33 - but now the end of the string in that
116:35 - array or the end of the character
116:37 - sequence in that array has a zero at
116:39 - position sub three and of course array
116:41 - start at zero so you see the first three
116:43 - characters and the third one is an end
116:45 - and that that stops IT to print out and
116:48 - so you got to you got to a allocate for
116:50 - the end of the character string and you
116:53 - you be you've got to have it there if
116:55 - just because it goes up to six if you
116:58 - don't have the end of the string it's
116:59 - going to go off and and and R randomly
117:02 - go through memory until it blows up
117:07 - probably right and so strings must be
117:11 - terminated if you append something to a
117:13 - string first you have to have enough
117:15 - space in that string if you pen
117:17 - something to a character aray you have
117:18 - to have enough space and then if you
117:20 - overwrite the end of the string you got
117:22 - to add another little Mark to say now
117:24 - the end of the string has been moved so
117:27 - terminating a string is a thing that you
117:29 - always got to think about both when
117:30 - you're scanning through a string and
117:32 - when you're creating a new
117:34 - string like I said the C string length
117:37 - is only computable by a loop that scans
117:39 - for a zero character so there's a
117:41 - sterland function in string.h that
117:43 - computes the string but it's very very
117:47 - different than the Len function in
117:49 - Python Len function in Python X is an
117:53 - object and length is an attribute of
117:55 - that object whereas in C there is an
117:58 - array and it has a length and it has a
118:00 - zero position but to ask how long is it
118:03 - you've got to actually Loop through all
118:05 - the characters looking for the zero
118:07 - marker so you kind of can find a length
118:11 - of a character a length of a string the
118:14 - length of a quote unquote string in C
118:17 - but you got to write a for Loop to do it
118:18 - you don't have to write a for Loop
118:19 - because python just knows the length
118:21 - later we'll bring all these things
118:23 - together much
118:25 - later so one of your assignments
118:29 - exercise
118:30 - one7 is reversing a string in
118:34 - C without requiring any information an
118:38 - extra string you can't you have a string
118:40 - it's got a certain amount of space and
118:42 - you've got to just flip you got to swap
118:45 - the characters you're going to probably
118:47 - have to draw a picture to do that it is
118:49 - exercise 117 and I'm going to tell you
118:52 - do not cheat there are probably a
118:55 - million Solutions out there on the
118:56 - internet chat GPT will tell you how to
118:59 - do it don't be
119:02 - tempted as you do this you will get
119:06 - there I show you a blurred out version
119:09 - of it it's not all that much code so
119:13 - don't shortcut this don't just the
119:16 - solution getting the solution to this
119:18 - assignment without actually doing it is
119:21 - the meanest thing you'll ever do to
119:23 - yourself you have to do the reversal in
119:26 - place it's a classic interview question
119:29 - at the interview you don't get to go to
119:31 - chat
119:32 - GPT you got to think about even length
119:35 - strings odd length strings empty strings
119:38 - and Single Character strings you're
119:40 - going to have to draw some pictures take
119:42 - your time enjoy this assignment
119:46 - seriously it's not that big and when you
119:49 - get it done you can be very very proud
119:51 - of yourself that you you really thought
119:53 - through the low-level storage of what an
119:56 - array of characters with an ending
119:58 - marker is working with and so that's why
120:01 - it's such a good interview question so
120:04 - there we go that's kind of my callouts
120:07 - from chapter one give you a sense of
120:09 - overall sense of the book see character
120:11 - arrays and encouraging you to actually
120:14 - do your homework even though there's a
120:16 - million ways to get it done for you
120:18 - cheers
120:25 - [Music]
120:30 - welcome to C programming for everybody
120:33 - my name is Charles sance and this is my
120:36 - reading of the 1978 C programming book
120:38 - written by Brian kernigan and Dennis
120:40 - Richie at times I add my own
120:42 - interpretation of the material from a
120:44 - historical
120:46 - perspective chapter 1 a tutorial
120:49 - introduction let us begin with a quick
120:51 - ruction to see our aim is to show the
120:54 - Essential Elements of the language in
120:55 - real programs but without getting bogged
120:58 - down in details formal rules and
121:01 - exceptions at this point we are not
121:03 - trying to be complete or even precise we
121:06 - want you to get as quickly as possible
121:09 - to the point where you can write useful
121:11 - programs and to do that we have to
121:13 - concentrate on the basics variables and
121:16 - constants arithmetic control flow
121:18 - functions and the rudiments of input and
121:20 - output we are quite intentionally
121:23 - leaving out of this chapter features of
121:25 - C which are of vital importance for
121:28 - writing bigger programs these include
121:30 - pointers structures and most of se's
121:34 - Rich set of operators several control
121:36 - flow statements and a myriad of
121:39 - details this approach has its drawbacks
121:42 - of course most notable is that the
121:45 - complete story on any particular
121:46 - language feature is not found in a
121:48 - single place the tutorial by being brief
121:52 - may also mislead and because they cannot
121:55 - use the full power of C the examples are
121:57 - not as concise and elegant as they might
122:00 - be we have tried to minimize these
122:02 - effects but be warned another drawback
122:06 - is that later chapters will necessarily
122:07 - repeat some of this chapter in any case
122:11 - experienced programmers should be able
122:12 - to extrapolate from the material in this
122:14 - chapter to their own programming needs
122:17 - beginners should supplement it by
122:19 - writing small similar programs of Their
122:21 - Own both groups can use it as a
122:23 - framework on which to hang the more
122:25 - detailed descriptions that begin in
122:27 - Chapter 2 1.1 getting
122:31 - started the only way to learn a new
122:33 - programming language is by writing
122:35 - programs in it the first program to
122:37 - write is the same for all languages
122:40 - print the words hello world this is the
122:44 - basic hurdle to leap over it you have to
122:46 - be able to create the program text
122:48 - somewhere compile it successfully load
122:51 - it it run it and find out where your
122:54 - output went with these mechanical
122:57 - details mastered everything else is
123:00 - comparatively easy in traditional C the
123:04 - program to PR print hello world is main
123:08 - open parentheses close parentheses open
123:11 - curly brace print F parentheses double
123:14 - quote hello comma space world back sln
123:18 - double quote close parentheses semicolon
123:22 - close curly brace the modern minimal
123:25 - version of this program needs a bit more
123:27 - syntax we add a single line at the
123:30 - beginning hashtag include space left
123:35 - angle brackets
123:37 - stdio.h right angle bracket P include
123:42 - stdio.h we have to add that line for the
123:44 - modern
123:45 - program back to the book just how to run
123:49 - this program depends on the system that
123:51 - you're using
123:52 - as a specific example on the Unix
123:55 - operating system you must create the
123:57 - source program in a file whose name ends
123:59 - in C such as
124:02 - hello.c and then you compile it with the
124:04 - command
124:06 - CC space
124:08 - hello.c if you haven't botched anything
124:11 - such as omitting a character or
124:13 - misspelling something the compilation
124:15 - will proceed silently and make an
124:17 - executable file called
124:19 - a.out running that by the command a.out
124:23 - will produce hello comma world as its
124:26 - output on other systems the rules will
124:29 - be different check with a local
124:32 - expert on Modern systems we use the GCC
124:36 - compiler with the dash ANC option to
124:38 - accept the Legacy syntax of C so we use
124:43 - GCC space minus an space
124:47 - hello.c and to run the resulting a.out
124:50 - file you usually you need to prepend the
124:53 - local directory because most shell
124:55 - configurations do not include the
124:57 - current path in the paths to search for
124:59 - applications so you need to write SL
125:05 - a.out now for some explanations about
125:08 - the program itself a c program whatever
125:11 - its size consists of one or more
125:14 - functions which specify the actual
125:16 - Computing operations that are to be
125:19 - done C functions are similar to
125:21 - functions and subroutines of a Fortran
125:23 - program or the procedures of pl1 Pascal
125:27 - Etc in our example Maine is such a
125:31 - function normally you are at Liberty
125:33 - give functions whatever names you like
125:35 - but Maine is a special name your program
125:38 - begins executing at the beginning of
125:40 - main this means every program must have
125:43 - a main somewhere main will usually
125:46 - invoke other functions to perform its
125:48 - job some coming from the same program
125:52 - and others from libraries of previously
125:55 - written
125:56 - functions one method of communicating
125:58 - data between functions is by arguments
126:01 - the parentheses following the function
126:04 - name surround the argument list here
126:07 - main is a function of no arguments
126:10 - indicated by open parentheses closed
126:12 - parentheses the curly braces enclose the
126:16 - statements that make up the function
126:18 - they're analogous to the due end of pl1
126:21 - or the begin end of alol or Pascal and
126:24 - so
126:25 - on a function is invoked by naming it
126:28 - followed by a parenthesized list of
126:31 - arguments there is no call statement as
126:34 - there is in foran or pl1 the parentheses
126:37 - must be present even if there are no
126:41 - arguments in the above text the authors
126:43 - were making connections to the popular
126:45 - general purpose programming languages of
126:47 - the time when the book was written it
126:50 - was not all a ured that c and C- like
126:53 - languages would ever evolve past writing
126:55 - high performance applications like
126:58 - operating system kernels and device
127:00 - drivers by comparing C to these more
127:03 - general purpose languages the authors
127:05 - are trying to plant the seed that c
127:08 - could have value as a general purpose
127:10 - language back to the text the line that
127:14 - says print F parentheses double quot
127:17 - hello commas space world back slash and
127:20 - double quot close parentheses semicolon
127:23 - is a function call which calls a
127:26 - function named print f with the argument
127:29 - hello world print f is a library
127:32 - function which prints the output to the
127:34 - terminal unless some other destination
127:36 - is specified in this case it prints the
127:39 - string of characters that make up its
127:42 - argument any sequence of any number of
127:45 - characters enclosed in double quotes is
127:47 - called a character string or string
127:49 - constant
127:51 - for the moment our only use of the
127:53 - character strings will be as arguments
127:55 - to print F and other
127:57 - functions the sequence back sln in the
128:01 - string is C notation for the new line
128:03 - character which when printed advances
128:06 - the terminal to the left margin on the
128:08 - next line if you leave out the back
128:11 - slash n a worthwhile experiment by the
128:14 - way you will find that your output is
128:16 - not terminated by a line feed the only
128:19 - way to get a new line character into the
128:20 - print f argument is with back
128:24 - sln if you try to break it into two
128:26 - lines like print F quote hello world and
128:30 - then just hit the return double
128:33 - quote close parentheses semicolon on a
128:37 - new line the C compiler will print out
128:39 - unfriendly Diagnostics about missing
128:42 - quotes printf never supplies a new line
128:44 - automatically so multiple calls can be
128:47 - used to build up an output line in
128:49 - stages our first program could have just
128:52 - as well been written as main open
128:55 - parentheses Clos parentheses open curly
128:57 - brace prf quote hello quote
129:02 - semicolon print F quote World quote
129:05 - semicolon print F back slash n semicolon
129:09 - and then on a sixth line Clos curly
129:12 - braids and it would have produce the
129:14 - identical
129:15 - output note that back sln represents
129:18 - only a single character an Escape SE
129:21 - sequence like back sln provides a
129:23 - general and extensible mechanism for
129:26 - representing hardto get or invisible
129:29 - characters among the others that c
129:31 - provides are back SLT for tab back SLB
129:35 - for backspace back SL double quote for
129:37 - double quote and back slashback slash
129:40 - for the backs slash
129:42 - itself
129:44 - 1.2 page8 variables and arithmetic the
129:48 - next program prints the following table
129:50 - of fair fhe temperatures and their
129:52 - Centigrade or Celsius equivalents using
129:55 - the formula c equal parentheses 5 / 9
129:59 - Clos parentheses parentheses Fus
130:03 - 32 the table contains Fahrenheit of 0
130:06 - Celsius of -7.8 Fahrenheit of 20 Celsius
130:11 - of -6.7 Fahrenheit of 40 Celsius of 4.4
130:16 - and so forth here is the program itself
130:20 - for reference this this program is on
130:22 - page 29 of the
130:26 - textbook so it starts with pound include
130:29 - stdio.h to include the standard library
130:32 - then it has a comment it says print the
130:34 - Fahrenheit Celsius table for f equals 0
130:37 - comma 20 comma dot dot dot comma
130:40 - 300 close
130:43 - comment main open parentheses close
130:46 - parentheses open curly brace int lower
130:50 - comma upper comma step semicolon float
130:54 - far comma
130:56 - Celsius lower equals z semicolon
131:00 - followed by a comment upper equals 300
131:04 - semicolon followed by a comment step
131:07 - equals 20 semicolon followed by a
131:10 - comment far equals
131:13 - lower then while open parentheses far
131:17 - less than or equal upper close
131:20 - parentheses open curly brace Celsius
131:23 - equals parentheses
131:26 - 5.0 9.0 Clos parentheses
131:30 - asterisk open parentheses far minus
131:34 - 32.0 closed parentheses
131:38 - semicolon then a print F statement print
131:41 - F open parentheses double quote percent
131:46 - 4.0 f space percent 6.1 f back slash n
131:52 - close quote comma far comma Celsius
131:56 - close parentheses
131:59 - semicolon far equals far plus
132:03 - step and then a closing curly brace to
132:06 - finish the while statement and then a
132:08 - closing curly brace to finish the main
132:11 - statement the first two lines slash star
132:15 - print Fahrenheit to Celsius table for
132:18 - FAL 0 comma 20 dot dot dot 3
132:21 - 100 star slash are a comment which in
132:26 - this case explains briefly what the
132:28 - program does any characters between
132:30 - slashstar and star slash are ignored by
132:33 - the compiler they may be used to freely
132:36 - make the program easier to understand
132:39 - comments may appear anywhere a blank or
132:41 - new line can in C all variables must be
132:46 - declared before use usually at the
132:48 - beginning of a function before any
132:51 - executable statements if you forget a
132:53 - declaration you will get a diagnostic
132:55 - from the compiler a declaration consider
132:58 - consists of a type and a list of
133:01 - variables that have that type as in int
133:04 - lower comma upper comma step
133:07 - semicolon float far comma Celsius
133:12 - semicolon the type int implies that the
133:15 - variables listed are integers float
133:18 - stands for floating Point I.E numbers
133:21 - which may have a fractional part
133:23 - Precision of both int and Float depends
133:26 - on the particular machine that you are
133:28 - using on the pdp1 for instance an INT is
133:31 - a 16bit signed number that is one that
133:35 - lies between negative
133:38 - 32,768 and positive
133:42 - 32,767 a float number is a 32bit
133:45 - quantity which amounts to about seven
133:48 - significant digits with a magnitude of
133:50 - about 10 Theus 38 and 10 + 38 chapter 2
133:57 - lists the
133:58 - sizes for other
134:00 - machines I would note that the 1970s was
134:04 - a time of transition in the amount of
134:06 - memory installed in computers the C
134:08 - language int type was 16 bits in the
134:11 - older but more generally available
134:13 - computers like the
134:15 - pdp1 C could be used to write programs
134:18 - like the Unix operating system that made
134:20 - efficient use of available memory in
134:22 - particular the 1978 version of C did not
134:26 - require that Computers support 32bit
134:29 - integers but
134:31 - 32,768 is a pretty small number the size
134:34 - of an integer affected the maximum size
134:37 - of arrays and strings a lot of early C
134:40 - programs use the long type to get at
134:42 - least a 32-bit integer capable of
134:44 - representing numbers up to about 2
134:47 - billion in modern modern computers and
134:50 - database we tend to choose between 32bit
134:53 - and 64-bit integers back to the text C
134:57 - provides several other basic data types
134:59 - besides int and Float Char is a
135:03 - character a single bite short is a short
135:06 - integer long is a long integer and
135:09 - double is a double Precision floating
135:12 - Point size of these objects are also
135:15 - machine dependent and details are in
135:17 - Chapter 2 there are also arrays
135:20 - structures and unions of these basic
135:22 - types and pointers to them and functions
135:24 - that return them all of which we will
135:26 - meet in due
135:28 - course the actual computation in our
135:31 - temperature conversion program begins
135:32 - with the assignments lower equals z
135:35 - upper equals 300 step equals 20 far
135:40 - equals lower all ending with
135:43 - semicolon these set the variables to
135:45 - their starting VAR values individual
135:47 - statements are terminated by semicolons
135:51 - each line of the table is computed in
135:53 - the same way so we use a loop which
135:56 - repeats once per line This is the
135:58 - purpose of the while
136:00 - statement while parentheses far less
136:03 - than or equal upper closed parentheses
136:06 - open curly brace then the body of the
136:08 - loop and then close curly
136:10 - brace the condition in the parenthesis
136:13 - is tested if it is true I.E far is less
136:17 - than or equal to Upper the body of the
136:18 - loop all of the statements included
136:21 - between the open curly brace and the
136:23 - closed curly brace are
136:25 - executed then the condition is retested
136:28 - if true the body's executed again when
136:31 - the test becomes false I.E far exceeds
136:34 - upper the loop ends and execution
136:37 - continues at the statement that follows
136:38 - the loop there are no further statements
136:41 - in the program so it
136:43 - terminates the body of a while loop can
136:46 - be one or more statements enclosed in
136:48 - braces as the temperature converter or a
136:51 - single statement without braces as in
136:54 - while open parentheses I less than J
136:57 - closed parentheses I = 2 * I
137:01 - semicolon in either case the statements
137:04 - controlled by the while are indented by
137:07 - one tab stop so you can see at a glance
137:10 - what statements are inside the
137:12 - loop the indentation emphasizes The
137:15 - Logical structure of the program
137:17 - although C is quite permissive about
137:19 - statement positioning proper indentation
137:22 - and the use of Whit space are critical
137:24 - in making programs easy for people to
137:27 - read we recommend writing only one
137:30 - statement per line and usually leaving
137:32 - blanks around operators the position of
137:35 - the braces is less important we have
137:37 - chosen one of the several popular Styles
137:41 - pick a style that suits you and then use
137:43 - it
137:45 - consistently I would add that with these
137:48 - words the authors triggered a great
137:50 - debate about how to best indent code and
137:53 - use curly braces that continues to this
137:56 - day the indentation style used in this
137:59 - book is often referred to as the k&r
138:02 - style it tends to put open braces at the
138:05 - end of statements like if and while to
138:07 - keep code more compact in terms of the
138:09 - number of lines of code the best advice
138:11 - is not to debate at all when you modify
138:15 - someone else's code just imitate the
138:17 - style that they used when they wrote
138:19 - their code
138:22 - back to the
138:24 - text most of the work gets done in the
138:27 - body of the loop the Celsius temperature
138:30 - is computed and assigned to the Celsius
138:32 - variable by the statement Celsius equals
138:35 - open parentheses 5.0 SL 9.0 closed
138:39 - parentheses asteris open parentheses far
138:44 - minus 32.0 closed parentheses semicolon
138:48 - the reason for using 5.0
138:51 - 9.0 instead of the simpler looking 59 is
138:54 - that in C as in many other languages
138:57 - integer division truncates so that any
139:00 - fractional part is discarded thus
139:04 - 59 is zero and of course so would then
139:08 - all the temperatures be zero a decimal
139:11 - point in a constant indicates that it is
139:13 - floating point so that 5.0 over 9.0 is
139:19 - 0.555 5 repeating which is what we want
139:23 - we also wrote 32.0 instead of 32 even
139:28 - though since far is a float 32 would
139:31 - automatically be converted to float
139:33 - before the
139:34 - subtraction but as a matter of style
139:36 - it's wise to write floating Point
139:37 - constants with explicit decimal points
139:40 - even when they have integral values it
139:43 - emphasizes their floating Point nature
139:45 - for human readers and ensures the
139:47 - compiler will see things the way you do
139:49 - as well
139:51 - I would note that for those of you
139:53 - familiar with python before Python 3
139:56 - integer division truncated and returned
139:59 - an integer just like C in Python 3 one
140:03 - of the major improvements was that the
140:06 - division of two integers perform the
140:08 - division operation in floating point and
140:11 - returns a floating Point
140:13 - result C and python 2 made the choice
140:17 - because of efficiency integer division
140:19 - with truncation especially for 16bit
140:22 - numbers was quite fast in the 1970s
140:24 - computers compared to floating Point
140:26 - division that kept the fractional part
140:29 - intact early pdp1 computers did integer
140:32 - division in Hardware while all floating
140:35 - point was done with loops and functions
140:37 - so it was far slower if you wanted to
140:40 - write fast code in the 1970s you avoided
140:43 - floating Point numbers except for
140:46 - special
140:47 - situations modern computers usually do 6
140:50 - 4bit floating Point operations almost at
140:53 - the same speed as integer division so we
140:56 - don't need to allow programmers to avoid
140:58 - using floating point computations in
141:00 - their code the detailed rules for when
141:03 - integers are converted to floating Point
141:05 - are in chapter two for now notice that
141:08 - the assignment far equals lower
141:11 - semicolon and the test while far less
141:15 - than or equals upper both work as
141:17 - expected the int is converted to a float
141:20 - before the operation is
141:23 - done this example also shows a bit more
141:26 - of how print F Works print f is actually
141:29 - a general purpose format conversion
141:32 - function which we will describe
141:34 - completely in chapter 7 its first
141:36 - argument is a string of characters to be
141:39 - printed with each percent sign
141:41 - indicating where one of the other second
141:44 - third Etc arguments is to be substituted
141:48 - and what form it is to be printed in for
141:50 - instance in the statement print F
141:54 - parentheses double quote percent 4.0 f
141:57 - space percent 6.1
142:00 - F back slash and double quote comma far
142:03 - comma Celsius the conversion
142:05 - specification percent 4.0 F says that a
142:09 - floating Point number is to be printed
142:11 - in a space at least four characters wide
142:14 - with no digits after the decimal point
142:17 - percent 6.1 F describes another number
142:21 - to occupy at least six spaces with one
142:24 - digit after the decimal point analogous
142:27 - to the f61 of Fortran or the F
142:32 - parentheses 6 comma 1 of
142:34 - pl1 parts of a specification may be
142:37 - omitted percent 6f says that the number
142:41 - is to be at least six characters y
142:43 - percent 2f requests two places after the
142:47 - decimal point but the width is not
142:49 - constrained
142:50 - and merely percent F says to print the
142:53 - number itself as floating point printf
142:56 - also recognizes percent D for decimal
142:59 - integers percent o for octal percent X
143:02 - for heximal and percent C for characters
143:05 - and percent s for a character string and
143:08 - percent percent for the percent
143:11 - itself each percent Construction in the
143:13 - first argument of print f is paired with
143:16 - its corresponding second third Etc
143:19 - argument they must line up properly by
143:22 - number and type or else you'll get
143:24 - meaningless
143:25 - Answers by the way print f is not part
143:29 - of the C language there is no input or
143:32 - output defined in C
143:33 - itself there is nothing magic about
143:36 - printf it's just a useful function which
143:39 - is part of the standard library of
143:40 - routines that are normally accessible to
143:43 - C programs in order to concentrate on C
143:46 - itself we won't we won't talk much about
143:49 - IO until chapter 7 in particular will
143:54 - defer formatted input until then if you
143:57 - have to input numbers read the
143:59 - discussion of the function scanf in
144:01 - chapter 7 section
144:03 - 7.4 scanf is much like printf except
144:07 - that it reads input instead of writing
144:10 - output the balance between building a
144:13 - feature into the language itself and
144:15 - providing it as a function in a library
144:17 - is something that computer language
144:19 - designers struggle with many years later
144:22 - for example in Python 2 print was a
144:25 - language element in Python 3 one of the
144:28 - non- upwards compatible and somewhat
144:30 - unpopular changes was changing print to
144:34 - be a function many programmers feel that
144:37 - a print statement is a more elegant way
144:39 - to Express Printing but from a compiler
144:41 - and language design perspective a
144:44 - function call with a variable number of
144:45 - parameters is seen as technically more
144:48 - elegant and flexible
144:50 - with kernigan and Richie focused on
144:52 - keeping everything small and portable
144:54 - they opted to keep all input output
144:57 - functionality in libraries the syntax is
144:59 - a little more complex but given how
145:02 - Computing has changed in the past 30
145:04 - years it is the right choice section 1.3
145:08 - the four
145:10 - statement as you might expect there are
145:12 - plenty of different ways to write a
145:14 - program let's try a variation on the
145:16 - temperature converter this is sample
145:18 - code is on page 11 of the
145:21 - textbook pound sign include less than
145:25 - stdio.h greater than main open
145:29 - parentheses closed parentheses open
145:31 - curly
145:32 - brace int bar that is f a HR
145:38 - semicolon for open parentheses far
145:41 - equals z
145:43 - semicolon far less than or equal to 300
145:46 - semicolon far equal far + 20 close
145:51 - parentheses print F open parenthese
145:54 - double quote percent 4D space percent
145:58 - 6.1 F back sln close print close
146:02 - quote comma
146:05 - far comma open parentheses
146:08 - 5.0 9.0 Clos parentheses asterisk open
146:13 - parentheses far minus 32 close
146:16 - parentheses close parentheses semicolon
146:20 - this code produces the same answers as
146:22 - the one before but it certainly looks
146:24 - different one major change is the
146:26 - elimination of most of the variables
146:27 - only far fahr remains as an INT to show
146:32 - the percent D conversion in print F the
146:34 - lower and upper limits of the step size
146:37 - appear only as constants in the four
146:39 - statement itself four is a new
146:41 - construction and the expression that
146:43 - computes the Celsius temperature now
146:45 - appears as the third argument of print F
146:48 - instead of in a separate assignment
146:51 - statement this last change is an
146:54 - instance of a quite general rule in C in
146:57 - any context where it is permiss
146:59 - permissible to use the value of a
147:01 - variable of some type you can use an
147:04 - expression of that type since the third
147:06 - argument of print F has to be a floating
147:09 - point value to match the percent 6.1 F
147:13 - any floating Point expression can occur
147:15 - there the four itself is a loop a
147:19 - generalization of while if you compare
147:22 - it to the earlier while its operation
147:24 - should be clear it contains three parts
147:27 - separated by semicolons the first part
147:30 - far equals zero is done once before the
147:33 - loop proper is entered the second part
147:35 - is the test or condition that controls
147:37 - the loop far less than or equal to 300
147:42 - this condition is evaluated if it is
147:44 - true the body of a loop in this case a
147:46 - single print f is executed then the
147:48 - reinitialization step
147:50 - faral far + 20 is done and the condition
147:53 - is
147:54 - re-evaluated the loop terminates when
147:56 - the condition becomes false as with the
147:59 - while the body of the loop can be a
148:02 - single statement or a group of
148:03 - statements enclosed in braces the
148:06 - initialization and reinitialization
148:08 - parts can be any single expression the
148:11 - choice between while and for is
148:13 - arbitrary and should be based on what
148:15 - seems clearer the four is usually
148:17 - appropriate for Loops in which the
148:19 - initialization and reinitialization are
148:22 - single statements and logically related
148:24 - since it is more compact than while and
148:26 - keeps the Lo Loop control statements
148:29 - together in one
148:31 - place I would note that the syntax of
148:34 - the four and while loop is a feature of
148:36 - c and derived C- like languages in
148:40 - modern languages we tend to have two
148:42 - kinds of loop structures determinant and
148:45 - indeterminant the four and the Y Loop
148:48 - structures in C are both indeterminant
148:51 - because you must read them closely to
148:53 - make sure they are properly constructed
148:55 - and for example are not unintentionally
148:58 - infinite Loops an example of a
149:00 - determinant Loop is the for each Loop in
149:03 - PHP or the for Loop in Python the
149:06 - semantics of both of these Loops is to
149:08 - iterate all the elements in a
149:11 - collection but since collections are
149:13 - never infinite you can be assured that
149:15 - these determinant Loops will not run
149:18 - forever section 1. for symbolic
149:21 - constants a final observation before we
149:24 - leave temperature conversion it's a bad
149:27 - practice to bury magic numbers or magic
149:30 - constants like
149:32 - 320 or
149:33 - 320 in a program they convey little
149:36 - information to someone who might read
149:38 - the program later and they're hard to
149:40 - change in a systematic way fortunately C
149:44 - provides a way to avoid such magic
149:46 - numbers with the pound sign defined
149:49 - Construction at the beginning of a
149:51 - program we can define a symbolic name or
149:53 - symbolic constant to be a particular
149:55 - string of characters thereafter the
149:58 - compiler will replace all unquoted
150:00 - occurrences of the name by the
150:02 - corresponding string the replacement for
150:04 - the name can actually be any text at all
150:07 - it's not related to
150:10 - numbers so this is sample code on page
150:13 - 13 of the text pound sign
150:16 - include less than stdio.h greater than
150:21 - next line pound toine space lower space
150:25 - zero next line pound toine space upper
150:29 - space 300 pound define space step space
150:33 - 20 for these pound sign statements I
150:36 - would note that they have to start in
150:39 - the First
150:41 - Column the rest of this sample code is
150:43 - the code itself main open parentheses
150:46 - Clos parentheses open curly brace int
150:50 - far F A HR for open parthy far equals
150:56 - uppercase lower semicolon far less than
151:00 - or equal to uppercase upper semicolon
151:04 - far equals far plus uppercase
151:08 - step and then the same print statement
151:10 - print F open parentheses double quote
151:13 - percent 4D space percent 6.1 F back sln
151:18 - quote comma far comma percent 5.0 9.0
151:25 - close parentheses asterisk open
151:28 - parentheses far minus 32 close
151:31 - parentheses close parentheses semicolon
151:33 - and then to end the program close curly
151:36 - brace the quantities uppercase lower
151:39 - uppercase upper and uppercase step are
151:42 - constants so they do not eer in
151:45 - declarations symbolic names are commonly
151:47 - written in uppercase so they can be
151:49 - readly distinguished from lowercase
151:51 - variable names notice that there is no
151:54 - semicolon at the end of a pound fine
151:56 - statement since the whole line after the
151:59 - defined name is substituted there would
152:01 - be too many semicolons in the
152:03 - four section 1.5 a collection of useful
152:08 - programs we are now going to consider a
152:10 - family of related programs for doing
152:12 - Simple operations on character data you
152:15 - will find that many programs are just
152:17 - expanded versions of the prototypes we
152:19 - discussed
152:20 - here character input and output the
152:23 - standard Library provides functions for
152:25 - reading and writing a character at a
152:27 - time get charar fetches the next input
152:30 - character each time it is called and
152:32 - Returns the character as its value that
152:35 - is after C equals get Char open
152:39 - parentheses Clos parentheses the
152:40 - variable C contains the next character
152:42 - of input these characters normally come
152:45 - from the terminal or keyboard but that
152:47 - need not concern us until chapter 7 the
152:50 - function put Char open parentheses C
152:53 - closed parentheses is the complement of
152:55 - get
152:55 - charar put charar open parentheses C
152:59 - close parentheses prints the content of
153:02 - the variable C on some output medium
153:05 - again usually the terminal or screen
153:07 - calls to put chart and print F may be
153:09 - interleaved the output may be app will
153:12 - appear in the order in which the calls
153:14 - are made as with printf there is nothing
153:17 - special about getchar and putchar they
153:19 - are not part of the C language but they
153:22 - are universally
153:24 - available once again I would note that
153:27 - the authors are making the case that the
153:29 - syntax of the language should not
153:31 - include Syntax for input output
153:33 - operations but instead call library
153:36 - functions keeping the compiler small and
153:38 - easy to Port new systems was important
153:40 - to the creators of
153:41 - c and even if it's something like
153:44 - putchar was part of the language syntax
153:46 - it would be translated at runtime to
153:49 - call a function
153:50 - programming languages from the 1960s
153:52 - tended to have a small set of use cases
153:55 - read some input run some calculation and
153:57 - then write some output so it seemed like
153:59 - a few language elements would be
154:00 - sufficient to describe all programs but
154:03 - as programs started to make network
154:05 - connections draw buttons on a screen or
154:07 - respond to API calls over the network it
154:10 - would have been difficult to keep
154:11 - expanding the core language Syntax for
154:13 - each new use case but it was extremely
154:16 - natural to add new libraries to
154:18 - languages like C with functions to call
154:21 - to accomplish these new use cases file
154:25 - copying given getchar and putchar you
154:27 - can write a surprising amount of useful
154:29 - code without knowing anything more about
154:31 - input output the simplest example is a
154:34 - program which copies its input to its
154:36 - output one character at a time in
154:39 - outline here's what we do get a
154:43 - character while the character is not the
154:45 - end of file signal I'll put the
154:47 - character we just read and then get a
154:49 - new
154:50 - character converting this into C gives
154:53 - us the sample code on page 14 of the
154:56 - textbook pound includes
154:59 - stdio.h main open parentheses Clos
155:02 - parentheses open curly prce int c
155:06 - semicolon C equals getchar open
155:09 - parentheses close parentheses
155:11 - semicolon while c not equal eoff
155:15 - uppercase eoff close parentheses open
155:17 - curly brace put char C C equals get
155:22 - charge semicolon close parentheses close
155:25 - curly brace the
155:28 - relational operator exclamation equals
155:31 - means not equal
155:34 - to the main problem is detecting the end
155:37 - of the input by convention getchar
155:40 - Returns the value which is not a valid
155:42 - character when it encounters the end of
155:44 - input in this way programs can detect
155:47 - when they did not get a character and
155:49 - and they've actually simply run out of
155:51 - input the only complication which is a
155:53 - serious nuisance is that there are two
155:55 - conventions in common use about what
155:57 - that endif file value really is we have
156:01 - deferred this issue by using the S
156:03 - symbolic name EF capital eof for the
156:07 - value whatever it might be in practice
156:10 - eof will be either negative one or zero
156:13 - so the program must be proceeded by the
156:16 - appropriate pound Define eof minus one
156:20 - or pound Define e0 to work properly by
156:24 - using the symbolic constant eof to
156:27 - represent the value that geta returns
156:29 - when the end of file occurs we are
156:31 - assured that only one thing in the
156:33 - program defines on the specific depends
156:36 - on the specific value numeric value of
156:41 - eof I would
156:44 - note most of that is incorrect modern C
156:47 - compilers actually Define EOS in the
156:50 - stdio.h include file so you never Define
156:52 - eoff in your code in modern C the value
156:55 - of eoff is minus one you should just
156:58 - include stdio.h and use predefined eoff
157:00 - constant to check for end a file the
157:03 - nuisance of different values for eof was
157:06 - resolved shortly after
157:08 - 1978 continuing with the text we also
157:12 - declare C to be an INT not a chair Char
157:15 - so that it can hold the value which get
157:17 - Char returns as we'll see in chapter two
157:19 - the value is actually an in because it
157:22 - must be capable of representing end of
157:23 - file in addition to all possible
157:26 - characters so the program for copying
157:29 - could actually be written more concisely
157:32 - by experienced C programmers in C any
157:36 - assignment such as C equals get Char
157:38 - open parentheses close parentheses can
157:40 - be used in an expression it's a value is
157:44 - simply the residual value being assigned
157:47 - to the left hand side if the assignment
157:50 - of a character to the variable C is put
157:52 - inside the test part of a while
157:54 - statement the file copy program can be
157:56 - written as shown in the example code on
157:59 - page 15 of the
158:01 - textbook pound include
158:04 - stdio.h main open parentheses closed
158:07 - parentheses open curly brace int space c
158:12 - semicolon while open parentheses open
158:15 - parentheses C equals getchar open
158:18 - parentheses close parentheses Clos
158:20 - parentheses not equal EF Clos
158:23 - parentheses put Char C parentheses C
158:26 - Clos parentheses semicolon close curly
158:29 - brace the program gets a character
158:32 - assigns it to C and then tests whether
158:34 - the character was the end ofile signal
158:36 - if it was not the body of the while is
158:39 - executed printing the character the
158:41 - while then repeats when the input is end
158:44 - of input is finally reached the Wild
158:46 - termin terminates and so does Main this
158:49 - version version centralizes the input
158:52 - there's now only one call to getchar and
158:54 - shrinks the program nesting an
158:56 - assignment is a test of one of the
158:58 - places where C permits a valuable
159:01 - conciseness it is possible to get
159:03 - carried away and create impensable code
159:07 - though a tendency that we will try
159:09 - though that is a tendency we will try to
159:11 - curve it's important to recognize that
159:14 - the parentheses around the assignment
159:16 - within the conditional are really
159:18 - necessary the Precedence of exclamation
159:21 - equal not equals is higher than that of
159:24 - equals the assignment operator which
159:26 - means that in absence of parentheses the
159:28 - relational test exclamation equals would
159:31 - be done before the assignment equals so
159:35 - the statement C equals get charar
159:37 - parentheses open parentheses closed
159:39 - parentheses not equal eof is equivalent
159:41 - to C equals get Char open no sorry is
159:46 - equivalent to C equals open parthey get
159:50 - chart open parthy closed parentheses not
159:52 - equal e closed parenthesis this has the
159:55 - undef desired effect of
160:02 - setting it is important to recognize
160:04 - that the parentheses around the
160:06 - assignment within the conditional are
160:07 - really necessary the Precedence of
160:10 - exclamation equals is higher than that
160:13 - of
160:14 - equals which means that in the absence
160:16 - of parentheses the relational test not
160:19 - equals would be done before the
160:21 - assignment so the statement C equals get
160:23 - Char not equal eoff is equivalent to C
160:27 - equals open parentheses get Char not
160:29 - equal eof closed parentheses this has
160:33 - the undesired effect of setting C to
160:35 - zero or one depending on whether or not
160:38 - the call of getchar encountered the end
160:40 - of file more on this in Chapter 2 The
160:44 - Next program counts characters it is a
160:46 - small elaboration of the copy program
160:49 - this sample code is on page 16 of the
160:52 - textbook pound include
160:54 - stdio.h main open parentheses close
160:57 - parentheses open curly brace long NC
161:02 - semicolon N C equals 0
161:05 - semicolon while open parentheses get CH
161:08 - Char open parthey close parentheses
161:11 - exclamation equal
161:13 - EO Plus+ n c
161:16 - semicolon print f double quot percent LD
161:21 - back sln double quot comma NC
161:24 - parentheses semicolon close curly brakes
161:28 - the statement plus plus NC semicolon
161:31 - shows a new operator Plus+ which means
161:35 - increment by one you could write ncal NC
161:39 - + 1 but plus plus NC is more concise and
161:44 - often more efficient there is a
161:46 - corresponding operator minus minus to de
161:49 - By One The Operators
161:53 - Plus+ and minus minus can either be
161:56 - prefix operators Plus+ C NC or
162:01 - postfix n
162:03 - C++ these two forms have different
162:05 - values and expressions as will be shown
162:07 - in Chapter 2 but Plus+ NC and N C++ both
162:12 - increment and see for the moment we'll
162:15 - stick to the prefix
162:17 - form the character counting program
162:20 - accumulates its count in a long variable
162:22 - instead of an INT on a pdp1 the maximum
162:26 - value of an INT is
162:29 - 32,767 and it would take relatively
162:31 - little input to overflow that counter if
162:34 - it were declared as an INT in honey well
162:36 - and ibmc long and int are synonymous and
162:39 - much larger the conversion specification
162:42 - percent LD signals to print F that the
162:45 - corresponding argument is a long integer
162:50 - we again as a note we again see another
162:52 - reference to the fact that the number of
162:54 - bits of the int type is in transition in
162:57 - 1978 the older pdp1 used a 16-bit
163:00 - integer to save limited memory on a
163:02 - small almost obsolete computer while
163:05 - later computers from IBM and Honeywell
163:08 - have already switched to their int type
163:10 - to be 32bits this allowed code
163:12 - originally written for the pdp1 like
163:15 - Unix or even the C compiler to be
163:17 - recompiled on the IBM or Honeywell with
163:20 - very few
163:22 - changes to cope with bigger numbers you
163:24 - can use a double which is a double
163:27 - length float we will also use a four
163:29 - statement instead of a while to
163:31 - illustrate an alternate way to write a
163:33 - while loop this code is the second
163:36 - sample code on page 16 of the textbook
163:40 - found include
163:42 - stdio.h main open parentheses closed
163:44 - parenthesis open curly brace double NC
163:48 - semicolon
163:49 - for open parentheses NC equal 0
163:53 - semicolon getar open parentheses closed
163:55 - parentheses not equal e EF semicolon
163:59 - plus plus NC Clos parentheses and then a
164:03 - semicolon a semicolon in this case is an
164:05 - empty statement because there's nothing
164:07 - in the body of the of the for Loop and
164:10 - at the end we say print F double quote
164:14 - percent. 0f back
164:17 - sln double quot
164:19 - comma NC close parentheses semicolon
164:23 - close curly
164:24 - bracket print F uses percent f for both
164:27 - float and double percent. ZF suppresses
164:32 - printing of the non-existent fraction
164:34 - part the body of the for Loop here is
164:37 - empty because all the work is done in
164:39 - the test and reinitialization parts of
164:41 - the for Loop but the grammatical rules
164:44 - of C require that a four statement have
164:46 - a body the isolated SE semi and
164:49 - technically a null statement is there to
164:52 - satisfy that syntax requirement we put
164:55 - it on a separate line to make it more
164:58 - visible before we leave the character
165:00 - counting program observe that if the
165:02 - input contains no characters the while
165:05 - or for test fails on the very first call
165:08 - to getchar so that the loop program
165:11 - produces zero the right answer this is
165:15 - an important observation one of the nice
165:17 - things about while and four is they are
165:20 - tested at the top of the loop proceed
165:23 - before proceeding with the body if there
165:25 - is nothing to do nothing is done even if
165:28 - that means never going through the loop
165:31 - body programs should act intelligently
165:34 - with hand handed input like no
165:36 - characters the while and the four
165:38 - statements help ensure that they do
165:41 - reasonable things with boundary
165:44 - conditions line counting the next
165:47 - program counts lines in its in put input
165:49 - lines are assumed to be terminated by
165:51 - the new line character back sln that has
165:54 - been carefully appended to every line
165:56 - written out this is sample code on line
165:59 - 17 of the textbook pound includes
166:03 - stdio.h main open parentheses closed
166:06 - parentheses open curly
166:08 - brace int C comma NL
166:12 - semicolon NL equals z
166:16 - semicolon while open parentheses open
166:19 - parentheses C equals get Char open
166:21 - parentheses closed parentheses close
166:23 - parentheses not equal eoff Clos
166:27 - parentheses if open parentheses C double
166:30 - equals single quote back sln single
166:33 - quote close parentheses Plus+ NL
166:37 - semicolon print F double quot percent D
166:41 - back sln double quot comma NL close
166:44 - parentheses semicolon Clos curly
166:47 - brace the body of the while loop now
166:50 - consists of an if which in turn controls
166:53 - the increment Plus+ n l the if statement
166:57 - tests its parenthesized condition and if
167:00 - true does the statement or group of
167:02 - statements inside braces that follow we
167:05 - have again indented to show what is
167:07 - controlled by what the double equal sign
167:10 - in is the C notation for is equal to
167:13 - like fortrans do EQ do this symbol is
167:17 - used to distinguish the quality test a
167:20 - question being asked from the single
167:22 - equal sign used for assignment since
167:25 - assignment is about twice as frequently
167:27 - used as equality testing in typical C
167:30 - programs it's appropriate that the
167:32 - operator be half as
167:34 - long A Single Character can be written
167:37 - between single quotes to produce a value
167:39 - equal to the numerical value of the
167:41 - character in The Machine's character set
167:43 - this is called a character
167:45 - constant so for example single quote a
167:48 - single quote is a a character constant
167:49 - in the asky character set its value is
167:52 - 65 the internal representation of the
167:55 - character a of course double single
167:58 - quote a single quote is to be preferred
168:01 - over 65 its meaning is obvious and it is
168:04 - independent of a particular character
168:06 - set these Escape sequences that are used
168:09 - in character strings are also legal and
168:11 - character constants so in tests and
168:14 - arithmetic Expressions single quote back
168:17 - slash ning single quote stands for the
168:20 - value of a new line character you should
168:23 - note carefully that single quote back
168:25 - sln is a single qu character and in
168:29 - Expressions is equivalent to a single
168:31 - integer on the other hand double quote
168:34 - back sln double quote is a character
168:36 - string which happens to contain only one
168:39 - character the topics of strings versus
168:42 - characters is discussed further in
168:44 - Chapter
168:46 - 2 the numeric values that are shown for
168:49 - characters are using the asy character
168:51 - set the character sets in the 1970s were
168:54 - quite intricate most were eight bits
168:56 - long to conserve computer memory and
168:58 - only support a 100 or so Latin like
169:00 - characters this is why early programming
169:03 - languages use special characters like
169:05 - asterisk and curly brace in their syntax
169:08 - very carefully they needed to choose
169:10 - characters that were commonly available
169:12 - on computer keyboards from different
169:15 - manufacturers modern programming
169:17 - languages like Python 3 three and Ruby
169:19 - store internal string values using the
169:21 - Unicode character set so they are all
169:24 - able to represent all the characters in
169:27 - all languages around the
169:28 - world modern languages tend to represent
169:31 - 8 bit values in the range from 0 to 256
169:35 - using a bite or similar type python 2
169:38 - strings were stored as 8bit bytes and
169:41 - Python 3 strings are stored as 32-bit
169:44 - Unicode characters moving to Unicode was
169:47 - a major effort in the python 2 to Python
169:50 - 3
169:52 - transition word counting the fourth in
169:55 - our series of useful programs counts
169:57 - lines words and characters with a loose
170:01 - definition that a word is any sequence
170:03 - of characters that does not contain a
170:05 - blank a tab or a new line this is a very
170:10 - very barebones version of the Unix
170:12 - utility
170:14 - WC this example is on page
170:19 - in the
170:20 - textbook pound include
170:22 - stdio.h pound Define yes one pound
170:26 - Define no zero main open parentheses
170:31 - closed parentheses open curly braas int
170:35 - C comma NL comma NW comma NC comma
170:40 - NW NW equals no NL = NW = ncal Z
170:49 - while open parentheses open parentheses
170:51 - C equals get Char not equal to
170:55 - eof open curly brace plus plus n
170:59 - c if parentheses C equals quote back sln
171:05 - quote parentheses Plus+ n
171:09 - l if open parentheses C double equals
171:14 - single quote space single quote double
171:17 - vertical bar
171:20 - C
171:21 - equals single quot back slash n single
171:25 - quote double vertical Bar C equals
171:29 - equals single quote back SLT single
171:32 - quote close parentheses inward equals no
171:37 - else if open parentheses inward equal
171:40 - equal
171:41 - no close parentheses open curly brace
171:44 - inward equals yes semicolon Plus+ n W
171:50 - semicolon close curly brace close curly
171:54 - brace print F open priny double quot
171:58 - percent d space percent d space percent
172:01 - D back sln double quot comma
172:05 - NL comma NW comma NC close curly
172:11 - brace every time the program encounters
172:15 - the first character of a word it counts
172:18 - it
172:19 - the variable inword records whether the
172:21 - program is currently in a word or not
172:24 - initially it is not in a word which
172:27 - which is assign the value no we prefer
172:30 - the symbolic constants yes and no to the
172:32 - literal values one and zero because they
172:34 - make the program more readable of course
172:37 - in a program as Tiny as this it makes
172:38 - little difference but in larger programs
172:40 - the increase of clarity is well worth
172:43 - the modest X effort to write it this way
172:46 - to make it more readable
172:49 - you will also find that it's easier to
172:50 - make changes to programs where numbers
172:52 - appear only as symbolic
172:54 - constants the line NL equal
172:59 - nwal N C equals
173:02 - z sets all three variables to zero this
173:05 - is not a special case but a consequence
173:09 - of the fact that an assignment has a
173:11 - value and assignments associate right to
173:14 - left it's really as if we had written NC
173:18 - equals open parentheses NL equals open
173:22 - parentheses NW equals 0 close
173:25 - parentheses close parentheses
173:27 - semicolon the operator double vertical
173:30 - bar vertical bar vertical bar means or
173:33 - so the line if open parentheses C equals
173:38 - single quote space single quote vertical
173:40 - bar vertical bar cble equals single
173:43 - quote back slash n single quote double
173:46 - vertical Bar C equals quot back
173:50 - SLT quote parentheses says if C is a
173:54 - blank or C is a new line or C is a tab
173:57 - the escape sequence back SLT is a
173:59 - visible representation of the tab
174:01 - character there's a corresponding
174:03 - operator which is double Amper sand for
174:06 - and expressions connected by double
174:09 - Amper sand or double vertical bar are
174:11 - evaluated left to right and it is
174:13 - guaranteed that the evaluation will stop
174:15 - as TR as true soon as the truth or
174:19 - falsehood for the overall expression is
174:21 - known thus if C contains a blank there
174:25 - is no need to test whether it contains
174:27 - contains a new line or tab so these
174:29 - tests are not made this isn't
174:31 - particularly important here but is very
174:34 - significant in more complicated
174:36 - situations as we will soon
174:39 - see I would note that the double
174:41 - vertical bar and double Ampersand are
174:43 - the norm for Boolean operators in C like
174:45 - languages when a new language was being
174:47 - designed it was really easy to just
174:49 - adopt the C convention for logical
174:51 - operators because while they may seem
174:53 - cryptic millions of software developers
174:56 - were already familiar with the operators
174:58 - in this way the relationship between C
175:01 - and C like languages is like the
175:03 - relationship between Latin and romance
175:06 - languages including
175:07 - English back to the text the example
175:11 - also shows the C else statement which
175:13 - specifies an alternative action to be
175:16 - done if the condition part of an if
175:18 - statement is false the general form is
175:21 - if open parentheses expression closed
175:23 - parentheses statement one else statement
175:27 - two one and only one of the two
175:29 - statements associated with an if then
175:31 - else is done if the expression is true
175:34 - statement one is executed if not
175:36 - statement two is executed each statement
175:39 - can actually be in fact quite
175:41 - complicated in the word count problem
175:43 - the one after the else is an if that
175:46 - controls two statements in
175:49 - braces section 1.6
175:53 - arrays understanding the capabilities
175:55 - and limitations of CR arrays is one of
175:57 - the most important topics in our
176:00 - historical look at the C programming
176:02 - language most importantly the number of
176:05 - elements in an array declaration must be
176:07 - a constant at compiled time and the size
176:11 - of an array cannot be adjusted using an
176:14 - array declaration while the program's
176:16 - running this inability to automatically
176:19 - resize C arrays as data is added leads
176:22 - to a class of security laws that are
176:25 - generally referred to as buffer overflow
176:28 - where a program reads more data in that
176:31 - can fit into an array and is tricked to
176:33 - overwriting other data or code in
176:34 - compromising an
176:36 - application later in this book we will
176:38 - create Dynamic array like structures in
176:41 - C using pointers and the standard
176:44 - Library calic function python has
176:47 - support for non-dynamic arrays buffers
176:50 - python buffers are generally not used
176:52 - except for programmers writing Library
176:53 - code that talks to low-level code
176:56 - written in a language other than python
176:58 - or talking to operating system things
177:00 - like
177:01 - Linux more commonly used python list and
177:05 - dictionary structures can change their
177:07 - sizes automatically as elements are
177:10 - added and deleted at
177:12 - runtime Java has support for non-dynamic
177:15 - arrays like C which are given a length
177:19 - at the moment they are created and the
177:20 - array length cannot be increased nor
177:22 - decreased without making a new array and
177:24 - copying all the elements from the first
177:26 - to the second array Java does provide
177:29 - list and map structures that
177:31 - automatically adjust their length as
177:33 - data is added or removed Java has a
177:36 - class called array list which can be
177:38 - dynamically extended but provides array
177:41 - likee linear access it is a list
177:44 - internally but it can be used like an
177:47 - array
177:48 - externally the underlying technique that
177:51 - is used to implement language structures
177:53 - like Python's list is dynamic memory
177:56 - allocation in a link list structure link
177:59 - list are one of the most important data
178:01 - structures in all of computer science we
178:03 - will cover Dynamic allocation in
178:05 - implementing data structures in C in
178:08 - chapter 6 for now we will merely examine
178:12 - the syntax of C arrays but keep in mind
178:15 - that allocating an array in C is very
178:18 - different than C creating a list in
178:23 - Python back to the
178:25 - text let us write a program to count the
178:27 - number of occurrences of each digit of
178:30 - Whit space characters blank tab and new
178:32 - line and all other characters this is an
178:35 - artificial problem to solve but it
178:38 - permits us to illustrate several aspects
178:40 - of C in one program there are 12
178:44 - categories of input so it is convenient
178:47 - to use an array to hold the number of
178:50 - occurrences of each digit rather than 10
178:52 - individual variables actually 12
178:55 - individual variables here is one version
178:57 - of the program on page 21 in the
179:01 - textbook and I would note that as these
179:05 - programs get larger and larger it is
179:07 - harder and harder for you to just listen
179:09 - to me read them and you have to go look
179:10 - at them in the
179:12 - textbook so I recommend that you go
179:15 - check out the textbook in page 20 and
179:17 - find this um actual
179:19 - code found include
179:23 - stdio.h main open parentheses close
179:25 - parenthe open curly brace int C comma I
179:30 - comma n white comma n other semicolon
179:34 - int n digit open square bracket 10 Clos
179:39 - square bracket
179:40 - semicolon n white equal n other equals z
179:45 - semicolon four open parentheses I equal
179:48 - 0 semicolon I less than 10 semicolon
179:51 - Plus+ I open I mean close parentheses n
179:56 - digit open square bracket I closed
179:59 - square bracket equals 0
180:02 - semicolon now we're going to have a loop
180:05 - to read all of our input while double
180:08 - open parentheses C equals get Char open
180:10 - parentheses close parentheses and
180:12 - another closed parentheses not equal EF
180:15 - closed parentheses
180:18 - if open parentheses C greater than or
180:21 - equal to single quote 0 single quote
180:24 - double Amper sand C less than or equal
180:27 - single quote 9 single quote close
180:29 - parentheses Plus+ in digit open square
180:34 - bracket C minus single quote 0 single
180:37 - quote close square bracket semicolon
180:41 - else if open parentheses C double equals
180:45 - space uh quote space quote
180:49 - or double vertical bar cble
180:52 - equals single quot back sln single quote
180:56 - double vertical Bar C double equals
180:59 - single quot backt single quote close
181:01 - parentheses plus plus n white semicolon
181:06 - else plus plus n other that if statement
181:10 - was a sort of a three branch if checking
181:12 - to see if we were doing a digit a a whit
181:15 - space character or some other character
181:19 - at the end of the while loop or not at
181:20 - the end of The L while loop and so we
181:21 - say print F parentheses double quote
181:24 - digits equals double quote closed
181:26 - parentheses semicolon now we'll note in
181:29 - this that there is no new line so we can
181:31 - have these print defs kind of
181:33 - concatenate outward without going to a
181:35 - separate line for parentheses I equals 0
181:40 - semicolon I less than 10 semicolon Plus+
181:44 - I close parentheses print F double quote
181:48 - space percent d double quote comma igit
181:52 - open square bracket I close square
181:55 - bracket Clos parentheses
181:58 - semicolon print F open parentheses
182:02 - double quote back slash n Whit space
182:05 - equals percent D comma other equals
182:08 - percent D back slash N double quote
182:11 - comma n white comma n other Clos
182:15 - parentheses semicolon close curly brace
182:18 - let's go through the code the
182:20 - Declaration int n digit op square
182:23 - bracket 10 closed square bracket
182:26 - semicolon declares igit to be an array
182:30 - of 10 integers array of subscripts
182:32 - always start as zero in C rather than
182:35 - one as in forrer pl1 so the elements are
182:38 - igit Subzero igit sub one dot dot dot n
182:42 - digit sub n square brackets are the sub
182:47 - this is reflected in the for Loops which
182:49 - initialize and print the
182:51 - array a subscript can be integer any
182:53 - integer expression which of course
182:55 - includes integer variables like I and
182:58 - integer
182:59 - constants this particular program relies
183:03 - heavily on the properties of character
183:05 - representation of the digits for example
183:09 - if C greater than or equal to single
183:12 - quote zero single quote double Ampersand
183:15 - C less than or equal to single quote 9
183:18 - single quote Clos parentheses determines
183:21 - whether it's a digit that is if the
183:24 - numeric value of the
183:26 - digit and the numeric value of the digit
183:29 - is C minus double quot 0 double quot
183:33 - this only works if double quot 0 double
183:35 - quote one Etc are positive and
183:38 - increasing order and there's nothing but
183:40 - digits between 0 and 9 fortunately this
183:43 - is true for all conventional character
183:46 - sets by definition
183:49 - arithmetic involving chars and ins
183:51 - converts everything to int before
183:53 - proceeding so Char variables and
183:55 - constants are identically to essentially
183:58 - identical to ins in arithmetic
184:00 - contexts this is quite natural and
184:02 - convenient for example C minus single
184:05 - quote 0 single quote is an integer
184:07 - expression that gives us a value between
184:09 - zero and nine an integer value between
184:11 - Zer and N corresponding to the character
184:14 - quote 0 quote 2 quote 9 quote stored in
184:17 - C and is thus a valid subscript for the
184:20 - 10 element array and
184:23 - digit the decision as to whether the
184:26 - character is a digit a white space or
184:28 - something else is made by the sequence
184:30 - if open parentheses C greater than or
184:32 - equal to quote zero quote double Amper
184:36 - San C less than or equal quote Z quote
184:39 - quote 9 quote closed parentheses plus
184:42 - plus igit open square bracket C minus
184:46 - quote zero quote close bracket semicolon
184:49 - else if C equals single quote or C
184:55 - equals single quot back sln or cou
184:58 - equals single quot
185:00 - backt plus plus n white else Plus+ and
185:05 - other the pattern if in parentheses
185:09 - condition statement else if parentheses
185:12 - condition statement L statement occurs
185:15 - frequently in programs as a way to
185:17 - Express a multi-way decision the code is
185:20 - simply read from the top of the B until
185:22 - the bottom until some condition is
185:25 - satisfied at that point the
185:26 - corresponding statement part is executed
185:29 - and the entire construction is finished
185:31 - of course statement can be several
185:34 - statements enclosed in braces if none of
185:37 - the conditions are satisfied the
185:38 - statement after the final else is
185:40 - executed if present if the final else
185:43 - and statement are omitted as in the word
185:45 - count program no action takes place
185:48 - there can be an arbitrary number of
185:51 - elsif condition statements groups
185:54 - between the initial if and the final
185:57 - else as a matter of style it is
185:59 - advisable to format this construction as
186:01 - we have shown with proper indentation so
186:04 - that long decisions do not March off the
186:06 - right side of the
186:07 - page the switch statement to be
186:10 - discussed in chapter 3 provides another
186:12 - way to write multi-way branching that is
186:14 - particularly suitable when the condition
186:17 - being tested is simply whether some
186:19 - integer or character
186:21 - expression matches one of a set of
186:23 - constants for contrast we will present a
186:26 - switch version of this program in
186:28 - chapter
186:29 - three functions in C a function is
186:33 - equivalent to a subroutine or function
186:34 - in Fortran or a procedure in pl1 Pascal
186:38 - Etc a function provides a convenient way
186:41 - to encapsulate some computation in a
186:43 - black box which can then be used without
186:45 - worrying about its inerts functions are
186:48 - really the only way to cope with the
186:50 - potential complexity of large programs
186:53 - with properly designed functions it is
186:55 - possible to ignore how a job gets done
186:58 - knowing what is done is
187:00 - sufficient C is designed to make the use
187:03 - of functions easy convenient and
187:05 - efficient you will often see a function
187:08 - only a few lines long called only once
187:11 - just because it clarifies some piece of
187:13 - code so far we have used functions like
187:16 - print f get charart and put chart that
187:19 - have been provided for us now it's time
187:22 - to write a few of our own since C has no
187:25 - exponentiation operator like the double
187:27 - asterisk of forrer pl1 let us illustrate
187:30 - the mechanics of function definition by
187:33 - writing a function power open
187:35 - parentheses M comma n closed parentheses
187:38 - to raise an integer into a positive
187:42 - power n that is the value of power
187:46 - parentheses 2 comma 5 5 is
187:49 - 32 this function certainly doesn't do
187:52 - the whole job of exponentiation since it
187:55 - only handles positive powers of small
187:57 - integers but it is best to confuse only
188:00 - one issue at a time here is the function
188:03 - power and a main program to exercise it
188:05 - so you can see the whole structure at
188:07 - once this sample code is on page 23 of
188:11 - the
188:12 - textbook pound include
188:15 - stdio.h main open curly R in I semicolon
188:21 - for for parentheses I equal 0 semicolon
188:24 - I less than 10 semicolon plus plus I
188:27 - Clos parentheses print F double quote
188:31 - percent d space percent d space percent
188:33 - D back slash N double quote comma I
188:37 - comma power open parentheses 2 comma I
188:40 - close parentheses comma power open
188:44 - parentheses -3 comma I close parentheses
188:48 - close parentheses semicolon close curly
188:50 - brace the end of the main now we' begin
188:53 - the function power open parentheses x
188:56 - comma n Clos
188:58 - parentheses int X comma n semicolon open
189:02 - curly brace int I comma
189:06 - p p equal
189:08 - 1
189:10 - for open parentheses I equal 1 semicolon
189:14 - I less than or equal to n semicolon plus
189:16 - plus I
189:19 - p = p * X semicolon return open
189:23 - parentheses p closed parentheses
189:25 - semicolon close curly brace each
189:29 - function has the same form function name
189:32 - open parentheses argument list if
189:35 - any followed by argument declarations if
189:39 - any followed by the body of the function
189:42 - which includes declarations and
189:44 - statements the functions can't appear in
189:47 - either order and in one source file or
189:49 - two if of course the source file appears
189:52 - in two files you will have to say more
189:53 - to compile and load it then it fall
189:55 - appears in one but that's an operating
189:57 - system matter not a language attribute
190:00 - for the moment we'll just assume that
190:02 - both fun functions are in the same file
190:04 - so whatever you learned about C programs
190:07 - running them will not change the
190:09 - function power is called twice in the
190:12 - Line Print F open parenes double quote
190:15 - percent d space percent d space percent
190:18 - D back sln double quote comma I comma
190:21 - power open parentheses to comma I Clos
190:25 - parentheses comma power open parentheses
190:28 - -3 comma I close parentheses close
190:31 - parentheses each call passes two
190:34 - arguments to the power function which
190:36 - each time returns an integer to be
190:38 - formatted and printed in the expression
190:41 - power open parentheses 2 comma I is just
190:44 - an integer as two and I are not all
190:47 - functions produce an integer value and
190:49 - we'll take this up in more detail in
190:51 - chapter 4 in power the arguments have to
190:55 - declared appropriately so their types
190:57 - are known before the beginning of the
190:59 - body of the function this is done by the
191:01 - line int X comma n semicolon that
191:06 - follows the function name the argument
191:08 - declarations go between the argument
191:11 - list and the opening left brace each
191:14 - declaration is terminated by a semicolon
191:16 - the names used for power and for its
191:18 - arguments are purely local to power and
191:21 - not accessible to any other functions
191:24 - other routines can use the same names
191:26 - for their variables without conflict
191:28 - this is all so true of the variables I
191:30 - and P within the function the i in power
191:34 - is unrelated to the i in main the value
191:37 - that power comp computes is returned to
191:40 - main by the return statement which is
191:43 - just as in
191:44 - pl1 any expression must occur within the
191:48 - parentheses a function need not return a
191:51 - value a return statement with no
191:53 - expression causes control but no useful
191:55 - value to be returned to the call caller
191:58 - as does falling off the end of a
192:01 - function by reaching the terminating
192:03 - right curly
192:05 - brace section 1.8 arguments call by
192:09 - value one aspect of C function which may
192:12 - be unfamiliar to programmers who are
192:14 - used to other languages particularly
192:16 - Fortran and P one in C all function
192:19 - arguments are passed by value this means
192:23 - that the called function is given the
192:25 - values of its arguments in temporary
192:27 - variables actually on a stack rather
192:30 - than their addresses this leads to some
192:33 - different properties than are seen with
192:35 - call by reference languages like Fortran
192:38 - and
192:39 - pl1 in which the called routine is
192:41 - handled the address of the argument not
192:43 - its
192:44 - value it may seem strange that the
192:47 - authors are calling so much attention to
192:49 - the fact that function arguments are
192:51 - passed call by value in the very first
192:54 - chapter most modern programming
192:56 - languages like python PHP or Java pass
192:59 - single value arguments by value by
193:02 - default and to pass in an argument by
193:04 - reference you need to do something
193:06 - special like adding the Ampersand in the
193:08 - function declaration in
193:11 - PHP passing by reference was the norm
193:14 - before c and passing by value was the
193:16 - norm form after C since modern languages
193:20 - were deeply influenced by and often
193:22 - written in C passing by value is the
193:25 - norm for modern languages it's nice
193:28 - because it isolates the data in the
193:30 - calling code from the called code so the
193:32 - called code can't easily mess with its
193:35 - arguments either intentionally or by
193:37 - mistake and create an unexpected side
193:40 - effect and possibly a bug or security
193:43 - flaw in the calling code it was a bit of
193:46 - work to make pass by value work in C C
193:50 - implements a call stack where a bit of
193:53 - memory is automatically allocated at
193:55 - each function call and C makes a copy of
193:57 - the values in the calling code to pass
193:59 - them into the called code in a way that
194:02 - the calling code can see the values and
194:04 - change their local copies without
194:06 - affecting the values in the calling code
194:09 - the same call stack that made it
194:10 - possible for C function arguments to be
194:13 - passed by value also made it possible
194:16 - for a function to call itself
194:18 - recursively Fortran functions could not
194:20 - be called recursively until the 1990
194:23 - version of Fortran if you know your
194:25 - python you know that simple variables
194:28 - like integers and strings are passed by
194:30 - value while structured data like
194:32 - dictionaries and list are passed by
194:34 - reference I.E the called function can
194:37 - modify its arguments we will later see
194:40 - this in C as
194:42 - well talking about call Stacks recursive
194:45 - functions and the fact that arrays andru
194:47 - structured are called by reference is
194:48 - jumping ahead somewhat so for now let's
194:52 - just remember the author's point that
194:54 - normal valuable values like integers and
194:57 - floats are passed by value in C back to
195:02 - the text the main distinction is that in
195:04 - C the called function cannot alter a
195:07 - variable in the calling function it can
195:09 - only alter its private temporary copy
195:13 - call by value is an asset however not a
195:15 - liability it usually leads to more
195:18 - compact programs with fewer extraneous
195:20 - variables because arguments can be
195:22 - treated as conveniently initialized
195:24 - local variables in the called routine
195:27 - for example here is a version of power
195:30 - which makes use of this fact this code
195:33 - is on page 24 of the
195:36 - text power open parentheses x comma n
195:41 - close
195:42 - parentheses int X comma n semicolon open
195:46 - curly brace
195:47 - int I comma P semicolon for open
195:52 - parentheses p = 1 semicolon n greater
195:55 - than 0 semicolon minus- n Clos
195:59 - parentheses p = p * X semicolon return
196:05 - open parentheses p close parentheses
196:08 - semicolon close curly
196:10 - brace the argument n is used as a
196:13 - temporary variable and is counted down
196:15 - until it becomes zero
196:17 - there is no longer a need for the
196:19 - variable I as in the previous example
196:22 - whatever is done to n inside the power
196:24 - function has no effect on the argument
196:26 - that power was originally called
196:28 - with when necessary it is possible to
196:31 - arrange for a function to modify the
196:33 - variable in the calling routine the
196:35 - caller must provide the address of their
196:38 - variable to be set technically a pointer
196:41 - to the variable and the called function
196:44 - must declare the argument to be a
196:46 - pointer and reference the actual
196:48 - variable indirectly through it we will
196:51 - cover this in detail in chapter
196:54 - five when the name of an array is used
196:56 - as an argument the value passed to the
196:58 - function is actually the location or
197:01 - address of the beginning of the array
197:04 - there is no copying of the elements in
197:07 - the array by subscripting this value the
197:10 - function can access and alter any
197:13 - element of the array in the calling code
197:16 - this is the topic of the next
197:20 - section now I would recommend that
197:22 - you're careful looking at the code
197:24 - samples in the rest of this chapter
197:26 - recall that in C array sizes do not grow
197:29 - and Shrink dynamically at all after
197:31 - they're allocated the authors statically
197:34 - allocate character arrays capable of
197:36 - handling up to 1,000 characters long
197:39 - their code works but it is somewhat
197:41 - riddle so look at the next two sections
197:44 - as examples of cyntax with many
197:46 - important Concepts about character
197:48 - strings stored as arrays and calling
197:50 - patterns when passing arrays to
197:52 - functions as parameters that but not
197:55 - exactly the best practice when handling
197:57 - dynamically sized data back to the text
198:01 - probably the most common type of array
198:03 - in C is an array of characters to
198:05 - illustrate the use of character arrays
198:07 - and functions to manipulate them let's
198:09 - write a program that reads a set of
198:11 - lines and prints the longest the basic
198:13 - outline is simple enough while there's
198:16 - another line if it's longer than the
198:19 - previous longest save it and its length
198:22 - and then at the very end print the
198:23 - longest
198:24 - line the outline makes it clear that the
198:27 - program divides naturally into pieces
198:29 - one piece gets a new line another checks
198:32 - it another saves it and then the rest
198:34 - controls the process since things divide
198:37 - so nicely it' be it would be well to
198:39 - write them that way too accordingly
198:42 - let's write first a separate function
198:45 - called getline to fetch the next line of
198:48 - input this is a generalization of get
198:50 - Char to make the function useful in
198:53 - other context we'll try to make it as
198:54 - flexible as possible at the minimum get
198:58 - line has to return a signal about
199:00 - possible end of file a more generally
199:03 - useful design would be to return the
199:04 - length of the line line or zero if the
199:07 - end of file is encountered zero is never
199:10 - a valid line length since every line has
199:12 - at least one character even a line
199:15 - containing only a new line has length
199:17 - one I would note that here in chapter
199:20 - one we have changed the book's original
199:22 - use of the function named getline to get
199:24 - underscore line in the code examples
199:27 - because it conflicts with Ste the
199:30 - stdio.h that defines getline as a
199:32 - library function in this chapter the
199:34 - authors are providing examples around
199:36 - function naming and linking in later
199:38 - chapters code samples will simply use
199:40 - the built-in git line without an
199:42 - underscore to read an input
199:46 - when we find a line that is longer than
199:48 - the previous longest it must be saved
199:50 - somewhere this suggests a second
199:52 - function copy to copy the new line to a
199:55 - safe place finally we need a main
199:58 - program to control get line and
200:00 - copy here is the result the sample code
200:04 - for this is on page
200:06 - 26 and it's a bit long so you might want
200:08 - to show take a look at uh the sample
200:11 - code in a
200:13 - browser pound include stdi H pound
200:18 - Define MAX Line
200:20 - 1000 Main open pen and Clos pen open
200:24 - curly brace int Len semicolon which is
200:28 - the current line length int Max
200:31 - semicolon which is the maximum length
200:33 - we've seen so far Char Line open square
200:38 - bracket MAX Line closed square bracket
200:41 - semicolon a character array that's the
200:43 - current input line and then char Save
200:48 - open square bracket MAX Line close
200:50 - square bracket semicolon which is a
200:52 - character array that has the longest
200:54 - line where we're going to save
200:57 - it onto the
200:59 - code Max equals z while open parentheses
201:04 - open parentheses Len equals get Line
201:07 - open parentheses line comma MAX Line
201:09 - close parentheses close parthy greater
201:11 - than
201:13 - zero if Len is greater than Max
201:18 - open curly brace Max equals Len to save
201:21 - it and then copy line comma
201:25 - save close curly
201:28 - brace if open parentheses Max greater
201:31 - than zero I.E there was a line print F
201:35 - open parentheses double quote percent s
201:39 - double quote comma save close curly
201:42 - brace to end the main
201:43 - program now we're in the first function
201:46 - getline open parentheses s comma limb
201:50 - closed
201:51 - parentheses Char s Open Bracket close
201:55 - bracket semicolon since it's being
201:58 - passed in as an argument we don't need
202:01 - to know the length of it and the next
202:05 - argument is int limb semicolon so
202:09 - getline takes a character array of
202:13 - unknown length and a limit that tells us
202:15 - the length of the character array open
202:18 - curly brace int C comma I
202:22 - semicolon four open parentheses I equals
202:25 - 0
202:27 - semicolon I less than limb
202:30 - minus1 double Amper sand parentheses C
202:34 - equals get Char open parentheses close
202:37 - parentheses close parentheses not equal
202:40 - eof and double Amper sand c not
202:45 - equal single quote back sln back single
202:49 - quote semicolon Plus+
202:54 - I and in the body of the loop it's s
202:57 - open square bracket I closed square
203:00 - bracket equals c from now on I'll read
203:03 - that S Sub I equals
203:07 - c at the end of the loop we say if open
203:11 - parentheses cble equals single quote
203:14 - back slash n single quote closed
203:16 - parenthe see open curly brace S Sub i =
203:20 - c Plus+ I Clos curly
203:25 - brace s subi equals back
203:30 - sl0 quot
203:32 - semicolon return open parentheses I Clos
203:36 - parentheses semicolon close curly brace
203:39 - and that's the end of the getline
203:42 - function and now we on to the copy
203:45 - function copy copy open parentheses S1
203:48 - S2 closed parentheses purpose of this
203:51 - function is copy S1 to S2 assume that S2
203:54 - is big
203:55 - enough the Declaration is Char S1 open
204:00 - square bracket close square bracket
204:01 - comma S2 open square bracket closed
204:04 - square
204:06 - bracket as a note these arrays have a
204:09 - size we just don't know what they are
204:11 - and we hope that they're large
204:13 - enough the body of the copy function
204:16 - starts with open curly braids int I
204:20 - semicolon I equal 0 while open
204:25 - parentheses open parentheses S2 sub I
204:29 - equals S1 sub I Clos parentheses not
204:33 - equal single quote back sl0 single quote
204:37 - plus plus I glow curly brace to end the
204:40 - copy
204:42 - function Main and getline communicate
204:45 - both through a pair of arguments and a
204:47 - returned value in getline the arguments
204:49 - are declared by the lines Char s open
204:53 - square bracket close square bracket
204:55 - semicolon int limb semicolon which
204:59 - specify that the first argument is an
205:01 - array of unknown length and the second
205:04 - is an integer the length of the array s
205:07 - is not specified in getline since it's
205:10 - determined in main getline uses return
205:14 - to send a value back to the call Callum
205:16 - caller just as the function power did
205:18 - some functions return a useful value
205:20 - others like copy are only used for their
205:23 - effect and return no value getline puts
205:27 - the character back sl0 the null
205:29 - character whose integer value is zero at
205:32 - the end of the array it's creating to
205:34 - Mark the end of the string of characters
205:37 - this convention is also used by the C
205:40 - compiler with a when a string constant
205:42 - like double quote h l l back SL N double
205:47 - quote is written in a c program the
205:50 - compiler creates an array of characters
205:52 - containing the characters of the string
205:54 - and adds a back sl0 at the end to
205:58 - terminate so that functions such as
206:00 - print F can detect the
206:03 - end so that would lead to an array that
206:07 - has h e l l o back sln back sl0 so it's
206:14 - a five character
206:17 - array with a new line which is a sixth
206:20 - character and then back sl0 which is an
206:22 - actual character again we don't know the
206:25 - arrays don't know their length and so
206:27 - you use the back sl0 as the indicator of
206:30 - the end of a
206:32 - string the percent s format
206:34 - specification in print F expects a
206:36 - string represented in exactly this form
206:39 - if you examine copy you will discover
206:42 - that it too relies on the fact that its
206:44 - input argument S1 is ter terminated by
206:46 - back sl0 and it copies this character
206:50 - back sl0 into the argument output
206:54 - argument
206:55 - S2 all of this implies that back sl0 is
206:59 - not part of normal text it's merely a
207:02 - marker it is worth mentioning in passing
207:06 - that even a program as small as this one
207:09 - presents some sticky design problems for
207:13 - example what should Maine do if it
207:15 - encounters line which is bigger than its
207:18 - limit get line works properly in that it
207:22 - stops collecting when the array is full
207:24 - even if no new line has been seen by
207:27 - testing the length in the last character
207:29 - returned main can determine whether the
207:32 - line was too long then cope with it as
207:34 - it wishes in interest of brevity we have
207:38 - ignored this
207:40 - issue there's also no way for a user of
207:43 - getline function to know in Advance how
207:46 - long an input line might be so get line
207:49 - checks for
207:50 - overflow on the other hand a user of the
207:53 - copy function already knows or should be
207:55 - able to find out how big the strings are
207:57 - so we have have chosen not to add error
208:01 - checking to
208:03 - it
208:05 - section section 1.10 scope external
208:10 - variables the variables in Main Line
208:14 - save Etc are private or local to main
208:18 - because they're declared within main no
208:21 - other function can have direct access to
208:23 - them the same is true of the variables
208:25 - in the other functions for example the
208:27 - variable I in get line is unrelated to
208:30 - the i in copy each local variable in a
208:33 - routine comes into existence only when a
208:36 - function is called and disappears when
208:38 - the function is exited it is for this
208:41 - reason that such variables are usually
208:43 - known as automatic variables following
208:46 - terminology and other languages we'll
208:49 - use the term automatic henceforth to
208:51 - refer to these Dynamic local variables
208:54 - chapter 4 discusses the static storage
208:57 - class in which local variables do retain
208:59 - their values between function
209:01 - invocations because automatic variables
209:04 - come and go with function in invocation
209:07 - they do not retain their values from one
209:09 - call to the next and must be explicitly
209:12 - set upon each entry if they are not set
209:15 - they will contain
209:17 - garbage as an alternative to automatic
209:20 - variables it is possible to Define
209:22 - variables which are external to all
209:23 - functions that is global variables which
209:27 - can be accessed by name by any function
209:29 - that cares to this function is rather
209:32 - like Fortran common or pl1 external
209:36 - because external variables are globally
209:38 - accessible they can be used instead of
209:40 - arguments to communicate data between
209:42 - functions furthermore because external
209:45 - variables remain in existence
209:46 - permanently rather than appearing and
209:48 - disappearing as functions are called and
209:50 - exited they retain their values even
209:53 - after the functions that set them are
209:55 - done an external variable has to be
209:58 - defined outside of any function this
210:01 - allocates actual storage for it the
210:04 - function also must be declared on each
210:06 - function that wants to access it this
210:09 - may be done either by an explicit extern
210:12 - declaration or implicitly by context to
210:15 - make the discussion concrete let's
210:18 - rewrite the longest line program with
210:20 - line save and Max as external variables
210:25 - this requires changing the calls
210:27 - declarations and bodies of all three
210:31 - functions this sample code is on page 29
210:34 - of the textbook and it's pretty long but
210:37 - um I'll read it for you pound include
210:41 - stdio.h pound Define MAX Line
210:44 - 1000 and we're still outside of main
210:47 - Char line Open Bracket MAX Line close
210:51 - bracket semicolon Char save Open Bracket
210:55 - MAX Line semicolon int Max semicolon
211:00 - those are our three Global variables
211:02 - starting the main main open pin Clos pin
211:06 - open curly
211:08 - brace int
211:10 - Len extern int Max so we're saying that
211:14 - this is an integer but it's also not to
211:16 - be allocated inside of main extern Char
211:20 - Save open square bracket closed square
211:24 - bracket we the line length the length of
211:27 - the save array is defined above so we
211:30 - don't need to Define it here Max equals
211:34 - z semicolon while double parentheses Len
211:38 - double left parentheses Len equals get
211:40 - line parentheses greater than zero
211:44 - parentheses if parthey Len greater than
211:47 - Max open curly brace Max equals Len copy
211:52 - open parentheses no parentheses
211:54 - semicolon no parameters to copy because
211:57 - it's going to Simply talk to the global
211:58 - variables close curly brace after the
212:02 - loop finishes we say if open parentheses
212:05 - Max greater than zero then print F open
212:08 - parentheses double quote percent s
212:11 - double quote comma save close
212:14 - parentheses semicolon close close curly
212:17 - brace and that is the end of the main so
212:20 - now we have the getline function which
212:22 - is specialized to deal with external
212:26 - variables
212:28 - okay so we start get Line open
212:32 - parentheses closed parentheses no
212:34 - parameters open curly brace int comma C
212:38 - comma int C comma I semicolon these are
212:42 - local variables extern Char Line open
212:45 - curl curly BL brace closed curly brace
212:49 - semicolon this is the our reference
212:51 - inside of getline to the global variable
212:55 - line for open parentheses I equals z
212:59 - semicolon I less than MAX Line minus one
213:03 - MAX Line minus one max line is a
213:06 - predefined constant at compile
213:09 - time for I less than MAX Line minus one
213:12 - double Amper sand parentheses C equals
213:15 - get open parentheses close parentheses
213:17 - close parentheses not equal EF double
213:21 - Amper sand IE and c not equal single
213:25 - quot back sln single quote semicolon
213:29 - Plus+ I line subi equals c that's the
213:33 - for Loop that in effect reads characters
213:35 - one at a time and puts them in
213:39 - line after the for Loop we say if open
213:43 - parentheses C double equals single quote
213:46 - back slash n single quote close
213:48 - parentheses open curly brace line sub I
213:51 - equal C plus plus I close curly brace
213:55 - this ensures that we append the new line
213:58 - to the
214:00 - function line subi
214:03 - equals single quote back slash zero back
214:06 - slash that's semicolon the that's the
214:09 - string termination character return I
214:13 - return open parentheses I Clos parenthe
214:15 - see this is the length that getline is
214:18 - returning and then close curly brace to
214:20 - end the getline function and then we
214:22 - have the copy function and again it
214:25 - takes no parameters copy open
214:27 - parentheses Clos parentheses curly brace
214:29 - in I extern Char line Open Bracket close
214:35 - bracket comma save Open Bracket close
214:38 - bracket semic colum I equals z while
214:43 - parentheses open parentheses open
214:44 - parentheses say sub I equals line sub I
214:49 - Clos parentheses is not equal quote back
214:52 - sl0
214:54 - quote plus plus
214:57 - I close curly brace for
215:00 - copy so the external variables in Main
215:03 - getline and copy are defined by the very
215:06 - first lines in the example above outside
215:08 - of main which state their type and cause
215:11 - storage to be allocated for them
215:14 - syntactically external definitions are
215:16 - just like the Declarations we used
215:18 - previously but because they occur
215:20 - outside of any function including
215:22 - outside the main function the variables
215:24 - are external before a function can use
215:28 - or access an external variable the name
215:30 - of the variable must be made known to
215:32 - the function one way to do this is to
215:35 - write an extern declaration in the
215:37 - function the Declaration is the same as
215:39 - before except for the added keyword
215:43 - extern in certain circumstances the
215:46 - external declaration can be admitted
215:48 - omitted if the external definition of
215:50 - the variable occurs in the same source
215:53 - file before it's used in a particular
215:55 - function then there's no need for an
215:57 - extern declaration in the function the
215:59 - extern Declarations in Main and getline
216:02 - and copy are thus redundant in fact
216:05 - common practice is to place all
216:07 - definition of all external variables at
216:09 - the beginning of the source file and
216:12 - then omit all extern
216:14 - declarations if the program is in
216:16 - several source files and a variable is
216:18 - defined in say file one and used in file
216:21 - two then an extern declaration is needed
216:24 - in file two to connect the two
216:26 - occurrences of the variables this topic
216:29 - is discussed at length in chapter 4 you
216:32 - should note that we are using the words
216:34 - declaration and definition very
216:36 - carefully when we refer to external
216:38 - variables in this section definition
216:40 - refers to the place where the variable
216:42 - is actually created or assigned storage
216:45 - declaration
216:46 - refers to places where the nature of the
216:48 - variable is stated but no storage is
216:50 - allocated by the way there is a tendency
216:53 - to make everything in sight an extern
216:55 - variable because it appears to simplify
216:57 - things argument lists are short and
217:00 - variables are always there when you want
217:01 - them but external variables are always
217:04 - there also when you don't want them the
217:07 - style of coding is fraught with Peril
217:09 - since it leads to programs whose data
217:10 - connections are not at all obvious
217:13 - variables can be changed in unexpected
217:15 - and even inadvertent ways and the
217:18 - program is hard to modify when it
217:20 - becomes necessary the second version of
217:22 - the longest line program is inferior to
217:25 - the first partly because of these
217:27 - reasons and partly because it destroys
217:29 - the general generality of two quite
217:32 - useful functions by hardwiring them into
217:35 - the names of the variables they will
217:37 - manipulate section 1.1
217:40 - summary at this point we have covered
217:43 - what might be called the conventional
217:44 - core of see with this handful of
217:47 - building blocks it's possible to write
217:49 - useful programs of considerable size and
217:52 - it probably a good idea if you paused
217:54 - long enough to do so the exercises that
217:57 - follow are intended to give you
217:59 - suggestions for programs of somewhat
218:01 - greater complexity than the ones
218:03 - presented in this
218:05 - chapter after you have this much C under
218:08 - control it will be well worth your
218:10 - effort to read on for the features
218:12 - covered in the next few chapters are
218:14 - where the power and expressiveness of
218:16 - the language begin to become
218:20 - apparent this work is based on the 1978
218:24 - C programming book written by Brian W
218:26 - kernigan and Dennis M Richie their book
218:29 - is copyright All Rights Reserved by AT&T
218:32 - but is used in this work under fair use
218:35 - because of the book's historical and
218:37 - scholarly significance its lack of
218:39 - availability and the lack of an
218:41 - accessible version of the book the book
218:43 - is augmented in places to help
218:45 - understand stand Its Right Place in a
218:46 - historical context amidst the major
218:48 - changes of the 1970s and 1980s as
218:52 - computer science evolve from a hardware
218:54 - first vendor centered approach to a
218:56 - software centered approach where
218:58 - portable operating systems and
218:59 - applications written in C could run on
219:02 - any
219:03 - hardware this is not the ideal book to
219:05 - learn SE programming because the 1978
219:08 - Edition does not reflect the modern sea
219:10 - language using an obsolete book gives us
219:13 - an opportunity to take students back in
219:15 - time and understand how the sea language
219:17 - was evolving as it laid the groundwork
219:20 - for a future with portable
219:22 - [Music]
219:38 - applications welcome to chapter 2 types
219:41 - operators and expressions so again I'm
219:44 - not going to tell you everything the
219:45 - book I want you to read the book the
219:47 - book does a great job I'm just going to
219:48 - call your attention to some things that
219:50 - that might seem a little bit weird if
219:52 - you're coming from a language like
219:53 - python or JavaScript or even PHP where
219:58 - things are objects and you don't even
219:59 - notice it you've been using objects your
220:01 - whole career and you didn't even realize
220:03 - it so we're going to talk about data
220:05 - types and storage allocation one of the
220:07 - things that you just got to part of what
220:09 - I love about teaching this historical
220:11 - view on C is that we have to talk about
220:13 - storage allocation um float and double
220:16 - worked out pretty well um partly because
220:18 - in the early days of C they did them all
220:20 - in software so they just made them easy
220:22 - and they made them work well um they
220:24 - weren't expected expected to be fast the
220:26 - things that they wanted to be super fast
220:28 - were like the integer and bite bite data
220:31 - character data uh type conversion and
220:34 - then and there's a story that connects
220:36 - integer division in Python 2 and all
220:38 - that pain of Python 3 and how division
220:40 - changed and why it was the way it was
220:43 - and how that worked and again it has to
220:44 - do with performance and simple decisions
220:46 - that got made sadly bitwise logical
220:49 - operations we'll talk about them you're
220:52 - probably not going to use them but it's
220:54 - really important in a historical context
220:56 - to understand why they were so thorough
220:59 - and it really had to do with the fact
221:01 - that because of word oriented computers
221:05 - switching to character oriented
221:06 - computers all of us programmers were
221:08 - thinking in words and if we didn't see
221:10 - shifting and masking and bitwise stuff
221:12 - we'd be like I can't program in this
221:14 - thing cuz a lot of our work work in
221:16 - those word oriented computers was
221:17 - masking and shifting and so it's like we
221:20 - had to have it um we didn't use it as
221:22 - much as we uh we could have thought so
221:25 - let's start with uh
221:31 - division in the good old days we were
221:35 - not worried too much about doing
221:37 - Division and if you were doing Division
221:40 - and you cared about the division uh you
221:42 - were probably doing it in floating point
221:44 - because you were doing SCI scientific
221:45 - Computing and you did that on
221:47 - supercomputers you didn't do that on
221:48 - general purpose computers Unix is really
221:50 - designed for general purpose computers
221:52 - and in general purpose computers you you
221:55 - sort thought to yourself you know why is
221:57 - division that important and I'm sure
221:59 - they made some decision somewhere I do
222:01 - not know why it probably had to do with
222:03 - one of the computers they were working
222:04 - with had truncating division in hardware
222:08 - and non-truncating Division in software
222:11 - I don't know or rounding division or
222:13 - whatever a lot of those computers didn't
222:15 - even have fast floating point so some of
222:17 - the computers they were working on did
222:18 - all the floating point in software and
222:21 - maybe they even did integer division in
222:22 - software with loops and stuff uh but we
222:25 - don't know I I don't exactly know but
222:29 - they made this decision to do integer
222:33 - Division
222:34 - truncating and this was one of the
222:36 - biggest things of going from python 2 to
222:39 - Python 3 that was the most painful so
222:42 - python 2 was like over 25 years old and
222:47 - it wasn't that long after C that python
222:49 - 2 was written python 2 was written in C
222:53 - and uh python 2 to Python 3 transition
222:56 - was a big deal it took a long time it
222:58 - took 12 years to get there but python 2
223:01 - was like the greatest thing ever except
223:04 - for a few things because python 2 was so
223:07 - related to C the strings in Python 2
223:10 - natively were asky not Unicode which
223:12 - meant it was it it couldn't even do like
223:14 - Spanish characters let alone uh Asian
223:17 - characters print was part of the
223:19 - language and the programmers got a lot
223:22 - of help like they got automated code
223:24 - converter and syntax Checkers and they
223:27 - did all kinds of things where they would
223:28 - take certain libraries like the print
223:30 - function and then would put it in Python
223:32 - 3 then we backport it to python 2 so you
223:34 - could like switch from using the print
223:36 - statement to the print function and
223:38 - there were lots of things that made this
223:39 - transition as easy as possible the one
223:42 - thing that they really never could crack
223:45 - and we just had to bite the bullet and
223:47 - get used to it was python 2 returns
223:51 - integer and the division is truncated so
223:54 - if you do three four three divided by
223:56 - four is zero in Python 2 and in Python 3
224:01 - it's integer 3 divided by integer 4
224:04 - becomes floating Point
224:06 - 0.75 because that's what calculators do
224:10 - and the python 2 Division truncated
224:12 - because it didn't seem like it mattered
224:14 - much back in the 80s and C integer
224:17 - division
224:19 - truncated so 3/4 in C was zero and 3/4
224:23 - integer 3/4s was zero in C and so it was
224:26 - in Python and 20 plus years later that
224:29 - was the one thing we couldn't autocon
224:31 - convert and Python 3 does it the way
224:35 - python does
224:36 - so it's less of a problem in C because C
224:40 - is actually a strongly typed language
224:41 - which means if I wanted to say 3 over4
224:45 - I knew whether it was integers or floats
224:47 - and I could force that um and so but in
224:51 - in Python you just what's the variable
224:54 - and so that it imputes the variable type
224:56 - from the result of that
224:58 - expression where C has got a declare X
225:01 - as a float or a double or an in so when
225:03 - a c programmer writes a division they
225:04 - need to know they know already that they
225:07 - have to cast the values or use float
225:09 - constants to trigger type conversion and
225:11 - expressions so as you're looking through
225:12 - the chapters seeing these type
225:14 - conversions and casting uh that's the
225:16 - kind of problem that was solved but then
225:19 - python simplified it and then made it
225:22 - really kind of kind of luck uh kind of
225:25 - yucky and then they had to fix it it's
225:27 - better in Python 3 and most of you have
225:29 - just learned Python 3 so consider
225:32 - yourself
225:33 - lucky so another thing they talk about a
225:35 - lot and it has to do with as we start
225:37 - thinking about um storage allocation on
225:40 - a bit bybit basis we tend to need to
225:43 - know how how to represent and print
225:46 - things out not just in base 10 and it
225:48 - really has to do with the fact that um
225:51 - base 8 and base 16 are better at
225:53 - printing out binary data raw data 10 is
225:56 - the number like where you know how many
225:59 - pizzas do you want I want 16 pizzas or
226:01 - 22 pizzas it's it's our natural the way
226:04 - we think way humans think so talk about
226:06 - to talk about bases let's start by just
226:08 - reviewing what base 10 means there is
226:10 - you know the ones place and the 10's
226:12 - place and of course later there's
226:13 - hundreds and thousands but
226:15 - the the four and 42 represents 4 10 so
226:19 - you can think of it as 4 * 10 which is
226:22 - 40 and then the one's place is two more
226:26 - so 42 is 40 + 2 which is kind of
226:29 - redundant we do that
226:31 - instinctively so now let's take a look
226:33 - at base
226:34 - 8 so in 42 in base 10 is 52 in base 8
226:40 - and what base 8 is really doing is it
226:42 - means that the digits in the two places
226:44 - means something different meaning the
226:46 - five and 52 represents an
226:50 - eight so there's 58s in this number that
226:53 - we're dealing with and two ones and so 5
226:56 - * 8 is 40 and 2 * 1 is 2 and so
227:00 - converting from 52 base 8 to 52 base 10
227:04 - we get to 42 and we used base 8 and
227:07 - again base 8 lines up perfectly with
227:10 - base two because three base 2 digits
227:12 - equals one base 8 digit and I did a lot
227:16 - of Base 8 in the early days but base 16
227:18 - is really the way we tend to do it now
227:20 - because it's a little more dense the
227:22 - rightmost place is still the ones and
227:24 - the next place is the 16s so the two in
227:26 - the 16's Place represents 2 * 16 or 32
227:30 - and then what's left over is 10 which we
227:33 - represent with an A and 10 + 32 is 42
227:37 - now the problem is is we only have
227:39 - digits 0 through n so by convention 10
227:43 - is a 11 is B 12 is C 13 is D 14 is e and
227:48 - 15 is f f is all the ones it's four ones
227:52 - I know that I just like four ones so I
227:55 - can convert hex from hex to base two
227:59 - like very very quickly and if I need to
228:01 - look at some a dump of some memory I can
228:04 - dump it in HEX and then I can when I
228:06 - need to I can convert it to base two so
228:09 - just converting back and forth between
228:11 - base 16 and base two uh is a bit of a
228:14 - trick
228:15 - and I don't really care if you do much
228:17 - of this you can grab this sample code
228:19 - and play with it this is a conversion
228:21 - from base 10 Base number like 1 2 3 4 to
228:25 - base eight and then base
228:27 - 16 and the way this one does it is it
228:31 - converts the number in effect from the
228:34 - left the rightmost number up to the low
228:37 - the low digit up to the high digit and
228:40 - so what you do is you use the modulo
228:42 - function and so you take your number one
228:44 - 2 3 4 and you take it modulo
228:47 - 8 and what's left over as remainder is
228:50 - two so that's the far right number in
228:52 - the new one and then you chop it off
228:54 - with integer
228:56 - division you chop that off and see
228:58 - what's left and that's
229:00 - 154 and you're accumulating the two in
229:03 - the converted number and then you take
229:05 - the modulo of 154 modulo 8 and you get
229:08 - two and then you chop off the next eight
229:11 - with divide by integer divide by four
229:13 - and you get 19 so now you your bottom
229:16 - two digits are two two and then you do
229:19 - 19 modulo 8 and you get three and that
229:21 - next digit from the right is a three
229:23 - then you divide by eight integer divide
229:25 - by 8 to get what's left over and that's
229:27 - below eight and so that the fourth digit
229:30 - from the right is a two so 1 2 3 4 in
229:34 - base 8 is 2
229:36 - 322 and you can do the exact same thing
229:39 - the difference is you got to look up the
229:41 - digits
229:42 - because the base 16 needs the ab bcde e
229:45 - f and so I make a little string now go
229:48 - we're talking python here and so we do a
229:50 - we do repeatedly modulo 16 integer
229:53 - divide by 16 modulo 16 integer divide by
229:56 - 16 modulo 16 integer divide by 16 and so
229:59 - we take 1 2 3 4 and when we convert it
230:02 - to base 16 it's kind of comes up from
230:04 - the bottom as 2 D4 which we read 4d2 so
230:09 - that's just an algorithm that converts
230:11 - these you tend to you tend to use this
230:13 - modulo and that's how can convert from
230:16 - one base to another now it's not
230:18 - critical in this class we're not going
230:19 - to spend a lot of time converting bases
230:22 - but we just need to be aware that uh
230:25 - because there was so
230:27 - much awareness of how bits were stored
230:30 - we tended to print a lot of stuff out in
230:32 - heximal or in base eight and so I just
230:35 - want you to to know what those things
230:37 - are so if you look for example at the
230:39 - asy chart that we've already seen you
230:41 - see that it shows us that the letter a
230:43 - is 65 and in HEX it's 41 and in octal
230:47 - it's one1 and in base 2 or binary it's
230:51 - one and a bunch of zeros and a one and
230:53 - so this is this is just something that's
230:55 - making and you know in the old days you
230:57 - had to be just much more aware of the
231:00 - real bits inside the computer and hex
231:03 - and base 8 hex and octal were better
231:06 - ways to sort of know what the bits were
231:09 - um you know so there you
231:11 - go now another thing that uh C really
231:15 - was one of the early Innovative language
231:17 - was bite addressable computers right and
231:21 - so we don't think much everything's a
231:24 - string and we can look at the characters
231:26 - in The String but in the old days before
231:30 - c and the generation of computers that
231:32 - kind of triggered c um we didn't have
231:37 - characters you couldn't in the hardware
231:38 - load a character you could only load a
231:40 - word and then you had to find the
231:42 - character within the word and uh the
231:44 - language that really was the immediate
231:46 - precursor to C was the B language and
231:48 - the difference was is the B language was
231:50 - a really cool low-level word oriented
231:54 - language and then the C language came
231:56 - from B and became a bite oriented
231:58 - language and so C sort of like said
232:01 - we're going to do bite and dressing so
232:03 - if I take a look at the way I had to do
232:06 - character character support in a CDC
232:09 - 6500 which is the computer I was using
232:12 - in like 1975 1976
232:15 - it was a scientific computer it it
232:18 - barely cared about printing characters
232:20 - it didn't even have lowercase it had 60
232:23 - bit words and packed six-bit uppercase
232:26 - characters into those words and it used
232:29 - a series of zeros to fill it up and so
232:32 - if I put the word hello world words
232:34 - hello world into the CDC 6500 it took
232:38 - two words and hello space w r l was
232:43 - packed into the first word and D was in
232:45 - the second one and then we did what was
232:47 - called zero filling the rest of those
232:49 - characters were all zeros the integer
232:52 - zero
232:53 - 0000000000
232:54 - Z and if I wanted to know what the fifth
232:57 - character of this two-word string was
233:00 - like the O for example you would create
233:03 - a mask and in that mask you would have
233:06 - zeros where you wanted to get rid of
233:08 - stuff and ones where you wanted to copy
233:10 - stuff so you would take hello world and
233:12 - you'd run it through this mask with the
233:14 - bits in the right position and then you
233:16 - would get the O and all zeros in the
233:19 - rest of the word and then you would have
233:20 - to shift it half the way down because
233:23 - there were 10 characters so you had to
233:24 - shift it five characters to the right
233:28 - and then you would have the letter o in
233:31 - the bottom six bits of that word and
233:34 - then I could write an if statement
233:36 - that's how I would say if the fifth
233:38 - character is the letter O I had to
233:41 - extract the fifth character by hand so
233:44 - you can imagine how happy I was when I
233:47 - began to see programming languages that
233:49 - allowed me to use more of an array
233:51 - syntax and say string sub five or even
233:55 - in this case 0 1 2 3 four string sub
233:57 - four but I could treat characters as an
234:00 - array the notion of a character array
234:01 - for me in the 197 in
234:03 - 1977 was what why would you you know you
234:07 - couldn't do that right and so we you
234:11 - know a
234:13 - whole generation of programmers went go
234:17 - through their entire career without
234:18 - having to do any masking and shifting so
234:21 - this chapter is going to talk to you
234:22 - about it and you might say well if C was
234:24 - so good at doing it for you um why did
234:28 - they show it and that is that people
234:30 - like me would not have had respect for
234:32 - this language if it weren't for the fact
234:34 - that they had good masking and shifting
234:36 - CU we were doing that all the time in
234:38 - these word oriented computers and word
234:41 - oriented
234:42 - languages and just as C and Unix were
234:45 - making the world safe for characters
234:47 - then we had this other problem and I'm
234:50 - only going to talk a little bit about
234:52 - this just don't worry about it the
234:56 - concept of indianness so if you're
235:00 - loading words do you load them with the
235:04 - least significant digits first or the
235:07 - most significant digits first
235:12 - and most comp
235:14 - computers were big Indian and big Indian
235:18 - to us software developers made the most
235:20 - sense because that's how we thought it
235:21 - would lay out but it turns out
235:24 - that a few processors wanted to load if
235:27 - they were going to do an ad they wanted
235:28 - to Lo load the low end of the integer
235:31 - first so they could start the addition
235:32 - while they're adding bringing in the
235:33 - high end and they could overlap the load
235:36 - and the ad and then Intel which in those
235:41 - days wasn't all that popular but they
235:43 - were so so interested in the
235:45 - microprocessor performance that they
235:47 - became little Indian so that they
235:48 - loading an addition were fast and so
235:51 - we've been stuck with a lot of little
235:53 - Indian microprocessors since then and
235:55 - big Indian and little Indian it's it's
235:58 - one of the harder things to solve really
236:00 - it really is and so I'm going to show
236:02 - you some
236:03 - code I really I really all I want you to
236:07 - do is feel sorry for those of us who had
236:10 - to figure out little Indian and big
236:12 - Indian and let me just give you an out
236:14 - line of what this code is doing I'm not
236:16 - going to walk through it in detail it
236:18 - just is kind of scary so and and you're
236:22 - not even going to understand most of
236:24 - this code until chapter 5 it's just
236:26 - let's just talk a little bit about the
236:29 - bits and how masking and shifting would
236:31 - have worked if we didn't have character
236:33 - arrays so what I'm doing in this program
236:36 - is I'm creating a character array the
236:39 - length of this character array is hello
236:41 - world plus one for the Terminator h e l
236:44 - l o space w r l d so 11 + 1 uh should be
236:49 - 12 characters are allocated and then
236:52 - what I'm doing in this next line that
236:53 - says in Star SII is I'm actually saying
236:57 - I want to take the same storage and
236:59 - pretend it's an integer array and so
237:02 - that's what that line is is the it takes
237:04 - the address of the beginning of the
237:06 - first character and convert it from a
237:09 - pointer to a character which is Char s
237:12 - is a pointer to a character and have it
237:14 - be a pointer to an integer and again I'm
237:16 - sort of like jumping ahead in chapter 5
237:18 - so I'm I'm not expecting to understand
237:19 - all this I'm just just making you aware
237:22 - of it so in those first two lines I've
237:26 - got a character array and an integer
237:31 - array okay and this is a this is a
237:35 - 32-bit integer and so that means that um
237:39 - the characters are stuck into 32-bit
237:42 - integers in a little ending
237:45 - way and so if you look that means that
237:50 - if you just look at memory from left to
237:52 - right that the the lowest of the first
237:56 - four which is 32 bits the the first
238:00 - character that comes out is the L right
238:03 - and you can see the the little Indian
238:06 - which which in your mind should thinks
238:07 - it should be shifted but it's because
238:09 - this is running on a little Indian
238:10 - computer and different computers will
238:12 - give you different results and this is a
238:14 - a little endian
238:16 - example and so you can
238:19 - see with masking and shifting where I'm
238:23 - going to try to get the E out which
238:26 - would normally be the second character
238:28 - but it's kind of the second from the
238:29 - bottom of the first integer and so what
238:32 - I do is I make a
238:33 - mask and I'm going to print this out I
238:36 - take FF which is uh eight bits of ones
238:40 - and then I shifted up eight characters
238:42 - to the left and you can see that in the
238:44 - printout and then I mask out that
238:47 - character which is the e but then it's
238:51 - in the wrong position and then I have to
238:53 - take that masked result and I have to
238:54 - shift it back down eight so that it's in
238:57 - the bottom part so now I can check to
239:00 - see what that letter is this is how I
239:02 - would pull out the second character of a
239:04 - string so I could check to see if it's
239:06 - an e because I can't compare directly
239:09 - the second character of string right in
239:11 - Python you're like why are we doing this
239:14 - that's why you build a string class
239:16 - instead of use a character array for
239:18 - this and i' I made it even worse by like
239:21 - starting with taking a character array
239:23 - and viewing it as an integer array and
239:25 - then playing with the
239:27 - integers
239:30 - so you don't have to understand
239:33 - this just be thankful that you use
239:37 - Python and if you don't use Python use C
239:41 - and whether it's a big Indian or a
239:42 - little Indian machine you can you can
239:44 - treat an array of characters as an array
239:46 - of characters and you can get the third
239:48 - one or the fifth one with with a square
239:51 - bracket notation
239:54 - okay storage allocation storage
239:56 - allocation storage allocation so a
239:59 - summary of this lecture is we talked
240:01 - about number base conversion we talked a
240:03 - little bit about division why the python
240:05 - 2 integer division happened I I don't
240:08 - really have a really good answer for
240:09 - that concept of integers and words and
240:12 - bites and masking and shifting and
240:13 - characters just because these topics are
240:15 - covered in this chapter and they will
240:17 - feel very foreign to you and unnatural
240:20 - but just give them a shot read through
240:22 - them understand them and uh and they'll
240:25 - make sense later later we're going to
240:27 - learn about structures and pointers and
240:30 - addresses advancing and stuff like that
240:33 - it'll all make a lot more sense coming
240:35 - up
240:42 - [Music]
240:48 - welcome to C programming for everybody
240:50 - my name is Charles sance and this is my
240:53 - reading of the 1978 C programming book
240:55 - written by Brian kernigan and Dennis
240:57 - Richie at times I add my own
240:59 - interpretation of the material from a
241:01 - historical
241:03 - perspective chapter 2 types operators
241:06 - and expressions variables and constants
241:09 - are the basic data objects manipulated
241:11 - in a program declarations list the
241:14 - variables to be used and state what
241:15 - typee they have and perhaps what their
241:17 - initial values are operators specify
241:20 - what is to be done to them Expressions
241:22 - combine variables and constants to
241:24 - produce new values these are the topics
241:26 - of this chapter section 2.1 variable
241:30 - names although we didn't come out and
241:33 - say so there are some restrictions on
241:35 - variable and symbolic constant names
241:38 - names are made up of letters and digits
241:40 - the first character must be a letter the
241:42 - underscore counts as a letter it is
241:45 - useful for improving the readability of
241:46 - long variable names Upper and Lower
241:49 - cases are different traditional C
241:51 - practice is to use lowercase for
241:53 - variable names and all uppercase for
241:55 - symbolic
241:57 - constants only the first eight
241:59 - characters of an internal name are
242:00 - significant although more may be used
242:02 - for external names such as function
242:04 - names and external variables the number
242:06 - must be less than eight because external
242:08 - names are used by various assemblers and
242:11 - loaders appendix a list the details
242:13 - furthermore keywords like if else in
242:17 - float Etc are reserved you can't use
242:20 - them as variable names and they must be
242:22 - in lower
242:23 - case I would note that in modern CA
242:26 - languages the limitation of the first
242:27 - eight characters of a variable name
242:29 - being unique has been extended in most C
242:32 - variants at least 30 characters of a
242:34 - variable are treated as unique the
242:36 - character limitation was to reflect the
242:38 - typical limitation of identifier length
242:40 - in Assembly Language programming and
242:42 - runtime linkers of the time
242:45 - naturally it's wise to choose variable
242:47 - names that mean something that are
242:48 - related to the purpose of the variable
242:50 - and are unlikely to get mixed up
242:53 - typographically section 2.2 data types
242:56 - and sizes there are only a few basic
242:59 - data types in C Char which is a single
243:02 - bite capable of holding one character in
243:04 - the local character set int an integer
243:08 - typically reflecting the natural size of
243:10 - integers on the host machine float a
243:13 - single precision floating point and
243:15 - double is a double Precision floating
243:17 - point in addition there are a number of
243:19 - qualifiers which can be applied to int
243:22 - short long and unsigned short and long
243:26 - refer to different sizes of integers
243:28 - unsigned numbers obey the Ari arithmetic
243:32 - of modulo 2 to the N where n is the
243:34 - number of bits in an INT unsigned
243:36 - numbers are always positive the
243:39 - Declarations for qualifiers look like
243:41 - short int X semicolon long int y
243:47 - semicolon unsigned int Z
243:52 - semicolon the word int can be omitted in
243:54 - such situations and typically is the
243:57 - Precision of these objects depends on
243:59 - the machine at hand the table below
244:02 - shows some representative
244:04 - values on the deck pdp1 a Char is 8 Bits
244:08 - an in is 16 a short is 16 a Char is 32 a
244:12 - float is 32 a double is
244:15 - 64 on a Honeywell 6000 which uses asky
244:19 - character set a Char is nine bits an INT
244:21 - is 36 bits a short is 36 bits a Char is
244:25 - 36 bits and a float is 36 bits and a
244:27 - double is 32
244:29 - bits on the IBM 370 which is idic in its
244:34 - character set a Char is 8 Bits an INT is
244:36 - 32 bits a short is 16 bits a Char is 32
244:40 - bits a float is 32 bits and a double is
244:43 - 6 64 bits and so on the intent is that
244:47 - short and long should provide different
244:49 - lengths of integers where practical int
244:52 - will normally reflect the most natural
244:55 - size of a particular machine as you can
244:57 - see each compiler is free to interpret
245:00 - short and long as appropriate for their
245:02 - own Hardware about all you should count
245:04 - on is that short is no longer than
245:08 - long in this table we see that in the
245:11 - mid1 1970s C was designed to support a
245:14 - range of computer Generations the pdp11
245:17 - was a common previous generation
245:19 - computer that had less memory so
245:21 - variable sizes were kept small the more
245:23 - modern computers in the chart had a bit
245:25 - more memory and could afford to have
245:27 - slightly larger larger sizes the idea of
245:30 - a natural size is the size that could be
245:33 - loaded computed and stored in usually a
245:36 - single machine language instruction you
245:39 - knew as a programmer that when you used
245:40 - int the machine code you would generate
245:42 - would not need to include extra
245:44 - instructions for a simple line of code
245:47 - like xal x +1
245:49 - semicolon modern int values in C are 32
245:53 - bits long and long values are 64 bits
245:55 - long even though modern computers can do
245:57 - 64-bit computations in a single
245:59 - instruction using the shorter int type
246:02 - when appropriate can save on memory
246:03 - storage and memory bandwidth using int
246:06 - values interestingly the length of a
246:09 - 32-bit int leads to a Unix and C problem
246:12 - with dates that is called the year 2038
246:15 - problem a common way to represent time
246:18 - in Unix C programs was as a 32bit
246:21 - integer of the number of seconds since
246:24 - January 1st 1970 it was quick and easy
246:27 - to compare or add or subtract these
246:31 - second counter dates in code and even in
246:33 - databases but the number of seconds
246:36 - since January 1st 1970 will overflow a
246:39 - 30-bit number on the 19th of January in
246:41 - 2038
246:43 - by now in order to avoid systems in
246:46 - order to avoid problems most systems
246:48 - have converted to storing these number
246:49 - of second values in long or 64-bit
246:52 - values which gives us almost 300 billion
246:55 - years until we need to worry about
246:57 - overflowing second Tim counters
247:00 - again back when C was developed we had
247:03 - two different character sets and two
247:04 - different character variable lengths the
247:06 - world generally standardized on the asy
247:09 - character set for the core Western
247:11 - characters and the Unicode utf8 to
247:14 - represent all characters in all
247:16 - languages worldwide but that is a story
247:19 - for another time for now just think of
247:21 - the Char type as also a bite type it is8
247:25 - bits in length and can store asy modern
247:28 - languages like python or Java have
247:30 - excellent support for wide character
247:32 - sets in our historical look at C we will
247:35 - not cover wide or multi-b
247:37 - characters also if you look at the float
247:40 - and double types you will see different
247:42 - bit sizes
247:44 - even worse each of these computers in
247:47 - the 1970s did floating Point computation
247:49 - using slightly different hardware
247:51 - implementations and the same code run on
247:54 - different computers would give slightly
247:56 - different results and have unpredictable
247:58 - Behavior un overflow underflow and other
248:01 - extraordinary floating Point
248:03 - operations this was solved by the
248:05 - introduction of the i e
248:07 - 754 standard in 1985 which standardized
248:11 - floating Point format this standardized
248:14 - both the length of the float in the
248:15 - double but also ensured that the same
248:17 - set of floating Point calculations would
248:20 - produce the exact same result on
248:23 - different
248:24 - processors 2.3 constants int and Float
248:28 - constants have already been disposed of
248:30 - except to note that the usual
248:33 - 123.456
248:35 - eus 7 or
248:39 - 0.12 E3 scientific notation for floats
248:43 - is also legal every floating Point
248:46 - constant is taken to be double so the E
248:49 - notation serves for both float and
248:52 - double long constants are written in the
248:54 - style 1 2 3 capital L an ordinary
248:58 - integer constant that is too long to fit
249:00 - into an INT is also assumed to be a long
249:04 - there is a notation for octal and
249:06 - heximal
249:07 - constants a leading zero on an INT
249:10 - constant implies octal and a Le meting
249:14 - 0x or 0x uppercase indicates heximal for
249:19 - example the decimal 31 can be written as
249:22 - 037 in octal and
249:26 - 0x1f or
249:28 - 0x1f where f is capitalized in HEX
249:31 - heximal and octal constants may also be
249:34 - followed by the letter L to make them
249:37 - long a character constant is a single
249:40 - character written in single quotes as in
249:42 - quote X quote the value of the character
249:45 - constant is the numeric value of the
249:47 - character in The Machine's character set
249:50 - for example the asking character set
249:52 - zero or quote Zer quote is 48 and in
249:56 - idic quote Zer quote is 240 both quite
250:00 - different from the numeric value zero
250:03 - writing quote zero quote instead of a
250:05 - numeric value like 48 or 240 makes the
250:08 - program independent of the particular
250:10 - value character constants participate in
250:13 - numeric operations just like any other
250:15 - numbers although they are most often
250:18 - used in comparisons with other
250:20 - characters a later section treats
250:23 - conversion
250:25 - rules certain non-graphic characters can
250:28 - be represented in character constants by
250:30 - escape sequence like back sln for New
250:33 - Line back SLT for tab back sl0 for null
250:37 - back slashback slash for backs slash
250:39 - itself and back slash quote for single
250:42 - quote Etc
250:43 - these look like two characters but
250:45 - they're actually only one in addition an
250:48 - arbitrary bite-sized P bit pattern can
250:51 - be generated by
250:52 - writing single quote back slash and then
250:55 - three digits single quote where the
250:58 - three digits is 1 to three octal digits
251:01 - as in pound define space form feed
251:05 - single quote back
251:07 - sl14 single quote which is asking for a
251:10 - form
251:11 - feed we mentioned
251:13 - form feed here because in the 1970s we
251:16 - sent much of our output to printers
251:18 - physical printers a form feed was the
251:21 - character we would send to the printer
251:22 - to a to advance to the top of a new
251:26 - page the character constant quote back
251:30 - sl0 quote represents the character with
251:33 - the value zero quot back sl0 quote is
251:38 - often written instead of zero to
251:40 - emphasize the character nature of some
251:42 - expression
251:43 - expression a constant expression is an
251:47 - expression that only involves constants
251:50 - such expressions are evaluated at
251:51 - compile time rather than runtime and
251:54 - accordingly may be used in in any place
251:57 - a constant may be as in pound Define MAX
252:01 - Line
252:02 - 1000 Char line Open Bracket MAX Line
252:07 - plus one close
252:09 - bracket semicolon or seconds equals 60 *
252:16 - 60 *
252:18 - hours a string constant is a sequence of
252:21 - zero or more characters surrounded by
252:24 - double quotes as in double quote I space
252:28 - am space a space string double quote or
252:32 - double quote double quote which is a way
252:34 - to show an empty string the quotes are
252:38 - not part of the string but only serve to
252:40 - delimit it the same Escape sequences
252:43 - used for character constants apply in
252:45 - strings back SL double quote represents
252:47 - the double quote
252:49 - character technically a string is an
252:52 - array whose elements are single
252:54 - characters the compiler automatically
252:56 - places the null character back sl0 at
252:59 - the end of each such string so programs
253:01 - can conveniently find the end this
253:04 - representation means that there is no
253:06 - real limit on how long a string can be
253:09 - but programs have to scan one to
253:11 - completely determine its length length
253:14 - the physical storage required is one
253:16 - more location than the number of
253:18 - characters written between the quotes
253:20 - the following function sterin taking the
253:23 - parameter s Returns the length of the
253:25 - character string s excluding the
253:28 - terminal back
253:30 - sl0 sterlin open parentheses s closed
253:34 - parentheses Char s Open Bracket Clos
253:38 - bracket semicolon open curly brace int
253:41 - space I
253:43 - semicolon I equal 0 semicolon while
253:48 - parentheses S Sub I exclamation
253:53 - equals quote back sl0 quote close
253:57 - parentheses plus plus I
254:00 - semicolon return parentheses I
254:03 - parentheses semicolon Clos curly brace
254:07 - be careful to distinguish between the
254:09 - character constant and a string that
254:11 - contains a single character single quote
254:13 - X single quote is not the same as double
254:16 - quot X double quote the former is a
254:18 - single character used to produce the
254:20 - numerical value of the letter X in the
254:22 - machine's character set the latter is a
254:25 - character string that contains one
254:26 - character the letter X and a back
254:30 - sl0 section
254:32 - 2.4 all variables must be declared
254:34 - before use although certain declarations
254:37 - can be made implicitly by context a
254:39 - declaration specifies a type and is
254:42 - followed by a list of one or more
254:44 - variables of that type as in int lower
254:48 - comma upper comma step semicolon Char C
254:53 - comma line Open Bracket 1000 close
254:56 - bracket
254:57 - semicolon variables can be distributed
255:00 - among declaration in any fashion the
255:03 - list above could be could be equally
255:05 - well written as in lower semicolon int
255:09 - upper semicolon int step semicolon Char
255:12 - C semicolon Char line Open Bracket 1000
255:16 - close bracket semicolon the latter form
255:19 - takes more room but it is convenient for
255:21 - adding a comment to each declaration or
255:24 - for subsequent
255:25 - modifications variables may also be
255:28 - initialized in their declaration
255:30 - although there are some restrictions if
255:32 - the name is followed by an equal sign in
255:34 - a constant that serves as an initializer
255:37 - as in Char backs slash equals single
255:41 - quote backs slashback slash single quote
255:44 - semicolon int I equal 0 semicolon float
255:50 - EPS equal 1.0 eus 5 semicolon if the
255:55 - variable in question is external or
255:57 - static the initialization is done once
256:00 - only conceptually before the program
256:02 - starts executing explicitly initialized
256:05 - automatic variables are initialized each
256:08 - time the function they are in is called
256:10 - automatic variables for which there is
256:12 - no EXP explicit initializer have
256:14 - undefined that is garbage values
256:17 - external and static variables are
256:19 - initialized to Zero by default but it is
256:21 - a good style to State the initialization
256:24 - anyway we will discuss initialization
256:27 - further as new data types are
256:30 - introduced section 2.5 arithmetic
256:34 - operators the binary operators are plus
256:39 - minus asterisk and Slash and the modulus
256:43 - operator percent there is a unary minus
256:47 - but no unary plus integer division
256:51 - truncates any fractional fractional part
256:54 - the expression x% y produces the
256:58 - remainder when X is divided by Y and is
257:02 - thus zero when y divides X exactly for
257:06 - example a year is a leap year if it is
257:09 - divisible by four but not by 100 except
257:13 - years divisible by four are leap years
257:16 - therefore if parentheses year percent 4
257:19 - equal equal 0 and and year
257:24 - percent 100 not equal zero or year
257:29 - perent 400 equal equal Z it's a leap
257:33 - year else it's not the percent operator
257:37 - cannot be applied to float or
257:40 - double the plus and minus operators have
257:42 - have the same precedence which is lower
257:45 - than the identical precedence of
257:48 - asterisk slash and percent which are in
257:51 - turn lower than unary minus arithmetic
257:54 - operators group from left to right a
257:58 - table at the end of this chapter
257:59 - summarizes precedence and associativity
258:01 - for all
258:02 - operators the order of evaluation is not
258:06 - specified for associative and
258:07 - communative operators like asterisk and
258:10 - plus the compiler May rearrange a
258:13 - parenthesized computation involving
258:15 - these thus A Plus open parentheses B
258:18 - plus C closed parentheses can be
258:21 - evaluated as open parentheses a plus b
258:24 - closed parentheses plus C this rarely
258:27 - makes any difference but if a particular
258:29 - order is required explicit temporary
258:32 - variables might be used the action on
258:35 - overflow or underflow depends on the
258:37 - machine at
258:39 - hand I would note that the above
258:42 - paragraph allows the
258:47 - compiler I would note that the above
258:50 - paragraph allowing the compiler to
258:52 - reorder computations even in the
258:54 - parenthe presence of parentheses is
258:56 - known as the knr C Arrangement license
259:01 - as the author state it almost never
259:03 - makes a difference unless an expression
259:05 - contains a value computed in a function
259:07 - call or is there a poined lookup to find
259:09 - a value for the computation that might
259:11 - fail the the rule was subtly adjusted in
259:14 - the iso version of C but ISO C still
259:18 - does not strictly Force the order of
259:20 - otherwise communative operations even in
259:22 - the pr presence of
259:24 - parentheses the good news is that as
259:26 - long as you keep your expression simple
259:28 - you don't have to worry about this rule
259:30 - sometimes the real value of parentheses
259:32 - is to communicate your intentions to the
259:34 - human readers of your code if you are
259:36 - writing code that depends on the order
259:38 - of overflow function calls and pointer D
259:42 - references in a single mathematical
259:43 - expression perhaps you should break your
259:46 - expression into multiple statements
259:49 - section 2.6 relational and logical
259:52 - operators the relational operators are
259:55 - greater than greater than or equal less
259:58 - than less than equal they all have the
260:01 - same precedence just below them in
260:03 - precedence are the equality operators
260:05 - double equals and exclamation equals
260:08 - which have the same
260:09 - precedence relational have lower
260:12 - precedence than arithmetic operators so
260:14 - expressions like I less than limb minus
260:17 - one are taken as I less than open
260:20 - parentheses limb minus one closed
260:22 - parentheses as would be
260:24 - expected more interesting are The
260:26 - Logical connectives double Amper sand
260:29 - and double vertical bar and and
260:32 - or Expressions connected by double Amper
260:35 - sand or double vertical bar are
260:36 - evaluated left to right and the
260:38 - evaluation stops as soon as the truth or
260:41 - falsehood of the result result is known
260:44 - these properties are critical in writing
260:46 - programs that work for example here is a
260:50 - loop from the input function getline
260:52 - which we wrote in chapter 1 for
260:54 - parentheses I equal 0 semicolon I less
260:58 - than limb minus one double Ampersand
261:02 - parentheses C equals get Char open
261:04 - parentheses closed parentheses closed
261:06 - parthy not equal single quote back slash
261:09 - n single quote double ampersand C
261:13 - exclamation equal e f semicolon Plus+ I
261:19 - close
261:20 - parentheses S Sub I equals
261:23 - c clearly before reading a new character
261:26 - it is necessary to check that there's
261:27 - room to store the array so the test I
261:30 - less than limb minus one must be made
261:33 - first not only but if this test
261:36 - fails we must not go on and read another
261:39 - character similarly it would be
261:41 - unfortunate if C were tested against eof
261:44 - before get Char was called the call must
261:47 - occur before the character C is checked
261:50 - against do the Precedence of double
261:53 - Amper sand and is greater than that of
261:56 - double vertical bar or and both are low
261:59 - lower than the relational inequality
262:01 - operators so expressions like I less
262:05 - than limb minus one double %an
262:07 - parentheses C equals get Char open pen
262:09 - Clos P Clos pin not equal single quote
262:13 - back sln single quote double Ampersand c
262:16 - not equal EF needs no extra parentheses
262:19 - but since the parentheses of not equals
262:22 - is higher than assignment parentheses do
262:24 - need to be added in open pry equals get
262:28 - Char open print close print close print
262:30 - not equal back
262:32 - sln to achieve the desired
262:35 - result let's take a brief
262:39 - digression one of the great debates of
262:41 - the 1970s was how to use structured
262:44 - programming to avoid any use of go-to
262:46 - statements that lead to completely
262:48 - unreadable spaghetti code structured
262:51 - code was easier to read debug and
262:53 - validate structured code advocated for
262:56 - if then else else if while do loops and
262:59 - do while Loops where the loop exit test
263:01 - was at the top or the bottom of the
263:03 - loops
263:04 - respectively there was a move from
263:06 - flowcharts with lines boxes and arrows
263:09 - to to structured programming techniques
263:11 - like nshi niderman diagrams that youed
263:14 - used nested boxes to emphasize the
263:16 - structured nature of the
263:18 - code the proponents of each approach
263:20 - tended to approach the problem based on
263:22 - the language they used alal and Pascal
263:25 - programmers were strong Advocates of
263:26 - structured programming and those
263:28 - languages had syntax that encouraged the
263:31 - approach Fortran programs had Decades of
263:35 - flowchart use and style flowchart style
263:38 - thinking intended to avoid full adoption
263:41 - of structured programming
263:43 - Kuran and Richie chose a middle path and
263:45 - made it so that c could support both
263:47 - approaches to avoid angering either side
263:50 - of the structure programming debate one
263:53 - area where the structured code movement
263:55 - kept hitting a snag was implementing a
263:57 - loop that reads a file and processes
263:59 - data until it reaches the end of
264:02 - file the loop must be able to handle an
264:05 - empty file or no data at all there are
264:09 - three ways to construct a read and
264:11 - process until EOS Loop and none of the
264:13 - approaches are
264:15 - ideal the loop constructions that you
264:17 - can do are a top tested loop with prime
264:20 - a priming read before the loop a bottom
264:23 - tested loop with a read is the first
264:25 - statement in the loop and then if then
264:26 - else is the rest of the body of the loop
264:29 - a top tested infinite loop with a
264:31 - priming read and a middle test and exit
264:33 - and a top tested loop with a side effect
264:35 - read in the test of the loop which is
264:38 - the way that kerigan and Richie chose to
264:40 - document in this chapter
264:43 - all of this serves to explain the syntax
264:46 - while open parentheses open parentheses
264:49 - C equals getchar open print Clos print
264:52 - close parentheses not equal eof close
264:55 - parentheses open curly brace body of the
264:58 - loop closed curly brace this construct
265:00 - is a topped tested Loop which most
265:03 - programmers prefer and it folds the
265:05 - priming read and puts its value inside
265:08 - the variable
265:10 - C but since getch might also return eof
265:13 - we need to check if we actually receive
265:15 - no data at all and need to avoid
265:17 - executing the body of the loop or exit
265:19 - the loop if eof were defined as zero
265:24 - instead of n minus one the loop could
265:26 - have been written while open parentheses
265:29 - C equals getchar open paren Clos paren
265:31 - Clos parentheses open curly brace body
265:34 - of the loop Clos curly brace
265:36 - now the getar function returns a
265:39 - character or zero and the test itself is
265:41 - looking at the side side effect or
265:43 - residual value of the assignment
265:44 - statement to decide to start and or
265:46 - continue the loop
265:48 - body the problem with using zero is end
265:51 - file if you are reading a binary file
265:53 - like jpeg data a zero character might
265:55 - make perfect sense and we would not want
265:58 - to incorrectly end the loop because of a
266:01 - zero character in input data that does
266:02 - not end a
266:04 - file so we get the double parentheses
266:07 - syntax the side effect call to get Char
266:09 - and test the return value within the
266:12 - while
266:13 - test I'm quite confident that this is
266:15 - far more detail that you wanted he in
266:17 - Chapter 2 but is it is as good a time as
266:20 - any to understand how much thought goes
266:22 - into a programming language how it is
266:24 - designed and documented by the time we
266:27 - finish chapter 3 and look at the break
266:29 - and continue statements which are in
266:31 - languages like Python and Java you will
266:33 - see that this 50-year-old structured
266:36 - programming debate debate is still
266:39 - unresolved in the minds of many software
266:41 - Developers
266:43 - back to the book The unary negation
266:46 - operator logical negation operator
266:49 - converts a nonzero or true operand into
266:52 - zero and a zero or false operand into
266:55 - one a common use of exclamation which we
266:58 - often call bang is in constructions like
267:01 - if open parentheses exclamation point
267:03 - inward closed parentheses rather than if
267:07 - open parentheses inward equal equal zero
267:11 - it is hard to generalize about which of
267:12 - these two forms is better construction
267:14 - like exclamation in word read quite
267:17 - nicely as if not in word but more
267:20 - complicated ones can be hard to
267:23 - understand section 2.7 type conversions
267:27 - when operands of different types appear
267:29 - in Expressions they are converted to a
267:31 - common type according to a small number
267:33 - of rules in general the only conversions
267:36 - that happen automatically are those that
267:39 - make sense such as converting an integer
267:41 - to a floating point in an expression
267:43 - like f+ I Expressions that don't make
267:46 - sense like using a float in a subscript
267:49 - are
267:51 - disallowed first chars and ins may be
267:54 - freely intermixed in arithmetic
267:56 - Expressions every chart in an expression
267:59 - is automatically converted to an INT
268:01 - this permits considerable flexibility in
268:04 - certain kinds of character
268:05 - Transformations one is exemplified by
268:08 - the function a toi which converts a
268:10 - string of digits into its numeric
268:13 - equivalent a to Y open parentheses s
268:16 - closed parentheses Char s Open Bracket
268:19 - close bracket
268:20 - semicolon open curly brace int I comma n
268:25 - semicolon n equals z for parentheses I
268:29 - equals 0 semicolon S Sub I greater than
268:33 - or equal to quot 0 quote double
268:36 - Ampersand s subi less than or equal to D
268:40 - quote 9 quote semic
268:42 - Plus+ I closed
268:45 - parentheses n = 10 asterisk n plus s
268:51 - subi minus single quote 0 single quote
268:55 - semicolon return open parentheses n
268:58 - close parentheses semicolon close curly
269:00 - brace to end the function as we
269:02 - discussed in chapter one the expression
269:05 - S Sub I minus quot 0 quote gives the
269:09 - numeric value of the character stored in
269:11 - s subi because of values 0 1 Etc form a
269:15 - continuously increasing positive sequ
269:17 - positive sequence another example of the
269:21 - card chart int conversion is the
269:23 - function lower which mats A Single
269:26 - Character to lowercase for the asky
269:28 - character set only if the character is
269:31 - not an uppercase letter lower is
269:32 - returned
269:33 - unchanged here's a function lower open
269:37 - parentheses C closed parentheses int c
269:41 - semicolon open curly
269:43 - brace if open parentheses C greater than
269:46 - or equal to quote capital a quote double
269:50 - Amper C less than or equal to quote Z
269:55 - quote uppercase Z parentheses return
269:59 - open parentheses C plus quote lowercase
270:03 - a quote minus quote uppercase a quote
270:07 - Clos parentheses semicolon else return C
270:11 - this works for asky because the
270:13 - corresponding upper and lowercase
270:15 - letters are a fixed distance apart as
270:18 - numeric values and each alphabet is
270:20 - contiguous there is nothing but letters
270:22 - between a and z this later observation
270:26 - is not true of the idct character set on
270:28 - IBM 360 370 architectures so this code
270:31 - fails on such systems it converts more
270:34 - than
270:35 - letters there is one subtle point about
270:37 - the conversion of characters to integer
270:40 - the language does not specify whether
270:42 - character V where the variables of type
270:44 - Char are signed or unsigned quantities
270:47 - when Char is converted to an INT can it
270:50 - ever produce a negative number
270:53 - unfortunately this varies from machine
270:55 - to machine reflecting differences in
270:57 - architecture on some machines pdp1 for
271:01 - instance a Char whose leftmost bit is
271:04 - one will be converted to negative
271:06 - integer using S extension on others a
271:10 - Char is promoted to an INT by adding
271:12 - zeros at the Left End and is thus always
271:17 - positive the definition of c guarantees
271:19 - that any character in The Machine
271:21 - standard character set will never appear
271:23 - to be negative so these characters may
271:25 - be used freely in Expressions as
271:27 - positive quantities but arbitrary bit
271:30 - patterns stored in character variables
271:32 - may appear to be negative on some
271:34 - machines yet positive on
271:37 - others the most common occurrence of
271:39 - this situation is when the value Nega -1
271:41 - is used for eof consider the code Char c
271:47 - semicolon C equals get Char open PR Clos
271:50 - PR semicolon if open pren couble equals
271:55 - eof Clos PR dot dot dot on a machine
271:59 - which does not do sign extension C is
272:01 - always positive because it returns a
272:03 - Char yet eof is negative as a result
272:06 - this test always fails to avoid this we
272:09 - have been careful to use int instead of
272:11 - char
272:12 - for any variable which holds a value
272:15 - returned by the function
272:17 - getar the real reason for using int
272:19 - instead of char is not related to any
272:21 - questions of possible sign extensions it
272:24 - is simply that get Char must return all
272:26 - possible characters so that it can be
272:29 - used to read arbitrary input and in
272:31 - addition a distinct eof value thus its
272:34 - value cannot be represented as a car
272:37 - Char but must instead be stored as an
272:39 - INT
272:42 - as an aside since the book was written
272:44 - before the getar function was
272:46 - standardized the text is somewhat vague
272:48 - in this section shortly after the book
272:50 - was published getchar was put into the
272:53 - stdio.h library and declared to return
272:56 - an integer so as to accommodate all
272:59 - possible characters and the integer
273:01 - minus one value to indicate the end
273:04 - file the above code would be better
273:06 - written with C declared as an
273:09 - integer int c semicolon
273:12 - C equals get Char open PR Clos PR
273:14 - semicolon if open PR c equal eoff Clos
273:19 - PR dot dot dot while the conversion from
273:22 - Char to int may or may not have S
273:24 - extension and yes it still depends on
273:27 - the implementation 50 years later the
273:29 - conversion from int to char is
273:31 - predictable with the top bits being
273:33 - simply
273:34 - discarded if you're using the library
273:37 - function gets to read a file line by
273:39 - line we don't need to worry about this
273:41 - converion
273:42 - since git s returns a pointer to a
273:44 - character array I.E a string it
273:47 - indicates it reach has reached end of
273:48 - file by returning the null pointer I.E
273:51 - there is no more data to
273:54 - give back to the
273:56 - textbook another useful form of
273:59 - automatic type conversions is that
274:01 - relational expressions like I greater
274:03 - than J and logical Expressions
274:05 - constructed by double Amper sand and
274:06 - double vertical bar and Andor
274:08 - respectively are defined to have the
274:10 - value one if true true and zero if false
274:13 - thus the assignment is digit equals c
274:17 - greater than or equal to quote 0 quote
274:20 - double % C less than or equal to quote 9
274:23 - quote sets the variable is digit to one
274:26 - if C is a digit and zero if it's
274:29 - not in the if test of a in a test part
274:33 - of an if while or for True just means
274:36 - non
274:37 - zero implicit arithmetic conversions
274:41 - work much as expected in general if an
274:44 - operator likes C or asterisk for
274:46 - multiplication which takes two operators
274:48 - I.E a binary operator if it has operate
274:51 - oper of different types the lower type
274:54 - is promoted to the higher type before
274:55 - the operation proceeds and the result is
274:57 - the higher type more precisely for each
275:01 - arithmetic operator the following
275:03 - sequence of conversion rules is applied
275:06 - Char and short are converted to int and
275:08 - Float is converted to double then if
275:11 - either operand is double the other is
275:13 - converted to double and the result is
275:15 - double otherwise if either operand is
275:17 - long and the other is converted to Long
275:19 - the result is long otherwise if either
275:21 - operand is UN operand is unsigned the
275:24 - other is converted to unsigned and the
275:25 - result is unsigned otherwise the
275:29 - operands must be int and the result is
275:31 - in note that all float values in an
275:34 - expression are converted to double all
275:36 - floating Point arithmetic in C is done
275:38 - in double
275:40 - precision conversions take place across
275:43 - assignments the value of the right side
275:45 - is converted to the type of the left
275:48 - which is the type of the result a
275:50 - character is converted to an integer
275:51 - either by ass sign extension or not as
275:53 - described above the re reverse operation
275:56 - in Char is well behaved excess high
275:59 - order bits are simply discarded thus in
276:02 - in I semicolon Char c semicolon IAL C
276:07 - Cal I the value of C is unchanged and
276:11 - this is true true whether or not sin
276:13 - extension is
276:14 - involved if x is float and I is int then
276:18 - xal I and IAL X both cause conversions
276:23 - float to in causes truncation of any
276:26 - fractional part double is converted to
276:29 - float by rounding longer ins are
276:31 - converted to Shorter ones by or to chars
276:35 - by dropping excess high order
276:37 - bits since a function argument is an
276:40 - expression type conversions also take
276:42 - place when arguments are passed to
276:44 - functions in particular Char and short
276:47 - become int and Float becomes double and
276:50 - that is why we have declared function
276:51 - arguments to be int and double even when
276:54 - the function is called with Char and
276:56 - Float finally explicit type conversions
277:00 - can be forced also we call it coerced in
277:04 - any expression with a construct called
277:06 - the cast in the construction open
277:09 - parentheses type name closed parentheses
277:11 - expression the expression is converted
277:13 - to the named type by the conversion
277:15 - rules above the precise meaning of cast
277:18 - is in fact as if the expression were
277:21 - assigned to a variable of the specified
277:23 - type which is then used in place of the
277:26 - whole construction for example the
277:29 - library square root sqrt expects a
277:32 - double argument and will produce
277:34 - nonsense if inadvertently handed
277:36 - something else so if n is an
277:39 - integer sqr r t open parentheses open
277:43 - parentheses double closed parentheses n
277:45 - closed parentheses converts n to double
277:48 - before passing it to
277:50 - sqrt note that the cast produces the
277:53 - value of n in the proper type the actual
277:56 - content of n is not altered the cast
277:59 - operator has the same pre precedence as
278:01 - other unary operations as is summarized
278:04 - in the table at the end of this
278:08 - chapter section 2.8 increment and
278:11 - decrement operators C provides two
278:14 - unusual operators for incrementing and
278:16 - decrementing variables the increment
278:18 - operator Plus+ adds one to its operand
278:22 - the decrement operator minus minus
278:24 - subtracts one we have frequently used
278:26 - plus plus to increment variables as in
278:29 - if open parentheses C equals equals
278:32 - single quote back sln single quote
278:34 - closed parentheses Plus+ n l semicolon
278:38 - the unusual aspect is that Plus+ and
278:41 - minus minus may be used either as prefix
278:44 - operators I.E before the variable as in
278:47 - Plus+ n or postfix after the variable
278:50 - n++ in both cases the effect is to
278:53 - increment n but the expression the
278:56 - residual value of the expression Plus+ n
279:00 - increments n before using its value
279:03 - while n++ increments n after its value
279:06 - has been used this means that in a
279:09 - context where the value is used not just
279:12 - the effect Plus+ n and n Plus+ are
279:15 - different if n is five then xal n++
279:20 - semicolon sets X to 5 the old value but
279:25 - x = ++ n semicolon sets X to six the new
279:30 - value in both cases n becomes six the
279:34 - increment and decrement operators can
279:36 - only be applied to
279:38 - variables an expression like x equals
279:40 - open parthey i+ J closed parth
279:43 - parentheses Plus+ is
279:47 - illegal in a context where no value is
279:49 - wanted just incrementing effect as in if
279:52 - open parentheses C double equals single
279:55 - quote back slash n single quote closed
279:58 - parentheses n l++ semicolon choose
280:01 - prefix or postfix according to taste but
280:03 - there are situations where one or the
280:05 - other is specifically called for for
280:08 - example consider the function squeeze s
280:11 - comma C which removes all occurrences of
280:13 - the character C from the string
280:17 - s squeeze open parentheses s comma C
280:21 - closed parentheses Char s Open Bracket
280:25 - close bracket semicolon int c semicolon
280:29 - open curly brace int I comma J semicolon
280:33 - for parentheses i = j = 0
280:39 - semicolon S Sub I I not equal to single
280:44 - quote back sl0 single quote semicolon
280:47 - i++ closed
280:49 - parentheses if open parentheses S Sub I
280:53 - not equal to C Clos parentheses S Sub
280:58 - j++ closed parentheses equals S Sub
281:02 - I and outside the for Loop totally s
281:05 - subj equals back slash quot
281:12 - s subj equals quot back0 quot semicolon
281:17 - close curly
281:19 - brace each time a non c a character
281:23 - other than what's in the variable C
281:25 - occurs is copied into the current J
281:27 - position and only then is J incremented
281:30 - to be ready for the next character this
281:32 - is exactly equivalent to if open
281:35 - parentheses S Sub I not equal to C
281:37 - closed parentheses open curly brace s
281:40 - subj equal S Sub
281:43 - I semicolon j++ semicolon Clos curly
281:48 - brace another example of a similar
281:51 - construction comes from the getline
281:52 - function we wrote in chapter 1 where we
281:54 - can replace if open parentheses C equals
281:57 - quote back slash n quote Clos
282:00 - parentheses open curly brace s subi
282:02 - equal c semicolon Plus+ I semicolon Clos
282:07 - parentheses by the far more compact if
282:10 - parentheses c equal back sln quot close
282:14 - parentheses S Sub i++ equal c
282:19 - semicolon in a third example the
282:21 - function stir cat concatenates the
282:24 - string t to the end of the string s stir
282:27 - cat does assume that there's enough
282:28 - space in s to hold the
282:30 - combination here's the code stir cat
282:34 - open parentheses s comma T closed
282:36 - parentheses Char s Open Bracket close
282:40 - bracket comma T Open Bracket close
282:43 - bracket semicolon open curly brace int I
282:47 - comma J
282:49 - semicolon i = j = 0
282:52 - semicolon while open PR S Sub I not
282:58 - equal single quot back sl0 single quote
283:01 - Clos pren
283:03 - i++ in this we'd find the end of
283:06 - s while open parentheses open
283:09 - parentheses S Sub I ++ equals T sub j++
283:14 - close parentheses not equal back sl0
283:18 - close parentheses
283:20 - semicolon that code copies the rest of T
283:23 - into s Clos curly brace as each
283:27 - characters copied from T to S the
283:28 - postfix Plus+ is applied to both I and J
283:32 - to make sure they are in position for
283:34 - the next pass through the
283:36 - loop section 2.9 bitwise logical
283:40 - operators C provides a number of
283:42 - operators for bit manipulation these may
283:45 - not be applied to float or
283:48 - double Amper sand is bitwise and
283:51 - vertical bar is bitwise inclusive
283:54 - or carrot is bitwise exclusive or less
283:58 - than less than is left shift and greater
284:00 - than greater than is Right shift and
284:02 - till is one complement and it's a unary
284:05 - operator the bitwise and operator
284:09 - Ampersand is often used to mask off off
284:11 - some set of bits for example c equal n
284:15 - Ampersand
284:17 - 0177 sets to zero all but the lower
284:20 - seven bits of n the bit wise or operator
284:24 - is used to turn bits on xals X vertical
284:28 - bar mask sets to one the X bits that are
284:33 - set to one in
284:34 - mask you should carefully distinguish
284:36 - the bitwise operator Amper sand and
284:39 - vertical bar from The Logical connective
284:41 - giv double Amper sand and double
284:42 - vertical bar which imply left to right
284:45 - evaluation of a truth value for example
284:48 - if x is 1 and Y is two then X single
284:52 - Amper sand Y is
284:54 - zero while X double Amper sand Y is one
284:58 - think about that for a
285:00 - moment the shift operators less than
285:03 - less than and greater than greater than
285:05 - per perform left and right shifts
285:07 - respectively of their left oper End by
285:09 - the number of bit positions given by the
285:11 - right operand thus X less than less than
285:15 - two shifts X left by two positions
285:18 - filling the vacated bits with zero this
285:21 - is the equivalent to multiplication by
285:23 - four right shifting an unsigned quantity
285:26 - fills the vacated bits with zero right
285:29 - shifting a s quantity will fill the sign
285:31 - bits or arithmetic shift on some
285:34 - machines such as pdp1 and with and with
285:37 - zero bits logical shift on other the
285:41 - unary operator till yields the ones
285:44 - complement of an integer that is it
285:47 - converts each one bit into a zero bit
285:49 - and vice versa this operator typically
285:52 - finds use in expressions like X
285:56 - Ampersand till
285:59 - 077 which masks the last six bits of X
286:04 - to Zero note that X Ampersand till 077
286:08 - is independent of word length and is
286:11 - thus preferable to for example X
286:16 - Ampersand
286:17 - 0177 70 which assumes that X is a 16bit
286:22 - quantity the portable form involves no
286:24 - extra cause since keld 077 is a constant
286:28 - expression and thus evaluated at compil
286:32 - time to illustrate the use of some of
286:35 - the bit operators consider the function
286:36 - get bits open parentheses x comma P
286:40 - comma n which Returns the right adjusted
286:42 - nbit field of X that b begins at
286:45 - position P we assume that bit position
286:49 - zero is at the right end and that n and
286:51 - p are sensible positive values for
286:54 - example get bits open print X comma 4
286:58 - comma 3 close print Returns the three
287:01 - bits in bit positions Four 3 and two
287:03 - right
287:05 - adjusted here we go with the code get
287:08 - bits open PR X comma p comma n unsigned
287:13 - X comma P comma n semicolon open curly
287:17 - brace
287:18 - return open parentheses open parentheses
287:21 - x greater than greater than open
287:23 - parentheses p + 1 minus n closed
287:26 - parentheses Clos parentheses and
287:29 - Ampersand till open parentheses till
287:33 - zero less than less than in close
287:36 - parentheses close parentheses semicolon
287:38 - Clos curly
287:39 - brace X greater than greater than
287:42 - parentheses p + 1 minus n Clos
287:45 - parentheses moves the desired field to
287:46 - the right end of the word declaring the
287:49 - argument to be X declaring the argument
287:52 - X to be unsigned ensures that when it is
287:54 - right shifted vacated bits will be
287:56 - filled with zeros not sign bits
287:58 - regardless of the machine the program is
288:00 - run on till zero is all one bits
288:03 - shifting it left in bit positions with
288:07 - till zero left Shi uh till zero less
288:10 - than less and N creates a mask with the
288:12 - zeros in the rightmost end bits and ones
288:14 - everywhere else complimenting that with
288:18 - till makes a masks with ones in the
288:20 - rightmost
288:22 - bits bitwise operators may seem
288:24 - unnecessary for modern computers but if
288:27 - you look at the internal structure of
288:29 - tcpip packet the values are packed very
288:31 - tightly into the headers in order to
288:33 - save space c made it possible to write
288:36 - portable tcpi implementations on a wide
288:39 - range of hardware architectures
288:41 - bitwise operators also play an important
288:44 - role in encryption decryption and check
288:46 - some calculations modern languages like
288:48 - Java and python support bitwise
288:50 - operators following the same patterns
288:53 - that we established in C so that things
288:55 - like TCP IP and encryption algorithms
288:57 - can also be implemented in these
289:00 - languages by defining these operators it
289:03 - kept software developers from needing to
289:05 - write non-portable Assembly Language to
289:07 - implement these low-level features in
289:09 - operating systems in and libraries
289:12 - section 2.10 assignment operators and
289:16 - expressions Expressions such as IAL I +
289:19 - 2 in which the left hand side is
289:21 - repeated on the right can be written in
289:23 - the compressed form I plus equal 2 using
289:27 - an assignment operator like plus equals
289:30 - most binary operators operators like
289:32 - plus that have a left and right operand
289:34 - have a
289:36 - corresponding assignment operator op
289:38 - equals where op is one of Plus plus
289:41 - minus asterisk for multiplication slash
289:44 - for division percent for
289:47 - modulo less than less than left
289:50 - shift greater than greater than right
289:52 - shift ampers sign bitwise and carrot
289:56 - exclusive or vertical bar bitwise or if
290:00 - E1 and E2 are expressions then E1
290:05 - operand equals E2 is equivalent to E1
290:08 - equal E1 operand E2
290:11 - except that E1 is only computed once
290:13 - note the parenthesis around
290:17 - E2 X star = y + 1 is actually x = x *
290:25 - parentheses y + 1 Clos parentheses
290:27 - rather than x * y + 1 as an example
290:32 - function bit count counts the number of
290:33 - one bits in its integer
290:36 - argument here's the code bit count open
290:40 - parentheses and closed parentheses
290:42 - unsigned and
290:44 - semicolon open curly brace int
290:47 - B for open parentheses b equals 0
290:51 - semicolon n exclamation equals 0
290:55 - semicolon
290:57 - n greater than greater than equal 1
291:01 - close
291:03 - parentheses if open parthey n Ampersand
291:07 - 01 Clos parentheses B plus plus
291:12 - semicolon return open print B Clos print
291:16 - semicolon curly brace quite apart from
291:19 - its conciseness assignment operators
291:22 - have the advantage in that they
291:23 - correspond better to way the way people
291:25 - think we said we say add two to I or
291:28 - increment I by two not take I add two
291:31 - and put the result back in I thus I plus
291:35 - equal 2 in addition for a complicated
291:38 - expression like y y L Open Bracket y ypv
291:44 - Open Bracket P3 plus P4 close bracket
291:48 - plus y y PV Open Bracket P1 plus P2
291:52 - close
291:53 - bracket close bracket plus equals 2 the
291:56 - assignment operator makes it code easier
291:58 - to understand since the reader doesn't
292:00 - have to check painstakingly that two
292:02 - long expressions are indeed the same or
292:05 - wonder why they're not an assignment
292:08 - operator may even help the compiler to
292:10 - produce more efficient code we have
292:12 - already used the fact that the
292:14 - assignment statement has a side effect
292:16 - value and can occur in Expressions the
292:19 - most common example is while open
292:22 - parentheses open parentheses C equals
292:24 - get Char open parentheses closed
292:25 - parentheses closed parentheses
292:28 - exclamation equal e closed parentheses
292:30 - and then the rest of the
292:32 - loop assignments using other assignment
292:35 - operators plus equal minus equal can
292:37 - also occur in Expressions although it's
292:39 - a less frequent occurrence
292:41 - the type of an assignment expression is
292:42 - the type of its left operand section
292:46 - 2.11 conditional
292:48 - Expressions the statements if
292:51 - parentheses a greater than b Clos
292:53 - parentheses Z equals a semicolon else Z
292:57 - equals B semicolon of course compute Z
293:00 - in the maximum of A and B the
293:03 - conditional expression written with a
293:05 - trinary operator which is question mark
293:07 - and colon provides an alternate way to
293:09 - write this and similar constructions in
293:12 - the expression E1 question mark E2 colon
293:16 - E3 the expression E1 is evaluated first
293:20 - if it is non zero true then the
293:22 - expression E2 is evaluated and that is
293:25 - the value of the conditional expression
293:27 - otherwise E3 is evaluated and that is
293:29 - the value only one of E2 and E3 are
293:32 - evaluated thus to set the Z to set Z to
293:36 - the maximum of A and B we say Z equals
293:40 - Pro parentheses a greater than b close
293:43 - parentheses question mark a colon B and
293:47 - this implements Z equals Max of A and B
293:51 - it should be noted that the conditional
293:53 - expression is indeed an expression and
293:55 - can be used just as any other expression
293:58 - if E1 and E if E2 and E3 are different
294:01 - types the type of the result is
294:03 - determined by the conversion rules
294:04 - described earlier in this chapter for
294:06 - example if f is a float and N is an INT
294:09 - then the expression
294:11 - parentheses n greater than zero Clos
294:13 - parentheses question mark F colon n is
294:17 - of type double regardless of whether n
294:20 - is positive or not parentheses are not
294:23 - necessary around the first expression of
294:25 - a conventional expression since the
294:27 - Precedence of question mark colon is
294:29 - very low just above assignment they are
294:32 - advisable anyway however since they make
294:34 - the condition part of the expression
294:36 - easier to
294:37 - see the conditional expression often
294:40 - needs to succinct code for example this
294:43 - Loop print prints n elements of an array
294:46 - 10 per line with each column separated
294:48 - by one blank and with each line
294:50 - including the last terminated by exactly
294:52 - one new line here's the code four
294:56 - parentheses I equals 0 semicolon I less
294:59 - than n semicolon I ++ Clos parentheses
295:03 - print F open parentheses double quote
295:06 - percent 6D percent
295:09 - C double quote comma a sub I
295:14 - comma open parentheses i% 10 equal
295:20 - 9 or double vertical bar I equal n
295:24 - minus1 Clos parentheses question mark
295:28 - single quote backs slash and single
295:29 - quote colon single quote space single
295:33 - quote close parenthesis semicolon a new
295:36 - line is printed after every 10th element
295:39 - and after the nth and all elements are
295:41 - followed by one blank although this
295:43 - might look tricky it's instructive to
295:45 - try to write it without the conditional
295:47 - expression section 2.2 precedence in
295:50 - order of evaluation the table below
295:53 - summarizes the rules for precedence and
295:55 - associativity of all operators including
295:58 - those which we have not yet discussed
296:00 - operators on the same line have the same
296:02 - precedence rows are in order of
296:04 - decreasing precedence so for
296:07 - example asterisk slash and percent all
296:10 - have the same precedence Which is higher
296:12 - than that of plus and
296:15 - minus parentheses square brackets the
296:19 - arrow operator and the dot operator are
296:22 - first with the right left to right
296:26 - associativity next precedence is
296:29 - exclamation till plus plus minus minus
296:34 - single
296:37 - minus the cast
296:42 - multiplication bitwise and size of with
296:45 - left with right to left
296:48 - associativity then multiplication
296:50 - division and modulo with left right
296:54 - associativity then plus and minus with
296:56 - left to right
296:58 - associativity then left shift Which is
297:01 - less than less than and right shift
297:03 - which is right greater than greater than
297:05 - with left to right
297:07 - associativity then logical operators
297:09 - less than less than or equal to greater
297:11 - than or greater than or equal to with
297:13 - left to right
297:14 - associativity then comparison double
297:17 - equals not equal exclamation equal left
297:20 - to right then we have some bitwise
297:22 - operators the bitwise and with left to
297:25 - right associativity then the bitwise
297:29 - exclusive or with Left Right
297:30 - associativity which is a carrot then the
297:34 - single vertical bar which is bitwise or
297:36 - with left to right
297:37 - associativity then we have Amper sand s
297:40 - which is and the logical and left to
297:43 - right associativity then double vertical
297:45 - bar which is the logical or with left to
297:48 - right associativity then the ternary
297:50 - operator which is question mark and
297:52 - colon with right to left
297:54 - associativity then the assignments
297:58 - equals plus equals minus equals Etc with
298:01 - right to left associativity and then the
298:03 - comma which we'll cover in the next
298:05 - chapter with left to right associativity
298:08 - The Operators Dash greater than and Dot
298:11 - are used to access members of structures
298:13 - they'll be covered in chapter six along
298:15 - with size of in ch and then in chapter
298:19 - five we'll discuss asterisk in Direction
298:22 - and Ampersand address of note that the
298:25 - Precedence of The bitwise Logical
298:27 - operators Ampersand carrot and vertical
298:29 - bar flws below double equals and
298:32 - exclamation equals that this implies
298:35 - that bit bit testing expressions like if
298:38 - parentheses parentheses X Amper sand
298:41 - Mass closed parentheses equal equal Z
298:44 - closed parentheses must be fully
298:46 - parenthesized to get proper
298:49 - results as mentioned before Expressions
298:52 - evolving one or more of the associative
298:54 - and commutative operators like multiply
298:57 - plus bitwise and bitwise or bit and
299:01 - bitwise exclusive or can be rearranged
299:03 - even when parenthesized in most cases
299:05 - this makes no difference whatsoever in
299:08 - situations where it might explicit
299:10 - temporary variables can use to force a
299:12 - particular order of
299:14 - evaluation C like most languages does
299:16 - not specify in what order operands of an
299:19 - operator are evaluated for example in a
299:22 - statement like xals f open parentheses
299:25 - closed parentheses plus G open
299:27 - parentheses closed parentheses semicolon
299:30 - F may be evaluated before v g or vice
299:33 - versa thus if F or G Alters an external
299:37 - variable that the other depends on x X
299:40 - can depend on the order value of
299:42 - evaluation again intermediate results
299:45 - can be stored in temporary variables to
299:48 - ensure a particular
299:49 - sequence similarly the order which
299:52 - function arguments are evaluated is not
299:55 - specified so the statement print F open
299:59 - parentheses double quote percent d space
300:02 - percent D back sln double quote comma
300:05 - Plus+ n comma power open parentheses 2
300:09 - comma n Clos parentheses Clos
300:11 - parentheses is wrong it can and often
300:14 - does produce different results on
300:16 - different machines depending on whether
300:18 - or not n is incremented before power is
300:20 - called the solution of course is to
300:22 - write Plus+ n
300:25 - semicolon print F open parentheses
300:28 - double quote percent d space percent D
300:30 - back sln double quote comma n comma
300:34 - power open parentheses 2 comma n close
300:36 - parentheses close
300:38 - parentheses function calls nested
300:40 - assignment statements and increment and
300:42 - decrement operators cause side effects
300:45 - some variable is changed as a byproduct
300:47 - of the EV valuation of an expression in
300:50 - any expression involving side side
300:52 - effects there can be subtle dependencies
300:54 - on the order in which variables taking
300:56 - part in the expression are
300:58 - stored one unhappy situation is typified
301:02 - by the statement a sub I equals
301:06 - i++ the question is whether or not the
301:09 - subscript is the old value of I or the
301:11 - new value the compiler can do this in
301:14 - different ways and generate different
301:16 - answers depending on its
301:18 - interpretation when side effects I.E
301:21 - assignment to actual variables takes
301:23 - place is left to the discretion of the
301:25 - compiler since the best order strongly
301:28 - depends on machine architecture the
301:30 - moral of this discussion is writing code
301:32 - which depends on the order of evaluation
301:35 - is a bad programming practice in any
301:38 - language now naturally it is necessary
301:41 - to know what things to avoid but if you
301:43 - don't know how they are done on various
301:45 - machines that innocence may help to
301:47 - protect you the C verifier lint will
301:51 - detect most dependencies on order of
301:54 - evaluation I would add that the real
301:56 - moral of the story is to use side effect
301:58 - operators very carefully they are
302:01 - generally only used in idiomatic
302:03 - situations and then use it written using
302:05 - simple code the authors are happy to
302:08 - tell you everything that you can do and
302:11 - see in great detail and they are also
302:14 - suggesting that just because you can do
302:16 - something does not mean that you should
302:17 - do something remember that a key aspect
302:20 - of writing programs is to communicate
302:22 - with future human readers of your code
302:25 - including you reading your own code in
302:27 - the future with modern-day compilers and
302:30 - optimizers you gain little performance
302:33 - by writing DSE or obtuse code write the
302:36 - code describe what you want done and let
302:38 - the compiler find the best way to to do
302:40 - it one of the reasons that a common
302:42 - senior project in many computer science
302:44 - degrees was to write a compiler is to
302:46 - make sure that all computer
302:49 - scientists understand that they can
302:51 - trust the compiler to generate great
302:54 - code this work is based on the 1978 C
302:59 - programming book written by Brian W
303:01 - kernigan and Dennis M Richie their book
303:04 - is copyright All Rights Reserved by AT&T
303:07 - but is used in this work under fair use
303:09 - because of the book's historical and
303:11 - scholarly significance its lack of
303:14 - availability and the lack of an
303:15 - accessible version of the book the book
303:18 - is augmented in places to help
303:19 - understand Its Right Place in a
303:21 - historical context amidst the major
303:23 - changes of the 1970s and 1980s as
303:26 - computer science evolved from a hardware
303:28 - first vendor centered approach to a
303:31 - software centered approach where
303:32 - portable operating systems and
303:34 - applications written in C could run on
303:36 - any
303:37 - hardware this is not the idea book to
303:40 - learn SE programming because the 1978
303:42 - Edition does not reflect the modern sea
303:44 - language using an obsolete book gives us
303:47 - an opportunity to take students back in
303:49 - time and understand how the sea language
303:52 - was evolving as it laid the groundwork
303:54 - for a future with portable applications
303:59 - [Music]
304:13 - hello welcome to chapter 3 I'm Charles
304:15 - Severance and I'm your instructor so
304:17 - here in chapter 3 again I'm just I want
304:20 - you to read the book I'm just going to
304:21 - call your attention to a few of the
304:24 - unique things that uh might help you
304:26 - make more sense of the book so we're
304:29 - going to talk about semicolon use how
304:31 - it's uh started in Sea and is used
304:33 - across multiple languages how elsif is a
304:35 - little different across
304:36 - languages the switch statement a bit of
304:39 - motivation the switch statement is even
304:41 - Inc um the comma comma I don't know
304:44 - operator separator and then sort of this
304:48 - this tendency towards excessive
304:50 - succinctness or brevity that uh is
304:52 - pretty common in uh C programming right
304:56 - it just it's like it's there's such a
304:58 - value in making things really really
305:00 - short and that makes it kind of
305:02 - different so I love semicolon based
305:06 - languages and we have a whole bunch of
305:09 - semicolon based languages that that
305:11 - we've learned and are going to learn um
305:14 - certainly 1978 the C programming
305:17 - language with its you know non non
305:20 - syntactically important spacing um the
305:23 - key to C is that c the semicolon is a
305:26 - terminator and every statement must be
305:28 - terminated by a semicolon so we say xal
305:31 - X+1 semicolon and xal x divided two
305:34 - semicolon right and that's that's the
305:36 - idea the print F ends in a
305:38 - semicolon so you may or may not know in
305:41 - Python you're allowed to have semicolons
305:43 - they're pretty much optional like on the
305:46 - print open print X Clos print that
305:48 - semicolon does not need to be there but
305:50 - it is a separator not a Terminator so
305:53 - you can think of the print open print X
305:55 - Clos PR semicolon as one statement
305:59 - followed by a separator followed by an
306:00 - empty statement which does nothing but
306:03 - the interesting thing is you can put
306:05 - more than one line on one line you can
306:09 - put more than one line of Code by put
306:10 - using a separator so there I say x = x +
306:13 - 1 semicolon x = x over2 semicolon I
306:17 - don't have to indent that I just it it
306:19 - it's two two lines in the same block of
306:22 - code and that's legal most of the time
306:26 - people choose not to use semicolon the
306:29 - other thing about that is that shell
306:31 - scripting which is sort of the Linux
306:34 - automation uh treats it as a separator
306:36 - and so that sort of looks a bit like
306:37 - shell scripting to have multip
306:39 - statements on the same line uh separated
306:42 - by semicolons in Java it tends to follow
306:47 - the C pattern where it's a Terminator I
306:50 - tend to like it as a Terminator I don't
306:52 - like the idea that you can leave it off
306:54 - the way JavaScript does and so you see
306:56 - it's on two assignment statements and
306:58 - the system out print Lin in
307:01 - Java in PHP PHP follows C very closely
307:05 - and so it is um it is a Terminator there
307:09 - as well and so that I I think that's
307:12 - natural and the good news if it's a
307:13 - separator like in JavaScript in the next
307:15 - example where it's separating it and so
307:19 - in this case the xal x / 2 does not need
307:22 - to be terminated because the closed
307:24 - curly brace is going to going to
307:26 - terminate that and um and like even the
307:29 - console.log open print Clos print
307:32 - semicolon that semicolon is optional
307:35 - when I tend to write JavaScript I tend
307:37 - to put semicolons everywhere when I tend
307:39 - to write python I put semicolons nowhere
307:43 - and then in phpc and Java I tend to you
307:46 - know put semicolons everywhere even
307:49 - though sometimes there are things you
307:50 - can leave out another thing that is very
307:54 - very subtle is the notion of else if so
307:59 - C predates Python and um C in this book
308:04 - shows else if has two separate words and
308:08 - there's an else keyword and an if
308:10 - keyword and so you say else space if and
308:13 - then you have the expression and another
308:15 - statement else space if expression and
308:18 - another statement and then else for the
308:20 - one where none of those expressions are
308:21 - true and if you look at python it looks
308:24 - almost identical it says if expression
308:27 - then L if expression L if expression and
308:31 - else the key is that L if is a separate
308:36 - language construct in Python and I think
308:39 - it's actually really beautiful and
308:41 - elegant and the key is is that this else
308:44 - if while it is I can think of it in C as
308:47 - like indented
308:48 - incorrectly so you can look at it is the
308:51 - very first if has an if and an else and
308:55 - everything from the second if on down is
308:57 - really part of that else and so if you
309:00 - look to the right you see the curly
309:02 - braces with the entation that's explicit
309:04 - it's exactly the same thing but what
309:07 - you're going to see is you can see that
309:09 - it's if you were going to truly
309:11 - correctly indent an if else if else if
309:15 - else in C you would indent it the way
309:17 - it's shown on the right side and it it's
309:20 - neither here nor there very very it is
309:24 - very rare that you would see anyc
309:26 - programmer you know do all the
309:27 - indentation the technically right way
309:29 - but I just want to call your attention
309:31 - to it that it's different than LF LF is
309:34 - its own language element that is not a
309:37 - deeper nesting deeper and deeper nesting
309:39 - if you were to Nest it you see on the
309:40 - right hand side you see I've got three
309:42 - Cur closed curly braces curly brace
309:45 - curly brace curly brace and it's just so
309:47 - the LF I think is a really elegant
309:49 - addition that python has added the
309:53 - switch
309:55 - statement I I think that the reason that
309:58 - the authors put the switch statement
310:00 - into C is there was a time where we
310:04 - would write code in Assembly Language
310:07 - using what we call a jump table where
310:09 - where we take sort of the take a number
310:11 - maybe take it mask it so it's only from
310:14 - 0 through 16 and then look up a series
310:16 - of addresses and jump through a jump
310:18 - table and the computed go-to was the way
310:22 - in Fortran of expressing a jump table
310:24 - but in Fortran it was just a mess you
310:27 - got these you got these labels and
310:29 - columns 1 through six and the continue
310:31 - statement doesn't work like the Contin
310:33 - in and c and and C like languages and
310:36 - you had to have these go-tos to get out
310:38 - of the the switch statement if you think
310:41 - about it from an Assembly Language
310:42 - perspective it's not that hard to build
310:44 - the computed goto with a little tiny
310:46 - jump table um and so I I think to some
310:50 - degree whether or not we have to use a
310:52 - jump table in modern C is really it's
310:55 - really really rare where you have to use
310:57 - a jump table we just would do a few
310:59 - repeating Els and it's just fine back
311:02 - then a few extra statements might have
311:05 - bothered something if you were going to
311:06 - do it a million times a you know a
311:08 - million times a minute or something the
311:10 - switch statement is much prettier you do
311:12 - have to put The Brak statements in there
311:13 - you can kind of Nest the ca you have the
311:15 - Stacked cases and then there's a default
311:17 - case so if I at least I compare the C
311:20 - switch statement with the Fortran
311:23 - computed goto I want to say that the C
311:25 - switch statement was pretty much a lot
311:27 - more elegant a lot easier to use a lot
311:29 - easier to understand and because
311:31 - Assembly Language programmers of the
311:33 - time did think in terms of jump tables
311:35 - if a highlevel language didn't have a
311:37 - way to express a jump table
311:39 - in that language then we would kind of
311:41 - think of it as missing but frankly you
311:45 - know in your programming I I'm not sure
311:47 - I've written a switch statement in
311:49 - because Java has a switch statement too
311:51 - I probably haven't written a switch
311:52 - statement in over 20 years and maybe
311:55 - more so I I like the fact that it
311:58 - improved on Fortran but that doesn't
312:00 - mean that that you should use
312:01 - it the comma operator or comma separator
312:05 - it's I like to think of it as like a
312:07 - light version of the semicolon
312:09 - and um most people almost never use it
312:14 - and the only place we use it is uh when
312:17 - it is sort of uh idiomatic where in a
312:20 - four statement because we're already
312:22 - using semicolon to separate the start
312:25 - before the loop the loop test and then
312:27 - the
312:28 - loop increment per iteration we're using
312:31 - semicolon for that so if we want to do
312:33 - like two statements we going to like oh
312:36 - I equals z J equal sterland s minus1
312:39 - with a comma in between to say do these
312:41 - two things before the loop starts and
312:44 - then at the end you say i++ comma J
312:46 - minus minus it says do these two things
312:49 - at the end of each Loop so I only see it
312:52 - in idiomatic situations just think of it
312:55 - as like we couldn't use a semicolon here
312:58 - it functions exactly like a semicolon
313:01 - although the syntax already has a
313:02 - semicolon it so I I think it's actually
313:04 - a pretty clever um way to say I want to
313:08 - put two statements in here you could
313:09 - maybe you could put curly braces in
313:10 - there or something but I thought the
313:12 - comma was a pretty cool
313:14 - thing another problem is that there was
313:18 - just this notion that we as Assembly
313:20 - Language programmers we could do things
313:23 - like be smart and leave some value in a
313:26 - register and then check the register a
313:27 - couple of different ways and that would
313:29 - lead to really succinct fast code hand
313:33 - tune code where you might have to look
313:35 - at it to figure out what it's doing but
313:37 - then you realize well I I did got in six
313:39 - statements rather than 12 statements 12
313:41 - statements might have made more sense
313:43 - but the six statements were really fast
313:45 - and in the early days in the early 70s
313:47 - they were changing their compilers so
313:50 - fast and changing their Hardware so fast
313:52 - that they really didn't build um super
313:55 - great optimizing compilers so they would
313:57 - look at the source code that came out of
313:59 - the compiler and like I could do better
314:01 - than that so there was a lot of a kind
314:03 - of comparison of the source code um
314:07 - between the what the C compiler generate
314:09 - and whatever and so they found over time
314:12 - that if they would kind of use these
314:14 - tricks that like told the compiler to
314:17 - like take this C equals get charar and
314:20 - leave the C in a register and compare it
314:23 - to double to a space and then compare it
314:26 - again to a new line and compare it again
314:28 - to a tab we would think oh I I can see
314:30 - how that would run in Assembly Language
314:32 - and I can hope that the compiler would
314:35 - generate the Assembly Language that um
314:39 - compiler would generate Assembly
314:40 - Language that would make me happy and
314:42 - then another pattern you see in this is
314:44 - the number four thing where all the
314:45 - work's been done in the loop test it's a
314:49 - y Loop that whole big expression is just
314:50 - a test to know when it's done but it's
314:53 - actually reading the data comparing it
314:55 - three times storing it in a variable and
314:58 - when that's all done there's nothing to
315:00 - do in the loop and so that's why you say
315:01 - close pen uh semicolon and you'll see a
315:05 - lot of those things especially when
315:06 - you're doing string stuff where you're
315:07 - sort of zooming through an array and you
315:09 - did it all in the for Loop and you don't
315:11 - really have anything to do in the for
315:12 - Loop and again we're thinking in the
315:16 - early days of how this is going to
315:17 - translate into Assembly Language and so
315:19 - you're trying to make that Loop really
315:20 - really small and again it's amazing how
315:23 - often they looked at the resulting
315:24 - Assembly Language um in a non-optimizing
315:27 - compiler situation and then wondered if
315:29 - the compiler could have done
315:31 - better so that gets us going in uh this
315:34 - chapter we talked about the semicolon we
315:36 - talked about the switch statement the if
315:39 - subtle syntax difference between Python
315:41 - and C the comma and just get used to the
315:45 - notion that it's obtuse code please
315:47 - don't write obtuse code these days the
315:49 - optimizers are so great and uh and so
315:53 - don't write obtuse code but don't be too
315:55 - upset as you read the textbook and see
315:57 - obtuse code
316:03 - [Music]
316:10 - welcome to C programming for everybody
316:13 - my name is Charles sance and this is my
316:15 - reading of the 1978c programming book
316:18 - written by Brian kernigan and Dennis
316:20 - Richie at times I add my own
316:22 - interpretation of the material from a
316:24 - historical
316:26 - perspective chapter 3 control flow the
316:30 - control flow statements of a language
316:32 - specify the order in which the
316:34 - computations are done we have already
316:36 - met the most common control flow
316:39 - constructions of C in earlier examples
316:42 - here we will complete the set and be
316:43 - more precise about the ones discussed
316:46 - above 3.1 statements and blocks an
316:51 - expression such as xal 0 or i++ or
316:56 - printf open pen dot dot dot Clos pen
316:59 - becomes a statement when it is followed
317:01 - by a semicolon as in X = 0 semicolon I
317:07 - ++ semicolon
317:09 - print F open parentheses something
317:12 - closed parentheses semicolon in C the
317:15 - semicolon is a statement Terminator
317:18 - rather than a separator as it is in alol
317:22 - like
317:23 - languages the braces the curly braces
317:26 - open curly brace and closed curly brace
317:28 - are used to group declarations and
317:30 - statements together into a compound
317:33 - statement or block so that they are
317:35 - syntactically equivalent to a single
317:37 - statement the braces that actually
317:40 - surround the statements of a function
317:42 - are one obvious example braces around
317:45 - multiple statements after an if else
317:47 - while or for or another variables can
317:51 - actually be declared inside any block we
317:54 - will talk about this in chapter 4 there
317:57 - is never a semicolon after the right
317:59 - curly brace that ends a
318:02 - block ah see how do I love thee let me
318:06 - count the ways uh quote by Dr Chuck with
318:09 - homage to Elizabeth Barrett
318:12 - Browning The Humble semicolon is why
318:14 - spacing and line ends do not matter in C
318:17 - and SE like languages it means that we
318:20 - as programmers can focus all of our
318:22 - white space and line ends on
318:24 - communicating our intent to
318:27 - humans this freedom is not an excuse to
318:30 - write obtuse code or dense code for
318:33 - example see the obfuscated Pearl contest
318:36 - but instead freedom to describe what we
318:39 - mean or use spacing to help us
318:42 - understand or maintain our code we can
318:44 - take a quick look at how a few other
318:46 - c-like languages that came after C treat
318:49 - the semicolon Java is just like C in
318:52 - that the semicolon terminate statements
318:54 - python treats the semicolon as a
318:56 - separator like algol allowing more than
318:59 - one statement on a single line but since
319:02 - python treats the end of a line as a
319:04 - statement separator you generally never
319:07 - use semicolon in Python
319:09 - but for people like me who automatically
319:11 - add a semicolon when typing code too
319:13 - fast at least python ignores the few
319:16 - semicolon I mistakenly add to my code
319:18 - out of
319:19 - habit JavaScript treats the semicolon as
319:22 - a separator but since JavaScript ignores
319:25 - the end of the line it's treated as Whit
319:27 - space semic Colones are required when a
319:30 - block of code consists of more than one
319:33 - statement when I write JavaScript I
319:36 - meticulously include semicolons at the
319:38 - end of all statements because any good
319:41 - programmer can write C in any
319:45 - language back to the text
319:48 - 3.2 if else the if else statement is
319:52 - used to make decisions formally the
319:54 - syntax is if parentheses expression
319:58 - parenthesis statement one else statement
320:02 - two where the else part is optional the
320:05 - expression in parentheses is evaluated
320:08 - if it's evaluates to true that is the
320:10 - expression has a nonzero value statement
320:13 - one is done if it is false the
320:16 - expression is zero and there's an else
320:18 - part statement two is executed
320:21 - instead since an if simply tests the
320:24 - numeric value of the expression certain
320:27 - coding shortcuts are possible the most
320:30 - obvious is writing if open parenes
320:33 - expression instead of if open
320:36 - parenthesis expression not equal Z zero
320:39 - Clos
320:40 - parentheses sometimes this is natural
320:42 - and clear other times it's
320:46 - cryptic because the else part of an if
320:48 - else is optional there is an ambiguity
320:51 - when an else is omitted from a nested if
320:55 - sequence this is resolved the usual way
320:58 - the else is associated with the Clos
321:01 - closest previous eless
321:05 - if for
321:07 - example if
321:09 - open parentheses n greater than Z closed
321:12 - parentheses if open parentheses a
321:15 - greater than b closed parentheses zal a
321:19 - semicolon else Z equal
321:22 - B the else with the Z equal B goes with
321:25 - the inner if as we have shown by the
321:27 - indentation in the above example if
321:29 - that's not what you want braces must be
321:32 - used to force the proper
321:34 - Association if n greater than zero open
321:37 - curly brace
321:39 - if a greater than b z equals a semicolon
321:43 - Clos curly brace else Z equals
321:46 - B this ambiguity is especially
321:49 - pernicious in situations like if open
321:53 - parenes n greater than Z for open
321:56 - parentheses I equal 0 semicolon I less
321:58 - than n semicolon i++ closed
322:02 - parentheses if open parentheses S Sub I
322:06 - greater than zero closed parentheses
322:07 - open curly brace print F string dot dot
322:11 - dot close parentheses semicolon return
322:15 - open parentheses I close parentheses
322:16 - semicolon close curly brace else and
322:20 - this is where it's wrong print F open
322:24 - parthy eror and is zero closed
322:26 - parentheses
322:28 - semicolon the indentation in the above
322:30 - example shows unequivocally what you
322:32 - want but the compiler does not get the
322:35 - message and Associates the else with the
322:38 - inner F this bug can be very hard to
322:42 - find by the
322:44 - way notice that there is a semicolon
322:47 - after Z equals a in if open parentheses
322:50 - a greater than b closed parentheses Z
322:53 - equal a semicolon else Z equals B
322:58 - semicolon that is because grammatically
323:00 - a statement follows the if and an
323:02 - expression like Z equals a is always
323:06 - terminated by a semicolon
323:10 - section
323:11 - 3.3 else
323:13 - if the construction if open parentheses
323:17 - expression closed parentheses statement
323:19 - else blank if open parentheses
323:23 - expression Clos parentheses statement
323:25 - else if open parentheses expression
323:29 - closed parentheses statement else
323:31 - statement occurs so often that is worth
323:34 - a brief separate discussion the sequence
323:37 - of ifs is the most General way of
323:39 - writing a multi-way decision the
323:41 - expressions are evaluated in order if
323:44 - any expression is true the statement
323:46 - associated with it is executed and this
323:48 - terminates the whole chain the code for
323:52 - each
323:53 - statement is either a single statement
323:55 - or a group of statements in Braes the
323:58 - last else handles the none of the above
324:00 - or default case where none of the other
324:02 - conditions was
324:04 - satisfied sometimes there is no explicit
324:06 - action for the default in that case the
324:08 - trailing else statement can be omitted
324:12 - or it may be used for error checking to
324:14 - catch an impossible condition to
324:17 - illustrate three-way decision here is a
324:19 - binary search function that decides if a
324:22 - particular value X occurs in the sorted
324:24 - array V the elements of V must be in
324:28 - increasing order the function Returns
324:30 - the position a number between 0 and N
324:33 - minus1 if x occurs in v n minus one if
324:37 - not this sample code is on page 54 it is
324:41 - the first example on page 54 in the
324:44 - book binary open parentheses x comma V
324:48 - comma n Clos parentheses int X comma V
324:54 - open square bracket closed square
324:56 - bracket comma n semicolon open curly
324:59 - brace int low comma High comma mid
325:04 - semicolon low equals zero semicolon High
325:09 - equal n-1
325:11 - semicolon while open parentheses low
325:14 - less than or equal to high closed
325:16 - parentheses open curly brace mid equals
325:20 - open parentheses low plus High closed
325:22 - parentheses slash to
325:25 - semicolon if open parentheses x less
325:29 - than V sub mid closed
325:32 - parentheses High equal midus one
325:35 - semicolon else if open parentheses x
325:40 - greater than V sub mid closed
325:42 - parentheses low equals mid + 1
325:47 - else return open parentheses mid close
325:50 - parentheses semicolon close curly brace
325:52 - closing the
325:54 - while and then return open parentheses
325:57 - minus one close parentheses semicolon
325:59 - close curly brace to end the function
326:02 - the fundamental decision in this code is
326:04 - whether X is less than greater than or
326:07 - equal to the middle element V submit at
326:09 - each step this is a natural for
326:15 - Els I would note that in the above
326:18 - examples the else and the if in C are
326:21 - two language constructs that are just
326:23 - being used idiomatically to construct a
326:26 - multi-way branch or elsf pattern with
326:29 - indentation that captures the
326:31 - idiom if we are pedantic about the
326:33 - indentation of the of the above sequence
326:36 - we would be separating the else and if
326:38 - and ending each succeeding block further
326:41 - as follows with brackets or added for
326:45 - clarity if open parthey expression close
326:48 - parenthe parentheses open curly brace
326:50 - statement Clos curly brace else open
326:54 - curly brace if open parenthesis
326:57 - expression closed parentheses open curly
326:59 - brace statement Clos curly brace else
327:03 - open curly brace and now we're quite
327:05 - indented at this point if open
327:07 - parenthesis expression close parentheses
327:10 - open curly brace statement close curly
327:12 - brace else open curly brace statement
327:15 - close curly brace close curly brace
327:18 - close curly
327:19 - brace Java and JavaScript keep the else
327:22 - and if as separate language elements and
327:25 - document their idiomatic usage and
327:27 - indentation just like C but in Python L
327:32 - if is a single keyword and a new
327:35 - language construct that achieves the
327:37 - same name idiom as shown
327:40 - below if open parentheses expression
327:43 - closed parentheses colon block LF open
327:47 - parentheses expression closed
327:48 - parentheses colon block LF if LF
327:53 - parentheses expression
327:55 - parentheses colon block else colon
327:58 - block the C Java JavaScript and python
328:03 - idioms thankfully look the same when the
328:05 - idiomatic indentation is used
328:08 - even fortran77 supports El the elseif
328:12 - construct to implement multi-way
328:20 - logic section 3.4
328:23 - switch the switch statement is a special
328:25 - multi-way decision maker that tests
328:27 - whether an expression matches one of a
328:30 - number of constant values and branches
328:33 - accordingly in chapter 1 we wrote a
328:35 - program to count the occurrences of each
328:37 - digit Whit space and all other
328:40 - characters using a sequence of if else
328:44 - if else here's the same program with a
328:47 - switch this is the first example program
328:50 - on page
328:53 - 55 pound
328:55 - include less than
328:59 - stdio.h main open parentheses closed
329:01 - parentheses open curly brace int C comma
329:06 - I comma n White comma n other comma n
329:09 - digit open square bracket 10 closed
329:12 - square bracket a 10 element
329:15 - array n white equal n other equals 0 for
329:19 - I equal 0 I less than 10 i ++ n digit
329:24 - sub I equals
329:27 - z while parentheses parentheses C equals
329:31 - getar open print close PR Clos PR not
329:34 - equal EF Clos print switch open
329:38 - parentheses C close parentheses open
329:40 - curly
329:42 - brace case quot Zero quote colon case
329:46 - quote 1 quote colon case quote 2 quote
329:51 - colon case quote 3 quote colon case
329:54 - quote 4 quote colon case quote 5 quote
329:59 - colon case quote 6 quote colon case
330:03 - quote 7 quote colon case quote 8 quote
330:07 - colon
330:08 - case quote 9 quote colon igit Sub C
330:13 - minus quot 0 quot close bracket
330:17 - Plus+ break now that that bit of code
330:21 - right there was to take all of Z through
330:23 - nine and guide it to the line of code
330:27 - that incremented the particular element
330:29 - of the igit array by
330:32 - one continuing after the break semicolon
330:35 - case quote space quote quote
330:38 - case quot sln quot colon case quot SLT
330:43 - quot colon n white Plus+ semicolon break
330:49 - default colon n other Plus+ colon break
330:56 - semicolon close curly brace print F open
331:01 - parentheses double quote digits equals
331:03 - double quote close parentheses semicolon
331:07 - four open open print I equals 0 I less
331:10 - than 10 I semicolon i++ close
331:14 - parentheses print F open parentheses
331:17 - percent space percent D close double
331:21 - quote comma igit subi Clos parentheses
331:26 - semicon print F quote back sln wh space
331:30 - equals percent D comma other equals
331:34 - percent D back slash N double quote
331:37 - comma n white comma n other closed
331:40 - parentheses semicolon closed querly
331:45 - brace the switch statement evaluates the
331:48 - integer expression in parentheses in
331:50 - this case the character C and Compares
331:52 - its
331:53 - value simultaneously to all the cases
331:56 - each case must be labeled by an integer
331:59 - or character constant or constant
332:01 - expression if a case matches the
332:04 - expression value execution starts at
332:06 - that case the case labeled default is
332:09 - executed if none of the other cases is
332:12 - satisfied default is optional if there
332:14 - isn't if it isn't there and none of the
332:17 - cases matches no action at all takes
332:19 - place cases in default can occur in any
332:22 - order cases must all be different the
332:26 - break statement causes an immediate exit
332:28 - from the switch because the cases serve
332:31 - as labels after the code for one case is
332:36 - done and execution falls through to the
332:39 - next unless you take explicit action to
332:42 - escape break and return are the most
332:45 - common Ways to Leave a switch a break
332:48 - statement can be used to force an
332:50 - immediate exit from a while for and two
332:53 - Loops as well as will be discussed later
332:55 - in this
332:58 - chapter falling through the cases is a
333:00 - mixed blessing on the positive side it
333:04 - allows multiple cases for a single
333:05 - action as with blank tab or new line
333:07 - this example but it also implies that
333:10 - normally each case must end with a break
333:12 - to prevent falling through to the
333:14 - next falling through from one case to
333:17 - another is not robust being prone to
333:19 - disintegration when the program is
333:21 - modified with the exception of multiple
333:24 - labels for a single computation fall
333:26 - throughs should be used
333:29 - sparingly as a matter of good form put a
333:31 - break after the last case in this case
333:34 - default although it's logically
333:36 - unnecessary some when another case gets
333:38 - added at the end this bit of defensive
333:41 - programming will save
333:45 - you uh the switch statement what is
333:47 - there to say I think that the switch
333:49 - statement was added to se C to compete
333:52 - with the earlier Fortran computed go-to
333:54 - statement or just to keep low-level
333:57 - Assembly Language programmers from
333:58 - switching into Assembly Language to
334:00 - implement the concept of a branch table
334:03 - the authors spend most of the previous
334:05 - section apologizing for the switch
334:06 - statement so you you should perhaps take
334:08 - this as a hint and never use it there
334:12 - are very few situations where a branch
334:14 - table outperforms a series of this if
334:17 - then else checks and those are likely
334:20 - deep in a library or operating system
334:22 - code programmers should only use switch
334:26 - if they understand what a branch table
334:28 - is and why a branch table is more
334:31 - efficient for the particular bit of a
334:32 - program they're writing otherwise just
334:36 - use LF and do the read of your code a
334:41 - favor 3.5 Loops while and for we have
334:46 - already ex countered the while and for
334:49 - Loops in while open parentheses
334:51 - expression closed parentheses statement
334:53 - the expression is evaluated if it is
334:56 - nonzero the statement is executed and
334:58 - the expression is re-evaluated this
335:00 - cycle continues until the expression
335:03 - becomes a zero at which point execution
335:05 - return resumes after the statement
335:08 - the four statement for open parentheses
335:11 - expression one semicolon Expression 2
335:14 - semicolon Expression 3 closed
335:17 - parentheses statement is equivalent to
335:19 - expression one semicolon while open
335:22 - parentheses Expression 2 Clos
335:24 - parentheses open curly brace
335:27 - statement Expression 3 semicolon Clos
335:30 - curly
335:32 - brace grammatically the three components
335:34 - of the four are expressions most
335:37 - commonly expression one and expression
335:39 - three are assignments or function calls
335:41 - and expression two is a relational
335:43 - expression any of the three parts can be
335:45 - omitted although the semicolons must
335:48 - remain expression if expression one or
335:51 - expression three is left
335:53 - out it is simply dropped from the
335:55 - expansion if the test expression two is
335:58 - not present it is taken as permanently
336:00 - true so the code for open parentheses
336:04 - semicolon semicolon closed parentheses
336:06 - open curly
336:08 - dot dot dot closed curly brace is an
336:10 - infinite Loop presumably to be broken by
336:13 - some other means such as a break or a
336:16 - return whether to use while or for is
336:19 - largely a matter of taste for example in
336:23 - the code while open parentheses open
336:26 - parentheses C equals get chart open
336:27 - paren close paren close parentheses
336:29 - equal equal quote space quote or c equal
336:34 - equal quot back sln quote or or c equal
336:39 - equal quot back SLT quote closed
336:41 - parentheses semicolon skipping White
336:44 - characters there is no initialization or
336:47 - reinitialization so a while seems more
336:50 - natural the four is clearly Superior
336:53 - when there is simple initialization and
336:56 - reinitialization since it keeps the loop
336:58 - control statements close together and
337:00 - visible at the top of the loop this is
337:02 - the most obvious in for open p i equal 0
337:07 - sum semicolon I less than n semicolon
337:09 - i++ Clos per n which is the C idiom for
337:14 - processing the first n elements of an
337:16 - array the analog of a Fortran or pl1 do
337:20 - Loop the analogy is not perfect however
337:23 - since the limits of a for Loop can be
337:25 - altered within the loop and the
337:26 - controlling variable I retains its value
337:29 - when the loop terminates for any reason
337:32 - because the components of the four are
337:34 - arbitrary expressions for Loops are not
337:37 - restrict red to arithmetic
337:39 - progressions nonetheless is bad style to
337:42 - force unrelated computations into a four
337:45 - it is best reserved for loot control
337:50 - operations as a larger example here is
337:53 - another version of the a2i function for
337:56 - converting a string to its numeric
337:58 - equivalent this one is more General it
338:01 - copes with optional leading white space
338:04 - and an optional plus or minus sign
338:07 - chapter four shows a to F which does the
338:10 - same conversion for floating Point
338:12 - numbers the basic structure of the
338:14 - program reflects the form of the input
338:16 - skip whites space if any get the sign if
338:19 - any get the integer part and convert it
338:22 - each step does its part and leaves a
338:24 - clean slate for the next the whole
338:26 - process terminates on the first
338:28 - character that would not be part of a
338:31 - number this is the first example on page
338:35 - 58 of the textbook
338:39 - a to I open pen s closed pen which is
338:42 - going to convert s to an integer Char s
338:46 - open square bracket closed square
338:48 - bracket semicolon open curly brace int I
338:52 - comma n comma sign
338:55 - semicolon for I equal
338:58 - 0 S Sub I equal equal quote space quote
339:03 - or S Sub I equals equals quote back n
339:07 - quote or S Sub I equals equals back SL
339:11 - quote back SLT quote semicolon I ++
339:17 - semicolon skip white space this is a for
339:20 - loop with an empty Loop
339:22 - body s equal 1
339:25 - semicolon if S Sub I equal equal plus or
339:31 - S Sub I equal equal quote minus quote
339:34 - close parentheses sign
339:38 - equals and here we use a turn Turner
339:41 - operator open parentheses S Sub i++
339:45 - equal equal quote plus quote close
339:49 - parentheses question mark 1 colon minus
339:52 - one
339:55 - semicolon for open parentheses n equals
339:58 - 0 semicolon s subi greater than or equal
340:01 - to quot 0 quote and S Sub I less than or
340:05 - equal to quote 9 quote I Plus plus Clos
340:09 - parentheses n = 10 * n + S Sub I minus
340:16 - quot 0 quote
340:18 - semicolon return open parentheses sign
340:21 - time n closed parentheses
340:24 - semicolon Clos curly brace to end the
340:26 - function the advantages of keeping Loop
340:29 - controls centralized are even more
340:31 - obvious when there are sep several
340:32 - nested Loops the following function is a
340:35 - shell sort for sorting an array of
340:37 - integers the basic idea of the shell
340:40 - sort is that in early stages far apart
340:43 - elements are compared rather than
340:44 - adjacent ones as in simple interchange
340:46 - sorts this tends to eliminate large
340:49 - amounts of disorder quickly so later
340:51 - stages have less work to do the interval
340:53 - between the compared elements is
340:55 - gradually decreased to one at which
340:57 - point the sort becomes an effectively
340:59 - adjacent interchange method this sample
341:03 - code is the second example in page 58 of
341:06 - the textbook
341:09 - shell open parentheses V comma n Clos
341:12 - parentheses int V open square bracket
341:15 - closed square bracket comma n
341:17 - semicolon open curly brace int Gap comma
341:22 - I comma J comma
341:25 - temp for open p Gap equals n / 2
341:30 - semicolon Gap greater than zero
341:33 - semicolon Gap slash equals to closed
341:38 - parentheses for open parentheses I
341:41 - equals Gap semicolon I less than n
341:46 - i+ Clos parentheses
341:49 - four and now we're 3D nested in the four
341:52 - Loops for open parentheses Jal IUS Gap
341:56 - semicolon J greater than equal to Zer
342:00 - and V
342:02 - subj greater than V subj plus Gap
342:05 - semicolon J minus equals Gap close
342:09 - parentheses open curly brace temp equals
342:12 - v
342:13 - subj v subj equals V subj plus Gap
342:18 - semicolon V subj plus Gap equals temp
342:21 - semicolon just a swap of V and V V subj
342:24 - plus Gap V subj and V subj plus Gap
342:27 - close curly brace and that Clos the in
342:31 - inmost for Loop and and then the next
342:33 - closed curly brace closes the function
342:37 - there are three nested Loops the
342:39 - outermost Loop controls the gap between
342:41 - the compared elements shrinking it from
342:43 - n/ Two by a factor of to each pass until
342:46 - it becomes zero the middle Loop Compares
342:48 - each pair of elements that is separated
342:50 - by Gap the innermost Loop reverses any
342:53 - elements that are out of order since Gap
342:56 - is eventually reduced to one all
342:58 - elements are eventually ordered
342:59 - correctly note that the generality of
343:02 - the four makes the outer loop fit the
343:04 - same form as the others even though it
343:06 - is is not an arithmetic
343:12 - progression one final C operator is the
343:15 - comma which most often finds use in the
343:18 - four statement a pair of Expressions
343:21 - separated by a comma is evaluated left
343:23 - to right and the type and value of the
343:26 - result are the type and value of the
343:28 - right operand thus in a force statement
343:31 - it is possible to place multiple
343:33 - expressions in the various parts for
343:35 - example to process two parallel indices
343:39 - this is Illustrated in the function
343:40 - reverse which reverses the function
343:42 - string in place this code is from page
343:47 - 59 of the textbook and it is the first
343:49 - example on page
343:51 - 59 pound include less than string.h
343:54 - greater than reverse open pen s closed
343:58 - pen Char s open square bracket closed
344:02 - square bracket semicolon open curly
344:04 - brace int C comma I I comma J for open
344:09 - fenesy i = 0 comma Jal sterin sub
344:16 - s-1 semicolon I less than J semicolon
344:21 - i++ comma J minus minus Clos parentheses
344:25 - open curly brace Cal S Sub I S Sub IAL s
344:30 - subj semicolon s subj equals c semicolon
344:34 - close curly brace close curly braas to
344:37 - end the function the commas that F
344:39 - separate the function arguments
344:41 - variables declarations Etc are not comma
344:44 - operators and do not guarantee left to
344:46 - right
344:48 - evaluation section 3.6 Loops do
344:52 - while the while and for Loops share the
344:55 - desirable attribute of testing the
344:57 - termination condition at the top rather
344:59 - than at the bottom as we discussed in
345:00 - chapter one the third Loop in see the do
345:03 - while tests at the bottom after making
345:05 - each pass through the loop body the body
345:08 - is always executed at least once the
345:11 - syntax is as follows do statement while
345:16 - open parentheses expression closed
345:17 - parentheses
345:18 - semicolon the statement is executed then
345:21 - the expression is evaluated if it is
345:23 - true statement is evaluated again and so
345:25 - on if the expression becomes false the
345:28 - loop
345:29 - terminates as might be expected do while
345:32 - is much less used than while and four
345:34 - accounting perhaps 5% of all loops
345:38 - nonetheless it is from time to time
345:40 - valuable as the following as in the
345:42 - following function I to a which converts
345:44 - a number to a character string the
345:46 - inverse of a to I the job is slightly
345:48 - more complicated than it might be
345:49 - thought at first because the easy
345:51 - methods of generating the digits
345:53 - generate them in the wrong order we've
345:56 - chosen to generate the string backwards
345:58 - and then reverse
345:59 - it this is the first sample code on page
346:03 - 61 uh page 60 of the textbook
346:07 - I to a open parentheses n comma s closed
346:11 - parentheses Char s open square bracket
346:14 - Clos square bracket semicolon int n
346:18 - semicolon open curly brace int I comma
346:22 - sin
346:23 - semicolon
346:25 - if open parentheses open parentheses s
346:29 - equals n close parentheses less than
346:32 - zero close
346:34 - parentheses n = minus n SU col that's a
346:38 - bit of a complex if I would say there uh
346:40 - it has an assignment statement that both
346:42 - copies n into sign um and then evaluates
346:46 - as to whether or not it's less than Z
346:48 - the N or sign is less than zero because
346:50 - it's a side effect assignment statement
346:52 - with a residual
346:54 - value but the net result is sign
346:57 - contains n and then it's negated um uh
347:00 - then n is made positive so continuing I
347:04 - equal 0 semicolon do open curly brace S
347:09 - Sub
347:11 - i++ equals n modulo
347:14 - 10 plus quote 0 quote
347:19 - semicolon close curly brace while
347:23 - parentheses parentheses n/ equal 10
347:26 - close parentheses greater than zero
347:29 - close parentheses
347:32 - semicolon if open parentheses sign less
347:36 - than zero Clos parentheses S Sub I ++
347:40 - equals quote- quote or minus sign
347:45 - semicolon s subi equals qu0 quote
347:50 - semicolon in a sense to terminate the
347:52 - string and then we call the function
347:53 - reverse reverse open parentheses s
347:56 - closed parentheses semicolon Clos curly
348:00 - brace the do while is necessary or at
348:03 - least convenient since at least one
348:05 - character must be installed in the array
348:07 - s regardless of the value of n we have
348:10 - also used braces around the single
348:12 - statement that makes up the body of the
348:13 - do while even though they are
348:15 - unnecessary so the Hasty reader will not
348:17 - mistaken mistake the while part for the
348:20 - beginning of a while
348:22 - loop I would note that it's important
348:24 - for any language to provide top tested
348:26 - loops and bottom tested Loops but don't
348:28 - feel bad if you write code for years and
348:31 - never feel like a bottom tested Loop is
348:33 - the right way to solve a problem you're
348:34 - facing it is usually rare to write a
348:36 - loop that you insist will run once
348:39 - regardless of its input
348:43 - data section 3.7
348:47 - break it is sometimes convenient to be
348:50 - able to control Loop exits other than by
348:53 - testing at the top or the bottom the
348:56 - break statement provides an early exit
348:58 - from a for while or do just as it does
349:02 - from the switch statement a break
349:04 - statement causes the innermost enclosing
349:06 - Loop or switch to be executed
349:08 - immediately the following program
349:10 - removes trailing blanks and tabs from
349:13 - the end of each line of input using a
349:15 - break to exit from a loop when the most
349:18 - character is non-blank non- tab is
349:20 - found this example code is on page 61 of
349:24 - the textbook and it is the first example
349:26 - on that page pound include less than
349:31 - stdio.h pound Define MAX Line 1000 Main
349:36 - open parentheses closed parenthesis open
349:38 - curly brace int n semicolon Char line
349:44 - Open Bracket MAX Line close
349:50 - bracket semicolon while open pren open
349:54 - pren n equals get Line open pren Line
349:57 - comma MAX Line Clos PR close pren
349:59 - greater than zero Clos print open curly
350:01 - brakes while open Cur open parentheses
350:06 - minus- n greater than or equal to zero
350:09 - close parentheses if open parentheses
350:12 - lines sub n not equal Z quote space
350:14 - quote and line subn not equal quote back
350:19 - SLT quote and line subn not equal quot
350:23 - back slend
350:25 - quote close parentheses
350:27 - break line subn +1 equals back0 quote
350:33 - semicolon print F double quot percent s
350:37 - back sln double quot comma line close
350:40 - parentheses semicolon close curly brace
350:43 - to end the while and then close curly
350:45 - brace to end the
350:47 - main get line Returns the length of the
350:50 - line the inner y Loop starts at the last
350:53 - character of line recall that minus
350:55 - minus n decrements n before using the
350:58 - value and scans backwards looking for
351:01 - the first character that is not a blank
351:03 - tab or new line the loop is broken when
351:06 - one is found or when n n becomes
351:09 - negative that is when the entire line
351:11 - has been
351:12 - scanned you should verify that this is
351:14 - the correct Behavior even when the line
351:16 - contains only whites space
351:18 - characters an alternative to break is to
351:21 - put the testing in the loop
351:25 - itself while open parentheses open
351:27 - parentheses n equals get Line open
351:30 - parentheses line comma MAX Line closed
351:32 - parentheses closed parentheses greater
351:33 - than zero closed parentheses open curly
351:35 - brace
351:38 - while open PR minus- n greater than
351:41 - equal to zero and open PR line subn
351:45 - equal equal quot subas qu quote or line
351:49 - subn equals quot backt quote or line
351:53 - subn equals quote back slash n quote
351:57 - close per n close per n
351:59 - semicolon dot dot dot close curly brace
352:03 - this is inferior to the previous version
352:05 - because the test is is harder to
352:07 - understand test which require a mixture
352:11 - of and or not and parentheses should
352:15 - generally be
352:17 - avoided 3.8
352:21 - continue the continu statement is
352:23 - related to break but less often used it
352:26 - causes the next iteration of the
352:28 - enclosing Loop for while or due to begin
352:31 - in the while and do this means that the
352:32 - test part is executed immediately in the
352:35 - four control passes to the
352:37 - reinitialization step contr by the way
352:40 - continue applies only to Loops not to
352:42 - switch a continue inside a switch
352:45 - statement inside of a loop causes the
352:47 - next Loop iteration as an example this
352:51 - fragment processes only positive
352:53 - elements in the array a negative values
352:55 - are
352:57 - skipped for open print I equal 0
353:00 - semicolon I less than n semicolon i++
353:04 - closed pen open curly brace
353:07 - if open p a subi less than zero closed P
353:12 - continue this line skips the negative
353:15 - elements and then the rest of the body
353:16 - of the loop dot dot dot is will run only
353:19 - for the positive elements of the loop
353:21 - and the loop finishes with a close curly
353:25 - brace the continue statement is often
353:27 - used when part of the loop that follows
353:29 - is complicated so that reversing a test
353:31 - and indenting another level would Nest
353:33 - the program too deeply
353:37 - it's time for a bit of an
353:38 - aside now that we have seen the break
353:41 - and continue language structures in C
353:43 - that also have made it into C like
353:45 - languages and learned about middle
353:46 - tested Loops it is time to revisit the
353:48 - structured programming debate and the
353:51 - need for priming operations when a
353:52 - program must process all data until it
353:55 - finishes and still handle the there is
353:57 - no data at all
353:59 - situation in the previous chapter the
354:01 - author somewhat skirted the issue by
354:02 - using a top tested while loop and a side
354:05 - effect statement with residual value
354:07 - that was compared to eof to decide when
354:09 - to exit the loop int C colon while open
354:14 - parthey open parentheses C equals get
354:16 - Char open pren close paren close
354:18 - parentheses not equal eoff close
354:20 - parentheses open curly brace process
354:22 - your data close curly brace and just for
354:26 - fun now that we do know about the for
354:28 - Loop let's rewrite this loop as a for
354:30 - Loop to make sure we really understand
354:32 - how for loops
354:34 - work int C semicolon for open print C
354:39 - equals getchar open print Clos print
354:41 - semicolon c not equal eof semicolon C
354:45 - equals getchar open PR close PR close PR
354:48 - curly brace process your data close
354:51 - curly brace for the for Loop now you
354:53 - will almost never see a read all
354:56 - characters until eof written this way
354:58 - because because it is not the way KR
355:01 - told us KR told us to use a y Loop for
355:04 - this but the four Loop formulation is
355:07 - probably clearer to
355:08 - many than the while formulation
355:10 - especially to a reader who's not
355:12 - familiar with the assignment side effect
355:14 - idiom commonly used in C in particular
355:17 - the four formulation does not
355:19 - require that the assignment statement
355:22 - has a residual value of the value that
355:24 - was assigned the first part of the four
355:27 - is a priming read the second part of the
355:28 - four is a top text tested exit criteria
355:31 - that works both for no data and after
355:34 - all data has been read and processed and
355:36 - the third part of the four is done at
355:38 - the bottom of the loop to advance to the
355:39 - next character or encounter eof before
355:42 - going back to the top and doing the loop
355:44 - test the call up to get Char is done
355:47 - twice in the four formulation of the
355:49 - read all all available data loop and
355:52 - while we don't like to repeat ourselves
355:53 - in code it is a if it is a small and
355:56 - obvious bit of code perhaps this code is
355:58 - more clear with a bit of
356:02 - repetition so with all this is
356:04 - background you can take this page of the
356:07 - document and sit down with a friend at a
356:08 - coffee shop and debate as long as you
356:11 - like about which is the better
356:13 - formulation for the read all available
356:16 - data but if at that coffee shop you ask
356:18 - Dr Chuck's opinion neither of these is
356:20 - ideal because in the real world we build
356:22 - data oriented Loops that usually do a
356:24 - lot more than get one character from
356:26 - standard
356:27 - input my formulation of a data loop will
356:30 - upset the structured programming purists
356:32 - and probably upset kernigan and Richie
356:35 - as well but but I write code in the real
356:37 - world so here is my
356:40 - version int c semicolon while open print
356:45 - one Clos print open curly prce C equals
356:49 - getchar if open print C double equals
356:52 - eof close pen break process your data
356:56 - and then close curly brace to end the
356:58 - loop and if I wanted to skip blanks and
357:00 - new lines I could use both break and
357:03 - continue further angered angering the
357:05 - structure programming
357:08 - purists int c semicolon while open
357:11 - parentheses one closed parentheses open
357:13 - curly bra C equals get charar open
357:16 - parentheses closed parentheses semicolon
357:19 - if open parentheses c equal equal eoff
357:23 - close parentheses break if open
357:25 - parentheses c equal equal quote space
357:28 - quote or c equal equal quot back slash
357:31 - and quote close parentheses continue
357:34 - then process your data close
357:38 - I use this middle tested approach
357:39 - because usually the data I am processing
357:41 - is coming from a more complex Source
357:43 - than the keyboard and I don't want a
357:45 - function with two to three parameters
357:47 - stuck inside of a sign side effect
357:49 - statement in a while test and also
357:52 - sometimes you want to exit Loop not just
357:54 - based on the return value from the
357:55 - function but instead based on the
357:58 - complex structure that came back from
358:00 - the function
358:01 - itself as these data processing Loops
358:04 - get more complex the middle test Loop is
358:06 - a tried and true pattern even kernigan
358:09 - and Richie point out its benefits
358:11 - above and with that I have now triggered
358:15 - endless coffee shop conversations about
358:17 - the best way to write a data handling
358:24 - Loop section 3.9 Goos and
358:28 - labels C provides the infinitely
358:31 - abusable go-to statement and labels to
358:34 - Branch to form
358:36 - the go-to is never necessary and in
358:39 - practice it is almost always easy to
358:42 - write code without it we have not used
358:44 - goto in this book nevertheless we will
358:47 - suggest a few situations where go-tos
358:50 - might find a place the most common use
358:53 - is to abandon processing in some deeply
358:55 - nested structure such as breaking out of
358:57 - two Loops at once The Brak statement
359:00 - cannot be used directly since it leaves
359:02 - the only the most inter Loop innermost
359:04 - Loop thus four open parentheses dot dot
359:08 - dot close parentheses four open
359:10 - parentheses dot dot dot close
359:11 - parentheses open curly brace do some
359:13 - stuff if open parentheses disaster close
359:15 - parentheses go to error semicolon close
359:19 - curly brace dot dot dot dot dot dot and
359:21 - then error colon and then clean up the
359:24 - mess this organization is Handy if the
359:28 - error handling code is non-trivial and
359:30 - if errors can occur in several places a
359:32 - label has the same form as a variable
359:34 - name and is followed by a c
359:36 - it can be attached to any statement in
359:39 - the same function as the
359:43 - goto another example consider the
359:46 - possibility of finding the first
359:48 - negative element in a two-dimensional
359:49 - array multi-dimensional arrays are
359:52 - discussed in chapter 5 one possibility
359:55 - is for open parentheses I equals 0
359:58 - semicolon I less than n semicolon i++
360:03 - closed parentheses four open parentheses
360:06 - J equals 0 semicolon J less than M
360:09 - semicolon j++ Clos parentheses if open
360:13 - parentheses V sub I subj less than zero
360:17 - close parentheses go to
360:19 - found other and then you handle and you
360:22 - keep going and then found
360:24 - colon include is where it comes to uh
360:27 - jumps to code involving a go-to can
360:31 - always be written without one but though
360:33 - perhaps at the price of somewhat
360:35 - repeated test or an extra variable for
360:37 - example the array search
360:39 - becomes found equals z for open pry I
360:44 - equals 0 semicolon I less than n
360:48 - Ampersand Ampersand exclamation found
360:50 - semicolon
360:51 - i++ for open parentheses J equal 0
360:55 - semicolon J less than M Ampersand
360:58 - Ampersand exclamation found semicolon
361:02 - j++ found equals V sub I subj less than
361:06 - than zero if found continue else not
361:10 - found although we are not dogmatic about
361:13 - the matter it does seem that go to goto
361:15 - statements should not should be used
361:17 - sparingly at if at
361:19 - all I would add before we leave control
361:22 - flow I need to say that I agree with
361:24 - structure programming experts as well as
361:26 - kernigan and Richie in that the go-to is
361:28 - universally a bad
361:30 - idea there are a lot of little details
361:33 - that make them a real problem things
361:35 - like how the stack Works in function
361:37 - calls and how code blocks happen and
361:39 - patching the stack up correctly when a
361:41 - go-to happens in the middle of a deeply
361:42 - nested
361:44 - mess you might be tempted to use a go-to
361:47 - when you want to exit multiple nested
361:49 - Loops in a single statement break can
361:50 - continue only exit the innermost Loop
361:53 - the authors use this example above but
361:55 - are quite lukewarm when describing it as
361:57 - a use of
361:59 - go-to usually if your problem is that
362:02 - complex putting things in a function and
362:04 - using return or adding a few if
362:06 - statements is a better choice the Dr
362:09 - Chuck middl tested Loop data processing
362:11 - solves this because the loop is always
362:13 - the innermost Loop also as new languages
362:17 - were built the concept of exceptions
362:19 - became part of language design and was
362:22 - by a by far more elegant solution to a
362:25 - path of some deeply nested code that
362:27 - just needs to get out so most of the
362:29 - time you think the goto might be a good
362:31 - idea you should lean towards a throw
362:34 - catch pattern to make your your
362:35 - intention clear it is one of the reasons
362:38 - why we prefer languages like Java or
362:40 - python over C when writing general
362:43 - purpose
362:47 - code this work is based on the 1978 C
362:51 - programming book written by Brian W
362:53 - kernigan and Dennis M Richie their book
362:56 - is copyright All Rights Reserved by AT&T
362:59 - but is used in this work under fair use
363:02 - because of the book's historical and
363:04 - scholarly significance its lack of
363:06 - availability and the lack of an
363:08 - accessible version of the book the book
363:10 - is augmented in places to help
363:12 - understand Its Right Place in a
363:13 - historical context amidst the major
363:15 - changes of the 1970s and 1980s as
363:19 - computer science evolved from a hardware
363:21 - first vendor centered approach to a
363:23 - software centered approach where
363:25 - portable operating systems and
363:26 - applications written in C could run on
363:28 - any
363:30 - hardware this is not the ideal book to
363:32 - learn SE programming because the 1978
363:35 - Edition does not reflect the modern sea
363:37 - language using an obsolete book gives us
363:39 - an opportunity to take students back in
363:42 - time and understand how the sea language
363:44 - was evolving as it laid the groundwork
363:47 - for a future with portable applications
363:52 - [Music]
364:06 - welcome to chapter four functions and
364:08 - program
364:09 - structure in this chapter we're going to
364:12 - start digging a little deeper part of
364:14 - the goal of this course is to get you to
364:16 - the point where we can talk about how
364:19 - things really work eventually in the
364:21 - next course we'll even go down to
364:22 - Hardware hardware and architecture and
364:24 - Gates and so it's it's time to start
364:27 - opening things up and looking at how
364:29 - things work and so this is a good time
364:31 - to do so and the big thing we're going
364:33 - to learn among other things is the
364:35 - concept of a stack how pass by reference
364:38 - works how how pass by value and pass by
364:42 - reference work a little bit about
364:43 - recursion recursion is a a thing that I
364:46 - worry about a lot um well we'll get
364:50 - there and a pre-processors these are all
364:52 - things where we're really stting it's
364:54 - I'm not just it's not so much about just
364:56 - how functions work but how functions are
364:59 - implemented and how that affects how
365:02 - they work so the first thing I want to
365:04 - talk to you about is a really Nifty
365:06 - computer science concept called a stack
365:09 - a stack is a data structure that we use
365:15 - and it has a couple of attributes the
365:17 - idea of a stack is we we start with an
365:20 - empty stack and we put things on the
365:22 - stack and then we take things off we
365:23 - take them off the last thing we to put
365:26 - on is the first thing we get off and
365:27 - they go up and they go down you can push
365:29 - things onto them and take things off of
365:31 - them we can approximate this with a
365:34 - python list so so we start with an empty
365:36 - list we append the string one to it and
365:39 - the stack has a one on it it's kind of
365:40 - growing up from the bottom and it's
365:42 - going to shrink from the top and then we
365:44 - append a two to it and then we our stack
365:47 - is now one and two so the bottom thing
365:49 - in the stack is one and the top one is
365:51 - two and then we append a three to it and
365:54 - we have one two three on the stack at
365:56 - that point we pop pop says give me the
366:00 - most recent pushed thing and then take
366:02 - it off so we pop off three and the stack
366:05 - REM with one and two again this is also
366:08 - known as a last in first out or lifo q q
366:12 - is like a line of things and so the the
366:14 - last thing in is the first thing you got
366:16 - out so that's a stack and we're going to
366:17 - use Stacks in function
366:21 - calls so historically when we talk about
366:23 - call by value and call by reference we
366:26 - basically say that call by value means
366:28 - that somehow this value like in the main
366:30 - program ma with a variable with a value
366:32 - of 42 ends up being copied into the
366:35 - function and the parameter op is got a
366:39 - is got a copy of the 42 it's not the
366:42 - original ma it's the copy of 42 so 42
366:46 - gets passed in the function one and op
366:48 - is a copy of 42 so then inside the
366:51 - function we can subtract 10 from it and
366:55 - then we can see that but then when we
366:57 - get back in the main function we see
366:58 - that Ma is been unchanged and it's like
367:01 - oh we built a little wall around the
367:03 - function and nothing inside the function
367:05 - happens the outside world is unaffected
367:07 - by it and that's a great
367:09 - oversimplification of call by value of
367:12 - course call by reference means the stuff
367:14 - un function can affect outside the
367:16 - function but let's talk a little bit
367:18 - about how a stack is used to accomplish
367:21 - this so just to use some
367:24 - terminology C calls these variables that
367:26 - are allocated inside the function before
367:30 - the function starts as the automatic
367:33 - variables and frankly int Ma = 42 in
367:36 - main is an automatic variable inside the
367:39 - main because main is a function inside a
367:41 - seat program that happens to be the one
367:43 - that starts everything out so if we get
367:46 - to the point where it says int ma equals
367:48 - 42 and then it prints ma being 42 at
367:52 - that point on the stack the C runtime is
367:55 - allocated one integer and we've assigned
367:58 - 42 to it so that's what the stack looks
368:01 - like at that first print statement in
368:03 - Maine then we call the function one and
368:06 - pass ma in and this is where the C
368:09 - runtime Library kind of
368:12 - before everything starts out in the
368:14 - function one it allocates what's called
368:16 - a stack frame and a stack frame includes
368:21 - the parameters op and the automatic
368:24 - variables that are inside of that
368:27 - function and so in this case we're going
368:28 - to get two variables we're going to get
368:30 - op as an integer and TN as an integer
368:34 - and before the program starts up the
368:36 - value 42 is copied from ma into op and
368:41 - so the stack frame is the context in
368:44 - which that function operates so when it
368:47 - first starts you see that op has 42 you
368:50 - also see we have two copies of the
368:51 - number 42 and we have a parameter op and
368:55 - then we have the the automatic variable
368:58 - the
369:00 - TN then the next line runs okay and that
369:05 - point op is changed op equals op minus
369:08 - TN and so op becomes 32 but you'll
369:11 - notice that on the stack out beyond the
369:14 - stack frame the stack frame is our
369:16 - current execution of the function one
369:18 - beyond the stack frame the 42 is still
369:20 - there we can't see it we're we're in the
369:22 - function right now and we're only seeing
369:24 - the top part of the stack we're not
369:26 - seeing the part of the stack that
369:27 - belongs to the main program so that's
369:29 - where it prints out 32 so 32 in the
369:32 - function says op is 32 and that's fine
369:35 - and then we return and that's when the C
369:38 - runtime removes the stack frame pops
369:41 - those things off the stack it remembers
369:43 - how much it put on and it pops all the
369:45 - stuff off the stack that it put on and
369:47 - then it basically comes back into Ma and
369:50 - the stack frame for the main program has
369:53 - one variable in it and it's Ma and it
369:55 - has 42 and that's because one operated
369:58 - in its stack frame and now the main
370:01 - program is back to operating in the same
370:03 - stack frame you can almost think of to
370:05 - this as like one never happened right
370:09 - from Main's perspective it had some
370:11 - variables one ran and a stack frame was
370:14 - created some of the main data was copied
370:16 - into the one stack frame one operated in
370:19 - its stack frame and then the stack frame
370:21 - went away right before one or right at
370:24 - the moment that one returned and the
370:26 - return value ends up in the stack frame
370:27 - too I just haven't shown you that and
370:30 - these don't send return value the the
370:32 - return value comes back uh from the
370:34 - stack frame but you can see how main
370:37 - started with a stack with one one
370:39 - variable on it and then it one ran and
370:41 - all that stuff happened and then it kind
370:43 - of was undone and that's where the
370:45 - changed variable just kind of went away
370:48 - and so the stack it's as if nothing ever
370:50 - happened except it went up and then it
370:51 - went back
370:53 - down now one thing we notice and and in
370:56 - Python we see this too where you say
370:57 - everything is called by value which
370:59 - implies a copy um except for things like
371:03 - certain objects and calling method and
371:05 - objects and if but if you look at say
371:08 - this function zap and we pass in X and X
371:13 - is starts out as original and then it
371:15 - calls the zap function and it passes in
371:18 - and it's got the original then it gets
371:19 - changed inside the inside the zap
371:21 - function and that change uh prints out
371:25 - but then when it comes
371:27 - back it is back to the original so X is
371:29 - back to the original in the main code
371:32 - and you might say oh that looks right
371:33 - and that that's actually quite intuitive
371:34 - and that that python has made it so a
371:37 - call by value inside of this ins call by
371:41 - value to the zap function it happened
371:44 - meaning that nothing change nothing
371:45 - changed outside of the zap function and
371:48 - it was a call by value not a call by
371:50 - reference now I'm not going to go into
371:52 - it at least not right now talking about
371:54 - why that really worked and it's it's
371:56 - less about call by value and call by
371:57 - reference and more about the fact that Y
372:01 - is really a pointer to an object and
372:03 - when y equals changed executes inside of
372:05 - Zap the object pointer it points to a
372:07 - different object and then but X never
372:10 - changed and
372:11 - so python has a slightly different
372:13 - runtime but it leads to this notion that
372:16 - seems like a string
372:18 - variable in Python is call by value now
372:23 - if we look at the similar but quite
372:26 - different code inside of C we see the
372:30 - main has a a a character array X of
372:33 - unknown length which is original and
372:35 - that just unknown length means that it
372:37 - say it's uh looks like eight characters
372:40 - plus a back sl0 which is nine characters
372:43 - and it prints out kind of like a string
372:46 - it's a character array with a terminator
372:48 - and then we Call Zap pass X in and then
372:53 - inside of zap zap takes a character
372:56 - array as its parameter and it can print
372:59 - out the word original when it starts and
373:01 - then it copies changed into it and then
373:04 - it says at the end it's it's the why is
373:08 - at the end is changed but then we come
373:10 - back and back in the main program it got
373:12 - changed so does that mean it was called
373:15 - by reference or what and the answer is
373:20 - sort of and this is where it kind of
373:23 - helps so it turns out that when you are
373:26 - passing an
373:28 - array into a function in C you're not
373:33 - actually passing the contents of the
373:34 - aray
373:36 - so most time we think of that 42 being
373:38 - copied if it's an integer if it's just
373:39 - like a scaler thing like a float or an
373:41 - INT or a Char or something that's being
373:43 - copied but when you have an array that
373:45 - could be gigantic so it doesn't actually
373:47 - copy in the whole array so when X is
373:51 - being passed into zap and being received
373:53 - as y we're not actually passing the
373:57 - string because that could be a million
373:58 - characters for all we know so it's not
374:00 - like it makes an extra copy of a million
374:03 - characters what it's doing is it's
374:05 - passing in the address of the start of
374:08 - the string not on the stack but
374:10 - somewhere
374:11 - else it actually could be on the stack
374:14 - somewhere but it's not in the stack
374:16 - frame and the word original is not
374:19 - copied into the stack frame the stack
374:21 - frame only includes a pointer or the
374:24 - address X is the address of this letter
374:27 - O and then Y is also the address of the
374:29 - letter O which means when we're calling
374:31 - stir copy we are overwriting those
374:35 - characters oh and by the way I carefully
374:37 - made sure that the string changed was
374:39 - shorter than the string original or my
374:41 - program could have blown up because this
374:43 - is C and arrays don't get
374:47 - bigger python strings get bigger but
374:50 - arrays don't in a couple more lectures
374:52 - we will build a data structure where
374:54 - it's like a python string and we can add
374:56 - to it and you'll see that the code is
374:59 - very
375:00 - complex a character array is very simple
375:04 - okay and
375:06 - so it's not exactly a pass by reference
375:11 - it is a pass by location and if you
375:13 - happen to misuse that location meaning
375:16 - you write to that location you write to
375:18 - location now this might have been in
375:19 - like readon memory something your
375:21 - program might have blown up so you
375:23 - better be sure what you're doing when
375:25 - you start messing inside of a function
375:27 - with an array that's been passed to you
375:29 - now sometimes you're supposed to
375:31 - sometimes we tell you to write that
375:34 - another thing that you're going to see
375:35 - in this is the reference to register
375:36 - variables uh this is another rather
375:39 - historical notion and in my opinion it
375:42 - really had to do with uh convincing uh
375:45 - really skilled Assembly Language
375:47 - programmers that they could get the same
375:49 - performance out of sea that they were
375:51 - used to getting inside Assembly Language
375:53 - and so what are registers well when you
375:56 - have a central processing unit and you
375:59 - have memory the data lives in the memory
376:01 - and the registers live in the central
376:02 - processing unit and depending on the
376:04 - speed of things a register might be you
376:07 - know 40 times faster than regular memory
376:10 - and so if you could keep a variable like
376:12 - I in a loop you could keep that in a
376:15 - register that's faster and so what we
376:18 - can do with saying register int X is say
376:20 - hey by the way next few lines X is a
376:23 - really important variable and I expect
376:24 - to use it a lot so if you can possibly
376:27 - not store this in memory please do so
376:30 - and that's why the only kind of weird
376:32 - thing about the register is you can't
376:33 - get the memory address of a register
376:36 - variable now in mon compilers we have
376:39 - runtime optimizers that are miraculous I
376:42 - mean they border on mirac even the
376:43 - simplest of runtime optimizers that
376:45 - speed the code up at runtime are
376:47 - miraculous and saying this is a register
376:51 - or that's a register might actually
376:53 - confuse things so all the register does
376:55 - is hey I am never going to ask you the
376:57 - address of this variable so don't bother
376:59 - putting it in memory if you don't feel
377:01 - like it okay so it's it's probably but I
377:04 - also think I think it's kind of
377:05 - fascinating and fun to think about this
377:09 - think about how early sea developers
377:12 - were so deeply connected to their
377:14 - Assembly Language that is at the
377:18 - runtime uh recursion recursion recursion
377:22 - recursion when a function calls itself
377:24 - it's called recursion it's a powerful
377:26 - it's a beautiful concept there is places
377:29 - when if you're given a treel like
377:32 - structure like you parse some XML or
377:33 - something and you're reading through the
377:35 - XML recursion is such a pretty way to
377:39 - write code I'm about to show you a very
377:42 - simple recursion example that are two
377:45 - things first they're really inefficient
377:48 - and silly uses of recursion and they
377:51 - mislead you as to why you should use
377:52 - recursion and they misleadingly kind of
377:55 - tell you that like recursion is great
377:57 - let's use it for something it doesn't e
377:58 - is not well used for so so really in
378:02 - this section I'm not trying to show you
378:06 - what recursion is used for well I'm more
378:08 - interested in giving you a
378:11 - really artificial synthetic example to
378:14 - show how the call stack works and how
378:18 - recursion works with the call stack so
378:21 - here we have I mean some tortured code
378:25 - it is not pretty code this is a I'm I'm
378:29 - writing code that if given a number like
378:31 - uh three adds up 1 plus 2 plus
378:35 - three okay and gives me six there are so
378:38 - many ways to do this there's even a
378:40 - close form solution that doesn't even
378:41 - require a loop that's called algebra but
378:45 - we're going to use
378:46 - recursion
378:48 - so if you look at the int main I'm going
378:51 - to say sum up three that means sum up
378:53 - things one two three so sum up is being
378:56 - called from Main and then I've got the
378:58 - return value and I say Su and you'll
378:59 - notice in the print out that Su is the
379:02 - very last thing that comes out and so if
379:04 - you
379:05 - walk through sum up you see that there
379:09 - is a parameter called above that's
379:11 - coming I call that above because it's
379:13 - coming from whoever's calling us there's
379:15 - a parameter below which is we're going
379:16 - to compute a value and send it down to
379:18 - the next copy of ourselves down and then
379:21 - sum is the sum of the the above value
379:24 - and the sum of the below values and then
379:27 - R Val is I mean actually sum is just
379:30 - coming back from the call to ourselves
379:32 - and then R Val is adding those two
379:34 - things
379:35 - together and I do this in exceedingly
379:37 - slow motion with print statements
379:39 - everywhere that just makes this look
379:40 - ugly because really the only thing that
379:42 - matters is where it says sum equals sum
379:44 - up below and what we're doing is we're
379:46 - calling the same function again so if
379:50 - you look at Main and you see the sumup
379:52 - call that is going to create a stack
379:55 - frame and in that stack frame it's going
379:57 - to have a whatever the three number is
379:59 - we're going to make an above variable
380:01 - copy three into the above variable and
380:03 - allocate a below sum and R valve so our
380:05 - stack frame is going to have four
380:07 - integers on it and then the function
380:10 - starts working and the way the r
380:12 - recursion works is there's always got to
380:14 - be a time at which it stops this is kind
380:16 - of like going down down down and it has
380:18 - to work its way back up if it goes down
380:20 - forever that's called a stack Overflow
380:22 - and then your computer runs out of
380:24 - memory and your application blows up so
380:26 - you know have to have a time at which
380:28 - the stack uh algorithm stops so what
380:32 - we're saying is if we're being told to
380:34 - sum up up one or less well we Define the
380:37 - sum of that as one so we just return the
380:39 - sum of everything up to one as one and
380:42 - that's our way of stopping the recursion
380:43 - at the bottom and then what we do is we
380:46 - take below and we subtract one from it
380:48 - so if we're being called with three
380:49 - below becomes two and so you see that
380:51 - over in the lower stack frame below is
380:54 - two right below is two and we're about
380:57 - to go down deeper into the call tree and
381:01 - um so we're going to we're going to call
381:03 - sum equals sum up below so what happens
381:06 - now is we're passing two in to another
381:09 - stack frame and so there's not really a
381:11 - cop another copy of the code but there's
381:13 - another stack frame and so now we're
381:15 - calling sum up with two as the parameter
381:19 - that's our below but then we see the
381:20 - stack frame and now this is the stack
381:22 - frame that's kind of on the left hand
381:23 - side there above in this stack frame is
381:26 - two and then execution begins and we
381:29 - subtract one from below well above is
381:33 - not less than one so we subtract one and
381:36 - above below becomes one because it's 2 -
381:40 - one and we're going to go down so it
381:41 - says down one which means it's going to
381:43 - again say sum equals sum up below and
381:47 - below in this case is
381:49 - one and so it makes another stack frame
381:52 - there's a so we're actually there
381:54 - there's a maximum of like three calls
381:56 - here and then it's going to work its way
381:57 - out so then it calls another stack frame
382:01 - that's not shown on the right hand side
382:03 - and then it runs runs with one as above
382:06 - and then above is less than or equal to
382:07 - one so it returns one and that's why it
382:09 - says in one and it doesn't say anything
382:12 - because then it's returned and it
382:13 - returned the value one so now the third
382:16 - stack frame comes off and now we're in
382:19 - the other stack frame and sum is what
382:21 - the return value of the sum up call was
382:24 - so it says back
382:25 - one and then it says above now we're now
382:28 - we're in the stack frame that's on the
382:29 - right hand side so sum is one below is
382:32 - one above is two and so we compute R Val
382:35 - which is 1 + 2 and that's three and we
382:38 - print that out and that's kind of where
382:40 - the where we're indicating and then we
382:42 - return the
382:43 - three right and then it returns R Val
382:47 - and it runs some more it gets three back
382:50 - then it adds the adds the three to it
382:53 - and returns one more time and the stack
382:55 - all pops up and eventually you get
382:58 - six and this is a I mean you can look at
383:02 - this as long as you like
383:06 - I don't this code is like a foolish way
383:08 - to make this calculation like most
383:10 - artificial recursion
383:12 - examples the key thing here is just
383:15 - think about the stack frame right every
383:17 - time you call in another stack frame
383:19 - happens call in stack frame happens and
383:21 - then when the return value happens it
383:22 - goes back to that stack frame so the
383:24 - stack frame is a way of pausing
383:26 - execution at the moment create a new
383:29 - stack frame execu in that stack frame
383:31 - and if you need to have a yet another
383:32 - stack frame and so this idea of creating
383:35 - stack frame with the parameters and
383:37 - automatic variables each time you call a
383:39 - function copying the parameters into
383:40 - that stack frame and then executing the
383:42 - function in that stack frame we're not
383:44 - making extra copies of the function we
383:47 - are just creating a new stack
383:50 - frame that's what the essence of
383:53 - recursion is is the fact that you have a
383:55 - stack and each call makes a stack frame
383:58 - and if you recursively call again you
384:00 - just make another stack frame and so
384:02 - it's almost easier in my mind to Think
384:05 - Through how stack frames work than it is
384:08 - to think through how recursive code
384:10 - works now I want to talk a little bit
384:13 - about the C preprocessor it's it's the
384:16 - last thing of this chapter and it's in
384:17 - some ways orthogonal to functions and
384:19 - program structure I mean it it is part
384:20 - of program
384:22 - structure and so I've talked a lot about
384:25 - how wonderfully the C
384:27 - compiler and eventually Unix solve so
384:31 - many problems of uh software source code
384:33 - portability
384:35 - and things like indianness and character
384:38 - arrays and masking shifting not being
384:42 - necessary that those were awesome but
384:44 - the problem was is that c has always
384:47 - operated in an environment the language
384:49 - has
384:50 - changed uh in the early days it uh it
384:54 - wasn't standardized by 84 it got
384:56 - standardized ancc came out a lot of
384:59 - people used it outside its original
385:01 - creation and so a lot of things got
385:03 - fixed in the first decade of C's use the
385:06 - language evolved a lot the language kept
385:08 - kept evolving and a lot of the things
385:10 - that would make it evolve are things
385:12 - like integers went from 32 bits in some
385:14 - situations to 64 bits and then you have
385:17 - to say well what is a long is long 64
385:20 - long 32 because in some it started with
385:23 - int being 16 bits and long being 32 and
385:26 - then long with 64 well for a while then
385:28 - ins were 32 and Longs were 32 and then
385:31 - ins were 32 and Longs were 64 and what
385:34 - would happen if ins were 64 and it had
385:36 - to do with computer architecture 64 bits
385:39 - right and so sometimes you would have a
385:43 - bit of code and it just what you knew
385:46 - you wanted a 32bit thing and you weren't
385:48 - sure if an INT or a long or a short was
385:49 - going to give you 32 and so you had to
385:52 - say you know I really need different
385:53 - source code like if I'm working on a
385:56 - pdp1 I got one thing and if I'm working
385:58 - at interd 732 I want another thing CU
386:00 - really I want a 32 a 32-bit integer and
386:04 - now there's actually int 32 in some of
386:06 - these things because you do need to know
386:07 - sometimes you're using 32-bit integer
386:09 - then libraries changed there's calling
386:12 - sequences that changed because again as
386:14 - computers got bigger and bigger and
386:15 - memory got bigger and dis drives got
386:17 - bigger you would be in a certain version
386:19 - of an operating system and and the the
386:22 - calls to reading files might be slightly
386:24 - different and so it's not really that
386:26 - the source code was portable it's the
386:28 - the the the calling sequences to library
386:31 - started to change um Hardware evolved
386:34 - operating systems evolved C started
386:36 - running on non-unix because C originally
386:39 - started on Unix but then it quickly went
386:41 - to other operating systems because it
386:43 - was such a powerful concept but
386:44 - sometimes in these other operating
386:46 - systems just things were kind of
386:48 - different because they weren't working
386:49 - on Unix and so the pre-processor really
386:52 - was a an effective way to patch your
386:55 - source code so that you could say look I
386:57 - I wrote this Source Code 10 years ago
386:59 - and it worked on a pdp1 and now I'm
387:02 - going to run this on an IBM 3 60
387:04 - architecture and I don't want to change
387:07 - that there's a few changes I need to
387:09 - make that have nothing to do with sort
387:11 - of the what what a for Loop looks like
387:13 - but it has to do with like what library
387:15 - I'm calling or what the return type for
387:17 - that Library might be so the
387:20 - pre-processor allowed us to put
387:22 - variations in the source code and the
387:25 - pre-processor it's really feels weird
387:27 - because it's it's syntax syntax is very
387:29 - different because the pre-processor is
387:31 - kind of a line oriented processor and
387:34 - has these pound things right these these
387:37 - um like pound if def pound Define pound
387:40 - else pound end if and pound include
387:43 - that's even a pre-processor so what the
387:46 - pre-processor is is a not a compiler at
387:49 - all it is a source code to source code
387:52 - translator it expands the include files
387:55 - and then it makes changes so in the top
387:56 - example where you see pound include
387:59 - stdio.h you can actually run GCC minus
388:02 - capital E and says just run on the
388:04 - pre-processor and shows me what comes
388:05 - out you take you know 10 12 lines of
388:08 - code on the left and it puts out
388:10 - hundreds and hundreds of lines of code
388:12 - on the right I'm only showing you a
388:14 - subset of it but the biggest part is the
388:16 - fact that include std. is literally
388:19 - expanded and then that is C code without
388:22 - the pound include okay so that's the
388:24 - pre-processor but then another example
388:27 - here is I'm creating this use underscore
388:30 - long this is not really a variable this
388:31 - is a compiled time variable so I'm going
388:34 - to create a new string called intore 32
388:38 - and if Ed long has been defined I'm
388:41 - going to make int 32 be long else I'm
388:44 - going to make intore 32 be an INT and
388:46 - again this could be a thing where I'm
388:48 - compiling for different architectures
388:49 - and I want this variable IP address to
388:53 - be a 32-bit integer and I need it to
388:56 - work on different operating
388:58 - systems so in this case um because use
389:01 - long is not defined int 32 as a string
389:05 - substitution like a macro string
389:07 - substitution before the compiler even
389:08 - does anything turns n32 into int and so
389:12 - that's what the uh five lines of pound
389:15 - if Def and all that stuff do is it says
389:17 - change this in32 string in my source
389:20 - code into int and so what we see on the
389:23 - right is really C code what we see on
389:26 - the left is kind of c pre-processor plus
389:29 - c code and so the pre-processor
389:32 - transforms source code to source code so
389:36 - I was looking around at some old code
389:37 - that I happen to have grabbed and put
389:39 - into uh GitHub which was some code from
389:43 - 1994 from X Mosaic 1.2 and for those of
389:47 - you took my internet history technology
389:49 - and security you know that X Mosaic was
389:51 - the first web browser that was portable
389:55 - across multiple operating systems which
389:57 - and the more and then eventually Mosaic
389:59 - ended up on uh unic systems with x
390:02 - windows that's why it's called X mosaic
390:04 - and it went to the mac and went to the
390:05 - PC and so it was really many unix's Mac
390:08 - and PC and what we're seeing here on the
390:11 - right hand side is actual source code
390:13 - from that which was written in like 1993
390:16 - 1994 and what you see is a bunch of if
390:18 - defs in if and defs and some comments
390:22 - and like there's a if def Solaris 9
390:24 - broken um and it has to do with like
390:26 - where do we find the error messages on
390:28 - this across all these weird operating
390:31 - systems because the way they put error
390:34 - sometimes they would use extern which
390:35 - are Global variables defined inside the
390:37 - runtime and we would just look at those
390:40 - variables we would make a function call
390:42 - and it would write into these Global
390:43 - variables but then that Global variable
390:45 - might be different so this is actually
390:47 - from some code that was
390:49 - HTT p and
390:52 - C that was some early network
390:54 - connections now these days you know we
390:56 - just do this stuff in like pound import
390:58 - requests in Python but in those days the
391:01 - C libraries for network connections were
391:04 - really different meaning that they were
391:06 - just you know here comes the network
391:08 - here's this language C It's Been Around
391:10 - by you know 89
391:13 - 991 we were the network was there and so
391:16 - we were building libraries but then how
391:18 - each Library worked in each operating
391:19 - system was a little wonky and so they
391:23 - had to write different C code to
391:25 - compensate for the different operating
391:27 - systems that this C program a web
391:30 - browser would be running on and so all
391:33 - these if defs mean that one source code
391:36 - with a few
391:37 - predefined constants compile time
391:40 - constants could then work on a wide
391:43 - range of of operating systems and so yes
391:46 - the C language itself is portability
391:48 - portable but we also want to be portable
391:50 - over time and so sometimes Library Val
391:54 - libraries change operating systems
391:55 - change um and we want to be able to
391:58 - compensate for that and so this is an
392:01 - important part of C these days it's less
392:04 - important um because a lot of the
392:06 - libraries have stabilized and they don't
392:08 - change quite so much and so this code
392:10 - here would probably just be a bit of
392:12 - socket code and the errors would come
392:13 - back the same way no matter what version
392:17 - like um VMS is an operating system that
392:21 - doesn't exist anymore think C it doesn't
392:23 - exist anymore NEX doesn't exist anymore
392:26 - Solaris doesn't exist anymore so these
392:28 - are all operating systems that don't
392:30 - even exist anymore but this code was
392:32 - portable across all those things
392:34 - and actually I I compiled all this and
392:36 - you can kind of take a look at it I made
392:37 - a a video where I re resurrected this
392:40 - code oh it's got to be eight or nine
392:42 - years ago on a Macintosh which is an
392:45 - evolved from next I don't know if I
392:47 - could get it to work again but back then
392:49 - I got it to work on a Macintosh and I
392:51 - said to find it as next and so I
392:54 - compiled this C code and I there's there
392:57 - wasn't there is an x- windows on
392:58 - Macintosh I got the x windows Library I
393:00 - got all this stuff working and I told it
393:02 - you're an next and then I recompiled the
393:04 - C code and eventually something came up
393:07 - and I I made a video about it and so
393:09 - because I knew that it'd be very
393:11 - difficult to keep this thing working
393:13 - over time but to go from 1994 to
393:18 - 2014 um and recompile something in you
393:21 - know 20 years later uh that's still
393:23 - pretty impressive that that next code
393:25 - would still work uh things like the V VM
393:27 - code VMS code there's no VMS computers
393:30 - that I know of uh these days so just it
393:34 - just shows that the idea of you know
393:39 - portability is a it it some of it is
393:43 - simple and elegant and was laid down in
393:46 - 1978 but then there are things outside
393:49 - the programming language that were
393:50 - evolving uh and still are evolving to
393:53 - this day and if you are doing uh C
393:55 - coding today or C++ coding today you may
393:58 - be using things that start with pound
394:00 - sign which are compiler directives
394:02 - rather than um C code so with that uh
394:08 - dive into chapter four and uh learn
394:11 - about
394:13 - [Music]
394:24 - functions welcome to C programming for
394:26 - everybody my name is Charles sance and
394:29 - this is my reading of the 1978 C
394:32 - programming book written by Brian
394:33 - kernigan and Dennis Richie at times I
394:36 - add my own interpretation of the
394:38 - material from a historical
394:40 - perspective chapter four functions in
394:43 - program structure functions break large
394:45 - Computing tasks into smaller ones and
394:48 - enable people to build on what others
394:50 - have done instead of starting over from
394:52 - scratch appropriate functions can often
394:54 - hide details of operation from parts of
394:56 - the program that don't need to know
394:58 - about them thus clarifying the whole and
395:00 - easing the pain of making changes C has
395:04 - been designed to make functions
395:05 - efficient and easy to use C programs
395:08 - generally consist of numerous small
395:10 - functions rather than a few big ones a
395:13 - program May reside on one or more source
395:15 - files in any convenient way the source
395:17 - files may be compiled separately and
395:19 - loaded together along with previously
395:22 - compiled functions from libraries we
395:24 - will not go into that process here since
395:26 - the details vary according to the local
395:29 - system most programmers are familiar
395:32 - with Library functions for inut and
395:33 - output like get Char and put charart and
395:36 - numerical computations like s cosine and
395:39 - square root in this chapter we will show
395:41 - more about writing new
395:44 - functions 4.1 Basics to begin let us
395:49 - design and write a program to print each
395:51 - line of input that contains a particular
395:53 - pattern or string of characters this is
395:56 - a special function of the Unix utility
395:58 - program grap for example searching for
396:01 - the pattern the' in the set of lines now
396:04 - is the time for all good men to come to
396:07 - the aid of their party will produce the
396:10 - output now is the time men to come to
396:14 - the aid of their party the basic
396:17 - structure of the task Falls neatly into
396:19 - three pieces while there's another line
396:23 - if that line contains a pattern print
396:25 - it although it's certainly possible to
396:28 - put the code for all of this in one main
396:30 - routine a better way is to use the
396:32 - natural structure to Advantage
396:34 - by making each part a separate function
396:36 - three small pieces are easier to deal
396:38 - with than the one big one because
396:40 - irrelevant details can be buried in the
396:43 - functions and the chance of unwanted
396:45 - interactions minimized and the pieces
396:48 - might even be useful later in their own
396:51 - right while there is another line is get
396:54 - line a function we wrote in chapter one
396:56 - and print it is print F which someone
396:59 - has already provided for us this means
397:01 - that we need to only write a routine
397:03 - which which decides if the line contains
397:05 - an occurrence of the pattern we can
397:08 - solve that problem by stealing a design
397:10 - from pl1 the function
397:13 - index s comma T Returns the position or
397:17 - index in the string s where the string T
397:19 - begins or minus one if s doesn't contain
397:23 - T we use zero rather than one as the
397:26 - starting position in s because C arrays
397:28 - always begin at position zero when we
397:31 - later need more sophisticated pattern
397:33 - matching we only have to replace index
397:36 - the rest of the code can remain the
397:39 - same recall that because the modern
397:42 - stdio.h defines a getline function
397:44 - whenever the book writes this function
397:46 - to teach a feature of functions we reame
397:49 - it to get underscore
397:52 - line given this much design filling in
397:54 - the details of the program is
397:56 - straightforward here's the whole thing
397:58 - so you can see how the pieces fit
397:59 - together for now the pattern to be
398:01 - searched for is a literal string in the
398:04 - argument of index which is not the most
398:06 - general of mechanisms we will return
398:09 - shortly to a discussion of how to
398:11 - initialize character raise and in
398:12 - chapter five we will show how to make
398:14 - the pattern a parameter that is set when
398:17 - the program is run this is also a new
398:20 - version of getline you might find it
398:22 - instructive to compare it to the one in
398:24 - chapter
398:26 - one pound include
398:28 - stdio.h pound Define MAX Line 1000 Main
398:32 - open parth Pary closed parentheses open
398:34 - curly brace Char Line open square
398:38 - bracket MAX Line closed square bracket
398:41 - semicolon while parentheses get Line
398:44 - open parentheses line comma MAX Line
398:46 - closed parentheses greater than zero
398:49 - Clos parentheses if open parentheses
398:52 - index open parthey Line comma double
398:55 - quote the double quote close parentheses
398:58 - greater than or equal to
399:00 - zero close parentheses print F open
399:03 - parthey double quote percent s double
399:06 - quote comma line Clos parentheses
399:10 - semicolon and a close curly brace to
399:12 - finish the main
399:15 - function next function is get line get
399:19 - Line open parentheses s comma limb
399:21 - closed parentheses Char s open square
399:25 - bracket close square bracket semicolon
399:27 - int limb semicolon open curly brace int
399:32 - C comma I I
399:34 - semicolon for I equal 0 semicolon I less
399:39 - than Lim minus1 and Pen C equals get
399:43 - Char open pen Clos pen Clos pen not
399:45 - equal
399:46 - EF double Amper sand c not equal double
399:51 - quot back slash N double quote semicolon
399:54 - Plus+ I close parentheses S Sub I equals
399:59 - c that Loop basically read until it
400:02 - found a new line or and Def
400:04 - file
400:06 - if open parentheses cble equals quot
400:10 - back slash and quot close parentheses
400:12 - open curly brace S Sub I equal C plus
400:16 - plus I semicolon Clos curly brace
400:18 - closing the
400:23 - f s subi equals quote back0 quote
400:28 - semicolon to terminate the string
400:30 - properly return open par
400:34 - I Clos PR semicolon to return the length
400:38 - of the line and then close curly brace
400:40 - to finish the getline function and now
400:43 - the new
400:44 - code index open parentheses s comma T
400:47 - close parentheses Char s open square
400:51 - bracket close square bracket comma T
400:53 - open square bracket close square bracket
400:56 - semicolon I would note that when we are
401:00 - declaring a character array and we don't
401:02 - give the length of the array that means
401:03 - that we're inside of a function the
401:06 - length of the array exists but it was
401:08 - from the calling calling code so j s
401:13 - open square bracket closed square
401:14 - bracket T open square bracket closed
401:17 - square bracket semic equalent means
401:19 - parameters s and t are strings of some
401:22 - length and we will use back sl0 to know
401:24 - when that length is done beginning the
401:27 - code in index with an open curly brace
401:30 - int I comma J comma k
401:34 - semicolon and then we have two nested
401:36 - for Loops for open print I equals 0 S
401:41 - Sub I not equal to back0 semicolon I ++
401:46 - open curly
401:48 - brace for JAL I comma K = 0 semicolon t
401:56 - t subk not equal to Back sl0 and Double
402:00 - Amper sand s subj equal T sub K
402:05 - semicolon j++
402:07 - k++
402:10 - semicolon if open PR t subk double
402:14 - equals quot back sl0 quote close PR
402:18 - return open PR I close peren semicolon
402:21 - close curly brace return open peren
402:25 - minus one close peren semicolon curly
402:31 - brace each function has the form name
402:35 - argument list if
402:37 - any in parenthesis argument declarations
402:40 - if any open curly brace declarations and
402:43 - statements if any Clos curly brace as
402:46 - suggested various parts may be absent a
402:48 - minimal function is dummy open pen
402:51 - closed pen open curly brace closed curly
402:54 - brace which does nothing a do nothing
402:57 - function is sometimes useful as a
402:59 - placeholder during program development
403:01 - the function name may also be preceded
403:03 - by a type if the function returns
403:06 - something other than an integer value
403:08 - this is the topic of the next
403:10 - section a program is just a set of
403:13 - individual function definitions
403:15 - communication between the functions is
403:17 - in this case by arguments and values
403:19 - return by the functions it can also be
403:22 - via external variables the functions can
403:24 - occur in any order in the source file
403:26 - and the source program can be split into
403:28 - multiple files so long as no function is
403:31 - split the return statement is the
403:33 - mechanism for returning a residual value
403:36 - from the called function to its caller
403:39 - any expression can follow return return
403:43 - open parentheses expression close
403:45 - parentheses the calling function is free
403:47 - to ignore the return value if it wishes
403:50 - furthermore there need there is no need
403:54 - to have an expression after the return
403:56 - in that case no value is returned to the
403:58 - caller control also returns to the
404:00 - caller with no value when EX ution falls
404:04 - off the end of the function by reaching
404:06 - the right closing brace it is not
404:08 - illegal but probably a sign of trouble
404:11 - if a function returns a value from one
404:13 - place and no value from another place in
404:16 - any case the residual value of a
404:18 - function which does not return one is
404:21 - certain to be garbage the C verifier
404:23 - lint checks for such
404:26 - errors mechanics of how to compile and
404:29 - lot toy program which resides on
404:30 - multiple source files vary from one
404:33 - system to the next on the Unix system
404:35 - for example the CC command mentioned in
404:37 - chapter one does the job suppose that
404:40 - three functions are in three files
404:42 - called main.c getline Doc and index. C
404:46 - then the command CC main.c get line. C
404:50 - index. C compiles the three files and PR
404:54 - places the resulting relocatable object
404:56 - code in files main. o get line. o and
404:59 - index. O and loads them all into an
405:01 - executable file named a do out if there
405:04 - is an error say in main.c that file can
405:07 - be recompiled by itself and the result
405:10 - loaded with the previous object files
405:12 - with the command CC main.c get line. o
405:16 - index. o the CC command uses the C
405:19 - suffix versus the suffix naming
405:21 - convention to distinguish source files
405:24 - from object
405:25 - files I would note that this CC example
405:29 - exactly as the authors has wrote it does
405:30 - not quite work as described in modern SE
405:33 - compilers if you want to compile your
405:35 - source code and leave the compiled
405:37 - object code around after the compile you
405:39 - add the minus C option to the compiler
405:41 - call Modern C compilers generally do
405:44 - accept multiple files with either C or.
405:46 - O suffixes and comi combine them into a
405:50 - runnable application section 4.2
405:53 - functions returning non-
405:55 - integers so far none of our programs has
405:58 - contained any Declaration of the type of
406:00 - a function this is because by default
406:02 - called a function is implicitly declared
406:05 - by its appearance in an expression or
406:07 - statement such as while open print get
406:11 - Line open print line comma MAX Line Clos
406:13 - print greater than zero Clos print if a
406:16 - name which has not been previously
406:18 - declared occurs in an expression and is
406:21 - followed by a left parentheses it is
406:23 - declared by context to be a function
406:25 - name furthermore by default the function
406:29 - is assumed to return an INT since Char
406:32 - promotes to INT in Expressions there is
406:34 - no need to declare functions that return
406:37 - Char these assumptions cover the
406:39 - majority of classes including all of our
406:41 - examples so
406:43 - far I would add that's not true quite
406:46 - true anymore in modern C languages you
406:49 - are required to provide a type for each
406:51 - function if you leave off the type for a
406:54 - function declaration at a minimum you
406:55 - will give a get a Stern warning message
406:58 - but sometimes functions do not intend to
407:00 - return anything at all and so so the
407:03 - void type was invented to indicate that
407:06 - a function returns nothing the rule of
407:08 - requiring a type on a modern function
407:11 - definition in C even if it's void allows
407:13 - the compiler check to make sure all of
407:15 - your return values in a function match
407:18 - the expected return
407:20 - type back to the text but what happens
407:24 - if a function must return some other
407:26 - type many numerical function like square
407:29 - root S and cosine return double other
407:32 - specialized function functions return
407:33 - other types to illustrate how to deal
407:35 - with this let us write and use the
407:37 - function a to F which converts its
407:40 - argument string s to its double
407:42 - Precision floating Point equivalent a2f
407:46 - is an extension of a to I which we wrote
407:49 - versions of in chapters 2 and three it
407:52 - handles an optional sign and decimal
407:53 - point and the presence or absence of
407:55 - either the integer or fractional
407:58 - part we would note that this is not a
408:00 - highquality input conversion routine
408:03 - takes doing everything takes a bit more
408:05 - space than we care to use here in this
408:06 - book first a to F must declare the type
408:10 - of the value it returns since it's not
408:12 - int because float is converted to double
408:14 - in Expressions there is no point in
408:16 - saying that a to F returns float we
408:19 - might as well make use of the extra
408:20 - precision and thus declare it to return
408:22 - double the type name precedes the
408:25 - function name like this double A to F
408:29 - open parentheses s closed parentheses
408:31 - char s open square bracket closed square
408:35 - bracket open curly brace double Val
408:38 - comma power int I comma sign semicolon
408:42 - for I equal 0 semicolon s subi double
408:46 - equals quote space quote or SBI double
408:50 - equals quot back slash and quote or
408:55 - SBI double equals quot backt quote
408:58 - semicolon
409:00 - i++ semicolon that's skips the white
409:03 - space s equal
409:06 - 1 if s subi dou equals quot plus quote
409:10 - or s double equals quote minus
409:14 - quote s equals and now we're going to
409:17 - use a turn operator here pen S Sub i++
409:22 - close bracket double equals quote plus
409:25 - quote close Pin question mark one colon
409:30 - minus one semicolon and basically tells
409:33 - us it it makes sign be one or negative 1
409:36 - based on the presence or absence of a
409:39 - plus or
409:41 - minus for Val equals 0 semicolon s subi
409:45 - greater than or equal to quot 0 quote
409:47 - double Amper s subi less than or equal
409:50 - toble quot 9 quot I
409:53 - ++ Clos PR Val equals 10 * Val plus s
409:59 - subi minus qu0 quot semicolon what this
410:03 - is doing is multiplying the current
410:04 - value by 10 in effect shifting it left
410:06 - and then adding in that new lower empty
410:09 - spot um the digit that we're
410:11 - encountering which is somewhere between
410:13 - the character Zero and the character
410:15 - nine continuing if parentheses s subi
410:19 - double equals quote. quote Clos
410:21 - parentheses
410:25 - i++ four open parentheses power equals
410:29 - 1 semicolon S Sub I greater than or
410:33 - equal to qu0 quote double Amper sand S
410:36 - Sub I less than or equal toot 9 quot
410:39 - semicolon I ++ open curly brace Val
410:43 - equals 10 * Val plus S Sub I minus quot
410:48 - 0
410:49 - quote again Shifting the number to the
410:52 - left as it's as we encounter characters
410:55 - Power Star equals 10 semicolon close
410:59 - curly
411:00 - brace return open parentheses s times
411:05 - Val over power close parentheses
411:09 - semicolon close curly
411:13 - brace second and just as important the
411:16 - calling routine must state that a to F
411:19 - returns a non-int value the Declaration
411:21 - is shown in the Pro following primitive
411:23 - desk calculator barely adequate for
411:25 - checkbook balancing which reads one
411:28 - number per line optionally preceded by
411:30 - sign and adds them all up printing the
411:32 - sum after each
411:35 - input this example is from page 70 of
411:38 - the textbook pound include
411:41 - stdio.h pound Define MAX Line 100 Main
411:46 - open parentheses close parentheses open
411:49 - curly brace double sum comma a to F open
411:52 - parentheses closed parentheses
411:54 - semicolon Char Line open square bracket
411:57 - MAX Line Clos square bracket semicolon
412:00 - sum equals zer while open parentheses
412:03 - get Line open parentheses line comma MAX
412:06 - Line close parentheses greater than zero
412:09 - close
412:10 - parentheses print F quote back
412:14 - SLT percent. 2f back sln comma sum plus
412:21 - equals a to F open parentheses line
412:24 - closed parentheses close parentheses
412:27 - semicolon close curly
412:29 - brace that code use the plus plus side
412:32 - effect operator and merge the called to
412:36 - a to F right into the parameter of the
412:38 - second parameter of print
412:40 - F the Declaration double sum a to F open
412:44 - parentheses closed parentheses says that
412:46 - sum is a double variable and that a to F
412:49 - is a function that returns a double
412:51 - value as a pneumonic it suggests that
412:54 - sum and a to F parentheses dot dot dot
412:56 - are both double Precision floating Point
412:59 - values unless a to F is explicitly
413:01 - declared in both places C assumes it
413:05 - returns an integer and you will get
413:06 - nonsense
413:08 - answers if a to F itself and the call to
413:11 - it in main are typed inconsistently with
413:14 - the with in the same source file it will
413:16 - be detected by the compiler but if as is
413:19 - more likely a to F were compiled
413:21 - separately the mismatch would not be
413:23 - detected and a to F would return a
413:25 - double which main would treat as an end
413:28 - and meaningless answers would result
413:31 - Lind catches this
413:33 - error given a to F we could in principle
413:36 - write a to I to convert a string to an
413:39 - integer in terms of it int a to I open
413:43 - parentheses s closed parentheses Char s
413:46 - open square bracket closed square
413:48 - bracket semicolon open curly brace
413:50 - double A to F open parentheses closed
413:53 - parentheses
413:54 - semicolon return open parentheses a to F
413:58 - close parentheses s close parentheses
414:00 - close parentheses semicolon Clos curly
414:03 - brace note the structure of the
414:05 - Declarations in the return statement the
414:07 - value in the expression and return
414:09 - expression is always converted to the
414:11 - type of the function before the return
414:14 - is taken therefore the value of a to f a
414:18 - double is converted automatically to int
414:20 - when it appears in a return since the
414:24 - function a toi returns an
414:27 - INT the conversion of a floating point
414:29 - value to int truncates any fractional
414:32 - part as we discussed in chapter two more
414:35 - on function arguments in chapter one we
414:38 - discussed the fact that function
414:39 - arguments are passed by value that is
414:42 - the called function receives a private
414:45 - temporary copy of each argument not its
414:47 - address this means that the function
414:50 - cannot affect the original argument in
414:52 - the calling function within a function
414:55 - each argument is in a a local variable
414:57 - initialized to the value with which the
414:59 - function was called when an array name
415:02 - appears as an argument to a function the
415:04 - location of the beginning of the array
415:06 - is passed elements are not copied the
415:10 - function can alter elements of the array
415:13 - by subscripting from this location the
415:15 - effect is that arrays are always passed
415:18 - by reference in chapter five we will
415:21 - discuss the use of pointers to permit
415:23 - functions to affect non- arrays in
415:26 - calling
415:27 - functions a bit of a a
415:30 - digression since including a array as an
415:32 - argument passes the location or memory
415:35 - address of the array into the function
415:36 - the function cannot can change the items
415:38 - in the array using array subscripts in
415:41 - particular the array contents are not
415:44 - copied when an array is passed into a c
415:46 - function when we get to strs in a future
415:49 - chapter we will find that the content of
415:51 - strs also are passed using the address
415:54 - of the entire struct so strs are passed
415:56 - by reference as
415:58 - well when thinking about pass by
416:00 - reference or pass by value remember that
416:02 - a Char variable is a single item similar
416:05 - to int and passed by value I.E it is
416:07 - copied in C strings are arrays of
416:11 - characters so they are passed by
416:14 - reference python follows this design for
416:17 - the same efficiency reason is C normal
416:20 - single variables like int or float are
416:22 - copied before being passed into a
416:24 - function and therefore passed by value
416:27 - collections like list or dict are passed
416:30 - into functions by reference so the
416:32 - contents can be changed within a
416:34 - function python strings are not
416:37 - technically copied when being passed
416:39 - into a function but the way assignments
416:41 - happen in Python make it seem like
416:43 - strings are passed by value since they
416:46 - can never be modified you can learn more
416:49 - with a bit of web research but the easy
416:52 - way is to imagine in Python that strings
416:54 - are passed by value with a clever trick
416:56 - to avoid requiring a copy for every
416:58 - function call PHP follows the same
417:01 - pattern of passing numbers and strings
417:03 - by value and passing arrays as
417:06 - reference PHP passes strings by value
417:08 - without recever without requiring a copy
417:12 - again using clever runtime code because
417:15 - in Java JavaScript and PHP strings are
417:18 - objects of course which we haven't
417:20 - discussed much yet those languages can
417:23 - make sure that strings act as if they
417:25 - were passed by value and not passed by
417:27 - reference the way they are always passed
417:29 - in C C made decision
417:32 - on its runtime based on getting the
417:34 - maximum performance out of the hardware
417:36 - of the 1970s at the expense of making it
417:39 - too easy to write code that overwrites
417:41 - memory and leads to corrupted programs
417:43 - that have dangerous and undefined
417:45 - Behavior languages like PHP Java and
417:48 - JavaScript add a small amount of runtime
417:51 - overhead to do things like store the
417:53 - length of an array and make sure we
417:55 - programmers don't over reference the
417:58 - array and overwrite random bits of our
418:00 - programs code or data
418:03 - the creators of C placed more priority
418:05 - on speed and efficient use of memory
418:08 - than safety it is like driving an autom
418:11 - automobile in the rain without ABS
418:13 - automatic braking system it is fast but
418:16 - dangerous and should be reserved by
418:19 - highly skilled and very careful
418:21 - programmers and drivers and those
418:24 - drivers should probably be on a race
418:26 - course by the way back to the text by
418:30 - the way there is no entire L
418:32 - satisfactory way to write a portable
418:34 - function that accepts a variable number
418:36 - of arguments because there is no
418:37 - portable way for the called function to
418:39 - determine how many arguments were
418:41 - actually passed in a given
418:43 - call thus you can't write a truly
418:46 - portable function that will compute the
418:48 - maximum of an arbitrary number of
418:50 - arguments as well the max functions that
418:53 - are built in to Fortran and
418:55 - pl1 it is generally safe to deal with a
418:58 - variable number of arguments if the
418:59 - called function doesn't use an argument
419:01 - that was not actually supplied and if
419:03 - the types are consistent print F the
419:06 - most common C function with a variable
419:08 - number of arguments uses information
419:11 - from the first argument which is the
419:13 - formatting string to determine how many
419:15 - other arguments are present and what
419:17 - their types are it fails badly if the
419:20 - caller does not supply enough arguments
419:22 - or if types are not what the first
419:23 - argument says it is also non-portable
419:27 - and therefore must be modified for
419:29 - different programming environments
419:32 - alternatively if arguments are of known
419:34 - types it is possible to Mark the end of
419:36 - the argument list in some agreed upon
419:38 - way such as a special argument value
419:41 - often zero that stands for the end of
419:43 - the
419:44 - arguments interestingly modern languages
419:46 - like python PHP and Java go to Great
419:49 - Links to make variable length argument
419:52 - lists work predictably and portably the
419:54 - Syntax for variable length argument
419:56 - lists in these language can be a bit
419:57 - obtuse at times but at least it's
419:59 - allowed documented reli iable and
420:03 - portable section four external variables
420:07 - a c program consists of a set of
420:10 - external objects which are either
420:12 - variables or functions the adjective
420:15 - external is used primarily in contrast
420:18 - to internal which describes arguments
420:20 - and automatic variables defined inside
420:23 - functions external variables are defined
420:25 - outside any function and are thus
420:28 - potentially available to many functions
420:31 - functions themselves are always external
420:33 - because C does not allow functions to be
420:36 - defined inside other functions by
420:38 - default external variables are also
420:41 - Global so that all references to such a
420:43 - variable by the same name even from
420:45 - functions that are compiled separately
420:47 - are references to the same thing in this
420:51 - sense external variables are analogous
420:53 - to Fortran common or pl1 external we
420:57 - will later see how to define external
420:58 - variables and functions that are not
421:00 - globally available but but instead only
421:02 - visible within a single source
421:05 - file because external variables are
421:08 - globally accessible they provide an
421:10 - alternative to function arguments and
421:12 - return values for communicating data
421:14 - between function any function May access
421:17 - an external variable by referring it to
421:19 - by
421:20 - name if the name has been declared
421:23 - somehow if a large number of variables
421:26 - must be shared among functions external
421:27 - variables are a more convenient and
421:29 - efficient than long argument list
421:32 - as pointed out in chapter one however
421:34 - this reasoning should be applied with
421:36 - some caution for it can have a bad
421:38 - effect on program structure and lead to
421:41 - programs with many data connections
421:43 - between
421:45 - functions a second reason for using
421:48 - external variables concerns
421:50 - initialization in particular external
421:52 - arrays may be initialized but automatic
421:55 - I.E internal arrays may not we will
421:57 - treat initialization near the end of
421:59 - this
422:00 - chapter the third reason for using
422:03 - external variables is their scope and
422:05 - lifetime automatic variables are
422:07 - internal to a function they come into
422:10 - existence when the routine is entered
422:12 - and disappear when it's left external
422:15 - variables on the other hand are
422:16 - permanent they do not come and go so
422:18 - they retain values from one function
422:20 - invocation to the next thus if two
422:23 - functions must share some data yet
422:25 - neither calls the other it is often most
422:27 - convenient if the shared data is kept in
422:30 - external variables rather than rather
422:32 - than passed in and out via
422:34 - arguments let's examine this issue
422:36 - further with a larger example the
422:38 - problem is to write another calculator
422:41 - program better than the previous one
422:44 - this one permits plus minus asterisk and
422:47 - Slash and equals equals will print our
422:51 - answer because it is somewhat easier to
422:53 - implement the calculator will use
422:55 - reverse polish notation instead of infix
422:59 - notation reverse polish notation is the
423:02 - scheme used by for example hulet Packard
423:05 - pocket
423:06 - calculators in Reverse polish notation
423:09 - each operator follows its operators
423:12 - operand an infix expression like open
423:15 - parentheses 1 minus 2 closed parentheses
423:18 - star open parentheses 4 + 5 closed
423:21 - parentheses equals is entered as 1 2
423:26 - minus
423:28 - 45 + star equals
423:32 - parentheses are not needed in Reverse
423:35 - polish notation the implementation is
423:37 - quite simple each operand is pushed onto
423:41 - a stack when an operator arrives the
423:43 - proper number of operands two for binary
423:46 - operators are popped the operator
423:49 - applied to them and the result is pushed
423:50 - back onto the stack in the example above
423:54 - one and two are pushed then replaced by
423:56 - their difference neg1 next four and five
423:59 - are pushed then replaced by their sum N9
424:02 - and then the product of -1 and 9 which
424:05 - is9 replaces them on the stack and then
424:08 - the equal sign operator prints the top
424:10 - element without removing
424:12 - it so intermediate steps in a
424:15 - calculation can be
424:16 - checked the operations of pushing and
424:19 - popping a stack are trivial but by the
424:21 - time airor detection and Recovery are
424:23 - added they're long enough so it's better
424:25 - to put each in a separate function then
424:27 - to repeat the code throughout the whole
424:29 - program and there should be a separate
424:31 - function for f fetching the next input
424:33 - operator or operant thus the overall
424:36 - structure of the program is while next
424:39 - operator or operand is not end file if
424:42 - it's a number push it else if it's an
424:45 - operator pop operands do the oper
424:47 - operation and push the result else error
424:51 - the main design decision that has not
424:53 - yet been discussed is where the stack is
424:55 - that is what routines access it directly
424:59 - one possibility is to keep it in Main
425:01 - and pass the stack and current stack
425:03 - position to the rettin that push and pop
425:05 - it but N Main doesn't need to know about
425:07 - the variables that control the stack it
425:09 - should only think about pushing and
425:11 - popping so we have decided to make the
425:14 - stack and its Associated
425:16 - information external variables
425:18 - accessible to push and pop but not to
425:21 - main translating this outline to code is
425:24 - easy enough the main program is
425:26 - primarily a big switch on the type of
425:29 - operator or operand this is a more
425:32 - typical use of switch than the one shown
425:34 - in chapter
425:36 - 3 this sample code is from page 74 of
425:40 - the
425:42 - textbook pound include
425:45 - stdio.h pound Define Max op 20 pound
425:49 - toine number quote zero quote this is
425:52 - going to be a single we found a number
425:54 - and pound toine two big quote N quote a
425:56 - signal that the string is too
425:59 - big main open print
426:02 - closed parentheses open curly brace int
426:06 - type semicolon Char s open square
426:09 - bracket Max op Clos square bracket
426:12 - semicolon double op two a to F open
426:16 - parentheses closed parentheses comma pop
426:20 - open parentheses Clos parentheses comma
426:22 - push open parentheses closed parentheses
426:27 - semicolon while open parthey open
426:29 - parentheses type equals get up open
426:32 - parentheses s comma Max op closed
426:34 - parentheses closed parentheses not equal
426:36 - e f closed
426:39 - parentheses switch open parentheses type
426:42 - closed parentheses open curly brace case
426:45 - number
426:46 - colon note that number is a predefined
426:49 - constant above push open parentheses a
426:52 - to F open parentheses s close
426:54 - parentheses Clos parentheses semicolon
426:58 - break case quote plus quote colon push
427:03 - open parentheses pop open pin Clos pin
427:06 - plus pop open pin Clos pin Clos pin
427:09 - semicolon break semicolon case quote
427:13 - asteris quote
427:15 - colon push open pin pop open pen Clos
427:19 - pin asterisk pop open pen Clos pin Clos
427:24 - P semicolon break semicolon that was the
427:27 - multiplication
427:29 - case quote quote colon op two equals pop
427:35 - open Forint close PR push open print pop
427:39 - minus op2 Clos print semicolon break
427:43 - semicolon that was
427:45 - subtraction case open pin slash Clos pin
427:50 - colon Op 2 equals pop open pin
427:55 - semicolon if op two not equal 0.0 push
428:01 - open print pop open print Clos print SL
428:04 - Op 2 close print semicolon else print F
428:09 - double quote zero divisor popped back
428:12 - sln double quote close print semicolon
428:17 - break case quote equal quote colon print
428:23 - F open PR double quote backt percent F
428:26 - back sln double quote comma push open
428:30 - pin pop open print close print close
428:33 - print close print semicolon so to print
428:36 - it we pop it and push it and then print
428:40 - the residual value of the push function
428:42 - the next line is break
428:44 - semicolon case quote C quote colon clear
428:49 - open print Clos print semicolon break
428:52 - semicolon case too big colon print F
428:58 - double quot percent. 20s
429:02 - space dot dot dot is too long back sln
429:04 - double quote comma s close Pin semicolon
429:08 - break
429:09 - semicolon default colon print F open
429:13 - print double quote unknown command
429:15 - percent C back sln double quote comma
429:18 - type open print Clos print semicolon
429:21 - break semicolon close P close curly
429:24 - brace to finish the switch statement and
429:26 - then close curly brace to
429:29 - finish the main
429:32 - so now we're going to have a separate
429:34 - file that has some of these functions
429:36 - defined this file is on page 75 of the
429:42 - textbook this file will be compiled
429:44 - separately but then later linked all
429:47 - together with the main program but we're
429:48 - going to Define push pop and clear in
429:52 - this
429:53 - file pound include
429:56 - stdio.h pound toine maxv Val 100 maximum
430:01 - value that' be the maximum value of our
430:02 - stack the maximum size of our stack
430:04 - maximum depth of our stack now we are
430:07 - declaring variables outside of any
430:10 - function these are the external
430:11 - variables int SP equals z double Val
430:16 - open square bracket Max Val closed
430:18 - square bracket
430:21 - semicolon and so those variables are
430:23 - external variables and they're outside
430:24 - of all of the functions but we can use
430:26 - them in any function and there's just
430:28 - one copy no matter what function we're
430:30 - using in so now Define our
430:32 - functions double push open pen F Clos
430:36 - pen double F semicolon open curly brace
430:40 - if open pen SP less than Max Val Clos
430:44 - pen return open pen Val open square
430:48 - bracket SP Plus+ closed square bracket
430:50 - equals F Clos pen
430:53 - semicolon else open curly brace print F
430:58 - double quote air colon stack full back
431:01 - SL N double quote Clos print semicolon
431:04 - clear open print Clos print semicolon
431:07 - return open print zero close PR
431:09 - semicolon close curly brace to finish
431:13 - the else and then close curly brace to
431:15 - finish the double function the push
431:19 - function and now we Define the pop
431:23 - double pop open PR close print open
431:26 - curly brace if open pen SP greater than
431:29 - zero closed pen return open PR Val open
431:33 - square bracket minus minus SP close
431:36 - square bracket close curly brace
431:39 - semicolon else open curly brace print
431:43 - F open print double quote air colon
431:46 - stack empty back sln close quote close
431:50 - double quote close PR semicolon clear
431:54 - open PR close PR semicolon return open
431:57 - pen zero close pen semicolon close curly
432:00 - brace to finish the else and then close
432:02 - curly brace to finish the double and the
432:05 - last function we're going to Define is
432:06 - the clear function which is quite simple
432:09 - clear open pen Clos pend open curly
432:12 - brace SP equals zero semicolon Clos
432:17 - pend I would note that just read this
432:20 - one carefully um they're very good at
432:23 - using side effect operators and side
432:25 - effect assignments and to keep this code
432:27 - very simple and succinct um and you
432:30 - really have to understand a lot of the
432:32 - other stuff that you've covered in the
432:34 - book up to this
432:36 - point back to the text the command C
432:39 - clears the stack with a function clear
432:42 - which can also be used by push and pop
432:44 - in case of error we return to getop in a
432:47 - moment as discussed in chapter one a
432:50 - variable is external if it is defined
432:53 - outside the body of any function thus
432:56 - the stack and stack pointer which must
432:58 - be shared by push pop and clear are
433:01 - defined outside the three functions but
433:04 - if main itself does not refer to the
433:06 - stack or stack pointer their
433:07 - representation is carefully hidden thus
433:11 - the code for the equal operator must use
433:14 - push open print pop parentheses par
433:17 - closed parentheses closed parentheses
433:19 - semicolon to examine the top of the
433:21 - stack without disturbing it notice also
433:23 - that because plus and multiplication or
433:26 - commutative operators the order in which
433:28 - the popped operands are combined is
433:29 - irrelevant but for the minus and slash
433:32 - operators the left and right operands
433:33 - must be
433:36 - distinguished this example code above
433:38 - shows why it's important to remember the
433:40 - k&r C arrange rearrangement license as
433:43 - it applies to operators that are
433:44 - associative and commutative if the code
433:47 - for the minus operator were written
433:48 - written push open print pop open print
433:52 - close print minus pop open print Clos
433:54 - print Clos print semicolon there is no
433:58 - guarantee that the left pop will run
434:01 - before the right pop and since these
434:04 - functions access Global variables and
434:06 - have side effects it is important to
434:09 - force the compiler not to rearrange the
434:11 - order of the function calls to force the
434:13 - evaluation order the code is broken into
434:15 - two statements op two equals pop open
434:18 - pen Clos pen semicolon push open open
434:21 - pen pop open pen Clos pen minus op to
434:25 - Clos print semicolon now you might think
434:28 - that the lesson here is that the KRC
434:30 - Arrangement license which was done to
434:32 - allow optimization in performance is a
434:34 - bad idea but the more important lesson
434:37 - is that writing low-level utility
434:39 - functions like push and pop that use
434:41 - Global variables and high side effects
434:44 - is a dangerous pattern in any
434:46 - programming language section 4.5 scope
434:50 - rules the functions and external
434:53 - variables that make up a c program need
434:55 - not all be compiled at the same time the
434:58 - source text of the program may be kept
435:00 - in several files and previously compiled
435:02 - routines may be loaded from libraries
435:05 - the two questions of Interest are how
435:07 - are declarations written so that
435:09 - variables are properly declared during
435:12 - compilation and how are declarations set
435:15 - up so that all the pieces will be
435:17 - properly linked or connected when the
435:19 - program is
435:20 - loaded the scope of a name is the part
435:24 - of the program over which the name is
435:26 - defined for an automatic variable
435:29 - declared at the beginning of a fun
435:31 - function the scope is the function in
435:32 - which the name is declared and variables
435:34 - of the same name in different functions
435:37 - are unrelated the same is true of the
435:39 - arguments of the function the scope of
435:42 - an external variable lasts from the
435:44 - point at which is it is declared in a
435:47 - source file to the end of that
435:49 - file for example if Val SP push pop and
435:53 - clear are defined in one file in the
435:56 - order shown above that is int SP equals
435:59 - z double Val open square bracket Max Val
436:02 - close square bracket
436:03 - semicolon double push open pen F Clos
436:07 - pin open curly brace do do da close
436:09 - curly brace double pop open print Clos
436:11 - PR open curly brace dot dot dot close
436:14 - curly brace clear open pen close PR open
436:17 - curly brace dot dot dot close curly
436:20 - brace then the variables Val and SP P
436:22 - may be used in push pop and clear simply
436:26 - by naming them and no further
436:27 - declarations are needed on the other
436:30 - hand
436:31 - if an external variable is to be
436:33 - referenced before it is defined or it is
436:35 - defined in a different source file from
436:37 - the one in which it's being used then an
436:39 - extern declaration is
436:41 - mandatory it is very important to
436:44 - distinguish between the Declaration of
436:46 - an external variable and its
436:48 - definition a declaration announces the
436:51 - property of the variable its type its
436:53 - size Etc a definition also causes
436:57 - storage to be
436:58 - allocated if the lines int SP semicolon
437:03 - double Val open square bracket Max Val
437:06 - closed square bracket semicolon appear
437:08 - outside any function they Define the
437:11 - external variables SPN Val and cause the
437:14 - storage to be allocated and also serve
437:17 - as the Declaration for the rest of that
437:19 - source file on the other hand the lines
437:23 - exter
437:24 - INTP xter double Val open square bracket
437:28 - close square bracket semicolon declare
437:31 - for the rest of the source file that SP
437:33 - is an INT and Val is a double array
437:35 - whose size is determined and allocated
437:38 - elsewhere but they do not create
437:40 - variables or allocate storage for them
437:44 - there must be only one definition of an
437:47 - external variable among all the files
437:50 - that make up the source program other
437:52 - files may contain extern declarations to
437:55 - access it there may also be an extern
437:58 - declaration in the file containing the
438:00 - definition
438:02 - any initialization of an external
438:04 - variable goes only with the definition
438:07 - array sizes must be specified with the
438:10 - definition but are optional with the
438:13 - extern
438:14 - Declaration although it is not a likely
438:17 - Organization for this program Val and SP
438:21 - could be defined and initialized in one
438:23 - file and the functions push pop and
438:26 - clear defined in another then these
438:29 - definitions and declarations would be
438:32 - necessary to tie them together in file
438:35 - one we would see int spals 0
438:38 - semicolon double Val open square bracket
438:42 - Max Val closed square bracket semicolon
438:44 - and then in file two exter int SP
438:47 - semicolon X turn double Val open square
438:51 - bracket close square bracket semicolon
438:53 - double push open pren F Clos pen open
438:57 - curly brace dot dot dot Clos curly brace
438:59 - double pop open pren close pen open
439:03 - curly brace do dot dot close curly
439:05 - brace clear open pren close pen open
439:08 - curly brace dot dot dot close curly
439:10 - brace because the ex turn declarations
439:14 - in file two lie ahead and outside the
439:16 - three functions they apply to all one
439:19 - set of declarations suffices for all of
439:22 - file
439:24 - to for larger programs the pound include
439:28 - file inclusion facility discussed later
439:30 - later in this chapter allows one to keep
439:33 - only a single copy of the extern
439:35 - Declarations for the program and have
439:37 - that inserted in each source file it's
439:40 - as it's being
439:42 - compiled let us now turn to the
439:44 - implementation of getup the function
439:46 - that Fe fetches the next operator or
439:49 - operand the basic task is easy skip
439:52 - blanks tabs and new lines if the
439:56 - character is not a digit or a decimal
439:58 - point return it otherwise collect a
440:01 - string of digits that might include a
440:03 - decimal point and return number a single
440:06 - signal that a number has been
440:10 - collected routine is substantially
440:12 - Complicated by an attempt to handle the
440:14 - situation properly when an input number
440:16 - is too
440:17 - long get up reads digits perhaps with an
440:21 - intervening decimal point and until it
440:23 - doesn't see anymore but only stores the
440:25 - ones that fit if there was no overflow
440:28 - it returns number in the string of
440:30 - digits if the number was too long
440:32 - however getop discards the rest of the
440:34 - input line so the user can simply retype
440:37 - the line from the point of air it
440:39 - returns too big as the Overflow
440:45 - signal this example code is from page 78
440:50 - of the textbook and you can view it at
440:55 - www.cc.com
440:58 - code page 78
441:01 - get up open print s comma Lim Clos print
441:05 - Char s open square bracket close square
441:07 - bracket semicolon int limb semicolon
441:11 - open curly brace int i commac c
441:15 - semicolon while open PR open PR C equals
441:19 - get CH open PR close PR close PR double
441:22 - equals quote space quote or C equals
441:26 - quot SLT quote or C equals quot back sln
441:31 - quote close Pin
441:33 - semicon skip all the
441:36 - blanks if C is not
441:39 - equal quote. quote and open PR C less
441:44 - than quot 0 quote vertical bar vertical
441:47 - Bar C greater than quote 9 quote Clos PR
441:50 - close P return return open PR C Clos PR
441:55 - S Sub 0al C 4 pen I = 1 semicolon open
442:00 - PR C equals get chart open PR Clos PR
442:03 - close PR greater than or equal to quote
442:06 - 0o quote and C less than or equal to
442:09 - quote 9 quote semicolon
442:12 - i++ inside the for Loop if I less than
442:17 - limb S Sub I equal C if open for N C
442:22 - equals quote. quote closed pen open
442:26 - curly brace we begin to collect the
442:28 - fraction if open pen I less than limb
442:33 - Clos pen S Sub I equal
442:36 - C four open PR
442:40 - i++ C equals get Char open p close PR
442:43 - close PR greater than or equal to quote
442:45 - 0o quote ersan ersan C less than or
442:49 - equal to quote 9 quote semicolon i++
442:53 - Clos per if open p i less than limb Clos
442:57 - pen S Sub I equals c
443:00 - close curly brace to close the if
443:02 - statement where we're collecting the
443:04 - fraction if open pen I less than limb
443:08 - closed pren open curly
443:10 - brace this means the number is good
443:13 - unget to CH open pren C closed pen
443:17 - semicolon S Sub I equals quote back0
443:21 - quote semicolon return open print number
443:25 - Clos print and recall that number is a
443:27 - predefined
443:28 - constant close Cur curly brace else open
443:31 - curly
443:32 - brace if it's too big we're going to
443:34 - skip to the end of the line while open
443:37 - PR c not equal quote back slash and
443:41 - quote and c not equal eof open PR C
443:46 - equals get Char open par closed par
443:48 - semicolon s sublim minus one equals quot
443:52 - back sl0 quote semicolon return too big
443:56 - semicolon close curly brace to finish
443:59 - the if and then close curly brace to
444:01 - finish the function recall that too big
444:03 - is a a constant that indicates that uh
444:06 - We've read too much back to the text
444:10 - what are get CH and unget CH well it is
444:13 - often the case that a programming
444:15 - reading input cannot determine that is
444:17 - read enough until it is read too much
444:19 - one instance is collecting characters
444:21 - that make up a number until the first
444:24 - non digit is seen the number is not
444:26 - complete but then the program has read
444:29 - one character too far and that is a
444:31 - character it is not prepared for the
444:33 - problem would be solved if it were
444:35 - possible to unread The Unwanted
444:36 - character then every time the program
444:38 - reads one character too many it could
444:40 - push it back on the input so that the
444:42 - rest of the code would behave as if it
444:44 - never been read fortunately it is easy
444:48 - to simulate UNG getting a character by
444:50 - writing a pair of cooperating functions
444:52 - get CH delivers the next input character
444:55 - to be considered unget CH puts the
444:57 - character back on the input so the next
444:59 - call to get ch will return it again how
445:02 - they work together is simple unget CH
445:06 - put puts the pushed back characters into
445:08 - a shared buffer a character array get CH
445:11 - reads from the buffer is there's
445:12 - anything there and then it calls get
445:14 - Char if the buffer is empty there must
445:16 - be an index variable which records the
445:18 - position of the current character in The
445:20 - buffer since the buffer and index are
445:22 - shared by get CH and unget CH and must
445:25 - retain their values between calls they
445:27 - must be external to both routines thus
445:30 - we can write get CH and unget CH and
445:33 - their shared variables as
445:35 - follows this is on page 79 of the
445:38 - textbook we can see the code at
445:41 - www.cc.com code and go to page
445:45 - 79 pound include
445:48 - stdio.h pound Define buff size
445:51 - 100 char buff open square bracket buff
445:54 - size close square bracket semicolon int
445:57 - buff P equals 0 semicolon those or the
446:00 - external variables outside any
446:03 - function here's the first function get
446:05 - CH open pen close pen open curly
446:09 - brace return open parentheses open
446:11 - parentheses buff P greater than zero
446:14 - close parentheses question
446:15 - mark buff open square bracket minus
446:19 - minus buff P close square bracket colon
446:23 - get Char open print close PR close PR
446:25 - semicolon close curly brace to finish
446:28 - the get CH function
446:30 - the unget CH function pushes a character
446:32 - back on
446:33 - input unget CH open PR C Clos PR int c
446:38 - semicolon open curly brace if open print
446:42 - buff P greater than buff size print F
446:46 - open PR double quote unget CH colon too
446:49 - many characters back slash N double
446:52 - quote Clos PR semicolon else buff open
446:57 - square bracket buff p++ closed square
446:59 - bracket braet equals c semicolon and
447:03 - then close curly brace to finish the
447:04 - unget CH function we have used an array
447:07 - for push back rather than a single
447:09 - character since the generality may come
447:11 - in handy
447:13 - later section 4.6 static variables
447:18 - static variables are a third class of
447:20 - storage in addition to the X turn and
447:23 - automatic that we've already
447:25 - met static variables May either be
447:28 - internal or external internal static
447:31 - variables are local to a particular
447:33 - function just like automatic variables
447:35 - are but unlike automatics they remain in
447:38 - existence rather than coming and going
447:40 - each time the function is activated this
447:43 - means that internal static variables
447:45 - provide private permanent storage in a
447:48 - function character strings that appear
447:50 - within a function such as the arguments
447:52 - of print f are internal static an
447:55 - external static variable is known within
447:58 - the remainder of the source file in
448:00 - which it's declared but not in any other
448:03 - file external static thus provides a way
448:06 - to hide names like buff and buff p in
448:09 - the get ch unget ch combination which
448:12 - must be external so they can be shared
448:15 - yet which should not be visible to users
448:17 - of get CH and unget CH so there's no
448:19 - possibility of conflict if the two
448:22 - routines are compiled in one file as in
448:25 - static Char buff open square bracket
448:28 - buff size closed square bracket ET
448:30 - semicolon static int buff P equals z
448:34 - semicolon get CH open print Clos PR open
448:38 - curly brace dot dot dot close curly
448:39 - brace unget CH open print C close print
448:42 - open curly brace dot dot dot close curly
448:45 - brace then no other routine will be able
448:48 - to access buff and buff p in fact they
448:52 - will not conflict with the same names in
448:54 - other files of the same
448:56 - program static storage whether internal
448:59 - or external is specified by pref
449:02 - prefixing the normal declaration with
449:04 - the word static the variable is external
449:07 - if it's defined outside of any function
449:09 - and internal if defined inside a
449:11 - function normally functions are external
449:14 - objects their names are known globally
449:17 - it is possible for a function however to
449:20 - be declared static this makes its name
449:23 - unknown outside the file in which it's
449:26 - declared in C static kind otates o not
449:31 - only permanence but also a degree of
449:35 - what might be called
449:37 - privacy internal St static objects are
449:40 - known only inside one function external
449:43 - static objects variables or function are
449:46 - are known only within the source file in
449:48 - which they appear their names do not
449:51 - interfere with variables or functions of
449:54 - the same name in other
449:56 - files external static variables and
449:59 - function s provide a way to conceal data
450:02 - objects and any internal routines that
450:05 - manipulate them so that other routines
450:07 - and data cannot conflict even
450:10 - inadvertently for example get CH and
450:12 - unget CH form a module for character
450:15 - input in push back buff and buff P
450:18 - should be static so they're inaccessible
450:20 - from the outside in the same way push
450:24 - pop and clear form a module for stack
450:27 - manipulations Val and SP should also be
450:31 - external static
450:33 - 4.7 register variables the fourth and
450:37 - final storage class is called register a
450:40 - register declaration advises the
450:42 - compiler that the variable in question
450:44 - will be heavily used when possible
450:47 - register variables are placed in machine
450:50 - registers which may result in smaller
450:52 - and faster programs the register
450:55 - declaration looks like register int X
450:59 - semicolon register Char C suol and so on
451:04 - the in part may be omitted register can
451:06 - only be applied to automatic variables
451:08 - and the formal parameters of a function
451:11 - in this latter case the function
451:12 - declaration looks like f open prin C
451:16 - comma n Clos PR register int C comma n
451:20 - semicolon open curly brace register in I
451:23 - semicolon and then dot dot dot close
451:26 - curly
451:27 - brace in practice there are some
451:30 - restrictions on register variables
451:32 - reflecting the realities of the
451:33 - underlying Hardware only a few variables
451:36 - in each function may be kept in
451:37 - registers and only certain types are
451:40 - allowed the word register is ignored for
451:42 - excess or disallowed declarations and it
451:46 - is not possible to take the address of a
451:47 - register variable a topic that will be
451:50 - covered in chapter 5 the specific
451:52 - restrictions vary from machine to
451:54 - machine as an example on the pdp1 only
451:58 - the first three registered declarations
452:00 - in a function are effective and the
452:03 - types must be int Char or
452:07 - pointer as a quick aside the description
452:10 - of the details of the implementation of
452:11 - the register Mo modifier on the pdp1 is
452:15 - a delightful Peak into how the C
452:18 - compiler generated runtime code on that
452:20 - particular system in the
452:22 - 1970s as compilers have become more
452:25 - sophisticated the compiler could decide
452:27 - which variables to keep in registers far
452:29 - better than the programmer could and
452:32 - since how variables would be allocated
452:34 - to registers might be different on
452:36 - different Hardware architectures the
452:38 - register indication is generally ignored
452:40 - by modern C compilers so you should
452:42 - probably never use it in your code as a
452:45 - matter of fact I wrote The Following
452:47 - sample C program and compiled it with
452:49 - the minus capital S option so I can see
452:51 - the generated Assembly Language with and
452:54 - without the register declaration with
452:56 - optimization there was no difference
452:58 - between the code generated with or
453:01 - without the register
453:03 - declaration the reason the generated
453:04 - assembly code was identical once you
453:06 - take a look at it was regardless of the
453:08 - use of the register keyboard was that
453:10 - the C Optimizer on my armm based
453:13 - computer in 2022 realized the best way
453:15 - to implement the code was to keep both
453:17 - of the variables in registers because
453:20 - the loop code was so simple and the CPU
453:22 - in my computer has plenty of registers
453:24 - and optimized any loading and storing of
453:26 - the data for these variables right out
453:28 - of the program
453:30 - in 1978 the authors likely included the
453:34 - register function as a feature to
453:37 - convince the experienced Assembly
453:39 - Language programmers that they should
453:41 - write all but the lowest lowest level
453:44 - code in C so write a little tiny bit in
453:47 - C and then I mean write a little tiny
453:50 - bit in Assembly Language and write
453:51 - everything else in C so here's an
453:54 - example that's not in the textbook it's
453:56 - on page 81 if it were in the textbook
453:59 - you can see this code at
454:03 - www.cc.com code page
454:06 - 81 and this is code that I wrote to play
454:10 - with the register keyword to mostly
454:12 - convince myself it was pointless to use
454:14 - it but here we go pound include
454:18 - stdio.h int main open print Clos print
454:22 - open curly brace int compute semicolon
454:26 - register int itter semicolon
454:30 - scan F open print double quote percent D
454:34 - close quote comma Ampersand compute
454:37 - close parentheses semicolon PR F open
454:40 - parentheses double quot compute space
454:42 - percent D back sln double quot comma
454:45 - compute closed parentheses semicolon
454:48 - four open print iter equals z semicolon
454:52 - iter less than 1,000 semicolon iter
454:55 - Plus+ close parentheses open curly brace
454:58 - compute equals open parentheses compute
455:00 - time 22 closed parentheses * 7 if
455:04 - compute greater than 1,000 compute
455:08 - equals compute modulo 1000 close curly
455:11 - brace print F open print double quote
455:15 - compute space percent D back sln close
455:18 - quote comma compute semicolon close
455:22 - curly brace now some of these I wrote
455:24 - this code in a way that tries to
455:28 - convince the the the optimizer that I'm
455:31 - actually going to use these values
455:32 - that's why I read the value from input
455:35 - as compared to a constant it would
455:37 - actually optim the optimizer so so so
455:39 - smart that it would just eliminate all
455:40 - the constant calculations so but that's
455:44 - my sample U playing with
455:47 - register section 4.8 block structure C
455:52 - is not a block structured language in
455:54 - the sense of pl1 or alol in that
455:57 - functions may not be defined within
455:59 - other function
456:00 - on the other hand variables can be
456:02 - defined in a block structured fashion
456:05 - Declarations of variables including
456:07 - initializations may follow the left
456:08 - brace that introduces any compound
456:11 - statement not just the one that begins a
456:14 - function variables declared this this
456:16 - way supersede any identically named
456:19 - variables in outer blocks and remain EX
456:22 - in existence until the matching right
456:24 - brace for example if open parentheses n
456:28 - greater than Z closed parentheses open
456:30 - curly brace in I semicolon declare a new
456:34 - I for open parentheses I equal 0
456:38 - semicolon I less than n semicolon
456:41 - i++ close parentheses and dot dot dot
456:44 - the rest of the for Loop and then a
456:46 - closed curly brace for the if the scope
456:48 - of the variable I is in the true branch
456:51 - of the if this I is unrelated to any
456:55 - other I in the program Blu structure
456:58 - also applies to ex internal variables
457:00 - given the
457:02 - Declarations int X semicolon F open
457:05 - parentheses closed parentheses open
457:07 - curly brace double X semicolon dot dot
457:10 - dot Clos
457:12 - parentheses then within the function f
457:15 - occurrences of X refer to the internal
457:17 - double variable outside of f they refer
457:21 - to the external integer this is same is
457:24 - true of the names of formal
457:27 - parameters for example
457:30 - in Z semicolon outside of any function f
457:34 - open parentheses Z closed parentheses
457:36 - double z semicolon open curly brace dot
457:39 - dot dot Clos curly brace within function
457:42 - f z refers to the formal parameter not
457:46 - the external variable section 4.9
457:51 - initialization initialization has been
457:53 - mentioned in passing many times so far
457:55 - but always peripherally to some other
457:57 - topic this section summarize some of the
458:00 - rules now that we have discussed the
458:02 - various storage classes in absence of
458:05 - explicit initialization external and
458:07 - static variables are guaranteed to be
458:09 - initialized to zero automatic and
458:12 - register variables have undefined or
458:15 - Garbage values simple variables not
458:18 - arrays or structures may be initialized
458:20 - when they are declared by following the
458:22 - name with an equal sign and a constant
458:25 - expression int x = 1 semicolon j s quot
458:31 - equals single quote back single quote
458:34 - single quote semicolon a constant of a
458:37 - single character that is a single quote
458:40 - itself long day equals 60 * 24 semicolon
458:45 - which is the minutes in a day for
458:47 - external and static variables the
458:49 - initialization is done once conceptually
458:52 - at compile time for automatic and
458:54 - register variables it is done each time
458:56 - the function or block is entered for
458:58 - automatic can register variables the
459:00 - initializer is not restricted to being a
459:03 - constant it may in fact be any valid
459:06 - expression involving previously defined
459:08 - values even function calls for example
459:12 - the initializations of the binary search
459:14 - program that we wrote in chapter 3 could
459:16 - be written as binary open parentheses x
459:21 - comma V comma n closed parentheses int X
459:26 - comma V open square bracket close square
459:28 - bracket comma n
459:30 - semicolon open curly brace int low
459:34 - equals z semicolon in high equals nus1
459:38 - semicolon and in mid followed by the
459:40 - rest of the function and enclosed curly
459:42 - brace instead
459:46 - of initializing these as the first
459:49 - executable statements and we would do
459:50 - this with binary open pen x comma V
459:55 - comma n Clos pen int X comma V open
459:58 - square bracket close square bracket
460:00 - comma n semicolon open curly brace int
460:05 - low comma mid comma High semicolon low
460:09 - equals z semicolon High equals n minus1
460:12 - semicolon and so forth in effect
460:16 - initializations of automatic variables
460:18 - are just shorthand for assignment
460:20 - statements which form to prefer is
460:22 - largely a matter of taste we have
460:24 - generally used explicit assignments
460:27 - because initializers and declarations
460:28 - are harder to
460:30 - see automatic arrays may not be
460:33 - initialized external and static arrays
460:35 - may be initialized by following the
460:37 - Declaration with a list of initializers
460:40 - enclosed in braces and separated by
460:42 - commas for example the character
460:45 - counting program of chapter one which
460:47 - originally was main open parency closed
460:51 - parency open curly brace int C comma I
460:55 - comma n white comma n other int n
460:59 - open Square braet 10 Close square
461:01 - bracket
461:02 - semicolon n white = n other equal
461:07 - 0 for open parentheses I equal 0
461:10 - semicolon I less than 10 semicolon I ++
461:14 - closed parentheses n digit sub I equals
461:17 - Zer and then the rest of the code
461:19 - followed by a Clos curly brace finishing
461:23 - main this could be written instead using
461:26 - initializers as follows int and white
461:29 - equal 0 semicolon int n other equals z
461:32 - semicolon int n digit open square
461:35 - bracket 10 Close square bracket equals
461:37 - open curly brace 0 comma 0 comma 0 comma
461:41 - 0 comma 0 comma 0 comma 0 comma 0 comma
461:45 - 0 comma Z Clos curly brace 10 zeros in a
461:50 - row in separated by commas and in
461:55 - braces and then the main code is simply
461:58 - main open PR close Pin open curly brace
462:01 - int comma C comma I and then the rest of
462:03 - the main code close curly brace the idea
462:05 - is is that with the initializers with
462:07 - the external variables outside of the
462:09 - main function you do not need to
462:11 - initialize them even with a for Loop in
462:14 - the beginning of the main
462:15 - program these initializations are
462:18 - actually all unnecessary since they're
462:20 - all zero anyways but it's a good form to
462:23 - make them explicit anyway if there are
462:25 - fewer initializers than the specialized
462:27 - size the others will be zero
462:29 - it is an error to have too many
462:32 - initializers regrettably there is no way
462:34 - to spe specify the repetition of an
462:37 - initializer nor to initialize an element
462:39 - in the middle of the array without
462:40 - supplying all the intervening
462:42 - intervening values as well character
462:45 - arrays are a special case of
462:48 - initialization a string may be used
462:50 - instead of the braces and comm's
462:53 - notation as in Char pattern open square
462:57 - bracket closed square bracket equals
462:59 - Double quot T H double quot semicolon
463:03 - this is a shorthand for the longer but
463:06 - equivalent Char pattern open square
463:09 - bracket Clos square bracket equals open
463:12 - curly brace single quote T single quote
463:14 - comma single quote H single quote comma
463:18 - single quote e single quote comma single
463:20 - quote back slash zero single quote Clos
463:23 - curly brace
463:25 - semicolon when the size of an array of
463:28 - any type is omitted the compiler will
463:30 - compute the length of the array by
463:32 - counting the initial initializers in
463:35 - this specific case the size of pattern
463:38 - is four three actual characters plus the
463:41 - terminating back
463:44 - sl0 I would note that the primary
463:47 - difference between C and C influence
463:49 - like languages like Java PHP and
463:52 - JavaScript this key is that c strings
463:56 - are character arrays while in the other
463:58 - languages strings are objects these
464:01 - string objects do have inside themselves
464:04 - an array of byes or characters but they
464:06 - also keep track of things like the
464:08 - length of the string and provide
464:10 - functionality like extract a substring
464:12 - in the methods in these objects in C
464:16 - there is a set of Library functions that
464:18 - perform string operations like compare
464:20 - to Strings while string comparison is
464:22 - built into the string objects in each of
464:24 - the other languages strings as character
464:27 - arrays allow programmers to build very
464:30 - fast low-level code in libraries and
464:32 - operating systems but to write the code
464:35 - well you need to understand what is
464:36 - really going on at the low level section
464:41 - 4.10
464:42 - recursion C functions may be used
464:45 - recursively that is a function may call
464:48 - itself either directly or
464:50 - indirectly one traditional example
464:52 - involves printing of a number as a
464:54 - character string as we mentioned before
464:56 - the digits are generated in the wrong
464:58 - order order low order digits are
465:01 - available before for high order digits
465:04 - but they have to be printed in the other
465:05 - way around there are two solutions to
465:08 - this problem one is to store the digits
465:11 - in an array as they are generated and
465:12 - then print them in reverse order as we
465:14 - did in chapter 3 with I to a the first
465:17 - version of print D follows this pattern
465:20 - this is sample code on page 85 of the
465:23 - textbook you can view the sample code at
465:26 - www. cc4 /c code page 85 example
465:33 - one pound include
465:36 - stdio.h print D open pen n close pen int
465:41 - n open curly brace Char s open square
465:45 - bracket 10 closed square bracket
465:48 - semicolon in I semicolon if parentheses
465:52 - n less than zero parentheses open curly
465:55 - brace put Char open prin single quote
465:59 - Dash single quote Clos peren semicolon n
466:03 - equal minus n semicolon Clos curly brace
466:07 - I equal Z semicolon do open curly brace
466:12 - S Sub
466:14 - i++ equals n modulo 10 plus quot 0
466:19 - quote which gets the next character
466:22 - while parentheses parentheses
466:25 - n/ equal 10 close parentheses greater
466:28 - than Z closed parentheses
466:32 - semicolon then we reverse the string
466:34 - while open print minus- I greater than
466:37 - equal to zero Clos pen put Char open pen
466:41 - s subi Clos pen semicolon close curly
466:45 - brace to end the print D
466:48 - function the alternative is a recursive
466:51 - solution in which each call of print D
466:54 - first it calls itself to cope with any
466:56 - leading digits then prints the trailer
466:59 - digit after that call returns this is an
467:02 - example on page 85 of the textbook in
467:05 - its example
467:06 - two pound include
467:10 - stdio.h print D open pen n close pen Inn
467:15 - semicolon open curly brace in I
467:19 - semicolon if open for n less than Zer
467:23 - Clos pren open curly brace put chair
467:26 - open pren single quote- sing single
467:29 - quote close pen
467:31 - semicolon Nal minus n semicolon close
467:34 - curly brace to finish the
467:37 - if if open print open print I equal n/
467:42 - 10 Clos print not equal
467:46 - zero close print print D open print I
467:50 - Clos print semicolon that's the
467:52 - recursive call and after the recursive
467:54 - call comes back we do put Char open pen
467:57 - in modulo 10 plus single quote 0 single
468:01 - quote close print semicolon close curly
468:04 - brace to end the print D
468:06 - function when a function calls itself
468:09 - recursively each invocation gets a fresh
468:11 - set of all the automatic variables quite
468:13 - independent of the previous set thus in
468:17 - print D
468:18 - 123 the first print D has Nal
468:22 - 123 it passes 12 to a second print D
468:25 - then prints three when that one returns
468:27 - in the same way that second print D
468:29 - passes one to a third which prints it
468:32 - and then prints
468:33 - two recursion generally provides no
468:36 - saving in storage since somewhere a
468:38 - stack of values is being processed or
468:40 - has to be maintained nor will it be
468:42 - faster but recursive code is more
468:44 - Compact and often much easier to write
468:47 - and understand recursion is especially
468:50 - convenient for recursively defined data
468:52 - structures like trees we will see a nice
468:54 - example in chapter
468:57 - six as as an aside uh recursion
469:01 - recursion recursion recursion is a
469:04 - beloved Concept in computer science it
469:07 - is often taught early in most
469:09 - programming courses because it is just
469:11 - so cool most examples are sadly like
469:15 - Computing factorial or the example above
469:18 - converting an integer to a string and
469:20 - they're not good uses of recursion
469:22 - actually but when you do finally find
469:24 - yourself in need of traversing a tree
469:26 - based structure like an XML document or
469:29 - parsing a mathematical expression with
469:31 - parentheses recursion is the ideal
469:34 - solution so the problem in a sense is
469:36 - not recursion but when it is taught and
469:39 - what examples are
469:41 - used interestingly kernigan and Richie
469:44 - include the correct warning about using
469:47 - recursion when it is not the best
469:50 - solution in the above text and it Bears
469:53 - another
469:54 - read back to the
469:57 - book cursion generally provides no
470:00 - saving in storage since somewhere a
470:02 - stack of values is being processed or
470:04 - has to be maintained nor will it be
470:06 - faster but recursive code is more
470:09 - Compact and often much easier to write
470:11 - and understand recursion is especially
470:14 - convenient for recursively defined data
470:17 - structures like trees we will see a nice
470:20 - example in chapter
470:22 - six I couldn't have said it better
470:29 - section 4.11 the c
470:32 - pre-processor c provides certain
470:35 - language Extensions by means of a simple
470:38 - macro pre-processor the pound Define
470:41 - capability which we have used is the
470:43 - most common of these extensions another
470:45 - is the ability to include the entire
470:47 - contents of other files during
470:49 - compilation file inclusion to facilitate
470:53 - handling of pound defines and
470:55 - declarations among other things C
470:57 - provides a file included feature any
471:00 - line that looks like pound include space
471:03 - double quote file name double quote is
471:05 - replaced by the conts of the file name
471:07 - the quotes are indeed
471:09 - mandatory often a line or two of this
471:11 - form appears at the very beginning of
471:13 - each source file to include common pound
471:15 - defined statements and extern
471:17 - declarations for Global variables pound
471:19 - includes may be nested pound include is
471:22 - the preferred way to tie declarations
471:24 - together for a large problem and in a
471:26 - large program it guarantees that all the
471:29 - source files will be supplied with the
471:30 - same definitions and variable
471:32 - declarations thus eliminating a
471:34 - particularly nasty kind of bug of course
471:37 - when an include file is changed all the
471:39 - files that depend on it must be
471:43 - recompiled macro substitution a
471:46 - definition of the form pound Define yes
471:50 - one calls for a macro substitution of
471:53 - the simplest
471:55 - kind rep replacing a logical name by a
471:59 - string of characters names and the pound
472:01 - Define have the same forms of as the C
472:03 - identifiers the replacement text is
472:05 - arbitrarily normally the replacement
472:08 - text is the rest of the line a long
472:10 - definition may be continued by pacing a
472:13 - backslash at the end of the line to be
472:15 - continued the scope of the name defined
472:17 - with pound Define is from from its point
472:19 - of definition to the end of the source
472:21 - file names may be redefined and a
472:24 - definition may use previous
472:26 - definitions substitutions do not Place
472:29 - take place within quoted strings so for
472:32 - example if yes is a defined name there
472:35 - would be no substitution in print F open
472:38 - print double quote yes double quote Clos
472:41 - print since implementation of pound
472:44 - Define is a macro prepass not part of
472:47 - the compiler proper there are very few
472:49 - grammatical restrictions on what can be
472:51 - defined for example alcohol fans can say
472:55 - pound Define
472:57 - then and then nothing pound Define begin
473:01 - open curly brace pound Define end
473:05 - semicolon Clos curly brace and then
473:07 - write approximate alol if pen I greater
473:12 - than zero Clos pen then begin a = 1
473:17 - semicolon b = 2
473:22 - end it is also possible to Define Mac
473:25 - macros with arguments so the replacement
473:27 - text depends on on the way the macro's
473:29 - called as an example to find a macro
473:32 - called Max like this pound Define Max
473:36 - open PR a comma
473:39 - B open PR open PR a Clos PR greater than
473:43 - open PR B Clos print question mark open
473:46 - print a Clos print colon open print B
473:50 - Clos print Clos print now the line x
473:54 - equals Max open print p+ Q comma r+ s
473:58 - closed BR semicolon will be replaced in
474:02 - the pre-processor by the line x equals
474:06 - open print open PR p+ Q Clos print
474:08 - greater than open PR R plus s Clos PR
474:11 - question mark open PR p+ Q Clos pen
474:15 - colon open pen r+ s Clos pen Clos print
474:20 - semicolon this provides a maximum
474:22 - function that expands into inline code
474:25 - rather than a function call so long as
474:27 - the arguments are treated consistently
474:30 - this macro will serve for any data type
474:32 - there is no need for different kinds of
474:34 - Macs for different data types as there
474:36 - would be with
474:38 - functions of course if you examine the
474:40 - expansion of Max above you will notice
474:42 - some pitfalls the expressions are
474:44 - evaluated twice it is bad if they
474:47 - involve side effects like function calls
474:49 - increment operators or perhaps push and
474:51 - pop like we've used before some care has
474:54 - to be taken with parentheses to make
474:56 - sure the OD order of evaluation
474:58 - is preserved consider the macro pound
475:02 - Define Square open print X Clos print
475:06 - equals x *
475:08 - X when it is invoked as Square open
475:13 - print Z + one close print there are even
475:17 - some purely lexical problems there can
475:19 - be no space between the macroon name and
475:21 - left parenthesis that introduces the
475:23 - argument list nevertheless macros are
475:26 - quite valuable one practical example
475:28 - example is the standard IO library to be
475:30 - described in chapter 7 in which get
475:32 - charar and putchar are defined as macros
475:36 - obviously put chart needs an argument
475:38 - thus o avoiding the overhead of a
475:40 - function call per character Pro process
475:43 - other capabilities of the macro
475:45 - processor are described in appendex
475:50 - a as a bit of a long aside in this
475:53 - section we are talking about the
475:55 - pre-processor is probably a good time to
475:57 - talk bit about why we use this
476:00 - terminology for those of you with a
476:03 - computer science degree from back in the
476:04 - day many of you wrote a compiler as a
476:06 - senior project just like I did building
476:09 - a compiler was a great project because
476:11 - part of the goal of computer science is
476:13 - to understand the technologies that make
476:14 - programming proc possible from the
476:17 - language syntax down to the hardware the
476:20 - compiler that translates our source code
476:22 - into machine code is an essential part
476:24 - of the technology stack that we use
476:27 - early compilers for languages like the
476:29 - early Fortran variants tended to be
476:31 - translators they just translated code
476:33 - one line at a time from a high level
476:34 - language to Assembly Language you could
476:37 - think of early Fortran programs in the
476:39 - 1950s and the 1960s as just more
476:41 - convenient ways to write Assembly
476:43 - Language for programmers that knew
476:45 - Assembly Language you always needed to
476:47 - be aware of Assembly Language and the
476:50 - translation that it was going to
476:52 - write fast Fortran programs were small
476:56 - and optimization was done at the for
476:58 - Trend level often leading to some hard
477:00 - to understand
477:01 - code by the mid 1970s programming
477:05 - languages were based on parsing Theory
477:07 - and we used what is called a grammar to
477:09 - define the language kernigan and Richie
477:11 - kept I/O statements out of the C
477:13 - language to keep its formal definition
477:15 - I.E its grammar as simple as possible as
477:18 - these new languages emerged they allowed
477:20 - for more theoretical and Powerful
477:22 - approach to converting source code to
477:24 - machine
477:25 - language the theoretical advances in
477:28 - compiler and language design me that
477:30 - parts of the compiler might be reusable
477:32 - across multiple programming languages
477:35 - each language could have its own syntax
477:37 - and grammar rules and they could be
477:39 - plugged into the compiler and poof you
477:41 - would have a new programming language it
477:44 - got to the point where Unix system Unix
477:46 - systems had a tool called Yak which
477:49 - stood for yet another compiler compiler
477:52 - you would give it a grammar for your new
477:54 - language and it would make a compiler
477:55 - for you as a matter of fact the job
477:58 - JavaScript language that was created in
477:59 - 10 days back in 1995 was possible
478:03 - because Brendan Ike had a lot of
478:04 - experience with compiler
478:06 - generators he defined a grammar for
478:08 - JavaScript and generated his first
478:10 - compiler part of what made a compiler
478:13 - generate generator possible is the idea
478:15 - of a multi-step compiler or the tasks of
478:18 - a compiler were broken down into a
478:20 - series of simpler and more well-defined
478:22 - steps here are the steps of a typical C
478:25 - compiler in the
478:27 - 1970s first a pre-processor step that
478:29 - takes code with syntax like pound Define
478:32 - and P include as its input and produces
478:34 - raw code output with those instructions
478:37 - processed and or expanded the
478:39 - pre-processor processor was a ctoc
478:43 - transformation next a parser step that
478:46 - took the raw C code applied the grammar
478:48 - to the language and created what is
478:50 - called a parse tree think of the tree is
478:52 - a hierarchy of statements grouped into
478:54 - blocks grouped into functions Etc a
478:57 - things like a loop where just one node
478:58 - in a parse
478:59 - tree after that a code generation would
479:02 - turn the parse tree into some kind of
479:04 - simplistic portable internal code that
479:07 - expanded things like loops and if and
479:08 - elf statements into code after that a
479:12 - code optimization that looked at the
479:14 - internal code and moved things around
479:17 - eliminating any redundant computations
479:20 - say don't compute the same things twice
479:22 - this step is why the authors make such a
479:24 - big Foss about how there are times where
479:26 - C might do things in a slightly
479:28 - different order in an expression even in
479:30 - the presence of parentheses remember the
479:33 - KRC Arrangement license back in Chapter
479:36 - 2 that rule removes constraints on the
479:39 - compiler's optimization step so it can
479:41 - generate the most efficient
479:43 - code I would note that all the steps up
479:46 - to this point did not depend in any way
479:49 - on the actual machine language of the
479:50 - system that they were running on this
479:52 - meant a pre-processor parser code
479:55 - generator and code Optimizer could
479:57 - literally be written in C and used on
479:59 - any
480:01 - architecture the final step is a code
480:04 - generator that takes the optimized
480:06 - intermediate code and generates the
480:08 - actual assembly and machine language for
480:10 - the processor for fun you can add the
480:13 - minus capital S parameter to your C
480:14 - compiler and see the resulting Assembly
480:16 - Language output for your system if you
480:19 - look at the machine language generated
480:21 - on Intel or AMD processor and compare it
480:24 - to the machine language on an armm
480:26 - processor it will look very different
480:29 - because all but the final compiler steps
480:31 - did not depend on the computer where the
480:33 - program is being run you could actually
480:34 - create a c compiler on a new computer
480:36 - architecture by writing a code generator
480:39 - on the new computer then running all but
480:41 - the last step of the compiler on one
480:42 - computer then copying the internal code
480:45 - generated by the compiler to the new
480:46 - compiler and running the code generation
480:48 - step on the new computer then you
480:52 - actually have a working C compiler on
480:54 - the new computer and the first step is
480:56 - usually to recompile the C compiler
480:58 - itself from source code to produce a
481:00 - fully native C compiler on the new
481:02 - computer that can compile all the rest
481:04 - of the C code you have including
481:06 - possibly the mostly portable elements of
481:09 - the Unix operating system on the new
481:12 - compile yes describing how to cross
481:14 - compile and bootstrap a c compiler onto
481:16 - a new computer hardware architecture can
481:18 - give you a headache if you think about
481:19 - it too much but this notion of
481:22 - bootstrapping a c compiler onto a new
481:24 - architecture was an important technique
481:26 - to move C and Unix to a wide range of
481:29 - very different computer
481:31 - architectures we see this in action as
481:33 - the Unix like Mac OS operating system
481:36 - over the past 20 years was delivered
481:37 - initially on a Motorola 68,000 family
481:40 - processors then on power PC processors
481:44 - and then on Intel processors and most
481:46 - recently on arm-based processors built
481:49 - by Apple using the software portability
481:52 - patterns that come from C and Unix and
481:54 - described by kran and Richie in this
481:56 - book Apple now made makes their own
481:58 - Hardware that can be tuned and evolved
482:01 - over time as their operating system and
482:04 - their applications requirements
482:07 - dictate the use of a grammar by the way
482:09 - is to define a programming language is
482:11 - one of the reasons that syntax errors
482:13 - are so obtuse the compiler is not
482:16 - looking at your code like a human it is
482:19 - following a very set of simple rules to
482:21 - parti your code and it's stuck with
482:23 - something ilog logical and gives you a
482:24 - message like unexpect unexpect expected
482:28 - statement block or constant on line 17
482:31 - and the error is nowhere near line
482:34 - 17 modern compilers are more
482:37 - sophisticated of course than the steps
482:39 - above but these steps give you a sense
482:40 - that the compiler does many things to
482:42 - make it so your code can actually run
482:45 - very
482:46 - efficiently and given that kernigan and
482:48 - Richie were building a programming
482:49 - language c a more mostly portable
482:51 - operating system written in C Unix and a
482:53 - mostly portable C compiler written in C
482:57 - some of the their Innovative work and
482:59 - Research into compiler design finds it
483:02 - its way into this book so we have a
483:04 - section in this chapter called the C
483:08 - preprocessor so here we are at the end
483:09 - of chapter 4 and it's a good time to
483:12 - talk about the word
483:14 - address up to this point in the book if
483:16 - you count them the word address has been
483:18 - used 10 times without a precise
483:20 - definition beyond the notion that data
483:23 - is stored in memory and the address of
483:25 - the data is where the data is stored in
483:27 - memory
483:29 - in the next chapter this notion of the
483:31 - address where the data is stored becomes
483:34 - very real and tangible as we explore
483:37 - pointers as well as the Ampersand and
483:39 - asterisk
483:41 - operators up to now an experienced
483:44 - JavaScript PHP or Java programmer can
483:46 - view c as just another set of similar
483:49 - syntax rules with a few quirky runtime
483:52 - bits but in the next chapter we will
483:55 - deeply explore the concept of data
483:57 - allocation and
484:00 - location it turns out that every
484:02 - programming language pays a lot of
484:04 - attention to data allocation and
484:06 - location but the runtime environments of
484:08 - modern languages work very hard not to
484:11 - expose you to those details just because
484:14 - modern languages hide the difficult bits
484:16 - from us it does not mean that those
484:18 - languages solve the problem using magic
484:22 - eventually the problem needs to be
484:25 - solved and that is why the comp and
484:28 - lowlevel runtime elements of language
484:30 - like PHP JavaScript and Java are usually
484:33 - written in C so the Builders of those
484:36 - languages can solve the difficult data
484:38 - storage and allocation problems for
484:42 - you this work is based on the 1978 C
484:47 - programming book written by Brian W
484:49 - kernigan and Dennis M Richie their book
484:51 - is copyright All Rights Reserved by AT&T
484:55 - but is used in this work under fair use
484:57 - because of the book's historical and
484:59 - scholarly significance its lack of
485:02 - availability and the lack of an
485:03 - accessible version of the book the book
485:06 - is augmented in places to help
485:07 - understand Its Right Place in a
485:09 - historical context amidst the major
485:11 - changes of the 1970s and 1980s as
485:14 - computer science evolved from a hardware
485:16 - first vendor centered approach to a
485:19 - software centered approach where
485:20 - portable operating systems and
485:22 - applications written in C could run on
485:24 - any
485:25 - hardware this is not the ideal book to
485:28 - learn SE programming because the 1978
485:30 - Edition does not reflect the modern sea
485:32 - language using an obsolete book gives us
485:35 - an opportunity to take students back in
485:37 - time and understand how the sea language
485:40 - was evolving as it laid the groundwork
485:42 - for a future with portable applications
485:47 - [Music]
486:01 - hello and welcome to our lecture on
486:03 - kernigan Richie chapter 5 putting some
486:05 - context around it chapter five is
486:08 - functions and program
486:10 - structure so the first thing I want to
486:13 - call your attention to is section 5.1 I
486:17 - actually think that section 5.1 is the
486:20 - most poignant and beautiful section in
486:23 - the
486:24 - book everything you've learned up till
486:26 - now everything talked about size of data
486:29 - Etc has led to the point where you can
486:31 - read
486:32 - 5.1 and understand every word of it you
486:36 - should enjoy reading it I think of it as
486:38 - like a love letter from the creators of
486:40 - sea to Future computer
486:42 - scientists so 5.1 is important uh we'll
486:45 - talk a little bit about Pointer
486:47 - arithmetic uh 5.6 we'll look at the sort
486:50 - of The Duality between pointers and
486:53 - integers then we'll hit call by
486:55 - reference and call by value that are Ena
486:57 - B in C by pointers and then look at the
487:00 - biggest security hole that c has caused
487:02 - over the past 40 plus years uh buffer
487:06 - overflow now the the the the chapter
487:09 - gets a little dense um in some of the
487:11 - sections and so I'll I'll just have you
487:13 - skim some of those sections this is the
487:17 - essential
487:18 - example of
487:21 - pointers we have two variables int X and
487:24 - Y we have a variable PX which is of type
487:27 - pointer it points to an integer that's
487:30 - what instar means we store 42 in X and
487:34 - we store the address of X into PX using
487:38 - the Ampersand operator and then we use
487:40 - the address of X which is in PX and then
487:43 - we use a lookup operator or a dreference
487:45 - operator star PX it says go to the
487:48 - memory location pointed to by PX and
487:50 - load me an integer and put that into Y
487:53 - and so we can see when we print out X is
487:55 - 42 and Y is 42 and P X is a long
487:58 - hexadecimal number that is some memory
488:00 - location inside the actual computer and
488:03 - so ERS send and asterisk and in Star the
488:07 - star as a sort of a modifier for a type
488:10 - are the the important things one of the
488:13 - things that You' probably never seen in
488:14 - Python is the ID function we've used
488:17 - functions like type and dur and there
488:21 - are ways for us to inquire about
488:22 - variables and constants ID is a way to
488:27 - ask ask for the idea of something now in
488:29 - cpython and and just to be clear there
488:31 - are multiple versions of python cpython
488:34 - is the classic one it's the
488:35 - implementation of python that happens to
488:37 - be written in C uh there are other
488:40 - implementations of python um and so what
488:44 - I'm telling you with this ID function is
488:46 - something that will
488:48 - work for the moment in cpython but not
488:51 - necessarily every other one if you print
488:53 - it out and you say what is X and what is
488:55 - the ID of X it's kind like the address
488:59 - and if you look at the documentation it
489:01 - says don't think this is the address
489:03 - right and it says the python ID function
489:06 - is not intended to be dereferenceable
489:08 - meaning we're not supposed to look up
489:09 - memory from that the fact that it's
489:12 - based on the memory address is a
489:14 - cpython implementation detail that other
489:17 - python implementations do not follow now
489:19 - if you download the source code
489:22 - k501 py I actually have a
489:26 - completely unauthorized implementation
489:29 - of a lookup a
489:31 - dfference and it has to know the type of
489:34 - the thing that it's D referencing y
489:36 - equals DF of PX and it can then give me
489:40 - back that integer pointed to by the
489:42 - address but this is not guaranteed to
489:44 - work it's not supposed to be how it
489:46 - works it just is there is kind there
489:50 - things have addresses and in cpython at
489:53 - least for this particular version of
489:55 - python that I'm using you can use that
489:59 - pointers gives us the ability to do call
490:01 - by reference and so you know if you've
490:04 - done python you see that we we we have a
490:06 - I had a slide in an early version of my
490:08 - python class that said uh sorry python
490:11 - doesn't do call by reference it only it
490:13 - only does call by value and that means
490:15 - that within a function you change the
490:16 - parameters and nothing happens but some
490:19 - languages do have call by reference
490:21 - which means the parameters that come
490:23 - into a function are somehow handles that
490:26 - allow us to actually change the values
490:29 - in the main programmer or where where
490:31 - we've been calling from so the language
490:33 - Pascal and c and C++ PHP and C have this
490:37 - notion a formal notion of call by
490:39 - reference and languages that don't have
490:41 - it are like Python and Java and
490:44 - JavaScript now these there is a notion
490:47 - the fact that I said this is for simple
490:49 - types like
490:51 - integers objects are passed in but then
490:54 - if you call methods in objects you can
490:56 - actually change the dat that the object
490:58 - has but it's not like you're changing
490:59 - the object you're changing the object's
491:01 - data so let's take a look at a bit of
491:03 - code now the first example is actually
491:06 - Pascal now Pascal is a programming
491:08 - language that was written by uh Nicholas
491:11 - verth and in Switzerland in 1970 and it
491:15 - had a call by reference and it had this
491:18 - notion of VAR and so you're creating a
491:20 - function name Funk takes two parameters
491:23 - one is a call by value which is a and
491:26 - then the other one's call by reference
491:28 - which is a b and we set a and b to two
491:31 - new numbers and then in the main program
491:33 - we set x = 42 yal 43 and then we call
491:37 - the function and you'll notice there's
491:38 - no extra like syntax in the function and
491:41 - then we come back and you will see that
491:44 - uh the Y variable is changed and the X
491:46 - variable is not and then the C version
491:49 - of this we have you know x = 42 y = y =
491:52 - 43 and then when we call Funk we say
491:56 - we're going to pass in x and then
491:57 - Ampersand Y which is the address of Y
492:00 - and if you go back to the very first
492:01 - example in section 5.1 we're passing in
492:04 - a number which we're actually passing in
492:06 - by value but the value is the address
492:09 - and then inside the function we take a
492:11 - and then a pointer to B PB and we say
492:14 - that a is just an integer and PB is an
492:17 - address of an integer by adding the
492:18 - little asterisk there so the address
492:21 - where it's at has been passed by
492:24 - value but using that value we can
492:27 - dreference it and get to the thing so we
492:29 - say a equal 1 and we say star PB equals
492:33 - 2 that says store two as an integer into
492:36 - the location pointed to by PB and then
492:39 - when you come back the second parameter
492:41 - will have been changed y will have been
492:42 - changed and X will not be changed if we
492:44 - take a look at a few other languages so
492:46 - here we have the C code again um python
492:51 - uh 1989 doesn't have the notion of pass
492:54 - by reference and so one of the things
492:56 - that I think is a an excellent
492:59 - compromise uh that is the case in Python
493:02 - is the notion of returning a tupple not
493:04 - just a single value but a topple return
493:08 - and so that way we could if we really
493:10 - wanted to get back a value more than one
493:14 - value um we could return a tupple and
493:17 - then in the main program we assign the
493:20 - tupple so if we really wanted X and Y to
493:22 - change from uh inside the function we
493:26 - could do so by just explicitly saying
493:28 - function is going to return two values
493:30 - and we're going to change them both and
493:32 - if we look at PHP which is
493:34 - 1994 um we see a very elegant I think
493:38 - now whenever you look at PHP you got to
493:40 - realize the dollar sign is just part of
493:41 - the variable name that's just the first
493:43 - character of all variables in PHP so
493:45 - what we do inside a function is we say
493:48 - Ampersand dollar B which is the second
493:50 - parameter is B dollar B and we're
493:53 - expecting to change it and you'll note
493:54 - that we don't change the syntax inside
493:57 - the function dollar Bal 2 dollar AAL 1
494:00 - the syntax doesn't change and when we
494:02 - make the call Funk dollar X comma dollar
494:04 - y we don't change that either and yet
494:07 - call by reference works so if you look
494:08 - at all these examples other than the
494:11 - weird dollar sign convention I would say
494:14 - that the simplest and most elegant is
494:16 - probably the PHP implementation right
494:18 - because we don't have to do anything
494:19 - inside the function except I'm planning
494:22 - on changing
494:23 - this now C sh which is much later 2000
494:28 - um has this notion of ref which is
494:30 - somewhat a call a throwback to um Pascal
494:35 - but also you know it's the Amper sand
494:37 - thing and um but the one thing I like
494:39 - about it is inside the C defunk you have
494:43 - to kind of agree the calling code by
494:47 - saying refx is in a sense agreeing that
494:49 - it is aware that X is likely to be
494:52 - changed by that function and so that's
494:55 - that's called by reference now you know
494:57 - we're in a cclass and so Amper sand and
495:00 - asterisk are how we do it so again
495:02 - that's just it's it's really quite
495:04 - straight forward inside a c code as long
495:07 - as you are very good at understanding
495:09 - what the asterisk and Ampersand do in C
495:12 - another important thing that's easily
495:15 - understood with a very simple bit of
495:16 - code is pointer
495:18 - arithmetic the key to pointer arithmetic
495:21 - is that a pointer to an integer is
495:23 - different than a pointer to a character
495:25 - now both these point pointers are the
495:27 - same size because they are an address
495:29 - and addresses are all the same size but
495:31 - if you add one to a character pointer
495:34 - that actually adds one to the address
495:36 - and if you add one to an integer
495:39 - pointer then it adds four and that's
495:41 - because on each integer takes four
495:44 - characters and so when you're doing
495:47 - increments and subtracts Etc you are
495:51 - when they're pointers it it increments
495:53 - based on the type of the thing that's
495:54 - pointed to so a pointer is not just a
495:56 - pointer
495:57 - it's a pointer to a thing with a type
495:59 - and when you're incrementing and
496:00 - decrementing the type that's being
496:02 - pointed to is more important than the
496:04 - fact that it's a pointer it goes up and
496:06 - goes down but it doesn't always just go
496:08 - up and down by one pointers are not
496:11 - integers so if you go back to chapter 2
496:14 - there was from the book a table of the
496:16 - sizes of things and so if you look in
496:19 - the PDP 11 integers are 16 bits and
496:22 - Honeywell 6000 there're 36 bits and IBM
496:26 - 370 there 32 bits and inata 832 there's
496:29 - 32 bits now I've added a line to this
496:31 - that tells the number of bits in
496:34 - addresses in these systems and you can
496:36 - see if you compare the int numbers to
496:39 - the address numbers that in all the
496:41 - cases except the
496:43 - pdp1 the the integer is larger than the
496:46 - address which means that there is extra
496:49 - space in the address and we can almost
496:51 - treat addresses as unsigned integers now
496:54 - the pdp11 is a little weird in that 16
496:57 - to 32 is a range of delivered computers
497:00 - over over the years and uh not all
497:03 - computers had full memory and not all
497:07 - applications use the entire memory of
497:08 - the entire computer so um most of the
497:12 - time you can conveniently put an address
497:15 - into an integer and then get that
497:17 - address back out and not have truncated
497:20 - um that address or messed it up so
497:22 - treating pointers as integers almost
497:24 - works and the long longer in longer ago
497:28 - in history it was the more likely it did
497:30 - work addresses are generally positive
497:32 - numbers that often start from zero
497:34 - sometimes Heap numbers come down and
497:36 - sometimes stack numbers go up or
497:38 - whatever but most computers did not come
497:41 - with a maximum memory installed and and
497:42 - if you're a multi-user computer you
497:44 - didn't give all the systems memory to
497:46 - every application and we tended to use
497:49 - very little memory in applications we're
497:51 - very careful about it so it just never
497:54 - ran into the problem of our memory
497:56 - address is not fitting into integers so
497:59 - in the early ' 70s applications could
498:02 - get away with having a function that
498:04 - returned an address return it as an
498:05 - integer and then copy it into a pointer
498:08 - without
498:09 - conversion and
498:11 - so by like the early 80s the notion of a
498:15 - void pointer gave us a way to have a
498:18 - generic address that is a pointer to
498:20 - something we don't know what type it is
498:22 - cuz all addresses are addresses but what
498:25 - they point to is different and so uh if
498:29 - you take a look at the Alec function
498:31 - which we'll play a lot more in the next
498:33 - chapter the Alec says oh give me 42
498:35 - bytes and give it back to me as a
498:38 - pointer give me a pointer to 42 new
498:40 - bytes that you just allocated so if you
498:42 - go in the early 70s Alec returned an INT
498:46 - but then we would cast it to whatever
498:48 - type we wanted so we would say Alec 42
498:50 - would give us an address that'd be an
498:52 - integer but then we cast it to an
498:53 - integer star which is a no loss C pass
498:57 - and then we would store it by the time
498:59 - in the 1978 CNR book we tended to call
499:02 - it a charar cuz the 42 is how many
499:05 - characters we're going to allocate and
499:07 - then you would take the pointer to a
499:08 - character and cast it to a pointer to an
499:10 - integer and so Alec of 42 would give us
499:14 - 14 integers actually I think if I got my
499:17 - multiplication right but in modern C we
499:20 - have this pointer void pointer which
499:22 - basically says look Alec is going to
499:25 - return an address and you have to cast
499:27 - it to something so Alec 42 returns a
499:31 - void star which is cast it to an instar
499:33 - which is a lossless cast and not
499:36 - something that's going to confuse the
499:37 - compiler and then we store it in our
499:39 - intar variable and so void
499:44 - you'll everything you'll ever touch will
499:47 - be using void um but I just wanted to
499:49 - give you a little bit of the history of
499:50 - it and why void's kind of not mentioned
499:53 - in this 1978 book every time in the
499:56 - class I'm like hey it's time to learn
499:57 - about security and everybody got kind of
499:58 - groans like oh no back when I taught
500:01 - HTML injection and SQL injection and
500:04 - cross-site scripting in all my previous
500:06 - classes and here's the classic
500:08 - XKCD where um the mom has named their
500:13 - child with a bit of SQL and some single
500:15 - quotes and some comments and um that's
500:17 - all fun it's important that we as
500:21 - software developers are aware of how the
500:24 - things that we build could be corrupted
500:27 - by those with uh those with uh in evil
500:30 - intent right so it has come time to talk
500:34 - about that for
500:36 - C probably the single worst security
500:41 - hole in all of computing
500:44 - history from 1950 to today even before c
500:49 - was a thing is what's called buffer
500:52 - overflow and it has to do with the fact
500:55 - that the there is no sense that a string
501:00 - of characters has a
501:02 - length it's has an allocated length but
501:05 - it doesn't have a runtime length and so
501:08 - when we put more data into a string than
501:11 - can hold the string it just keeps on
501:13 - storing beyond the end of the string it
501:15 - doesn't like push make a little more
501:18 - space and so this is from the Wikipedia
501:20 - page where you have an eight
501:24 - character
501:25 - um string followed by a two character
501:29 - integer or something and we copy the
501:32 - string excessive which is a nine
501:34 - character which includes nine characters
501:37 - and the sl0 the zero and that completely
501:40 - overwrites by just trying to write into
501:42 - the a string it overwrites the B
501:46 - variable as well and so that's buffer
501:49 - overflow it's sort of like somehow we're
501:51 - going to push too much into this
501:53 - variable so that it extends where it's
501:56 - been allocated and that never is
501:58 - detected and then it keeps going on and
502:01 - it means that you can do all kinds of
502:03 - things with buffer overflow you can
502:05 - change variables you can like turn on
502:08 - super user permission who knows you got
502:10 - to look at the source code you got to
502:11 - carefully construct a sort of nasty
502:14 - attack but the attack Vector is the fact
502:18 - that string arrays bounds are not
502:21 - checked when we're copying stuff in and
502:23 - if you write bad code or if the system
502:25 - writes bad code it's just going to go
502:27 - wiping out memory so it turns out that
502:30 - the probably the the the worst offender
502:32 - of this is the gets function and this
502:35 - was part of standard C for a long time
502:39 - and so here what I'm doing is I'm I'm
502:41 - creating a 15 character uh string array
502:44 - a character array which is 15 elements
502:47 - and I'm calling get S and the problem
502:49 - with get S is like somebody's going to
502:52 - give us that data and it's not us and
502:54 - then I print it out so the first first
502:56 - thing you see is when I compile a pit of
503:02 - code that has GS the compiler is upset I
503:05 - have
503:07 - greatly uh simplified the errors it just
503:11 - it comes up with three errors and this
503:13 - is a subset of one of the errors the
503:15 - compiler is telling you don't use gets
503:18 - if you didn't hear what I said the first
503:20 - time don't use
503:21 - gets and so so the compiler is not happy
503:24 - but it it's like you know people WR
503:26 - write that so we're going to run it okay
503:29 - a. out which starts the code as soon as
503:32 - that line gets
503:35 - runs the runtime of the C standard SDI
503:40 - Doh says before it prompts us for the
503:43 - data it actually adds a print statement
503:45 - it's not our print statement it's the
503:46 - library saying you really really should
503:50 - not be using gets and if you think this
503:52 - program is trustworthy you're probably
503:54 - wrong so I Type Hello World which is 11
504:00 - characters hello space world yeah it's
504:02 - 11 characters hello world's 11
504:04 - characters I type 11 characters in that
504:06 - includes the 12th character which is the
504:08 - back slash zero and that fits into s S15
504:12 - a 15 15 element string uh character
504:15 - array in the variable s so the program
504:18 - works just fine then I type a. out again
504:20 - and it once again tells me please don't
504:22 - use gets you're going to be in so much
504:24 - trouble and now I type in dead a bunch
504:27 - of a hello and a bunch of spaces and
504:30 - then world and it prints out hello bunch
504:32 - of spaces and world but has overwritten
504:34 - all kinds of unknown data
504:38 - after the S15 so that's you know that's
504:41 - like 30 or 25 or 30 characters and it
504:44 - the first 15 are in s but then the next
504:47 - 15 are somewhere else and S is on the
504:50 - stack because it's an automatic variable
504:52 - in Main and it goes wiping out the rest
504:55 - of the stack now it turns out that the
504:57 - cun time puts things on the stack to
505:00 - kind of Mark or to catch this overflow
505:02 - and so what happens is as soon as that
505:04 - code finishes it says abort trap six
505:07 - which is basically the C runtime saying
505:10 - you know what I'm not going to let this
505:12 - program proceed any further because
505:13 - there has been an array that got messed
505:16 - up and it's not that it caught it's not
505:20 - that it caught the array messing up it
505:23 - didn't know how long it was it just put
505:24 - characters in but what it did is I put
505:26 - something after the array and then it
505:28 - checked for it later and that got wiped
505:30 - out and it's like okay you wiped out my
505:33 - magic little secret and so I'm going to
505:36 - not let you continue and so we don't you
505:39 - want you to use get S um and this is a
505:42 - buffer overflow and I I can give you
505:44 - eventually maybe we will look at some
505:46 - much more complex examples of this where
505:48 - we try to like use something like get us
505:51 - to manipulate what the program does
505:53 - rather than just blow the program up but
505:55 - this is a very simple example of buffer
505:58 - overflow so in summary pointers
506:01 - are the beautiful most beautiful part of
506:05 - SE they're complex but basically
506:09 - pointers make it so that a highlevel
506:10 - language can function like a low-level
506:12 - language if we don't have pointers and I
506:15 - mean not even kind of crappy python ones
506:18 - I mean pointers that we can look up and
506:20 - then D reference officially and formally
506:23 - and not have it be a sneaky way that
506:24 - we're doing it that means means that you
506:26 - can do the things that operating systems
506:28 - need to do the kinds of things that we
506:30 - used to write Assembly Language for
506:32 - meaning we're going to here's a buffer
506:33 - of memory we're going to copy this
506:35 - buffer we're going to do another thing
506:36 - and there there's another buffer and
506:37 - there's a link list of all the different
506:41 - buffers so understanding pointers leads
506:44 - you to the path of Assembly Language
506:46 - machine language and then ultimately
506:48 - Hardware so you should not rush through
506:51 - this material pointers are really really
506:54 - important
506:56 - everything we're going to do from now on
506:58 - pointer is just I'm just going to say
507:00 - pointer pointer pointer just like I say
507:02 - object oriented over all the time I'm
507:03 - going to say pointer all the time
507:05 - sections 57 and 510 through 5 52 are a
507:09 - little dense so what I really want you
507:11 - to do is understand the stuff I just
507:13 - talked about and the corresponding
507:15 - sections and chapter six will be more
507:18 - fun because we'll be doing much more
507:20 - with the pointers rather than just what
507:23 - is a pointer
507:30 - [Music]
507:36 - welcome to C programming for everybody
507:38 - my name is Charles S and this is my
507:41 - reading of the 1978c programming book
507:43 - written by Brian kernigan and Dennis
507:45 - Richie at times I add my own
507:47 - interpretation of the material from a
507:49 - historical
507:51 - perspective chapter five pointers and
507:54 - arrays
507:56 - before we start chapter 5 a quick note
507:58 - from your narrator from time to time I
508:01 - have been adding some of my
508:02 - interpretation to this book but I won't
508:05 - be adding anything to this chapter I
508:08 - think that sections 5.1 through 5.6
508:11 - contain some of the most elegantly
508:13 - written text in the book concepts are
508:16 - clearly stated and the example quote is
508:19 - short direct and easy to understand
508:22 - pointers are the essential difference
508:25 - between C and any other modern
508:27 - programming language so pay close
508:30 - attention to this chapter and make sure
508:32 - that you understand it before
508:34 - continuing this chapter is as strong now
508:37 - as it was in
508:38 - 1978 and so without further Ado we read
508:42 - and listen as kernigan and Richie teach
508:44 - us about pointers and
508:47 - arrays a pointer is a variable that
508:50 - contains the address of another variable
508:53 - pointers are very much used in C partly
508:56 - because they are sometimes the only way
508:58 - to express a computation and partly
509:01 - because they usually lead to more
509:03 - Compact and efficient code than can be
509:06 - obtained in other
509:08 - ways pointers have been lumped with a
509:10 - go-to statement as a marvelous way to
509:12 - create impossible to understand programs
509:15 - this is certainly true when they are
509:17 - used carelessly and it is easy to create
509:20 - pointers that point somewhere
509:22 - unexpected with discipline however
509:25 - pointers can can also be used to achieve
509:28 - Clarity and simplicity this is the a
509:31 - aspect that we will try to
509:34 - illustrate section 5.1 pointers and
509:39 - addresses since a pointer contains the
509:42 - address of an object it is possible to
509:45 - access the object indirectly through the
509:47 - pointer suppose that X is a variable say
509:51 - int and that PX is a pointer created in
509:55 - some as yet unspecified way the unary
510:00 - operator Ampersand gives the address of
510:02 - an object so the statement PX equals
510:06 - Ampersand X
510:07 - semicolon assigns the address of x to
510:10 - the variable PX PX is now said to point
510:14 - to X the Ampersand operator can be
510:18 - applied only to variables and array
510:21 - elements construct like Amper sand open
510:24 - pren X+1 Clos pren and ersan 3 are
510:28 - illegal is also illegal to take the
510:31 - address of a register
510:33 - variable the UN the unary operator
510:36 - asterisk treats its operand as the
510:39 - address of the ultimate Target and
510:41 - accesses that address to fetch the
510:43 - contents thus if Y is also an INT y
510:48 - equals star PX
510:51 - semicolon assigns to Y the contents of
510:55 - whatever p PX points to so the sequence
510:59 - PX = Ampersand X semicolon yal star PX
511:05 - semicolon assigns the same value to Y as
511:08 - does y =
511:11 - x it is also necessary to declare the
511:14 - variables that participate in all of
511:16 - this int X comma y semicolon int star PX
511:22 - semicolon the Declaration of X and Y is
511:25 - what we have seen All Along The
511:27 - Declaration of the pointer PX is new int
511:31 - star PX semicolon is intended as a
511:34 - pneumonic it says that the combination
511:37 - star PX is an INT that is if PX occurs
511:42 - in the context star PX it is equivalent
511:45 - to a variable of type INT in effect the
511:49 - syntax of the Declaration for a variable
511:52 - mimics the syntax of expressions in
511:54 - which the variable might appear this
511:57 - reasoning is useful in all cases
511:59 - involving complicated
512:01 - declarations for example double A to F
512:05 - open parentheses closed parentheses
512:07 - comma star DP semicon says that in a
512:11 - particular expression a to F open PR
512:13 - Clos print and star DP have values of
512:17 - type
512:18 - double you should also note the
512:20 - implication in the direction declaration
512:23 - that a pointer is constrained to point
512:25 - to a part particular kind of objects
512:28 - pointers can occur in expressions for
512:31 - example if PX points to the integer X
512:34 - Then star PX can occur in any context
512:38 - where X could y equal star PX + 1 sets y
512:45 - to one more than
512:47 - x print F open parentheses double quote
512:51 - percent D back sln double quote comma
512:54 - star PX close perin prints the current
512:57 - value of x and D equal Square OT open
513:03 - pin open p double Clos paren star PX
513:07 - closed per n produces in D the square
513:10 - root of x which is coerced into a double
513:13 - before being passed to square
513:16 - root expressions like y equals star PX +
513:20 - one The unary Operators star and
513:24 - Ampersand bind more tightly than
513:26 - arithmetic operators so this expression
513:29 - takes whatever PX points at adds one and
513:32 - assigns it to Y we will return shortly
513:35 - to what y equal star open print PX + one
513:40 - Clos print might
513:42 - mean pointer references can also occur
513:46 - on the left side of assignments if PX
513:48 - points to X Then star PX equals 0 sets X
513:54 - to Zero and star PX plus equals 1
513:59 - increments it as does open pen star PX
514:02 - Clos pen plus plus the parentheses are
514:06 - necessary in this last example without
514:08 - them the Inc expression would increment
514:11 - PX instead of what it points to because
514:14 - unary operators like star and Plus+ are
514:18 - evaluated right to
514:20 - left finally since pointers are
514:23 - variables they can be manipulated as
514:25 - other variables can if py is another
514:29 - pointer to int then py equals PX copies
514:34 - the contents of PX into py thus making
514:38 - py point to whatever PX points
514:42 - to section 5.2 pointers and function
514:47 - arguments since C passes arguments to
514:50 - functions by call by value there is no
514:53 - direct way for the called function
514:56 - to alter the variable in the calling
514:58 - function what do you do if you really
515:02 - have to change an ordinary argument for
515:04 - example a sorting routine might exchange
515:07 - two outof order elements with a function
515:09 - called swap it's not enough to write
515:12 - swap open parentheses a comma B closed
515:15 - parentheses semicolon where the swap
515:17 - function is defined as and this is
515:20 - sample source code on page 91 of the
515:22 - textbook and you can see it at ww w. cc4
515:27 - e.com
515:28 - code this is a wrong swap by the way
515:31 - this this is showing you the code that
515:33 - you're not supposed to
515:35 - do swap open PR X comma y Clos print int
515:40 - X comma y semicolon open curly brace in
515:44 - temp semicolon temp equals X xal Y
515:48 - semicolon y equals temp semicolon Clos
515:51 - curly
515:53 - brace because of call by value swap
515:56 - can't affect the arguments A and B in
515:58 - the routine that called it fortunately
516:02 - there is a way to obtain the desired
516:04 - effect the calling Point program passes
516:08 - pointers to the values to be changed the
516:11 - call is swap open parentheses Amper sand
516:14 - a comma Ampersand B closed parentheses
516:18 - semicolon since the operator Ampersand
516:21 - gives the address of a variable
516:23 - Ampersand a is a pointer to a in swap
516:26 - itself the arguments are declared to be
516:28 - pointers and the actual operands are
516:30 - accessed through
516:31 - them so the correct code is on page
516:36 - 92 swap open pin PX comma py Clos pin
516:41 - int star PX comma star py semicolon open
516:46 - curly brace int temp semicolon temp
516:51 - equals star PX semicolon star PX equals
516:55 - star py semicolon star py equals temp
517:00 - semicolon and close curly
517:05 - brace one common use of pointer
517:07 - arguments is in functions that must
517:09 - return more than a single value you
517:11 - might say that swap actually returns two
517:13 - values the new values of its
517:16 - arguments as an example consider a
517:18 - function get int which performs a free
517:20 - format input conversion by breaking a
517:22 - stream of characters into integer values
517:25 - one integer birth call it int has to
517:29 - return the value that it found or an Ile
517:31 - signal when there is no more input these
517:34 - values have to be returned as separate
517:36 - objects for no matter what value is used
517:39 - for eof that could also be a value of
517:43 - the
517:43 - integer one solution which is based on
517:46 - the input function scanf that we will
517:48 - describe in chapter 7 is to have get int
517:52 - return eof as its function value at
517:54 - finds end of file
517:56 - and other any other returned value
517:58 - signals a normal integer the numeric
518:01 - value of the integer it found is
518:03 - returned through an argument which then
518:05 - must be a pointer to an integer this
518:07 - organization separates the end of file
518:10 - status from The Returned numeric
518:13 - value the following Loop fills an array
518:16 - with integers by calls to get in int
518:20 - comma n comma array open pin size Clos
518:23 - pen semicolon for n equals 0 n less than
518:29 - size double Amper sand yet int open
518:33 - print Ampersand V Clos print not equal
518:35 - eof semicolon n plus plus close
518:39 - parentheses array subn equals
518:43 - V each call sets V to the next integer
518:47 - found in the input notice it is
518:50 - essential to write Ampersand V instead
518:53 - of v as the argument to get int
518:56 - using plain V is likely to cause an
518:58 - addressing error since get in believes
519:00 - that it's been handed a valid
519:03 - pointer get in is an obvious
519:05 - modification to a toi which we wrote
519:08 - earlier the sample code is on page 93 of
519:12 - the textbook and you can see this sample
519:14 - code at
519:16 - www.cc.com
519:19 - code pound include
519:22 - stdio.h get int open print PN
519:25 - close print int star PN
519:30 - semicolon open PR open curly brace int C
519:34 - comma
519:35 - sign while open print open print C
519:38 - equals get CH open print close print
519:40 - close print dou equals quote space quote
519:45 - or C equals quot sln quote or C equals
519:51 - back
519:52 - SLT
519:54 - quot close paren semicolon this Loop
519:58 - we've done before and it skips the white
520:00 - space s equals one semicolon if open pen
520:05 - C equals quot plus quote or C equals
520:09 - quote minus quote Clos paren open cly
520:12 - brace sign equals open pen cou equals
520:17 - quote plus quote Clos pen question mark
520:19 - one colon minus one
520:23 - semicolon C equals get CH to advance the
520:27 - character semicolon and then close curly
520:30 - brace that those four lines record the
520:33 - sign now for Star PN equals z c greater
520:39 - than or equal to quote 0 quote and C
520:41 - less than or equal to quote 9 quote
520:44 - colon semicolon C equals get C open pen
520:48 - closed pin close curly
520:50 - brace star PN equal 10 * star PN plus C
520:57 - minus quot 0
521:00 - quote star PN star equals
521:05 - sign if open PR c not equal to EF Clos
521:10 - print on get CH open print C Clos print
521:15 - semicolon return
521:20 - C throughout get int star PN is used as
521:24 - an ordinary int
521:25 - variable we have also used get CH and
521:28 - unget CH as described in chapter 4 so
521:31 - the one extra character that must be
521:33 - read can be pushed back down to the
521:35 - input section 5.3 pointers and arrays
521:39 - and see there is a strong relationship
521:40 - between pointers and arrays strong
521:43 - enough that pointers and arrays should
521:45 - really be treated
521:47 - simultaneously any operation which can
521:50 - be achieved by array subscripting can
521:52 - also be done with pointers
521:55 - the pointer version will in general be
521:58 - faster but at least to the uninitiated
522:00 - somewhat harder to grasp
522:03 - immediately the Declaration int a sub
522:07 - 10 finds an array a of size 10 that is a
522:11 - block of 10 consecutive objects named a
522:14 - sub z a sub one dot dot dot a sub n the
522:19 - notation a subi means the element of the
522:22 - array I positions from the beginning
522:26 - if PA
522:29 - is a pointer to an
522:32 - integer declared as int star PA then the
522:37 - assignment PA equals Ampersand a sub Zer
522:44 - sets PA to point to the zeroth element
522:48 - of a that is PA contains the address of
522:52 - a Subzero
522:55 - now the assignment x equals star PA will
522:59 - copy the contents of a sub Z into
523:04 - X if PA points to a particular element
523:07 - of array a then by definition PA points
523:12 - to the next Element
523:18 - no if PA points to a particular element
523:21 - of an array a then by definition PA plus
523:25 - one points to the next element and in
523:28 - general PA minus i points to I elements
523:32 - before PA and Pa plus I points to I
523:36 - elements after thus if PA points to a
523:41 - sub Zer star parentheses PA + one Clos
523:46 - parentheses refers to the contents of a
523:49 - sub
523:51 - one PA plus I is the address of a subi
523:56 - and star P
524:00 - print and star openr PA plus I is the
524:06 - contents of a
524:07 - subi these remarks are true regardless
524:10 - of the type of the variables in the
524:12 - array a the definition of adding one to
524:15 - a pointer and by extension all pointer
524:19 - arithmetic is that the increment is
524:21 - scaled by the size of the storage of the
524:23 - object that is pointed to
524:26 - thus in PA plus I I is multiplied by the
524:31 - size of the objects that PA points to
524:33 - before being added to
524:35 - PA the correspondence between indexing
524:38 - and pointer arithmetic is evidently very
524:41 - close in fact a reference to an array is
524:45 - converted by the compiler to a pointer
524:47 - to the beginning of the
524:49 - array the effect is that the array name
524:52 - is a pointer expression this has quite a
524:55 - few useful implications since the name
524:58 - of an array is a synonym for the
525:00 - location of the zeroth element the
525:04 - assignment PA equals Ampersand a subz
525:09 - can also be written as PA equals
525:15 - a rather more surprising at least at
525:18 - First Sight is the fact that a reference
525:20 - to a subi can also be written as star
525:24 - open PR a + I Clos PR in evaluating a
525:29 - subi c converts it to Star open pren A+
525:34 - I close pren immediately the two forms
525:37 - are completely equivalent applying the
525:40 - operator Ampersand to both parts of this
525:42 - equivalence it follows that Ampersand a
525:44 - sub I and A+ I are also identical a plus
525:49 - I is the address of the I element Beyond
525:53 - a as on the other side of this coin if
525:56 - PA is a pointer Expressions may use it
525:59 - with a
526:00 - subscript PA a subi is identical to Star
526:05 - open print PA plus I Clos print in short
526:09 - any array and index expression can be
526:12 - Rewritten as a pointer and an offset and
526:15 - vice versa even in the same
526:19 - statement there is one difference
526:21 - between an array name and a pointer that
526:23 - must be kept in mind a pointer is a
526:26 - variable so PA equal a and Pa A++ are
526:32 - sensible
526:33 - operations but an array name is a
526:35 - constant not a variable constructions
526:38 - like a equals PA or
526:41 - A++ or P equals Ampersand a are
526:47 - illegal when an array name is passed to
526:49 - a function what is passed is the
526:52 - location of the beginning of the array
526:55 - within the called function this argument
526:57 - is a variable just like any other
526:59 - variable and so an array name argument
527:02 - is truly a pointer that is a variable
527:05 - containing an
527:07 - address we can use this fact to write a
527:09 - new version of sterlin which computes
527:12 - the length of the
527:13 - string the sample code is on page 95 of
527:16 - the book and you can see it in
527:20 - www.cc.com
527:22 - code page 95
527:25 - in sterin open PR s Clos PR Char star s
527:32 - semicolon open curly brace int and
527:37 - semicolon
527:39 - four open parentheses n equals 0
527:42 - semicolon star s not equal qu0 quot
527:47 - semicolon
527:49 - s++ close per n
527:53 - n++ return open print and Clos print
527:56 - semicolon Clos curly
527:59 - brace incrementing s is perfectly legal
528:03 - since it's a pointer variable s++ has no
528:08 - effect on the character string in
528:09 - function that called sterland but merely
528:12 - increments the sterland private copy of
528:14 - the
528:15 - address as the formal parameters in a
528:18 - function definition Char s open square
528:21 - bracket closed square bracket semicolon
528:24 - and and Char star s semicolon are
528:28 - exactly
528:30 - equivalent which one should be written
528:32 - is determined largely by how Expressions
528:34 - will be written in the function when an
528:37 - array name is passed to a function the
528:39 - function can its convenience believe
528:41 - that has been handed either an array or
528:43 - a pointer and manipulated accordingly it
528:46 - can even use both kinds of operations if
528:49 - it seems appropriate and
528:52 - clear it is possible to pass part of an
528:55 - array to a function by passing a pointer
528:58 - to the beginning of the subarray for
529:01 - example if a is an
529:04 - array F open PR Ampersand a sub 2 Clos
529:09 - prin and F open print a + 2 Clos print
529:14 - both pass to the function f the address
529:17 - of the element a sub 2 because Ampersand
529:20 - a sub 2 and a + 2 are both pointer
529:24 - expressions
529:25 - that refer to the third element of
529:28 - a within F the argument declaration can
529:33 - read F open print array Clos print int
529:39 - array Open Bracket close bracket
529:42 - semicolon dot dot dot or F open print
529:47 - array Clos print in Star array
529:51 - semicolon dot dot dot so far as f is
529:55 - concerned the fact that the argument
529:57 - really refers to a part of a larger
529:59 - array is really of no
530:03 - consequence section 5.4 address
530:07 - arithmetic if p is a pointer then p++
530:10 - increments P to point to the next
530:13 - element of whatever kind of object P
530:15 - points to and P plus equals I increments
530:19 - P to the point I elements Beyond where
530:22 - it currently does these and simp similar
530:25 - constructions are the simplest and most
530:26 - common form forms of pointer or address
530:30 - arithmetic C is consistent and regular
530:33 - in its approach to address arithmetic
530:35 - its integration of pointers arrays and
530:38 - address arithmetic is one of the major
530:40 - strengths of the language Let Us
530:43 - illustrate some of the properties by
530:45 - writing a rudimentary storage allocator
530:47 - but useful in spite of its Simplicity
530:50 - there are two routines Alec open pren
530:53 - and closed pren returns a pointer P to n
530:56 - consecutive character positions which
530:58 - can be used by the caller of Alec for
531:01 - storing characters free open print P
531:04 - closed print releases the storage thus
531:07 - acquired so it can later be reused these
531:10 - routines are rudimentary because the
531:12 - calls to free must be made in the
531:15 - opposite order to the calls on Alec that
531:18 - is storage managed by Alec and free is a
531:21 - stack or last in first out the standard
531:24 - seed Library provides analogous
531:26 - functions which have no such
531:28 - restrictions and in chapter 8 we'll show
531:30 - how improved versions as well in the
531:32 - meantime however many applications
531:34 - really only need a trivial alet to
531:36 - dispense little pieces of storage of
531:39 - unpredictable sizes at unpredictable
531:42 - times the simplest implementation is to
531:45 - have Alec hand out pieces of a large
531:48 - character array which we will call Alec
531:50 - buff this array is private to Alec and
531:52 - free since they deal in pointers and not
531:55 - array indices no other routine need know
531:58 - the name of the array which can be
531:59 - declared as external static that is
532:01 - local to the source file containing
532:03 - alakin free and invisible outside it in
532:07 - Practical implementations the array May
532:09 - well not even have a name it might be
532:12 - obtained by asking the operating system
532:14 - for a pointer to some unnamed block of
532:17 - storage the other information needed is
532:20 - how much Alec buff has been used we use
532:22 - a pointer to the next free element
532:24 - called Alec CP when Alec is asked for n
532:28 - characters it checks to see if there is
532:30 - enough room left in Alec buff if so Alec
532:34 - Returns the current value of Alec P I.E
532:37 - the beginning of the free boach and then
532:39 - increments it by n to point to the next
532:41 - free area free P merely sets Alec P to P
532:46 - if p is inside Alec
532:48 - buff this next code example is on page
532:51 - 97 of the textbook you can you can see
532:54 - the code at
532:57 - www.cc.com
533:00 - code pound include
533:03 - stdio.h pound toine null Zer it's a
533:06 - pointer value for in the error report
533:08 - pound toine Alex size 1000 the size of
533:11 - the available
533:12 - space static Char Alec buff open square
533:16 - bracket Alex size closed square bracket
533:19 - semicolon static chair Char star Alec P
533:23 - equals Alec buff next free position
533:26 - initialized to the start of the array
533:29 - Char star Alec open print and Clos print
533:34 - return a pointer to nend characters int
533:37 - and semicolon open curly brace if Alec
533:42 - CP plus n less than or equal to Alec
533:46 - buff plus Alec size Clos pen open curly
533:49 - brace meaning we have space Alex CP plus
533:53 - equals n return Alex CP minus n closed
533:58 - parentheses
533:59 - semicolon close curly brace else if
534:02 - there's not enough room return open pin
534:05 - null Clos pin semicolon close curly
534:08 - brace free open PR P Clos print this
534:12 - function will free the storage point2 by
534:14 - P Char star P open curly brace if open
534:19 - PR P greater than equal to Alec buff and
534:23 - P less than Alec buff plus Alex size
534:26 - Alex CP equals P close curly
534:30 - brace some
534:32 - exclamations in general a pointer can be
534:35 - initialized just as any other variable
534:37 - can though normally only meaningful
534:39 - values are null discussed below or an
534:41 - expression involving the address of a
534:43 - previously defined data of the
534:45 - appropriate type the Declaration static
534:48 - Char star Alex CP equals Alec buff
534:52 - defines Alex CP
534:55 - to be a character pointer and
534:57 - initializes it to point to Alec buff
534:59 - which is the next free position when the
535:01 - program
535:02 - starts this could also have been written
535:05 - static Char St star Alex CP equals ENT
535:10 - Alec buff Subzero semicolon since the
535:13 - array name is the address of the zeroth
535:16 - element whichever is more natural the
535:20 - test if open foren Alec p
535:24 - plus n less than or equal to Alec buff
535:27 - plus Alex size checks if there's enough
535:29 - room to satisfy a request for n
535:32 - characters if there is the new value of
535:35 - Alec P would be at most one beyond the
535:38 - end of Alec buff if the request can be
535:41 - satisfied Alec returns a normal pointer
535:44 - notice the Declaration of the function
535:46 - itself if not Alec must return some kind
535:49 - of signal that there's no space left C
535:52 - guarantees that no pointer that validly
535:54 - points to data will ever contain a zero
535:57 - so a return value of zero can be used to
536:00 - signal in an abnormal event in this case
536:03 - no space we write null instead of zero
536:06 - however to indicate more clearly that
536:08 - this is a special value for a pointer in
536:11 - general integers cannot be meaningfully
536:14 - assigned to pointers but zero is a
536:16 - special
536:18 - case tests like if open for n Alec P
536:22 - plus n less than or equal to Alec buff
536:24 - plus Alex size and if open print P
536:28 - greater than or equal to Alec buff and P
536:31 - less than Alec buff plus Alex size shows
536:34 - several important facets of pointer
536:37 - arithmetic first pointers may be paired
536:40 - on certain
536:41 - circumstances if p and Q point to
536:44 - members of the same array then relations
536:47 - like less than greater than equal Etc
536:50 - work
536:51 - properly P greater than Q is true for
536:55 - example if P points to an earlier member
536:58 - of the array than Q the relations double
537:01 - equals and not equals exclamation equals
537:04 - also work any pointer can be
537:07 - meaningfully compared for equality or
537:09 - inequality with
537:11 - null but all bets are off if you do
537:14 - arithmetic or comp comparisons with
537:16 - pointers that point to different arrays
537:19 - if you're lucky you get obvious nonsense
537:22 - on all machines if you're lucky your
537:24 - code will work on one machine but
537:26 - collapse mysteriously on
537:28 - another second we've already observed
537:31 - that a pointer and an integer can be
537:33 - added or subtracted the construction p+
537:37 - N means the nth object beyond the one p
537:40 - currently points to this is true
537:43 - regardless of the kind of object p is
537:45 - declared to point at the compiler Scales
537:48 - N according to the size of the objects P
537:50 - points to which is determined by the
537:53 - Declaration of P
537:55 - for example on the PDP 11 the factors
537:58 - are one for Char two for INT and short
538:01 - and four for long float and d and float
538:04 - and eight for double pointer subtraction
538:07 - is also valid if p and Q point to
538:10 - members of the same array P minus Q is
538:14 - the number of elements between p and Q
538:17 - This fact can be used to write yet
538:19 - another version of
538:22 - sterland sterland open pin s closed pin
538:26 - Char star s semicolon open curly brace
538:30 - Char star P equals s semicolon while
538:35 - star P not equal back slash single quote
538:39 - back sl0 single quote Clos pen p++
538:43 - semicolon return open pen P minus s Clos
538:47 - pen semicolon Clos curly
538:51 - brace in its declaration p is a
538:54 - initialized s that is to point to the
538:56 - first character in the Y Loop each
538:59 - character in turn is examined until back
539:01 - sl0 at the end of scene since back sl0
539:05 - is zero and since while tests only
539:08 - whether the expression is zero it is
539:10 - possible to emit the explicit test and
539:13 - such Loops are often written as while
539:16 - open pen star P close Brin p++ semicolon
539:21 - because P points to characters p p++
539:24 - advances P up to the next character each
539:27 - time and P minus FS gives the number of
539:30 - characters Advanced over that is the
539:32 - string length pointer arithmetic is
539:35 - consistent if we'd been dealing with
539:37 - floats which OCC occupy more storage
539:39 - than chars and if P were a pointer to a
539:41 - float p++ would advance to the next
539:44 - float thus we could write another
539:46 - version of Alec which maintains say
539:48 - floats instead of chars merely by
539:50 - changing Char to float throughout Alec
539:52 - and free
539:54 - all the pointer manipulations
539:55 - automatically take into the account the
539:58 - size of the object pointed to so nothing
540:00 - else has to be altered other than the
540:03 - operations mentioned here adding or
540:05 - subtracting a pointer in an integer
540:07 - subtracting or comparing two pointers
540:09 - all other pointer arithmetic is illegal
540:13 - it is not permitted to add two pointers
540:15 - or to multiply or divide or shift or
540:17 - mass them or add float or double to
540:22 - them Section 5 .5 character pointers and
540:26 - functions a string constant written as
540:29 - double quote I am a string double quote
540:31 - is an array of characters in the
540:34 - internal representation the compiler
540:36 - terminates the array with a character
540:37 - back sl0 so programs can find the end
540:41 - the length in storage is thus one more
540:43 - than the number of characters between
540:45 - the double
540:46 - quotes perhaps the most common
540:48 - occurrence of a string constant is
540:50 - arguments to functions as in print F
540:52 - open PR double quot quot hello comma
540:55 - world back sln double quote when a
540:58 - character string appears like this in a
541:00 - program access to it is through a
541:02 - character pointer what print F receives
541:05 - is a pointer to the character
541:07 - array character arrays of course need
541:10 - not be function arguments if message is
541:13 - declared as Char star message then the
541:17 - statement message equals double quote
541:19 - now is the time double quot semicolon
541:22 - assigns message to a pointer to the
541:24 - actual characters this is not a string
541:27 - copy only pointers are involved C does
541:31 - not provide any operators for processing
541:33 - an entire string of characters as a unit
541:36 - in the
541:38 - language we will illustrate more aspects
541:40 - of pointers and arrays by studying two
541:42 - useful functions from the standard IO
541:44 - library to be discussed in chapter 7 the
541:48 - first function is Stir copy open print s
541:50 - comma T which copies the string t to the
541:53 - string s s the arguments are written in
541:56 - this order by analogy to assignment
541:58 - where one would say s equals T to assign
542:02 - T to S the array version is
542:05 - first stir copy open print s comma T
542:10 - Clos print Char s open square bracket
542:13 - close square bracket comma T open square
542:15 - bracket close square bracket semicolon
542:17 - open curly brace in I
542:20 - semicolon I equals z semicolon
542:24 - while open PR open pren S Sub I equals T
542:28 - sub I Clos pren not equal quote back sl0
542:33 - quote close parentheses i++ semicolon
542:37 - close curly
542:39 - brace you'll note in that while
542:41 - statement that there is a copying of the
542:44 - actual characters as an assignment and
542:46 - then the side effect of the result of
542:47 - that assignment is compared to the new
542:49 - line to the end of string which
542:51 - terminates the while loop
542:54 - for contrast here is a version of stir
542:57 - copy with pointers and this is on page
542:59 - 100 of the textbook and you can see all
543:02 - the code in the textbook at
543:05 - www.cc.com
543:07 - codee and again this is example number
543:10 - two on page
543:11 - 100 stir copy open pren S comma T close
543:16 - pren Char star s comma star T semicolon
543:21 - open curly brace while open par open
543:24 - Print Star s equals star T Clos print
543:27 - not equal single quote back sl0 single
543:30 - quote close print open curly brace s++
543:34 - comma uh semicolon t++ semicolon close
543:38 - curly brace close curly brace to end the
543:41 - function because the arguments are
543:43 - passed by value stir copy can use SNT in
543:48 - any way it pleases here they are
543:50 - conveniently initialized pointers which
543:52 - are marched along arrays a character at
543:55 - a time until the backslash
543:57 - terminates then T has been copied to
544:01 - s in practice stir copy would not be
544:03 - written as we showed above a second
544:06 - possibility might be and this is the
544:08 - third example on page 100 of the
544:11 - textbook stir copy open BR s comma T
544:14 - Clos PR Char star s comma star T
544:18 - semicolon open curly brace while pen pen
544:22 - star S Plus plus equals star
544:26 - t++ Clos print not equal quot back sl0
544:31 - quote close print semicolon curly brace
544:36 - this moves the increment and S&T into
544:38 - the test part the value of star t++ is
544:42 - the character that t pointed to before T
544:45 - was incremented the post fix Plus+
544:49 - doesn't change T until after this
544:51 - character has been fetched in the same
544:54 - way the character is stored in the old
544:56 - position of s before s is incremented
544:59 - the character is also the value that is
545:01 - compared against back sl0 to control the
545:03 - loop the net effect is that the
545:07 - characters are copied from T to S up to
545:10 - and including the terminating back
545:13 - sl0 as the final
545:17 - abbreviation of this solving this
545:20 - problem we can observe that the
545:22 - comparison against back x0 is redundant
545:25 - so the function is often written as and
545:27 - now this is the first sample code on
545:30 - page 101 of the
545:32 - textbook stir copy open print s comma T
545:36 - Clos print Char star s comma star T
545:40 - semicolon open curly brace while open
545:44 - Print Star
545:46 - s++ equals star t++ Clos print semicolon
545:53 - Cur
545:54 - brace although this may seem cryptic at
545:57 - first the notational convenience is
546:00 - considerable and the idiom should be
546:02 - mastered if for no other reason than you
546:04 - will see it frequently in C
546:07 - programs the second routine is Stir comp
546:10 - open PR s comma
546:12 - T which compares the character strings s
546:15 - and
546:17 - t and returns negative zero or positive
546:21 - according to as s is lexographic
546:23 - less than equal to or greater than T the
546:26 - value returned is obtained by
546:28 - subtracting the characters at the first
546:30 - position where s&
546:33 - disagree this is the second example on
546:36 - page 101 of the
546:38 - textbook which you can see at
546:42 - www.cc.com
546:44 - code stirm open print s comma T Clos
546:49 - print Char s open square bracket close
546:52 - square square bracket comma T open
546:54 - square bracket close square bracket
546:56 - semicolon open curly brace in I
547:00 - semicolon I equals z
547:02 - semicolon while S Sub I double equals T
547:07 - subi Clos PR open print S Sub i++ double
547:12 - equals single quote back slash 0 single
547:15 - quote close print return zero return
547:18 - open print S Sub I minus t sub I Clos
547:22 - print semicolon close curly brace the
547:25 - pointer version of stir comp is the
547:28 - first example on page 102 of the
547:31 - textbook stir comp open p s comma T Clos
547:34 - pen Char star s comma star
547:38 - T open curly brace four open prin
547:43 - semicolon star s dou equal star T
547:47 - semicolon s++ comma
547:50 - t++ Clos pint if open pren star s equal
547:55 - equal single quote back sl0 single quote
547:58 - close pren return open pren Z close
548:01 - print return open Print Star s minus
548:05 - star T Clos print semicolon close curly
548:08 - brace since plus plus and minus minus
548:11 - are either prefix or postfix operators
548:14 - the combination of star and Plus+ and
548:18 - minus minus occur although less
548:21 - frequently for example star
548:24 - r++ P increments P before fetching the
548:29 - character that P points
548:31 - to Star minus minus p decrements p first
548:37 - section 5.6 pointers are not
548:40 - integers you may notice in older C
548:43 - programs a rather Cavalier attitude
548:46 - towards copying pointers it has
548:48 - generally been true that on most
548:50 - machines a pointer may be assigned to an
548:52 - integer and back again without changing
548:54 - it no scaling or conversion takes place
548:56 - and no bits are lost regrettably this
548:59 - has led to the taking of liberties with
549:02 - routines that return pointers which are
549:04 - then merely passed to other routines the
549:06 - requisite pointer declarations are often
549:08 - left out for example consider the
549:11 - function stir Save open print s Clos
549:13 - print which copies the string s into a
549:16 - safe place obtained by a call to Alec
549:18 - and returns a pointer to it properly
549:21 - this should be written as this this is
549:23 - the first example on page 103 of the
549:25 - textbook you can see the sample code at
549:28 - www.cc for.com
549:32 - code pound include STD live. charar Ser
549:37 - stir Save open print s Clos pin save a
549:40 - string somewhere Char star s semicolon
549:44 - open curly brace Char star P star Alec
549:48 - open PR Clos PR semicolon if open PR
549:52 - open PR p equals Alec open PR sterland
549:55 - open PR s Clos PR plus one Clos PR Clos
549:58 - PR not equal null Clos PR stir copy open
550:03 - PR P comma s close PR semicolon return
550:08 - open p p Clos print semicolon curly
550:12 - brace in practice there would be a
550:15 - strong tendency mistaken tendency that
550:18 - is to emit declarations this is the
550:21 - example two on page 103
550:25 - pound include stdlib.h stir Save open
550:28 - print s Clos
550:30 - print open curly brace Char star P
550:34 - semicolon if parentheses
550:36 - parentheses p equals Alec open p sterlin
550:41 - open p s Clos PR plus one close print
550:45 - close print not equal null Clos PR stir
550:47 - copy open print P comma s Clos print
550:51 - semicolon return open print P close
550:54 - print
550:55 - semicolon this will work on many
550:57 - machines since the default type for
551:00 - functions and arguments is int and int
551:03 - and pointer can usually be safely
551:05 - assigned back and forth nonetheless this
551:08 - kind of code is inherently risky for it
551:11 - depends on the details of the
551:12 - implementation and machine architecture
551:15 - which may not hold for the particular
551:17 - compiler you use it is wiser to be
551:20 - complete in all declarations the program
551:22 - lint will warn of such constructions in
551:25 - case they creep in
551:27 - inadvertently section 5.7
551:30 - multi-dimensional
551:31 - arrays in general rectangular
551:34 - multi-dimensional arrays are used in
551:36 - computational programs like a weather
551:38 - simulation and were a way back in the
551:42 - day to write C code that could accept
551:44 - Fortran multi-dimensional arrays as
551:46 - parameters so that computational or
551:48 - statistical libraries could be written
551:50 - in C arrays of pointers are a mapping to
551:53 - the typical operating system and string
551:56 - manipulation use cases that are more the
551:58 - core of C applications we also call
552:01 - these ragged arrays because each row can
552:03 - be a different length this also works
552:06 - well as data is dynamically allocated in
552:08 - C as compared to the more static
552:10 - allocation approach that's typical in
552:12 - forr multi-dimensional
552:15 - arrays uh now to the
552:17 - textbook C provides for rectangular
552:20 - multi-dimensional arrays although in
552:21 - practice they tend to be much less used
552:24 - than the arrays of pointers in this
552:26 - section we will show some of their
552:27 - properties consider the problem of date
552:30 - conversion from the day of the month to
552:32 - the day of the year and vice versa for
552:34 - example March 1st is the 60th day of a
552:37 - non-leap year and 61st day of a leap
552:41 - year let us Define two functions to do
552:43 - the conversions day of year converts
552:45 - month and day to the day of the year and
552:48 - month day converts the day of the year
552:49 - into the month and the day since this
552:52 - latter function returns to two values
552:53 - the month and day arguments will be
552:56 - pointers month day open parentheses 1977
553:00 - comma 60 Ampersand M comma Ampersand D
553:04 - Clos parentheses sets m to3 and d to one
553:08 - which is March
553:10 - 1st these functions both need the same
553:13 - information a table of the number of
553:15 - days in each month 30 days half
553:17 - September Etc since the number of days
553:20 - per month differs for leap years and
553:23 - non- Le years it's easier to separate
553:25 - them into two rows of a two-dimensional
553:27 - array rather than try to keep track of
553:29 - what happens in February during
553:31 - computation the array and the functions
553:33 - performing the Transformations are as
553:36 - follows this is example number one on
553:40 - page 104 of the textbook and you can see
553:42 - the code at
553:44 - www.cc.com
553:50 - code static int d a tab open PR to close
553:55 - PR open PR 13 close PR equals open curly
554:00 - brace open curly brace 0 comma 31 and
554:04 - then a number of numbers close curly
554:07 - brace comma open curly brace 0 comma 31
554:11 - 29 and then a bunch of numbers close
554:13 - curly brace close curly brace
554:18 - semicolon day of the year open print
554:21 - year comma month comma day
554:23 - int year comma month comma day semicolon
554:26 - open curly brace int I comma leap
554:29 - semicolon leap equals z year modulo 4
554:35 - equals 0 and year modulo 100 not equals
554:40 - z or year modulo 400 equals equals z
554:45 - semicolon for open print I equal 1 I
554:49 - less than month I ++ Clos prin day plus
554:53 - equals Day tab open square bracket leap
554:57 - close square bracket open square bracket
554:59 - I close square bracket
555:01 - semicolon return open pen day close pen
555:05 - semicolon close curly brace then the
555:08 - month day function month day open pen
555:12 - year comma Year Day comma P Monon comma
555:15 - pday close pen int year comma Year Day
555:20 - star P month comma star p day semicolon
555:25 - open curly brace in I comma leap
555:28 - semicolon leap equals year percent 4
555:32 - Double equals z and year percent 100 not
555:37 - equals z or year percent 1400 double
555:41 - equals z for I equal 1 Year Day greater
555:46 - than date tab open square bracket leap
555:49 - close square bracket open square bracket
555:51 - I close square bracket semicolon I ++
555:54 - close parentheses Year Day minus equal
555:58 - Day tab open Square parenthe open square
556:01 - bracket leap closed square bracket open
556:03 - square bracket I closed square bracket
556:06 - semicolon star P month equals I star
556:10 - pday equals Year Day semicolon Clos
556:14 - parent the array Day tab has to be
556:17 - external to both day of year and month
556:19 - day so they can both use it dat tab is
556:22 - the first two-dimensional array we've
556:24 - dealt with in C by definition a
556:27 - two-dimensional array is really a
556:29 - one-dimensional array Each of which
556:31 - elements is also an array hence
556:34 - subscripts are written as Day tab open
556:37 - square bracket I closed square bracket
556:39 - open square bracket J closed square
556:41 - bracket rather than Day tab open square
556:45 - bracket I comma J close square bracket
556:47 - as in most
556:49 - languages other than this a
556:51 - two-dimensional array can be treated
556:53 - much the same in the same way as other
556:55 - languages elements are stored by rows
556:57 - that is the rightmost subscript varies
557:00 - fastest as elements are accessed in
557:03 - storage order an array is initialized by
557:06 - ini list of initializers and braces each
557:09 - row of a two-dimensional array is
557:11 - initialized by a corresponding sublist
557:14 - we started the array datab with a column
557:16 - of zero so that month numbers can run
557:18 - from the natural 1 to 12 instead of 0 to
557:21 - 11 since space is is not a premium here
557:23 - this is easier than adjusting
557:26 - indices if a two-dimensional array is to
557:28 - be passed to a function the argument
557:31 - definition declaration in the function
557:34 - must include the column Dimension the
557:35 - row Dimension is irrelevant since what
557:38 - is passed in as before it is a pointer
557:42 - this is in this particular case it's a
557:43 - pointer to objects which are arrays of
557:46 - 13 ins thus the array Day tab if it's to
557:49 - be passed to a function f the
557:51 - Declaration would be F open pren Day tab
557:55 - Clos pren int Day tab open square
557:58 - bracket 2 close square bracket open
558:00 - square bracket 13 close square bracket
558:03 - semicolon open curly brace dot dot dot
558:06 - Clos curly
558:07 - brace the argument declaration in F
558:09 - could also be int dat tab open square
558:13 - bracket close square bracket open square
558:15 - bracket 13 close square bracket
558:17 - semicolon since the number of rows is
558:20 - actually irrelevant it could also be SE
558:23 - as in open prin star Day tab Clos prin
558:27 - Open Bracket 13 Clos bracket semicolon
558:32 - which says that the argument is a
558:33 - pointer to an array of 13 integers the
558:37 - parentheses are necessary since the
558:39 - brackets have higher precedence than
558:41 - asterisk without parentheses the
558:43 - Declaration int star datab
558:47 - sub3 close square bracket semicolon is
558:51 - an array of 13 pointers to integers as
558:54 - we shall see in the next section section
558:57 - 5.8 pointer arrays pointers to pointers
559:01 - since pointers are variables themselves
559:03 - you might expect that there would be
559:05 - uses for arrays of pointers this is
559:09 - indeed the case let us illustrate by
559:11 - writing a program that will sort a set
559:14 - of text lines into alphabetic order than
559:17 - a stripped down version of the Unix
559:19 - utility sort in chapter 3 we presented a
559:22 - shell sort function that would sort an
559:24 - array of integers this same algorithm
559:27 - will work except that now we have to
559:29 - deal with lines of text which are of
559:31 - different lengths and which unlike
559:32 - integers can't be compared or moved in a
559:35 - single operation we will need a data
559:38 - representation data structure that will
559:40 - cope efficiently and conveniently with
559:42 - variable length text lines this is where
559:45 - an a array of pointers enters if the
559:49 - lines to be sorted are stored end to end
559:51 - in one long character Ray maintained by
559:53 - Alec perhaps then each line can be
559:56 - accessed by a pointer to its first
559:58 - character the pointers themselves can be
560:00 - stored in an array two lines can be
560:04 - compared by passing their pointers to
560:06 - stirum when two outof order lines have
560:09 - to be swapped or exchanged the pointers
560:12 - in the pointer array are exchanged not
560:14 - the text lines themselves this
560:16 - eliminates the twin problems of complex
560:18 - storage management and high overhead
560:21 - that would go with moving the text of
560:23 - the actual lines the Sorting process
560:26 - involves three steps read all the lines
560:28 - of input sort them and then print them
560:31 - in order as usual it's best to divide
560:34 - the program into functions that match
560:36 - this natural division with the main
560:38 - routine controlling
560:39 - things let us defer the Sorting step for
560:42 - a moment and concentrate on the data
560:44 - structures and the input and output the
560:46 - input routine has to collect and save
560:48 - the characters in each line and build an
560:49 - array of pointers to the lines it will
560:52 - also have have to count the number of
560:53 - input lines since that information is
560:55 - also needed for sorting and printing
560:57 - since the input function can only count
560:59 - cope with a finite number of input lines
561:01 - it can return some illegal line count
561:03 - like negative one if too much input is
561:06 - presented the output routine only has to
561:08 - print the lines in order in the order in
561:10 - which they appear in the array of
561:14 - pointers this next code segment uh is
561:17 - actually a combination of three
561:19 - successive sample code segments uh
561:21 - starting on page one 6 of the textbook
561:23 - and it's pretty complex so you might be
561:27 - uh best it might be best for you to see
561:29 - them on
561:31 - www.cc.com
561:32 - code line 106 example
561:36 - one
561:38 - okay pound include std. pound include
561:42 - string.h pound Define lines 100 the
561:45 - maximum lines of support to be sorted
561:48 - main open PR close PR Char line PT TR
561:53 - open bra open square bracket lines
561:55 - closed square bracket semicolon int n
561:58 - lines which is the number of lines
562:00 - red if open print open print end lines
562:04 - equals read lines open print line PTR
562:07 - comma lines close PR close PR greater
562:09 - than or equal to zero Clos PR open curly
562:12 - brace sort open PR line PTR comma end
562:16 - lines Clos pen right lines open pen line
562:20 - PTR comma end lines closed pen Su col
562:23 - close curly brace else print F open PR
562:28 - double quote input too big to sort back
562:31 - slash n close double quote close pen
562:35 - semicolon and close curly brace to end
562:37 - the main
562:39 - program this next routine is actually
562:41 - from page 107 of the textbook but we
562:43 - combined them into one pound to find
562:46 - maxan
562:48 - 1000 read lines open pren Line PTR comma
562:52 - Max lines Clos perin Char Star Line PTR
562:56 - open square bracket Clos square square
562:58 - bracket sum Co this is an array of
563:01 - pointers to characters an array of
563:04 - pointers pointers being you know long
563:06 - like four bytes characters being
563:08 - generally one bite int MAX Line
563:11 - semicolon open curly brace int Len comma
563:15 - end lines semicolon Char star P star
563:20 - Alec open PR Clos PR comma line
563:23 - open square bracket max length closed
563:25 - square bracket
563:27 - semicolon so just to recall Alec is a
563:30 - function we we did later I mean did
563:33 - earlier that allows us to allocate uh uh
563:36 - some text of uh a varying length and
563:39 - then lines so max Len is a place that
563:42 - we're going to uh read each line into
563:45 - beginning the code of read lines end
563:48 - lines equal zero while open pen open pen
563:52 - Len equals get Line open print line
563:54 - comma MAX Line Clos print Clos print
563:56 - greater than or equal to zero Clos print
564:00 - if open print end lines greater than or
564:03 - equal to Max lines Clos print return
564:05 - open print minus one Clos print
564:08 - semicolon else if open print open print
564:11 - P equals Alec open print Len close print
564:14 - close print double equals null Clos
564:18 - print return minus one so those two
564:21 - tests basically make sure that we don't
564:24 - get too many lines and that we have
564:26 - enough space in
564:28 - our Al Dynamic data area that Alec is
564:31 - managing for us so continuing with the
564:35 - if we're at the else opens curly brace
564:38 - line sub Len minus
564:40 - one equals quot back0 quote
564:45 - semicolon stir copy P comma line Clos
564:50 - print semicolon line PTR sub n lines
564:54 - Plus+ equals P semicolon Clos curly
564:58 - brace that finishes the else segment
565:02 - return n lines semicolon and close curly
565:05 - brace to finish the read lines
565:08 - function now at a high level we're
565:11 - reading a
565:12 - line into a allocated automatic variable
565:16 - line and then we
565:18 - are calling Alec to get another
565:22 - cop place a copy that line then we're
565:24 - making a copy of that line and then we
565:27 - are remembering the pointer to the
565:29 - beginning of that line in line PTR and
565:31 - that's the essence of
565:34 - it
565:38 - okay right lines open pren Line PTR
565:42 - comma end lines Clos pren Char Star Line
565:45 - PTR open square bracket closed square
565:47 - bracket semicolon again an array of
565:51 - point characters int n lines
565:55 - semicolon which is the number of
565:57 - character pointers in line PTR open
565:59 - curly brace in I semicolon four pen I
566:04 - equal 0 semicolon I less than n lines
566:06 - semicolon i+ plus Clos print print F
566:10 - open print double quote percent s back
566:13 - sln double quote comma line PTR subi
566:17 - Clos pin semicolon Clos curly brace a
566:20 - simple Loop that goes through the the
566:22 - array of character pointers and then
566:24 - prints each one out using print
566:27 - F the main new thing is the Declaration
566:31 - for line PTR Char Star Line PTR sub open
566:37 - square bracket lines closed square
566:39 - bracket semicolon says that line PTR is
566:41 - an array of lines elements each element
566:45 - of which is a pointer to a Char that is
566:47 - line PTR sub I is a character pointer
566:51 - and star line PR PTR sub I accesses a
566:57 - character since line PTR itself is an
566:59 - array that was passed to right lines it
567:01 - can be treated as a pointer exactly in
567:04 - the same manner as our earlier examples
567:06 - and the function can be written instead
567:08 - as right lines open pen line PTR comma
567:12 - end lines closed pen Char Star Line PTR
567:16 - open square bracket close square bracket
567:18 - semicolon int and line semicolon open
567:21 - curly bra Cas while open PR minus minus
567:25 - end lines greater than or equal to zero
567:27 - close PR print F open prin double quot
567:31 - percent s back sln double quot comma
567:34 - Star Line PTR ++ Clos PR
567:39 - semicolon that code by the way was on
567:41 - page 108 example one of the
567:46 - textbook Star Line PTR points initially
567:49 - to the first line but each in increment
567:52 - of line PTR advances it to the next line
567:56 - while in lines is counted
567:59 - down with input and output under control
568:03 - we can proceed to sorting the shell sort
568:05 - from chapter 3 needs minor
568:07 - changes the Declarations have to be
568:10 - modified and the comparison operation
568:12 - must be moved into a function but the
568:15 - basic algorithm is Remains the Same
568:17 - which gives us some confidence that it
568:18 - will still work and this is the second
568:21 - example on page 108 of the textbook and
568:24 - you can see this example at
568:27 - www.cc.com
568:30 - code sort sort open PR V comma n Clos PR
568:36 - Char starv open square bracket Clos
568:39 - square bracket semicolon in and
568:42 - semicolon open curly brace so we're
568:45 - getting an array of pointers to the
568:47 - beginnings of lines and how many of
568:50 - those pointers matter and the rest of it
568:53 - is shell sort with the stir comp being
568:56 - used um to do the string comparison so
569:00 - it's a three nested for loop with a
569:03 - simple if test in it so here we go open
569:07 - curly brace for the sort function int
569:10 - Gap comma I comma J semicolon Char star
569:13 - temp semicolon and that's a pointer to a
569:16 - character for open print Gap equals n /2
569:21 - slash I mean
569:22 - semicolon Gap greater than zero
569:25 - semicolon Gap slash equals 2 close
569:28 - parentheses four I equal Gap semicolon I
569:32 - less than n semicolon I ++ Clos
569:35 - parentheses four open print Jal IUS Gap
569:40 - semicolon J greater than equal to Z
569:43 - semicolon J minus equals Gap Clos pren
569:46 - open curly
569:48 - brace so that's sort of the shell part
569:51 - of the shell sort and now we have to do
569:52 - our comparison if open pin stir comp
569:57 - open
569:58 - pin V subj comma V subj plus
570:02 - Gap Clos pin less than or equal to
570:05 - zero Clos pin break and note that that's
570:09 - only breaking the third deep for Loop
570:13 - which it just goes and then runs the
570:14 - next iteration of the second for Loop
570:17 - now we do the swapping temp equals V
570:20 - subj semicolon V subj equal a V subj
570:24 - plus Gap
570:25 - semicolon V subj plus Gap equal temp now
570:28 - that's just swapping pointer values so
570:31 - the the strings that are pointed to by
570:33 - these two pointers V subj and V subj
570:36 - plus Gap if they're out of order we're
570:39 - going to swap the pointers in the array
570:42 - and move them so that if you then go
570:44 - through like we did in right lines
570:46 - earlier then um they come out in order
570:49 - but we literally read the data once
570:53 - we copy it once into the its final
570:55 - destination using Alec Alec and stir
570:58 - copy but Al once we sort it which is the
571:00 - most complex part of the calculation
571:03 - we're only moving the pointers back and
571:05 - forth so this sort is very efficient and
571:07 - requires no extra uh memory than uh what
571:11 - we had before the sort so that's really
571:13 - nice and it sorts in
571:16 - place so back to the text since any
571:19 - individual element of V which is an to
571:22 - line pointer PTR is a character pointer
571:25 - temp could also should also be one so
571:27 - one can be copied to the other we wrote
571:30 - the program about as straightforwardly
571:31 - as possible so as to get it working
571:33 - quickly it might be faster for instance
571:36 - to copy the incoming lines directly into
571:38 - an array made by read lines rather than
571:40 - copying them into line and then into a
571:42 - hidden Place maintained by Alec but it's
571:45 - wiser to make the first draft of
571:46 - something easy to understand and worry
571:49 - about efficiency later the way to make
571:52 - this program significantly faster is
571:55 - probably not by avoiding an unnecessary
571:57 - copy of the input Lines Just instead
572:00 - replacing the shell St sort by something
572:02 - quicker and better like quick sort is
572:05 - much more likely to make a real
572:06 - difference that matters in chapter one
572:09 - we pointed out that because while and
572:11 - for Loops test the termination condition
572:13 - before executing the loop body even once
572:16 - they help to ensure that the programs
572:17 - will work at their boundaries in
572:19 - particular with no input it's
572:22 - Illuminating to walk through the
572:23 - functions of the Sorting program
572:25 - checking what happens if there is no
572:28 - input text at all section 5.9
572:33 - initialization of pointer
572:35 - arrays consider the problem of writing a
572:37 - function month name open pren and Clos
572:40 - pren which returns a pointer to a
572:42 - character string containing the name of
572:44 - the MTH month this is an ideal
572:46 - application for an internal static array
572:49 - month name contains a private array of
572:51 - characters strings and returns a pointer
572:53 - to the proper one when called the topic
572:56 - of this section is how that array of
572:58 - names is
573:00 - initialized the syntax is quite similar
573:02 - to the previous initializations this is
573:05 - sample code from page 109 of the
573:06 - textbook which you can see at
573:10 - www.cc.com
573:13 - code
573:14 - charar month name open print Clos print
573:18 - so the return value for this function is
573:20 - a character pointer int n semicolon open
573:24 - curly
573:25 - brace static Char star name open square
573:29 - bracket closed square bracket equals
573:31 - open curly brace quote illegal month
573:35 - quote comma double quot January double
573:38 - quote comma double quote February double
573:41 - quote comma and so forth down to double
573:44 - quote December double quote Clos curly
573:47 - brace
573:48 - semicolon the body of the function
573:51 - function is one line return open pen
573:54 - open pen n less than one or n greater
573:57 - than 12 Clos pen question mark name Sub
574:00 - Zero colon name
574:03 - subn close pen semicolon close curly
574:07 - brace the Declaration of name which is
574:10 - an array of character pointers is the
574:12 - same as line PTR in the Sorting example
574:15 - the initializer is simply a list of
574:17 - character strings each assigned to the
574:21 - Corr responding position in the array
574:23 - more precisely the characters of the E
574:26 - string are placed somewhere else and a
574:28 - pointer to them is stored in name subi
574:32 - since the name size of the array name is
574:34 - not specify the compiler itself counts
574:36 - the initializers and fills in the
574:39 - correct
574:40 - number section 5.10 pointers versus
574:44 - multi-dimensional arrays newcomers to
574:47 - see are sometimes confused about the
574:49 - difference between a two-dimensional
574:51 - array and an array of pointers such as
574:53 - name in the example above given the
574:57 - Declarations int a open square bracket
575:01 - 10 Close square bracket open square
575:02 - bracket 10 Close square bracket
575:04 - semicolon and int star B open square
575:07 - bracket 10 Close square bracket
575:10 - semicolon the usage of A and B may be
575:13 - similar in that a sub 55 and B sub 55
575:18 - are both legal references to a single
575:20 - integer but a is a true array all 100
575:24 - storage cells have been allocated and
575:26 - the conventional rectangular subrip
575:29 - calculation is done to find any given
575:31 - element for B however the Declaration
575:34 - only allocates 10 pointers each must be
575:37 - set to point to an array of integers
575:40 - assuming that each does point to a 10
575:42 - element array then there will be 100
575:45 - storage cells set aside plus the 10
575:48 - cells for the pointers thus the array of
575:50 - pointer uses slightly more space and may
575:53 - require an explicit initialization step
575:56 - but it has two advantages accessing an
575:59 - element is done by IND direction through
576:01 - a pointer rather than by a
576:02 - multiplication and an addition and the
576:04 - rows of the array may be of different
576:06 - lengths that is each element of B need
576:09 - not point to a 10 element Vector some
576:12 - may point to two elements Others May
576:14 - point to 20 and some to none at all
576:17 - although we have phrased this discussion
576:18 - in terms of integers by far the most
576:20 - frequent use of arrays of pointers is
576:23 - like that shown in month name to store
576:25 - character strings of diverse
576:28 - lengths section
576:31 - 5.11 command line arguments in
576:34 - environments that support C there is a
576:36 - way to pass commandline arguments or
576:38 - parameters to a program when it begins
576:40 - executing when main is called to begin
576:43 - execution it is called with two
576:45 - arguments the first conventionally
576:47 - called argc is the number of command
576:50 - line arguments the program was in
576:51 - invoked with the second argv is a
576:54 - pointer to an array of character strings
576:56 - that contain the arguments one per
576:59 - string manipulating these character
577:01 - strings is a common use of multiple
577:03 - levels of
577:04 - pointers I would note that back in 1978
577:08 - the two largest bodies of code were
577:10 - likely the AT&T Unix kernel itself and
577:12 - Unix utilities like grep LS or the login
577:15 - shell so writing an operating system was
577:18 - fresh on the mind of the authors while
577:20 - writing this book
577:22 - these topics find their way into the
577:24 - text of this book in a sense a likely
577:27 - second order goal of the book was to
577:29 - train programs that might learn C and
577:31 - then might help build and maintain Unix
577:34 - the 1978 edition of this textbook fits
577:37 - nicely into a series of AT&T Bell Labs
577:40 - technical reports like the portability
577:42 - of C programs in the Unix system written
577:44 - by Stephen C Johnson and Dennis M Richie
577:47 - published in the bell's system technical
577:49 - Journal volume 57 number six part two
577:53 - July through August 1978 Pages 2021
577:56 - through
577:58 - 2048 you can see this one online if you
578:01 - search for
578:02 - it back to the
578:05 - textbook the simplest illustration of
578:07 - the ne necessary declarations and use is
578:10 - in the program echo which simply Echoes
578:13 - its command line arguments in a single
578:15 - line separated by blanks that is if the
578:18 - command Echo hello comma world is given
578:21 - the output is hello comma World by
578:25 - convention arv subz is the name by which
578:28 - the program was invok so AR C is at
578:30 - least one in the above example AR C is
578:33 - three and AR arv Sub 0 arv sub1 and r v
578:38 - sub 2 are Echo hello comma and World
578:44 - respectively the first real argument is
578:46 - argv sub one and the last is
578:50 - argv sub sub Arc minus one and if Arc is
578:54 - one there are no command line arguments
578:56 - after the program name this is shown in
578:59 - the source code to Echo and this source
579:01 - code is on page 111 of the textbook and
579:03 - you can see this source code at
579:07 - www.cc.com
579:09 - codee pound include
579:12 - stdio.h pound include string.h main open
579:16 - pen Arc comma AR Fe Clos pen int Arc
579:20 - semicolon
579:21 - Char star arv open square bracket close
579:24 - square bracket semicolon open curly
579:27 - brace in I semicolon for open p i equal
579:32 - 1 semicolon I less than RX c semicolon I
579:36 - ++ close
579:38 - pen print F open pen double quote
579:42 - percent s percent
579:44 - C double quote
579:47 - comma arv subi comma open pen I less
579:52 - than r c minus one closed pen question
579:55 - mark single quote space single quote
579:58 - colon single
579:59 - quot back slash n single quote close
580:03 - parentheses semicolon close curly brace
580:06 - to end
580:06 - it since ARG VV is a pointer to an array
580:10 - of pointers there are several ways to
580:12 - write this program that involve
580:14 - manipulating the pointer rather than
580:15 - indexing an array let us show two
580:18 - variations and this is the example
580:21 - number two on page 111 of the
580:24 - textbook pound include
580:26 - stdio.h pound include
580:28 - string.h main open pen Arc comma arv
580:32 - Clos pen int argc semicolon Char star
580:37 - arv open square bracket close square
580:39 - bracket semicolon open curly brace while
580:43 - open pen minus minus r c greater than
580:46 - zero Clos print print F open PR double
580:49 - quote percent s percent C
580:52 - double quote comma star Plus+ arv comma
580:58 - open print ARG C greater than one close
581:00 - peren question mark single quote space
581:02 - single quote colon single quote back
581:05 - slash n single quote close PR semicolon
581:08 - Clos curly brace since arcv is a pointer
581:13 - to the beginning of an array of argument
581:15 - strings incrementing it by one plus plus
581:18 - RV makes it point to the at at the
581:21 - original array argv sub1 instead of arv
581:24 - Sub 0 each successive increment moves it
581:27 - along to the next argument star argv is
581:31 - then the pointer to that argument at the
581:33 - same time ARG C is decremented and when
581:36 - it becomes zero there are no arguments
581:38 - left to
581:40 - print another version the third version
581:43 - on page 111 of the
581:45 - textbook pound include stdi Doh pound
581:49 - include string.h m
581:51 - open pen Arc comma arv Clos pin int Arc
581:56 - semicolon Char star arv open square
582:00 - bracket closed square bracket semicolon
582:02 - open curly brace while open pin minus
582:05 - minus r c greater than zero close pen
582:09 - print F open pen open pen RC greater
582:12 - than one close pen question mark double
582:15 - quot percent s blank double quote colon
582:19 - double quot percent s back sln double
582:22 - quote comma star Plus+ argv Clos PR
582:27 - semicolon Clos curly brace this version
582:31 - so shows that the format argument of
582:33 - print F can be an expression just like
582:35 - any of the others this usage is not very
582:38 - frequent but worth
582:40 - remembering as a second example let's
582:43 - make some example uh enhancements to the
582:46 - pattern finding program from chapter 4
582:49 - if you recall we wired the search
582:50 - pattern deep into the programing and
582:52 - this is an obviously unsatisfactory
582:55 - arrangement for flexible code following
582:57 - the lead of the Unix utility GP which
583:01 - stands for the generalized regular
583:03 - expression parser let us change the
583:05 - program so that the pattern to be
583:06 - matched is specified by the first
583:08 - argument on the command
583:10 - line This is example one on page 112 of
583:13 - the book which you can see at
583:16 - www.cc.com
583:19 - code pounding clude
583:22 - stdio.h pound include string.h pound
583:25 - toine MAX Line
583:26 - 1000 Main open pren Arc comma arv Clos P
583:31 - int Arc semicolon charar arv open square
583:34 - bracket close square bracket semicolon
583:36 - open curly brace Char Line open open
583:40 - square bracket MAX Line closed square
583:42 - bracket
583:43 - semicolon if open PR Argy not equal to
583:47 - closed PR print F double quote usage
583:50 - colon find pattern back sln double quote
583:54 - Clos pin semicolon else while open pen
583:58 - get Line open pen line comma MAX Line
584:01 - Clos pen greater than zero Clos pen if
584:04 - index open pen line comma RV sub one
584:09 - Clos pen greater than or equal to zero
584:11 - Clos pen print F open p double quot
584:15 - percent s double quot comma line Clos PR
584:19 - semicolon close curly brace
584:22 - the basic model can now be elaborated to
584:25 - illustrate further pointer constructions
584:27 - suppose we want to allow two optional
584:29 - arguments one says print all the lines
584:32 - except those that match the pattern the
584:35 - second says preced each print each
584:37 - printed line with its line
584:40 - number a common convention for C
584:42 - programs is that an argument beginning
584:44 - with A minus sign introduces an optional
584:47 - flag or parameter if we choose minus X
584:51 - for except to Signal the inversion and
584:54 - minus n number to request line numbering
584:57 - then the command find Space - x space
585:00 - minus n the with the input now is the
585:04 - time for all good men to come to the aid
585:07 - of their party should
585:09 - produce two comma for all good
585:14 - men optional arguments should be
585:16 - permitted in any order and the rest of
585:18 - the program should be insensitive to the
585:20 - number of arguments which were actually
585:21 - present in particular the call to index
585:24 - should not refer to arv sub 2 where a
585:27 - single flag argument and to argv sub one
585:30 - when there was no single flag
585:32 - furthermore it's convenient for users if
585:35 - option arguments can be concatenated and
585:38 - as in find space- NX space
585:42 - thee here is the
585:45 - program and this program is on page 113
585:50 - of the textbook
585:51 - and it is complex enough that I suggest
585:53 - that you take a look at it at
585:57 - www.cc.com SLC
586:00 - code it's it's about 35 lines
586:05 - long the commentary on the program
586:07 - hopefully now you're watching looking at
586:09 - it argv is incremented before each
586:11 - optional argument and argc is
586:13 - decremented if there are no errors at
586:15 - the end of the loop argc should be one
586:18 - and star argv should point to the point
586:21 - to the pattern note that star ++ arv is
586:25 - a pointer to an argument string open pin
586:29 - star Plus+ arv Clos print open square
586:32 - bracket 0o square square bracket is its
586:35 - first character a parentheses are
586:37 - necessary for without them the
586:39 - expression would be star Plus+ open
586:42 - paren arv subz close print which is
586:46 - quite different and
586:48 - wrong an alternate valid form would be
586:51 - star star Plus+
586:55 - arv section 5.12 pointers to functions
586:59 - in C a function itself is not a variable
587:02 - but it is possible to define a pointer
587:03 - to a function which can be manipulated
587:06 - past to functions placed in arrays and
587:08 - so on we will illustrate this by
587:11 - modifying the Sorting procedure written
587:12 - earlier in this chapter so that if the
587:15 - optional argument minus n is given it
587:17 - will sort the input lines numerically
587:19 - instead of lexographic graphically a
587:22 - sort often consists of three parts a
587:25 - comparison which determines the ordering
587:27 - of any pair of objects an exchange which
587:30 - reverses their order and a sorting
587:32 - algorithm which which makes comparisons
587:34 - and exchanges until the objects are in
587:36 - order the Sorting algorithm is
587:38 - independent of the comparison and
587:40 - exchange operations so by passing
587:43 - different comparison and exchange
587:44 - functions to it we can arrange to sort
587:47 - by different criteria this approach is
587:49 - taken in our new sour
587:51 - the lexographic comparison of the two
587:53 - lines is done by stir comp and swapping
587:56 - by swap as before we'll also need a
587:58 - routine num comp which Compares two
588:01 - lines on the basis of numeric value and
588:03 - Returns the same kind of condition
588:04 - indication as stir comp does these three
588:07 - functions are declared in Main and
588:09 - pointers to them are passed to sort sort
588:12 - in turn calls the functions via pointers
588:15 - we have skimped on error processing
588:17 - processing for arguments so as to
588:18 - concentrate on the main issues
588:21 - this sample code is from page 115 of the
588:24 - textbook which you can view at
588:27 - www.cc
588:28 - for.com
588:31 - slode pound include
588:33 - stdio.h pound include string.h pound
588:36 - Define lines 100 Main open paren Arc
588:41 - comma arv Clos parent int argc semicolon
588:45 - Char star Ary open square bracket close
588:48 - square bracket sumon open curly brace
588:52 - jar Star Line PTR open Open
588:56 - Bracket lines close square bracket
588:59 - semicolon this is the pointers to the
589:01 - text lines so we're going to be reading
589:03 - in the lines saving them and keeping an
589:05 - array of the pointer and then we're
589:06 - going to sort that way int end lines of
589:09 - semicolon int stir comp open print Clos
589:13 - print comma num comp open print Clos
589:16 - print which are comparison
589:18 - functions int swap open print close
589:21 - print semicolon int numeric equals z and
589:24 - this is going to be one if it's a
589:26 - numeric
589:27 - sort first we par the
589:29 - arguments if open print AR C greater
589:32 - than one % % arv sub 1 Sub 0 equal equal
589:38 - quote minus quote and RV opens bracket
589:42 - one close bracket Open Bracket 1 close
589:45 - bracket double equal quote and quote
589:48 - close perin numeric equals 1
589:53 - if open pen open pren end lines equals
589:56 - read lines open pen line PTR comma lines
589:59 - Clos print Clos print greater than or
590:01 - equal to zero Clos print open curly
590:04 - brace if openr numeric Clos PR sort open
590:09 - pren Line PTR end lines num comp comma
590:12 - swap Clos PR semicolon else sort open
590:16 - print line PTR comma n lines comma stir
590:20 - comp comma swap Clos pen right Lines
590:23 - line PR PTR comma end lines Clos pen
590:27 - close curly brace else print F open PR
590:31 - double quote input too big to sort back
590:34 - slash
590:35 - N double quote Clos peren
590:38 - semicolon stir comp num comp and swap
590:42 - are addresses of functions since they're
590:44 - known to be functions the Ampersand
590:46 - operator is not necessary in the same
590:49 - way that it is not needed before an
590:51 - array name the compiler arranges for the
590:53 - address of the function to be passed the
590:56 - second step is to modify our sort
590:59 - function and this is the first example
591:01 - on page 116 of the
591:04 - textbook sort open pen V comma n comma
591:09 - comp comma ex C Exchange close pen Char
591:15 - star V open square bracket closed square
591:18 - square bracket semicolon
591:21 - that's our
591:22 - pointer array of pointers int and
591:28 - semicolon int open pren star comp close
591:32 - PR open pren close PR comma open pren
591:35 - Star Exchange Clos pen open pen Clos pen
591:38 - semicolon that declared the type and the
591:42 - fact that these are Pointers to
591:44 - functions it's a little more complex
591:46 - here in the called
591:48 - code open curly brace int Gap comma I
591:52 - comma J
591:53 - semicolon and now we're going to do the
591:56 - three nested for Loops for the uh quick
591:59 - sort no shell sort um and then the only
592:03 - really change is in the code checking to
592:06 - see if the uh two items pair of items
592:09 - are out of order and then what we do so
592:11 - for open print Gap equals n over 2
592:15 - semicolon Gap greater than zero
592:16 - semicolon gra Gap slash equals 2 close
592:20 - PR four open pren I equals Gap semicolon
592:24 - I less than n semicolon I ++ Clos pren
592:28 - four open PR Jal IUS Gap semicolon J
592:32 - greater than or equal to Z semicolon J
592:35 - minus equals Gap Clos PR open curly
592:38 - brace and now here starts the different
592:40 - code if open print open Print Star comp
592:45 - Clos print open print V subj comma V
592:49 - subj plus Gap
592:51 - Clos print less than or equal to zero
592:54 - Clos print
592:56 - break open Print Star ex exchange Clos
593:01 - print open print Amper V subj comma
593:06 - Amper V subj plus Gap Clos print
593:10 - semicolon close curly brace for the for
593:13 - Loop and then close curly braas for the
593:15 - sort
593:16 - function and so really all we're doing
593:19 - is we're checking the the order of the
593:21 - two items B subj and B subj plus Gap and
593:25 - if they're out of order IE less than or
593:27 - equal Zer I mean greater than or equal
593:30 - to U greater than zero then we just
593:32 - exchange them with the provided exchange
593:34 - function and so the key thing here is it
593:36 - looks exactly like the previous time we
593:37 - wrote this code except we're calling the
593:40 - pointer to the comparison function and
593:42 - the pointer to The Exchange function
593:45 - which is makes this flexible um so it
593:48 - can handle different kinds of data
593:52 - back to the
593:53 - textbook The Declaration should be
593:55 - studied with some care int open print
593:58 - start comp close print open print close
594:02 - print says that comp is a pointer to a
594:05 - function that returns an INT the first
594:08 - set of parentheses are necessary without
594:11 - them int star comp open print Clos print
594:15 - would say that comp is a function
594:16 - returning a pointer to an INT which is a
594:18 - quite different thing
594:21 - the use of comp in the line if open PR
594:24 - open print start comp Clos print open
594:26 - print V subj comma V subj plus Gap close
594:31 - print less than or equal to zero Clos PR
594:34 - is consistent with a
594:36 - declaration comp is a pointer to the
594:38 - function and star comp is the function
594:41 - and open Print Star comp Clos print open
594:45 - print V subj comma V subj plus Gap close
594:50 - print is the call to it the parentheses
594:52 - are needed so the components are
594:55 - correctly
594:56 - Associated we've only we've already
594:58 - shown stir comp which Compares two
595:00 - strings here is num comp which Compares
595:03 - two strings on a leading numeric value
595:06 - this is sample code from page 117 of the
595:09 - textbook which you can see at
595:13 - www.cc.com
595:16 - code numc open print S1 com S2 Clos
595:21 - print Char star S1 comma star S2
595:24 - semicolon open curly brace double A to F
595:28 - open print Clos print comma V1 comma
595:31 - V2 V1 equal a to F open print S1 Clos
595:35 - print semicolon V2 equal a to F open
595:39 - print S2 Clos print semicolon if open
595:44 - print V1 less than V2 Clos print return
595:47 - open print minus one else if open PR V1
595:51 - greater than V2 Clos pin return open p
595:55 - one closed pen semicolon else return
595:58 - open
595:59 - pin zero Clos pin semicolon Clos curly
596:04 - brace the final step is to add the
596:07 - function swap which exchanges the two
596:09 - pointers this is adapted directly from
596:12 - what we presented earlier in the chapter
596:15 - swap open print PX comma py Clos print
596:19 - Char star p PX open square bracket close
596:22 - square bracket comma star py open square
596:25 - bracket close square bracket semicolon
596:27 - open curly brace Char star temp
596:30 - semicolon temp equals star PX semicolon
596:34 - star PX equal star py semicolon star py
596:38 - equals temp semicolon close curly
596:41 - brace there are a variety of other
596:43 - options that can be added to the Sorting
596:45 - program some make challenging exercises
596:49 - [Music]
596:51 - this work is based on the 1978 C
596:54 - programming book written by Brian W
596:56 - kernigan and Dennis M Richie their book
596:59 - is copyright All Rights Reserved by AT&T
597:02 - but is used in this work under fair use
597:05 - because of the book's historical and
597:07 - scholarly significance its lack of
597:09 - availability and the lack of an
597:11 - accessible version of the book the book
597:13 - is augmented in places to help
597:15 - understand Its Right Place in a
597:16 - historical context amidst the major
597:18 - changes of the 19 7s and 1980s as
597:22 - computer science evolved from a hardware
597:24 - first vendor centered approach to a
597:26 - software centered approach where
597:28 - portable operating systems and
597:29 - applications written in C could run on
597:32 - any
597:33 - hardware this is not the ideal book to
597:35 - learn C programming because the 1978
597:38 - Edition does not reflect the modern sea
597:40 - language using an obsolete book gives us
597:43 - an opportunity to take students back in
597:45 - time and understand how the SE language
597:47 - was evolving as it laid the groundwork
597:50 - for a future with portable
597:55 - [Music]
598:08 - applications so hello welcome to chapter
598:10 - 6 in this chapter we talk about
598:12 - structures but so much
598:17 - more there is a mid chapter surpris in
598:20 - this book and I'm sure that it's so
598:23 - surprising that it's caused a few too
598:26 - many people to drop out a a computer
598:29 - science first computer science course
598:32 - and that's because in section 6.1
598:36 - through
598:36 - 6.4 we're learning the C
598:39 - language and we're learning just what a
598:42 - structure is it's a simple beautiful
598:45 - elegant concept it's a sort of a wrapper
598:47 - for a whole bunch of types it groups
598:49 - them together so that you can create a
598:50 - new type and it really at this point is
598:53 - the last foundational component of the
598:55 - cor C languages cor C
598:58 - language and then in section
599:03 - 6.5 they the authors pivot to talking
599:07 - about data structures and that is the
599:10 - applications of C
599:12 - structures and it's the foundational
599:15 - notion in computer science it's the kind
599:17 - of thing where how do you build a python
599:19 - dictionary and
599:20 - C um and and so this this is a a pattern
599:25 - we call the knee of the curve where
599:27 - things are going along just fine up to
599:29 - 6.4 like oh here's a for Loop and here's
599:33 - a string and here's an array and here's
599:36 - even a pointer that that's not that hard
599:38 - and structures are not that hard but
599:40 - then when we start talking about
599:42 - applications of
599:44 - structures what we call data structures
599:46 - and structures was named because data
599:48 - structures was a concept but how we use
599:51 - structures is a quite a Next Level thing
599:54 - we're kind of leveling
599:56 - up so I want you starting from here
600:00 - chapter six is the last real chapter
600:02 - that I'm going to cover but it is
600:05 - expanding because chapter 6 is the
600:07 - beginning of a
600:09 - whole additional course a course on data
600:12 - structures so I want you if you're
600:15 - rushing I want you to slow down I want
600:18 - you to take your time and understand
600:22 - because if you understand this you can
600:25 - literally you have a doorway into a lot
600:28 - of computer science we'll talk about
600:30 - recursion even by the end and so just
600:34 - don't
600:35 - rush work on Mastery these are complex
600:38 - Concepts they are not natural to
600:42 - understand and
600:44 - so before we start I want to do
600:47 - something different I want to read you a
600:50 - poem one of my favorite poems from
600:52 - Robert
600:53 - Frost uh I was lucky enough fortunate
600:57 - enough to be a good friend of Bob Frost
600:59 - who was a grandson of Robert Frost Bob
601:02 - Frost had a connection to the University
601:04 - of Michigan Robert Frost has a Michigan
601:07 - and University of Michigan uh connection
601:10 - and um I loved this poem that I'm about
601:13 - to read you uh long before I met Bob
601:17 - Frost the grandson of Robert Frost
601:21 - so the poem that
601:24 - I talk a lot
601:26 - about and really it's one
601:29 - line miles to go before I
601:32 - sleep this is the poem called stopping
601:34 - by the Woods on a Snowy Evening and to
601:37 - me it it speaks of the notion that
601:41 - Journeys are not short nor
601:45 - easy and it's okay accept that so here
601:49 - we go
601:50 - Dr Chuck in
601:54 - poetry whose woods these are I think I
601:57 - know his house is in the village though
602:00 - he will not see me stopping here to
602:02 - watch his Woods fill up with snow my
602:05 - little horse must think it queer to stop
602:08 - without a farmhouse near between the
602:10 - woods and frozen lake the darkest
602:13 - evening of the
602:15 - year he gives his harness bells a shake
602:18 - to ask if there is is some
602:20 - mistake the only other sounds The Sweep
602:23 - of easy wind and dowy Flake the woods
602:27 - are lovely dark and deep but I have
602:31 - promises to
602:33 - keep and miles to go before I
602:37 - sleep and miles to go before I
602:41 - sleep so the essence of this is that you
602:46 - have come a long
602:48 - way to get to 6.4 in this book and it
602:54 - may feel like you've gone long enough
602:57 - and you should just pat yourself on the
603:00 - back but after 6.4 there are miles to go
603:04 - before I sleep but the good news is when
603:07 - you're done you can relax so what I want
603:10 - you to do is take your time things get
603:14 - much more complex really fast going
603:16 - forward and I don't want to lose
603:20 - [Music]
603:30 - you structures structures is the mo one
603:36 - of the most beautiful parts of SE like
603:39 - pointers it's a userdefined type that
603:42 - contains sort of one or more types
603:44 - within it we call things like X and Y in
603:47 - this case uh members of the structure X
603:51 - is a member of the struct point and Y is
603:53 - a member of the struct point the dot
603:55 - operator allows us to take a variable
603:57 - that is a structure variable that has
603:59 - all these members within it and then
604:01 - access the members of the structure so
604:04 - an example kr601 doc we have struct
604:08 - Point open curly brace double X
604:10 - semicolon Double Y semicolon closed
604:13 - curly brace semicolon and this defines a
604:15 - new type it doesn't allocate any data
604:18 - and then we say Point P1 comma P2
604:21 - semicolon and that actually allocates
604:23 - two
604:25 - points which is four doubles named P1
604:29 - and and two of each point is P1 and P2
604:32 - then I say
604:33 - p1.x equal 3.0 and I say p1y = 4.0 and
604:38 - then I say P2 = P1 which copies all the
604:41 - fields into the corresponding locations
604:44 - in P2 and then I print them out and I
604:47 - get three and four and so that's BAS
604:49 - basic
604:50 - structures simple clean elegant
604:54 - understand every line of this memorize
604:56 - it when you do a in a sense call by
604:59 - value with a structure the entire
605:02 - structure is placed on the stack and so
605:05 - you don't want to make structures too
605:06 - gigantically big you know if they're
605:08 - like 10 to 40 bytes of characters
605:10 - they're not all that bad but when we
605:12 - make struct Point pm and set X and Y to
605:16 - three and four and then we call Funk
605:18 - with funk open print PM Clos print PM is
605:23 - a structure that is in the scope of the
605:25 - main program and then we're calling Funk
605:27 - and passing it in and then we're
605:29 - accepting it as a structure inside of
605:31 - funk and the key thing there is at this
605:34 - point it's a sort of copy call by value
605:36 - where the entire structure is allocated
605:39 - on the stack and then passed into Funk
605:41 - so if we change it inside Funk PF dox =
605:44 - 9.0 and pfy = 8.0 it changes locally and
605:49 - can print it out and then when it
605:51 - Returns the PM that's in the main
605:53 - program is unchanged and that's because
605:56 - the entire structure PM is duplicated
606:00 - into the stack frame for function Funk
606:02 - operating inside function Funk we're
606:04 - only messing with the copy that's in our
606:05 - stack frame and then when we sort of
606:08 - undo that it restores PM back to the way
606:11 - it was so those are just plain
606:13 - structures but pointers to structures
606:15 - are where we get a lot more powerful so
606:18 - here we have another same struct with a
606:20 - double X and A Double Y and now we say
606:23 - struct Point PT which is a regular old
606:26 - variable and Then star PP which is a
606:29 - pointer to a structure an address of a
606:32 - structure and you can take the address
606:34 - of a structure just like you can take
606:36 - the address of an integer a structure is
606:37 - a very fundamental type so PP equals
606:41 - Ampersand PT copies the address of the
606:44 - actual structure PT into the variable PP
606:47 - PT dox equal 3.0 0 or open Print Star PP
606:52 - Clos print doy equals 4.0 so if we have
606:57 - a pointer to a structure we have to use
606:59 - the asteris to sort of look up the
607:01 - actual structure and then we can do
607:03 - structure things with it like set the
607:04 - doy value there's a shortcut take an
607:07 - address dreference it with the asterisk
607:10 - and then use the dot they're combined
607:12 - into kind of what we call the arrow
607:14 - operator which is
607:16 - pp-h greater than Y which is the same as
607:20 - open paren star PP Clos par n.x and so
607:23 - this we call it the arrow operator and
607:25 - so it's kind of a shorthand and it's
607:28 - used all the time and you'll see when we
607:30 - look later at things like PHP they
607:32 - adopted this Arrow operator most other
607:34 - object oriented languages tend to use
607:37 - the dot operator but others use the
607:39 - arrow
607:41 - operator so if we're going to pass a
607:45 - structure by reference you use the Amper
607:48 - sand in the call and the asterisk inside
607:51 - the function so we create stru Point PM
607:54 - set X and Y within that to three and
607:56 - four respectively then we print it out
607:59 - and then we call Funk but now we call it
608:01 - with Ampersand PM which says pass in the
608:04 - address of
608:05 - PM and then in the function we take in
608:08 - PP and we declare its type as struct
608:11 - point star PP which means we are getting
608:14 - as a parameter an address not the value
608:18 - and then we use the arrow op operator PP
608:20 - Arrow X = 9 PP Arrow yal 8 we print that
608:24 - in the function but because PP just
608:27 - points to PM it's also changed in the
608:30 - copy that's in the main so PM is being
608:32 - changed at the moment that PP is being
608:35 - changed and so when it comes back you
608:37 - see that the value is 9 and 8 in outside
608:41 - of the function so this is simply
608:43 - passing by reference it almost be better
608:46 - call it pass by address so if you take a
608:48 - look at the stack frame what you see is
608:51 - when we're calling Funk open pren
608:53 - Ampersand PM Clos pren we are making a
608:57 - copy of the address and putting that
609:00 - into the stack frame and then passing
609:02 - that stack frame into Funk and so now
609:05 - Funk has an address of something it
609:07 - happens to not be in its domain meaning
609:10 - that PM is still in main but we can work
609:13 - with the arrow operator and actually
609:15 - make changes in the underlying object
609:18 - and so the key there is that you could
609:20 - change PP but PP Arrow X you're actually
609:23 - changing the single copy that is in pm
609:26 - at that point storage allocation now
609:29 - pretty soon we're going to be
609:30 - dynamically allocating things we've
609:32 - always said that oh you create a Char
609:34 - array of char with Open Bracket 10
609:37 - there's 10 things in that what if we
609:39 - want more and we've said you can't
609:41 - reallocate this stuff but now we have
609:44 - this thing we're going to start
609:45 - allocating so it turns out when you're
609:47 - allocating things you have to know how
609:48 - big they are
609:50 - okay and so there's this size of
609:52 - operator so size of so if we take struct
609:55 - Point PT and star PP which means we have
609:57 - a a structure with two doubles in it and
610:01 - then a pointer to a structure with two
610:02 - doubles of it and we simply say what is
610:04 - the size of the structure and it's 16
610:07 - because each double is eight and then
610:09 - what is the size of a pointer to a
610:12 - structure and that is eight because
610:14 - eight is how big addresses are the fact
610:16 - that doubles and addresses happen to
610:18 - both be the same thing is not relevant
610:20 - here addresses are on most C systems
610:23 - eight
610:25 - characters you can also because it's an
610:27 - operator not just give it a variable but
610:29 - also give it a type so we can say size
610:31 - of open per N struct Point close per n
610:34 - and that also will be 16 because the
610:36 - size of a struct if we were going to
610:39 - allocate it is 16 characters so size of
610:42 - returns the size of something in
610:46 - characters and so we have this function
610:48 - called Mal
610:49 - and Malik you have to include stdlib.h
610:52 - to do it and so now what we're going to
610:54 - do is create a the structure Point again
610:57 - and we're going to create a pointer
610:58 - we're going to not actually allocate it
611:00 - so that struct point star PP allocates
611:03 - an8 character address not the actual
611:06 - double two doubles now what we do is we
611:09 - say PP equals first and we're casting
611:12 - this we're casting The Returned address
611:14 - from Malik pen struct point star pen
611:18 - Clos pren and that is casting it to a
611:22 - pointer to a struct a pointer to a point
611:25 - and then we say Malo open friend size of
611:27 - struct Point Clos print Clos print and
611:30 - so that says Malik 16 because a struct
611:33 - point is 16 characters so Malik goes and
611:35 - finds some free memory for us in its
611:37 - pool of free memory and gives us back an
611:40 - address which we then convert to a
611:42 - pointer to a
611:44 - point and then we store that in PP and
611:47 - at that point we have data we have a a
611:50 - working structure and we can set the x
611:52 - and the Y value just as the normal way
611:54 - whether we use the arrow operator or the
611:57 - star and Dot operators we can access
612:00 - that
612:01 - information the next thing we're going
612:03 - to talk about is combining all these
612:06 - things dynamic memory and structures to
612:08 - create
612:10 - lists and this is a simple Python
612:14 - program lines equals list Hand equals
612:16 - open open pren romeo. txt
612:19 - then Loop through and then append each
612:21 - line after stripping the new lines and
612:24 - then printing them out so lines is a
612:27 - list object now underneath it there is a
612:30 - data structure which by the end of this
612:32 - course you're going to get to know
612:34 - really well but this will print out the
612:37 - four lines from romeo. txt and this is
612:41 - kr67
612:43 - py now we're going to build this list
612:47 - structure and then we can store some
612:49 - data in it the entries of the list are
612:52 - going to be stored in dynamically
612:53 - allocated memory and each list contains
612:56 - some data and then links to other
612:58 - members and so we're going to create a
613:00 - thing called struct L node open PR Char
613:04 - star text which is a pointer to a list
613:07 - an array of characters of of unknown
613:09 - length struct L node star next semicolon
613:13 - colos curly brace semicon and so if you
613:15 - construct a real live uh link list you
613:19 - need also to have two variables struct L
613:22 - node star head and struct L node star
613:24 - tail and if we end up with a link list
613:26 - of three things head points to the first
613:29 - item in the list and then within that
613:31 - there is the text the text points to
613:34 - some string in this case it's the letter
613:36 - c and then the next is an address of the
613:38 - second thing in the list in that second
613:40 - thing text points to is and next points
613:43 - to the third thing in the list and then
613:46 - next in the third thing in the list
613:47 - points to a value called null which is
613:49 - our indication that it's an address to
613:51 - Nowhere null and zero are pretty much
613:54 - the same thing all addresses are nonzero
613:56 - so we look for an address of zero and
613:58 - that tells us that we've got to the end
614:00 - and then in order to append to this list
614:03 - we have another value which is a pointer
614:05 - called tail which points to the last
614:08 - element in the list when we start the
614:09 - list head and tail both point to null
614:13 - and so ultimately what we've done is
614:14 - we've created a dynamically allocable
614:17 - structure where we can put put sort of
614:19 - any number of lines in it and so it's
614:22 - kind of like a python list so the first
614:24 - line of this the while statement reads a
614:28 - value into line a string value into line
614:30 - the next line from the file right and so
614:33 - we have a pointer to a character that we
614:35 - pre-allocated Above This and That points
614:38 - to the variable fun uh three characters
614:43 - plus an end of string and then the next
614:46 - thing we're going to do is allocate a
614:48 - new string that is the same length plus
614:51 - one so we're going to allocate four
614:53 - characters using Malik sterland line
614:56 - plus one which is going to give us four
614:59 - then we're going to get that address
615:00 - back and we're going to cast that to a
615:02 - Char star and then we are going to
615:05 - assign that to save so that's the the
615:08 - place we're going to save this new
615:11 - item the next thing we're going to do is
615:14 - allocate a brand new L node a brand new
615:17 - node in our list and we're going to
615:19 - maloc size of struct L node and then
615:22 - we're going to cast it to a struct l
615:24 - node star and then we're going to assign
615:26 - that into a struct l node star variable
615:28 - named new we we saved our string and
615:31 - we've got a pointer to that save string
615:33 - and a pointer to a empty at this point
615:36 - uh L node then what we do is we connect
615:41 - with um if tail is not equal to null
615:45 - tail next equals new so we take the now
615:49 - the about to be second to last item and
615:51 - we connect it to the last
615:53 - item and then what we do is we take the
615:56 - text pointer inside of our newly
615:59 - allocated list node and point it at the
616:02 - saved copy of our string in dynamic
616:05 - memory and then we point the next to be
616:07 - null and then we simply Advance tail so
616:11 - that next time we do this tail is
616:13 - pointing to the new end of the
616:15 - string now we've got one more thing that
616:18 - we've got to do and that is if head is
616:20 - null we have to set head to new this is
616:23 - only that's only going to happen on the
616:24 - very first one and so at this point our
616:27 - list has three entries it went from two
616:29 - entries to three entries and so we can
616:31 - go back up and read the next line and
616:33 - this sequence of statements will figure
616:36 - it out so I would just say take your
616:39 - time on this one thing that we learn
616:41 - when we're working on linked data
616:43 - structures inside of C is you got to
616:45 - draw a picture I I literally can't do
616:48 - this for from memory I just draw the
616:50 - picture and then it's really easy to do
616:53 - so sometimes you want to walk through a
616:55 - link list so we tend to call this we
616:58 - make a variable called Cur current which
617:01 - is a struct l node star a pointer to an
617:03 - L node and so this is the same as
617:06 - looping through a python list We Set
617:09 - current to head because that's where
617:11 - we're going to start going through the
617:12 - list and then we print out current text
617:16 - which prints the print C out and then we
617:19 - go to the bottom of the loop and then we
617:21 - advance current to current next it's
617:24 - kind of like adding plus one but we just
617:26 - went from the first item in the list to
617:28 - the second item in the list and then we
617:31 - do it again and we are printing out the
617:34 - third item of the list and then we
617:37 - current equals current next gets to null
617:40 - and so then the list is over and we have
617:41 - printed all of them out so in addition
617:45 - to creating link lists we're going to do
617:46 - many different things with link lists
617:49 - we're going to delete things we're going
617:50 - to sort things we're going to find
617:51 - things we're going to look things up
617:53 - we're going to change things so one of
617:56 - the things that will save you a lot of
617:59 - craziness when working with link lists
618:01 - is always draw pictures and arrows it's
618:05 - just it's just necessary and frankly
618:07 - those programming exams all they ever
618:09 - tell you is to draw these pictures
618:11 - sometimes draw a picture of a hashmap as
618:13 - as a good example so I'm just going to
618:16 - show you some pictures rather than
618:17 - showing you a bunch of code and then I
618:19 - think you can produce the code um uh
618:23 - later so I want to show you how you
618:26 - delete an item from a singly linked list
618:28 - so first you got to find it you got to
618:30 - do the walking of the link list which I
618:32 - just showed you you got to walk through
618:35 - and you got to find the item that you
618:37 - want to delete now if you walk through
618:39 - and you don't find it there's nothing to
618:40 - delete so our goal is is to delete the
618:43 - line is is and so but you got to handle
618:47 - three cases there's the easy one which
618:50 - is where the thing you found is in the
618:51 - middle of the list or if the thing that
618:54 - you found is at the start of the list or
618:56 - if the thing you found is the last item
618:58 - in the list and again you got to draw
619:00 - pictures and you may have to draw them
619:02 - separately because we we're going to be
619:04 - adjusting head and tail in addition to
619:07 - the next values now it turns out when
619:10 - you're going to do a delete you want to
619:12 - not only track the current item in the
619:15 - list you want to track the previous item
619:17 - in the list so as you're walking down
619:19 - the list you look you current moves
619:21 - ahead and preve moves right behind it so
619:24 - preve Trails current by one item you can
619:28 - see that current the the is line is the
619:31 - one we're going to delete and it's
619:33 - pretty simple the only real thing that
619:36 - you've got to change is you take PR next
619:39 - and you point it at ker next right so
619:42 - you can see on the right hand side that
619:44 - the the little link from the C to the
619:47 - fun has just B P the is now you do have
619:51 - to deallocate the struct L node and the
619:54 - string but that's pretty much all you
619:56 - need to do and so the middle is really
619:58 - easy you find it you keep track of
620:00 - prieve you have current and then you
620:03 - just kind of bypass it by moving next so
620:06 - that's the easy one the next thing that
620:08 - you got to do is what if it's the first
620:10 - node and in this case prieve will point
620:13 - at null because we have not really seen
620:15 - more than one PR only goes non-null when
620:17 - we've passed the first one so current is
620:20 - pointing itead let's say we want to
620:21 - delete the line that says C and so we
620:24 - notice that preve is null and so what we
620:26 - do is we actually just move the head to
620:30 - Kern next right you can see in the on
620:33 - the right hand the head just points now
620:35 - the head has now bypassed that first
620:37 - line and that's all we've got to do
620:39 - except clean up the memory of the first
620:43 - entry uh both the string and the struct
620:46 - L node so that's pretty easy you detect
620:48 - by noticing that preve is null because
620:50 - you you're catching it in the first time
620:52 - through the loop and preve trails
620:54 - current by one and if you have not seen
620:56 - the second one preve is still null so
620:59 - that's a pretty easy one but you got to
621:01 - check it you got to check all so this
621:02 - one is if preve is null you're sitting
621:06 - at the front so you mess with head and
621:09 - that's all you've got to do other than
621:11 - get rid of the data and free it up the
621:13 - last note is perhaps a little bit
621:16 - trickier and so at if you look and how
621:19 - you know you're on the last node is C
621:21 - next is null right because if you're
621:24 - pointing at the very last node in the
621:25 - list then the next is null so if C next
621:29 - is null then what you're doing is you
621:32 - know you're deleting the last one and so
621:36 - you first set PR next to be null because
621:40 - that's the new last one and then you
621:42 - have to update tail to point to preve so
621:45 - tail was pointing at cerr at the current
621:47 - and then tail at the end points to
621:49 - proeve and then you got to clean up your
621:50 - data of that formerly last item in the
621:55 - list so now we're going to talk about
621:57 - doubly link lists and the main purpose
622:00 - to have doubly link lists is to be able
622:02 - to reverse a list python is easy there's
622:05 - a method in the list object called
622:08 - reverse what we're about to see is
622:11 - exactly how reverse works so you just
622:14 - read the lines in and you say lines.
622:16 - reverse and then you print them out and
622:17 - they come out and backwards order now
622:20 - somebody probably G van rossom who wrote
622:23 - this in the first place in
622:25 - 1991 he is writing a doubly link list to
622:29 - make reverse easy so if you remember how
622:31 - we did the um deleting where we kept
622:33 - track of prieve well in a doubly link
622:36 - list we actually just have preve in the
622:39 - L node and so in addition to the text
622:41 - we're going to store we're going to have
622:43 - a pre pointer and a next pointer and um
622:47 - at the beginning of the list the pre
622:48 - will be null and at the end of the list
622:51 - next will be null it's called a doubly
622:53 - link list because it has both reverse
622:56 - and forward chains of pointers and we
622:58 - keep them working all the time so it
623:00 - turns out that making a doubly link list
623:02 - in terms of code is not that different
623:05 - we have another thing in the L node we
623:07 - now have three things Str struct L node
623:10 - star preve and as we're linking a new
623:13 - thing onto the end of the
623:14 - list we basically take new preve the new
623:18 - new item we're adding and we copy tail
623:20 - into that because tail points to the
623:23 - last one we're adding a new one to the
623:25 - last one and the previous one is tail
623:28 - and then we do that before we set tail
623:30 - to new so we add a new one and then we
623:33 - set tail to new so it's not that hard so
623:36 - this is an example of the three item
623:38 - list with all of the previous and nexts
623:41 - properly uh properly shown and so you it
623:44 - it just links together once you draw
623:45 - these things in a picture and you get
623:46 - the understanding of what they're
623:48 - talking about they're not too hard and
623:50 - section 6.5.1 in the book which I added
623:53 - actually um walks through this W link
623:56 - list in some details so I won't
623:57 - replicate that here now let's just say
624:00 - that you have a doubly link list and you
624:03 - want to now reverse it well it's pretty
624:06 - simple you set current to tail same as
624:10 - long as current stays n not null and
624:12 - then say current equals current prieve
624:14 - so you're you're sort of popping back up
624:16 - one at a time so the second time through
624:19 - the loop current has followed the preve
624:21 - from the last item and now it's on the
624:23 - second to last item and then it does it
624:25 - again and then it goes to the top and
624:27 - then the last time it goes up to the
624:29 - preve of the top one and finds null and
624:32 - then the uh loop finishes because
624:35 - current has become null and you printed
624:37 - out the three lines cool is C backwards
624:41 - so this is just an example in
624:43 - k69 Doc and I won't walk through it in
624:46 - this lecture I'll let you take a look at
624:48 - that that um it's quite common to encode
624:51 - all this stuff in uh some functions
624:54 - rather than just in straight line code
624:56 - it's not all that hard you don't want to
624:58 - pass in uh the the list structure and
625:02 - the line um a list is passed in by
625:05 - reference and so you have to say
625:07 - Ampersand my list on this list add
625:09 - function and inside the function you do
625:13 - uh you have the list be a pointer to
625:16 - that structure and then you have to use
625:18 - the arrow syntax inside of the function
625:21 - the next thing I want to talk about is
625:22 - unions a union is like a structure but
625:24 - it it reallocates the same memory over
625:27 - and over whereas a structure allocates
625:29 - more memory this says I'm going to take
625:31 - this same piece of memory and I'm going
625:33 - to view it different ways and so it's
625:36 - the same area and you can assign
625:37 - multiple types to it this this is useful
625:41 - in like Network protocols and pulling
625:45 - bits out of uh memory Etc and so in my
625:49 - current sample I've got my union sample
625:51 - open curly brace in I semicolon Char CA
625:56 - bracket 4 bracket semicolon float F
625:59 - semicolon Clos curly brace semicolon
626:02 - what I have done here is allocated in a
626:04 - sense four bytes integers in this case
626:07 - are 32 bits ca4 is four bytes which is 4
626:11 - * 8 is 32 and floats are 32-bit floating
626:15 - Point numbers so that's the same amount
626:17 - of memor so instead of being 4 * 3 or 12
626:20 - bytes this is actually Four bytes that I
626:23 - can see it I can I can view it either as
626:26 - an integer or as a character array of
626:29 - four characters or float and I've
626:30 - carefully lined them up so that they're
626:32 - the same width allocate Union sample U
626:36 - and then I set the integer version of
626:38 - that that 4 bytes to 42 and then I print
626:41 - it out and you can see the hex floating
626:45 - Point that's a complete failure is 0. z
626:47 - is like it's not a very good big
626:49 - floating Point number and then the as a
626:52 - character string it is an asterisk and
626:56 - then I take view.ca which is viewing
627:00 - that same area of memory as a character
627:03 - array and I copy quote capital a BC into
627:07 - it and you'll see that it prints out as
627:09 - a string as ABC the floating Point
627:11 - number is still zeros it's still kind of
627:13 - a bad floating Point number um but then
627:16 - I see the hex as 00 63
627:20 - 6241 now this is a little Indian
627:23 - computer that I'm running on it so the a
627:25 - is the 41 the B is the 62 and the C is
627:29 - the 63 and the zero is the end of string
627:33 - indicator and so that's why I picked
627:35 - very carefully only copying a three
627:38 - character string into a four character
627:41 - array so I could copy that end of end of
627:45 - string indicator then I take u.f which
627:48 - is taking that exact same memory and
627:50 - perceiving it as a floating point and I
627:52 - put 1/3 into it so now when I print that
627:55 - out it's
627:57 - 0.33 lovely when I print it out as a
628:00 - string it is pretty bad and so it turns
628:03 - out that uh the first three characters
628:06 - are the string but there's no zero at
628:09 - the end of the string so that greater
628:10 - than is there and it just keeps on going
628:13 - it goes into memory and it's it you know
628:16 - that all that stuff that's greater than
628:18 - at sign question mark HK that's just
628:21 - random garbage on the stack somewhere
628:23 - that because the percent s is wandering
628:26 - randomly through memory at this point
628:29 - and then if I print that out as hex and
628:31 - if if we wanted to we could learn
628:32 - something about the I floating Point
628:34 - format but 3E AA aaab is 1/3 and that is
628:41 - a base two repeating 1/3 with a exponent
628:44 - and uh floating Point Internal formats
628:46 - are not the sub object for this course
628:49 - I've accomplished everything I wanted
628:51 - you to know about C so the next topic is
628:54 - going to be object Orient programming
628:57 - but not just how to use object-oriented
628:58 - programming in python or whatever C
629:02 - doesn't have it what I want to do is
629:04 - look at if we were writing python itself
629:08 - in C which is what C python
629:11 - is how would we have to build things
629:14 - like a list structure a a list object a
629:18 - string object and a dictionary object
629:20 - how would we build them and we'll take a
629:22 - look at other programming languages that
629:24 - have objectoriented features like C++
629:27 - and Java and Etc and so really the next
629:31 - bit is going to be about the
629:33 - implementation details for
629:35 - objectoriented programming
629:43 - [Music]
629:49 - welcome to C programming for everybody
629:51 - my name is Charles sance and this is my
629:54 - reading of the 1978 C programming book
629:56 - written by Brian kernigan and Dennis
629:58 - Richie at times I add my own
630:00 - interpretation of the material from a
630:02 - historical
630:04 - perspective chapter six structures a
630:07 - structure is a collection of one or more
630:09 - variables possibly of different types
630:11 - grouped together under a single name for
630:13 - convenient handling while we talk about
630:16 - data structures and how to use them in
630:17 - every language this section is about
630:20 - understanding how software developers
630:22 - carefully control the low-level shape of
630:24 - their data items to solve their problems
630:26 - when you first learn about the C struct
630:28 - keyword you might think it's equivalent
630:30 - to a python dict a dynamic key Value
630:33 - Store like a PHP array Java my apppp or
630:36 - JavaScript object but nothing is further
630:38 - from the truth these other languages
630:40 - provide us with easy to usee data
630:42 - structures where all the challenging
630:44 - problems are solved this chapter tells
630:47 - or for told the creators of python PHP
630:51 - Java and JavaScript how to solve the
630:53 - complex problems and build convenient
630:55 - and flexible data structures which we
630:57 - now all use in those objectoriented
631:00 - languages one way to look at this code
631:02 - in the chapter is to think of it as a
631:04 - lesson on how one might build Python's
631:07 - list and dict data structures if the
631:10 - code in the chapter takes you a little
631:12 - while to figure out mentally make a note
631:15 - of thanks for all the hard work that mod
631:18 - languages invest to make their highlevel
631:21 - data structures flexible and easy to use
631:24 - back to the textbook the traditional
631:27 - example of a structure is a payroll
631:29 - record an employee is described as a set
631:32 - of attributes such as name address
631:34 - social security number salary Etc some
631:36 - of these in turn could be structures a
631:38 - name has several components as does an
631:40 - address and even a
631:42 - salary structures help organize
631:44 - complicated data particularly in large
631:47 - programs because in many situations they
631:49 - permit a group of related variables to
631:51 - be treated as a unit instead of separate
631:54 - entities in this chapter we'll try to
631:56 - illustrate how structures are used the
631:58 - programs that we will use are bigger
632:00 - than many others in the book but are
632:02 - still of modest size section 6.1 Basics
632:06 - let us revisit the date conversion
632:08 - routines of chapter 5 a date consists of
632:11 - several parts such as the day month and
632:13 - year and perhaps the day of the year and
632:15 - the month name these five variables can
632:18 - all be placed in a single structure like
632:20 - this struct date open curly brace in day
632:25 - semicolon int month semicolon in in year
632:29 - semicolon int Year Day semicolon Char M
632:33 - name open square bracket 4 closed square
632:36 - bracket semicolon curly brace
632:39 - semicolon the keyword struct introduces
632:42 - a structure decoration which is a list
632:44 - of
632:44 - decorations enclosed in braces an option
632:47 - name called the structure tag may follow
632:50 - the word struct as with date here the
632:52 - tag names this kind of a structure and
632:55 - can subsequently be used as shorthand
632:57 - for the detailed
632:59 - declaration the elements or variables
633:01 - mentioned in a structure are called its
633:03 - members a structure member or tag and
633:06 - ordinary I.E non-member variable can
633:09 - have the same name without conflict
633:11 - since they are always distinguished by
633:14 - context of course as a matter of style
633:16 - one would normally use the same names
633:18 - only for closely related
633:21 - objects the right brace that terminates
633:23 - the list of members may be followed by a
633:25 - list of variables just as for any basic
633:27 - type that is struct open curly brace dot
633:31 - dot dot closed curly brace X comma y
633:35 - comma Z semicon is syntactically
633:38 - analogous to int X comma y comma Z
633:41 - semicon in the sense that each statement
633:44 - declares X Y and Z to be variables of
633:46 - the named type and causes space to be
633:49 - allocated for them a structured
633:52 - declaration that is not followed by a
633:53 - list of variables allocates no storage
633:56 - it merely describes a template or the
633:58 - shape of the structure if the
634:00 - Declaration is tagged however the tag
634:02 - can be used in later definitions of the
634:04 - actual instances of the structure for
634:07 - example given the Declaration of date
634:10 - above struct date D defines a variable D
634:14 - which is a structure of type date and
634:17 - external or static structure can be
634:19 - initialized by the following by
634:20 - following its definition with a list of
634:22 - initializers for the
634:24 - components struct date D equals open
634:28 - curly brace 14 comma 7 comma 1776 comma
634:33 - 186 comma Double quot jul L double quot
634:36 - Clos curly brace
634:38 - semicolon a member of a particular
634:41 - structure is referred to in an
634:43 - expression by construction of the form
634:46 - structure name do member the structure
634:49 - member operator dot connects the
634:51 - structure name and the member name to
634:53 - set leap from the date in structure D
634:56 - for example leap equals
634:59 - D.E modulo 4 equal 0 and D.E modulo 100
635:06 - not equal to zero or D.E modulo 400
635:10 - equal 0 semicolon or to check the month
635:14 - name if open PR stir comp open PR d.m
635:19 - name comma double qu Aug double quote
635:22 - close pren equals 0 close PR dot dot dot
635:27 - or to convert the first character of the
635:29 - month name to lowercase d.m name subz
635:34 - equals lower open pin d.m name Subzero
635:38 - closed pen
635:40 - semicolon structures may be nested a
635:43 - payroll record might actually look like
635:45 - struct person open curly bra Char name
635:49 - open square bracket name size close
635:51 - square bracket semicolon Char address
635:54 - open square bracket Adder size Clos
635:56 - square bracket semicolon long zip code
635:59 - semicolon long SS number semicolon
636:03 - double salary struct date birth date
636:06 - semicolon struct date hire date
636:10 - semicolon close curly bra semicolon the
636:13 - person structure contains two dates if
636:17 - we declare M as struct person M
636:21 - semicolon
636:22 - then. birthd dat. Monon refers to the
636:26 - month of birth the structure member
636:28 - operator dot associates left to right
636:33 - section 6.2 structures and functions
636:37 - there are a number of restrictions on C
636:38 - structures the essential rules are that
636:41 - only operations you can perform on a
636:42 - structure are to take its address with
636:45 - Amber sand and access one of its members
636:48 - this implies that structures may not be
636:50 - assigned or copied to as a unit and that
636:52 - they cannot be passed or returned from
636:56 - functions these restrictions will be
636:58 - removed in forthcoming versions porista
637:00 - structures do not suffer these
637:02 - limitations however so structures and
637:03 - functions do work together comfortably
637:06 - finally automatic structures like
637:08 - automatic arrays cannot be initialized
637:11 - only external or static structures can
637:13 - this prediction was indeed accurate
637:15 - modern C compilers do support the
637:17 - copying of a structure with a single
637:18 - assignment statement given that a c
637:20 - structure is just a fixed length block
637:22 - of memory it's easy easy to generate
637:24 - machine code to copy it a key bit to
637:27 - remember that when the C structure is
637:29 - copied it is done as a shallow copy a
637:32 - shallow copy copies the values of the
637:33 - variables and the pointers in the
637:35 - structure but does not make copies of
637:37 - any data which the pointers point to a
637:40 - structure that contains other structures
637:42 - I.E not pointers to structures then
637:44 - those structures are shallow copied as
637:46 - well
637:48 - back to the text let us investigate some
637:51 - of these points by rewriting the date
637:53 - conversion functions in the last chapter
637:54 - to use structures since the rules
637:56 - prohibit passing of a structure to a
637:58 - function directly we must must either
638:00 - pass the component separately or pass a
638:02 - pointer to the whole thing the first
638:05 - alternative uses of day of year which as
638:08 - we wrote in chapter
638:10 - five D.E day equals day of year open
638:14 - print D.E comma d. Monon comma d. day
638:18 - Clos print semicolon the other way is to
638:21 - pass a pointer if we've declared higher
638:24 - date as struct date higher date
638:26 - semicolon and Rewritten day of year we
638:29 - could then say higher date. Year Day
638:31 - equals day of year open print % higher
638:34 - date Clos print
638:36 - semicolon to pass a pointer to higher
638:38 - date to day of year the function has to
638:40 - be modified because its argument is now
638:42 - a pointer rather than a list of
638:45 - variables this example code is on page
638:48 - 122 of the textbook and you can see it
638:50 - at
638:52 - www.cc.com
638:54 - code struct date open curly brace int
638:59 - day semicolon int month semicolon int
639:03 - year semicolon int Year Day semicolon
639:07 - int M name open square bracket 4 Clos
639:10 - square square bracket semicolon closed
639:13 - curly brace
639:15 - semicolon static int Day tab open square
639:19 - bracket 2 close square bracket open
639:20 - square bracket 13 close square bracket
639:22 - equals open curly brace open curly brace
639:26 - 0 comma 31 comma 28 comma 31 comma 30
639:29 - comma 31 comma 30 comma 31 31 comma 30
639:34 - comma 31 comma 30 31 Clos curly brace
639:38 - comma and then another list just as long
639:40 - as that Co with a closed curly brace and
639:43 - a semicolon that just initialized the
639:46 - lookup table for the days in each month
639:49 - now on to the function day of year open
639:52 - pin PD close perin struct date star PD
639:56 - semicolon open curly braks in I comma
640:00 - day comma leap semicolon day equals
640:04 - PD minus greater than day semicolon leap
640:10 - equals PD minus greater than
640:13 - year percent 4 equals 0 and and PD minus
640:19 - greater than year per 100 not equal to
640:23 - zero or PD minus greater than year per
640:28 - 400 equal 0
640:31 - semicolon four open print I equal 1
640:34 - semicolon I less than
640:37 - PD minus greater than month semicolon I
640:41 - plus plus close print day plus equals
640:44 - Day tab
640:47 - open square bracket leap close square
640:49 - bracket open square bracket I close
640:51 - square bracket semicolon return open pen
640:54 - day closed pren semicolon close curly
640:58 - brace the d The Declaration struct date
641:02 - star PD says that PD is a pointer to a
641:05 - structure of type date the notion
641:07 - exemplified by PD minus greater than
641:12 - year I think I'll call that at this
641:15 - point PD right arrow because that's
641:17 - really what it is it's the minus greater
641:19 - than looks like an arrow to the right so
641:20 - I'm going to call it right arrow but
641:22 - it's really two characters PD right
641:24 - arrow year is new if p is a pointer to a
641:28 - structure then PD right arrow member of
641:31 - structure refers to the particular me
641:34 - member the operator right arrow is a
641:36 - minus sign followed by a greater than
641:40 - since PD points to the structure the
641:42 - year member could also be referenced as
641:45 - open Print Star PD Clos print
641:48 - doe but pointers to structures are so
641:50 - frequently used that the right arrow
641:52 - notation is provided both as a
641:55 - convenient shorthand the parentheses are
641:58 - necessary in open penar PD Clos P.E
642:02 - because the Precedence of the structure
642:03 - member operator dot is higher
642:06 - than the pointer lookup operator
642:08 - asterisk both right arrow and Dot
642:10 - associate to left from left to right so
642:14 - P right arrow Q right AR
642:18 - M and .b birthdate Doon are open print P
642:24 - WR aroq Clos print right arrow M and
642:27 - open print. birthdate close print.
642:31 - Monon for completeness here is the other
642:34 - function month day Rewritten to use the
642:37 - structure this is the first example on
642:40 - page 123 of the text which you can look
642:42 - at the source code at
642:44 - www.cc.com codee
642:47 - I won't read the struct and the date the
642:49 - struct date definition and the struct
642:51 - int static int dat tab definition we'll
642:54 - just go month
642:56 - day month day open pen PD Clos pen
643:00 - struct date star PD semicolon open curly
643:04 - brace in I comma leap semicolon leap
643:09 - equals PD right arrow year percent 4
643:13 - equals 0 and PD right arrow year percent
643:17 - 100 not equal to zero or PD right arrow
643:20 - year percent 400 equal 0
643:23 - semicolon PD right arrow day equals PD
643:27 - right arrow year day four open print I
643:31 - equal 1 semicolon PD right arrow day
643:35 - greater than Day tab sub leap sub I
643:38 - semicolon i++ Clos print PD right arrow
643:42 - day minus equals Day tab sub leap sub I
643:48 - semicolon PD right arrow month equals I
643:52 - semicolon close curly
643:55 - brace the structure operators right
643:58 - arrow and Dot together with parentheses
644:01 - for argument lists and square brackets
644:03 - for subscripts are the top of the
644:04 - precedent hierarchy and then thus bind
644:07 - very tightly for example given the
644:10 - Declaration struct open curly brace int
644:13 - X int star y semicolon close curly brace
644:19 - star P semicolon then plus plus P right
644:23 - arrow X increments X not P because the
644:28 - implied parenthesis is Plus+ open PR P
644:32 - right arrow X Clos print parentheses can
644:35 - be used after The
644:36 - Binding open print Plus+ P right arrow X
644:41 - increments P before accessing X and open
644:44 - print p++ Clos PR right Arrow X
644:47 - increments P afterward the last set of
644:50 - parentheses is
644:52 - unnecessary in the same way star P right
644:55 - arrow y fetches whatever y points to
644:58 - Star P right arrow y ++ increments y
645:03 - after what after accessing whatever it
645:06 - points to just like Star
645:09 - s++ open PR star P right arrow Y close
645:14 - print Plus+ increments whatever y points
645:16 - to to and star
645:19 - p++ right arrow y increments P after
645:23 - accessing whatever y points to section
645:27 - 6.3 arrays of structures structures are
645:31 - especially suitable for man managing
645:33 - arrays of related variables for instance
645:36 - consider a program to count the
645:38 - occurrences of each C keyword we need an
645:41 - array of character strings to hold the
645:42 - names and an array of integers to hold
645:44 - the counts one Poss possibility is to
645:47 - use two parallel arrays keyword and key
645:50 - count as in Char star keyword open
645:53 - square bracket n Keys close square
645:55 - bracket
645:56 - semicolon int key count open square
645:59 - bracket n Keys close square bracket
646:01 - semicolon but the very fact that the
646:04 - arrays are parallel indicates a
646:06 - different organization is possible each
646:08 - keyword entry is really a pair Char star
646:11 - keyword semicolon int key count
646:14 - semicolon and there's an array of the
646:16 - pairs
646:17 - the structure declaration struct key
646:20 - open curly brace Char star keyword
646:23 - semicolon int key count semicolon closed
646:26 - curly brace key tab open square bracket
646:28 - n Keys close square bracket semicolon
646:32 - defs an array key tab of structures of
646:34 - this type and allocates storage to them
646:36 - each element of the array is a structure
646:39 - this could also be written struct key
646:42 - open curly brace Char star keyword
646:45 - semicolon int key count semicolon Co
646:49 - closed curly brace semicolon struct key
646:52 - key tab open square bracket n Keys close
646:55 - square bracket
646:57 - semicolon since the structure key tab
647:00 - actually contains a constant set of
647:02 - names it's easiest to initialize it once
647:03 - and for all when it's defined the
647:05 - structural initialization is quite
647:07 - analgous to the earlier ones the
647:08 - definition is followed by a list of
647:10 - initializers enclosed in
647:12 - braces struct key open curly brace Char
647:16 - stock R keyword semicolon int key count
647:20 - semicolon close curly brace key tab open
647:23 - square bracket close square bracket
647:25 - equals open curly brace double quote
647:28 - break comma 0 comma double quote case
647:31 - comma 0 comma double quote Char comma
647:35 - zero comma and so forth down to double
647:39 - quote unsign double quote comma 0 comma
647:42 - double quote while double quot comma 0er
647:45 - close curly brace
647:48 - semicolon these initializers are listed
647:52 - in pairs corresponding to the structure
647:53 - members it would be more precise to
647:56 - enclose initializers for each row or
647:58 - structure in the braces as in open curly
648:01 - brace double quote break double quote
648:04 - comma zero closed curly brace comma open
648:07 - curly brace double quote case double
648:09 - quot comma zero Clos curly brace comma
648:13 - and so forth but the inter braces are
648:16 - not necessary when the initializers are
648:18 - simple variables or character strings
648:20 - and when all are present as usual the
648:22 - compiler will compute the number of
648:24 - entries in the array key tab if the
648:25 - initializers present and the open square
648:27 - bracket closed square bracket is left
648:30 - empty the keyword counting program which
648:33 - begins with a definition of key tab the
648:35 - main routine reads the input repeatedly
648:37 - by calling a function get word that
648:39 - fetches input one word at a time each
648:42 - word is looked up in key tab with a
648:45 - version of binary the binary search
648:46 - function we wrote in Chapter 3 of course
648:49 - the list of keywords has to be given in
648:51 - increasing order for this to
648:54 - work here is the first example on page
648:57 - 125 of the textbook you can see
649:01 - this at
649:04 - www.cc.com
649:07 - code pound include
649:10 - stdio.h pound toine maxw 20 pound toine
649:15 - letter quote a quote
649:18 - main open PR Clos PR open curly rce int
649:22 - n Comm T semicolon Char word open square
649:26 - bracket Max word close square bracket
649:30 - semicolon while open print open PR T
649:33 - equals get word open PR word comma Max
649:36 - word close PR close PR not equal eoff
649:39 - close
649:40 - PR if open PR t equal letter Clos PR if
649:45 - double open PR open PR n equals binary
649:50 - open print word comma key tab comma n
649:52 - Keys close print close print greater
649:54 - than or equal to zero close print key
649:57 - tab subn dokey count
650:01 - Plus+ four open pen n equals z semicolon
650:06 - n less than n Keys semicolon
650:09 - n++ if open open PR key tab sub n. key
650:13 - count greater than zero close PR print f
650:17 - double quote percent 4D space percent s
650:20 - back sln double quote comma key tab subn
650:24 - dokey count comma key tab sub n. keyword
650:28 - close pren semicolon and then a close
650:31 - curly brace to finish
650:33 - main
650:35 - binary to find the word in the in the
650:38 - table binary open PR word comma tab
650:41 - comma n close print charar word
650:45 - semicolon ruct key tab open square
650:48 - bracket close square bracket semicolon
650:51 - int n open curly brace int low comma
650:55 - High comma mid comma cond low equals z
650:59 - semicolon High equal n minus one
651:01 - semicolon while open pren low less than
651:05 - or equal to high closed pen open curly
651:08 - brace mid equals pren low plus High Clos
651:12 - print over
651:14 - two semicolon if
651:17 - open PR open PR cond equals stir comp
651:20 - open PR word comma tab comma open square
651:24 - bracket mid close Square bracket.
651:26 - keyword close print close print less
651:28 - than zero close print high equals mid
651:31 - minus one semicolon else if open pren
651:35 - Con greater than zero Clos pen low
651:38 - equals mid + one semicolon else return
651:42 - open PR mid Clos pren semicolon close
651:45 - curly brace to finish finish the while
651:47 - and then return open print minus one
651:49 - close print
651:50 - semicolon close curly brace so that's
651:53 - really a rewrite of the binary function
651:55 - from the earlier part where we're just
651:59 - taking the keyword and the count and uh
652:03 - and look and looking up in the array but
652:06 - then using the dot keyword to find the
652:08 - actual
652:09 - keyword back to the text we'll show
652:12 - function get word in a moment for now it
652:14 - suffices to say it returns letter each
652:16 - time it finds a word and copies the word
652:19 - into its first argument the quantity n
652:22 - Keys is the number of keywords in key
652:24 - tab although we could count this by hand
652:26 - it's a lot easier and safer to do it by
652:28 - Machine especially if the list is
652:30 - subject to change one possibility would
652:33 - be to terminate the list of initializers
652:34 - with a null pointer and then the loop
652:36 - along key tab just runs until the end is
652:39 - found but this is more than is needed
652:41 - since the size of the array is
652:43 - completely determined at compile time
652:46 - the number number of entries is just the
652:47 - size of key tab divided by the size of
652:50 - the struct
652:51 - Key C provides a compile time op unary
652:55 - operator called size of which can be
652:58 - used to compute the size of any object
653:01 - the expression size of open pen object
653:04 - closed pen yields an integer equal to
653:06 - the size of the specified object the
653:09 - size is given in unspecified units
653:11 - called bytes which are the same size as
653:13 - a Char closed pen
653:16 - the object can be an actual variable or
653:18 - an array or structure or the name of a
653:20 - basic type like int or double or the
653:22 - name of a derived type like a structure
653:25 - in our case the number of keywords is
653:27 - the array size divided by the size of
653:30 - one array
653:31 - element and this computation is used in
653:33 - a p pound define statement to set the
653:35 - value of n Keys pound Define n Keys open
653:40 - print size of open print key tab Clos
653:43 - print divided by size of open print
653:47 - struct key Clos print Clos
653:49 - print now for the function get word we
653:52 - have actually written a more General get
653:55 - word than is necessary for this program
653:57 - but is not really much more complicated
654:00 - get word Returns the next word from the
654:02 - input where a word is either a string or
654:04 - of letters or digits beginning with a
654:07 - letter or a single character the type of
654:09 - the object that is is the returned
654:11 - function as a function
654:13 - value it is the letter if the token is a
654:16 - word eof Rend of file or the character
654:18 - itself if it's
654:21 - non-alphabetic this sample code is on
654:24 - page 127 of the textbook which you can
654:26 - see at
654:28 - www.cc.com
654:30 - code pound toine letter quote a quote
654:34 - pound toine digit quote zero quote get
654:37 - word open paren w comma Lim close Pin
654:42 - Char starw colon semicolon int limb
654:47 - semicolon open curly brace int C comma T
654:51 - semicolon if open pen type open print C
654:56 - equals star w++ equals get CH open print
655:01 - close print close print not equal letter
655:03 - Clos print open curly brace start W
655:07 - equals quot back sl0 quote
655:11 - semicolon return open for C close for
655:14 - semicolon close curly brace
655:16 - that if statement has got some stuff
655:18 - going on in it you might want to look at
655:20 - it very
655:21 - closely while open print minus minus
655:24 - limb greater than zero closed print open
655:27 - curly brace T equals type open print C
655:31 - equals star
655:33 - w++ equals get CH open print Clos print
655:37 - Clos print
655:38 - semicolon if if open print T not equal
655:42 - letter and T not equal digit Clos print
655:46 - open curly brace unget CH open PR C Clos
655:49 - print
655:50 - semicolon break semicolon close curly
655:53 - brace star open pin wus one closed pin
655:58 - equals quote back sl0 quote semicolon
656:02 - return open pin letter close Pin
656:05 - semicolon close curly brace close curly
656:08 - brace that that example code has a lot
656:12 - of stuff about pointers and incrementing
656:14 - pointers and dereferencing pointers ET
656:16 - ET so take a good look at that
656:19 - code back to the text get word uses the
656:22 - routines get CH and unget CH which we
656:24 - wrote in chapter 4 when the collection
656:27 - of alphabetic of an alphabetic token
656:29 - stops get word has gone one character
656:31 - too far the call to unget CH pushes that
656:34 - character back on the input for the next
656:36 - call get word calls another function
656:38 - called type to determine the type of
656:40 - each individual character for input here
656:42 - is a version that's only for asky this
656:45 - code is the second example on page 127
656:49 - of the textbook at
656:52 - www.cc.com
656:55 - code Type open paren C Clos paren int c
657:00 - semicolon H C open curly brace if open
657:03 - paren C greater than or equal to quote a
657:06 - quote and C less than or equal to quote
657:08 - Z quote or C greater than or equal to
657:12 - quote uppercase a quote and C less than
657:15 - or equal to quote uppercase Z quote
657:18 - closed PR return letter
657:21 - semicolon else if open p c greater than
657:25 - or equal to quote 0 quote and C less
657:27 - than or equal to quote 9 quote close pen
657:30 - return open pen digit close Pin
657:33 - semicolon else return open pen C Clos
657:37 - pin semicolon close curly
657:40 - brace the symbolic constants letter and
657:43 - digits can have any values that do not
657:45 - conflict with nom non-alpha numeric
657:47 - values and eof the obvious choices
657:50 - are quote a quote and quote zero quote
657:54 - get word can be faster if calls to the
657:56 - function type are replaced by references
657:58 - to the appropriate array type the
658:00 - standard C library provides macros like
658:02 - is Alpha and is digit which operate in
658:05 - this manner section 6.4 pointers to
658:09 - structures to illustrate some of the
658:11 - considerations involved with pointers
658:13 - and arrays of structures let us write a
658:15 - keyword in program again this time using
658:19 - pointers instead of array
658:21 - Industries as an aside I would note that
658:23 - it's a classic early assignment in any
658:25 - programming language to do a word
658:27 - frequency program here is a Python
658:29 - program from my python for everybody
658:30 - course to count words from an input
658:33 - stream handle equ equals open open
658:37 - parentheses single quote romeo. txt
658:40 - close single quote comma quote R quote
658:42 - close parentheses words equals handle do
658:46 - read open print Clos print.it openr
658:49 - close PR counts equals dict open PR
658:52 - close PR for word inword
658:57 - colon counts subword equals counts.
659:01 - getet open print word comma 0er Clos
659:04 - Print Plus One print open print counts
659:07 - Clos print this section in this book
659:09 - implements a less General word counting
659:12 - program in C the code depends on several
659:14 - functions from earlier in the book and
659:16 - the code below is pretty complex where
659:18 - the programmer only has access to low-l
659:21 - language without powerful and easy to
659:22 - use data types like Python's list or
659:25 - dict it is likely that GTO van rossom
659:28 - read this book took a long look at this
659:30 - code and designed the dict data
659:32 - structure in Python so the rest of us
659:34 - could write a data parsing and word
659:36 - frequency programming program in the
659:38 - above six lines of code without worrying
659:40 - about dynamic memory allocation pointer
659:42 - management string length and a myriad of
659:45 - other Det details that must be solved
659:47 - when you're solving this program in
659:50 - C since python is open source you can
659:53 - actually look at the C code that
659:54 - implements the dict object in a file
659:56 - called dict object. C it is almost 6,000
660:00 - lines of code and includes other files
660:03 - or utility code there thankfully we only
660:06 - have to write one line of python to use
660:07 - it counts equals dict open friend close
660:11 - PR we will leave the complex bits to the
660:13 - C programmers that build and maintain
660:16 - this section is not showing us how to
660:18 - use the python dict object rather it is
660:22 - showing how one would build a dict like
660:24 - structure using
660:26 - C so continuing with Section 6.4
660:30 - pointers to
660:32 - structures the external definition of
660:34 - key tab do not need a change but Main
660:36 - and binary do need modification this is
660:40 - example on page 129 of the
660:42 - textbook and that is available at www .
660:46 - cc4
660:47 - e.com
660:50 - code pointer version of Counting C
660:53 - keywords main open print Clos print open
660:56 - curly brace int T
660:59 - semicolon Char word open square bracket
661:02 - Max word close square bracket semicolon
661:04 - struct key star binary open print Clos
661:07 - print comma star P
661:10 - semicolon while open PR open PR T equals
661:13 - get word open print word comma Max word
661:16 - close print Clos print not equal EF Clos
661:20 - PR if open PR t equal equal letter Clos
661:25 - print if open print open print b equals
661:28 - binary open print word comma key tab
661:31 - comma in Keys Clos print Clos print not
661:34 - equal null Clos print P right arrow key
661:37 - count
661:39 - Plus+ for p equals key tab P less than
661:43 - key tab plus n Keys semicolon P plus
661:46 - Plus close parentheses if open print P
661:49 - right arrow key count greater than zero
661:52 - Clos print print F open print double
661:55 - quote percent 4D space percent s back
661:59 - slash N double quote comma P Arrow key
662:03 - count comma P right arrow key
662:07 - word and now we look at the binary
662:12 - search struct key star binary open pin
662:16 - word comma tab comma n close Pin Char
662:20 - star word struct key tab open square
662:23 - bracket Clos spur bracket semicolon int
662:26 - n open curly brace int cond
662:31 - semicolon struct key star low equals
662:35 - ersan tab Subzero semicolon struct key
662:39 - Star High equals Ampersand tab subn
662:42 - minus1
662:43 - semicolon struct key equals
662:47 - mid while open pen low less than or
662:50 - equal to high closed pen open curly
662:52 - brace mid equals low plus High minus
662:57 - low / two if open pin open PR cond
663:03 - equals stir comp word comma mid right
663:06 - arrow key word close print close print
663:09 - less than zero Clos PR High equals midus
663:13 - one semicolon else if Clos PR con
663:17 - greater than zero Clos PR low equals mid
663:20 - + 1 semicolon else return open pen mid
663:24 - Clos pen
663:26 - semicolon close curly brace to finish
663:28 - the while and then return open pen null
663:32 - close Pin close curly
663:35 - brace there are several things worthy of
663:37 - note here first the Declaration of
663:40 - binary must indicate that it returns a
663:43 - pointer to the structure type key
663:45 - instead of of an integer this is
663:47 - declared both in Main and in binary if
663:50 - binary finds the word it returns a
663:52 - pointer to it if it fails it returns
663:54 - null
663:56 - second all the accessing elements of
663:59 - keydb is done by pointers this causes
664:02 - one very significant change in
664:04 - binary the computation of the middle
664:06 - element can no longer be simply mid
664:08 - equals pen low plus High Clos pin
664:12 - divided by two because the addition of
664:14 - two pointers will will not produce any
664:17 - kind of useful answer even when divided
664:19 - by two and is fact illegal this must be
664:21 - changed to Mid equals low Plus open pen
664:26 - High minus low closed peren / two which
664:29 - sets mid to the point point to the
664:31 - element halfway between low and high you
664:35 - should also study the initializers for
664:37 - low and high it is possible to
664:40 - initialize a pointer to the address of a
664:42 - previously defined object and that is
664:45 - precisely what we have done
664:47 - here in main we wrote for open print P
664:51 - equals key tab semicolon P less than key
664:54 - tab plus n Keys semicolon p++ Clos
664:58 - print if p is a pointer to a structure
665:02 - any arithmetic on P takes into the
665:04 - account the actual size of the structure
665:06 - so p++ increments P by the correct
665:09 - amount to get to the next element in the
665:11 - array of
665:12 - structures but don't assume that the
665:14 - size of a structure is the sum of the
665:15 - sizes of its members because alignment
665:17 - requirements for different objects C
665:20 - potentially may cause holes in the
665:22 - structure finally an aside on program
665:26 - format when a function returns a
665:28 - complicated type as instruct key star
665:31 - binary open print word comma tab comma n
665:35 - Clos print the function name can kind of
665:37 - be hard to see and or find with a text
665:40 - editor
665:42 - alternately another style is sometimes
665:44 - used on two lines now struct key star on
665:48 - the first line in binary open PR word
665:50 - comma tab comma n close print the
665:54 - spacing is mostly a matter of personal
665:56 - taste pick the form you like and hold to
665:58 - it section 6.5 self-referential
666:03 - structures before we start this section
666:05 - a slightly longer aside from your
666:07 - narrator up to now I've resisted the
666:10 - temptation to augment the book with my
666:12 - own bits of code but we have reached the
666:14 - single point in the book where I feel
666:16 - that there is too big of a conceptual
666:18 - leap between two sections so I'm going
666:20 - to add some of my own narrative between
666:22 - section 6.4 and
666:24 - 6.5 the rest of this chapter talks very
666:27 - nicely about binary trees and hash
666:29 - tables both essential lowle data
666:31 - structures in computer science and both
666:34 - excellent ways to understand pointers
666:36 - and how C can be used to build data
666:37 - structures like the python dictionary
666:40 - however the author skipped separately
666:42 - describing the structure of of a dynamic
666:45 - Dynam dynamically constructed link list
666:47 - which is the first and foundational
666:49 - collection data structure in computer
666:51 - science and should be understand
666:53 - understood before moving to tree and
666:55 - hashmap
666:57 - structures link lists form the
666:59 - foundation of the Python list object
667:01 - Java array object PHP numeric key arrays
667:04 - and JavaScript arrays the link list can
667:06 - be dynamically extended and items can be
667:09 - added in the middle efficiently as well
667:11 - as being pushed or popped on or off the
667:13 - front or back of the list link lists are
667:16 - used also to implement cues as well as
667:18 - other aspects of operating system I will
667:22 - attempt to mimic the authors's writing
667:23 - style in this new section of the book
667:25 - I'll write some sample code using a more
667:27 - modern dialect of C so it's easier to
667:29 - run on a modern
667:32 - compiler section
667:35 - 6.5.1 linked lists bonus
667:38 - content suppose we want to read a file
667:40 - and print the file in reverse order we
667:43 - don't know how many lines will be in the
667:44 - file before read the file so we can't
667:46 - simply use an array of pointers to
667:49 - Strings and character Rays like lines in
667:52 - a sense we need a dynamic array that
667:54 - grows as we encounter new lines when we
667:56 - reach the end of the file we then just
667:58 - Loop through our stored lines from the
668:00 - end to the beginning so we can print
668:02 - them out in reverse order one solution
668:05 - is to make a data structure called a
668:06 - doubly link list of character strings in
668:09 - addition to each line of data we will
668:11 - store a pointer to the previous line and
668:13 - the next line as well as well as a
668:16 - pointer to the first item the add to the
668:18 - list and then we'll call this the head
668:20 - of the list and then the most recent
668:22 - item we've added to the list which we
668:23 - will call the tail of the list we will
668:26 - see a singly link list as part of the
668:28 - hashmap data structure in a following
668:31 - section a single link list can only be
668:33 - traversed in a forward Direction a
668:35 - doubly link list can be traversed either
668:37 - forwards or backwards given that our
668:39 - link list of strings will keep expanding
668:41 - as we get new lines we avoid hardcoding
668:43 - array sizes like pound to find Max Len
668:46 - 1000 in the previous chapter we were
668:48 - building a program to sort a file going
668:51 - back to the description of a line in our
668:53 - doubly linked list it is clearly a
668:55 - structure with three components struct L
668:58 - node open curly brace Char star text
669:01 - semicolon struct L node star preve
669:04 - semicolon struct L node star next
669:07 - semicolon Clos curly
669:10 - brace this recursive definition of l
669:13 - node might look chancy but it's actually
669:15 - quite correct it is illegal for a
669:18 - structure contain to contain an instance
669:20 - of itself but struct L node star preve
669:24 - declares prieve to be a pointer to an L
669:26 - node not an l- node
669:29 - itself we'll write this code in a more
669:31 - modern seed dialect using modern memory
669:33 - allocation and IO routines provided by
669:35 - the standard seed Library this code is
669:38 - on page 130 of the textbook available at
669:42 - www.cc.com
669:46 - code pound include
669:48 - stdio.h pound include STD live. pound
669:52 - include string.h pound toine MAX Line
669:55 - 1,000 this is the length of the line not
669:57 - the number of lines struct L node open
670:01 - curly brace Char star text semicolon
670:04 - struct L node star preve semicolon
670:08 - struct L node star next semicolon Clos
670:11 - curly brace
670:13 - semicolon now we have our main program
670:15 - to print the lines in reverse and we
670:18 - will use int main open print Clos PR
670:21 - because we're coding in a modern dialect
670:23 - of C open curly brace struct L node star
670:28 - head equals null semicolon struct L node
670:32 - star tail equals null semicolon Charline
670:35 - submax line
670:37 - semicolon while open print fgs open
670:42 - print line comma MAX Line comma STD in
670:45 - close print not equal null Clos print
670:48 - open curly
670:50 - brace Char star save equals open print
670:54 - Char star Clos print Malik open print
670:58 - sterlin open print line Clos Print Plus
671:01 - One Clos print
671:03 - semicon stir copy save comma
671:07 - line struct L node Star new equals open
671:12 - print struct L node star Clos print
671:14 - Malik open pen size of struct L node
671:17 - close pen close pen semicolon new right
671:20 - arrow text equals save new right arrow
671:23 - next equals null new right arrow preve
671:26 - equals tail and tail equals
671:29 - new if head equals equals null close pen
671:34 - head equals new
671:37 - semicolon close curly brace to finish
671:40 - the while now we'll print it all out
671:42 - four open PR instruct L node star
671:46 - current equals tail semicolon current
671:48 - not equal to null semicolon current
671:52 - equals current right arrow prev close
671:54 - parentheses open curly brace print F
671:57 - open print double quote s close uh
672:01 - double quote comma current right arrow
672:04 - text close pen semicolon close curly
672:07 - brace to finish the four and then close
672:09 - curly brace to finish the
672:11 - main interestingly if we wanted to print
672:14 - the list in for forward order or if we
672:16 - did have only a singly link list our
672:18 - Loop would look as
672:19 - follows four open pen struct L node star
672:22 - current equals head semicolon current
672:25 - not equal to null semicolon current
672:28 - equals current right arrow next close PR
672:30 - open curly brace print F open print
672:34 - double quote percent s double quote
672:36 - comma current right arrow text Clos pen
672:40 - semicolon Clos curly
672:42 - brace in general we use the variable
672:45 - names head tail and current as well as
672:48 - next and preve or similar names when
672:50 - writing code that builds or uses a link
672:52 - list so other programs will quickly
672:54 - understand what we are talking about
672:57 - after a while reading a for Loop to
672:59 - Traverse a linked list becomes As
673:01 - Natural as reading a for Loop that
673:03 - progresses through a sequence of numbers
673:05 - section
673:06 - 6.5.2 binary trees suppose we want to
673:10 - handle the more General problem of
673:12 - counting the occurrences of all the
673:13 - words in some input since the list of
673:16 - words isn't known in advance we can't
673:18 - conveniently sort it and use a binary
673:20 - search yet we can't do a linear search
673:22 - for each word that is arrived to see if
673:24 - it's already been seen the program would
673:26 - take forever more precisely what is the
673:29 - expected running time and it would grow
673:31 - quadratically with a number of input
673:33 - words how can we organize the data to
673:36 - cope efficiently with a list of
673:38 - arbitrary
673:39 - words our solution is to keep the set of
673:42 - words seen so far sorted at all times by
673:47 - placing each word into its proper
673:49 - position in the order as it arrives this
673:51 - should this shouldn't be done by
673:53 - Shifting the words in a lineary array
673:55 - though that takes too long instead we
673:58 - will use a data structure called a
674:00 - binary
674:02 - tree the tree contains one node per
674:04 - distinct word each node contains a
674:07 - pointer to the text of the word a count
674:10 - of the number of occurrences of the word
674:12 - a pointer to the left child node and
674:15 - pointer to the bride child of
674:16 - node no node may have more than one more
674:21 - than two children it might have only
674:23 - zero or
674:24 - one the nodes are maintained so that any
674:27 - node in the left tree contains only
674:29 - words that are less than the words at
674:30 - the node and the right tree only
674:32 - contains words that are gr to find out
674:34 - whether a new word is already in the
674:36 - tree one starts at the root and compares
674:37 - the new word to the word starting into
674:39 - that node if they match we found it if
674:43 - the new word is less than the tree word
674:45 - the search continues down the left
674:46 - otherwise the right child is searched if
674:49 - there's no child in the required
674:50 - Direction then the word is not in the
674:52 - tree and in fact in fact the proper
674:55 - place for it to be is the missing child
674:59 - this search process is inherently
675:02 - recursive since the search from any node
675:04 - uses a search from one of its children
675:06 - accordingly recursive routines for
675:08 - inserting and printing will be the most
675:11 - natural going back to the description of
675:14 - a node is clearly a structure with four
675:17 - components struct t- Noe open curly
675:20 - brace Char star word in count semicolon
675:25 - struct t- node star left semicolon
675:28 - struct t- node Star right semicolon Clos
675:31 - curly
675:33 - brace this recursive Declaration of a
675:35 - node might look chancy but actually it's
675:38 - quite correct it's eal illegal for a
675:41 - structure to contain an instance of
675:42 - itself but struct te node star left
675:46 - semicolon declares left to be a pointer
675:48 - to a node not a node
675:50 - itself the code for the whole program is
675:53 - surprisingly small given the handful of
675:55 - supporting routines that we've already
675:56 - written these are get word to fetch
675:58 - input and Alec to provide space for
676:00 - squirreling the words away the main
676:03 - routine simply reads words with get word
676:07 - installs them in the tree with
676:09 - tree this is the first example on page
676:12 - 131 of the textbook which you can see
676:16 - www.cc.com
676:19 - code pound include
676:22 - stdio.h pound Define maxw 20 pound toine
676:25 - letter single quote a single quote main
676:28 - open pen Clos pen open curly brace
676:31 - struct t- Noe star root comma star Tree
676:36 - open print Clos print semicolon Char
676:39 - word open square bracket Max word close
676:41 - square bracket semicolon int T semicolon
676:44 - root equals
676:46 - null while open pen open pen T equals
676:51 - get word open pen word comma Max word
676:53 - close Pin close Pin not equal eoff close
676:56 - Pin if open pin t equal letter close Pin
677:00 - root equals Tree open pin root comma
677:03 - word Clos pin
677:05 - semicolon tree print open pen root Clos
677:10 - print semicolon close curly
677:13 - brace tree it's itself is
677:15 - straightforward a word is presented by
677:18 - main to the top level root of the tree
677:20 - at each stage that word is compared to
677:23 - the word already stored at the node and
677:24 - is percolated down either to the left or
677:26 - right subtree by a recursive called a
677:28 - tree eventually the word either matches
677:32 - something already in the tree in which
677:34 - case the count simply is incremented or
677:36 - a null poter pointer is encountered
677:38 - indicating the node must be created and
677:40 - added to the tree if a new node is
677:42 - created tree returns a pointer to it
677:45 - which is installed in the parent
677:48 - node this is the example on page 132 of
677:53 - the textbook at
677:55 - www.cc.com
677:59 - code pound includes
678:02 - string.h struct t- Noe open curly brace
678:06 - Char star word semicolon int count
678:09 - semicolon struct T node star left
678:12 - semicolon struct T node Star right right
678:15 - semicolon closed curly brace
678:18 - semicolon struct t- node star Tree open
678:22 - pin p comma W close print we're going to
678:25 - install w at or below P struck T node
678:30 - star P semicolon Char star W open curly
678:34 - brace struct t- node star T alic open
678:38 - pin Clos pin semicolon Char star stir St
678:42 - stir Save open p close p semicolon int
678:46 - cond
678:48 - semicolon if open print pble equal null
678:52 - Clos print open curly brace we've got a
678:55 - new word p equals T Alec open print
678:58 - close print to make a new note P right
679:02 - arrow word equals stir Save open print W
679:05 - Clos print semicolon P right arrow count
679:08 - equals 1 P right arrow left equals P
679:11 - right arrow right equals null
679:15 - close curly brace else
679:18 - if open print open print cond equals
679:21 - stir comp W comma P right arrow word
679:24 - close print close print double equals z
679:27 - close print P right arrow count
679:31 - Plus+ indicate that we've seen the word
679:34 - one more
679:36 - time else if open print cond less than
679:39 - zero Clos print lower will go into the
679:42 - left part of the tree
679:46 - P right arrow left equals tree P right
679:50 - arrow left comma W Clos PR semicolon
679:55 - else P right arrow right equals Tree
679:59 - open PR P right arrow right comma W Clos
680:04 - print
680:04 - semicolon return open print P Clos print
680:08 - semicolon close curly
680:10 - brace and that's a bit of code it's not
680:13 - much and it's beautiful recursion is
680:17 - happening the return P at the very end
680:19 - is really really important because we're
680:20 - kind of always overriding it but we're
680:23 - okay so um The overriding Works its way
680:27 - back up to the recursion because it's
680:28 - recursive it's using pointers where we
680:31 - go back to the text storage for the new
680:35 - node is fixed by a routine called tallic
680:38 - which is an adaptation of the Alec we
680:40 - wrote earlier it rep turns a pointer to
680:43 - a free space suitable for holding a tree
680:45 - Noe we'll discuss this more in a moment
680:48 - the new word is copied to a hidden place
680:50 - by stir say the count is initialized and
680:52 - the two children are made
680:54 - null this part of the code is executed
680:56 - only at the edge of the tree when a new
680:58 - node is being added we have unwisely for
681:02 - a production program omitted error
681:03 - checking on the values returned by stir
681:06 - save and T Alec tree print prints the
681:11 - tree in left sub tree order at each note
681:14 - Prince its left subtree all the words
681:16 - less than this word then the word itself
681:19 - then the right sub tree all the words
681:21 - greater if you feel shaky about
681:23 - recursion draw yourself a tree and print
681:26 - it with tree print it's one of the
681:28 - cleanest recursive routines you can
681:33 - find this example code is on page 133 of
681:36 - the textbook which you can see at
681:39 - www.cc.com code
681:45 - I won't
681:46 - read The Struck T node code just tree
681:51 - print tree print open pen P Clos pen
681:55 - struct T node star P semicolon open
681:58 - curly brace if open pen P not equal to
682:02 - null Clos
682:04 - pen curly brace open curly brace tree
682:07 - print open pen P right arrow left close
682:10 - pen semicolon print F percent 4D space
682:15 - percent s back slash N double quote
682:17 - comma P right arrow count comma P right
682:20 - arrow word some close parentheses
682:23 - semicolon tree print open PR P right
682:27 - arrow right Clos PR semicolon close
682:30 - curly brace for the if and then close
682:32 - curly brace for the tree print
682:35 - function again I agree with the authors
682:37 - and that is one of the cleanest and most
682:39 - beautiful and most applicable uses of
682:41 - recursion that you will probably ever
682:43 - see in all your
682:45 - I'm not a fan of recursion in all uses
682:47 - cases but you really can't do this any
682:50 - other way
682:52 - well back to the text pract as a
682:54 - practical note if the pre tree becomes
682:57 - unbalanced because the words don't
682:58 - arrive in random order the running time
683:00 - of the program can grow too fast as a
683:03 - worst case if the fors are already in
683:05 - order this program does an expensive
683:08 - simulation of linear search there are
683:10 - generalizations of the binary tree
683:12 - notably two three trees AVL trees and I
683:15 - would add balanced binary trees which do
683:17 - not suffer from this worst case Behavior
683:19 - but we will not describe them
683:22 - here before we leave this example it's
683:24 - also worth a brief digression on a
683:26 - problem related to storage allocators
683:29 - clearly it's desirable that there only
683:31 - be one storage allocator in a program
683:34 - even though it allocates different kinds
683:35 - of objects but if one allocator is to
683:38 - process requests for say pointers to
683:40 - chars and pointers to struck T noes two
683:42 - questions arise first does it meet the
683:45 - requirement of most real machines that
683:47 - objects of a certain types must satisfy
683:50 - alignment restrictions for example
683:52 - integers must often be located uneven
683:55 - addresses second what declarations can
683:58 - cope with the fact that Alec necessarily
684:01 - returns different kinds of
684:03 - pointers alignment requirements can
684:05 - generally be satisfied easily at the
684:07 - cost of some wasted space merely by
684:09 - assuring ensuring the allocator always
684:12 - returns a pointer that meets all
684:13 - alignment restri restrictions for an
684:16 - example on the pdp1 it is sufficient
684:19 - that Alec always returns an even pointer
684:21 - since any type of object may be stored
684:23 - at an even address the only C cost is a
684:27 - wasted character on the odd length
684:29 - requests similar actions are taken on
684:31 - other machines thus the implementation
684:34 - of Alec may not be portable but its
684:36 - usage is the Alec of chapter 5 does not
684:40 - guarantee any particular alignment in
684:43 - chapter 8 we'll show how to do the job
684:45 - right as an aside by now you know that
684:48 - when the authors mentioned the pdp1 they
684:51 - are sharing some aspects of the
684:53 - challenge of making CW work on previous
684:55 - generation computers with short memory
684:57 - words and small amounts of memory and at
684:59 - the same time making them work well on
685:02 - the incoming generation of computers
685:03 - with larger words and more memory the
685:06 - research thought and care that went into
685:09 - making sure the C code was portable
685:12 - across multiple generations of computer
685:14 - hard Ware is on display in the previous
685:18 - paragraph the question of the type
685:21 - declaration for Alec is a vexing one for
685:23 - any language that takes its type
685:25 - checking
685:26 - seriously in C the best procedure is to
685:29 - declare that Alec returns a pointer to
685:30 - char and then explicitly coers the
685:33 - pointer into the desired type with a
685:35 - cast therefore if p is declared as Char
685:39 - star P semicolon then open per instruct
685:43 - t-e star Clos print P converts it into a
685:46 - t- node pointer expression thus tallic
685:49 - is written as struct t- node star T Alec
685:53 - open pren Clos pren open curly brace
685:56 - Char star
685:57 - Alec return open pren open print struct
686:01 - t- node star Clos print Alec open print
686:04 - size of open print struct t- node Clos
686:07 - print Clos print close
686:10 - print this is more than is needed for
686:12 - current compounds but represents the the
686:14 - safest course for the
686:17 - future I would add that these concerns
686:21 - that the author's mention in this
686:22 - section are also nicely resolved in
686:25 - modern C compilers in the NC version of
686:27 - C they introduce the notion of the Void
686:29 - type the void type indicates the lack of
686:32 - a type much like null is used to
686:34 - indicate not a valid pointer or not a
686:38 - flying toy in 1978 because the charart
686:42 - type was generally the most native type
686:43 - on any system it was often used as the
686:46 - generic pointer needed to return memory
686:48 - from an allocation function in modern C
686:51 - we use pointers to void and then cast
686:53 - The Returning pointer to be a pointer to
686:55 - whatever struct or other data we just
686:58 - allocated if we were writing Alec the
687:00 - Alec routine in this book using modern C
687:03 - it would return a pointer to
687:04 - void the 1978 version is Char star Alec
687:08 - open pin Clos PR and the modern version
687:11 - is void star Alec open pin close
687:15 - Pin we've left the book alone we haven't
687:18 - used void throughout the book but it is
687:20 - a testament to the foresight of the
687:22 - authors that all the pointer casting
687:25 - code in this book still works today the
687:29 - same regardless of whether the memory
687:31 - allocation functions return Char or void
687:33 - pointers to the allocated data section
687:36 - 6.6 table
687:39 - lookup as an aside in this section we
687:42 - finish our quick tour of the implement
687:44 - ment ation of the Three core data
687:45 - structures in computer science one the
687:48 - link list two the tree and three the
687:51 - hashmap as described in this section A
687:54 - singly Link list is also part of a
687:56 - hashmap implementation so you can
687:58 - compare it to the doubly link list code
688:00 - introduced in the earlier bonus section
688:04 - 6.5.1 this section is worth
688:07 - understanding well because not only is
688:08 - it an excellent review of pointers and
688:10 - structures but also because one of the
688:12 - most common questions
688:14 - on a face-to-face programming interview
688:16 - is draw a hashmap on the Whiteboard and
688:19 - explain how it works this is an easy
688:22 - question if you study and understand
688:24 - this section of the book and almost
688:26 - impossible if you have
688:28 - not in some ways this section is the
688:31 - most intricate data structure that's
688:33 - described in the book it is why it is so
688:35 - popular in coding interviews chapters is
688:38 - seven and eight talk about lots of
688:40 - practical things like input output of
688:42 - the Unix operating system
688:44 - elegant data structures and their use
688:46 - are Core Concepts in computer science
688:49 - understanding them highlights the
688:50 - difference between a good programmer and
688:52 - a computer scientist in a sense
688:55 - understanding how a hashmap is the
688:58 - secret handshake of computer science and
689:01 - it is the secret
689:03 - handshake because of this book and this
689:06 - section of this book written back in
689:10 - 1978 and used in a course that the
689:13 - person interviewing you may have took
689:16 - when they were in
689:17 - college hashmaps were difficult for them
689:20 - to understand back then and so if you
689:22 - understand the concept then you must be
689:24 - solid so I hope you pay close attention
689:28 - to this section and remember the
689:31 - handshake back to the
689:34 - text in this section we will write the
689:36 - innards of a table lookup package as an
689:39 - illustration of more aspects of
689:40 - structures this code is typical of what
689:43 - might be found in the symbol table
689:44 - management routines of a macro processor
689:46 - or a
689:47 - compiler for example consider the C
689:50 - pound defined statement when a line like
689:52 - pound Define yes one is encountered the
689:55 - name replacement Tech the name yes and
689:58 - the replacement text one are stored in a
690:00 - table later when the name yes appears in
690:03 - a statement like inw equals yes
690:05 - semicolon it must be replaced by
690:08 - one there are two major routines that
690:10 - manipulate the names and replacement
690:12 - texts install open pin s comma T close
690:17 - Pin records the name s and the
690:18 - replacement T in the table s and t are
690:22 - just character strings look up open
690:24 - print s Clos print searches for s in the
690:27 - table and returns a pointer to the place
690:29 - where it was found or null if it wasn't
690:32 - there the algorithm used is a hash
690:35 - search the incoming name is converted to
690:38 - a small positive integer which is then
690:40 - used to index into an array of pointers
690:44 - an array element points to the beginning
690:46 - of a chain of blocks describing the
690:47 - names that have the hash value and if it
690:50 - is null then no names have hashed to
690:53 - that value a block in the a block in the
690:57 - chain is a structure containing pointers
690:59 - to the name the replacement text and the
691:02 - next block in the chain a null next
691:04 - pointer marks marks the end of the
691:08 - chain struct and list open pen Char star
691:12 - name semicolon Char stard def semicolon
691:17 - struct end list star next semicolon
691:21 - close curly brace
691:24 - semicolon the pointer array is just
691:27 - pound toine hash size 100 static struct
691:32 - end list star hashtab open square
691:35 - bracket hash size Clos square bracket
691:38 - semicolon the hashing function which is
691:41 - used by both lookup and install simply
691:44 - adds up the character values in the
691:46 - string and forms the remainder
691:48 - modulo the array size this is not the
691:51 - best possible algorithm but it has the
691:54 - Merit of extreme
691:57 - Simplicity hash open pen s Clos pin Char
692:01 - star s semicolon open curly brace int
692:05 - hash Val four open curly brace hash
692:10 - valal equals zero star s not equal quote
692:14 - single quot back sl0 single quote
692:16 - semicolon Clos
692:19 - pen hash Val plus equals star s++
692:25 - semicolon return open pen hash Val
692:29 - modulo percent hash size Clos prin
692:32 - semicolon closed curly
692:34 - brace as an aside hashing functions are
692:38 - one of the foundational Notions in
692:40 - computer
692:40 - science hashing functions are used for
692:43 - every from high performance in memory
692:45 - structures organizing
692:47 - databases data digital signing Network
692:51 - packet check sums security algorithms
692:53 - and much more the above text is a really
692:57 - great example of a really simple hashing
693:01 - function you should understand this
693:03 - simple presentation well so that when
693:05 - you encounter a more complex
693:07 - implementation or use of hashing you can
693:10 - fall back on this text to understand
693:13 - that at its core hashing is a very
693:16 - simple
693:17 - concept so much of this chapter is a
693:20 - succinct example of some of the most
693:23 - powerful Concepts in computer
693:25 - science please don't look at the eight
693:27 - code lines of code above and think I got
693:29 - that and just jump to the next
693:31 - bit this chapter is showing you the way
693:34 - of the master
693:35 - programmer wax on wax off be patient
693:41 - slow down and enjoy your time time
693:44 - here back to the text the hashing
693:48 - process produces a starting index in the
693:50 - array hashtab if the string is to be
693:53 - found anywhere it will be in the chain
693:55 - of blocks beginning there the search is
693:57 - performed by lookup if lookup finds the
694:00 - entry already present it just returns a
694:02 - pointer to it if not it returns
694:05 - null here's the code struct end list
694:08 - star lookup open pin s Clos pin Char
694:13 - star s
694:14 - semicolon open curly brace struct and
694:18 - list star NP
694:21 - semicolon four open pen NP equals
694:26 - hashtab sub hash open pen s Clos
694:30 - pen close square bracket semicolon NP
694:34 - not equal null semicolon NP equals an NP
694:38 - right arrow next close
694:40 - parentheses if stir comp open print s NP
694:44 - right arrow name close print double
694:46 - equals 0 return open print NP close
694:49 - print
694:50 - semicolon return open print null Clos
694:53 - print semicolon close curly brace
694:56 - install uses lookup to determine whether
694:58 - the name installed is already present if
695:01 - so the new definition must supersede the
695:03 - old one otherwise a completely new entry
695:07 - is created install returns null if for
695:11 - any reason there's no room for a new
695:12 - entry
695:16 - struct and list star install open pin
695:19 - name common def close Pin jar star name
695:23 - comma stard def semicolon open curly
695:26 - brace struct end list star NP comma star
695:31 - lookup open PR Clos PR semicolon Char
695:34 - stir save comma star Alec open PR close
695:37 - PR semicolon int hash file
695:41 - semicolon if open print open print NP
695:45 - equals lookup open PR name close print
695:48 - close print double equal
695:50 - null close Pin open curly brace I.E it's
695:53 - not found NP equals open pin struct end
695:57 - list star Clos pin Alec open print size
696:01 - of open Print Star NP Clos print Clos
696:04 - print
696:06 - semicolon if NP equals null return null
696:09 - that means the allocation
696:11 - failed if open pen open print NP right
696:15 - arrow name equals stir Save open print
696:19 - name close print close print double
696:20 - equals null Clos print return open p
696:25 - null Clos pint
696:28 - semicolon hash Val
696:32 - equals hash open PR NP right arrow name
696:37 - closed print
696:39 - semicolon and P next equals hashtab open
696:43 - square bracket hash Val close square
696:45 - bracket second
696:47 - semicolon hashtab open square bracket
696:50 - hash Val close sare bracket equals NP
696:53 - semicolon we're actually pushing these
696:56 - new ones to the head of this singly link
696:59 - list and so those last two
697:02 - statements push the the most recent top
697:05 - of the list forward and then replace
697:08 - with a new one at the top of the list
697:10 - the list does not stay in any order
697:15 - so we have a Clos curly brace to end all
697:19 - that if for the not found code closed
697:22 - curly brace else this is the already
697:24 - code already there code free open pin NP
697:29 - WR Arrow defa Clos pin semicolon free
697:32 - the previous definition that's the
697:34 - string part of
697:36 - the the uh the pound
697:39 - Define if open print NP right arrow def
697:44 - equal stir Save open print defa close
697:47 - print close print equals no close print
697:51 - return open print null Clos print
697:53 - semicolon return open print NP Clos
697:56 - print semicolon Clos curly brace so that
698:00 - last bit there was to if you have a
698:03 - pound Define with the
698:06 - same keyw and a different later you have
698:09 - a later a different uh definition you
698:12 - can replace the definition and so that
698:14 - last bit was replacing the definition
698:16 - again this code is pretty intricate it's
698:19 - really both the hash table and a singly
698:21 - link list going on at the same time so
698:24 - take a close look at this on page 136 of
698:27 - the
698:28 - book stir save merely copies the string
698:31 - given its argument to a safe space
698:33 - obtained by a call to Alec we've showed
698:36 - this code in chapter five since calls to
698:38 - Alec and free may occur in any order and
698:40 - since alignment matters the simple
698:42 - version of alic is just not adequate
698:46 - here see more in chapters 7 and
698:50 - 8 as an aside one of the reasons that
698:53 - the authors make vague forward-looking
698:54 - statements when they talk about dynamic
698:57 - memory is that large-scale memory
698:58 - management in a programming language is
699:01 - still a subject of active research 40
699:03 - years later back in 1978 it was
699:06 - absolutely not a settled topic you can
699:09 - see this when the authors build a simple
699:11 - non-production memory allocation scheme
699:13 - with their own Alec and free routines
699:15 - backed by a fixed length static extern
699:17 - array of characters Dynamic allocation
699:20 - is essential to writing competency
699:22 - programs but it is likely that the
699:24 - production grade dynamic memory support
699:26 - was still somewhat non-portable when the
699:28 - book was written so they use Simple
699:30 - self-contained implementations in this
699:32 - book modern dynamic memory support is
699:35 - through the Malak C alic and free
699:38 - functions in the standard Library these
699:40 - functions request dynamic memory blocks
699:41 - from the operating system and manage
699:43 - those areas on behalf of your C code on
699:46 - Unix and Unix like systems the memory
699:48 - allocation layer asks the underlying
699:50 - operating systems for blocks of memory
699:52 - through the sbrk
699:55 - interface even with virtual memory
699:57 - programmers must carefully manage their
699:59 - use of dynamically allocated memory
700:01 - because memory is never
700:04 - unlimited section 6.7 Fields when
700:08 - storage space is at a premium it may be
700:10 - necessary to pack several objects into a
700:12 - single machine word one especially
700:15 - common use is a set of single bit app
700:17 - flags and applications like compiler
700:19 - symbol tables externally imposed data
700:22 - formats such as interfaces to Hardware
700:24 - devices also often require the ability
700:27 - to get at pieces of a
700:29 - word as an aside we are going to go now
700:33 - from lowlevel programming to even lower
700:35 - level programming the Unix operating
700:38 - system is written in C and Unix needs to
700:40 - have for example an implementation of
700:42 - the internet Pro protocol so it can be
700:44 - connected to the internet one of the
700:46 - most important internet protocols is the
700:48 - transmission control protocol
700:51 - TCP in order to implement TCP you need
700:54 - to send very precisely formatted data
700:56 - across the network the data is very
700:58 - tightly packed in order to save precious
701:00 - Network bandwidth the exact format of a
701:03 - TCP header is described in the TCP
701:06 - Wikipedia page if you look at the header
701:09 - you will find that it bits 96 through 99
701:13 - TCP expects a 4-bit integer that defines
701:16 - the data
701:18 - offset exactly what this data means is
701:20 - less relevant unless you're actually
701:22 - writing the TCP implementation but it
701:24 - does demonstrate that we need to control
701:26 - our data layout at times on a bit bybit
701:29 - basis this section covers how we can use
701:32 - struct to build up a TCP header in C
701:35 - which can be parsed and set without
701:37 - using masking and shifting operations
701:39 - with hard-coded numbers the section
701:41 - below is simpler than constructing a
701:42 - valid TCP header using a carefully pack
701:44 - struct but it does lay the groundwork
701:46 - for these more complex
701:48 - situations now back to the
701:51 - text imagine a fragment of a compiler
701:54 - that manipulates a symbol table each
701:56 - identifier in a program has certain
701:58 - information associated with it for
702:00 - example whether or not it's a keyword
702:03 - whether or not it's external Andor
702:04 - static and so on the most compact way to
702:07 - encode such information is a set of one
702:09 - bit Flags in a single Char or int the
702:12 - usual way this is done is Define a set
702:14 - of masks corresponding to the relevant
702:17 - bit positions as in pound Define keyword
702:21 - 01 pound Define external 02 and pound
702:24 - define static 04 the numbers of course
702:27 - must be powers of two so that the
702:29 - shifting works then accessing the bits
702:32 - become a matter of bit fiddling with
702:34 - shifting masking and complimenting
702:36 - operators which were described in
702:37 - Chapter 2 certain idioms a appear
702:41 - frequently Flags vertical bar equals
702:44 - external vertical bar static turns on
702:47 - the external and static bits in Flags
702:49 - while flags and percent equal till open
702:53 - pen external or static closed pen
702:55 - semicolon turns them off and if open pen
703:00 - open pen Flags Amper sand pen external
703:04 - vertical bar static Clos pen Clos pren
703:06 - equal equals zero dot dot dot is true if
703:10 - both bits are off although these iums
703:13 - are readily mastered as an alternative C
703:16 - offers the capability of defining and
703:18 - accessing Fields Within A Word directly
703:21 - rather than by bitwise logical operators
703:24 - a field is a set of adjacent bits within
703:26 - a single int the syntax of field
703:29 - definition and access is based on
703:31 - structures for example the symbol table
703:34 - pound defines above could be replaced by
703:36 - the definition of three Fields struct
703:40 - unsigned is keyword colon one
703:43 - semicolon unsigned is extern colon one
703:47 - semicolon unsigned is static colon one
703:51 - semicolon closed curly brace Flags this
703:55 - defines a variable called flags that
703:57 - contains three onebit Fields the number
704:00 - following the colon represents the field
704:02 - width in bits the fields are declared
704:05 - unsigned to emphasize that they are
704:07 - really unsigned quantities individual
704:10 - fields are referenced as flags. is
704:13 - keyword flags. is extern ETC just like
704:16 - other structure members Fields behave
704:19 - like small unsigned integers and may
704:21 - part participate in arithmetic
704:23 - Expressions just like the other integers
704:25 - thus the previous examples may be
704:27 - written much more naturally as Flags is
704:31 - underscore extern equals Flags is static
704:35 - equals 1
704:36 - semicolon turn the bits
704:40 - on flags is exter equals Flags is static
704:44 - equals 1 semicolon to turn the bits on
704:47 - flags. is extern equals flags. is static
704:51 - equals z turns them off and if open prin
704:56 - flags. is extern double equals 0 and
704:59 - flags. is static double equals z close
705:01 - print dot dot dot to test
705:04 - them a field may not overlap an INT
705:07 - boundary if the width would cause this
705:09 - to happen the field is aligned to the
705:11 - next int boundary Fields need not be
705:13 - named unnamed Co Fields with a colon in
705:16 - width only are used for padding the
705:18 - special width zero may be used to force
705:21 - alignment to the next int boundary there
705:23 - are a number of caveats that apply to
705:25 - Fields perhaps the most significant
705:27 - fields are assigned left to right on
705:29 - some machines and right to left on
705:31 - others reflecting the nature of
705:33 - different Hardware this means that
705:35 - although fields are quite useful for
705:37 - maintaining internally defined data
705:39 - structures the question of which end
705:41 - comes first have to have has to be
705:43 - carefully considered when picking apart
705:45 - externally defined data other
705:48 - restrictions to bear in mind fields are
705:50 - unsigned they may only be stored in ins
705:53 - or equivalently unsigned they are not
705:55 - arrays and they do not have addresses so
705:57 - the Ampersand operator cannot be applied
705:59 - to them section 6.8 unions a union is a
706:04 - variable which may hold at different
706:06 - times object objects of different types
706:08 - and sizes with the compiler keeping
706:11 - track of the size and alignment
706:13 - requirements unions provide a way to
706:15 - manipulate different kinds of data in a
706:17 - single area of storage without embedding
706:20 - any machine dependent information in the
706:22 - program for example again from a
706:25 - compiler symbol table suppose constants
706:27 - may be in Floats or character pointers
706:31 - the value of a particular constant must
706:33 - be stored in a variable of the proper
706:34 - type yet it is most convenient for table
706:37 - management if the value occupies the
706:39 - same amount of storage and is stored in
706:41 - the same place regardless of its type
706:45 - this is the purpose of a union to
706:47 - provide a single variable which can
706:49 - legitimately hold one of several types
706:52 - as with Fields the syntax is based on
706:55 - structures Union UT tag open curly brace
706:59 - int IAL semicolon float F Val semicolon
707:04 - Char star P valal semicolon Clos curly
707:07 - brace U Val the variable U Val will be
707:11 - large enough to hold the largest of the
707:12 - these three types regardless of the
707:14 - machine it is compiled of compiled on
707:17 - the code is independent of Hardware
707:19 - characteristics any one of these types
707:21 - may be assigned to U Val and then used
707:24 - in Expressions so long as the usage is
707:26 - consistent the type retrieved must be
707:29 - the type most recently stored it is the
707:31 - responsibility of the programmer to keep
707:33 - track of what type is currently stored
707:35 - in Union the results are machine defend
707:38 - dependent if something is stored as one
707:40 - type and extracted as another type
707:43 - syntactically members of a union are
707:46 - accessed as Union name. member or Union
707:50 - pointer right arrow member Justice for
707:54 - structures if the variable U type is
707:56 - used to keep track of the current type
707:58 - start in U Val then one might see code
708:00 - as if open pin you type double equals
708:04 - int Clos pen print F pen double quot
708:09 - percent d/n double quot comma U
708:13 - IAL close paren semicolon else if open
708:17 - paren U type double equal float close
708:19 - paren print F open PR double quote
708:23 - percent F sln double quot comma U val.
708:27 - fval close pen semicolon else if open
708:31 - pen U type double equal string close pen
708:34 - print F double quote percent s back sln
708:38 - double quote comma U val. pval close PR
708:41 - semicolon else print F open print double
708:45 - quote bad type percent D and U type back
708:48 - sln double quot comma U type Clos pren
708:54 - semicolon unions may occur in structures
708:58 - and arrays and vice versa the notion for
709:01 - accessing a member of a union in a
709:03 - structure or vice versa is identical
709:05 - that to that for nested structures for
709:08 - example in the structure array defined
709:10 - by struct open curly brace Char star
709:14 - name semicolon int Flags semicolon int
709:18 - utype semicolon Union open curly brace
709:22 - int IAL semicolon float F Val semicolon
709:26 - Char star P Val semicolon Clos curly
709:30 - brace U Val semicolon Clos curly brace
709:33 - Sim tab open square bracket n Sim close
709:37 - square bracket
709:38 - semicolon the variable IAL is referred
709:41 - to as simab
709:44 - sub. val. IAL and the first character of
709:48 - the string P Val by star simab
709:52 - sub.
709:54 - U.P in effect a union is a structure in
709:57 - which all the members have offset zero
710:00 - the structure is big enough to hold the
710:02 - widest member and the alignment is
710:04 - appropriate for all types in the Union
710:07 - as with structures the only operations
710:09 - currently permitted on unions are access
710:11 - accessing a member and taking the
710:12 - address unions may not be assigned to
710:15 - passed to functions or returned by
710:17 - functions pointers to unions can be used
710:19 - in a manner identical to pointers to
710:23 - structures as an aside the above
710:25 - limitations on unions are just no longer
710:27 - accurate like structures modern C
710:29 - compilers can assign the contents of the
710:31 - Union to another Union variable you can
710:34 - also pass unions into functions by value
710:36 - and receive a union as the return type
710:39 - of a function the storage allocator in
710:41 - chapter 8 shows a union can be used to
710:44 - force a variable to be aligned on a
710:46 - particular kind of storage
710:48 - boundary section 6.9 typ def C provides
710:53 - a facility called type def for creating
710:55 - new data type names for example the
710:59 - Declaration typed def space int space
711:02 - length semicolon makes the name length a
711:06 - synonym for
711:07 - INT the the type length can be used in
711:10 - declarations casts Etc in exactly the
711:13 - same ways int can be length Len comma
711:17 - Max Len semicolon length star lengths
711:20 - open square bracket close square bracket
711:23 - semicolon similar the Declaration type
711:27 - def Char star string semicolon makes
711:32 - string a synonym for Char star or a
711:35 - character pointer which then may be used
711:37 - in declarations like string P comma line
711:41 - PTR open square bracket lines closed
711:44 - square bracket comma Alec open pen
711:46 - closed pen
711:47 - semicolon note that the type being
711:50 - declared in a type def appears in the
711:52 - position of a variable name not right
711:55 - after the word type def syntactically
711:58 - type def is like the storage class
712:01 - extern static Etc we've used uppercase
712:05 - letters in these examples to emphasize
712:07 - the
712:08 - names a more complicated example we
712:11 - could make type deps for the tree nod
712:13 - shown earlier in the tra
712:15 - chapter type def struct T node open
712:18 - curly brace Char star word semicolon int
712:22 - count semicolon struct T node star left
712:26 - semicolon struct T node Star right
712:30 - semicolon Clos curly brace tree node
712:34 - comma star tree
712:37 - PTR this creates three two new type
712:40 - keywords called tree node which is a
712:42 - structure and tree PTR which is a
712:45 - pointer to the structure then the
712:47 - routine tallic could become tree PTR T
712:51 - alic open PR Clos print open curly brace
712:54 - Char star Alec open print Clos PR
712:57 - semicolon return open print open print
713:00 - tree PTR Clos print Alec open print size
713:05 - of open print tree node close print Clos
713:08 - print close print semicolon close curly
713:11 - brace it should be emphasized that a
713:14 - type def declaration does not exactly
713:16 - create a new type in any sense it merely
713:20 - adds a new name for some existing types
713:22 - nor are there any new semantics
713:25 - variables declared this way have exactly
713:27 - the same property as variables who whose
713:29 - declarations are spelled out explicitly
713:32 - in effect type def is like toine except
713:36 - that since it's interpreted by the
713:37 - compiler it can cope with textual
713:39 - substitutions that are beyond the
713:41 - capabilities of the C Macro
713:44 - preprocessor for example typ def int
713:48 - open PR star PFI Clos print open print
713:53 - Clos print semicolon creates the type
713:56 - PFI to mean pointer to a function
713:59 - returning integer which can be used in
714:02 - contexts like PFI stir comp comma num
714:06 - comp comma swap in the sort program in
714:09 - chapter 5 there are two main reasons for
714:12 - using type def
714:14 - declaration the first is to parameterize
714:16 - a program against portability problems
714:18 - if type defs are used for the data types
714:21 - which may be machine dependent only type
714:24 - deps need to change when the program is
714:25 - moved one common situation is to use
714:29 - type def names for various integer
714:31 - quantities and then make an appropriate
714:33 - set of choices of short int and Lawn for
714:37 - each host
714:38 - machine the second purpose of type defs
714:41 - is to provide better document mentation
714:43 - for a program a type called tree PTR may
714:46 - be easier to understand than one
714:49 - declared only as a pointer to a
714:51 - complicated
714:52 - structure finally there's always the
714:54 - possibility that in the future a
714:56 - compiler or some other program such as
714:58 - Lind may make use of the information
715:01 - contained in typed def declaration to
715:03 - perform some extra checking on the
715:07 - program this work is based on the 1978 C
715:11 - programming book written by Brian W
715:13 - kernigan and Dennis M Richie their book
715:16 - is copyright All Rights Reserved by AT&T
715:19 - but is used in this work under fair use
715:22 - because of the book's historical and
715:23 - scholarly significance its lack of
715:26 - availability and the lack of an
715:28 - accessible version of the book the book
715:30 - is augmented in places to help
715:32 - understand Its Right Place in a
715:33 - historical context amidst the major
715:35 - changes of the 1970s and 1980s as
715:39 - computer science evolved from a hardware
715:41 - first vendor centered approach to a
715:43 - software centered approach where
715:45 - portable operating systems and
715:46 - applications written in C could run on
715:48 - any
715:50 - hardware this is not the ideal book to
715:52 - learn SE programming because the 1978
715:55 - Edition does not reflect the modern sea
715:57 - language using an obsolete book gives us
715:59 - an opportunity to take students back in
716:01 - time and understand how the sea language
716:04 - was evolving as it laid the groundwork
716:06 - for a future with portable applications
716:12 - [Music]
716:26 - hello and welcome to objectoriented
716:28 - patterns a historical perspective we're
716:31 - going to cover a number of different
716:32 - things in this lecture first we're going
716:34 - to do a bit of review of object
716:35 - orientation from previous courses that
716:38 - we're going to take a look at historical
716:39 - perspective across a bunch across time
716:41 - and a bunch of different programming
716:43 - languages important the important part
716:45 - about that is that object orientation is
716:47 - a concept it's not just a syntax and so
716:50 - by looking at different syntaxes we'll
716:52 - have a better understanding of the
716:53 - underlying concept then what we're going
716:55 - to do is we'll look at how one might
716:57 - have used C to build object Orient
716:59 - support into a language like say python
717:02 - for example or C++ and then we're going
717:05 - to look at building a python string
717:07 - class in C a python list class in C and
717:10 - then a python dictionary class in C sort
717:13 - of showing how C is also the foundation
717:16 - of most modern object-oriented
717:19 - languages so if you take a look at the
717:22 - other courses that I've taught I have
717:24 - been teaching objectoriented if you
717:26 - taken my courses I have been teaching
717:27 - you object orientation for a long time
717:30 - one of the things you'll notice is that
717:32 - um I just keep coming back to it if you
717:35 - look at python for everybody chapter 14
717:37 - is about object orientation I I claim
717:40 - that Django for everybody is is really a
717:42 - class and object orientation because D
717:44 - Jango itself is a a collection of
717:48 - cooperating objects you you create Jango
717:51 - applications by creating objects that
717:53 - are being sent messages which is very
717:55 - much a purely objectoriented concept I
717:59 - cover object oriented JavaScript
718:01 - particularly because JavaScript is a
718:02 - little bit different I cover that in
718:04 - both Django for everybody and in web
718:06 - applications for everybody and so we're
718:10 - going to take a look at all these
718:12 - different uh syntaxes of object
718:14 - orientation and then we're going to try
718:16 - to build our own objects but in a non-ob
718:19 - Orient language IE C I am not going to
718:22 - teach you object orientation in this
718:24 - lecture I am going to do a very very
718:26 - brief review on my other lectures mostly
718:29 - what I wanted you to know was
718:30 - terminology so the most important
718:32 - terminology is a class A Class is not an
718:34 - object it's a template to make objects
718:36 - it's like the cookie cutter in the
718:38 - cookie methodology an attribute is some
718:40 - data that you can contain in each
718:42 - instance of the class and a method is
718:44 - some code like a function that operates
718:46 - within the context of the instance of
718:48 - the class the object is a particular
718:51 - instance of the class Stamped Out from
718:53 - the class when a new instance of the
718:55 - class is requested so you have one class
718:57 - then you have many many instances so if
719:00 - you do a userdefined class in Python you
719:03 - see that we have a special keyword class
719:07 - which is different than defa and within
719:09 - it we have attributes and we have
719:12 - methods so the methods look like
719:14 - functions but in particular the methods
719:17 - inside of a class always have this first
719:20 - parameter which by convention we call
719:23 - Self you could call literally anything
719:25 - else but if you did people would be
719:26 - confused because the convention is so
719:29 - strong that SF is always the first
719:33 - parameter of every method inside a
719:35 - python so in it is the instance and then
719:39 - two parameters and then we can look at
719:42 - attributes like self.x and self.y and
719:46 - then assign them in this case to the X
719:48 - and Y from the call so we have a couple
719:51 - of methods like def dump and again a
719:54 - dump itself is a zero parameter method
719:57 - but it always has the instance and then
720:00 - we look within it we can say self.x and
720:03 - self.y and look at all the attributes
720:05 - and we can use the ID function which we
720:07 - learned in the last chapter which is
720:09 - kind of like an address lookup function
720:11 - in Python and so what we have here is we
720:13 - have a little method called origin which
720:15 - takes the distance for our point from
720:17 - the origin to our point and takes the
720:19 - square root of the the two sides of the
720:21 - triangle squared so if we then get out
720:23 - of the the class definition and move
720:26 - into the actual code we call PT equals
720:30 - 4050 that is how we call the Constructor
720:33 - point is the class name and then the
720:36 - parameters to the Constructor are four
720:37 - and five in that example point. dump
720:40 - that's the dump method inside a point
720:43 - and you can pass the parameter PT which
720:46 - is the instance so PT ends up being the
720:48 - instance of this point object but the
720:51 - more common syntax is to not use the
720:53 - class name and the method name and
720:55 - explicitly pass self in but instead in
720:58 - the next line we see print origin and
721:00 - then pt. origin well pt. origin is
721:03 - expanded to point. origin and then the
721:07 - first first parameter is kind of added
721:09 - on which is PT which is the instance now
721:14 - I've got a Dell Dell parentheses PT
721:16 - closed parentheses and that is the
721:18 - destructor now in Python the destructor
721:21 - would get run automatically at the end
721:22 - of the program so in this case that
721:24 - Destructor is a little bit redundant so
721:27 - now I want to take a bit of a historical
721:28 - look at object orientation so if you've
721:32 - seen any of my other classes I try to
721:34 - put the programming languages that were
721:36 - learning in context and these are the
721:38 - common programming languages like Python
721:40 - and PHP and
721:42 - JavaScript and now we're teaching C and
721:46 - so if you look at this the idea is is
721:48 - you can see that the language C has been
721:52 - the inspiration for virtually all of the
721:54 - modern languages that we we use today
721:57 - and that I've taught you um python
722:00 - inspired is INS while the syntax of
722:02 - python doesn't look like C python has
722:05 - been inspired we see things like there's
722:07 - formatted printing that talks directly
722:09 - to the underlying C implementation
722:11 - because cpython not every python but the
722:13 - C python that we normally use is written
722:16 - in C so c as we've said many times in
722:19 - this class already is profoundly
722:22 - influential in the syntactical evolution
722:25 - of procedural programming language so
722:27 - we've seen this before but if we think
722:29 - about object orientation object
722:31 - orientation the inspiration and
722:33 - evolution of object orientation really
722:35 - took sort of a different path through a
722:37 - bunch of languages that you may or may
722:40 - not have seen or heard so the oldest
722:43 - language on this is Fortran in 1955 and
722:46 - alal 60 UH alol 60 I don't have it
722:49 - marked as like that alol 60 was inspired
722:52 - by Fortran uh Fortran um but probably
722:55 - the better thing to say was that alol 60
722:57 - was created in spite of Fortran so
723:00 - Fortran was loved by some and not loved
723:02 - by others and alol 60 is more what the
723:05 - computer scientist of the day in 1960
723:09 - decided so there's a a series of
723:12 - languages that were popular in computer
723:15 - science but not necessarily popular in
723:17 - general purpose programming like uh
723:19 - simulus 67 which took a lot of the
723:21 - objectoriented ideas from um elal 60 and
723:25 - um Pascal which is a procedural language
723:28 - which is another language that uh I
723:30 - learned in the in the 70s when I was
723:32 - going to school and um if you look for
723:36 - so so algol and simula were languages
723:39 - that were mostly procedural but had
723:41 - objectoriented Concepts in them I always
723:44 - think of the most objectoriented
723:45 - languages as small talk it it you know
723:48 - it's not necessar the first one but it
723:49 - feels like it's the one that developed
723:52 - the notion of object orientation the
723:54 - most but it it really took inspiration
723:56 - from an earlier language which was lisp
723:59 - and so lisp was an early early 1960
724:02 - interpreted language uh lisp was often
724:04 - thought of as the foundations of
724:06 - artificial intelligence now scheme in
724:09 - 1975 was a direct derivative of lisp
724:13 - inspired by Lis kind of the next
724:14 - generation of lisp 15 years later and it
724:16 - had a bunch of objectoriented Concepts
724:18 - in it as well and so you can kind of see
724:23 - where where the object-oriented notation
724:28 - the object-oriented Notions were
724:29 - evolving kind of independently from the
724:33 - preferred syntax and in the' 70s when C
724:37 - came along it really
724:39 - changed the way we think of a syntax and
724:43 - so it inspired C++ inspired Java
724:46 - JavaScript C and
724:49 - PHP but then what happened is each of
724:51 - these things kind of took different
724:53 - inspiration from different object
724:56 - orientation so there's a there's really
724:58 - almost
725:00 - independent inheritance of where the
725:03 - inspiration for the language came from
725:05 - versus where the inspiration for the
725:06 - objectoriented pattern and probably the
725:08 - biggest thing that you see is C++ which
725:11 - is early 80s took its inspiration both
725:14 - from simula and from C so it it it was
725:17 - the a hybrid language that tried to take
725:20 - the object-oriented notations from
725:22 - simula and layer them on top of the
725:25 - procedural syntax of C now another
725:29 - interesting thing here is is that python
725:31 - in
725:32 - 1991 um was quite aware of C++ and so if
725:36 - you look at a PHP which in 1995 was not
725:39 - at all object oriented it wasn't object
725:41 - oriented till 2000 python was
725:44 - objectoriented in sort of almost 1991 92
725:47 - because the computer scientist of the
725:50 - day were quite aware of these kinds of
725:52 - things and so python sort of implemented
725:56 - object orientation almost as soon as
725:58 - python was
726:00 - implemented and so like I said python
726:02 - 1991 implemented object orientation and
726:06 - I I really like the object orientation
726:07 - in Python PHP implemented non-ob
726:10 - oriented '95 but then added objects in
726:13 - 2000 Java took a lot of inspiration from
726:16 - C++ Java was trying to be the next C and
726:20 - so it's got a lot from C it's got a lot
726:22 - from
726:23 - C++ and then C Shar was inspired by C++
726:27 - and Java but then JavaScript is kind of
726:29 - like the outlier JavaScript even though
726:32 - it came out in 1995 and was very much
726:35 - informed by Java it took its
726:37 - object-oriented pattern more from scheme
726:40 - which is a more pure object orientation
726:43 - rather than an objectoriented layer and
726:45 - so JavaScript among all of these things
726:48 - that we'll look at JavaScript is sort of
726:51 - the outlier in terms of its object and
726:53 - approach and if you've taken classes for
726:55 - me in the past I've mentioned that
726:57 - before because JavaScript has first
726:59 - class functions and the way you create
727:01 - things etc etc etc so we're going to
727:03 - take a look at some of these object Jo
727:05 - implementations over over time I've
727:07 - already talked about the python
727:08 - inspiration I flip Python and C++ Plus
727:12 - in the early days because at least
727:13 - python we kind of know um C++ is 1980
727:18 - Java ' 95 JavaScript in 95 PHP in 2000
727:23 - and then C in 2001
727:31 - [Music]
727:43 - n
727:45 - [Music]
728:15 - it was highly collaborative in the sense
728:17 - that this was a group of you make up a
728:19 - number 30-ish people who were all
728:21 - interested in much the same kinds of
728:23 - things although with tentacles off into
728:25 - you know theoretical computer science
728:26 - math and so on uh physical sciences kind
728:28 - of thing but mostly a lot of us at least
728:31 - we're we basically software people BNA
728:34 - came to uh B Labs I think in 1979 after
728:38 - getting his PhD at Cambridge um and he
728:41 - was interested in simulation you know he
728:44 - known uh simula in particular which was
728:47 - an object probably one of the very first
728:49 - object-oriented languages and he wanted
728:51 - to do simulation but C was kind of the
728:54 - language that people used at Bell labs
728:57 - and so what he did was to try and take
729:00 - some of the good ideas from SIM in
729:02 - particular class ideas and put that on
729:06 - top of c and for a long time the
729:09 - implementation of C++ was B basically
729:11 - translate C++ into C and then you could
729:14 - run it anywhere so it's one of many
729:16 - pragmatic engineering decisions that BNA
729:19 - made that if you want it's hard to get
729:22 - people to buy into a new language if
729:24 - they have to carry an enormous amount of
729:26 - infrastructure and support and other
729:28 - baggage with it whereas if it's one more
729:31 - program that then fits perfectly into
729:33 - your existing environment as a language
729:35 - as libraries and all the rest of it much
729:38 - easier and so C went through a period of
729:41 - evolu well it's still evolving uh but
729:46 - starting there in the very early you
729:49 - 1980 81 something like that the two
729:53 - languages were very much together
729:55 - because we're all in this one group and
729:56 - Babs would fit comfortably in this
729:58 - Corridor this building um
730:02 - and be which certainly new see inside
730:05 - out and then was developing this new
730:08 - language that ran on top of it that
730:10 - stressed C compilers so that was useful
730:13 - because the code that that his
730:15 - pre-processor generated was
730:19 - astonishing and I think some of the
730:22 - ideas in C++ then retrofitted back into
730:25 - C in particular the obvious one of how
730:28 - you declare the arguments for a function
730:30 - I mean that's just that was
730:32 - better and a handful of other things so
730:35 - for a while the two languages you could
730:37 - say that c was a pretty close perfect
730:41 - subset of
730:43 - C++ uh I think that's evolved in both
730:46 - directions and so it's less true now
730:48 - than it was but for a long time you
730:49 - could take a seek program and just run
730:51 - it through a C++ compiler and it would
730:53 - work there's a general observation
730:56 - that people write code differently than
730:59 - computers write code and so machine
731:01 - generated code tends to
731:04 - stress in particular the compiler or the
731:06 - language for which you're generating and
731:08 - and so in the C++ to C example were you
731:11 - know incredibly deeply nested constructs
731:14 - of one sort or another you know
731:17 - parentheses that made lisp look tame um
731:20 - and then very convoluted pointer kinds
731:23 - of computations as well function
731:25 - pointers all kinds of and so it was
731:27 - definitely a stress test and also
731:29 - generating things that had odd sizes and
731:31 - so on that were not expected or at least
731:34 - paths that had maybe not been thoroughly
731:36 - tested in a given compiler I think a lot
731:39 - of people did not think that C+ plus was
731:42 - right in some sense it had various warts
731:45 - blemishes and so on many of those were
731:48 - again direct result of be's engineering
731:51 - judgment if you want this thing to take
731:53 - off the more culturally compatible it is
731:56 - the more likely it will do that if you
731:57 - make something that's wildly different
731:59 - people are going to kind of ignore you
732:01 - and so um and so some of the syntactic
732:05 - problems of C++ that are still with us
732:08 - are you know the same syntactic problems
732:11 - that usually can see for quite a while
732:13 - when I was trying to teach C++ to people
732:16 - I would show them the translation that
732:18 - goes from a C+ plus object into C and
732:21 - you know it's basically just pointers
732:23 - into structures with the compiler kind
732:25 - of keeping the names apart so you don't
732:26 - have to think about them and and seeing
732:29 - that translation you could see how
732:31 - objectoriented programming could be done
732:33 - at essentially no overhead because it's
732:35 - just structure pointers and um and funny
732:40 - function name and you can pass function
732:42 - pointers around and so it was all pretty
732:45 - well behaved and I think that understand
732:47 - I mean it helped me understand what was
732:48 - going on in C++ and objectoriented
732:53 - programming and so
732:55 - on I think in modern languages and
732:58 - python a fine example of that there's an
733:00 - incredible amount of magic going on
733:02 - there and I don't quite know how it's
733:04 - done as well as it is I mean I can sort
733:07 - of Imagine but but the mechanisms to
733:09 - make some of those things list
733:11 - comprehensions with lambdas in them and
733:13 - so on I how the heck does that work
733:17 - [Music]
734:01 - I was trying to characterize what is C++
734:04 - particularly useful for what did I
734:06 - actually build it for and what is its
734:10 - strength today
734:11 - after almost 30 years of
734:14 - evolution and and so and and also
734:16 - where's the limits to where it is so the
734:19 - way I see it is there's a core domain
734:21 - for C++ and uh that's what you would
734:26 - call traditional uh um systems
734:29 - programming but that's not the right
734:32 - term because it's just a style of
734:35 - language and a style of programming so I
734:37 - go a little bit further I said what is
734:39 - it that that that
734:41 - requires the kind of services that C++
734:45 - has what is the sum of all these
734:48 - applications I've been dealing with
734:50 - where did it work and where was it
734:52 - essential and I came up with the phrase
734:55 - infrastructure and I I roughly Define it
734:57 - as if it breaks uh somebody gets hurt or
735:01 - somebody gets ruined these are the kind
735:03 - of
735:04 - foundational uh things in our systems
735:07 - that must work for the system for the
735:10 - societ to work the the the the question
735:14 - I'm trying to phrase is what matters in
735:16 - those areas and I've come up with some
735:20 - Notions of compact data
735:23 - structures um very strongly typed
735:25 - interfaces for maintaining ability and
735:28 - for minimizing
735:29 - errors um a heavier emphasis on
735:33 - algorithms or uh random code because we
735:38 - we need reliability we need the stuff to
735:40 - be comprehensive ible analyzable we want
735:43 - to make sure that it's actually
735:46 - correct and so the paper I was writing
735:49 - come from from that kind of of thinking
735:53 - what is the right Style and what are
735:56 - the supports for that style we need for
735:59 - infrastructure software for for for
736:01 - software that must be dependable and we
736:04 - can get real examples um sort of the the
736:08 - keys of some of the modern operating
736:10 - system the the basics of our phone
736:14 - system the brakes in my
736:17 - car um how do we make that dependable
736:20 - how do we uh make sure that the space
736:23 - probes don't uh get the logical
736:25 - equivalent of the blue screen of death
736:27 - halfway to Mars where we can't send a a
736:31 - repair man how do we make sure that they
736:33 - actually go into the right orbits and
736:36 - JPL lost a um a probe of Mars because
736:42 - two groups um had communicated nicely
736:45 - they thought but in fact one of them
736:48 - spoke Imperial meeses and the other one
736:49 - spoke uh the SI system the MKS system
736:53 - and the result was uh a misn navigation
736:56 - that sent uh more than
737:00 - 500 million worth of equipment into the
737:03 - wrong orbit not not a good idea it was
737:07 - the work of 200 good Engineers lifetimes
737:10 - work down the
737:12 - drain uh and that could have been
737:15 - avoided by an ever so slightly
737:18 - Improvement in the interfaces uh between
737:21 - the parts of that program so things like
737:24 - that I'm interested in so there's a core
737:26 - area where I think the the facilities
737:29 - for C++ the kind of they're not perfect
737:33 - the kind of things I would like the kind
737:36 - of things I work on are essential and
737:38 - then there's a uh huge gray area
737:43 - where uh you have choices they can help
737:46 - in my opinion but they're not essential
737:48 - then you have areas where it uh probably
737:51 - is unsuitable to apply that kind of uh
737:55 - of stringency and technique I mean I I
737:58 - want to essentially get 100% reliability
738:02 - if I'm putting up a small application
738:04 - for my own use or or if somebody is
738:07 - trying to push out a a little cute uh
738:10 - web app they don't need that kind of
738:13 - reliability and maybe what I'm talking
738:15 - about in terms of programming is not for
738:17 - them but I think the really important
738:20 - thing here is that realize that there
738:23 - are different techniques different
738:24 - languages that apply to different areas
738:28 - and we have to recognize this we can't
738:31 - have a single language for everybody a
738:33 - single technique of using that language
738:36 - for
738:36 - everybody um we can't have a single tool
738:39 - chain or single kind of of system um and
738:44 - from there we can go a little bit
738:45 - further we probably don't need the same
738:47 - kind of training for uh education for
738:52 - for everybody the engineer software
738:57 - develop or whatever that is building
739:00 - infrastructure um say the mechanism that
739:04 - automatically updates the software on uh
739:07 - on a cell phone uh has to have a
739:10 - different
739:11 - education different knowledge different
739:13 - training from the one that makes a
739:15 - little
739:16 - game um because the one can actually
739:20 - destroy um a whole day or um or a whole
739:25 - week for millions of people by a little
739:29 - slip um maybe even somebody gets hurt if
739:32 - the 911 calls don't get through bad
739:35 - things happen and it's not just the
739:38 - software that runs on it it's the update
739:40 - software it's anything in the chain of
739:43 - of safety
739:45 - critical uh issues that has to be dealt
739:48 - with but somebody doing that has to
739:51 - think differently from somebody who
739:53 - writes a little application uh maybe to
739:56 - make a couple of of of bucks uh uh
740:00 - quickly uh there's nothing wrong with
740:02 - that but they have to think different as
740:04 - a matter of fact if you apply this very
740:06 - stringent engineering oriented thinking
740:09 - to to little commercial apps you'll
740:12 - probably be a year late to Market and uh
740:15 - it will be irrelevant on the other hand
740:17 - if you took the attitude of of first to
740:20 - Market is the only thing that happens
740:22 - and apply them to uh the steering wheel
740:24 - of my car uh no that's not a good idea
740:29 - these people have to think different and
740:31 - the way you get people to think
740:32 - differently is to is to give them
740:36 - different educations we we don't have an
740:38 - ANC standard programmer and and we
740:40 - shouldn't have if it was we should have
740:43 - several and I think the field has to in
740:46 - some sense clean its up its act before
740:49 - somebody else comes in and try and
740:51 - cleans it up for us this notion that you
740:53 - can sort of make your own constants and
740:55 - have the seconds after the constants is
740:58 - that is that a feature that you added at
741:00 - some intermediate stage or is that
741:03 - simple sort of operator overloading we
741:05 - were observing that we're getting a
741:07 - whole zoo of little suffixes out of uh
741:11 - the various fundamental types so the U
741:16 - suffix is for unsigned and L is for long
741:20 - I think and I can't remember them all
741:22 - anymore and we thought you know you can
741:24 - do anything in C++ but you can't make
741:26 - your own little
741:27 - Ro and then I had observed separately
741:31 - that there was techniques
741:35 - that were effective except that people
741:38 - would not used them because no notation
741:40 - was too ugly uh the Unix example is one
741:45 - of units example is one of those uh
741:48 - you've been able to do everything in the
741:50 - Unix example I showed not quite as
741:53 - elegant but you can do everything showed
741:55 - for the last 10 years libraries have
741:57 - been available uh there was a nice one
742:00 - from firmy Labs back to nice places and
742:03 - nice people again uh but it wasn't used
742:05 - as much as it should because the users
742:08 - didn't believe in the notation they they
742:10 - didn't like it and so we were looking at
742:13 - how can you basically clean up People's
742:16 - Source Code how can we make code look
742:19 - the way it would look in an ideal
742:22 - language how can we make code look much
742:25 - as it does in the textbooks so the units
742:28 - sample is simply a way of getting your
742:30 - code to look uh the way the equations
742:34 - look in your physics textbook I mean we
742:37 - know how to avoid that Mars climate o a
742:40 - problem everybody had been taught it in
742:43 - physics in high school first make sure
742:46 - your units match then do the detail
742:49 - calculation so why didn't people do it
742:51 - it was too combersome and it was too
742:53 - ugly when they did it or too costly if
742:56 - they used um runtime techniques so I uh
743:01 - together with with friends we we thought
743:03 - this problem was worth addressing try to
743:06 - figure out what Solutions we had went
743:08 - through several Evolutions I I think the
743:11 - the last finishing touches was done by
743:14 - David um and it's it's now standard um
743:18 - this is one of the features that is not
743:20 - shipping widely today but wait a year
743:24 - and that that example will probably run
743:27 - your computer too is are there other
743:29 - kind of examples where you've let people
743:32 - um from within a class create their own
743:34 - literals Beyond sort of
743:36 - suffixes when I started out the C++ I
743:39 - provided conr structors which allows you
743:42 - to to construct objects of a certain
743:45 - type from
743:46 - arguments and and that has been very
743:48 - effective and people have used
743:50 - Constructors as um as if they were
743:55 - literals but they weren't there was a
743:58 - runtime cost so the first thing we did
744:01 - with C++ uh Ox C+ plus 11 was we
744:06 - introduced uh constant Expressions as a
744:09 - more fundamental unit this was work
744:12 - between me and my colleague Gabriel d r
744:16 - and we have con exper functions that can
744:18 - be evaluated at compile time and we have
744:22 - conext for types so that you can use
744:24 - type Rd programming at compile time this
744:27 - is very important in sort of the high
744:31 - performance Computing and in the
744:32 - embedded systems world that was what we
744:34 - did to address that constant expression
744:37 - evaluation is much more General much
744:40 - much easier to use and yes more more
744:42 - pretty uh in C++ 11 at an earlier
744:46 - versions so that just strengthens what
744:48 - the direction we've gone
744:50 - before uh so you could write complex one
744:53 - comma uh two to make a complex number in
744:58 - C++ in
745:01 - 1984 um today you can write the same
745:04 - thing and have the complex number uh
745:07 - created
745:08 - at compile sign
745:11 - and therefore say put in ROM I don't
745:13 - know why you would want a complex number
745:14 - on ROM but you might want a point which
745:16 - is the same thing point of what two now
745:20 - you still have to write point or complex
745:23 - and the other uh thread in uh of
745:27 - thinking in C++ work was to generalize
745:30 - and make safer the
745:32 - initialization and so it happens that if
745:35 - you know the type you need like you have
745:38 - a function returning uh a complex number
745:41 - you can simply write open curly 1 comma
745:44 - 2 and it says oh 1 comma 2 is supposed
745:47 - to make you a complex number and it will
745:50 - make a complex number and return it and
745:54 - if you happen to be a compil time you'll
745:55 - do that at compile time so things work
745:58 - together you get better notation you get
746:00 - better performance and anything you can
746:03 - do at compile time works even better in
746:05 - a concurrent system because you can't
746:07 - get a race condition on a constant if
746:09 - it's been calculated before the program
746:12 - starts you can't get the threading
746:13 - problems so open curly means find a
746:17 - Constructor for the thing that I'm about
746:18 - to put this in yes it looks at where the
746:21 - destination is and it says is there a
746:23 - two two parameter Constructor or a three
746:26 - parameter Constructor or whatever or if
746:28 - it's just a struct it'll take the first
746:30 - element and put in the first element and
746:32 - second it does it for a struct as well
746:34 - oh yeah see I should I haven't played in
746:36 - C++ in a while that's a great idea
746:39 - refers to say
746:41 - uniform and
746:44 - uh uniform initialization it's little
746:47 - little initialize if it can and if
746:50 - there's any ambiguity of course finds
746:52 - the ambiguity if you're in a context
746:54 - where the like you're calling a function
746:57 - and the target could be a point or a
747:00 - complex number it's a tough luck go or
747:05 - tell me so the the the error checking
747:08 - has actually been improved C++ 11 is
747:11 - slightly better at finding bugs than
747:15 - C++ uh 98 was I mean I come from the the
747:19 - school of philosophy that says that the
747:22 - compiler is your best friend when you
747:24 - generate um Cod when you build
747:28 - programs
747:30 - and uh to make it your best friend you
747:33 - actually have to have more types if
747:35 - everything is an integer well what can
747:39 - the type system help you you there no it
747:41 - can't if everything is a floating Point
747:44 - number it can't tell you whether it's
747:45 - Imperial or or SI units and you get
747:48 - books so you need type Bridge interfaces
747:51 - and for that you need to be able to
747:53 - build U cheap types basically and
747:55 - flexible types that's easy to use uh
748:00 - simple and so we worked from complex of
748:04 - 1 comma
748:05 - Z One comma two or something like that
748:08 - so curly is is 1 comma 2 and the type is
748:12 - optional only needed when it's needed
748:15 - and then finally we can now write uh if
748:18 - we wanted to uh 1 + 2 I Define I as the
748:26 - uh unit for the um imaginary parts and
748:30 - you get complex arithmetic without ever
748:33 - saying
748:34 - complex it's down in the definition of
748:37 - the ey suffix
748:40 - [Music]
748:58 - so we're going to take a look at some of
749:00 - these objectoriented implementations
749:01 - over over time I've already talked about
749:03 - the python inspiration I flip Python and
749:06 - C++ in the early days because at least
749:09 - python we kind of know
749:10 - um C++ is 1980 Java in '95 JavaScript in
749:15 - ' 95 PHP in 200 and then C in 2001 so
749:21 - here's the example that I uh showed you
749:23 - before uh talked about it before you
749:25 - have a Constructor double underscore
749:27 - andit double underscore with self as the
749:29 - first parameter um
749:31 - self.x the again the key thing is self
749:34 - is by convention self is not a language
749:37 - construct um it just so happens that the
749:39 - first parameter of method calls is to
749:43 - the instance and we almost exclusively
749:45 - use the word self for that that is a
749:49 - very early
749:50 - 1991 implementation of an objectoriented
749:54 - syntax on top of a mostly procedural
749:56 - language now if we take a look at C++
749:59 - C++ was initially implemented as a
750:01 - pre-processing past and it sort of did
750:03 - sort of one for one textual
750:05 - Transformations and so class was not a
750:08 - keyword in the C language
750:11 - public that's not a keyword in the C
750:14 - language there was syntactic
750:16 - transformation that kind of transformed
750:19 - it into C and then run it through the C
750:21 - compiler and so we say I mean and this
750:23 - is this is pretty elegant and you can
750:25 - absolutely see how python was inspired
750:29 - by C++ so class Point open curly brace
750:34 - uh double X and Y are the attributes and
750:37 - the Constructor by convention is the
750:40 - exact it's a function that has no type
750:43 - the Constructor is the exact same name
750:46 - as the class so in this case I've got
750:48 - point with an uppercase p and then the
750:50 - Constructor parameters um come in now
750:54 - the interesting thing is as you have to
750:56 - declare as double X and Y as the
750:58 - attribute variables and then within the
751:00 - function you can think of the double XY
751:03 - as almost like xter scope means they're
751:05 - Global across all functions so you have
751:07 - this weird thing where you can't have AE
751:09 - parameter like you could in Python you
751:12 - can't have a parameter the same name as
751:15 - an instance variable or you'll be
751:17 - confused and so you'll notice I called
751:18 - the XC and YC as my parameter variables
751:22 - so that I know that those are um
751:24 - parameters in the Constructor and so I
751:25 - can copy XC into X and YC into
751:29 - Y and um it also means if you look at
751:32 - the dump code you see like you don't
751:34 - have to say self.x you don't you just
751:35 - say X and Y because X and Y are doubles
751:38 - they're instance y extern variables as
751:41 - it were and the same is true in the the
751:43 - origin function that's returning the otk
751:45 - of x^2 + y^2 you don't have to have self
751:49 - or this or anything else so if we take a
751:52 - look at the main program on that first
751:54 - line Point PT open pin 4.0 comma 5.0 we
751:59 - are both allocating uh a point instance
752:03 - and uh calling the Constructor and
752:05 - setting it up then we use the dot syntax
752:08 - pt. dump open PR close close print
752:10 - semicolon uh to dump it out and then we
752:13 - can call pt. origin and then that will
752:16 - return us a uh double and so you'll see
752:20 - this sort of dot syntax um that that is
752:24 - becomes pretty common in every every
752:26 - language that comes afterwards so let's
752:28 - take a look at Java now recall that Java
752:31 - was inspired both by C and C++ and
752:34 - really wanted to be like the super
752:37 - language and you see that it looks a lot
752:39 - like like C++ but it does introduce the
752:41 - concept of this so that it Scopes the
752:45 - external variables that are the instance
752:47 - variables you access an instance
752:49 - variable by saying this.x and this.y
752:52 - rather than just X and Y and I I think
752:54 - it's actually more elegant this
752:56 - way so we say public class point and
753:00 - then double X comma Y which are the
753:01 - instance variables and then the the
753:03 - Constructor is using the C++ Convention
753:06 - of point with no type uh double x and
753:09 - double y are the two parameters this dox
753:12 - equals X and thisy equal Y close close
753:16 - curly brace now I I like this better
753:18 - because the this using this does not uh
753:21 - keeps me from having to make weird
753:23 - function parameter variable names I can
753:26 - make them what I want to be and this is
753:28 - the way using this is the way that we
753:30 - contextualize that so if we look at the
753:32 - dump method we see um the use of this uh
753:37 - and and this is not just by convention
753:40 - this is a language element so this is
753:43 - the pointer uh you'll see you can see
753:45 - from the output um it actually prints
753:48 - out the class that it is and some kind
753:50 - of uh reference like ID like thing and
753:54 - so Java actually if you start printing
753:56 - objects out it tells you what its type
753:58 - and what instance it is it's not
754:00 - necessarily an address but it probably
754:02 - is related to the address somehow but
754:04 - then we print out this.x and this doy
754:06 - and then if we look at the Double origin
754:08 - method we see it's this.x time this.x
754:12 - plus this.y * this.y so you see the sort
754:14 - of use of of this throughout then if we
754:18 - look at the main program we see Point PT
754:21 - equals new point 4.0 comma
754:24 - 5.0 this is where we see the use of this
754:27 - new operator where you're saying look
754:29 - call The Constructor and I like this I I
754:32 - like the sense that you're you're
754:34 - calling the Constructor on purpose
754:36 - you're not calling it implicitly and
754:39 - then you end with PT as the instance of
754:41 - this object and so for me uh this feels
754:45 - pretty good pt. dump is a good example
754:47 - of calling a method within the instance
754:50 - and pt. origin uh is uh similar if we
754:53 - take a look at JavaScript and recall
754:55 - that JavaScript is the weird one
754:57 - JavaScript did not take its inspiration
754:59 - from C++ c++'s
755:03 - syntax was kind of influenced by the
755:07 - fact that it was initially a a
755:08 - pre-processor to the language would see
755:10 - and it some would some computer
755:12 - scientists would think that that's a
755:14 - rather impure way to think about object
755:16 - orientation and so the JavaScript when
755:19 - it was created the idea was is to be
755:22 - more pure in object orientation and so
755:25 - the concept of first class functions
755:27 - there is because it has first class
755:30 - functions there is no class keyword the
755:34 - class keyword was really useful when it
755:36 - was a
755:38 - pre-processor the thing that uh
755:40 - JavaScript does take is the concept of
755:42 - this now the interesting thing is if you
755:45 - look at everything on the screen from
755:46 - function point to the closed curly brace
755:50 - this is the
755:52 - Constructor The Constructor constructs
755:55 - everything it constructs the attribute
755:57 - variables and it actually constructs all
755:59 - the methods as well so if we look at the
756:01 - line this.p party equals function open
756:04 - print Clos print open curly brace we are
756:07 - setting in a sense a attribute variable
756:11 - to source code this is an anonymous
756:14 - function there's no name to the function
756:15 - so most functions are named but this
756:17 - function has no name that's a JavaScript
756:20 - thing it's a first class function thing
756:22 - we are basically not running that
756:24 - function with the two lines of this.x
756:25 - equals this.x plus1 and console.log blah
756:28 - blah blah those lines aren't running
756:30 - they're being compiled and then they're
756:32 - being the code to execute that is being
756:35 - assigned into the attribute variable
756:38 - party so so it doesn't run it it reads
756:41 - it and stores it in party you can
756:43 - literally later print out this. party
756:45 - and you will see the source code to that
756:48 - function and the same is true for this.
756:51 - dump it's an assignment statement and
756:54 - then similarly this. origin and you see
756:57 - within those methods you see this.x and
756:59 - this.y which is taken directly from uh
757:03 - job we also see the concept of new in PT
757:07 - equals new. 4.0 5.0 we're explicit and I
757:11 - like this I like the idea of saying
757:13 - please call the Constructor from the
757:14 - point class and pass these two variables
757:16 - in and then we see the C++ inspired
757:20 - syntax of pt. dump to call a method in
757:23 - the PT instance and pt. origin to call a
757:26 - method in uh instance if we look at PHP
757:31 - now the key to PHP was is PHP is a
757:34 - procedural
757:35 - language uh when it was created in uh in
757:38 - '94 and then it became an objectoriented
757:40 - language in PHP 4 and then five it was
757:44 - late to the party so it could be
757:46 - inspired by everything by JavaScript by
757:49 - Java by by um by C++ by simula by scheme
757:54 - all of those things and so the PHP
757:57 - object orientation is is kind of pretty
757:59 - as a result of that now one of the
758:01 - things that happens in PHP is it's got
758:04 - some weird language syntax things in
758:08 - that variables have have to start with a
758:10 - dollar sign thank you Pearl for that um
758:14 - and the dot operator is used for
758:16 - concatenation in PHP so we couldn't use
758:19 - the dot operator to look up instance
758:22 - variable or a method inside of an
758:24 - instance PHP borrowed the C Arrow
758:28 - operator which is minus sign greater
758:30 - than now the interesting thing is is if
758:32 - you go back to pointers the the arrow
758:34 - operator is what you do when you have a
758:38 - pointer to a structure
758:40 - and so in some ways that is a throwback
758:42 - to see in a beautiful way because I
758:44 - think kind of under the covers and as we
758:46 - shall C when we are starting to
758:49 - implement object orientation in C
758:51 - ourselves we're going to see that pretty
758:53 - much we get pointers to an instance is a
758:56 - pointer to something rather than a thing
758:59 - and so we we see this this Arrow x
759:02 - equals dollar X and the Constructor we
759:04 - see the Constructor is a double
759:06 - underscore construct so the um uh PHP
759:09 - kind of use the single underscore and
759:10 - double underscore as sort of metadata
759:13 - about the meaning of things and double
759:15 - underscore are things you're not
759:16 - supposed to call they're supposed to be
759:17 - private and then we have a function dump
759:19 - and you see the concepts of this inside
759:22 - of dump and origin you see this in the
759:24 - main code you see dollar PT equals new
759:27 - 4050 well it's following the new from
759:30 - Java and others and then we call PT
759:32 - Arrow dump dump and then dollar PT Arrow
759:35 - origin it pretty much works like most of
759:37 - the other ones except that You' never
759:39 - use dot because dot is concatenation in
759:42 - PHP and I'll be honest I love dot for
759:45 - concatenation except for the fact that
759:47 - PHP is different than every other
759:48 - language that I use every other language
759:50 - uses Plus for concatenation of strings
759:53 - now C is a 2001 so C was inspired kind
759:57 - of by everything and so you see that c
760:00 - is uh clearly very C++ oriented but with
760:05 - some javess to it so you see the double
760:08 - XY in the class which is the uh two
760:11 - instance variables you also see that not
760:13 - there's no use of this and so you see
760:17 - that we have to name the parameters
760:19 - differently because X and Y are in
760:21 - effect Global across the entire class
760:25 - and then we have you know void dump
760:27 - there and then we see that it's just
760:28 - using X and Y no need to use this it's
760:31 - it's tough for me to decide which of
760:33 - these two ways I like better um I guess
760:37 - that this is this feels more explicit to
760:39 - me um so I like Java and JavaScript in
760:42 - that respect self in the I like self
760:45 - also if we look at the origin function
760:47 - we see um X starx and plus y star Y and
760:51 - so we don't need to use this we again
760:53 - see a very uh Java oriented Point PT
760:56 - equals new Point open pren 4.0 comma 5.0
760:59 - know point. dump we're using the dot
761:02 - operator to look at instance variables
761:04 - and methods within the uh within the
761:06 - class and then point. origin so now that
761:08 - we've looked at sort of a survey of the
761:10 - different kinds of object-oriented
761:12 - languages that are that are today and we
761:15 - can sort of see how they derived ideas
761:17 - from one another now we're going to
761:18 - actually try to build an object in a
761:21 - non-object oriented language so we're
761:22 - going to build like a python object in C
761:32 - [Music]
761:38 - so now what we're going to do is we're
761:39 - going to try to build objects in C C
761:41 - doesn't have obor support so in a sense
761:43 - we're going to do it by writing
761:45 - functions and using structures and
761:46 - pointers Etc so we're kind of answering
761:50 - the question about how was Python's
761:52 - object-oriented layer layered on top of
761:55 - a c structure so we can kind of put
761:58 - ourselves in the position of uh G van
762:01 - rosom as he was building python in
762:05 - 1991 and say how are we going to make
762:07 - this syntax work how are we going to um
762:10 - in C which is underneath all of this how
762:13 - can we make this syntax work and so this
762:15 - is just review you know we got class
762:17 - point we got a Constructor takes two
762:19 - parameters self is our instance pointer
762:23 - and we got dump and we got origin and
762:25 - then if we look at the main program we
762:27 - create a new Point call The Constructor
762:30 - we can we can see that point. dump that
762:33 - is the function name dump inside a point
762:35 - but then we've also got to pass the
762:37 - instance in or the shortcut syntax and
762:41 - so the pt. origin open print Clos print
762:44 - that is kind of paying more homage to
762:47 - the way C++ would have called Methods
762:49 - and then of course the Dell operator at
762:51 - the end so let's build ourselves some
762:56 - code in C we are building in effect a
762:59 - point object in
763:01 - C so we're going to just start with a
763:05 - structure and the structure is going to
763:07 - be point and there's some instance
763:08 - variables we're going to just allocate a
763:10 - double X and A Double Y inside of it but
763:13 - then the methods are kind of weird we
763:16 - are going to take the Dell method the
763:18 - dump method and the origin method and
763:20 - we're going to Define them as pointers
763:23 - to functions so void open PR star Dell
763:27 - Clos print open print construct point
763:30 - star self Clos print semicolon the void
763:33 - is the return type of this function
763:35 - stard Dell means a function name Dell
763:38 - that the code is not here but this
763:40 - points to a function somewhere else and
763:42 - then the construct point star self
763:45 - that's the first parameter right and so
763:47 - construct point star self is the fact
763:50 - we're going to have one parameter it's
763:51 - going to be named self and it is a
763:54 - pointer to a structure and we've got
763:56 - something similar to dump um the origin
763:58 - is pretty much the same except it's got
764:00 - a return value okay and so that now is a
764:04 - structure this is C so the structure is
764:07 - going to allocate one double two doubles
764:09 - which is uh should be eight bytes each
764:12 - and then three pointers which is eight
764:14 - bytes each so we got eight times 5
764:16 - that's going to be 40 bytes it's a it's
764:18 - not a dynamic structure it is exactly 40
764:21 - bytes of allocation because C structures
764:23 - are just memory and so it's not like you
764:26 - can sort of throw more stuff in there
764:28 - you got to define it you have to Define
764:30 - what type it is and it's going to
764:31 - allocate space we are going to use a
764:34 - naming convention for now and we're
764:36 - going to create the dump function and
764:39 - the dump function is going to take a
764:41 - self parameter and we're going to name
764:43 - it pointcore dump that's just a naming
764:46 - convention and we're going to name the
764:48 - first parameter as it comes into our
764:50 - function self just like python we're
764:53 - going to print out object point at and
764:56 - then percent P which is the way we print
764:58 - a pointer out so self is a pointer xal
765:02 - percent f y equal percent F and then
765:04 - we're going to print out self and self
765:06 - Arrow X and self Arrow y now remember
765:09 - that kind of looks like uh uh PHP uh
765:12 - because self is a pointer to a structure
765:14 - not a structure itself so we use the
765:16 - arrow operator to both dreference self
765:19 - and then look up the attribute uh the uh
765:22 - attribute variable X so if you look at
765:24 - the output you see it's object point at
765:27 - big long HEX number for the address and
765:29 - x = 4 y = 5 and then we have the void
765:34 - Point Dell which is very similar
765:36 - construct point star self so the first
765:38 - parameter to Dell is self and you're all
765:41 - of the first parameters are always going
765:42 - to be self when we create these
765:43 - functions that we're going to treat as
765:45 - methods and then we're going to free
765:47 - that's all that's going to do is call
765:48 - free on the pointer where we pre
765:50 - originally allocated it then we're going
765:52 - to create the origin method and again
765:55 - take a single parameter self and we're
765:57 - going to return the square root of self
765:59 - x * self X Plus self y * self Y and
766:03 - that's going to have return value and
766:05 - then we're going to go and do the
766:07 - Constructor and the Constructor is going
766:09 - to return a pointer to a point and it's
766:13 - called Point new we're going to sort of
766:15 - follow the new convention and it's going
766:16 - to take two parameters an X and A Y so
766:19 - the first thing we've got to do is we
766:20 - got to allocate the 40 bytes size of
766:23 - star P which is a double a double two
766:27 - doubles and two pointers to functions
766:29 - which I I think I've got it right is 40
766:31 - characters and then we're going to set
766:33 - the we'll get that address of 40
766:35 - characters back we're going to set the x
766:37 - value to be X from The Constructor the
766:38 - yv value to Y from The Constructor call
766:41 - and then we're going to set the dump
766:44 - pointer to Ampersand Point dump now this
766:47 - is done on purpose where Point dump is
766:50 - defined earlier in the file and then P
766:53 - origin is the same thing point aend
766:56 - point origin so in each object that
766:58 - we're creating we are going to record
767:00 - the address of three in effect Global
767:04 - functions right they're named Point
767:05 - underscore but these are just regular
767:07 - old functions in the global function
767:09 - namespace right now you know we don't we
767:12 - don't have namespaces we're in C folks
767:14 - we can't sort of do that fancy stuff so
767:16 - we just use a naming convention to
767:18 - accomplish it and then when we're done
767:20 - with the Constructor we do return P so
767:23 - that whatever is calling us gets their
767:26 - instance back so p is the instance but
767:29 - we are in the Constructor allocating and
767:32 - filling the instance up with data and
767:34 - it's just a struct it's just 40 bytes of
767:36 - memory with some labels so in the main
767:39 - code we say struct point star PT equals
767:43 - pointcore new and then prin 4.0 comma
767:46 - 5.0 and this looks a lot like oo code
767:50 - except it's not we're using a struct a
767:52 - pointer to a structure and we're calling
767:54 - a global function called Point new we
767:56 - just happen to have named it in a way
767:57 - that looks a lot like op
768:00 - orientation and so now what we can do is
768:02 - we can say PT Arrow dump which means go
768:05 - look up the dump variable inside the
768:08 - point object that's pointed to by PT and
768:11 - then call it but we still have to pass
768:13 - in PT as that first parameter because
768:16 - that is self that is the instance so all
768:18 - these functions dump Dell origin all
768:22 - need to have as their first parameter
768:25 - self and so PT dump looks up dump but
768:29 - then we still have to put PT in as a
768:32 - parameter and that syntax we're going to
768:34 - do the same thing for PT Arrow origin
768:36 - open print PT Clos print and then to
768:38 - clean things up and in this case we need
768:40 - to well the F the program is done but
768:43 - you know you need to free up allocated
768:45 - memory so the memory is allocated in the
768:47 - Constructor 40 bytes is allocated in the
768:49 - Constructor and then those same 40 bytes
768:51 - are deallocated with by calling free in
768:54 - the destructor and so we we fall intents
768:57 - of purposes there is other than
768:59 - conceptually there is no objects
769:01 - involved in this there's strs there's
769:03 - pointers and there's functions the fact
769:06 - that you can get a pointer to a function
769:08 - means that we've kind of imitated it and
769:10 - again I look at this as how GTO van
769:15 - rosom actually was like facing this and
769:18 - thought to himself how am I going to
769:20 - figure this out how am I going to make
769:22 - it look like this is object orientation
769:25 - so this is this is kind of probably some
769:27 - of the code looked a lot like this in
769:29 - the early days of
769:31 - python and then there was kind of a
769:33 - simple syntactic transformation layer in
769:35 - the in the python sort of parsing to
769:38 - call these things with naming
769:39 - conventions so you can do a lot of
769:41 - object orientation with naming
769:43 - conventions and if you recall
769:45 - C++ started as a language pre-processor
769:49 - and so again you could almost look at
769:51 - this as how did C++ get built right
769:55 - C++ had some oo syntax that then
769:59 - transformed the oo syntax into C code
770:02 - that looks a lot like this which is oh
770:04 - we got some functions the functions have
770:06 - name and conventions and we create a
770:08 - struct and that struct has data in it
770:10 - but it also has pointers to function in
770:12 - it and we'll call the data the
770:13 - attributes and we'll call the pointers
770:15 - to the functions the methods and
770:18 - voila we have objectoriented programming
770:21 - so up next we're going to actually
770:23 - implement the python string class or at
770:26 - least a little bit of the Python string
770:28 - class
770:35 - [Music]
770:40 - so now we're going to switch from my
770:41 - little point class which is just two
770:43 - doubles to an actual string class so
770:46 - what's interesting about the python
770:47 - string class is that you can extend it
770:51 - and so we've been talking a lot about
770:52 - pointers and arrays and even when you
770:54 - call Malo you can't just keep extending
770:57 - things whereas in Python thankfully we
771:01 - can just extend things we create a
771:03 - string we can append H to it and we can
771:05 - print it append L world and print it and
771:08 - then assign it to some other string and
771:11 - then print that and get get its length
771:13 - and we never had to allocate or
771:16 - deallocate any memory during this time
771:19 - when you get done looking at the code
771:20 - what we're going to have to do to
771:21 - allocate and deallocate memory what you
771:24 - should be thinking is wow I'm glad I'm
771:27 - programming in Python I'm glad that GTO
771:30 - van rasum gave me a string class rather
771:33 - than a character array of fixed length
771:35 - an expandable string class rather than a
771:37 - character array of fixed length so we're
771:39 - going to create in C using our little
771:42 - Convention of naming a string
771:45 - class and so if we look at the code what
771:49 - we're try going to try to do here is
771:51 - we're going to
771:53 - basically emulate the python syntax but
771:57 - in C so we're going to start bying
771:59 - making a structure pyer structure we're
772:01 - going to get a pointer back we're going
772:03 - to name that X we're going to call the
772:04 - Constructor pyer new we're going to dump
772:07 - it we're going to have a little dumper
772:09 - we're going to append an H to it we're
772:11 - going to dump it again then we're going
772:13 - to pend a whole string now H in C is a
772:16 - character and L world is a multi
772:18 - character string and so we're appending
772:20 - many characters we're going to dump that
772:23 - then we're going to assign it to a
772:24 - completely new string and then we're
772:26 - going to print it out like Pi give me
772:27 - the string version of this object or the
772:30 - length of it and then we're going to
772:32 - delete it throw it away so you can see
772:34 - all of the Python operations are sort of
772:38 - mimicked but with naming conventions in
772:41 - C now the one thing you'll notice here
772:43 - is in this main code we never allocated
772:47 - any memory and we never deallocated any
772:49 - any memory that is within the object now
772:52 - within the object we have a
772:53 - responsibility to properly allocate and
772:56 - deallocate but one of the interesting
772:59 - things here is is I haven't shown you
773:01 - the code to do any of that and
773:04 - so you don't know that but that's cool
773:07 - because we can use this as long as we do
773:10 - a new play with it and then do a Dell we
773:14 - can do stuff with it it underneath pyer
773:17 - it does all of that memory management
773:19 - for us and that's one of the beautiful
773:22 - things about an object-oriented approach
773:25 - again the syntax on one side if and see
773:28 - is pretty heavy but in the syntax on the
773:31 - on the other side which is the U the
773:33 - python is pretty light but the idea is
773:36 - is that in Python we never had to worry
773:39 - about over making a string too long or
773:41 - Too Short or having buffer overrun or
773:43 - anything like that so as we dive in we
773:48 - have to realize that part of the job of
773:51 - this pyer object is to handle all memory
773:54 - allocation on our behalf so we as
773:56 - programmers can write much simpler code
774:00 - okay so now we are going to build the
774:04 - pyer class we're going to create a
774:05 - structure called piser and in that we're
774:08 - going to have three things the length of
774:10 - the string we have how much data we've
774:12 - got allocated in the string and then
774:14 - Char data is the actual character array
774:17 - and so we have to have a character array
774:19 - inside of it we're not we're not going
774:21 - to let the outside code touch this
774:23 - character array directly we're going to
774:25 - completely manage it inside this object
774:27 - we got draw a little bubble around us
774:30 - and it's like you can do stuff you can
774:32 - use my object but I'm going to deal with
774:34 - everything for you so don't mess around
774:35 - with my internal stuff so what we would
774:37 - think of is all of this instruct pyer is
774:40 - sort of private and see we don't have a
774:42 - good way to force it to be private um
774:45 - but in the concept of object orientation
774:47 - length Alec and data would be something
774:50 - we'd think of it as private in our
774:52 - Constructor we are being asked to create
774:54 - a new python string and we're going to
774:57 - return a pointer to that structure when
774:58 - it's done so the first thing we do is we
775:00 - Al alloc it now int int is usually 32
775:05 - bits so that's four uh Alec there's 4
775:09 - eight there's probably 16 characters in
775:13 - pyer um when we do Malo size of p is 16
775:16 - that's the number 16 and so it's going
775:18 - to give me 16 characters now the the key
775:21 - thing is is that that is not allocating
775:24 - the actual string data it's just
775:26 - allocated eight bytes for a pointer to
775:28 - the string star data is a pointer and
775:30 - that first Malo is only giving us the
775:33 - pointer not the actual data so then we
775:35 - just sort of set it up we say our length
775:37 - of the string is zero there's nothing in
775:39 - it our allocated length of the
775:41 - underlying data string is 10 and then we
775:44 - immediately call Malik to get 10
775:46 - characters so now data is a 10 character
775:49 - character array and Alec tells us how
775:52 - much we've allocated because it's our
775:54 - job inside this thing to keep track of
775:56 - that stuff and then just to be be good
775:59 - we throw back sl0 at the zero position
776:02 - in that allocated character we don't
776:04 - know what the rest of them are we just
776:06 - know that the first one is zero and then
776:08 - we return the pointer to the structure
776:10 - not the pointer to the data the pointer
776:12 - to the structure and this gets called
776:14 - inside the main as TR struct pyer star x
776:18 - equals pister new and when we're done we
776:20 - get back this cool little two pieces of
776:23 - data that have been dynamically
776:25 - allocated and it's all it's all ready
776:27 - for us to do cool stuff with
776:29 - we got the struct we've got the
776:31 - Constructor and then we've got the
776:32 - destructor which is pyer Dell and that
776:35 - again passes in self now we're calling
776:38 - free now if you recall there are two
776:41 - allocated things one is the data which
776:43 - is the character array that we've got
776:45 - we've got to get rid of that and then we
776:47 - got to get rid of the object itself and
776:49 - so at the end of Dell we have given back
776:53 - all of the data that we've alled now one
776:55 - thing important here is the order of
776:56 - these two statements matters a lot so so
776:59 - when we free self we're not supposed to
777:02 - access self anymore after that point I'm
777:04 - I'm sure there could be some data just
777:06 - laying in there that's not been ruined
777:08 - but you just don't know and so that's
777:10 - why we have to free self Arrow Data
777:13 - before we free self just because it's
777:17 - just wrong to do that in the other order
777:19 - and so we do a pyer dump and in that we
777:21 - dump out the length we've dump out how
777:23 - much we've allocated so far and what the
777:26 - data is in it so far and then pyer Len
777:29 - piser Len returns an integer and it
777:31 - takes self as a parameter the key to
777:33 - this is it returns self length and you
777:35 - might ask why it is that we don't just
777:37 - let our calling code access self length
777:40 - and this again is encapsulation we don't
777:42 - want to refal the fact that we're
777:44 - keeping track of length in this variable
777:45 - because we don't want the calling code
777:47 - to be messing with it remember that
777:49 - length data and Alec are kind of
777:53 - private and so instead of saying just go
777:56 - look at self length no I would like you
777:58 - to call my function and I will give you
778:01 - the thing you want so you just call the
778:03 - Lend function and pass in the instance
778:05 - and that allows me to change the name of
778:06 - length it allows me to interpret length
778:09 - differently allows me to do all kinds of
778:10 - things but at least the object writer is
778:13 - in control of the contract with the
778:16 - outside world so by hiding all the data
778:19 - and giving methods to a we call these
778:21 - accessors to access this data is a good
778:24 - idea now the underscore stir if you
778:26 - think of python it's like you can say
778:28 - stir open print close print anything
778:30 - inside the parentheses and it converts
778:32 - it to a string well it just so happens
778:34 - that we're going to maintain self. data
778:37 - as a valid string So when you say take
778:39 - this string object and convert it to a
778:42 - string ready for printing I'm just going
778:44 - to return the pointer to the string
778:45 - we've been maintaining all along
778:47 - internally we have some other methods
778:48 - that we've got to add we've got to add
778:51 - an append to add a single character you
778:53 - can see that it's got two parameters
778:55 - it's got self and a single character CH
778:58 - you got a pend s which is a got two
779:02 - parameters the self the instance and a
779:04 - whole character string which is a
779:06 - pointer to a character then we have a
779:08 - sign which is a got two parameters one
779:11 - is self and one is a pointer to a
779:13 - character string now I'm not going to
779:16 - give you these lines of code I'm going
779:18 - to give you an assignment to write these
779:20 - lines of code I'm going to show you how
779:21 - they're supposed to work but I'm not
779:23 - going to give you the code so I'm
779:25 - telling you that pyer append is about 10
779:27 - lines of code
779:29 - pyer append s is just one line of code
779:31 - it's a for Loop pyer a sign is about
779:34 - three lines of code so pyer append s
779:36 - calls pyer append and pyer assign calls
779:40 - pyer append s and so we do a lot of
779:42 - reuse here so let's take a look at how
779:44 - these are going to be used in our main
779:45 - program we say struck pyer starx equals
779:48 - pyer new which is give me a new string
779:51 - object and then we're going to append A
779:53 - Single Character H to it and then we're
779:56 - going to append s a multi character
779:58 - string and we're going to dump it each
780:00 - time and then we're going to overwrite
780:02 - our object with a completely new string
780:05 - and so the key thing is you have got to
780:08 - build this this is what you're going to
780:10 - build okay but I'm talk a little bit
780:12 - about how to do it so let's walk through
780:15 - what you might need to do in pyer append
780:19 - now recall that when we set this thing
780:21 - up we created length we allocated 10
780:24 - characters and a 10 character array and
780:26 - had data point to that 10 character
780:28 - array and we remembered that we had 10
780:31 - characters so the first thing that a pen
780:33 - does is it checks if the the the length
780:37 - is greater than what we've allocated
780:38 - meaning that you know if we're going to
780:40 - put in character Zero like the letter H
780:43 - we can just depend it and then update
780:45 - length we still have 10 characters
780:46 - allocated and we've used one of them um
780:49 - and so we can just start appending into
780:52 - data right and we have to put a a zero
780:55 - at the after it so that the data is a
780:57 - valid string all the time and so if you
780:59 - kind of
781:00 - imagine that we create the new object we
781:03 - have a new object that has a length of
781:05 - zero and it has 10 character array and
781:08 - it has a a string end character in the
781:10 - first character we're good we have 10
781:13 - allocated and we know we have 10
781:14 - allocated then if we add an H character
781:17 - A Single Character H all we have to do
781:19 - is add H into that array data Subzero in
781:23 - that case and then update length to be
781:25 - one and then say data sub one is back
781:28 - sl0 so that we terminate it correctly so
781:30 - after that first
781:32 - line the data is H it's a valid H string
781:35 - so we've appended A Single
781:37 - Character we've updated the
781:40 - length and then we have terminated the
781:43 - string and then we go to the next line
781:44 - in C where we're just in this case we're
781:46 - going to append the letter e and we look
781:48 - at the length of the of it because it
781:51 - tells us where to put it the length is
781:52 - one so we put it in sub one and add back
781:56 - sl0 and then we check to make sure that
782:00 - we have space for it because we've got
782:01 - 10 but we've only used two we' really
782:04 - used three because h e end of character
782:07 - string so we really use three but the
782:09 - length of the string we've got is three
782:11 - so as long as no one asks us to append
782:15 - more than 10 characters append is a
782:18 - pretty simple operation you just add to
782:21 - the the character array that we've
782:23 - already got allocated okay but of course
782:27 - it gets interesting you can pen h e l l
782:30 - o space w r and at that point we have uh
782:35 - nine characters in our length of the
782:39 - string that's in data is nine we've got
782:41 - it properly terminated so we have used
782:44 - the 10th character to terminate the
782:45 - string so we're really good things are
782:49 - great but now the problem is we have got
782:53 - to
782:54 - append the L after the R so we have pen
782:58 - the L after the R so what we have to do
783:01 - is we have to call a function we called
783:03 - Malik in the Constructor and now in a
783:06 - pen we're going to have to call
783:08 - realic to say ooh I asked for 10
783:11 - characters but now I want to extend that
783:15 - from 10 to 20 characters and realic does
783:18 - that realic says here's a
783:21 - pointer and it knows how many characters
783:23 - it is please reallocate this
783:26 - pointer take this data in the this
783:28 - pointer and give me make it 20 long
783:31 - instead of 10 long it might have to copy
783:33 - it so let's take a look at what realic
783:35 - does so we can extend the size of a
783:38 - dynamically allocated area by calling
783:41 - realic with the current pointer to the
783:42 - area and the new size so in the
783:45 - Constructor you see that we Malik
783:48 - 10 and then we're in the pend and we say
783:51 - if the length is greater than self Alec
783:54 - minus 2 we don't have space for two
783:56 - characters left then and we going to
783:58 - have to realloc so what we're going to
784:00 - do is we're going to change this from 10
784:02 - to 20 characters so we're going to take
784:04 - self aloc which is 10 and add 10 to it
784:08 - so now self alic is 20 and then we're
784:10 - going to set self data to a to realloc
784:14 - the old self data 20 characters so this
784:18 - this
784:19 - realic takes a pointer and a new size
784:23 - and gives us back a new pointer now it
784:25 - actually may have to move it in memory
784:27 - so you can't assume that self data is
784:31 - the same before and after but you can
784:34 - assume that if it had to move the data
784:38 - to find you a 20 character slot in its
784:42 - free space that it will have copied all
784:44 - the first 10 characters will be copied
784:47 - and then you'll get a new parameter and
784:48 - that's why you see self data on both
784:51 - sides both in the call to realic and as
784:55 - the assignment statement so we go back
784:56 - here and we can see that oh yeah now we
784:58 - have 20 and it's got plenty of space for
785:00 - the L and the D and the back sl0 so now
785:04 - we're going to show the code that's
785:06 - going to basically test our class we're
785:08 - going to create a new we're going to
785:11 - dump it we're going to append A Single
785:12 - Character H we're going to dump it we're
785:15 - going to append a string one way to make
785:18 - this simple is just have append s call
785:21 - append repeatedly for nine characters
785:23 - because a pending nine character string
785:25 - is the same as a pending nine characters
785:28 - not appending one character at a time
785:29 - nine times then
785:31 - assign assigning a completely new string
785:34 - which means that you got a you got to
785:37 - take length back and you got to set some
785:39 - things and you got to check the size and
785:41 - do a whole bunch of stuff and then we're
785:43 - going to ask the piser uncore stir to
785:46 - give us back a printable string and then
785:49 - we're going to ask the pyer uncore L Len
785:52 - to tell us how long this thing is and so
785:55 - you get to write some code not too much
785:57 - code probably
785:59 - 15 lines of code um but it is code that
786:02 - you will need to think deeply about and
786:05 - you're going to need to understand the
786:06 - structures you're going to need to
786:07 - understand the pointers etc etc
786:11 - etc up next we are going to make a list
786:15 - class
786:17 - [Music]
786:28 - so the next class that we're going to
786:29 - build in C is an emulation of what you
786:33 - would do if you were building the python
786:35 - list class in C so let's just start by
786:37 - taking a look at sort of a python and uh
786:42 - C version of this thing in Python we
786:45 - create a new list then we append a whole
786:47 - string then we print it then we then we
786:50 - have another string then we print it we
786:52 - have another string we print that we ask
786:54 - how long is the list we do an index
786:57 - which is a positional look up saying
786:59 - where is the string Brian then we say if
787:02 - Bob's in the list where is it or we say
787:04 - we can't find Bob so we have to do an if
787:06 - then else and use in because otherwise
787:09 - we'd have to use a TR catch because if
787:11 - you do an index to a with a string
787:13 - that's not there in Python it's going to
787:15 - blow up so we can either do an if then
787:17 - else or we can do a TR catch it's sort
787:19 - of six in one half a dozen in the other
787:20 - but in C we're going to effectively call
787:23 - py list new to create a new list we're
787:26 - going to call py list aen and again
787:28 - remember all the time we're calling
787:30 - these things that are like methods we're
787:31 - always putting the instance as the first
787:33 - parameter in this case LST is the
787:35 - instance so we're going to append hello
787:37 - world we're going to print it we're
787:38 - going to append append catchphrase we're
787:40 - going to print it we're going to append
787:42 - Brian we're going to print it then we're
787:44 - going to look at the list length of the
787:45 - list then we're going to look up Brian
787:47 - and we're going to look up Bob and in
787:48 - this case I made it so that the index
787:51 - just gives us back negative one to say I
787:53 - didn't find Bob so that I didn't have to
787:55 - try catch because it's like a little bit
787:56 - more SE like and then we do a py listor
788:00 - Dell to clear up the memory we are about
788:03 - to switch from being the consumer of the
788:06 - list object to the builder of the list
788:08 - object and our job as the Builder of
788:10 - list object is to dynamically allocate
788:13 - all the data that we need to make this
788:15 - thing work and so we don't get to see
788:17 - the details of that all we know is there
788:20 - these functions that we can call in this
788:21 - structure that we can use and if we call
788:23 - the functions right somebody else is
788:26 - going to deal with all of the dynamic
788:28 - memory that makes this work and you've
788:30 - done link lists in previous assignments
788:33 - so link list should not be completely
788:35 - foreign to you but now we're taking an
788:37 - object-oriented approach to implementing
788:39 - a link list and hiding the
788:41 - implementation detail within the object
788:44 - which is an important part of
788:45 - object-oriented programming so here's
788:47 - like some basic stuff and some of this
788:49 - should start looking pretty familiar we
788:51 - got a l node which is short for list
788:53 - node we got a pointer to a character
788:56 - string um and then we have a pointer to
788:59 - the next one so we call that one next by
789:01 - convention next is not a keyword next is
789:04 - just a really common convention when
789:06 - we're making link lists and then we and
789:09 - that's just the node so link list is a
789:11 - list of nodes but then there's kind of
789:12 - the list itself and that's what the
789:14 - struct py list is and it's got a pointer
789:16 - to the head and a pointer to the tail
789:18 - and just a counter and so if we create
789:21 - the new list py list new we are going to
789:26 - allocate the the the py list object
789:29 - which is a pointer which is eight two
789:31 - pointer 16 and four should be 20 bytes
789:34 - and then we're going to that's what star
789:36 - p is going to be then we're going to set
789:38 - the head to null and the tail to null to
789:40 - indicate that we have an empty list
789:41 - we're just we're not creating a list
789:42 - with things in it and set the count to
789:44 - zero and we're done so it's it's pretty
789:46 - straightforward in some ways it is this
789:48 - list is easier in some ways than the the
789:51 - python uh string was now the destructor
789:54 - is a little trickier because we actually
789:57 - have to go through the list and we have
789:59 - to free up all of the text areas not
790:02 - just the um not just the the struct L
790:06 - nodes but we've also got the charar text
790:08 - that we've got to get rid of so what
790:10 - we'll see here is we're going to in the
790:11 - pyus Dell we're going to carefully start
790:13 - at the head and then Loop through and
790:17 - remember that I free Cur has got to be
790:20 - the last thing we do with CER once we
790:23 - say free CER for the that's the L
790:26 - nodes we got to do the free Cur we're
790:29 - not supposed to touch C ever again so
790:31 - you'll see I say free Cur text which is
790:33 - the string that's pointed to in the
790:36 - current node then I look up next and I
790:40 - I'm looking up next before I call free
790:42 - curve because I'm not supposed to use
790:43 - Cur afterwards so I say next equals K
790:46 - next give me the next pointer before I
790:48 - wipe out cerr I wipe out cerr and then I
790:51 - say C equals next and so I just I I
790:54 - created that next variable inside that
790:56 - function just to kind of get past the
790:58 - free Cur so I didn't have to say C
791:00 - equals c next after I called free C and
791:03 - then Loop goes through and it slowly but
791:05 - surely cleans up all of the L nodes
791:07 - might be zero there might be no l nodes
791:09 - and head head will be null at that point
791:11 - and W won't even run but you got to free
791:13 - the text and you got to know where the
791:16 - next pointer is then you free the the
791:19 - current one and then you advance to the
791:20 - next pointer and jump up to the while
791:22 - loop and then do the rest and then and
791:24 - only then afterwards do you free the
791:26 - self which is the actual py list object
791:29 - these structures tend to point to
791:31 - structures that tend to point to
791:32 - structures and you got to when you're
791:33 - ding them when you're freeing them you
791:35 - got to free them from the outside that
791:37 - that think of it as a tree you got the
791:39 - leaves and the branches and then the
791:41 - trunk and then The Roots You Got to you
791:43 - got to free them from the leaves inwards
791:46 - and so just be real careful about this
791:48 - that's part of the reason that I give
791:50 - you so much sample code where I do the
791:52 - Dell for you because I just don't want
791:54 - it to mess up if we take a look at the
791:57 - step of freeing the dynamic memory
792:00 - you're going to see that it's going to
792:01 - if we have a head and we have a tail
792:03 - here um the first thing it's going to do
792:06 - is it's going to to the L node that is
792:08 - the head and then it's going to the
792:11 - first thing that's actually going to be
792:12 - freed is the text and then it's going to
792:15 - free the L node then it's going to
792:17 - advance to the next L node which has is
792:20 - it's going to free the is then it's
792:21 - going to free the fourth thing which is
792:23 - the second L node and then it's going to
792:26 - advance to the third l node and then
792:28 - it's going to free the fun which is the
792:30 - fifth thing freed and then it's going to
792:32 - free the last L node and it'll notice
792:34 - that next is is is null and so we're
792:37 - done with there was a three node list
792:39 - and then the last thing we do is we free
792:43 - the the py list itself so that the order
792:45 - in which we free these things is really
792:48 - really important and you think of it as
792:49 - the leaves outwards right the C is fun
792:53 - those are three strings that have been
792:56 - allocated those have to be freed first
792:59 - before we free the L node that happens
793:01 - to point to them so every little bit of
793:04 - order matters the one thing I want you
793:06 - to do in this one is I want you to make
793:08 - the list output instead of it being dump
793:10 - I you'll notice I called this one print
793:12 - not dump and I want it to look exactly
793:15 - like Python's list output which means
793:17 - it's got to open Square brace it's got
793:19 - the strings and double single quotes
793:21 - comma space in between them Etc and
793:25 - don't try to use string concatenate to
793:28 - do this cuz you're in C you're not in
793:30 - Python you don't even know how long
793:31 - these strings are going to be what you
793:33 - need to do is you need to cleverly write
793:35 - a loop that uses print F so think of
793:38 - this as you can only use print F don't
793:42 - use a string because you don't have
793:45 - strings just use print
793:47 - F and
793:49 - remember that print F doesn't add a new
793:52 - line unless you actually put the new
793:53 - line in so it's pretty easy to do print
793:55 - F Open Bracket then print f single quote
793:58 - print off the string printf single quote
794:01 - printf comma etc etc so you got to it's
794:05 - about 10 lines of code and you know
794:08 - enjoy yourself I think you'll do a
794:10 - pretty good job of this and you'll be
794:11 - impressed when you're all done and then
794:13 - you think oh I'm walking down the path
794:15 - of GTO van rosom because GTO van rossom
794:18 - had to write exactly these lines of
794:21 - code now he he actually was probably
794:23 - using a string class which I just told
794:25 - you not to use because he didn't want to
794:28 - uh he didn't want to call Print F
794:30 - directly so he wanted to make it so you
794:32 - can convert to a string but
794:34 - whatever you're walking the path that
794:37 - GTO van rossom walked while he was
794:40 - building the list object that's what I
794:42 - want you to do here's some more methods
794:44 - some are easier some are hard um Len is
794:48 - really easy uh index is not too bad it's
794:50 - a for Loop but you Loop through you look
794:51 - for a value and then you just return
794:53 - negative one if you don't find it you
794:54 - just return the position you got to kind
794:56 - of ADD go 0 1 2 3 4 5 6 7 and return the
795:00 - seven if you find it aend is a bit
795:03 - tricky but hey that was chapter six you
795:06 - should know how to do that you've
795:07 - actually by this point in chapter six
795:09 - you would have written one of these
795:11 - things so go consult your own code at
795:13 - that point and so here is the ultimate
795:15 - test case of our list class you were
795:19 - just going to mimic that python code
795:21 - we're going to append a hello world
795:22 - string append a catchphrase string
795:24 - append a Brian string print them all the
795:26 - time we're going to print the length and
795:28 - we're going to do a index lookup for
795:29 - Brian and Bob and then we're going to
795:31 - delete it we always delete it because
795:33 - we're not in Python so we're carefully
795:34 - deleting it and other than the negative
795:38 - one for Bob being 404 in the python cuz
795:41 - that was kind of a joke um it is
795:44 - identical right we're really starting to
795:47 - build what looks like a python list so
795:51 - up
795:52 - next it's pretty much you guessed it we
795:55 - did a string we did a list
795:58 - yep it's a dictionary we're going to
796:00 - actually build a dictionary in our next
796:03 - [Music]
796:14 - bit so now we're going to build a python
796:18 - dictionary class and here is the code
796:22 - that we would put in our dictionary I I
796:24 - kept the strings really short because of
796:26 - of of all the uh I want the examples to
796:28 - be pretty short and easy um so what do
796:31 - we do we create a dictionary and we use
796:33 - the you know bracket square bracket
796:36 - operator to create a key it's a key
796:38 - value pair the key Z match it goes to
796:41 - catchphrase we print it out the
796:44 - dictionary Z goes to W which is
796:46 - replacing catchphrase with W because if
796:48 - you overwrite the same key you have to
796:51 - put the same Val the the you have to
796:53 - replace the value and then we're going
796:55 - to throw three more things y map maps to
796:57 - b c maps to Capital C and A maps to D
797:01 - that's just so that it's not sorted too
797:03 - badly and then I printed out and then I
797:07 - um print the length of it I do a get and
797:11 - with a default value of 404 so sometimes
797:14 - I get the for z i get the W and then for
797:16 - X is not there so I get the 404 again
797:19 - kind of an homage to the HTTP error code
797:22 - 404 not found and then I use it right a
797:24 - little for Loop for key and dict uh Etc
797:27 - and I can print the key value pairs
797:29 - out we'll do the same thing in C and
797:32 - again this is almost a perfect
797:34 - transformation literally we first create
797:37 - the dictionary with calling a new then
797:39 - we uh put the word catchphrase in the Z
797:43 - key then we print it then we put a w in
797:45 - the Z key which should overwrite it we
797:47 - print that and then we set the y key to
797:50 - be B the C to be Capital C the a to be
797:53 - capital D and then we print that and
797:55 - then we ask how long is it and then we
797:57 - do a get to look up under the Z key and
798:00 - the X key one of which is there one of
798:01 - which is not there and I get a null back
798:03 - in that situation I guess I was a little
798:05 - see like in my get code and then I dump
798:08 - it out and I do a struct d node Loop go
798:12 - from the head until it's null and I
798:14 - print out the key and the value from
798:17 - each of those uh dictionary nodes and
798:18 - then I delete it at the end so this is
798:22 - the code now again notice we don't know
798:25 - much about looking things up we don't
798:27 - know how the length is maintained we
798:29 - don't know how the static and dynamic
798:31 - allocation is going to happen we now
798:33 - have a contract with a bunch of Library
798:35 - code that is going to implement this
798:37 - dictionary object for us and do all of
798:39 - them memory manipulation on our behalf
798:42 - again we start with the basic stuff the
798:45 - big thing we're going to do is we're
798:46 - going to not just have a value it looks
798:48 - a lot like a link list we're going to
798:49 - have a key value pair the pi dict has a
798:51 - head and a tail and a count just like
798:53 - the P list and if you look at the the
798:57 - the Constructor it's pretty much like
798:59 - the Constructor for the list we allocate
799:01 - the uh dict Pi dict um uh structure and
799:05 - we set the head and tail to null to
799:07 - indicate empty and we set the count to
799:08 - zero and we're done and the same with
799:10 - the dell the Dell is very much like the
799:12 - link list Dell we are have to because
799:15 - we've allocated the key the key is also
799:17 - going to be a dynamically allocated
799:18 - pointer to a character array so we got a
799:21 - free Cur key along with Cur value but
799:23 - then everything else is the same we we
799:25 - we pre preload the next value then we
799:28 - free Cur then we move to the next value
799:30 - and then when it's all said and done we
799:32 - free self which is the pi dict value
799:35 - when it's all said and done we can call
799:37 - the new and then we can uh set a key
799:40 - like catch froze and the key thing there
799:42 - is the key and value are both Malik uh
799:47 - bits of memory just like you know before
799:50 - we had the text which was a Malik bit of
799:53 - memory and copied and we had to free it
799:55 - but now we just have two things and so
799:57 - the key and the value are two things
799:59 - that are that are going to be Malik and
800:01 - then copied into the Malik area so some
800:03 - methods for you to build the lens should
800:05 - be pretty easy similarly that we have a
800:07 - print that's going to be pretty and I
800:09 - want you to match exactly the output of
800:12 - the Python and so it turns out that we
800:15 - can make a method called find which
800:18 - returns a d node rather than get returns
800:21 - a string D and P find returns a d node
800:24 - and then we can use find both in get
800:27 - and inp put now we use it pretty much in
800:31 - get to go find it and then return um the
800:35 - the value because we have the key we
800:37 - look up find it by key and then return
800:39 - the value so that's pretty pretty easy
800:41 - to do the get once you have find so the
800:43 - find is find is a for Loop where you're
800:45 - going to go and you're going to find it
800:46 - and if you find it you're going to send
800:47 - it back okay and if you're not you're
800:49 - going to send a null back now you better
800:51 - check if it's null right including in
800:54 - the get you got to you got to check if
800:56 - it's null um but then in the put what
800:59 - you do is you look up the old one with
801:01 - pictor find and if you get one if old is
801:05 - not equal to null then you're updating
801:07 - the key updating the value for the key
801:10 - and if not you're adding it now the
801:12 - thing about the else Clause here is it
801:14 - looks a lot like a link list because
801:17 - really if you if you look at this thing
801:19 - it is a linked list it's just there's
801:22 - two values in each one we're not doing
801:24 - anything magical now more Advanced
801:26 - Dictionary implement ation might use
801:27 - hash Maps or binary trees or other
801:30 - things like that like that were in
801:32 - chapter six that we didn't talk too much
801:33 - about but for now we're just going to
801:35 - make our dictionary be a linked list but
801:38 - instead of just a value it's a key and a
801:40 - value so we can look it up by key and so
801:42 - we're not doing too much tricky stuff to
801:44 - make our dictionary really by just
801:46 - adding a bit to a list so let's just
801:50 - take a look at how this is going to work
801:54 - in sort of the real world as it runs
801:57 - so remember we have kind of the
801:59 - dictionary itself which is a head and a
802:01 - tail and a count and then we have the
802:03 - dictionary nodes which is our key and
802:05 - value and the next one now the key and
802:08 - the value are not the actual strings
802:10 - they're just pointers to Strings which
802:11 - means we're going to have to use Malik
802:12 - to when we get a key and we get a value
802:14 - we're going to have to Malik and copy
802:16 - both of those things um so if we start
802:21 - and we see Pi dictor new we're going to
802:23 - get a a dictionary with head and tail
802:26 - that point to n
802:28 - and then if we add catchphrase well
802:30 - we've we we allocate the Z we allocate
802:34 - and copy the key Z and we allocate and
802:37 - copy the value and put those in key and
802:40 - then next is null and head and tail
802:42 - point to this thing so we've allocated
802:45 - three things we've allocated a a d node
802:48 - and we've allocated a character two
802:50 - character arrays using Malik okay so
802:54 - then let's say we're going to run the
802:56 - next line of code which is setting the
802:59 - key Z to
803:01 - W now when you're in the put
803:04 - code you go and you call find and you
803:07 - see that there is a thing there is
803:09 - already a z in there so what you've got
803:11 - to do is you've got to replace
803:13 - catchphrase so you actually before you
803:17 - go and make a new
803:20 - value you have and copy W into it you
803:23 - want to free the old stuff and so you
803:25 - tend to free the catch the value that
803:27 - was in there before and then you maloc
803:30 - and copy in for the new value so if
803:33 - you're done at the end of this you will
803:35 - have catchphrase somewhere in Magic free
803:37 - space we don't know where how C does
803:39 - magic free space but it does do it so at
803:41 - the end of the second put you still have
803:44 - one entry but the value has been changed
803:47 - from pointing at catchphrase to pointing
803:49 - at w then we add y equals B well you do
803:53 - a find and there is no y key so now it's
803:56 - more like a link list you create a new D
804:00 - node and you pend it to the end just
804:01 - like in a link list and then you save
804:04 - the key and Point Key at it and then you
804:06 - save the value into new Malo space and
804:08 - then point value at that and then we go
804:10 - to the next one where we point C that we
804:14 - we don't find c in there so we create a
804:16 - new uh uh D node and then we we do a
804:19 - Malo of the the key and a malic of the
804:22 - value and we point to those and then
804:24 - copy the data into those two Malik areas
804:26 - and then Point Key and value at those
804:28 - malic areas and you can kind of see that
804:30 - this is really at this point it's unless
804:32 - we find the key uh in there already it's
804:35 - just a link list that happens to have
804:38 - two character arrays that are
804:40 - dynamically allocated and copied one for
804:42 - key one for Value that was a bunch of
804:44 - object orientation it was kind of a walk
804:46 - down the path that Neo van rossom took
804:49 - probably in the first few weeks of him
804:51 - building the string class list class and
804:54 - dictionary class chances are good he
804:56 - built something very very similar and
804:58 - then he's like okay now I got to make
805:00 - this better but uh you know if I was
805:02 - just writing this thing he'd probably
805:03 - just type this out it's kind of pretty
805:05 - for computer scientists who've been
805:07 - doing algorithms data structures their
805:08 - whole lives it's like well why don't I
805:11 - just make a class that does this you
805:12 - know now that I now that I've got sort
805:14 - of an object-oriented Universe let me
805:17 - hide all of the dynamic memory and
805:19 - that's really what we're doing we're
805:21 - hiding the dynamic memory and the
805:22 - implementation details and all the for
805:25 - loops and while Loops they're being hit
805:26 - hidden they're important and if you were
805:28 - to look at the source code to stir list
805:31 - and dict in Python you'd see they're
805:33 - allocating and reallocating they're
805:35 - doing it a lot more cleverly than what
805:36 - we did um you don't want to call real
805:39 - too many times but for for now it works
805:42 - we're doing small stuff um there is an
805:44 - infinite number there's an infinite
805:47 - array of optimizations to make all of
805:50 - this way faster and more
805:53 - impressive um
805:57 - but that's that's really for another
805:58 - time so we've kind of got the idea of
806:03 - the the Baby Steps From A procedural
806:06 - language with pointers structures and
806:09 - dynamic memory allocation how you would
806:11 - take the step using those underlying
806:13 - things in a procedural language to build
806:17 - basic objects and support those objects
806:20 - perhaps as you're building a new
806:21 - language like python
806:28 - [Music]
806:33 - hello and welcome to our continuing
806:35 - series of lectures on improving our
806:38 - implementation of a python object so
806:41 - what we've been doing is we have been
806:43 - building a series of of implementations
806:46 - of approximate
806:48 - implementations of some of the things
806:50 - that we find in Python like the python
806:52 - dictionary and so we the last thing we
806:55 - worked on with is pyth on dictionary
806:57 - class and in the previous implementation
806:59 - was just a linked list with a key now
807:02 - we're going to eventually have to build
807:03 - all kinds of different implementations
807:05 - and so the part of what we're doing is
807:06 - we're working toward abstraction where
807:08 - we're separating what the object is that
807:11 - we're interacting with from how we build
807:13 - it underneath and so we're going to do
807:16 - things like move our methods into the
807:18 - structure instead of just using prefix
807:20 - style naming conventions and
807:23 - just reduce the need to look inside
807:27 - the class or inside the structure that
807:30 - is holding our class for code that's in
807:33 - our calling code so we don't want to
807:35 - have to look at the
807:38 - class uh the class values inside the
807:41 - class so this is just continuing along
807:44 - understanding object or principles the
807:46 - three implement the three principles of
807:48 - object orientations are encapsulation
807:50 - abstraction inheritance and polymorphism
807:53 - and so for now we're bundling more
807:56 - things together that's encapsulation and
807:59 - we're working on abstraction and that is
808:00 - thinking about separately how we are
808:03 - going to use this object from how we're
808:07 - going to build the object we're going to
808:10 - reveal less and less of our
808:12 - implementation details to the caller
808:16 - okay and so for a while we just said
808:20 - well we'll just take the class and add
808:23 - like an underscore and and name it etc
808:26 - etc and it seems absolutely simple
808:28 - enough and in some ways you see that C++
808:31 - does exactly that when it's um compiling
808:34 - C++ to C code
808:37 - um but it just it seems like it's simple
808:39 - enough and it seems like you would keep
808:41 - it straight but it turns out to be a bad
808:42 - idea in practice so python strings which
808:46 - I can write python code and not have to
808:48 - look up documentation are real objects
808:51 - that follow the principle of
808:52 - encapsulation everything that you touch
808:55 - is inside of the object object like
808:58 - uppercase searching for something PHP
809:01 - strings are kind of more archaic and
809:05 - that PHP is more of a seike way of
809:08 - thinking about things and they're a type
809:10 - and then there's a bunch of libraries
809:11 - that know how to use this
809:13 - type and so I'm going to show you some
809:16 - ickiness in PHP but I do love phps so
809:19 - don't I'm not just criticizing PHP PHP
809:22 - has a lot going for it but the in the
809:24 - language and the library there are some
809:27 - annoyances so let's take a look at a
809:29 - little bit of python and some equivalent
809:31 - PHP and so you sort of see this this
809:33 - notion that name convention seems
809:36 - tempting but it's not necessarily a
809:37 - great idea so in Python we say x equals
809:40 - a string we call x. find and have the
809:44 - first parameter the thing we're looking
809:45 - for and then we have yals x. replace old
809:49 - new and so the the first parameter is
809:52 - the old string and the second parameter
809:54 - is the new string and then we say how
809:56 - long long this thing is and so
809:57 - everything's very consistent but if we
809:59 - look at PHP it's almost identical except
810:03 - it's calling libraries right so dollar x
810:05 - equals a string with old in it and then
810:07 - we're going to use Stir pose that is the
810:10 - position in a string and the first
810:12 - parameter is the what they call the Hy
810:14 - stack and then the second parameter is
810:16 - with which we call the needle but then
810:18 - we look at the replacement which is
810:20 - equivalent of x. replace in Python and
810:23 - it's not stir replace it's stir
810:25 - underscore replace so do we use
810:28 - underscores or we not use underscores
810:30 - and then the the thing that just drives
810:32 - me crazy is what is the what would you
810:34 - expect the first second and third
810:36 - parameter of PHP stir replace well if I
810:40 - was writing it it would be the The
810:44 - Source string the old the old search
810:47 - string and the new thing to replace it
810:50 - with but that's not what it is the stir
810:53 - replace says old string new string and
810:56 - then
810:56 - the string we're doing the searching in
810:59 - you you can go look this up but PHP
811:00 - talks about how there were generations
811:04 - of things like stur pose I think is one
811:06 - of the earlier ones um sterland
811:08 - basically is that's one of the new
811:10 - that's one of the older ones and so it's
811:12 - consistent with stir pose but not
811:14 - consistent with stir replace and so the
811:16 - naming conventions is just less than
811:18 - ideal and and you can just see from a
811:21 - programmer understanding is just really
811:23 - simple that if we look at the python
811:25 - says yal X . replace old new I can
811:28 - remember that calling sequence and I can
811:30 - never remember a sore replace in
811:35 - PHP so the thing we're going to do here
811:38 - is we're going to put the methods in the
811:40 - structure and so we see some of our C
811:42 - code before and after and so we create a
811:45 - pi dict and then you'll notice that just
811:49 - like what PHP did I called those Pi
811:52 - dictor put Pi dictor Len and pict get I
811:57 - was consistent because I always used
811:58 - underscores and pict is the name of the
812:01 - structure pictor Dell and so I was
812:04 - pretty consistent with that but now what
812:06 - we're going to do in the name of
812:07 - encapsulation is we are going to take
812:10 - all those methods make them be part of
812:13 - the structure we're going to find that
812:14 - they're just pointers to the methods but
812:16 - we are going to have Global methods
812:18 - we're just not going to access them
812:20 - through their Global names so we're
812:22 - going to create a new new pict saying
812:24 - pictor new
812:27 - but then we're going to call to put
812:28 - something in we're going to call DCT
812:30 - Arrow put and remember we have to make
812:33 - this first parameter like the self
812:35 - parameter DCT that's just always going
812:37 - to be that first parameter because we're
812:38 - sort of doing it python style and then
812:41 - you kind of know that Z is the key and
812:43 - catchphrase is the value and so that's
812:46 - the that's the calling sequence and
812:48 - again that DCT comma is just because
812:51 - we're not an objectoriented language and
812:53 - so we put self in there again homage
812:56 - back to exactly the way that python did
812:58 - it and why they did it the way they did
813:00 - it because they were creating an
813:02 - object-oriented framework on top of a
813:04 - non objector environment just like we
813:06 - are and then you look at DCT arol Len
813:10 - and of course putting DCT in is the
813:11 - first parameter is redundant but
813:13 - necessary and we can do a DCT get and we
813:17 - in effect other than the first parameter
813:19 - which is DCT we are putting the key in
813:22 - and away it goes and then we could call
813:24 - the Dell method but now you'll notice
813:26 - that that every single method that is
813:29 - associated with a pi dict is in the pi
813:32 - dick structure so let's talk about how
813:34 - we're going to do that and why and so
813:37 - this all kind of falls under um leaky
813:40 - abstractions meaning that when we are in
813:43 - the main calling code and we sneak in
813:45 - and Peak at the data attributes inside
813:47 - the class we call this leaking and later
813:50 - we'll talk about iterators and why we
813:52 - iterators seem inconvenient and clunky
813:55 - but what they whole job really is is to
813:57 - hide uh implementation details to make a
814:00 - cleaner abstraction when the calling
814:02 - code depends on this the internal
814:04 - implementation names and approaches
814:06 - that's what it is to be leaky so we need
814:09 - to define a contract between the class
814:11 - and its calling code from above that we
814:13 - won't change and we're going to call
814:15 - this contract on interface AB another
814:18 - kind of word for that is abstraction and
814:20 - so if we look at all the code in our
814:23 - earlier implementation the whole whole
814:26 - thing is leaky right um especially if
814:29 - you look at that for Loop where it says
814:31 - for struct D node Cur equals DCT
814:33 - arrowead Cur not equal null C equals c
814:36 - next print c key and Cur value and and
814:40 - so what happens is it that should
814:42 - trigger a little like that says don't
814:46 - look inside these things and this is we
814:48 - later we'll talk about uh iterators how
814:50 - far we go and how we actually what we
814:53 - look at this code that we're looking at
814:54 - right here I think it's pretty
814:57 - but it kind of violates the abstraction
814:58 - boundary because we're looking too
815:00 - deeply into what the fact that this is
815:02 - even a link list we don't know there's a
815:04 - link list it may not be a link list it
815:06 - may be some other kind of a structure it
815:09 - may be a tree or whatever and we will
815:11 - later get to the point where we will
815:13 - make these things different
815:15 - implementations not just a link list and
815:18 - so that's that's this idea that like you
815:21 - you should be like oh no I'm there's
815:23 - this little wall but now I'm looking
815:25 - inside and then when you're looking
815:27 - inside that's when you kind of violating
815:28 - the abstraction boundary or we call it a
815:30 - leaky abstraction what this leads to is
815:33 - the notion of not all object attributes
815:36 - are the same and so we are when we're
815:39 - going to build an object we are going to
815:40 - decide what parts of these things are
815:42 - the contract and what parts are leave us
815:44 - alone we're going to hide this stuff and
815:47 - so the the concepts in object running
815:50 - programming are that things that the
815:52 - calling code is allowed to see whether
815:53 - they be data or methods are called
815:56 - public things that are like reserved for
815:59 - class use only are private and then when
816:02 - we start talking about inheritance which
816:03 - we W talk about too much there is this
816:05 - middle class called protected and that
816:08 - is stuff that classes and derived
816:10 - classes can look at but um but not the
816:13 - calling code so protected is sort of
816:16 - more like private from the point of view
816:18 - of the calling code so if you look at
816:20 - the abstraction boundary that we have
816:22 - here we see that the place where the
816:24 - abstraction boundary is sort of failing
816:27 - is that if that is that head and tail we
816:29 - want to make an abstraction boundary and
816:33 - um and say that look that the notion of
816:35 - head and the tail that's going to be all
816:38 - ours and that's going to be all
816:40 - inside um and that's inside the
816:42 - abstraction boundary and you're not
816:44 - supposed to mess with it so if we look
816:46 - at how we do this in Java there is a
816:49 - keyword called private and so Java we're
816:51 - making a point class and we're making it
816:53 - two double values that we're saying X
816:55 - and y are private which means you can't
816:58 - access it outside of this class the
817:01 - Constructor is public and the dump is
817:03 - public and so you see that the that that
817:05 - just means that you can't access X and Y
817:08 - outside of the class but you can access
817:10 - dump and the Constructor in C++ you see
817:13 - a private and a public and so private
817:15 - says this double X and Y are things that
817:17 - can only be used inside the class and
817:19 - public is the Constructor can be used
817:21 - outside the class and the dump can be
817:23 - used outside the class and this is just
817:25 - syntax
817:26 - that they put in now interestingly
817:28 - Access Control in Python is a little
817:30 - sort of wonkier because python doesn't
817:34 - really put things like public and
817:35 - private so what python is doing and
817:38 - you've seen these across all the python
817:40 - you've done where you see these double
817:41 - underscores dunders as it were like the
817:44 - Constructor you're not supposed to call
817:46 - the under underscore underscore and nit
817:48 - underscore underscore that's just when
817:50 - you create an object that's what happens
817:53 - um and so that in the init is an in
817:55 - internal method it's a private method
817:58 - uncore uncore X andore uncore Y are
818:00 - totally valid variable names except
818:02 - we're marking to the outside world hey
818:04 - you're not supposed to access these and
818:06 - then deaf dump the fact that we didn't
818:08 - put double underscore in front of it
818:10 - means that it's public and so double
818:12 - underscore are is the signal inside of
818:15 - python to do access control and we look
818:17 - at some of the stuff that C++ really
818:19 - does this was borrowed in many ways from
818:22 - how C++ does things internally so up
818:24 - next we're going to talk about about
818:26 - this map and the abstraction and the
818:29 - kinds of things that we do uh under the
818:31 - covers of the implementation details of
818:33 - the
818:35 - [Music]
818:54 - abstraction so now we're going to dive
818:56 - into the notion of abstractions we're
818:58 - going to take an interface and kind of
819:00 - compare it across a number of different
819:03 - languages we're going call this
819:05 - abstraction a map a map is a common term
819:08 - that we use kind of abstractly to
819:10 - describe key value Collections and each
819:13 - different language tends to have on a
819:15 - different name for that C++ they
819:16 - actually call it a map python calls it a
819:19 - dictionary Java also calls it a map but
819:21 - with an uppercase and in PHP we call it
819:23 - arrays and in JavaScript are there
819:25 - actually
819:26 - objects and then we're going to look at
819:28 - the iterator pattern as an abstraction
819:30 - for looping across multiple
819:32 - implementations so let's take a look at
819:34 - some sample um python code that's
819:37 - playing with a dictionary class so we
819:39 - created dictionary at the very beginning
819:41 - then we fill it up with some uh key
819:44 - value Pairs and so you'll notice that
819:46 - like D subzal 8 and D subz equals 1
819:49 - that's got to be a replacement so so
819:50 - there's no eight in there after that
819:52 - second uh replacement we then print it
819:55 - then we do a get of Z to see if it's
819:59 - there and then we do a get of X and it's
820:00 - not there so we see x equals 42 when it
820:03 - executes then we say give me an iterator
820:07 - of the items in this dictionary and so
820:10 - what that basically is going to do is an
820:12 - is the iterator itself is not a list in
820:15 - earlier version like python 2 when you
820:17 - ask for the items you tended to get a
820:19 - fully filled out list but that's a waste
820:21 - of memory so the iterator is simply a
820:24 - data structure that is keeping track of
820:26 - where in the list we are and then we
820:29 - call it next over and over and over to
820:32 - advance through the iterator so we don't
820:34 - have to make complete copy of all the
820:36 - data we just have a little pointer that
820:38 - advances through so items is a
820:42 - relatively small data structure meaning
820:43 - it doesn't include all the data in the
820:45 - dictionary it just is itself a pointer
820:49 - to something it's all internal remember
820:51 - abstraction is like hey I can give you
820:53 - the next thing
820:55 - internally there's pointers and all
820:57 - kinds of crazy things inside these
820:58 - iterators which we shall soon see so if
821:01 - you print out items you will see that
821:03 - it's like an item iterator for
821:05 - dictionaries that's what that class dict
821:07 - item iterator is telling us but then we
821:10 - can call the next function which is
821:12 - built into Python and say hey iterator
821:15 - do your job and hand me back the next
821:18 - thing or if we've let reach the end of
821:21 - of the dictionary Falls now come in any
821:25 - order these have any order dictionaries
821:26 - of course um but we get back the entry
821:29 - or we get back
821:30 - false so we say while entry then we
821:34 - print the entry and then we say hey give
821:36 - me the next one and then Loop up to the
821:39 - top and when it becomes false we're all
821:41 - done and so what you see because this is
821:43 - an order dictionary is you see Z1 X9 B3
821:47 - A4 and then it finishes so this we've
821:50 - not we don't know about next Arrow next
821:53 - we don't know even the in this case
821:56 - we're just getting a tuple back so we do
821:58 - know that but if we take a look at this
822:00 - same kind of concept in PHP uh we make
822:04 - an array and we fill it up Z gets to be
822:07 - eight Z gets to be one and that's an
822:10 - overwrite and then we put three more
822:12 - things in and we can print them out and
822:14 - we see that it's kind of an ordered
822:16 - dictionary as it were x z
822:20 - yba and then we do a get and we're using
822:24 - the null coals operator which is the
822:26 - double question mark so we say give me a
822:29 - subz and if that doesn't exist then give
822:32 - me back 42 so it's kind of like a get
822:34 - but that's a that's a PHP 7 in later so
822:37 - we look up uh X and we don't get it so
822:39 - we see x equal 42 and then we run
822:42 - through an iterator and again there
822:44 - again there's structures inside of
822:46 - arrays but we know nothing about how PHP
822:49 - implemented the arrays we just know that
822:51 - if we say for each a as key is aign
822:55 - value we can print out K andv and so
822:57 - this is a very abstract way of saying I
823:02 - want to go through all of them I want
823:03 - the keys and values give those back to
823:05 - me but I don't care how you do it
823:07 - whether you make extra copies of data
823:09 - Etc so that's another iterator pattern
823:12 - now in C the data structure we created
823:15 - is a map and if you read this you'll see
823:18 - that talks about how the implementations
823:20 - work etc etc etc but the C++ equivalent
823:25 - of a dictionary is in effect a map and
823:28 - so this is some C++ code the first thing
823:31 - we see is we're going to create a map
823:33 - and in this less than greater than
823:35 - syntax you're seeing that the map is
823:38 - mapping a string to an integer so the
823:41 - key in this case is a string and the
823:43 - value is an
823:44 - integer the previous two languages
823:47 - didn't care so much about types and so
823:50 - that's that's why they but now we're in
823:52 - C++ which cares greatly about types and
823:55 - and so now we say MP subz equals 8 then
823:58 - MP subz equal 1 which again is a replace
824:01 - operator then y b and a are set to two
824:04 - three and four respectively and um and
824:08 - then we do like a get operation and this
824:12 - one is a little funky and see why they
824:15 - didn't give us a get operation I do not
824:17 - know but what this is using as a Turner
824:20 - operation and saying MP count how many Z
824:24 - keys are inside this thing and if it's
824:26 - greater than zero we print out MP subz
824:28 - and if it's if it's not greater than
824:30 - zero if it's zero then we print out 42
824:32 - which functions like a python get on a
824:36 - dictionary so this syntax is funky you
824:38 - can go like Google it there's just no
824:41 - that it's like there's two ways you can
824:42 - do it and neither of them makes me
824:44 - particularly happy because I think that
824:46 - for a map-like object a get a get with a
824:49 - default is uh pretty valuable um the
824:53 - notion of running through and Counting
824:55 - means you found it or didn't find it and
824:58 - if you found it why don't you give it
824:59 - back to me but they just don't have a
825:02 - get but now we see an iteration so it
825:05 - says for auto auto is a type but it's an
825:08 - automatic type and it
825:10 - knows um that this um
825:13 - MP is a map string int and so it creates
825:17 - this current pointer which is a pointer
825:20 - to not exactly a m map string it's a map
825:22 - entry but we don't have to care about
825:24 - that there's a there's actually a type
825:26 - CER the variable cerr has a type
825:29 - whatever the MP begin is going to give
825:31 - us back as a type and it knows that
825:33 - based on the map string int and it makes
825:36 - Cur the right type so this is like
825:37 - whatever type you want but it is not any
825:40 - type it's a very precise type and that's
825:43 - a that's a sort of a Hallmark of C++ is
825:45 - all the types are very very precise so
825:47 - it's a for Loop you see the three
825:49 - semicolons the initial initialization
825:52 - Clause Auto Cur equals MP begin says Hey
825:57 - we've got our iterator get me started
826:00 - begin go to the beginning of it and give
826:02 - me the first one and as long as C is not
826:05 - equal to MPN the the the the end there
826:09 - are no more that's kind of like their
826:11 - null um and then plus plus Cur so we're
826:14 - incrementing Cur and then there's a key
826:16 - in a value and they don't call them key
826:18 - and value they call them first and
826:20 - second that's the thing coming back from
826:22 - MP begin has a attribute first and
826:25 - attribute second and we call the ccore
826:28 - St to convert that to a C string so I
826:30 - can use print F so I don't have to use C
826:32 - out just because I don't know why I
826:35 - didn't want to see out in this one but
826:36 - you see an abstraction where the first
826:40 - and the second are known but because
826:42 - this is a key in of value that's not
826:44 - such a big deal okay and so that's doing
826:47 - the same thing in C++ in Java they have
826:51 - a interface you see the word interface
826:53 - here an interface the named map less
826:58 - than greater than K comma V and and just
827:01 - like in C++ this is saying a map is a
827:04 - key and a value but what we're putting
827:06 - in here is the type of the key and the
827:08 - type of the value so we're going to make
827:10 - a map that has a string key and an
827:13 - integer value you might say why didn't I
827:14 - do string string and that's because it
827:16 - makes it just easier when I'm writing so
827:17 - much C code um it it also will be fun
827:21 - when we actually count things if you
827:23 - remember from a long time ago we did
827:25 - count
827:26 - but map is the class and string integer
827:29 - there's that um this is kind of
827:31 - polymorphism where it can be a map is
827:33 - that Maps strings to integers or
827:35 - integers to Strings or strings to
827:36 - Strings or who knows what to who knows
827:39 - what else meaning this map is
827:41 - exceedingly flexible and it doesn't care
827:43 - what kind of type it's it's using as
827:45 - long as the type meets some basic
827:47 - criteria so here's a bit of java code
827:50 - that does the same thing that we've been
827:52 - doing and so we see that we're going to
827:54 - make this variable map lowercase is of
827:57 - type map map of strings to integers and
828:00 - we're going to create a new tree map of
828:02 - strings to integers and the new creates
828:05 - a new object now the difference between
828:06 - a map and a tree map is a map is an
828:10 - interface and a tree map is
828:12 - implementation the tree map says we're
828:14 - going to build this key value store but
828:16 - we're going to store our data in a tree
828:18 - and that says to a computer scientist
828:21 - that it's going to have a certain
828:22 - performance and memory footprint to are
828:25 - a great way to store key value data um
828:29 - but they they're they take a little bit
828:31 - more memory than a link list as we will
828:33 - later see um and so we're we're choosing
828:36 - an implementation the other thing where
828:38 - it says tree map that you might use is
828:40 - what's called a hashmap which is a
828:42 - simpler map implementation but doesn't
828:45 - keep things in order so you can choose
828:48 - the map doesn't change but you can say
828:50 - I'd like this to be a tree map or a
828:52 - hashmap they're both key value stores
828:55 - one is an ordered key value store and a
828:57 - hashmap is a unordered key value store
829:00 - and they both have different
829:02 - performance behaviors and internal
829:05 - implementation
829:06 - details but it doesn't matter because
829:08 - they're both maps and this code that we
829:10 - write we could literally change tree map
829:13 - to hashmap and the code would work
829:14 - exactly the same but the order of the
829:16 - key value pairs might be a little bit
829:18 - different now you'll notice that when
829:21 - we're putting stuff in We call we call a
829:23 - method map.
829:25 - so everything we've seen so far says
829:27 - like map Open Bracket quot Z quote close
829:31 - bracket equals 8 Java chose not to do
829:34 - what's called operator overloading and
829:36 - so it really does everything in a method
829:38 - so the kind of things that you think are
829:40 - going to be done with an assignment
829:41 - statement or uh some other syntax tend
829:45 - to be done it's like okay we're going to
829:48 - do everything with methods and
829:51 - parameters Now map is the object
829:54 - instance that's being worked on and Z
829:57 - where that's basically saying map subz
829:59 - equals 8 and we'll do an aut of Z1 which
830:02 - is going to overwrite you'll see I'm
830:04 - doing the same thing in each one of
830:05 - these things and then put in YB and a
830:07 - with two three and four respectively I
830:10 - can print it out and if you look at the
830:11 - print out it looks a lot like what it
830:14 - looks like in Python there's this thing
830:16 - called get or default map. getet or
830:19 - default which is you know if the key Z
830:21 - is in there give it to the value or just
830:24 - give me 42 is a default and in the first
830:27 - casee Z is there in the second case X is
830:28 - not there so you see X is 42 that's not
830:31 - a bad name for it it's a little more of
830:32 - aose than get it's pretty much the same
830:35 - as what we do in Python and then we have
830:37 - an iterator and now you see in this for
830:40 - Loop you see kind of the notion of the
830:44 - fact that the iteration variable
830:47 - is has a type so we don't have this Auto
830:50 - later versions of java may have an auto
830:52 - but now I'm explicitly showing you it's
830:54 - not a map string integer it's a map.
830:57 - entry which is an entry inside of a map
830:59 - it's an abstract interface to the entry
831:03 - inside of a map each entry that's got to
831:06 - match the string integer that's in the
831:07 - map and so there's a map string integer
831:09 - which is the whole map and then there's
831:11 - a map entry which is one of the entries
831:13 - but this map entry is also kind of an
831:16 - iterator right so we're going to iterate
831:19 - and move forward so it's not just the
831:21 - key and the value it's really the key
831:23 - and the value and the position but we
831:25 - don't see the position all we know is we
831:27 - keep we use this four syntax which is
831:30 - kind of like a four in in Python and we
831:34 - call map. entry set which is I want a
831:38 - set of all the entries and that map
831:39 - entry set does not construct a giant
831:42 - inmemory list and then go through it
831:45 - that actually creates a single map entry
831:48 - with the key and the value of the first
831:50 - one and then you hit it again and it
831:51 - gives you the second one you hit again
831:53 - it gives the third one and pretty soon
831:54 - it gives you null which means that the
831:56 - loop is going to stop and the entry
831:59 - itself does have a key and a value now
832:01 - key and value are known in the map entry
832:04 - interface so you say entry. getet key
832:07 - and entry. getet value now that they're
832:09 - using um methods to give us back the key
832:13 - and the value versus in the previous
832:15 - things you saw attributes being used in
832:18 - the iterators and that's because Java is
832:21 - obsessed with preferring to use access
832:24 - accessor methods like Getters and
832:27 - Setters versus just grabbing attributes
832:30 - and the key thing is is they can add
832:31 - just a little bit of business logic if
832:33 - they want rather than having to do
832:35 - something and have the key and the value
832:36 - already completely computed sitting in
832:38 - an attribute for you to use entry get
832:41 - key sometimes it just grabs something
832:43 - that's already got computed or it might
832:45 - actually go do something or do some work
832:47 - and so by putting these things in what
832:49 - they what Java calls Getters and Setters
832:51 - in this case we're not seeing a we're
832:53 - not seeing a Setter so much
832:55 - um but making it so that instead of it
832:58 - being entry. key it's entry. getet key
833:00 - open print close print that's a very
833:02 - Java way of thinking about this so we
833:06 - started by talking about a simple python
833:09 - dictionary where we filled up we use get
833:12 - then we create an iterator and then we
833:14 - abstractly Loop through that iterator
833:18 - and that's what we wanted to accomplish
833:20 - in this section just to see how that is
833:22 - done in a wide range of different
833:24 - language anges cuz the map
833:26 - abstraction is kind of like this thing
833:29 - that we use as software developers and
833:31 - then it's a a kind of a sealed thing and
833:33 - then Underneath It All the magic
833:36 - [Music]
833:46 - happens so I want to talk about the C++
833:49 - programming language for just a bit
833:52 - because C++ plays a really really
833:54 - important role in the development of
833:56 - objectoriented programming C of course
833:59 - came out like 72 through 78 and then C++
834:02 - came out in 80 and then both C++ and C
834:06 - co-evolved uh through the early 1980s
834:09 - and then you see things like C and Java
834:11 - and Python and PHP
834:13 - all informed heavily by
834:17 - C++ if we look at how object oriented
834:19 - was happening kind of before
834:22 - C++ it there was there was
834:26 - it was like
834:27 - C++ wasn't really appreciated by the
834:30 - typical mainstream procedural programmer
834:32 - of the day and so things like alal and
834:36 - simula they it was kind of like there
834:38 - were tribes that liked procedural and
834:40 - tribes that liked uh uh objectoriented
834:44 - but then C++ came along and sort of
834:47 - pretty much unified it which meant that
834:49 - you know you probably learned python as
834:51 - your first programming language and you
834:53 - were using object or progr from the time
834:55 - that you started and C++ is what sort of
834:58 - unified that and it was the C++ as the
835:02 - quickly number one procedural
835:04 - programming language and then
835:07 - C++ as the number one um object Orient
835:10 - programming language that kind of made
835:13 - brought order to the notion of
835:15 - procedural objectoriented hybrid Etc and
835:18 - sort of everything that kind of came
835:20 - after
835:21 - 1980 was really strongly influenced and
835:25 - informed by C and
835:27 - C++ so let's take a look at how this
835:30 - sort of changed over time by looking at
835:32 - some syntactical influence so C++ which
835:36 - was the earliest which is a
835:37 - pre-processor plus a compiler it turned
835:40 - into a compiler on its own eventually
835:42 - but it has this concept of a map that
835:44 - has uh a separately selectable uh type
835:47 - of the key type of the value and it uses
835:50 - the square brackets map open square
835:53 - bracket Z close square bracket equals 8
835:56 - and that is in effect a put right that's
835:59 - like a insert into the map um or update
836:02 - of the key and it's a pretty succinct
836:05 - syntax and so python came up with a way
836:09 - python really didn't want to make a more
836:11 - complex syntax than C++ so python worked
836:15 - on its language to make it so that you
836:17 - could just say d equals di ICT and it
836:19 - was a typeless language and so we don't
836:22 - care the fact that it's going to be
836:23 - strings mapping to integers because you
836:25 - can map lots of things to lots of things
836:27 - in Python but it did follow the D subz
836:31 - equals 8 and again you you use this from
836:34 - the beginning when you first started
836:35 - programming in Python and you thought
836:36 - that was just natural but what's really
836:38 - going on is more like what Java did in
836:40 - 1995 we're not going to use the square
836:42 - bracket to do put stuff into a map we're
836:45 - going to be more pure here and we're
836:47 - going to create methods now if you look
836:48 - at under the covers in Python you see
836:50 - that that is really a method that does
836:53 - that insert of the The Key Of Z and the
836:56 - value of
836:57 - eight but if you look at Java it says
836:59 - map string integers so we again have
837:01 - this notion of a generic class capital
837:04 - map map string integer map which is our
837:08 - object variable equals new tree map
837:10 - string integer which of course is
837:11 - choosing the underlying implementation
837:14 - and then they have the syntax of a
837:17 - Setter style map. put and then they're
837:21 - giving the key and the value as two
837:23 - different parameters there's choices
837:24 - that each of these languages are making
837:26 - and I'll try to highlight them as we go
837:29 - through it I want to talk a little bit
837:30 - about how
837:32 - C++ and its object under approach and
837:34 - design made it so that a class like the
837:39 - map works almost the same as like a sort
837:42 - of a low-level class like a float or an
837:44 - in and it has access in particular to
837:47 - kind of the special characters or
837:49 - operators like square brackets or plus
837:51 - or minus how that happens and it is that
837:55 - that you can create a specially named
837:57 - method inside of a C++ class that the
838:01 - compiler will consult and
838:04 - call when it encounters certain what you
838:07 - think of as language syntax meaning that
838:09 - as it's parsing the language syntax like
838:12 - square brackets it's like oh I've got
838:13 - some code to do some work here this
838:16 - concept is called operator overloading
838:18 - meaning that the
838:20 - operator the behavior of the operator is
838:23 - controlled by the writer of the class
838:25 - you are writing a class so in this bit
838:27 - of code here I've created for no
838:31 - particular reason a a class that I call
838:34 - 10 integers in a row and I have a array
838:38 - of 10 integer values but that's private
838:41 - so that's something that the outer class
838:43 - can't talk to right so you can't say 10
838:47 - in 10 like in the main you 10 do values
838:49 - is like no you're not allowed to touch
838:51 - that because it's private but then when
838:54 - what I do is I create a public
838:58 - method which is the square brackets
839:01 - operator method the method to be called
839:03 - when the compiler encounters square
839:06 - brackets my class name my object name
839:09 - followed by square brackets call me now
839:12 - the first thing we see is the return
839:14 - type of this operator square bracket
839:17 - operator code is an integer reference an
839:20 - integer that can either be read or
839:22 - written which means it can be on the
839:24 - left or right hand side of an assignment
839:27 - statement and the parameter that it's
839:30 - being given is an integer index which is
839:34 - the thing inside of the square brackets
839:36 - now it is a reference because of the
839:38 - Amper sand but it is a constant
839:40 - reference meaning we are not allowed to
839:42 - change
839:43 - it inside of this function okay so const
839:48 - means we're leaving it alone which means
839:50 - we're not allowed to say index equals 42
839:53 - inside the operat the square bracket
839:55 - operator
839:57 - method and so what we're returning is
840:00 - that private variable values sub index
840:03 - but we are returning a reference to it
840:05 - so wherever it appears in the original
840:07 - C++ code in the main what happens is
840:11 - that reference can be like I said on the
840:13 - left or right side of an assignment
840:15 - state so let's take a look at how this
840:16 - works in the main code I am going to
840:18 - create a variable called 10 of type 10
840:21 - int and then I say 10 sub 1 equals 40
840:26 - which means I'm storing 40 in position
840:29 - one but when it sees that 10 sub one it
840:31 - says oh oh this little class has an
840:34 - operator square bracket operator so I
840:36 - better call that little method pass the
840:38 - one in then that returns a reference to
840:43 - values sub one and then into that
840:46 - reference the 40 is assigned now python
840:49 - doesn't have return a reference and it
840:52 - doesn't have a call a reference
840:55 - C kind of does but it's very they're
840:58 - pointers and so references and pointers
841:00 - are different references you'll notice
841:03 - there's no special syntax to dreference
841:05 - a re a reference whereas you have when
841:07 - you get a pointer you got to have
841:08 - special syntax to D reference a pointer
841:11 - so this notion of call by reference and
841:14 - return by reference is like impressive
841:17 - in C++ and allows it to do a lot of
841:20 - things and allows us to have this
841:22 - seemingly native line of Code 10 sub 1
841:26 - equal 40 which is really just a bunch of
841:28 - method calls amazing and then we
841:32 - immediately say print 10 sub one
841:33 - contains and then 10 sub one and again
841:36 - when this is kind of a right hand side
841:38 - of an assignment statement it's looking
841:40 - at up it calls the method the operator
841:43 - the square bracket operator method
841:44 - passes one into it and then we return
841:48 - Valu sub one and then that's what gets
841:49 - printed out and so then we say 10 sub5 =
841:55 - 10 sub 1 + 2 and now we see 10 sub 1 on
841:59 - the right hand side of an assignment
842:01 - statement which calls that same code in
842:05 - the operator brackets method within the
842:08 - class passes in the one returning the
842:11 - reference to Value sub one but then that
842:15 - reference is just 40 and then we add two
842:17 - to it and then we assign it into T sub
842:19 - five which is again calling the in
842:22 - operator method to get a reference to
842:24 - values sub five and that assignment
842:27 - happens all I
842:29 - really did was kind of faked it but I I
842:33 - used it to show you this like lovely
842:37 - ability to do operator overloading when
842:40 - I first found my way into
842:43 - Java my greatest disappointment in
842:46 - because I taught a C++ class and then I
842:48 - learned Java I wasn't a wiiz at C++ but
842:51 - I really thought it was pretty ele again
842:54 - so for me my brain was so I didn't Learn
842:57 - Python first I learned C++ first and I'm
843:00 - like hey that's what object Orient ought
843:01 - to be and then I'm looking go to Java
843:03 - and Java didn't do that Java basically
843:06 - does not want and did not want as a
843:10 - choice to take values by reference in in
843:13 - method calls and even more it did not
843:17 - want to return references in the return
843:20 - values of method calls that those two
843:22 - things the Ampersand in the return type
843:25 - and the % in the call parameter call
843:28 - those are essential for C++ to
843:31 - accomplish this and Java did not want to
843:34 - return references in particular because
843:37 - it has to do with garbage collection
843:40 - variables going out of scope etc etc and
843:42 - if you return a reference you don't know
843:43 - when it's out of
843:45 - scope
843:47 - Etc um these are powerful complex and
843:52 - potentially quite dangerous things right
843:54 - but the C++ design was hey you are a
843:58 - samurai warrior and you are going
844:02 - to you are going to use these very
844:05 - wisely and we don't want to take power
844:08 - away from you we want to give you all
844:10 - the power that you might want and just
844:14 - trust that you're not going to make
844:15 - mistakes right and so it trust is that
844:18 - Java make and python make are like no no
844:20 - no we don't want you to make mistakes so
844:21 - we're not even going to give you this
844:23 - kind of thing there other ways to do
844:25 - everything U things like topple returns
844:27 - in C is a good example of
844:32 - um kind of an homage to this notion of
844:35 - returning things is not always just a
844:37 - single thing so um but C++ is kind of
844:41 - unique now again um
844:44 - python emulated the
844:47 - C syntax that was quite beautiful that
844:51 - was a result of C's support
844:54 - for operator overloading and here's the
844:57 - here's the thing where like it all comes
845:00 - together so python saw the beautiful
845:03 - syntax that
845:04 - C++ when you did the right things the
845:06 - compiler would give you this let you use
845:09 - this beautiful syntax and still call
845:10 - your methods inside the object but they
845:12 - didn't want to do the call by reference
845:15 - and return by return reference that the
845:18 - C++ did and so what they did is they did
845:22 - basically a syntax transformation
845:24 - if you look python is in a sense very
845:28 - javal likee in that everything has to
845:30 - happen through methods but then there's
845:32 - these hidden methods okay let's take a
845:35 - look at the code so I'll create a
845:37 - dictionary named X and then we say x sub
845:39 - 1al 40 and again we know what this means
845:41 - that means somewhere in the key the key
845:43 - under the key one there's 40 now I can
845:46 - print this out by saying x. Dore get
845:50 - item Dore open print one close print
845:53 - that's taking the index inside of the
845:55 - square brackets and passing it to a
845:59 - predefined python
846:01 - understood rule for what get item that
846:04 - the the square brackets turn into double
846:07 - underscore get item double underscore or
846:09 - X is the object and the parameter is the
846:12 - syntax so if we think about it on the
846:15 - right hand side of an assignment
846:17 - statement where we're just reading it
846:19 - it's just doing a get right it's kind of
846:21 - doing a getter like thing give me item
846:24 - one and then out comes the 40 and that's
846:26 - how the print of x sub one is a 40
846:29 - that's really what happens under the
846:32 - covers is there is a class which has
846:34 - under underscore uncore get item
846:36 - underscore uncore defined in it as a
846:38 - method and that's how it loads x sub
846:42 - one so if we go down another line and we
846:45 - say x sub 5al x sub 1 + 2 seems simple
846:48 - enough and and literally for years
846:51 - python software developers don't even
846:52 - need to know that this is miraculously
846:55 - and beautifully complex but what this
846:57 - translates into at runtime by compiler
847:01 - syntax
847:02 - transformation is the x sub one on the
847:05 - right hand side turns into a x.g get
847:07 - item pren one which pulls up the 40 and
847:11 - then plus two gets added to it but then
847:14 - that expression is passed into x. set
847:18 - item in position five so the the leftand
847:21 - side of the assignment statement is
847:24 - the x of five equals part and that's
847:26 - calling set item so if it's doing a
847:28 - square bracket look up on the right hand
847:29 - side it's calling get item and if it's
847:31 - doing a square bracket on the left hand
847:33 - side of an assignment statement it's
847:34 - doing a set item so this means that
847:36 - there was no need to return references
847:39 - no need to process references none of
847:41 - the
847:43 - Hoops that C++ went through and so you
847:46 - see that python did not did not choose
847:49 - to implement the way C++ did but they
847:52 - supported the very elegan syntax now and
847:55 - then you'll see that Java in 1995 takes
847:59 - it uh or 94 takes it one step further
848:02 - and that they're not even going to give
848:04 - you that cool syntax they're like no it
848:06 - we're going to say just do X dop put and
848:09 - X do get and call it good if you if you
848:12 - know that X is an object and you need to
848:14 - do a get in the put do the get in the
848:16 - put we're not going to do this little
848:17 - syntax transformation that makes it
848:19 - pretty and we're also not going to give
848:21 - you uh operator over overloading because
848:25 - again operator overloading requires
848:27 - references because it allows the
848:31 - class to return a thing that can be used
848:33 - on either the left or right hand
848:37 - side and again Java did that because
848:40 - they did not want to make their memory
848:42 - management more complex um so it
848:49 - a hard to
848:51 - argue but what this kind of shows you is
848:55 - like the
848:56 - amazing interplay between these
848:59 - languages um Garn strrip went to school
849:02 - in Denmark and started working on C++ in
849:06 - Denmark but then was hired to go to Bell
849:09 - labs in New
849:10 - Jersey where he met and worked with for
849:14 - a number of years uh bjn strrip and
849:17 - Dennis Richie and all the folks at Bell
849:20 - Labs that gave us Unix and C over the
849:22 - decades and so C+ plus kind of came to
849:24 - the world from Bell Labs from Murray
849:27 - Hill and and G van rasum who was in
849:30 - Netherlands at the time really was just
849:32 - looking at all this stuff and using all
849:34 - this stuff and an expert in C and
849:36 - C++ and back in those days we tended to
849:39 - Look a Lot at like the code that C++
849:41 - generated and G's like I'm just GNA I'm
849:44 - G to borrow these are really good
849:45 - patterns and so that's how we see so
849:48 - much influence of not just the syntax
849:50 - but the actual runtime conventions and
849:53 - and like
849:54 - if if you look at some of the generated
849:56 - C++ code the concept of private is often
849:58 - done with underscores they use
850:00 - underscores a lot Python's like yeah
850:02 - I'll just borrow that I'll just use
850:03 - double underscore as my signal of this
850:06 - private and a way you go so to
850:09 - show the influence that C++ and C had
850:14 - over python both in the syntax and in
850:16 - the runtime we can take a quick look at
850:19 - some internal details of how python
850:21 - works and python turns out to have
850:24 - almost identically implemented operator
850:26 - overloading in as as C++ but we don't
850:30 - see it it's all internal you have to
850:32 - kind of look so on on the left hand side
850:35 - that's the code that I just got done
850:36 - going through that's the C++ code that
850:39 - has the private values and then the
850:41 - public uh operator
850:43 - overload and now if we look on the right
850:45 - hand side we see a class 10in and I'm
850:47 - creating a double underscore values
850:49 - which is values private as a dictionary
850:52 - and then I'm going to Define the set
850:54 - item this this is like a private method
850:56 - called set item and then a private
850:58 - method called get item python basically
851:01 - has the left side and right side
851:03 - assignment of of uh of bracket lookup
851:06 - operators different and the set item is
851:08 - the left- hand side and the get item is
851:10 - the right hand side uh you'll see that
851:12 - in the set item I'm just taking self
851:14 - values sub index equals value and I'm in
851:17 - the in the getter I'm returning self
851:20 - uncore value sub index so that's the
851:22 - right hand side so if we look at the
851:24 - code I see let's make a 10 int on the
851:26 - variable 10 10 sub 1 equals 40 now
851:29 - python transforms that 10 sub one syntax
851:33 - into a set item of 10 comma the number
851:38 - one comma 40 and then call set item and
851:40 - you can see of course it worked right
851:44 - the three values are self index and
851:46 - value well self is 10 which is the
851:50 - object instance the index is the thing
851:53 - inside the square brackets and the value
851:55 - is the result of the expression on the
851:57 - right hand side it's not just 40 but
851:58 - it's the expression on the right hand
852:00 - side and so that goes in right we see
852:03 - the print 10 sub one well that is a
852:07 - right- hand side reference to 10 sub one
852:09 - so that's going to called get item self
852:12 - is 10 and then index is the one and
852:16 - we're going to just return it and that's
852:17 - going to print out a nice little happy
852:19 - little integer which is exactly the
852:21 - variable 40 so it says 10 10 sub 1
852:24 - contains 40 and at this point it should
852:26 - be obvious what's going on when I say 10
852:28 - sub 5al 10 sub 1 + 2 well the 10 sub 1
852:31 - on the right hand side turns into a get
852:34 - item that gives us back the 40 Value
852:37 - then the 40 and the two are added
852:39 - together to finish the right hand side
852:40 - of the expression then we're going to
852:42 - sign that into T sub five which then
852:45 - turns into a set item of 10 comma 5
852:48 - comma 42 and then that stores 42 in
852:52 - position five in our private VAR varable
852:54 - values private values variable and then
852:59 - I printed out which is the left hand
853:00 - side lookup of 10 sub5 which calls get
853:02 - item again with uh self is 10 and index
853:06 - is five and so we get the 42 and so you
853:09 - see how they're so similar inside I mean
853:15 - again like if you look at generated C++
853:16 - code from early C++ code compilers
853:19 - you'll see these doual underscores used
853:21 - in various places which means that
853:22 - python in internal implementation use
853:25 - the same patterns as C++ did in its
853:28 - internal implementation pan chose not to
853:31 - do call by reference and return by
853:32 - reference Java chose not to be not to do
853:36 - call by reference and return by
853:38 - reference and Java chose not to do the
853:40 - the fancy syntax transformation but you
853:43 - know who knows maybe maybe one of these
853:46 - days Java could do that syntax
853:48 - transformation and be like whoa Java has
853:52 - everything and then to some degree
853:54 - python has shown the way about how you
853:57 - do this without doing um without doing
854:01 - call by reference and again that
854:02 - Ampersand operator and Ampersand index
854:04 - on the left hand side that's the like
854:06 - scary part where language designers are
854:08 - like I'm not sure I want to go do that
854:11 - because C++ is not a a garbage collected
854:15 - language but Python and Java are garbage
854:18 - collected languages and that's not the
854:19 - only reason that's that Python and Java
854:22 - didn't want to do call by reference but
854:24 - it is one of the reasons that you kind
854:27 - of just simplifies to know that there
854:31 - when a function is done it's done and
854:33 - there's not like sneaky little pointers
854:34 - inside that function that need to stay
854:36 - alive so it allows you to throw stuff
854:38 - away with functions are
854:40 - finished okay enough of that just again
854:45 - I'm just trying to show you in the
854:46 - simplest possible examples the kinds of
854:50 - design decisions that all these language
854:52 - and Library designers were doing as they
854:55 - buildt the languages that we know love
854:58 - and use
854:59 - [Music]
855:19 - today so it's time to stop deep diving
855:22 - into objector in theory and get to
855:23 - writing some code so we're going to
855:25 - start with something simple going to do
855:27 - encapsulation the second thing we're to
855:29 - do is iteration but for now we're just
855:30 - going to do encapsulation and then in
855:32 - the next section we'll do iteration and
855:35 - really most of this code you've already
855:37 - done we're just kind of refactoring it
855:39 - and moving things around and taking
855:41 - these you
855:43 - know functions that we named by
855:46 - convention and we allowed the call-in
855:48 - code to use and uh and moving them into
855:52 - the class using some pointers so a real
855:55 - accomplishment here is the map Arrow put
855:59 - the map Arrow get and the map Arrow Dell
856:02 - these things are now named and accessed
856:05 - in such a way that they are attributes
856:08 - the the functions we're calling are
856:10 - attributes in the class itself and so
856:13 - other than that it's not that different
856:14 - we and so it's not that big of a deal
856:17 - the other thing we're going to do is be
856:18 - a little more explicit about what things
856:21 - in these classes are public and what
856:23 - things
856:24 - in this class that we're building are
856:25 - private so we'll start with a map entry
856:28 - this is the structure that makes up the
856:30 - nodes of the link lists uh the key is a
856:33 - character string and the actual value is
856:35 - an integer that we we're just going to
856:37 - make it simple to got to we got to
856:39 - dynamically allocate the key like we've
856:41 - been doing um and then we have a pre and
856:44 - a next the key there is the pre and the
856:46 - next are double underscore so that means
856:49 - they're private but we are going to
856:50 - decide that key and value are public and
856:53 - we just indicate that much like python
856:56 - would do by not putting double
856:57 - underscores in front of it and
856:59 - remembering in our mind that they're
857:01 - allowed to be used in calling
857:04 - code the map structure uh most of it
857:07 - looks pretty simple we have a head we
857:09 - have a tail and we have a count you've
857:11 - been maintaining those for some time now
857:15 - those are private attributes so we've
857:16 - renamed them in such a way that they
857:18 - have double underscores in front of them
857:20 - and then we have a series of public
857:22 - methods we have five of them the key
857:25 - thing is these are Pointers to functions
857:29 - and that's what void starp put that's
857:31 - parentheses star put that means that
857:34 - there is a we're allocating a variable
857:36 - in the structure named put and it is a
857:40 - function pointer that will return a void
857:43 - it's a pointer to a function that
857:44 - returns a void so not only are we
857:46 - defining the attribute that's we're
857:49 - going to use to access the function
857:50 - we're also defining the calling sequence
857:53 - it returns a void and it takes three
857:55 - parameters a struck map pointer self
857:59 - charar key and int value so when it's
858:02 - all said and done this is not putting
858:03 - the code in here as it might say in
858:05 - JavaScript for example what is is a
858:08 - single 64-bit number which is a pointer
858:11 - to the beginning of a function now the
858:14 - function method signature has to match
858:17 - so we're defining the method signature
858:19 - but in terms of allocating we're really
858:22 - allocating one one pointer for put one
858:25 - pointer for get one pointer for size one
858:27 - pointer for dump and one pointer for
858:29 - Dell and again you know you look at get
858:32 - well get takes as its first parameter a
858:35 - pointer to the map which is self a key
858:38 - that we're going to use to do the lookup
858:39 - and then a default value to return and
858:41 - then get returns and int and so that
858:44 - that's pretty straightforward it took me
858:46 - a little while to get the pattern right
858:48 - about because the parentheses here are
858:50 - really really important because we're
858:52 - both def finding the attribute name and
858:56 - the rules of its use and the method
858:59 - signature of the function that we're
859:00 - eventually going to point to okay but
859:04 - that's pretty much it right we we're
859:06 - just going to put these things in and so
859:08 - the Constructor is pretty
859:10 - straightforward it's not that different
859:12 - than the Constructor that you did we got
859:14 - to build these functions double uncore
859:16 - maput double AR get map size they're
859:19 - they're outside of this they're above us
859:21 - in the source code somewhere and we're
859:23 - just saying P put which is an attribute
859:27 - put public attribute put is equal to
859:30 - Ampersand the address of the double
859:32 - uncore maput
859:34 - function super simple a Ampersand is
859:38 - address of address of that function get
859:40 - is address of that function size is
859:42 - address of that function dump is address
859:44 - of the function and we're done and and
859:47 - this is kind of showing you that the
859:50 - this is let's see head is a 64-bit
859:53 - pointer Tail's a 64-bit pointer count is
859:56 - probably a 64-bit integer or a 32-bit
859:59 - integer put get size dump and Dell are
860:01 - all 64bit so the size of the map itself
860:05 - the map structure is about you know 10
860:09 - words or less and that again has to do
860:12 - with uh efficiency right but you
860:15 - probably have most of the code you need
860:17 - for map put map get map size map dump
860:19 - and map
860:20 - Dell so map dump is pretty simple you
860:24 - know the if we look at this the you know
860:26 - it's a the self is the pointer to the
860:29 - map so it has a head and a next and
860:31 - we're going to just go through it until
860:32 - Cur is equal to null we got a map entry
860:34 - which is the type now we don't double
860:36 - underscore the C because that's really
860:38 - just an automatic variable inside this
860:40 - function that has nothing to do with the
860:41 - outside world and you'll notice that
860:44 - we're just as access UND double uncore
860:46 - head we're accessing double underscore
860:48 - next because we're in the class right
860:50 - and so that those are private but are
860:53 - totally legit to access them when we're
860:56 - building a dump tool inside the class so
860:59 - private things are accessed in the
861:01 - methods in the class that's normal right
861:04 - we don't have to hide those I'll tell
861:06 - you when I'm building something like
861:07 - this the first thing I want to get to
861:09 - work as some kind of a dumper because
861:11 - how I mean when I write this code before
861:14 - I hand parts of it over to you I have
861:16 - like map dump map dump map dump map dump
861:19 - every line I put a map dump and
861:20 - eventually when stuff starts working I
861:22 - start taking the map dumps out so just
861:24 - debug debug debug debug always so that's
861:27 - that's why I'm just like I couldn't
861:29 - write this code if I didn't have a map
861:31 - dump and so I'm going to make you guys
861:33 - do it as well so the destructor like
861:35 - most destructors the key thing is to
861:37 - draw the picture and figure out what
861:40 - parts were dynamically allocated and
861:42 - then call free or which parts came from
861:45 - Malak and then make sure you free them
861:48 - and so we're just going to Loop through
861:49 - and again we're in the class so we're
861:51 - happily using double uncore
861:53 - attributes we're going to Loop through
861:56 - we're going to and the order this is
861:57 - always important but by now it should
861:59 - make sense we're going to free the key
862:01 - because remember that's a string pointer
862:02 - that we maled we do not need to free the
862:05 - value that's just actually part of the
862:07 - map entry struct and we're going to get
862:09 - rid of that in a second we're gonna
862:11 - we're going to advance to the next one
862:13 - first and then we're going to free the
862:15 - current map entry and then we're say
862:17 - Curr next and we're going to Loop up and
862:19 - So eventually we're just going to go
862:20 - through the link list and breath
862:23 - the key and then free the entry itself
862:26 - and we've given back all of our data and
862:28 - then we're all done with that we
862:29 - actually free
862:31 - the 10 words or so that is the map
862:35 - structure again this should start to
862:37 - look familiar to you so get is pretty
862:41 - simple as long as you have some code
862:43 - that like is map
862:45 - find um you know map find is going to do
862:47 - all the hard work but it but map fine
862:49 - can look at underscore head and and um
862:52 - and all that stuff and next and look at
862:54 - all that write some for Loops should be
862:56 - not too hard um and again underscore
862:59 - underscore map find is private but we're
863:02 - in the class and so just have fun
863:05 - talking to the private
863:07 - stuff Matt put is something you're going
863:10 - to have to write but if you think about
863:12 - it if you get map find and it returns
863:14 - you that it will and you've done this
863:17 - before you've used a find like method to
863:20 - find the thing in the link list and you
863:23 - update it if you found it it's really
863:25 - simple you just change the value in
863:27 - return and if not you add it to the end
863:29 - of the L you construct a new map entry
863:31 - and you add it to the end of the list
863:33 - and so again I just hope by now you can
863:35 - knock these things out and so that's
863:39 - basically it I mean if you really think
863:41 - this is was a very simple section where
863:44 - all we're doing is changing from
863:46 - globally named functions we're enforcing
863:49 - the rules of private double underscore
863:53 - and then we're taking those pointers we
863:55 - declared pointers to functions in our
863:57 - map and then our Constructor sets them
864:00 - up and the rest is really just
864:02 - refactoring code that you pretty much
864:04 - already have
864:07 - [Music]
864:27 - so now we come to the last section of
864:29 - this module and that is iterators it's
864:32 - all been building up to iterators and
864:35 - this is a situation where you might say
864:38 - wow I don't like iterators iterators
864:41 - seem like a more complex way to write
864:43 - Loops than just looking at like head and
864:47 - next and sneaking in and violating the
864:49 - abstraction
864:50 - boundary but as you'll see in the
864:52 - overall next module you're going to have
864:54 - to have very different underlying data
864:58 - structures and we want to be able to
865:00 - write the same code over and over again
865:03 - so at at some level what we're doing
865:06 - here is we're building a map
865:09 - implementation that can be a link list a
865:13 - hashmap list I mean a hash based map a
865:17 - list based map or a tree based map and
865:21 - what we want is this code right here
865:24 - this code should not change we should
865:27 - say hey give me a map we got a map entry
865:30 - we got a map iterator those are all part
865:32 - of the contract that we have with the
865:35 - object be it a link list tree or map our
865:39 - hash we're going to do a put put put put
865:42 - dump get get now we're going to
865:46 - iterate a hash won't even have like a it
865:49 - doesn't have a head and the next it's
865:51 - not going to work right so we're going
865:54 - to have to say hey there's this
865:57 - abstraction give me an iterator for your
866:00 - map okay and we don't know what's in the
866:04 - iterator we don't need to know what's in
866:06 - the iterator the only thing we need to
866:08 - know is it has a method called Next
866:11 - that's it so we're basically saying
866:13 - let's get started give me an iterator
866:16 - from the map call the iterator method
866:19 - passing the map instance as a parameter
866:21 - and give me back iterator and then we
866:23 - write a while loop and we say hey
866:25 - iterator give me the next thing it is up
866:28 - to the iterator to start at the
866:30 - beginning and then advance and move
866:34 - down and when we get null we break if
866:37 - not we print key in value from the CER
866:40 - now CER is of type map entry there's a
866:43 - map iter iter next and then CER is what
866:47 - we get back from iterator so we get from
866:49 - iter itter next we get back a map entry
866:52 - and so if you recall key and value are
866:55 - public in the map entry so we we could
866:58 - have I could have had you hide those
867:00 - behind sort of Getters and have get key
867:02 - and whatever and name those underscore
867:04 - but we're just going to leave them
867:06 - public attributes for
867:08 - now if we really going to be the if we
867:11 - were implementing Java I mean right now
867:13 - we're kind of hardcoding this string key
867:15 - integer throughout so it's going to be
867:17 - okay and then of course we call the
867:19 - destructor on the iterator once we're
867:21 - kind of done with that Loop and then we
867:23 - call the destructor on the overall map
867:25 - and this code should be roughly the
867:29 - same when we go from link list hashes to
867:34 - trees this is the moment and it's this
867:37 - iteration pattern
867:40 - so I'm going to do a bunch of pictures
867:42 - and so I just wanna we I've been drawing
867:46 - some pretty complex pictures on these
867:47 - things but by now the whole pattern of
867:49 - what next means and preve and these
867:52 - things being null a doubly link list and
867:55 - that key pointing to another little uh
867:59 - you know a Char star key which points to
868:01 - another little statically allocated
868:02 - thing and the head points to the tail
868:05 - and head and the tail and all that stuff
868:08 - I'm just going to for this section
868:10 - really simplify these pictures to say
868:12 - look there's a variable called Head
868:15 - somewhere and it points to a zal 22 then
868:18 - it points to a wal 42 and then that's
868:20 - the last one and that points to next
868:22 - there points to null and so I'm going to
868:24 - really use a succinct representation of
868:28 - Link list uh going far forward the if we
868:32 - re review what we don't want to do right
868:35 - we do not want our call and code to know
868:38 - about count we do not want it to know
868:40 - about head we don't even want it to know
868:43 - about next within the entries right we
868:46 - don't want to know that we do want to
868:48 - know about key and value and so the
868:50 - calling code where map eror number
868:53 - underscore head current underscore next
868:56 - no no no no no that's not allowed right
869:00 - those are private so in our calling code
869:02 - if we're if we're looking at things have
869:04 - underscores technically we could do it
869:06 - because there's nothing in C that's
869:07 - stopping us right we create those things
869:11 - right so we don't want to call head or
869:13 - count because then if we change when
869:16 - we're doing a map head's not there
869:18 - anymore I mean a hash head's not there
869:21 - next doesn't work I mean we got to hide
869:23 - that we got to like wrap it we got to
869:25 - create a strong abstraction around this
869:28 - notion of starting a loop and then
869:30 - iterating one iteration of a
869:32 - loop and then ending the loop we have to
869:35 - abstract that away this is the concept
869:38 - of separation of concerns our calling
869:40 - code does not need to be concerned about
869:43 - how the object can lo be looped through
869:47 - right so we need a generic notion of
869:50 - looping
869:52 - so you can think of the iterator object
869:56 - itself as thing you create and it sort
869:58 - of starts at the beginning and then you
870:00 - hit it Boop next give me another one
870:04 - give me another one give me another one
870:05 - and inside the iterator the state is
870:07 - changing it's like
870:10 - advancing and it just gives them to you
870:12 - want at a time you can't ask it for the
870:14 - same one once you it's been given to you
870:16 - it's sort of like ratcheted down to the
870:18 - next one so if we look at this python
870:20 - code we uh well we start with a
870:23 - dictionary a maps to one B to two c to
870:25 - three and we print it and there's the
870:26 - dictionary and we say oh let's convert
870:28 - that to a list and that list is the keys
870:31 - which is ABC and then say give me an
870:34 - iterator from that dictionary we print
870:37 - that out and we print the type of it it
870:39 - is of type dictor key iterator object
870:44 - and so the iterator itself is not the
870:46 - entire dictionary it is not a list of
870:48 - all the keys it is an internal structure
870:51 - that python is going to maintain and
870:53 - then we're going to poke it by calling
870:55 - next next next now the whole next thing
870:59 - that's probably calling an internal
871:00 - method like UND double underscore next
871:02 - Double underscore so next is part is is
871:05 - is part of the Python language so if you
871:08 - look at the while loop it's a while true
871:09 - Loop we say item equals next so that
871:12 - means give me the next available item in
871:15 - the iterator and then Advance it and if
871:18 - we're past the end return me false and I
871:21 - say if item is false break
871:22 - and otherwise I print the item and so
871:25 - I'm getting the items a b and c the the
871:29 - key thing here in Python just we're
871:30 - using python to keep it as simple as
871:32 - possible is we the the iterator is
871:35 - something that's
871:37 - created the iterator doesn't contain all
871:39 - the data the iterator contains pointers
871:42 - inside of it so that it knows what what
871:45 - to do
871:46 - next and we repeatedly probe the
871:49 - iterator with the next call to get the
871:52 - next thing and that both advances
871:55 - returns and indicates when we have run
871:57 - out of things
872:01 - so it's weird because we're so used to
872:03 - say like for blah in blah or for this
872:07 - that but that's that's not how iterators
872:11 - work iterators want this next thing to
872:14 - happen the C code to do the iterator you
872:16 - create it you Loop next through and the
872:19 - C1 is going to look pretty much the same
872:21 - as the python one so if we look at the
872:23 - map it structure it is going to have the
872:27 - kind of things that we we've needed we
872:28 - just are going to pull them in so the
872:30 - concept of current like we've used the
872:32 - variable current in the past for these
872:33 - Loops is in the map iter structure and
872:37 - it's private so we moved that from a
872:39 - sort of a variable that was in the main
872:41 - scope to inside this and made it private
872:44 - the only public things we have are a
872:46 - next method and a Dell method and so now
872:49 - what we have is a simple contract you
872:50 - can see our our kind of outside contract
872:53 - for this class
872:54 - is it's not cre it's created by the map
872:57 - class but once it's constructed next and
873:00 - Dell are the only thing that you can do
873:02 - with this and that's that and then we
873:03 - get to decide inside this class and so
873:07 - when we construct it we're basically
873:10 - going to start it we're going to
873:13 - allocate the right size we're going to
873:14 - take the current and point it at the
873:16 - first item pulling from the head of the
873:18 - link list and then we're going to set
873:22 - the two methods next and Dell based on
873:24 - the address of the implementations of
873:26 - the functions that implemented and then
873:28 - we're done right and so because we're
873:31 - inside of the map and that's map iter so
873:34 - this is what you get when you go Map
873:36 - arrow iter you get this code um and so
873:40 - we're totally allowed to do everything
873:42 - private with map because again the
873:45 - developer of the map class is the same
873:48 - person or team that's develop developing
873:50 - map iter and if we wanted to change head
873:53 - to you know X we could because we would
873:56 - just go inside all our code and change
873:57 - it but head is not exposed to the
873:59 - calling code so they wouldn't notice
874:01 - that change again that's that's the key
874:03 - at the moment the Constructor is called
874:05 - before the first call to next this is
874:08 - what the map B looks like current is
874:10 - pointing to the first item in our length
874:12 - list then the Y Loop starts and it calls
874:17 - head now you'll notice that it's kind of
874:19 - got this weird thing where it grabs the
874:21 - current and that's because current
874:23 - starts at we could have implemented this
874:26 - differently but the way I did it was
874:28 - current is pointing at head and I have
874:31 - to for the return it's got to return at
874:33 - the first call to next I grab current
874:37 - and then I Advance current so that at
874:39 - the moment that it Returns the return
874:42 - value is b equals 14 and current now
874:44 - points at 21 d equal 21 preparing for
874:48 - the next call to the next function okay
874:52 - okay so then it comes in and R Val grabs
874:56 - 21 and that's what we return and then we
874:59 - advance to 19 and you can kind of see R
875:01 - Val and current Chase each other down
875:03 - this uh link list so the we return f
875:06 - equals 19 and then current points to
875:09 - null and then we notice that current is
875:11 - null and then we return null to tell our
875:14 - calling code that we are finished so to
875:17 - start the iteration to Prime the
875:19 - iteration we call the map object say hey
875:22 - give me an iterator for the map and we
875:25 - get that back and we're going to store
875:26 - that in our variable iterator then we're
875:28 - going to start an infinite Loop that
875:30 - says while one or while true uh C equals
875:34 - it or next give me the next one which
875:36 - the first time two is going to give me
875:37 - the first one then if I got a null I'm
875:40 - done with a loop otherwise I print the
875:42 - key and the value of the one I got and
875:43 - then I go up and I iterate to the next
875:45 - one print it up print up print up print
875:48 - oop I got a null and then I delete the
875:50 - iterator and this is super equivalent to
875:55 - what we do in Python where we say x
875:57 - equal give me the iterator for the
875:59 - dictionary X in the variable it then
876:02 - while true we advance to the Advance
876:05 - next of it otherwise give me false if we
876:08 - got a false we're done and otherwise we
876:09 - printed it so these two are very very
876:13 - parallel and you'll notice that Java and
876:16 - C++ don't do iterators the same thing
876:19 - but I wrote this C code to mimic python
876:22 - way of doing
876:24 - this so it's been quite a long uh
876:29 - Journey we really focused on abstraction
876:32 - and encapsulation and we've done it with
876:34 - iterators and all we've done now is
876:37 - we've laid the
876:38 - groundwork for multiple implementations
876:41 - of the map we shouldn't have to change
876:43 - our main code anymore we should be able
876:46 - to put a we we build a list map a a list
876:50 - map and then we're going to build a hash
876:51 - map and we're going to build a tree map
876:53 - those have increasing complexity and
876:56 - improved performance characteristics and
877:00 - now you really are going to start seeing
877:02 - why we say have abstraction so that we
877:05 - can fool around underneath the
877:07 - abstraction and accomplish really cool
877:09 - things and get closer to what python
877:13 - really does underneath of the dictionary
877:15 - implementation
877:22 - [Music]
877:27 - hello and welcome to the last lecture in
877:29 - this course we're going to talk about
877:32 - tree maps and hash Maps up till now
877:34 - we've built a map abstraction we've
877:36 - looked at how iterators work we've
877:38 - created a linked list implementation of
877:40 - the hash abstraction and now we're going
877:42 - to go and build a hash version and a
877:44 - tree version of that same thing if you
877:47 - recall some lectures ago I read a Robert
877:50 - Frost poem
877:53 - you know miles to go before I sleep well
877:55 - that's where we're at now we're coming
877:57 - to the end of this miles to go although
877:59 - as you'll see the end is really just the
878:01 - beginning of the next phase and with a
878:04 - little
878:05 - foreshadowing if you have been with me
878:07 - for a very long time all the way since
878:11 - python for everybody which for me was
878:13 - recorded a number of years ago already
878:16 - this is the first complete piece of code
878:19 - that I showed you and that was the code
878:21 - to count the number of words in a file
878:23 - by splitting them then creating a
878:25 - dictionary and then counting them and
878:28 - we're going to finish this lecture by
878:31 - implementing this in C but I'm getting
878:34 - ahead of
878:36 - myself so the idea here is we're
878:39 - exploring you know different key value
878:41 - implementation Alternatives we're we
878:43 - built a unordered Java based hashmap
878:47 - which is like a python 2 dictionary if
878:49 - you
878:50 - recall python 2 had unordered hashmaps
878:54 - which meant you sort of ended up with
878:55 - your stuff coming out in a random order
878:57 - it was the same order but every time you
878:59 - inserted something the order might
879:01 - change now Python 3 they tend to later
879:04 - versions of Python 3 they tend to be
879:06 - ordered which are more like the list map
879:10 - that we did we're going to have a u map
879:13 - that is sorted that's more like Java's
879:16 - tree map with an iterator and it is sort
879:20 - of chapter 6.5 or section 6.5 of the
879:24 - book um and it is a combination of a
879:28 - tree map and a link list map um but uh
879:31 - Java doesn't have such thing which
879:33 - really kind of surprises me they got a
879:35 - tree map and they got a hashmap but they
879:37 - don't have a linked tree map or a linked
879:40 - map so here we go now these these the
879:45 - two abstractions were I mean two
879:46 - implementations we're going to build uh
879:48 - kind of you see them in Python you see
879:50 - them in C++ and you pretty much see them
879:53 - in um Java as well but we're going to do
879:57 - our own
879:58 - thing so I would say to you when you're
880:02 - writing this
880:03 - code
880:06 - um I I don't want you to think that when
880:09 - I wrote this code that I gave you with
880:11 - samples or when I wrote These slides
880:14 - that it was easy for
880:16 - me um the concept of trees and hashes
880:21 - are pretty straightforward but then you
880:23 - got to solve the little problems of how
880:25 - to take the previous and hook it to the
880:27 - current and hook the next to the to the
880:29 - next the current next to the next from
880:31 - the pre and so you you got to draw
880:34 - pictures and this is this is actual
880:35 - picture that I drew I really wrote all
880:37 - this code from scratch I mean I didn't
880:39 - come up with the idea of a tree from
880:41 - scratch but I wrote this code from
880:43 - scratch and you can see that the like
880:45 - when I was building the the tree map um
880:49 - my goal was to find the right place in
880:51 - the tree to insert the next item and so
880:53 - you see I've got this 1 3 5 7 9 11 13 so
880:57 - I kind of constructed this tree that was
880:59 - right it was in order um and then I was
881:02 - trying to figure out where I might put
881:03 - four and where I might put eight and
881:06 - where I might put 14 and then um I kind
881:09 - of had this notion when I was writing
881:11 - the picture that I you'll see I had the
881:13 - words lowest node greater than and I
881:15 - cross them all out because that wasn't
881:17 - enough and you'll see when we get there
881:19 - that I have the lowest node greater than
881:21 - and the greatest node less than and I've
881:23 - got to get both of those things and so
881:24 - as we work our way down the tree we got
881:26 - to keep track of this I'm I'm getting
881:27 - way ahead of
881:30 - myself like many data
881:33 - structure programming tasks they if you
881:37 - you can draw the picture and it makes a
881:39 - lot of sense you see the hashmap which
881:41 - is the first one we're going to do
881:42 - that's really just nothing more than a
881:44 - bunch of Link lists with a hash function
881:46 - picking the the head instead of one head
881:48 - it has in this case four heads um
881:52 - so that one turns out to be easy and
881:53 - that's the first one that we're going to
881:55 - do but when I wrote this I mean I knew
881:58 - what I was doing I knew what a tree was
882:00 - I knew what a hash was that that's the
882:02 - easy part the hard part's writing the
882:04 - code now taking the code from someone
882:05 - else like if you're taking it from
882:07 - python or C++ or Java that's easy thank
882:10 - heaven they wrote it and they tested it
882:12 - and we have a nice tested working
882:15 - implementations so you shouldn't have to
882:16 - write this stuff in most languages and
882:18 - so we're just understanding how to write
882:20 - it but if you do it right you're going
882:24 - to make mistakes and you're going to
882:26 - you're going to be 80% right but then
882:28 - it's going to be real hard to debug this
882:30 - stuff so part of what you need to figure
882:33 - you need to accept the fact that you
882:35 - will un you're not likely to write it
882:38 - perfect the first
882:40 - time and debugging is difficult you're
882:44 - going to print out a bunch of like
882:45 - percent PS and hex values and stuff and
882:49 - you're going to just go through it
882:50 - slowly like what did I do wrong because
882:53 - the main programs for the programming
882:54 - assignments that I give you are really
882:56 - kind of like unit tests they're sort of
882:58 - pushing your implementation to see if
883:00 - it's capable of handling all of the
883:03 - common
883:04 - situations and so don't don't stress if
883:08 - it doesn't work right away they my my
883:11 - implementations didn't work right away
883:13 - they they failed you you can you know if
883:15 - you can go to some website and get the
883:18 - solution I mean if you're going to do
883:20 - that just go to Python and make a
883:22 - dictionary if that's your goal your goal
883:24 - is to struggle with doing something that
883:28 - you understand you know how to do it you
883:31 - know what a tree is you kind of know
883:33 - that you got preves and necks and lefts
883:35 - and rights but you still got to write
883:37 - the code and making one or two mistakes
883:40 - and then fixing those one or two
883:42 - mistakes is essential to understanding
883:45 - so with that up next we're going to talk
883:48 - about the hashmap
883:55 - [Music]
884:00 - so now we're going to talk about a hash
884:03 - based implementation of our map and this
884:05 - is the answer to the world's most common
884:07 - programming interview question but we're
884:10 - going to do hashmaps and then tree Maps
884:11 - tree maps are harder so hash Maps turn
884:14 - out to be beautifully simple and that's
884:16 - kind of the reason that um Everyone
884:19 - likes these is interview questions
884:21 - because the interviewer can remember the
884:23 - answer a tree map they might have
884:24 - trouble remembering and so it's the
884:27 - perfect thing in an interview to say
884:30 - draw me a hashmap because they know the
884:32 - they still remember the answer from when
884:33 - they went to school they' have to do a
884:35 - little review to get the tree map right
884:36 - so here we go so let's talk a little bit
884:39 - about our hash map implementation it's
884:41 - got a weird order and once you see the
884:43 - data structure internally it'll be clear
884:45 - why there's a weird order it is like a
884:47 - python 2 dictionary and it's like a Java
884:50 - hashmap it's very very similar to both
884:52 - of these things I'm guessing the code
884:54 - we're going to write is very similar to
884:56 - when when GTO made his first dictionary
884:59 - it's going to have extremely fast insert
885:00 - and looked up just like python 2
885:03 - dictionaries and Java hashmaps it's
885:05 - going to be iterable like Java's python
885:08 - 2's dictionaries and Java's hashmaps and
885:10 - it builds on link lists surprisingly
885:13 - it's really easy to build a hash L
885:17 - hashmap if you understand link lists and
885:19 - so it's it's covered in chapters 6.5.1
885:23 - and 6.6 in kernigan and Richie
885:26 - 6.5.2 is literally the hardest part of
885:30 - the book and that's why we kind of start
885:33 - with 6.6 and then kind of go back to
885:37 - 6.5 okay so let's take a look at our
885:39 - data structures and how we're going to
885:41 - go from the list map to the hash map so
885:44 - our our our list map is pretty simple
885:46 - we've got the entries in the map which
885:49 - are key value which we've decided is
885:51 - going to stay public we've got the pre
885:53 - the next for the map entry which is just
885:57 - you know we're going to link these
885:58 - things together and then list map itself
886:01 - it's got a head and it's got a tail and
886:03 - maybe a count and a few other things and
886:04 - then the methods Etc because we've done
886:06 - encapsulation so the hashmap entry if
886:10 - you look at it it's pretty much
886:12 - identical and that's because the entries
886:14 - in a hashmap are just part of a link
886:16 - list the key to the hashmap is there's
886:19 - multiple link lists and we see that
886:22 - instruct hashmap and underscore buckets
886:24 - is how many buckets we have in a in a
886:26 - more sophisticated hashmap
886:28 - implementation we would have the number
886:30 - of buckets grow as size grew and the the
886:33 - list got too long but we're going to
886:34 - keep that so that's called rehashing and
886:37 - we're going to keep that out of our
886:39 - conversation so but we're going to have
886:41 - a number of buckets and in this case
886:42 - it's going to be eight so those are
886:44 - called hash buckets and then we're going
886:46 - to have heads plural we're going to have
886:49 - eight of them and Tails eight of them
886:51 - but within a particular head and the
886:53 - tail it really is a hashmap so as you're
886:56 - writing the code for the hashmap go back
886:59 - to the list map I mean literally copy
887:01 - the list map code and then change the
887:04 - singular to plural and you'll see some
887:05 - of the things I show you in the actual
887:08 - code so if we look at how a list map
887:10 - looks it's got a head and it's got a
887:13 - bunch of entries that have preves and
887:14 - necks I'm not even showing the preves in
887:16 - the arrows I'm just showing the next but
887:17 - assume there's always preves there
887:19 - because it's a way for us to link things
887:21 - in but if you look at the hashmap so you
887:25 - take the actual key you run it through a
887:26 - hash function which creates some big
887:29 - number no matter how but it is just a
887:32 - number no matter how long the key is it
887:35 - can be one character or 2,000 characters
887:37 - eventually the hash runs a calculation
887:39 - that gives us back a number sort of a
887:41 - pseudo random number that has you know
887:44 - equally likely and there's a whole
887:45 - science of hashing and then we take a
887:47 - modulo and in this case we have four
887:49 - buckets so we take this hash calculation
887:52 - modulo 4 and that gives us a number from
887:55 - 0 through
887:56 - three and with that number we pick the
888:00 - linked list and then we add it to the
888:02 - linked list just as if we were doing
888:07 - this with a link list so the M once
888:09 - we've done the hash and we picked a
888:11 - bucket it really is exactly the same as
888:14 - a link list so a hashmap with four
888:17 - buckets is the same as four link list
888:21 - lists and you pick the link list by the
888:23 - hash computation and hash computation is
888:26 - deterministic and predictable so
888:28 - wherever we put D it's going to be in
888:30 - bucket one and we can look it up in
888:32 - bucket one we can store it in bucket one
888:34 - Etc and so for inserting m equals 90
888:37 - that's going to Hash into into bucket
888:39 - two and we're going to put it in that
888:41 - that link list okay so it is beautifully
888:45 - simple now what is a hash calculation
888:47 - this is actually from my uh postgress
888:50 - for everybody course basically the hash
888:52 - Maps large data items to a
888:56 - single a single number basically and
888:59 - these are called hash values so the
889:01 - whole concept of a hash
889:03 - function when used with a modulo in this
889:06 - case I've got 16 modulo 16 in this
889:09 - picture it Maps a big string into some
889:13 - fixed number of buckets and often the
889:14 - buckets are power of two but they don't
889:16 - have to be it's really a modulo
889:19 - operation and so there's a whole
889:21 - um there's a whole science of hashing
889:24 - and hash functions and it turns out the
889:25 - hashing and hash functions are a big
889:29 - part of security and digital signatures
889:31 - and all that stuff and so there is there
889:34 - are people who spend their whole lives
889:37 - researching how to build good hash
889:40 - functions and so there's this this sha
889:42 - 256 compression function you can go look
889:44 - it up you can see what's going on here
889:47 - is like the arrows are shifting and the
889:50 - plus with a circle ccle is exclusive
889:52 - ores and they sort of both show you um
889:55 - the shifting and the exclusive ore and
889:57 - they give you a diagram of how these
889:58 - things and they shift an exclusive or
890:00 - yada and they're taking the pieces of a
890:04 - a value it's computed in a loop and
890:06 - updated and what they're showing you is
890:09 - what
890:10 - happens each iteration through the loop
890:13 - and so um the idea is is we are going to
890:16 - take a string string array and we're
890:19 - going to take a number of buckets
890:21 - and the idea of a hash is it is just
890:25 - some integer number and we're going to
890:28 - go through each of the items each of the
890:30 - characters in The String that's the four
890:33 - star stir star stir plus plus and we're
890:36 - going to take the current value of hash
890:38 - in this case we're going to shift it
890:40 - three to the left and then we're going
890:42 - to exclusive or it with the character
890:44 - we're looking at so you can say shift
890:47 - three exclusive or shift three exclusive
890:49 - or so you could think of it as like a
890:51 - accumulation but the exclusive or is a
890:54 - nice form of accumulation in that it it
890:58 - increases the randomness the pseudo
891:01 - randomness of this thing and so
891:03 - exclusive or just turns out to be a
891:05 - super valuable calculation and so this
891:08 - this Loop is going to run so many times
891:10 - and so we're going to print it out
891:12 - you're going to see the hex if we're
891:13 - just taking the letters Hi you can see
891:16 - kind of the internal hash value growing
891:19 - and changing and you can kind of see it
891:21 - going from uh right to left as it sort
891:24 - of grows um and there's new data being
891:27 - put in bitwise it's a bit you know bit
891:29 - exclusive or but at the very end it says
891:32 - return hash percent buckets which takes
891:35 - the modulo operator of the number of
891:36 - buckets and in this case I'm going to be
891:39 - using eight buckets just to run the hash
891:41 - function right give me the bucket for
891:43 - this string so you can see me running
891:45 - different things on the right hand side
891:48 - and getting back the ultimate final
891:50 - bucket so hi goes in bucket one hello
891:52 - goes in bucket s and World goes into
891:55 - bucket four this is this is really
891:58 - inspired by you know the the the
892:00 - shifting and the masking but I've
892:02 - simplifi it so you can kind of see
892:04 - what's going on and in our particular
892:06 - hash it's it's good enough for our
892:09 - purposes but it's probably going to have
892:11 - collisions when treated against a whole
892:13 - series of random data it's not going to
892:15 - be as good and that's where a fancy hash
892:18 - like shot 256
892:21 - would be helpful so now that we
892:23 - understand the basic data structures and
892:26 - how hashing functions work let's up next
892:29 - we're going to take a look at actually
892:31 - building a hashmap or at least adapting
892:34 - our list map and turning it into a
892:38 - [Music]
892:48 - hashmap so now that we understand what a
892:50 - hash function is is we're going to
892:51 - actually build our hashmap
892:52 - implementation but what we're really
892:54 - going to do is make a copy of our list
892:56 - map code and change as few things as
893:00 - possible you'll be impressed with how
893:02 - easy this really is if you have a bit of
893:04 - working list map code this is the new
893:07 - Constructor and I can call your
893:08 - attention to the changes right remember
893:10 - we have a number of buckets we have a
893:13 - however many head however many buckets
893:15 - we have we have eight heads and eight
893:17 - tails so we're going to look in the
893:19 - Constructor so we're going to allocate a
893:20 - hashman it's not that big right you it's
893:22 - still got it's still got the functions
893:24 - for our encapsulation to put get size
893:26 - dump and it or that's not changed at all
893:28 - except it's called hashmap instead of
893:30 - list map the buckets is set to eight
893:32 - we're going to initialize all eight
893:34 - buckets to had a head of null and a tail
893:36 - of all because remember this is just
893:38 - eight link lists and count you set to
893:41 - zero pretty straightforward especially
893:44 - if you understand the hash list and if
893:47 - you don't go back and watch that lecture
893:48 - don't just like go oh I didn't
893:51 - understand what hash list was I'll just
893:52 - keep on not understanding and and use
893:55 - chat GPT it's like well I I don't know
893:59 - what to do if that's how you're going to
894:00 - go through this assignment but if you
894:03 - have and understand a working hash list
894:05 - this is easy easy easy we've been using
894:08 - list map find before and all it does is
894:11 - it finds a hashmap entry if it's already
894:14 - there and so we send in the whole hash
894:16 - map self which is very you know python
894:19 - objectoriented pattern where the first
894:21 - parameter always s we have a key we're
894:23 - looking up and then we're telling it to
894:24 - start in a particular bucket and that's
894:27 - the real change if you have hash list
894:29 - find it doesn't have a bucket hashmap
894:30 - findind has a bucket and so this code is
894:33 - exactly the same as hash list find
894:35 - except instead of starting at head we
894:38 - have an array of heads and we use bucket
894:40 - to figure out the thing and then we Loop
894:42 - through it we're in the right bucket
894:45 - something above us figured out what
894:46 - bucket it go through and so if we look
894:48 - at hashmap get which is taking key and
894:51 - having a default and having a self we
894:53 - say hey compute the bucket from the key
894:57 - and however many buckets we have which
894:59 - in this case might be eight and then we
895:00 - do a struct hashmap star rvel go find it
895:03 - passing in the bucket if the if the
895:05 - return is null from find we return the
895:08 - default otherwise return the value so
895:11 - again there's one line changed between
895:14 - the code from list map get to hashmap
895:18 - get so let's do a quick review of what
895:20 - we do in mapap put now this is not the
895:22 - hashmap put this is map put this is our
895:24 - list map put so we call find if we find
895:27 - it then we're just going to update the
895:29 - value and we're done if we don't find it
895:31 - we allocate the new entry we set it's
895:33 - next to null and we link it into the
895:35 - list and this is the place where you
895:37 - should be drawing a picture if the head
895:38 - is null that means we have an empty list
895:40 - then self head is this new thing if the
895:42 - self tail is not equal to null we've
895:44 - linked it at the end then we're going to
895:45 - update the tail Etc so draw these
895:47 - pictures and these are the parts where
895:49 - you'll mess it up you you will get these
895:51 - wrong and it's okay to get these wrong
895:53 - put like a print statement in every line
895:55 - here if you're having trouble right and
895:57 - you got all the cases and this this nice
896:00 - little four lines of code captures the
896:03 - cases okay so remember we're inserting
896:05 - at the end so what do we do for hashmap
896:07 - put we have a bucket we're going to run
896:09 - a a hash computation to figure out which
896:11 - bucket it is and we're going to call
896:13 - hashmap find and we just tell it to find
896:15 - it in the bucket so in the linked list
896:18 - sub three or sub four or whatever and if
896:20 - we found it we update the value and
896:22 - return otherwise it's time to insert so
896:25 - we allocate a new one we said it's next
896:27 - to null and then we know which bucket it
896:29 - is so in this we looked at the previous
896:31 - code it was for one link list and for
896:33 - this current code there's eight link
896:35 - lists but we already know which link
896:36 - list we're dealing with and so literally
896:38 - you can take the word head and change it
896:40 - to head sub bucket everywhere you see
896:43 - head here you can change it the head sub
896:45 - bucket tail sub bucket and literally
896:47 - when I wrote this code that is exactly
896:50 - what I did I did it slowly not to mess
896:53 - up and of course the compiler helped me
896:54 - if I forgot something but that's as
896:57 - simple as it is to transform the put
897:01 - from a list map to a hashmap of course
897:04 - the dump we have to do a little bit
897:05 - differently we want to show all the
897:06 - buckets and so we were showing what
897:08 - bucket it is the key value pair but
897:10 - other than that it's a it's really a
897:12 - pretty straightforward stuff to do the
897:13 - hashmap dump remember I told you that
897:16 - writing a debug tool is essential so you
897:20 - can change your your main code to dump
897:21 - dump dump dump dump because you'll mess
897:23 - it up right you will not write this code
897:26 - perfectly and you need to be able to
897:27 - debug it so now let's take a bit of a
897:30 - review of the list map iterator so
897:32 - recall that the iterator is its own
897:35 - object we've got the entry we got the
897:37 - iterator and we got the map itself and
897:40 - the map iterator is allowed to do all
897:42 - the internal stuff because the whoever's
897:44 - writing these things writing them in a
897:46 - group so we can think of it as like a
897:47 - protected value and so um really the
897:51 - essence of the map iteration iterator is
897:54 - a current so we're going to call the
897:56 - public part of it is next and Dell and
897:59 - the private part is what the current
898:01 - thing is because we're going to we don't
898:02 - get to see the current but we can use
898:05 - next to get the current back and so the
898:07 - idea is is we can call next next next
898:09 - next next rather than looking at current
898:11 - recall that the way the iterator works
898:14 - is you ask for the iterator and then you
898:17 - hit the iterator with the next and you
898:19 - go until you you're done and when you
898:21 - find something you print it out and we
898:23 - can do the same thing in CC and as well
898:26 - as python if we think about how to do
898:28 - the iterator for a hashmap it's a little
898:30 - different we must move we must start at
898:33 - generally we start the first bucket and
898:36 - we must move through all the buckets
898:39 - eventually we got to get to because we
898:40 - got you know eight or four link lists we
898:42 - got to go through all of them and we got
898:44 - to go down each of them but if we're
898:46 - looking for the next item and we got to
898:49 - skip empty buckets so so we kind of got
898:51 - a bit of a complex while operation and
898:53 - so one of the things we're going to do
898:56 - is when we create the map Eder we are
898:58 - going to store a reference to the
899:00 - hashmap so when we construct the map
899:02 - hashmap itter we're going to know which
899:05 - which bucket is an internal value
899:07 - current is an internal value and map is
899:09 - an internal value which we're going to
899:11 - use to remember that map that we're an
899:13 - iterator for and then we're going to
899:14 - have a next and aell this is the
899:15 - Constructor and we're saying make an
899:17 - iterator given a hashmap we make the
899:20 - iter structure we remember a pointer to
899:24 - the map in case we're going to need it
899:26 - later the current bucket we're going to
899:27 - look at is zero and the current map
899:31 - entry is the head of the zero bucket and
899:35 - then next and Dell are just capsulated
899:37 - methods basically and then we return it
899:39 - now that first bucket may or may not be
899:41 - an empty list right so that first been
899:43 - you know there might be just one bucket
899:45 - the third bucket might have a list in it
899:47 - and 0 one and two won't have any in it
899:51 - so remember but so we've starting at the
899:53 - top bucket and our current is pointing
899:56 - to the head of the the first bucket
900:00 - which may be null the tricky bit is the
900:02 - it or next and we remember we've given
900:06 - the map it or we don't get map but we've
900:08 - stashed map in underscore map if self
900:11 - Curren equals null in the old days in a
900:14 - list map we knew we were done and we
900:16 - could just return null but now we have
900:18 - to go down a bucket so self this is the
900:21 - iterator's bucket goes from like 0 to
900:24 - one so we increment it and if the self
900:29 - the current bucket we're looking at in
900:31 - the iterator is greater than or equal to
900:34 - the maximum number of buckets we have
900:36 - now got to the last bucket and we return
900:40 - null and then what we do is we say okay
900:44 - that must mean we have more buckets so
900:46 - we say self current is equals self map
900:48 - that's our little stashed version the
900:51 - map and we're going to go we've already
900:53 - incremented self bucket and so we're
900:54 - going to grab the next head and then
900:56 - we're going to Loop up to the top now at
900:58 - this point if that bucket is empty we're
901:01 - going to do it again and we're either
901:03 - going to go through this y Loop enough
901:05 - times until we either have exhausted the
901:08 - buckets or we have found a bucket that
901:11 - has an entry in it then we got to do a
901:14 - little trick grab the current so the
901:15 - only way we're coming out of this Loop
901:17 - is if self current is not null because
901:20 - if self current was null we would have
901:22 - wilded our way through and then returned
901:24 - null eventually after we exhausted the
901:25 - buckets in the while loop above so the r
901:27 - Val is self current if self current is
901:30 - not equal to no we're going to go to the
901:31 - next and then return rep Val I've given
901:35 - you the code go through it carefully
901:38 - It's tricky to write what I would do is
901:40 - I would like print these Co this code
901:42 - out and draw the picture Okay draw the
901:45 - picture so let's take a look at a
901:47 - hashmap iterator in action so this is
901:49 - what it looks like when we've just got
901:53 - constructed and we're in the first call
901:55 - to next current is pointing at the first
901:59 - item in the first link list the link
902:01 - head Subzero we'll fall through we look
902:03 - at this self- current value and it's not
902:06 - equal to null which is great which means
902:07 - we have something to return so that so
902:09 - we don't have to go through the sort of
902:11 - scanning across null entries so we skip
902:13 - the while loop and we simply set R valid
902:16 - to self current and if it's not equal to
902:18 - n we advance that and then we return RV
902:22 - and so at the end it looks like this the
902:24 - current has been Advanced to the to the
902:27 - next thing we're going to return on the
902:29 - second call so the first call returns f
902:31 - equals 19 that's the r Val and the next
902:34 - thing is going to be H equal 17 but now
902:36 - we give it back to the calling code and
902:40 - away we go so now we come in in the
902:44 - second call it's going to do kind of the
902:47 - same thing current is going to have
902:49 - pointed to equal 17 it's not going it's
902:52 - not null and so we simply take R Val and
902:55 - be self. current and then we advance it
902:59 - as long as self current is not equal to
903:00 - null and because it was pointing to H
903:02 - equals 17 it is we're going to advance
903:04 - but now as we exit this second call
903:08 - current is going to be null but we're
903:10 - going to take care of that on the third
903:11 - call so don't worry about that R valal
903:13 - is H equal 17 and current equals null so
903:18 - now we're done with a second call so now
903:20 - we come into the third call and in this
903:22 - situation we are pointing at the zero
903:26 - bucket and current is null so the Y Loop
903:30 - is going to take over so while self
903:32 - current equals null which is true right
903:34 - now we are going to run the code say
903:37 - self bucket Plus+ which is the bucket
903:40 - number in the iterator and we're going
903:42 - to ask is the bucket number in the
903:44 - iterator greater than or equal to the
903:46 - number of buckets in the map if we are
903:48 - we're done we we're at the last one but
903:50 - we're not so we're not going to return
903:52 - null we're going to say self current
903:54 - equals self map head self sub bucket so
903:58 - we're going to go down to bucket sub one
904:00 - now and we are going to make current
904:03 - point at bucket whatever the head of
904:05 - bucket one is and that's okay we found
904:07 - an empty bucket because remember I said
904:09 - you got to skip empty buckets but we're
904:11 - still in the while loop while goes up
904:14 - says self current is still null I mean I
904:17 - just moved to the next bucket but self-
904:19 - current is still null so I add one to
904:22 - the bucket the bucket becomes two we
904:24 - check to see if we're done right if it's
904:26 - greater than or equal map buckets return
904:28 - now which it's not because we are we're
904:30 - at bucket one and self current is equal
904:33 - to self map Remember map is our
904:36 - remembered version of the whole map so
904:38 - we can see all the heads because we got
904:39 - to work through the heads so now self
904:41 - current points to b equals 14 and now
904:43 - the while loop goes back up and now self
904:46 - current is not null because it's
904:47 - pointing to the b equals 14 item so it
904:50 - pops out of that while loop and drops
904:52 - down and says R Val equals self current
904:56 - which was b equals 14 and then it
904:59 - advances self current and self current
905:01 - becomes null again but that's okay
905:04 - because we're going to return b equal 14
905:07 - on the third call so just to review we
905:11 - returned f equals 19 on the first call
905:13 - we returned H equal 17 on the second
905:15 - call and return Bal 14 on the third call
905:18 - and now it's going to loop back up
905:20 - and we're going to see the fourth call
905:23 - and so the fourth call is going to come
905:25 - in and um current was D equals 21 and so
905:31 - it's pretty simple we're we're we're not
905:32 - going to run the Y loop at this point um
905:35 - we're going to return equals 21 we're
905:37 - Advanced current so current is now
905:38 - pointing to null and now in the fifth
905:41 - call current is null but now that's
905:44 - going to trigger us working in the while
905:46 - loop we're going to add one to the
905:48 - bucket the bucket is going to become
905:51 - four and we say if this bucket inside
905:54 - this iterator is greater than the total
905:56 - buckets in the map return null and we're
905:59 - now done the fifth call returns null
906:02 - that tells the calling code that we are
906:04 - at the end of the list so if you keep
906:07 - yourself straight and you draw pictures
906:09 - like this and you think it through this
906:11 - is a surprisingly small amount of
906:14 - code to build a complete iterator for a
906:18 - hashmap I kind of mentioned this in
906:20 - passing but we still have more work to
906:23 - do a thing called rehashing it's not
906:26 - that hard and feel free to feel free to
906:28 - try it um at some point if these link
906:31 - lists get too long our performance
906:33 - starts to suffer and so one of the
906:35 - things that hashes do is in the middle
906:37 - of an insert they'll have something we
906:38 - call a load factor and it's like whoop
906:41 - this these buckets we have each bucket
906:43 - would have a length and we might check
906:45 - all the bucket lengths and if it got to
906:47 - be like over 10 or 15 or something we
906:50 - would go from we would have to rehash
906:52 - these things you don't have to
906:53 - reallocate you just have to make go from
906:55 - four buckets to eight buckets and then
906:57 - you recalculate the hash modulo 8 and
906:59 - figure out which bucket it belongs in
907:01 - and reconstruct all these things and so
907:02 - it's not impossible to do a rehash
907:06 - doubling the bucket and reducing the
907:08 - average chain length but we are not
907:11 - going to do that in this particular
907:13 - thing because we're going to keep it
907:14 - simple so the hashmap iterator while
907:17 - complex is surprisingly simple
907:20 - it's really very simil similar to the
907:22 - list iterator the the the key thing is
907:26 - that we've got to have that while loop
907:28 - that sort of Skips if we're at the end
907:30 - of one list it's got to get to the
907:32 - beginning of the next list and it's got
907:34 - to skip empty buckets now this is why
907:37 - you can see because that the things in
907:39 - the list are in somewhat random order
907:41 - the the buckets the the mapping of any
907:44 - key to any bucket is in random order and
907:46 - this is why when you think of python 2
907:49 - we
907:50 - we can look in Python 2 and we say oh if
907:54 - if you iterate through a
907:56 - map they come out in the same order but
907:58 - there is no predictable order but if you
908:00 - do it twice you're going to get the same
908:02 - order and the fact that the order might
908:04 - change if you do inserts or deletes that
908:06 - has to do with the
908:07 - rehashing and so we're we're kind of at
908:09 - the point where we have built the two
908:12 - foundational types of python 2.0 we've
908:14 - built a list and we built a dictionary
908:18 - python 2.0 but next we're going to move
908:21 - like to python 3.0 and start creating a
908:24 - link list that maintains sorted order
908:27 - and can be iterated in key order uh and
908:30 - so that's going to be our
908:33 - [Music]
908:43 - tree so up to now we've done all the
908:46 - easy stuff so it's time to do the link
908:50 - tree map which really is kind of a
908:53 - modern flexible key Value Store um this
908:56 - is a nice key value store that you would
908:59 - want to use if you were a software
909:01 - developer um our linked tree map is
909:05 - ordered like python order
909:08 - dictionaries it stays sorted meaning
909:11 - that not only does it stay in order it
909:14 - stays in sorted order we insert things
909:16 - and they go in in order like a Java tree
909:18 - map you can be iterated like a C++ map
909:23 - or an ordered dictionary but not a Java
909:25 - tree map this just boggles my mind why
909:28 - you can't well we'll talk about actually
909:30 - why they didn't do it but it's not that
909:33 - hard why why they so um and we're going
909:36 - to have fast lookup so the problem with
909:39 - a A list map is it's got a lot of nice
909:42 - features and we can make a sorted list
909:43 - map and we're going to in this section
909:46 - um but the problem with the list map is
909:49 - lookup is slow and so we're going to
909:50 - actually pretty much use the tree part
909:53 - to do fast lookup and you can see this
909:55 - in 6.5.2 of the textbook so we are going
909:58 - to do something that's pretty common in
910:01 - data structures and that is we're going
910:02 - to maintain two whatever the entries and
910:05 - they're going to maintain simultaneously
910:07 - a sorted link list through the entries
910:10 - and a binary tree and so we're going to
910:12 - look at them separately and then we're
910:14 - ultimately going to find them together
910:17 - we're going to put them together so
910:20 - let's talk about what a tree is a tree
910:24 - is a
910:27 - structure that the tree map entry you
910:29 - see has a left and a right so the things
910:32 - to the left are things where the key is
910:34 - lower than the current right so H equals
910:37 - 42 the question is where would a go well
910:42 - a goes to the left where would T go well
910:45 - T goes to the right so the idea of the
910:48 - tree is is that whatever entry you're in
910:52 - there's a key in that in the entry and
910:54 - then you can either go left or right
910:56 - based on the comparison of the key and
910:59 - instead of having a head and a tail
911:01 - there is just a root so the root is the
911:04 - top entry of this tree and then there's
911:07 - a series of left and right choices that
911:09 - you make and each entry has a left and a
911:12 - right and the tree map entry has a key
911:15 - value pair and we're going to keep key
911:18 - and value as um public because it's just
911:21 - an entry but now there is no next right
911:24 - this is why we are using abstraction
911:27 - because we're not even going to give
911:28 - them a next we're going to have a left
911:31 - and a right okay and that's we're not
911:34 - going to show that we're not going to
911:35 - let people see that we're just going to
911:37 - give them a set of methods to mess with
911:39 - our tree map and we're going to deal
911:42 - with all this stuff and we need a left
911:43 - and a right to do it so just taking a
911:46 - look at how it works is let's just say
911:48 - we're going to in this current tree that
911:50 - I've sort of built they're not always
911:52 - balanced I happen to balance it just
911:54 - because it looks better on PowerPoint
911:55 - slides but let's just say we're going to
911:58 - insert in this
911:59 - tree a a g equals 25 so it's got a a key
912:04 - of G and a value of 25 so what you do is
912:07 - you start at the root and you compare it
912:10 - and you say oh G is less than H so we're
912:14 - going to go down the left hand side so
912:16 - you can think of it as you're walking
912:18 - down the left hand side side then you
912:20 - are encountering D equal 8 and then
912:24 - you're like Okay g is greater than D so
912:27 - we got to take the it's like driving a
912:30 - car turn right at intersection D and so
912:37 - we do and we're working our way down and
912:39 - now we have we're looking at
912:41 - intersection F and we've either got to
912:43 - go left to right and so FG G is greater
912:48 - than F and so we're going to go to the
912:51 - right not the left and so we do and so
912:54 - that basically is the path that we took
912:58 - and so to insert g into the tree we find
913:02 - the
913:04 - greatest value less than which is f and
913:08 - you're kind of inserting it if you think
913:09 - about it between F and H right so it's
913:13 - it then the next Higher One in the tree
913:15 - is H and the next lower one in the tree
913:18 - is f and that was the trip we did I like
913:22 - to think of this sort of sort of
913:24 - trickling down the tree and making these
913:26 - decisions as almost like a Pachinko
913:28 - machine um where you you hit the balls
913:32 - they go dinging dinging dinging it's not
913:34 - random of course it's it's very precise
913:36 - but it is kind of like you stop at the
913:38 - top and you make a bunch of you know
913:41 - binary left right decisions and
913:43 - eventually you find yourself somewhere
913:45 - at the bottom and so if we kind of look
913:49 - at at tree matap put and we are going to
913:53 - start at the
913:55 - root and then we're going to do a
913:57 - comparison and um and if we find it the
914:02 - comparison is going to be zero we update
914:04 - the
914:05 - value and if we don't find it and it's
914:08 - less than we're going to go left and if
914:11 - it's greater than we're going to go
914:12 - right and so this is basically the idea
914:16 - this y Loop will trickle down the tree
914:18 - going left going right and it will
914:21 - either find the value if it there's a
914:24 - match like if we're looking for f we'd
914:26 - have found it and we would have stopped
914:28 - and we would have returned if we're
914:29 - looking for G we won't find it but we
914:33 - will find where we're supposed to insert
914:35 - it okay so the last thing that we talk
914:38 - to which G will find its way down to the
914:41 - right of f we will find where to put it
914:45 - so as long as the tree is correctly
914:46 - maintained you will either find a match
914:49 - or you will find the right place to
914:51 - insert it and the tree will it's not
914:54 - guaranteed it's not guaranteed to be
914:56 - balanced there's further algorithms that
914:58 - can make the tree balanced but the the
915:01 - key thing is is that the order will be
915:03 - right okay so so by inserting following
915:06 - these rules following this algorithm the
915:09 - order will be right and you will always
915:11 - find the right place to put it or you
915:14 - will find a matching place and think
915:17 - about how dictionaries work right you
915:19 - say x sub hello equals something well
915:25 - there's either going to be a hello key
915:26 - in there or not if there's not we're
915:28 - going to put it in if there is we're
915:30 - going to update it and that's what this
915:33 - code
915:35 - does we're going to create a a new tree
915:37 - map we're going to put H equal 22 and
915:41 - then we're going to do H equal 42 which
915:43 - replaces H right then we're going to do
915:45 - D equal 8 then we do b = 1 2 3 and then
915:49 - we're going to do f equals 6 and it
915:51 - turns out I'm kind of doing this in
915:52 - order so it doesn't get too long on the
915:54 - page and then I'm going to do a dump and
915:56 - remember how important a debug is when I
915:59 - first wrote this code you can daral bet
916:01 - you that I had map dump it was matap put
916:04 - matap dump mat put matap dump mat put
916:06 - Matt dump so I could like see what it
916:08 - does and so the Matt The Dump if you
916:10 - look at the dump um then we put in K and
916:13 - M and J and then we dump it again and so
916:16 - what I've done is I if you look at the
916:18 - map output you see that the map output
916:20 - has these H equal 42 and then it's kind
916:23 - of trying to give you some sense of the
916:26 - treeness of it okay meaning that the Bal
916:31 - 123 um FAL 6 and D equal
916:34 - 8 the number of vertical bars tell you
916:38 - how deep in the tree you are and so you
916:40 - can see that the immediate child nodes
916:42 - of H in the second dump are D and K and
916:46 - the child nodes of K are J and M so you
916:48 - can draw this all up and so the idea of
916:51 - my dump code is I'm trying to sort of
916:53 - draw you a tree so here is the dump code
916:57 - now this is very very different and
917:01 - literally this is the first
917:04 - time well I talked about recursions and
917:06 - functions talked about stack frames and
917:08 - stuff like that but if you go all the
917:09 - way back to python for
917:12 - everybody I delay talking about
917:14 - recursion until there's a real value for
917:16 - it and it turns out this is a beautiful
917:21 - use of recursion and if you didn't write
917:24 - this recursively you'd probably have to
917:26 - write your own stack and that would be
917:28 - like a bummer is we we're going to
917:30 - recursively go down the tree and we're
917:32 - going to keep track of the depth and the
917:33 - idea of the depth is it tells me how
917:35 - many vertical bars to print so we come
917:37 - in and we're pointed at a particular
917:39 - place in the tree maybe the root maybe
917:41 - the top one and depth is going to be
917:44 - zero and so if Cur is null we're done a
917:48 - key thing to recursion is you've got to
917:50 - have a way to get out so if we if we get
917:54 - to the end of some tree sub tree and we
917:57 - get to a null we go left or right and
917:58 - that it's a null don't print anything
918:00 - out just you're done you've gone one
918:02 - Beyond The Leaf of the tree and Cur is
918:05 - null so just return then what we do is
918:08 - we have a for Loop depending on depth
918:11 - that prints vertical bar space that
918:15 - spaces it over and we're going to go
918:18 - down the left tree and then we're going
918:21 - to come back and we're going to down the
918:22 - right tree and this is what's called a
918:23 - depth first search for those computer
918:26 - science nerds right and so we're going
918:29 - to go down the left and you'll notice
918:32 - that when we go down the left if the
918:34 - left is not equal to null we are going
918:37 - to dump the tree on the
918:39 - left with depth equals depth plus one
918:42 - and so if we start with a depth of zero
918:44 - that's going to become one and then if
918:45 - we recursively go down further then it's
918:47 - going to be two
918:49 - and then if and and then that when that
918:53 - recursion comes
918:55 - back if curve right is not equal to null
918:58 - we're going to dump the tree on the
918:59 - right so what you see is dump the tree
919:02 - on the left recursively which means go
919:04 - all the way down the left and come back
919:05 - up then dump the right node then come
919:08 - back up go up again and dump the right
919:10 - node and so you see this like how the
919:12 - order this is a depth first search of H
919:16 - we're going we're going down past um d
919:20 - then we're going even further past B and
919:23 - then we're coming up from B and we're
919:24 - going back down from D to F coming up
919:27 - from F then we come up from D then we go
919:30 - across H and then we go down to K but
919:34 - then we go to the left of K which is J
919:37 - we go back up and then we go to the
919:39 - right of K which is M and then we go
919:41 - back up we go back up and we're done so
919:44 - the calling sequence to this is tree map
919:48 - dump tree self root with a depth of zero
919:52 - I will say this when I wrote this code
919:53 - the first time I had print FS all over
919:56 - the place now I pretty much know how to
919:58 - do a depth first search of a tree but
920:01 - still you in a debugging
920:05 - sometimes sometimes you make your tree
920:07 - incorrectly and you're debugging is like
920:10 - huh that doesn't look like what I
920:11 - thought it was gonna be and uh and so I
920:15 - don't be ashamed if you have to put
920:18 - print state ments in all over the place
920:21 - first get your dump working just make
920:23 - sure your dump works because then you
920:24 - can debug everything else with the dump
920:28 - the gets pretty
920:29 - simple and we've got the default we got
920:32 - the key and we've got the tree so we're
920:34 - going to start a while loop where we're
920:36 - going to go down left right left right
920:38 - left right right so we're going to start
920:40 - at the root we're going to compare the
920:43 - key to the key we're searching for the
920:44 - current key if they're the same then
920:48 - return the value
920:49 - we could do this recursively but that
920:52 - you don't do recursion if you don't need
920:54 - to if the current key if the key we're
920:57 - looking for is less than the than the
920:59 - key we found we're going to go down the
921:01 - left and if the current key otherwise
921:03 - we're going to go down the right and so
921:05 - you can see this thing is just going to
921:06 - Pinko its way down Tink dtin Tink Tink
921:08 - Tink to the right spot and if it gets to
921:10 - null then we return the default right
921:13 - remember this is like a dictionary if
921:15 - the key is not there on a get we return
921:17 - the default you can see
921:21 - why gido van rosom in
921:25 - Christmas
921:27 - 1987 created a function called get which
921:31 - looked for a key and took a default
921:34 - value because this code is what what you
921:38 - you write what I'm going to return null
921:40 - and then I have an if statement heck no
921:42 - just passing a default if you get to the
921:44 - bottom of the tree and you haven't found
921:45 - it return the default if I want it to be
921:48 - null I can make the default null right
921:50 - away we go so this is
921:52 - beautiful this is
921:59 - beautiful so from that beauty both the
922:03 - dump are beautiful and the get is
922:07 - beautiful iterator is a pain you just
922:12 - can't easily build an iterator for a
922:14 - pure tree if you have nothing more than
922:16 - that
922:17 - tree so a list map can support an
922:22 - ordered iterator we saw before a hashmap
922:25 - can support an unordered iterator but a
922:29 - tree map cannot support an iterator
922:32 - without building some kind of a stack
922:34 - and
922:35 - that the problem is is
922:37 - that the concept of current is just so
922:41 - complex when we're doing recursion the
922:43 - concept of current is just so implicit
922:47 - it's actually in the call call stack the
922:49 - notion of current because there's really
922:52 - when you're doing the M the the dump you
922:55 - have a call stack of currents and then
922:56 - when you go back up the call stack
922:59 - you're getting a different current so
923:00 - you're switching back and so you either
923:02 - have to make your own stack of currents
923:04 - you could build an iterator for a tree
923:07 - but you'd have to build a stack so a lot
923:09 - of folks sort of don't want to do that
923:12 - we could build a stack but we're not
923:14 - going to so what we're going to do is
923:17 - we're going to do a technique for our
923:19 - iterator that is a common technique when
923:23 - you have a data structure that almost
923:25 - does what you want and then you have
923:27 - another data structure that does what
923:29 - you want you combine them so if you look
923:32 - at this tree there's a lot of nice
923:34 - things for
923:35 - searching for replacing for inserting
923:38 - and it does all that very fast because
923:40 - it's it's actually log in because the
923:43 - height of the tree is log base two of
923:45 - the width of the tree right the number
923:47 - of items in the tree so
923:49 - log base 2ish so it's super fast all my
923:52 - trees are small but if these trees get
923:54 - big they're super fast goes down the
923:57 - penos its way down to the bottom really
923:59 - fast but I can't easily build an
924:01 - iterator so what I'm going to do is I'm
924:04 - going to add to this a linked
924:06 - list but I'm going to have the link list
924:11 - simultaneously working with the tree so
924:15 - each of these items is going to have a
924:18 - next and a pre and a left and a right
924:21 - and we're going to almost write the code
924:23 - mentally independently for the tree code
924:26 - and the link list code okay so we're
924:29 - ultimately going to combine these things
924:31 - together there's not a separate link
924:34 - list in a separate tree it looks like
924:37 - this in a link tree
924:39 - man so think of each one of these things
924:42 - having a next and a preve and a left and
924:44 - a right and we maintain them in such a
924:47 - way when we're doing inserts
924:49 - that everything works perfectly so we're
924:52 - going to simultaneously maintain with
924:55 - the same entries a tree and a list but
924:58 - we're only going to use the list to
925:00 - build the iterator and we're going to
925:02 - make this a sorted list because these
925:04 - things are in order the tree is helping
925:07 - us quickly find the place to put it but
925:09 - also where to put it in order so let's
925:12 - take advantage of that so this is a
925:15 - sorted ordered dictionary in Python
925:18 - lingo okay so just remember that these
925:22 - entries these list tree map entries are
925:27 - simultaneously participating in a tree
925:31 - and at the same time in another layer as
925:33 - it were participating in a link list the
925:37 - tree map which is the tree map structure
925:40 - has a head and a root because at the
925:43 - same time tree map is both a tree and a
925:47 - link list and the map entry is going to
925:51 - have a next and a left and a right and
925:55 - again you just almost keep these things
925:58 - separate right in your mind when we're
926:00 - doing tree things we're going to use
926:02 - left and right and root and when we're
926:04 - doing list things we're going to use
926:05 - head and next and these are things now
926:07 - by now that should be sort of familiar
926:10 - to you so this is the structure that
926:13 - we're going to build and maintain and up
926:16 - next we're going to build the put code
926:20 - for this combined two- layer data
926:23 - structure that has a tree and a sorted
926:26 - link list all at the same
926:29 - [Music]
926:39 - time so this is an entire lecture on the
926:43 - put method of our tree and the essence
926:46 - of this is we're going to be
926:47 - simultaneously up updating two data
926:49 - structures at the same time I guess
926:52 - that's the definition of simultaneously
926:54 - so just before we
926:56 - start this is not easy I think it's
927:00 - pretty much impossible to do exactly
927:02 - what I'm asking you to do just use a
927:03 - bunch of Google searches or asking your
927:06 - AI bot maybe maybe you
927:08 - can you need to really understand what
927:11 - you're doing and this is where a picture
927:13 - is so valuable once you understand it
927:16 - the code should look very clean and very
927:18 - simple to you my put code as I was
927:23 - writing it was like
927:26 - broken and like I tried to fix it and
927:30 - then it was broken again and I threw it
927:33 - away and I wrote it again and I drew a
927:36 - new
927:36 - picture and I wrote it and it was broken
927:40 - and I threw it away again and then like
927:44 - poof it was perfect so as you're writing
927:47 - data structure code
927:49 - the notion of like it's broken just
927:51 - accept that it's broken it's going to be
927:55 - broken you're going to throw it away
927:58 - that's the point because you know that
928:01 - this algorithm is eventually going to
928:02 - work the algorithm is not the problem
928:04 - it's your implementation that's the
928:06 - problem okay so if we take a quick look
928:10 - at the performance of put and I've
928:11 - mentioned this the binary search is log
928:13 - in while a sorted list search is order
928:16 - in meaning that if you have a search
928:19 - list of 500,000 or a million it takes on
928:22 - average 500,000 lookups to find it
928:25 - whereas a million entry tree search you
928:28 - take the log two of a million and you
928:29 - get about 20 so the key thing is we're
928:31 - going to use the tree anytime we're
928:34 - searching and we're going to only use
928:36 - the list when we're iterating but we're
928:38 - going to while we're doing put we've got
928:40 - to maintain both the tree and the list
928:45 - okay so we are going to have to be real
928:49 - careful to keep in our mind and this is
928:52 - where I drew all those
928:54 - pictures we got to be able to insert
928:56 - into an empty list which is easy because
928:58 - roote is null and you just put the thing
929:00 - in then you got to find a right Gap a
929:02 - gap to the to the right of something and
929:04 - then find a left Gap and insert at the
929:07 - beginning after you go down a bunch of
929:09 - lefts and go down a bunch of Rights and
929:11 - then replacing is the easy part as we've
929:13 - seen in put you just that they you say
929:15 - if it's equal change the value
929:19 - okay so let's just take a look at our
929:22 - data structures and then we talked about
929:23 - these before we have simultaneously in
929:27 - the entry we have a left and a right and
929:29 - we have a next because we are
929:30 - simultaneously maintaining a sorted link
929:33 - list and a sorted
929:36 - tree the tree map has a head and it has
929:40 - a root that's pretty much it so in our
929:43 - in our Constructor we set the head to
929:45 - null we set the root to null we're empty
929:48 - we don't have anything in the tree we
929:49 - don't have anything in the link list so
929:53 - the empty list is easy right and so we
929:57 - have to scan to see if it's in the list
930:00 - right and you know
930:03 - if you know first we can just say hey if
930:06 - self head is null and it be the same as
930:08 - saying if self root is null well we just
930:11 - point head and root to the new item okay
930:16 - because we're inserting H equal 22
930:19 - I'm going to insert these in order so
930:20 - the list so I I don't run out of space
930:22 - on my PowerPoint slides and so when
930:25 - we're done with this root is going to
930:28 - point to H equal 22 the left is going to
930:30 - point to null the right is going to
930:32 - point to null the next is going to point
930:34 - to null and head is going to point to
930:38 - the item so we have a valid link list
930:42 - and we have a valid tree at the same
930:45 - time okay so again
930:48 - this is not the whole put code this is
930:51 - just the first part where we there's
930:53 - some dot dot dots in there where you're
930:55 - putting all the data in putting the key
930:56 - in and setting next to null and left to
930:58 - null Etc so that's that's in there but
931:01 - the first one is pretty easy from The
931:03 - Head and the root
931:05 - okay so we we keep doing that for a
931:08 - while we let's just take our we put some
931:11 - things in there and we've got our our
931:13 - link list going correctly you can just
931:15 - verify that you run through they're all
931:17 - in order you can take your your lefts
931:19 - and your rights and all the things that
931:21 - are less than H are to the left of H and
931:23 - all the things that are to the right of
931:24 - H are greater than H away we go so we're
931:29 - going to write some code and what we're
931:32 - really going to look for and this is the
931:33 - tricky part is to find the item or the
931:37 - Gap where the item belongs now the
931:40 - problem is is we're going to have to
931:41 - link these things back up when we were
931:43 - just doing a tree it was easier because
931:47 - you would either find find the item or
931:49 - find the place to link it okay so trees
931:53 - are
931:54 - easier to easy to maintain the link list
931:57 - is harder to maintain because you've got
931:59 - to keep
932:00 - track of the item that is the largest
932:05 - item less and the smallest item greater
932:09 - and that's what I call the Gap so this
932:11 - left in this right are to as we're
932:14 - walking down the list we're going to
932:16 - keep track of the the greatest the
932:19 - smallest greater item and the the
932:21 - largest less item okay and that's what
932:23 - this left so we got CER we got left and
932:27 - we've got right and you can think
932:30 - of left and right as like breadcrumbs
932:34 - like we're going to throw breadcrumbs
932:36 - when we turn when we're going to turn to
932:39 - the left we're going to remember the
932:40 - right when we turn to the right we're
932:41 - going to remember the left and you'll
932:42 - see it in action so here we go here we
932:46 - go so we got this tree gal 29 we're
932:50 - going to insert it so then what we do is
932:54 - we compare it to H =
932:56 - 42 and then we say oh that's a turn to
933:00 - the left so now we know at least at this
933:04 - point the greatest value the smallest
933:07 - greatest value is H and so we point
933:09 - right at H as we are moving down the
933:12 - tree and you see that you do the stir
933:15 - comp you see what it says if comp is
933:17 - less than zero we're going to turn turn
933:18 - left and then right is going to point at
933:20 - Curve where we
933:22 - were and now the next time when we're
933:25 - going to turn right which is what we're
933:26 - going to do next it's going to remember
933:28 - where left so we're now comparing G to D
933:32 - and G is greater than D so now we're
933:35 - going to turn right but now we're going
933:38 - to update left so D at this point in our
933:40 - search D is the largest number less than
933:44 - or the largest key less than G and H is
933:48 - the smallest key greater than G so you
933:51 - see how left and right are like
933:52 - breadcrumbs as we're sort of pinking our
933:55 - way down uh this
933:57 - tree so then we compare G to f and g is
934:02 - greater than F and so we're going to
934:03 - take a right turn and whenever we take a
934:06 - right turn we update left so now we have
934:10 - actually found the place that g belongs
934:13 - and if you look left and right are
934:15 - perfect for the link list because now we
934:18 - know that that left next is going to
934:21 - point to G and G next is going to point
934:24 - to H so so left next won't point at H
934:30 - anymore it's going to point at G
934:32 - and G new next is going to point at H
934:37 - okay so when we do this because we've
934:39 - got left and we've got right we just
934:41 - link them in and then we insert it into
934:44 - the tree and away we go and so now you
934:46 - look what we have done is we have now
934:49 - left and right were just temporary
934:50 - variables that we had during this tree
934:53 - map put code
934:55 - um but if you look at this and look it
934:57 - carefully we have a correctly formed
935:00 - link list that's sorted in order and we
935:03 - have a correctly form tree and we use
935:06 - the tree to get to F fast and we use
935:08 - left and right so that once we got to
935:11 - the right place which was to the right
935:13 - of f we could just hook it into that
935:15 - link list with no additional cost okay
935:18 - see how pretty it is so now let's take a
935:21 - look at some other of these things so
935:23 - let's take a look at inserting J well J
935:28 - is going to go right when it sees H
935:30 - because it's greater than it's going to
935:31 - go left when it sees K because it's less
935:33 - than I mean I I'm inserting I not J it's
935:37 - going to go left when it sees K and it's
935:39 - going to go left when it sees J and when
935:42 - it's done you got left is H and right
935:45 - the right value and the the I shouldn't
935:47 - even these left I should call them
935:50 - the smallest wait a second the largest
935:54 - value less than and the smallest value
935:56 - greater than that would probably be a
935:57 - more pneumonic name is largest value
936:00 - less than and smallest value greater
936:02 - than instead of left and right I'm
936:04 - thinking of it as the thing it's like a
936:05 - bracket you got a gap and what's your
936:07 - immediate left and what's your immediate
936:09 - right and so now we know exactly where
936:12 - this belongs and we know how to update
936:15 - both the link list and the tree so Bo
936:18 - update the link list using left and
936:20 - right and then update the tree um using
936:23 - cerr right so away we go and we've got
936:26 - ourselves in that Gap and so we can
936:29 - insert to the left we can insert to the
936:31 - right now remember remember
936:33 - remember that if we if if our key was J
936:36 - we'd have found it and then all we'd
936:38 - have done is updated the value so
936:39 - remember I I and my brain does this a
936:42 - lot when I'm looking at this code I'm
936:44 - like but will I find it and will I find
936:47 - the right one what if it's already there
936:49 - well already there's the easy part okay
936:52 - so there we go so let's take a look at
936:55 - inserting a equals 17 and how this works
936:57 - remember the use cases got to do the
936:59 - beginning the end left Gap right Gap
937:02 - empty list and then pretty much we'll
937:03 - have it so a equal 17 that's going to
937:06 - end up all the way
937:08 - down so we are going to compare it and
937:11 - we're going to we're going to turn left
937:13 - to the left to the left I think there's
937:15 - a song and a dance about that um um and
937:18 - so we remain remember right which is the
937:22 - smallest number greater than and it's
937:24 - not going to be right is not going to
937:25 - stay H equals 42 because we're going to
937:27 - compare a and d and then we're going to
937:30 - go left again and now right is going to
937:33 - follow us and then we're going to
937:34 - compare A and
937:36 - B and we're going to go left again and
937:39 - right is going to follow us now the
937:40 - interesting thing is left is now
937:42 - null we have found the place we're going
937:45 - to insert to the left of B but we're
937:48 - also going to insert through the head
937:52 - because we know that left is null which
937:54 - means that we just found the lowest
937:56 - thing in the current something lower
937:58 - than anything in the link
937:59 - list so then we just hook the hook a in
938:03 - before
938:04 - B right after head and then we hook it
938:08 - in to the the left of the B going with a
938:12 - larger than anything else that's in
938:14 - there we're going to end up with this at
938:15 - the end of the link list we're going to
938:18 - compare X to H and going to go
938:20 - right and remember left the largest
938:24 - value less than for now we're going to
938:27 - look at K we're going to go left again
938:29 - and left is going to be updated to be K
938:31 - the largest value less than then we're
938:32 - going to compare X to M and X is still
938:35 - greater than M so we're going to go I
938:38 - right again and left is going to be m
938:40 - equal 67 and you'll note that the thing
938:43 - we detect here is Right equals zero
938:47 - which means
938:48 - we have no value greater than x in this
938:52 - list so we just say x next the X current
938:57 - the current thing next is null and the
939:00 - Cur next is you know points to the X
939:03 - entry and then we hook it in on the
939:06 - right side of the m equal 67 and then we
939:09 - are
939:09 - done so if we're going to do a
939:11 - replacement remember I told you this was
939:13 - the easy one so again in my brain when I
939:17 - was writing this code I'm like but what
939:19 - if it's already there calm down that's
939:21 - the easy one okay so we're comparing F
939:25 - to H well it's to the left we're going
939:28 - to keep track of right but we're not
939:29 - going to use them because we're going to
939:30 - find it and then we have a match and
939:33 - then we just see it and go like oh fine
939:36 - f is 16 we're done life is simple if
939:38 - they're equal we found it you know we
939:40 - don't have to keep looking we found it
939:42 - we just change it and again think of how
939:44 - fast now how fast this works when it's
939:47 - the key already there it's like nothing
939:49 - to allocate no links to make you just
939:52 - change the
939:54 - value and you're
939:58 - done so it's
940:01 - important to test all of these cases and
940:03 - I just went through every single one of
940:05 - the
940:06 - cases
940:08 - and showed you what they're supposed to
940:10 - look like I I will tell you that you
940:13 - will make mistakes and I will tell you
940:15 - that asking Google for help as long as
940:18 - you read what they say will inform you
940:20 - but but I doubt that Google's going to
940:22 - just give you the whole code of
940:24 - something that is as intricate as
940:27 - this I would say a simultaneous sorted
940:31 - link list and a tree at the same time
940:33 - maybe it can do that because that's what
940:34 - you're really
940:36 - doing so up next we are going to go back
940:40 - to the beginning and go back to python
940:42 - for everybody to wrap things up
940:50 - [Music]
940:55 - well it's been quite a journey we have
940:59 - built in C a whole objectoriented
941:02 - pattern reviewed all of object running
941:05 - programming implemented a number of
941:07 - different python objects in c as a way
941:12 - to understand how C++ Works how Java
941:15 - Works how python Works how they all work
941:17 - under the
941:18 - covers so we come to the end of this
941:20 - sort
941:21 - of walk through all these amazing data
941:24 - structures and I hope you've had
941:26 - fun but one of the things I like to do
941:28 - at the end is I like to go back to the
941:30 - beginning so some of you have been with
941:32 - me from the very beginning python for
941:34 - everybody may be the first programming
941:36 - class that you ever took and I want to
941:40 - now finish by reviewing the very first
941:44 - program that I ever showed you in Python
941:47 - for everybody it is from chapter one I
941:51 - love this example and this is counting
941:54 - the most common word in a
941:56 - file so it's in Python we read a file
941:59 - name we create a dictionary we read all
942:02 - the lines we split
942:03 - it I think we we don't do conversion to
942:07 - lowercase but um then we're going
942:09 - through all the word and words and we're
942:12 - we're we're saying we're going to set
942:13 - the counts to counts. get word comma
942:15 - zero remember if you when you first saw
942:17 - that zero is the default then we're
942:19 - going to add one and that's the way when
942:21 - we see the first word we we sort of
942:24 - bootstrap whatever the word is that
942:26 - we're looking at then we have a Max Loop
942:28 - so we're going to iterate with items
942:32 - we're going to look for word comma
942:33 - counting items and we're going to do a
942:35 - simple Max Loop and then when it's all
942:37 - done we're going to print out the
942:38 - largest word and the count of the number
942:41 - of times that large word was
942:44 - shown so fast forward
942:48 - here we go now you by now have built a
942:52 - tree map
942:54 - hopefully so now what we're going to do
942:56 - is we are going to use your tree map
943:00 - code and we're going to implement this
943:02 - count so we're going to have a tree map
943:06 - call The Constructor for it that's our
943:08 - dictionary we're going to have the tree
943:11 - map entry that we're going to need to
943:12 - use to go through the iterator we're
943:13 - going to have a tree map iterator we're
943:16 - going to create cuz we don't have
943:18 - strings we're going to create a 100 item
943:20 - 100 item array name Char array and word
943:24 - and yes it's dangerous we're just not
943:26 - going to be too mean to our code and
943:27 - blow it up but we could and then
943:29 - variables like I and J and count max
943:31 - value and Char Max key that's all of our
943:34 - setup
943:35 - stuff so we're going to open the file
943:38 - name using scan F now we're in C it's
943:41 - not python anymore but you can see the
943:44 - similarity so then we're going to do an
943:46 - F open of the file using read and again
943:49 - you see the similarity we're going to do
943:52 - a scan F through f scanf with a file
943:55 - pointer and we're going to do a percent
943:57 - s which gives us a word and and word
944:01 - there is a pass by reference because
944:02 - it's remember words and array if we
944:04 - don't get an end of file we're going to
944:07 - then we're going to write a for Loop to
944:08 - go through word and call to lower which
944:10 - is in ctype.h and then we are going to
944:13 - carefully put a new line at the end of
944:16 - word
944:18 - and then we're going to get the current
944:20 - count with map
944:22 - get ask for map which is like self word
944:26 - is the key and zero is the default and
944:29 - then we're going to do a map put into
944:32 - the word position with count plus one
944:35 - and then we're going to f close it or
944:37 - close the thing and we're going to dump
944:38 - the map then what we're going to do is
944:41 - write a Max
944:42 - Loop Max Key equals null max value
944:46 - equals negative 1
944:48 - it's a count so I guess we can assume
944:49 - that negative 1 works here because
944:51 - there's only positive integers in our
944:53 - dictionary slash
944:55 - treap we're going to ask for an
944:58 - iterator we're going to create an
944:59 - infinite loop we're going to ask for the
945:02 - next item from the iterator if it's null
945:04 - we're done and if Max key is null or the
945:07 - curve value is greater than or equal to
945:08 - max value the one we're looking at is
945:10 - greater than our current Max we retrieve
945:13 - we return We retain Max Key and max
945:15 - value and when we're done done we give
945:19 - back the iterator and we print out the
945:20 - max key and the max value and then we
945:24 - delete
945:27 - the and so that's the miles to go before
945:30 - I
945:33 - sleep been a long
945:37 - time but the end is really the
945:40 - beginning these are the most basic data
945:42 - structures these are the classic data
945:45 - structures these are the data structures
945:47 - from chapter six of kernigan and Richie
945:49 - these are the data structures
945:53 - for 40 plus years that people have been
945:56 - learning
945:58 - about once you get good and I hope you
946:01 - have taken the time to get really good
946:03 - at these data structures because what
946:05 - these are is they're like the omelet of
946:10 - cooking they're easy and it seems like
946:13 - everyone knows how to do them but until
946:16 - you know how to do the easy stuff you
946:18 - can't understand the large fancy stuff
946:22 - in a recipe you need foundational
946:24 - Notions and you can create something
946:28 - amazing if you have done all the work in
946:31 - this course and you've done it well your
946:33 - journey can continue with many great
946:35 - cookbooks the one I'm showing you now is
946:38 - what we called
946:40 - CLR um because of the the authors when I
946:44 - did it back in grad school there was
946:45 - only three authors not four authors CLR
946:47 - and this is a thick book a very thick
946:51 - book and um what you're going to find is
946:55 - this is a very well-written book and if
946:58 - you know everything in this course you
947:00 - should be able to open this book up to
947:02 - war Shell's
947:04 - algorithm and write an implementation of
947:06 - C orell's algorithm because you know how
947:09 - to allocate things you know how to
947:12 - create structures with pointers in them
947:14 - and you know how to deallocate them and
947:16 - if you learned every lesson in this
947:19 - course you can start you can almost open
947:22 - anywhere Alpha Beta pruning all all
947:24 - kinds of things you can just open it up
947:27 - and go four or five pages look at how
947:29 - they describe the algorithm and then
947:31 - Implement so I'm not going to teach you
947:34 - every one of the algorithms in this book
947:37 - what I've taught
947:38 - you is what an algorithm is and what the
947:42 - foundational pieces of all algorithms
947:45 - are okay so I wish you luck and I
947:49 - encourage you to keep going on your
947:51 - journey your journey is not ending It's
947:55 - [Music]
948:06 - Beginning hello and welcome to the
948:09 - lecture in C programming for everybody
948:10 - that I call the epilogue and that's
948:13 - because this lecture happened after the
948:16 - course was completely finished I have a
948:18 - saying in my life that basically says
948:21 - that when you think you are finished
948:23 - with a journey often that's when you
948:25 - finally know where the journey actually
948:27 - begins and that applies in C programming
948:30 - for everybody because C programming for
948:32 - everybody for me was four and a half
948:35 - year project to create the book create
948:37 - the autog graders create the lectures
948:39 - get it up on corsera get it out on the
948:41 - internet
948:42 - Etc and so I just was going through the
948:45 - class and at some point I ran into to
948:48 - chapter 6 of kigan and Richie and I'm
948:51 - like uh what will some good examples to
948:54 - use what what are some good examples
948:57 - that I can use that will be relevant to
948:59 - the students who who perhaps have taken
949:01 - python for everybody and I'm like well
949:03 - why don't we just Implement some python
949:05 - classes we'll see how complex they get
949:07 - and if they get if it works out well it
949:10 - talks about the concept of interfaces
949:12 - and
949:13 - implementations you know and so so I
949:15 - think it worked out really really well
949:17 - so as we were going through chapter six
949:19 - of kernigan and Richie I built us a
949:21 - python string class and you can go back
949:23 - and you can watch those other ones as an
949:26 - extendable car character array with some
949:28 - chunking where it would allocate some
949:30 - space and then fill that space up and as
949:33 - that space filled up it would extend it
949:35 - and I made a list class and I used the
949:37 - link list from cigan Richie chapter 6 if
949:40 - you recall I made an extra little bonus
949:44 - section 6.5.1 where I talked about link
949:46 - list explicit itly because in the
949:47 - original kigan enriching 1978 book and I
949:50 - believe it's the same in the ' 84 and
949:52 - but I'm like I'm going to show you link
949:54 - list first and so I added this little
949:56 - piece to the the Canon the kernigan
949:59 - Richie Canon I added that I implemented
950:01 - the python
950:03 - dictionary using the technique of
950:05 - kernigan Richie 6.6 pretty much straight
950:08 - on when I built the python string class
950:11 - you'll notice that there's a structure
950:13 - that has a length and an Alec and the
950:15 - Alec has how many characters we Al ated
950:17 - and the length is how many of those
950:18 - we've used and we're putting
950:20 - automatically a zero BTE at the end of
950:22 - it as you add things together eventually
950:25 - you get the length to be nine with a
950:27 - zero bite and the alak is 10 which means
950:30 - we can't add the letter d and so we re
950:33 - use realic to extend it and make it be
950:36 - 20 and then we have space to put both
950:38 - the letter D and the end of string we
950:41 - built a python list class it was it was
950:43 - so natural to just make it be a link
950:45 - list and Link list has has two structs
950:48 - one is the link list itself that has a
950:50 - head pointer and a tail pointer and a
950:52 - number of items that like lets us give
950:54 - back Len when we need to give Len back
950:56 - but then every node we're going to just
950:59 - have a list of of character strings or
951:02 - character arrays and so we have a
951:03 - pointer to some to a character array and
951:06 - then we have a pointer to the next and
951:08 - so when we sort of do our Constructor we
951:11 - allocate the object and then we set the
951:14 - head and the tail to null to indicate
951:15 - that the the list is currently in empty
951:17 - and set the count to zero and we're done
951:19 - and then as we add things to the list
951:21 - right we have these pointers and we
951:24 - point to the head to the beginning of
951:26 - the list the tail to the the last item
951:28 - that we added and we store using Malo
951:32 - the strings so that we get a pointer to
951:34 - a string that the list owns rather than
951:36 - the the parameter which doesn't belong
951:38 - to us and then we hook the next up and
951:41 - there's a little tricky stuff right if
951:43 - the string is empty which means head is
951:45 - null then we just Point head at the
951:48 - newly allocated node if the Tail's not
951:50 - null we take the last thing and point it
951:52 - to the one we just made and set tail to
951:56 - new and then we allocate the string and
951:59 - then copy the text from the parameter
952:03 - into text and then we store that as a
952:07 - pointer and then we update our count
952:09 - like if we add another one you have to
952:11 - kind of graph the new one in beyond the
952:14 - tail so the tail instead of being null
952:17 - now points to the one we just created
952:19 - the fun and then we update tail to point
952:22 - to that and then the next on that one is
952:25 - zero because that's our way of ending
952:27 - the list and if we're going to iterate
952:29 - through this list we start at the head
952:31 - look at the item then we go to next and
952:34 - look at that item then go to next and
952:35 - look at that item and go to next and
952:36 - it's null and we're done again we were
952:38 - able to build a quite competent python
952:42 - list object from that and as you might
952:46 - expect uh when we switch to building the
952:48 - dictionary class we just go into section
952:51 - 6.6 and go in and make a hash table with
952:55 - buckets and it's uh literally the the
952:58 - hash the bucket based hashmap is
953:00 - probably the most common programming
953:03 - interview question perhaps it's less
953:05 - common now because every know everyone
953:07 - knows that it's a programming interview
953:09 - question right and so you know I I just
953:12 - figured of course the dictionary is
953:14 - going to be a set of buckets that are a
953:17 - set of pointers to lists you know recall
953:19 - that hashes are some function that takes
953:21 - the key and creates a large pseudo
953:25 - random number which means it's
953:26 - deterministic but it's widely
953:28 - distributed with the idea of to limit
953:30 - collisions so John Smith and Joe Smith
953:33 - hopefully will hash differently even
953:35 - though they're very close right and so
953:37 - the way we did this again following
953:39 - kernigan and Richie is we use the key
953:42 - computed a hash which is a large integer
953:44 - generally but then we modulo it based on
953:46 - the number of buckets and so the buckets
953:48 - are in a sense for link lists and if we
953:52 - wanted to write this code in a way we
953:55 - could have kind of used the list object
953:58 - and said here and and and and be a
954:01 - little bit less repetitive but we just
954:03 - implemented the whole thing so if you
954:06 - look we start with a struct KR dict
954:08 - which has a number of buckets it has
954:10 - four heads and four tails and a count
954:13 - and so it's just heads and tails of the
954:15 - way you do link lists and if you look at
954:18 - the node we're going to do key and value
954:20 - and I'm going to make it be a string key
954:22 - and an integer value again to simplify
954:24 - right um and the and the Char star key
954:28 - is a pointer to a key that we're going
954:30 - to save and if we look at the new
954:32 - operation we allocate the actual
954:36 - dictionary object we decide how many
954:38 - buckets we're going to have the way I
954:40 - Define struct dict it's just a Four
954:43 - Element array then we set them all to
954:45 - null so that we know that they're empty
954:47 - because it's important to know if the
954:50 - heads and tails are each of the link
954:51 - lists are are empty now one thing is
954:54 - this is doesn't have any expansion
954:56 - mechanism and so I just wanted to keep
954:58 - it really simple to show you the data
955:00 - structure so I kind of like punted on
955:02 - rehashing an expansion and then we set
955:05 - the count to zero and then we we return
955:07 - it as we're inserting things in right we
955:11 - use the hash to figure it out and then
955:13 - we simply have four link lists so if you
955:15 - were to compare the KR list code to the
955:18 - KR dict code you would see that a lot of
955:20 - it looks the same except we're starting
955:23 - with a head that has been chosen by a
955:27 - hash computation along with modulo based
955:30 - on the number of buckets as I finished
955:33 - all that up and I finished the class up
955:36 - I wondered I began to really wonder I
955:38 - looked I started looking at it less from
955:40 - a c and KR kigan Richie perspective and
955:44 - more from a python perspective and I'm
955:45 - like did I just inadvertently do exactly
955:50 - what GTO van rossom did did GTO van
955:53 - rossom read this book like most of us
955:55 - did in the 70s and 80s and did he just
955:58 - say you know what I'm going to make a
955:59 - list object and it's going to be link
956:01 - list and I'm going to make a hash object
956:04 - and it's going to be a set of buckets
956:06 - link lists and buckets like everybody
956:08 - would do
956:10 - so I decided I would ask gido if I could
956:13 - come out to him see him and talk to him
956:17 - about the influence that kernigan and
956:19 - Richie chapter 6 had on his design of
956:24 - python and in particular was my guess
956:27 - because I didn't look at the python code
956:28 - to do this I was really teaching kigan
956:31 - en Richie chapter 6 and so up next we
956:35 - have the first of two interviews with
956:38 - Kido asking about how he built his
956:41 - structures and whether or not my
956:43 - structures that I had just guessed and
956:45 - assumed were were even close and so we
956:48 - started the interview with me handing
956:51 - him a copy of the kernigan and Richie c
956:54 - book which was signed and I left it with
956:56 - him and saying you know skim through
956:59 - chapter 6 and tell me how chapter six
957:03 - affected how you built the original
957:06 - version of python
957:14 - [Music]
957:40 - where in the python
957:42 - 001 did you start building the objects
957:46 - and where where did the objects come
957:49 - first and then a syntax came or did you
957:51 - build a syntax and then the
957:55 - objects I
957:57 - think in my head I had both okay because
958:03 - I I was building a stripped down version
958:06 - of
958:07 - ABC and I had sort of I was very
958:11 - familiar with how ABC implemented its
958:15 - data structures
958:17 - and I had pretty welldeveloped ideas
958:20 - about
958:22 - how how I would do it instead of the ABC
958:26 - way both for the syntax and for the data
958:31 - structures so for the syntax
958:35 - actually my main gripe about ABC was
958:39 - that uh it used uppercase letters for
958:44 - the keywords of the language they had a
958:47 - reason for that
958:48 - but uh I didn't think it was a good
958:51 - reason and it just looked
958:53 - horrible to a Unix hacker like
958:58 - myself so that's what I wanted to change
959:01 - for the
959:02 - syntax but I knew that I wanted to do
959:04 - the indentation and I I had
959:07 - already participated in the paror for
959:11 - ABC so I knew how to do that stuff I had
959:13 - some some of my own ideas but I I knew
959:17 - what I
959:18 - wanted I I literally actually started
959:22 - with a
959:24 - parer and actually the the I started
959:27 - with a lexer and a parer those were
959:30 - actually the first bits of the language
959:32 - that I wrote
959:33 - but before I started I knew I had very
959:38 - specific ideas on how the primitive data
959:42 - types were would be implemented I would
959:45 - use the same reference count mechanism
959:49 - that I knew well from
959:51 - ABC Uh I would
959:55 - Implement integers in a similar way
959:58 - because I want I want
960:00 - it that would be an e would be an easy
960:04 - choice not to put in the object fi yeah
960:07 - no I sort of I wanted everything to be
960:10 - an object that that was also a thing I
960:13 - approved of about ABC
960:17 - and I think I I have to take it back
960:19 - about the arbitrary Precision
960:22 - integers those came quickly but I don't
960:26 - think that they came
960:28 - immediately there was there was an
960:31 - integer type which was 32 bits there was
960:34 - a separate long type which survived
960:37 - until the end of python 2 which was
960:40 - arbitrary position and there was a flow
960:43 - type uh then for the the sort of more
960:46 - complex data
960:48 - structures uh and and and sort of the
960:51 - the the in the numeric types were not
960:54 - all that different or interesting from
960:57 - not that different from
960:59 - ABC uh but for the the
961:03 - rest I I sort of had seen what ABC did
961:08 - which was that everything was
961:10 - implemented as a tree even
961:12 - strings and I did not like that because
961:16 - I wanted to interface with system calls
961:19 - and C libraries and I
961:23 - said I I want strings to be arbitrary
961:27 - length but I want them to be a linear
961:29 - buffer and so too bad if long string
961:33 - sort
961:34 - of uh requires allocating a large buffer
961:38 - at
961:39 - once uh most strings aren't that long
961:43 - I'll make sure that it works for any
961:44 - size but
961:46 - uh I'll optimize for the short strings
961:49 - that that are the bread and butter of so
961:51 - many programs I imagined would be
961:54 - written in Python that that is a
961:56 - brilliant choice but not automatic or
961:59 - intuitive that that would be the right
962:02 - answer having having sort of written a
962:05 - lot of C code and and knowing that I
962:08 - wanted python to be extensible with C
962:11 - that was also one of the the very early
962:14 - choices I I wanted to to sort of Link
962:19 - back to
962:20 - code in a natural way so the sort of the
962:24 - the import system was part of that so
962:28 - when when python was a month old or
962:31 - maybe two months old if you were
962:33 - appending to a string in a loop was it
962:36 - basically
962:37 - extending reallocating and copying no
962:40 - strings were always immutable so soor
962:43 - yes it was it was allocate it was
962:46 - calculating the size of the result
962:49 - allocating a new string object and then
962:52 - copying the two Originals into that
962:55 - there there is a string resize internal
962:57 - operation that is sort
963:00 - of intended to be only used when you're
963:04 - building up a string before you've shown
963:06 - it to anyone else right and I I needed
963:09 - that because I was envisioning an IO
963:13 - system where you say oh I'm going to
963:16 - read a line and I don't know how long
963:18 - that line is going to be or maybe I'm
963:20 - going to slurp an entire file into a
963:22 - single string and I don't know how long
963:23 - that file is so I'm allocating a large
963:27 - enough
963:28 - buffer I'm reading into that buffer and
963:32 - then if it turns out that I allocated
963:34 - 1,000 bytes but what I read was only 15
963:37 - bytes I reallocated to give the sort of
963:40 - remaining 85 or whatever 900 byes
963:44 - talking about your thinking Before You
963:47 - released the very first version of
963:49 - Python Meaning you didn't like at some
963:51 - point you came back from vacation and
963:53 - you handed it to somebody at work this
963:56 - is your thinking when there's only one
963:58 - person before even the 0.01 oh yeah yeah
964:03 - I I sort of I wanted strings to be done
964:06 - that way including like the the little
964:09 - detail that if you have a string of say
964:13 - 10 bytes you allocate 11 byes and you
964:17 - put a no by at the
964:18 - end just so that if you happen to want
964:22 - to pass that string to a C library
964:26 - function that expected zero terminated
964:30 - strings no by terminated strings you
964:33 - wouldn't have to copy it there might be
964:35 - a null bite in the middle so you might
964:37 - the things might still go wrong
964:40 - but if you youve sort of knew or trusted
964:43 - that that wasn't the case you you
964:46 - wouldn't have
964:47 - to make a copy with one extra bite just
964:50 - to make sure that that no bite was there
964:52 - the no bite is part of the data
964:54 - structure only of course visible on the
964:58 - seaside so for lists I had a similar
965:01 - idea again lists in in
965:04 - ABC uh were a twee structure that
965:09 - was sort of super efficient even if you
965:13 - grew a very large list from small ones
965:18 - and I thought the three structure was
965:19 - way too complicated so I said okay list
965:23 - just a list is a mutable data structure
965:26 - that was sort of a concept that didn't
965:27 - really exist in in ABC in ABC everything
965:31 - was
965:32 - immutable I I thought well pragmatically
965:35 - speaking I prefer my larger data
965:38 - structures meaning lists and
965:40 - dictionaries to be mutable and so the
965:43 - list was the implementation was always
965:46 - just a PO or two a buffer that that
965:50 - could be reallocated we call it list in
965:53 - Python it really is an array that that
965:57 - is just is an array of pointers and each
966:00 - pointer points to an object we know how
966:02 - long that array is that's in the object
966:04 - header and so if there's no room we
966:07 - reallocate it and if we throw something
966:10 - away from the middle then we shift
966:13 - everything over and we also reallocate
966:16 - okay the only the only Improvement that
966:20 - happened to that data structure in the
966:23 - last well let's say 34 years is that the
966:28 - original implementation did not have
966:31 - over allocation I was relying on realloc
966:36 - doing some kind of chunking so if you
966:38 - realloc something from a th000 bytes to
966:41 - 1,4 bytes I imagine well internally aloc
966:46 - probably aligns everything in in chunks
966:49 - of 16 bytes or more and so it's not
966:53 - going to move that that memory and that
966:55 - sort of eventually that was shown to be
966:59 - either false or just
967:01 - inefficient you would do it as well as
967:04 - you would have done it but eventually it
967:07 - didn't it didn't yeah and and so uh
967:11 - eventually there there sort of
967:12 - internally there are two sizes that are
967:15 - held in the list object header one tells
967:19 - you what the length of the array is for
967:22 - of the list is to the python user and
967:25 - the other one tells you how much space
967:28 - there is in the array which and the
967:29 - second is always larger than the first
967:32 - and I'm shocked that it wasn't the link
967:34 - list oh really yeah I'm shocked oh I'm
967:38 - sorry named
967:40 - list uh but okay yeah I know it it I get
967:45 - what you're doing so then talk through
967:48 - as you built the earliest dictionary
967:50 - structure what what's different between
967:52 - that uh so again in in ABC dictionaries
967:58 - were trees and in the case of
968:02 - dictionaries uh they were kept in sorted
968:05 - order by the key the key was
968:07 - always some orderable object well I
968:12 - think in ABC everything was comparable
968:15 - yeah
968:16 - at least two things of the same type so
968:20 - ABC p and and again I thought that was
968:23 - was too complex and I I had skimmed at
968:28 - least can volume 3 which explains the co
968:32 - concept of hash tables and I was
968:35 - familiar with hash tables in Pearl I
968:39 - where I think they're cold
968:41 - hashes and so I just sort of I Le
968:46 - through the table of contents of C
968:48 - volume 3 and I picked a hashing
968:51 - algorithm and then and and sort of a
968:54 - hashtable organization that that felt
968:57 - right and so I I sort of I chose open
969:00 - hashing instead
969:02 - of uh sort of having separate linked
969:06 - lists for
969:08 - buckets uh and the
969:10 - original hash algorithm for strings at
969:13 - least was something I don't know if I
969:15 - picked the the the hash function out of
969:18 - K also but I probably did between Python
969:21 - 37 and python 3.8
969:23 - dictionaries kept their
969:25 - order ah
969:28 - ah like what happened was it the Revenge
969:31 - of ABC you know meaning that the trees
969:35 - they so the the it's a different kind of
969:38 - order in in ABC the keys were sorted
969:42 - so
969:44 - uh if if you if you have numeric keys if
969:48 - you have key the 112 and 500 in your
969:52 - dictionary in ABC at
969:55 - least the keys are ordered
969:58 - 112500 or 1 123 or whatever and if you
970:01 - insert 11 it gets inserted between 1 and
970:05 - 12 on the other hand in the the newer
970:09 - python dictionaries that preserve
970:12 - order uh it is insertion order right so
970:17 - it is not mean because that sort
970:20 - of python dictionaries don't require
970:23 - that the key type is sortable is
970:27 - comparable it only needs to be
970:30 - hashable and so we can well and it it
970:33 - and of course it needs to be com you
970:36 - need to have an equality
970:39 - comparison uh is this string equal to
970:41 - that string but you don't need you you
970:44 - never need to look at is this string
970:46 - less than that string so what did you do
970:49 - to make it keep insertion order uh so
970:54 - that was in a time when I had long
970:57 - relinquished or delegated development of
971:01 - most of the basic data
971:03 - types uh I think we had a developer in
971:06 - Japan
971:08 - who sort of for years had been improving
971:12 - the efficiency of the dictionary type M
971:17 - and sort of one one of the problems of
971:21 - the original design with open hashing
971:23 - that I picked from K is that it's pretty
971:26 - space
971:27 - inefficient because if you
971:32 - have uh I let's let's see if I can
971:35 - reconstruct for each key value pair you
971:39 - have to have a pointer to the
971:42 - key let's be oldfashioned and say that
971:45 - four bytes you have a pointer to the
971:48 - value that's another four bytes then you
971:51 - have the hash which is another four
971:54 - bytes so now the the hash table is an
971:58 - array of structs that are each 12 bytes
972:02 - long and for the hashtable algorithm to
972:06 - the lookup and insertion and deletion
972:09 - algorithm to work at
972:11 - all uh you can't have the table be more
972:15 - than 2 third
972:16 - full so that means that if you have an
972:20 - array of a thousand
972:23 - entries you can store at most six or 700
972:28 - key value Pairs and so you have three or
972:32 - 400 uh times 24 bytes wasted
972:37 - space and so
972:40 - our Japanese uh cev figured out a way to
972:46 - have Separate Tables where the the sort
972:49 - of the
972:51 - hash table only
972:54 - contained one thing I and uh the actual
972:59 - key value Pairs and hashes were kept in
973:03 - a a table that had no holes in it so
973:06 - they were basically like kind of growing
973:09 - filling remembering everything is
973:11 - remembering where things are La out and
973:14 - so first he stumbled upon sort
973:17 - of I think he he refined the algorithm a
973:22 - few times having these separate arrays
973:26 - and then he stumbled upon the property
973:29 - that oh hey it it happens to preserve
973:33 - insertion order in the second table for
973:35 - sure right exactly in in in the second
973:39 - table because the the the sort of the
973:41 - table in which you jump around based on
973:43 - the hash value now just
973:47 - has in an index in into the other table
973:52 - and so there is an additional space
973:54 - saving because if you if your hash table
973:57 - has less than 256
974:00 - elements uh that array only needs needs
974:04 - to have one bite for the
974:06 - index and so there there there there's
974:09 - like all kinds of cleverness there it
974:12 - comes as a surprise to me that you don't
974:15 - do link
974:16 - list really I could have told you that
974:19 - 10 years ago that it doesn't do link
974:22 - list you you I mean I guess and that has
974:25 - probably to do with your your desire to
974:28 - interoperate with seed kind of just
974:30 - percolates throughout that uh blocks
974:33 - blocks of things that can be extended
974:35 - and then filled in seem to be better
974:38 - than generic n what I didn't know at the
974:41 - time that that's also a a good
974:45 - architecture for Modern
974:47 - Hardware because you have you have
974:49 - better cach locality exactly I I would
974:52 - have thought which is not a concept that
974:55 - that I think I I even knew existed in in
975:00 - '89 so I I I think I just avoided link
975:04 - lists because because I didn't like them
975:06 - for some other reason that's cool that's
975:08 - exactly it's not exactly what I hope
975:10 - you'd say I hope list over and over and
975:13 - over again cuz I just have assumed all
975:15 - my life link list were the you know link
975:17 - list and hashmaps and Link list on top
975:19 - of hashmaps and Link list link list link
975:21 - list cuz computer science thinks about
975:23 - link list all the time there are plenty
975:25 - of pointers in Python yeah but but sort
975:28 - of the Classic Link list is not used
975:32 - much
975:33 - [Music]
975:49 - so I hope you watch that interview
975:51 - carefully one of the things that I do
975:53 - when I edit the interviews that I have
975:55 - with luminaries is that um it's not
975:59 - uncommon that the questions that I ask
976:01 - them are not perfect questions and then
976:05 - you kind of what I do at that point is
976:07 - I'm like whoops my assumptions were
976:10 - Incorrect and and so one of the things I
976:13 - did in the editing of the interview that
976:15 - you just watched and you'll see it in
976:17 - the interview the next one is that I
976:19 - didn't cut out all of my confusion and
976:22 - that the reason for that is is that I
976:24 - wanted you to see the moments where I
976:26 - had an assumption that turned out to be
976:28 - wrong and then I'm kind of mentally
976:30 - scrambling to ask a a good question and
976:33 - I'm and I'm asking for clarifications
976:36 - and so during that video you can see me
976:39 - learning from gido the summary of this
976:41 - is that gido really didn't use the link
976:44 - list much at all he didn't use the link
976:47 - list for the list object and didn't use
976:48 - the link list for the string object and
976:50 - didn't use the list L linked list for
976:52 - the dictionary object surprise surprise
976:56 - I was completely wrong the python 1.0
976:58 - list in dictionary objects were
977:00 - extendable arrays of pointers and not
977:03 - linked list at all while gido was an
977:07 - expert in k&r chapter 6 like most of us
977:10 - were his much more recent work was um in
977:15 - ABC and C++ and so he really wasn't
977:20 - looking at k&r for his data structure
977:24 - implementation and more importantly he
977:26 - was looking at ABC for his data
977:28 - structure implementation or more
977:30 - specifically he was looking at ABC and
977:33 - saying I don't like the way ABC did its
977:35 - data structure implementation but he
977:37 - didn't then go back to chapter 6 of
977:39 - kernigan and Richie and say well I'll
977:40 - just do it this way which is again I'm a
977:42 - computer scientist and my instinct is
977:44 - like
977:46 - chapter six of kernigan En Richie is
977:47 - just the ground truth why wouldn't you
977:49 - do
977:50 - that so I think he started with lists as
977:53 - simple extendable arrays which makes a
977:55 - lot of sense because you're either
977:56 - linearly looking them up which is not
977:59 - the fastest way or you're looking them
978:01 - up by position like sub five and why not
978:04 - use array so that just you know once you
978:07 - talk to him and he walks you through it
978:09 - you're like oh yeah I get it I get it
978:13 - but then the other thing is is he didn't
978:14 - even use Link list and dictionaries and
978:16 - you can see me as I'm asking that
978:17 - question like Inc incredulously saying
978:20 - like please tell me that you're that use
978:23 - Link list and dictionaries and buckets
978:25 - like like all the interview questions
978:27 - for the last 35 years and the answer is
978:31 - no so he looked at a an earlier document
978:37 - and this was the truth of algorithms for
978:39 - all of us in the 70s um and that is
978:43 - Donald nth volumes 1 12 and three
978:47 - and here's here right here is Donald
978:50 - newth volume 3 the one that I scanned uh
978:53 - to get what's in there and here
978:57 - in where are
979:01 - we yeah Collision resolution by open
979:04 - hashing so what he was doing was what
979:07 - good computer scientists did of the day
979:09 - and that is read through this kind of a
979:11 - book and found inspiration for how to
979:15 - build a hashmap because he knew we
979:18 - wanted to do hashing so we we we did
979:21 - hashing in Kar chapter 6 and he wanted
979:24 - to do hashing but he did it a very
979:25 - different way and it has to do with the
979:27 - Collision resolution and and the linear
979:30 - probing and so again there were no real
979:33 - link lists in the core data structures
979:35 - um it turned out that and we talk about
979:37 - this a little bit in the video that
979:41 - um there are performance advantages to
979:43 - not using link lists and it and the
979:45 - interesting thing is if you look at when
979:47 - Gita was actually
979:49 - building
979:50 - um python we were all using computers
979:54 - that didn't depend heavily on cached
979:56 - memory architectures meaning that the
979:58 - CPUs that we were using and the memory
980:00 - that we're using had a speed match much
980:03 - better and that's because all of it was
980:05 - in refrigerator size computers and
980:08 - things were just slow enough that the
980:09 - CPU was not that much faster than the
980:13 - memory but when this CPU became a single
980:16 - chip CPU in sort of in the late 1980s
980:19 - and early 1990s when the floating Point
980:22 - fast floating Point even ended up on a
980:24 - single very large very hot chip um the
980:27 - memory could never keep up because what
980:30 - happened inside the chip which is you
980:32 - know maybe 3/4 of an inch to an inch or
980:34 - more likely more like a half inch um
980:37 - that was so fast inside the CPUs that
980:40 - the memory just couldn't keep up and so
980:42 - they put caches inside the CPUs that
980:44 - could keep up with the
980:46 - CPUs but link list caused this bouncing
980:49 - bounce a bounce bounce bounce a bounce
980:51 - bouncing through memory that would that
980:53 - blew the cash and so if if you were to
980:57 - you know try to run a pure link list
981:01 - based operation with you know a 10,000
981:03 - long list it would perform terribly on a
981:06 - 1992 93 94 computer but gido wrote this
981:11 - thing in 19 like 89 and 90
981:15 - and the so the so he wasn't like
981:17 - thinking I got to make an cash efficient
981:20 - data structure he's just like I like
981:23 - arrays but they turn out to be really
981:25 - good for cash architectures and so to
981:28 - some degree if you were to go back and
981:30 - look at it and say well let's go back
981:31 - and add link list you'd say no because
981:33 - link list would have a really bad
981:36 - performance impact if we did them in a
981:39 - sense the way I did them when I was
981:41 - teaching you chapter six of kernigan and
981:43 - Richie and so that's why it was you see
981:45 - the Delight I mean I'm wrong when I'm
981:47 - talking to gido I'm wrong the whole time
981:51 - but I'm learning and I'm like oh that's
981:54 - so cool so let's let's do a little bit
981:56 - of a review and this sample code is
981:58 - available to you so let's take a look at
982:02 - my
982:02 - re-implementation of a python 1.0 list
982:06 - not the kernigan Richie way but the gido
982:09 - way and what you find is you look at
982:11 - this code and and and I I'll get some
982:14 - code walkthroughs and you can look at
982:15 - those later but if you really spend some
982:18 - time and compare the link list
982:19 - implementation to the extendable array
982:22 - implementation you'll realize it's
982:25 - simpler so for one thing we only have
982:28 - one structure it's the list we have
982:32 - again how many allocated spaces are in
982:34 - the list much like the string that we
982:36 - did I did the string pretty close to how
982:38 - gido did the string but the list I got
982:40 - wrong so you have an allocation in
982:42 - length which is very much like the
982:44 - string that I did and then a an array of
982:47 - pointers okay so that's what the Char
982:49 - star star says that's a an array the
982:52 - first star is an array the second star
982:54 - is an array of what it's a pointers to
982:56 - items okay and that is an array of
983:00 - pointers to characters that's what
983:02 - that's saying and so if you look at what
983:04 - we do we allocate the the thing we we
983:07 - set the alloc to zero and I mean alect
983:10 - to two and the length is zero and then
983:12 - we allocate an a two item array of
983:15 - pointers we know that length is zero so
983:17 - we know that none of them are used and
983:19 - so that's the data structure in a sense
983:21 - it's already simpler than a linked list
983:24 - and if you append first you got to see
983:26 - if it's you've got space to append right
983:29 - and if you've got space to a pend well
983:31 - that's okay you just allocate the new
983:33 - string you copy the parameter into that
983:35 - string and it and wherever the end is
983:37 - and length tells you where the end is
983:40 - you put it in that position and add one
983:42 - to the length and so at the end of the
983:44 - first one
983:45 - you've got a half full link list now uh
983:49 - with a zeroth item pointing at the
983:52 - character array that you just saved and
983:54 - then if you put the second one in you do
983:55 - the same thing and we don't have to do
983:57 - anything right now because the length is
984:00 - two in the alicus 2 we've got a
984:01 - completely full array because our list
984:04 - has two items in it but then the next
984:07 - time you come in self length is greater
984:11 - than or equal to self alic so we're just
984:14 - going to extend it it so I just added
984:16 - two entries for
984:17 - Simplicity and then I do a realic and
984:20 - what realic does is for the things that
984:22 - were in it before we re they get copied
984:24 - if we get a new pointer back sometimes
984:26 - you get the same pointer back with a
984:27 - little more space allowed at the end
984:29 - sometimes you get a new pointer you
984:30 - can't tell with realic computer
984:32 - scientists like myself who were trained
984:34 - on link lists really tried to avoid
984:37 - realic and maybe that was a good idea
984:39 - and maybe that was because realic wasn't
984:42 - such a great implementation and gido and
984:44 - I talk a little bit about like uh real
984:46 - realic let gido down as python you know
984:49 - progressed and became more and more
984:50 - significant so he tended to start doing
984:53 - his own memory management and not
984:55 - depending on realic which is a
984:57 - combination of the C runtime and
984:59 - potentially the operating system but the
985:01 - key to realic is if you got two items in
985:04 - there you might get a new pointer back
985:06 - and that's why I've got to reassign
985:08 - it a new pointer back but it'll copy the
985:11 - ones that are there but you're
985:12 - responsible for setting up the ones that
985:14 - are new now for us because length is all
985:16 - we need we don't even have to set like
985:18 - two and three to zero we don't have to
985:20 - do that so we just now have four spaces
985:23 - and we save the Malo we maloc it again
985:26 - and we copy the save thing in and we put
985:28 - it in at the end now we have space and
985:31 - then we add one to the length and I have
985:34 - some code walkr that goes into this more
985:36 - in more detail but let's just take a
985:38 - quick look at the shapes of these two
985:43 - approaches right and again again I just
985:45 - assumed link list but I'll tell you that
985:47 - I apologize to you I'm like well some of
985:50 - these for Loops in link lists are not
985:51 - the greatest thing blah blah blah blah
985:53 - blah blah right and if you just look you
985:56 - can kind of see how the python in the
985:59 - lower right that just has an array of
986:01 - pointers is
986:04 - simpler than the link list on the left
986:07 - and again we computer scientists have
986:10 - always like taken pride in the fact that
986:12 - we understand link lists but that
986:14 - doesn't mean that just cuz it's
986:16 - something we know how to use that it's
986:17 - the right thing in all situations and G
986:20 - gido chose to go elsewhere and then if
986:23 - we look at the uh the code in the upper
986:26 - left we're dynamically extending the
986:28 - pointers there was no reallocation in my
986:31 - KR list of pen because I didn't need to
986:33 - because it would always alloc a new node
986:36 - so there's two malaks in here in the the
986:39 - kernigan en Richie one you Malo the node
986:42 - and then you Malo the string whereas in
986:44 - the in the G one you just Malik the
986:47 - string and every once in a while you
986:49 - realloc the items the part of Link list
986:53 - that always gets me and I just have to
986:54 - draw a picture every time I do it is
986:56 - that part in the middle of the KR list
986:59 - uncore append and that's if self head
987:01 - equals null self head equals new if self
987:04 - tail not equal null self tail next
987:07 - equals new and then self tail equals new
987:10 - I get it every time right but those
987:12 - don't roll off the T nearly as easily as
987:16 - saying self item self llength equals
987:19 - saved self length plus plus for all of
987:22 - the years since
987:24 - 1972 we just use Link list almost in
987:27 - some ways as a badge of honor and gido
987:30 - felt no real urge to do that and
987:36 - inadvertently his approach to extendable
987:39 - arrays is great for caching and it's
987:41 - great for fast lookup cuz you can never
987:43 - look up a link list by sub 27 whereas if
987:47 - you do it gido's way sub 27 is a very
987:49 - cheap operation so up next we're going
987:53 - to dive into what gido did as he
987:56 - implemented the python 1.0
987:58 - [Music]
988:09 - dictionary hello and welcome to a Code
988:12 - walkthrough for C programming for
988:14 - everybody the code we're walking through
988:16 - is some of the epilog code um where
988:20 - we're comparing kind of what I did in my
988:24 - chapter six kernigan and Richie stuff to
988:27 - what gido tells us uh was the python one
988:31 - and then later the python 3.7 approach
988:34 - to dictionaries lists and strings so
988:39 - what I'm going to go through right in
988:40 - this one is the string so let's take a
988:43 - look at that code code the this is
988:47 - basically the code that is the string
988:51 - code
988:52 - now the pattern that I'm using here is a
988:56 - chunked array of characters and so like
988:59 - like if you look at it the string has
989:02 - some data but what we're adding for this
989:04 - particular one was something that Gita
989:06 - was very obsessed with uh in the early
989:10 - python version again from ABC and the
989:13 - idea is is that we use this thing called
989:15 - reference counting and it means that if
989:18 - you sort of assign something you don't
989:20 - always have to copy all the data you can
989:22 - kind of copy a pointer instead but then
989:25 - you have to be careful that reference
989:28 - count because you got an because the
989:29 - Dell operation has to know when the
989:32 - reference count goes to zero so this
989:35 - pretty much looks like the code that I
989:37 - wrote uh sort of based on the k for the
989:41 - k&r book to implement it with some
989:43 - reference Counting
989:44 - and the easiest thing to do is uh look
989:48 - at the main code here and so we create a
989:53 - new
989:55 - string
989:57 - we dump it we add an H character we dump
990:02 - it we add L world as a string and we
990:06 - dump it and and then we're going to set
990:09 - it to a new
990:10 - value um but then here's the new part
990:13 - right here
990:15 - um we're going to create this assignment
990:18 - and so this we're creating a we have a
990:20 - variable called X which is a pointer to
990:23 - a
990:24 - p1st and we have a variable called Y
990:27 - which is also a pointer to a p1st so
990:30 - what this is is this is P1 store assign
990:34 - and we're passing in a pointer and so
990:37 - what's going to happen here is this is
990:39 - like going to increment the reference
990:41 - count you're going to see this it's
990:43 - going to increment the reference count
990:44 - because now we're going to have two
990:46 - variables X and Y that are literally
990:49 - pointing to the same string so let's
990:51 - let's even run this
990:54 - code okay and so I've got I've got it
990:56 - run here um and so what we see in that
991:01 - last bit when we make a all all the top
991:04 - bit here is all on the string X but the
991:07 - interesting part here is where we say
991:09 - string x equals a completely new string
991:11 - and we're pointing out the location in
991:14 - memory that that is and then after the
991:15 - assignment statement we see string y
991:18 - equals a completely new string and it's
991:20 - at the same location but what we've done
991:22 - is we have incremented the reference
991:24 - count then if you look at the main code
991:27 - we Dell X which was the original P1 Dell
991:31 - X which is the original one and all we
991:33 - do is we decrement the reference count
991:36 - but don't we don't actually deallocate
991:38 - data and then we still have the string y
991:42 - we shouldn't have the string X
991:44 - but then what happens when we delete Y
991:47 - at the very end here P1 store Dell open
991:50 - print y Clos print then it actually
991:53 - frees the data okay and so the idea is
991:57 - we can copy a reference without copying
992:01 - all the data have X pointing to it y
992:04 - pointing to it with a reference count of
992:06 - two and then we can free either X or Y
992:09 - that'll instead of throwing away the
992:10 - data that decrements the reference count
992:13 - so let's just sort of take a bit of a
992:16 - look now most of this is the same as
992:19 - what we covered um like if we look at
992:23 - uh let's look at sort of the The
992:26 - Constructor p1st new we allocate a a
992:31 - buffer we allocate the object and then
992:34 - we allocate 10 bytes and we tell it that
992:37 - it's 10 long and we we put a new line an
992:41 - end of string in there and we set the
992:43 - reference count to one so as soon as we
992:45 - create it we assume that this new is
992:48 - going to be assigned into a variable and
992:50 - then we make the reference count be one
992:53 - and so let if you look at the Len and
992:55 - the dump and the the ETC you and you
992:59 - look at the append we see the append is
993:01 - pretty much a clone of what I did where
993:04 - you know if we don't have enough space
993:06 - we allocate another block of 10 this GTO
993:09 - calls this chunking in the video and
993:11 - then we reallocate it and then we've got
993:13 - 10 more more and so we can stick our
993:15 - character in to the end of it and add
993:18 - one to it and then we we null terminate
993:21 - the string so that code is identical to
993:24 - what I did uh in the kernigan en Richie
993:26 - book
993:28 - um and so let's look at the
993:33 - assign code so this is the interesting
993:36 - thing where P1 store assign we have one
993:43 - pointer
993:44 - and we're going to return this pointer
993:47 - so we have two variables pointing to the
993:49 - same block of dynamically allocated
993:52 - memory so when we're doing this
993:54 - assignment statement in effect yal
993:57 - X inside the object we don't need to
994:01 - worry too much about y or X but we do
994:03 - need to know that we are now referenced
994:05 - two places so every time we reference
994:09 - add a second or third reference we just
994:11 - add one to the reference count so self
994:13 - eror refs Plus+ and then we return it so
994:17 - then if we look at the code in the main
994:19 - program where we're saying struct P1
994:21 - star yal P1 store aign X we could have
994:26 - said Y equals X but we wanted to record
994:29 - the fact that we've added a reference so
994:32 - that we know that that has reference
994:33 - count of two so we don't inadvertently
994:35 - free the wrong thing and then the only
994:38 - other place that this gets interesting
994:40 - is in the Dell method so if we go into
994:43 - the Dell method
994:45 - what's cool about this and this is where
994:47 - reference counts and so we we in our
994:49 - main code we just if we're we we delete
994:52 - y with underscore Dell method we delete
994:54 - X we can do all that stuff and it's
994:56 - inside the object where these reference
994:58 - counts are being resolved and so what's
995:01 - cool about this is we're saying okay
995:03 - we're going to Dell X which was the
995:05 - original thing that we assigned it into
995:08 - and if the reference are greater than
995:10 - one we don't actually free any
995:13 - data we just decrement the reference
995:15 - count and we're
995:16 - done and so that's where we see in the
995:18 - output we see decrementing reference and
995:21 - you see all these addresses are the same
995:23 - 06 0 x60 blah blah blah 91 c0 okay and
995:29 - so they're they're being decrement so
995:31 - the first free decrements it and that
995:35 - goes from 2 to one in this case because
995:37 - we the underscore assign incremented it
995:40 - and then the underscore Dell decremented
995:43 - it but then when we get the ref count to
995:45 - one that means we're in effect freeing
995:48 - the last reference so it prints out
995:50 - freeing reference and you can see it
995:52 - says free we're actually freeing the
995:54 - data and so that's where we do the free
995:56 - of self data and then we free the the
995:59 - self to get rid of it which is the code
996:01 - we did
996:02 - before and
996:03 - so the real e essence of this code is
996:08 - the uh uh the obsession that this this
996:11 - code is the obsession with reference
996:13 - count counting and that has to do with
996:15 - the fact that you want to be able to
996:17 - point multiple places to the same string
996:20 - without wasting extra memory just to
996:22 - make a bunch of copies for no real
996:24 - purpose so when you're when you're kind
996:26 - of making a copy that points to the
996:28 - original then you have to increment the
996:31 - reference count and decrement
996:33 - it and so in the rest of these uh sample
996:36 - code I will not add reference counting
996:38 - to it because we're just going to look
996:40 - at the underlying data structures but
996:42 - it's really important to understand
996:44 - understand that reference counting was
996:47 - essential to the ABC
996:51 - implementation and gido's C++
996:55 - implementation and python 1.0
996:58 - implementation it was all about
996:59 - reference counting to save very scarce
997:03 - memory so that you could point to the
997:04 - same string many times and the reference
997:07 - counts could get very high especially
997:08 - strings that were constants so reference
997:11 - counting is important and this is just
997:13 - you can take a look at this code and
997:15 - compare it to the KR code that I I built
997:18 - um reference counting is an important
997:20 - part of of
997:21 - [Music]
997:32 - python welcome to another code walkthr
997:35 - for C programming for everybody in this
997:37 - code walkth through we are going to
997:39 - compare how uh gido implemented list in
997:44 - the earliest versions of python versus
997:46 - how I implemented list while teaching
997:49 - chapter six of kernigan and Richie and
997:53 - um and so this was if you watch the
997:55 - video of my interview with GTO van rasum
997:58 - this was like my greatest like
998:00 - Revelation like what and so the the big
998:03 - Revelation is is that um Python's
998:07 - Python's list object in you know python
998:10 - 0.01 was an array of pointers
998:15 - and if we look at the kernigan en Richie
998:17 - list item this was a linked list I did a
998:20 - l linked list and so the actual KR list
998:24 - struct has a pointer To The Head and the
998:26 - tail of its link list and count and
998:29 - again this is Classic Link list and to
998:31 - some degree while I was teaching this in
998:33 - kernigan Richie chapter 6 I was really
998:35 - teaching you link lists and using the
998:39 - python list abstraction to teach it and
998:41 - so we have two data structures we have
998:43 - this node which just has a pointer to a
998:46 - uh text saved and a pointer to the next
998:49 - one so this is like Classic Link list
998:51 - I'm not going to I'm not going to go
998:53 - through that again so you just go back
998:56 - and watch the chapter six stuff and I
998:59 - talk about link list all the time but
999:01 - that's not how python does it did it or
999:05 - does it and it's not clear to me exactly
999:11 - why but he I think he was just trying to
999:14 - build the simplest possible data
999:16 - structure and we'll look at some code
999:18 - and you'll see that there is a certain
999:20 - Simplicity like already in the just the
999:22 - struct definition we see the struct P1
999:24 - list there's only one of them if it's a
999:27 - link list you have sort of a struct for
999:30 - the node and a struct for the list
999:32 - itself the The Constructor P1 list new
999:37 - well we're just going to Malo the the
999:39 - object and then we're going to say okay
999:41 - let's allocate let's allocate to a
999:45 - charact an array of pointers to
999:48 - characters and so so if we look at the
999:49 - struct P1 list and we see Char star star
999:53 - items that is syntax for a array of
999:59 - pointers okay so you think of each
1000:01 - pointer as either 32 bits in the old
1000:03 - days or 64 bits in the modern days so
1000:05 - that's an array and so so what I'm doing
1000:09 - in this P items equals Malik open print
1000:12 - p alak time of char star that
1000:16 - means I'm allocating two elements that
1000:20 - are Pointers which means again 2 * 64
1000:23 - bits in the modern world and noting that
1000:26 - I have two in there and length which is
1000:29 - the python view of the number of items
1000:32 - is zero so we we' got space for two and
1000:35 - we have zero and that's an array that we
1000:37 - know Alec tells us how long the array is
1000:40 - and length tells us how much of the
1000:41 - array we've used and just to go back
1000:46 - I'll try not to compare and contrast too
1000:47 - much but just think about the complexity
1000:51 - of Link lists the way I did them in
1000:53 - kernigan and Rich my kernigan Richie
1000:55 - chapter 6 you have this thing called
1000:57 - Head you have this thing called tail
1000:58 - which is null and count is zero and
1001:03 - again for those of us who know link list
1001:05 - this is obvious it's what you do but an
1001:08 - array is simpler than a link list and so
1001:12 - you know there we go
1001:14 - okay okay okay okay so that's what we're
1001:17 - what we've got when we're done with our
1001:19 - Constructor we've got an array of two
1001:21 - pointers two
1001:23 - characters allocated two and length one
1001:27 - so let's go take a look at let's take a
1001:29 - look at the main code right now and so
1001:31 - the the key to this main
1001:34 - code is that in a sense here's the
1001:37 - Kernan Richie main code because this is
1001:39 - like an interface and an abstraction the
1001:42 - main code should be pretty much the same
1001:45 - and the main code pretty much is the
1001:47 - same meaning that we create a link list
1001:50 - we append some stuff to it we print the
1001:51 - list we check the length we look
1001:53 - something up and then we delete it and
1001:55 - we do both things because below the
1001:58 - abstraction below the
1002:00 - interface both of these implementations
1002:03 - both the KR list and the P1 list are
1002:07 - supposed to provide to us the caller the
1002:10 - same abstraction we can append we can
1002:12 - print we we can check the length we can
1002:14 - check the index and we can delete it and
1002:17 - it does not matter what the
1002:18 - implementation is and that so that's
1002:19 - more the Builders of the Python
1002:23 - runtime get to decide how to do this
1002:26 - because we've got a contract with them
1002:28 - again an interface so let's just take a
1002:30 - look at the code we're going to add
1002:32 - hello world to our list and print it
1002:33 - then we're going to add catchphrase and
1002:35 - print it then we're going to add Brian
1002:36 - and print
1002:37 - it and then we're going to say how big
1002:40 - is it and then we're going to ask where
1002:42 - is Brian in there and where is Bob in
1002:44 - there and then we're going to delete it
1002:46 - and if you look at the run you see you
1002:48 - know the list starts out as hello world
1002:49 - then the list is Hello World catchphrase
1002:52 - and we'll see what this extending
1002:53 - because we started with two slots in our
1002:56 - array and for the first two you didn't
1002:59 - have to get bigger but then we're like
1003:01 - oh wow we're running out of space so we
1003:03 - got to like extend this array we'll show
1003:05 - that code in a bit but then we end up
1003:07 - with three things in the list again
1003:10 - that's not our job as the caller three
1003:13 - things in the list and Brian is in
1003:14 - position two which
1003:17 - 012 hello world is zero catchphrase is
1003:19 - one and Brian is two and Bob is not
1003:21 - there so we get back at negative one
1003:24 - pretty stuff okay so let's take a look
1003:27 - at the appen code because this is where
1003:29 - the fun
1003:32 - happens okay so here's the append code
1003:35 - so let's take a look at the I now let's
1003:37 - go back how I taught you
1003:41 - aend you know a month or so a go and so
1003:46 - so again you got this lecture has
1003:48 - pictures of all this right so if you're
1003:50 - app
1003:51 - pending um if it's empty your self head
1003:55 - is new if the self tail is not equal
1003:57 - null then self tail next equals new and
1004:00 - then self tail new equals new so that's
1004:03 - just like you got to draw the picture
1004:05 - and add the little arrows and a way you
1004:08 - go and then you allak can save the
1004:09 - string itself but now we look at the P1
1004:13 - list
1004:14 - and we ex we have to extend it if
1004:17 - necessary
1004:18 - right so if self length I.E is greater
1004:23 - than self Alex so we allocated two in
1004:25 - the first in the in the Constructor and
1004:28 - then if the length is two we don't have
1004:31 - enough space because our our next one
1004:33 - would be sub two and that you can't you
1004:36 - can have Subzero and sub one in a two
1004:38 - long array and so all we're going to do
1004:41 - then is we're going to have chunking and
1004:45 - GTO mentioned chunking in the video
1004:47 - we're going to chunk it to add 10 and so
1004:51 - we're going to basically extend from two
1004:53 - to 10 so we're going to add 10 we're
1004:56 - going to increase the Alex size and then
1004:59 - we're going to call realic and realic is
1005:01 - going to take the array of items and say
1005:06 - however big that was free it move it
1005:09 - whatever extend it depending on what
1005:11 - realic is how realic is working
1005:14 - and we're going to say okay we want to
1005:15 - have TW uh 12 of these things now 12 and
1005:19 - and that becomes our new items now
1005:22 - realic will also so there's two things
1005:25 - in it and we extended 12 realic will
1005:28 - copy the two things so we don't have to
1005:30 - do any copying because realic copies the
1005:33 - first two things because it knows that
1005:35 - items is too long and so it copies the
1005:37 - first two things and then gives us 10
1005:40 - more so we there's no copy code here and
1005:43 - so I think you know gido really liked
1005:45 - the realic and a lot of C programmers
1005:47 - don't like realic and he he did he's
1005:50 - like look realic says it's going to do
1005:52 - this and I want to do this so re realic
1005:56 - do your job and so I I I think back to
1005:59 - my own time as a software developer I
1006:02 - just felt because again we were taught
1006:04 - link list link list link list I just
1006:07 - didn't think about realic as a useful
1006:09 - thing and gido clearly felt like realic
1006:12 - is the answer and it lets him have this
1006:14 - simple array uh array mentality so you
1006:17 - just reallocate and say look here's an
1006:19 - array that's two I want it to be 12 help
1006:21 - me and we're done and so that's really
1006:24 - simple code I think very easy to
1006:27 - understand and then we make a a a save
1006:31 - string and then we just add at the end
1006:33 - of the array self length which in this
1006:36 - case is sub two is that string and then
1006:39 - we add one to the length so this code is
1006:41 - really simple and if you were doing
1006:43 - debug print you don't really need any
1006:45 - addresses CU if you recall when I'm
1006:48 - printing in all my link list stuff so
1006:51 - that you can debug it and redraw all
1006:52 - your lines and figure everything out I'm
1006:55 - I'm printing addresses out all the time
1006:56 - but no this is just a position so this
1006:58 - is the zero the one and now the two in
1007:01 - this case and so that's where you see
1007:03 - when it says extending from 2 to 12
1007:05 - that's as a side effect of adding the
1007:08 - third item to a list that was
1007:10 - pre-allocated with two slots
1007:13 - okay and that's it but then let's take a
1007:18 - look at the print
1007:20 - code
1007:22 - right let's look at the print code for
1007:24 - both of
1007:28 - them this is KR list print let's take a
1007:32 - look at the print code in GTO van
1007:34 - rossum's
1007:36 - version
1007:38 - okay so the key to this is the for Loop
1007:42 - in P1 uncore P1 listor print the for
1007:46 - Loop is 4 I equal 0 semicolon I less
1007:50 - than self length let's take that blank
1007:54 - out I less than self length i++ that is
1007:59 - like really
1008:02 - basic chapter four chapter five stuff in
1008:06 - kernigan and Richie so it's just an
1008:08 - array so you write a simple incremented
1008:11 - for loop it's fast
1008:14 - cash efficient it's it's beautifully
1008:16 - simple right so in this print this is
1008:20 - obvious now when I showed you the same
1008:22 - thing in kernigan and Richie chapter 6 I
1008:27 - was I I this four in KR listor print it
1008:32 - says four CER equals self Arro head ker
1008:35 - not equal null Kerr equals KR next and I
1008:38 - apologize for this line and I'm like you
1008:41 - will eventually write this
1008:43 - because it's an idiom you will write
1008:45 - this quite naturally and it'll make a
1008:48 - lot of sense to
1008:49 - you
1008:51 - right but in Python 1 we didn't do that
1008:56 - it was an array and the only place that
1008:59 - we have to worry about its Dynamic
1009:03 - nature the only place we have to worry
1009:05 - about its Dynamic nature is in the
1009:08 - append right where we reallocate it so
1009:12 - every everything we're doing here is a
1009:15 - simple for
1009:17 - Loop so like even the Dell command here
1009:20 - the Dell basically says let's free all
1009:22 - those little items let's free those
1009:24 - character strings with a for Loop for I
1009:27 - equals z i less than self length
1009:30 - i++ again a beginning c programmer can
1009:35 - understand this code and if we look at
1009:36 - the C code in KR listor Dell we just see
1009:41 - a while loop and remember you had had to
1009:43 - or you had to do these in a certain
1009:45 - order and so the whole free and I talked
1009:47 - about all this stuff the fact that you
1009:49 - got to do it in a certain
1009:51 - order
1009:53 - well this is pretty simple right so it
1009:57 - frees each of the
1009:59 - items it's 4 equal Z in in P1 list Dell
1010:04 - you free each of the characters strings
1010:06 - that we point to then we free the array
1010:10 - that's got those pointers which are now
1010:11 - valid because we got rid of them and
1010:13 - then you free the object itself and so
1010:15 - to some
1010:17 - degree one can
1010:19 - appreciate the
1010:21 - Simplicity of what gido did in this by
1010:25 - going with arrays and again the the key
1010:29 - thing that like misled me or that gido
1010:34 - just took a different approach it really
1010:36 - came down to
1010:38 - realic and so he believed in I was
1010:42 - trained to not think about realic is
1010:44 - plan a and so I thought link lists were
1010:47 - plan a because then you don't have to do
1010:49 - so many realic and and G's like I want
1010:52 - an array and realic says it's going to
1010:54 - do this for me and away we go so I
1010:57 - encourage you uh to take a look at uh P1
1011:01 - list and KR list and put them in two
1011:04 - windows next to each other and sort of
1011:07 - compare and contrast and what I really
1011:09 - want you to do as you're comparing and
1011:12 - contrasting is I want you to think about
1011:14 - the complexity of writing debugging and
1011:17 - then later the complexity of
1011:18 - understanding and how much
1011:22 - knowledge a programmer has to understand
1011:24 - to be able to make sense of these two uh
1011:28 - bits of code and again for those of us
1011:31 - computer scientists for whom link lists
1011:33 - are very natural we just write this
1011:36 - stuff I can write it pretty fast but
1011:38 - that doesn't mean that it's the easiest
1011:39 - to learn so way we go and so I hope you
1011:43 - found this comparison interesting
1011:46 - [Music]
1011:56 - cheers so now I want to talk to you
1011:58 - about the python 1.0 dictionary as built
1012:00 - by gido back in 1989 1991 and this
1012:04 - sample code is
1012:05 - available under slode and it's the
1012:08 - epilog code and it's p1d
1012:11 - I.C so the key thing is is that instead
1012:14 - of instead of reading the C programming
1012:18 - book and KR in chapter 6 G van Rasam was
1012:24 - reading page 518 of a much earlier
1012:28 - document which is more about pure data
1012:30 - structures and algorithms and so this
1012:32 - was this was kind of like our Bible on
1012:34 - how to write good fast code and this was
1012:37 - our Bible on how to write sophisticated
1012:39 - algorithms so gido found this and he
1012:42 - decided he didn't want to make link
1012:43 - lists and that's partly because of his
1012:45 - experience in ABC and so this is open
1012:49 - hashing using an array so this is an
1012:51 - array based hash concept and in the
1012:54 - bucket Styles it's there's an array of
1012:56 - hash hash link lists and so this is an
1012:59 - array that actually everything is stored
1013:02 - in the array rather than a pointer to
1013:04 - things that are outside the array the
1013:06 - key and open addressing is how you probe
1013:09 - and find open slots when your initial
1013:12 - hash it leads to a collision and hashes
1013:14 - we try to make hashes not Collide but
1013:18 - they can Collide and so this is
1013:20 - basically it us as a circular iteration
1013:23 - and it actually if you look at there at
1013:24 - L3 it's subtracting one and if it's less
1013:28 - than Zer set I to I + m go back to step
1013:32 - L2 it's probably just easier to show you
1013:34 - a picture of what's going on so let's
1013:37 - imagine that we've got an array of eight
1013:40 - key value Pairs and this is literally an
1013:42 - array in our case these will become
1013:44 - pointers key key will be a pointer value
1013:46 - be po pointer but canth is not thinking
1013:49 - about that as far as kth is concerned
1013:51 - everything is just a variable so it's an
1013:53 - array of key value
1013:55 - Pairs and the the key thing to the hash
1013:57 - it's the same hash computation in the
1013:59 - same modulo
1014:00 - operation that looks at the number of
1014:02 - buckets but when it picks a slot in the
1014:07 - the array that slot is just where we
1014:10 - hope to store it but if that's already
1014:12 - occupied we got to find another place
1014:15 - and we presuppose that there's always
1014:18 - space and we'll talk about how that ends
1014:20 - up getting solved later with
1014:22 - rehashing but the key is is we got to
1014:24 - figure out where we want to put it
1014:26 - assuming that there's space and linear
1014:28 - probing algorithm is you start going
1014:31 - backwards so you go from three to two
1014:33 - and is that available great use it if
1014:35 - two is not available go to one go to
1014:37 - zero and if you get to zero you got to
1014:39 - go all the way to the end this is kind
1014:40 - of a circular list eventually it's going
1014:42 - to visit all eight entries but it's
1014:44 - going to start at whatever entry the
1014:47 - hash indicated it's supposed to start
1014:49 - and the whole purpose of the hash is to
1014:51 - get to the entry that has the key and
1014:52 - value in question more rapidly or to
1014:56 - know that it's not there and the way you
1014:58 - know that it's not there is you run this
1014:59 - Loop and when you find a key in a value
1015:01 - of zero which means it's empty then you
1015:04 - know that it's not there and you also
1015:06 - know where you're supposed to put it so
1015:07 - if we look at the data structures that I
1015:09 - wrote to implement this python 1
1015:11 - dictionary we have a d Noe which is just
1015:14 - a pointer to a key and a pointer to a
1015:15 - value because we're going to do strings
1015:17 - key value pairs to simplify this the
1015:20 - dictionary itself has the size of the
1015:23 - array the alic which we've been using
1015:25 - all along count or length I switch back
1015:28 - and forth in some of this code and then
1015:30 - an array of D noes now remember that
1015:32 - that's a struct so we look at the
1015:34 - Constructor we allocate the dictionary
1015:37 - we set its length which is the number of
1015:39 - things in it to zero and we set the Alec
1015:42 - which is the size of the space we can
1015:43 - store things to two and then we allocate
1015:46 - our two item array of struct D noes and
1015:50 - then we have to mark them we can't just
1015:52 - assume they're zeros when we get it back
1015:55 - from Malik some malaks give us zeros
1015:58 - some Maliks don't but in this case we
1016:00 - need to no matter what ensure that we
1016:03 - have them marked as null because our
1016:04 - null is an indication of emptiness so
1016:08 - that later when we're looking around we
1016:10 - can find which areas are empty
1016:13 - and so if we take a look at the put the
1016:15 - hash tells us where to look and we put
1016:17 - this all in P1 dict find which does the
1016:19 - hash computation and does the modulo of
1016:21 - the number of buckets and gives us back
1016:24 - a pointer to the D node in question now
1016:27 - this pointer is either where that key
1016:30 - belongs and already exists or it's where
1016:33 - that key belongs and it's empty now if
1016:35 - we found an empty
1016:37 - slot we don't have to allocate the D
1016:39 - node because it's already the array we
1016:41 - just have to set up the key with a Malo
1016:44 - and a copy set up the value with a Malo
1016:47 - and a copy and then record the fact that
1016:49 - we now have one key value pair in our
1016:52 - array we're going to use this this not
1016:55 - only to return like Len but also to know
1016:58 - when we filled it up because when Len
1017:00 - gets to be the size of Alec it's full
1017:03 - and we'll talk more about that in a
1017:05 - second so that's what it looks like
1017:07 - after we've inserted one key value pair
1017:10 - now let's say we're getting a put
1017:12 - request for a key that's already in
1017:14 - there so we're going to say Z equals W
1017:16 - instead of Catchphrase so we run
1017:19 - predictor find and it comes back and it
1017:22 - says here's your thing but the
1017:24 - difference is you look in the key the
1017:26 - one it's pointing to the one it gave us
1017:28 - back the one it found already has a key
1017:32 - now you might think that's bad news no
1017:33 - it's great news it means Z already has a
1017:36 - slot and then all we have to do is
1017:39 - update the value cuz dictionaries
1017:41 - function like assignments statements if
1017:43 - you have Z that has catchphrase and then
1017:45 - we get Z equals W you just you're
1017:48 - supposed to store W and then throw
1017:50 - catchphrase away and so that's you see
1017:51 - it do that right it it frees old value
1017:55 - which was catchphrase and then Malo the
1017:57 - new one and then stir copies into it and
1018:00 - now at the end of this one we still have
1018:02 - a length of one and Z maps to W in our
1018:05 - hashmap so now let's add let's do
1018:07 - another put let's say y equal B we're
1018:10 - going to do PCT underscore find it's
1018:12 - going hash the value y it's going to
1018:14 - give us back position one now that could
1018:17 - be because it hashed to position zero in
1018:19 - linear probing found its way to position
1018:21 - one or maybe it hash to position one it
1018:23 - just doesn't matter predict fine says
1018:26 - look this is the best possible place to
1018:28 - store why Y in this particular
1018:33 - array so now at the end of that we will
1018:35 - have z and y and we have an Alec of Two
1018:38 - and a length of two but now let's say we
1018:41 - want to insert C
1018:44 - so the problem is is that we're full
1018:47 - which means that predictor find is not
1018:50 - going to find one it whatever it hashes
1018:53 - to it's going to look through all the
1018:54 - rest of them but there's no space
1018:56 - there's no space in the array so what we
1019:00 - have to do is if it's not
1019:02 - there and we're out of space we have to
1019:07 - expand items that is the code what we
1019:10 - call rehashing so let's take a look at
1019:12 - the reaction code we'll look at this in
1019:14 - some detail at the high level we store
1019:18 - the size and the array of items in Old
1019:23 - Alec and old items respectively then we
1019:25 - double the size that's just how we do it
1019:28 - and then we allocate a brand new array
1019:32 - of D noes in this case four D noes get
1019:35 - allocated and that's in items and then
1019:37 - we do some code that pretty much looks
1019:39 - like it came from the Constructor we're
1019:41 - going to take those four nodes for D
1019:43 - nodes and we're going to set their key
1019:44 - and value to null because at this point
1019:47 - we're kind of like halfway through
1019:49 - reorganizing this thing our old items
1019:51 - are available to us but new items are
1019:53 - empty that means that we can use find
1019:56 - and do inserting into the new one and so
1019:58 - that's what we're going to do before we
1020:00 - throw old Alec away we're just going to
1020:02 - write a simple for Loop to go through
1020:04 - them now we got to check to see if old
1020:07 - item subi is null because when we're
1020:10 - done with this we're not just going to
1020:11 - wait till it's 100% full we're going to
1020:13 - actually reallocate when it's 70% full
1020:17 - if old item sub I is null. key is null
1020:20 - that means it's empty we don't have to
1020:21 - reinsert it that's all we're nameing is
1020:22 - we don't have to reinsert it but if we
1020:24 - find one then we go and ask the P1
1020:27 - dictor find where to put it and in this
1020:32 - case we're only going to always get a
1020:34 - new slot because keys are unique which
1020:39 - means we can go through all the old item
1020:41 - keys and never hit the same one twice
1020:43 - and there will always be space because
1020:46 - we just alled a thing that's twice as
1020:48 - big as the thing it's coming from so
1020:51 - there was two and we've allocated it to
1020:53 - for it we will always find a place to
1020:55 - put it because the keys are unique think
1020:59 - about it for just a
1021:01 - minute and then we just say key equal
1021:03 - and value equals copy them we don't have
1021:04 - to reallocate them or anything they're
1021:06 - just pointers to the save strings that
1021:08 - are key in value and then the only thing
1021:11 - we throw away is old items and so you
1021:15 - know it's it's it's it's kind of pretty
1021:18 - now the last thing where we say old
1021:20 - equals P1 dick find self key um we used
1021:24 - old before to figure out that oh wait a
1021:27 - sec we need to make some more space um
1021:31 - so we have to then find where the
1021:33 - incoming key because we're in the middle
1021:35 - of an insert right now so we have to
1021:37 - know in the new items where that belongs
1021:40 - and so that's why we say that so if we
1021:42 - take a look at the moment where we're
1021:44 - inserting the c
1021:47 - key we've got we're full up we've got
1021:51 - two allocated right and we're looking
1021:55 - we're saying where should we put C and
1021:57 - the answer is you can't so now we drop
1021:59 - in to the reallocation code so the first
1022:03 - thing the reallocation code does is make
1022:05 - a copy of old items and old Alec so
1022:09 - there's the two items z and y are there
1022:11 - and then what we do is we double the
1022:13 - size and make an empty array of four D
1022:17 - nodes and set their key and value to
1022:19 - null and so we kind of have the old
1022:22 - array and the new array sitting around
1022:26 - right now so then what we do is we start
1022:28 - looping through the old array and we see
1022:31 - oh Z equals W so we just run a simple
1022:34 - hash calculation and say where does Z
1022:36 - belong in the new items and then we put
1022:38 - it in there now we don't have to
1022:39 - deallocate or reallocate the actual Z or
1022:42 - the actual w we just have to change the
1022:44 - pointers now you'll notice at this
1022:46 - moment we've got a pointer in the top
1022:49 - one and the bottom one that's pointing
1022:51 - to the same allocated
1022:53 - memory that's a reference count problem
1022:55 - but we're going to throw old items away
1022:58 - in just a bit so we Loop through that
1023:00 - right so we find the Z and we put the Z
1023:03 - in the right spot remember we're still
1023:06 - in the middle of trying to insert C
1023:08 - we've kind of temporarily paused and
1023:10 - clean are cleaning up our hashmap to
1023:13 - give us space to insert so then we go
1023:15 - through the loop again and now we find
1023:18 - that the Y belongs in position
1023:21 - three yals B goes into position three
1023:24 - and now we're at the point where what we
1023:26 - have done we're still again trying to
1023:28 - insert C but we have to first make space
1023:31 - now we're kind of done with old items
1023:33 - we've got pointers in the new items that
1023:36 - point to the key value Pairs and we can
1023:38 - actually just throw that away not only
1023:40 - when we throw that away it not only
1023:42 - throws away the array itself but it
1023:44 - really kind of resolves our problem that
1023:46 - we had two pointers pointing to the same
1023:48 - thing which leads us to like memory
1023:51 - leaks potentially but now we've cleaned
1023:52 - our mess up we've freed the old items
1023:55 - we're still in the middle of inserting C
1023:58 - and this is one of the like downsides to
1024:01 - hashing is this cleanup phase can take a
1024:04 - little while I just moved everything
1024:05 - around so it looks like what we had
1024:07 - before and now that we've got this thing
1024:09 - rehashed and we've got our Z equal W and
1024:12 - yal B in an array that is four long
1024:17 - rather than two long um we are ready to
1024:20 - continue with the insertion of C so we
1024:23 - say okay where does c belong We Run The
1024:26 - Hash again with the predict underscore
1024:28 - find of the c key and it says that
1024:31 - belongs in two and again it might be in
1024:34 - two because it's empty it might be in
1024:35 - two because something was not empty and
1024:38 - we did Collision resolution but it
1024:39 - doesn't matter when it comes back from
1024:41 - find remember it's bigger so there's
1024:44 - always going to be space so we don't
1024:45 - have to worry too much about there not
1024:47 - being space but now we got an empty slot
1024:50 - and we can put that value in and put the
1024:54 - key in and and update it so that there
1024:56 - are three items uh the length becomes
1025:00 - three so that's how they did it how gido
1025:02 - did it in Python
1025:05 - 1.0 but up next we're going to talk with
1025:08 - G we we already talked with gido about
1025:10 - how things changed between Python 3.6
1025:13 - and python
1025:15 - 3.7 the same implementation was like
1025:18 - python 0.1 through python 3.6 roughly
1025:21 - the same shape I just covered but things
1025:23 - changed in Python
1025:26 - [Music]
1025:36 - 3.7 so welcome to another code walkthr
1025:40 - for C programming for everybody
1025:43 - this is another in our epilog code where
1025:45 - we're comparing and contrasting the way
1025:48 - I taught uh dictionaries lists and
1025:51 - strings in the kerning and and Richie
1025:54 - chapter 6 with how gido van rossom
1025:57 - actually implemented diction D
1025:59 - dictionaries lists and strings and we're
1026:01 - going to look at dictionaries here so
1026:03 - I've got two tabs open in my text editor
1026:07 - I've got one that's P1 dict doc which is
1026:10 - the python 1 implementation which is my
1026:13 - approximation of gido's approach and my
1026:17 - simplification of gido's approach and
1026:19 - then I have the KR dict which is the
1026:22 - version that I wrote kind of cleaned up
1026:24 - and adapted for this um the version that
1026:28 - I wrote uh as we covered it in uh kig
1026:32 - breni chapter 6
1026:35 - and if we look at the very allocation
1026:37 - and I mean the structures at the top um
1026:40 - we have a a D node a dictionary node and
1026:44 - and and we have and the dictionary node
1026:46 - in my implementation is got a next
1026:50 - pointer and so it's got a key and a
1026:52 - value we're going to have character
1026:54 - we're going to have uh string keys and
1026:56 - integer values just to keep our malx
1026:58 - down but the difference between the
1027:00 - dictionary node in my code is that I am
1027:04 - going to everyone is going to be part of
1027:06 - a link list because if you recall in my
1027:09 - code in kernigan and Richie as it's
1027:11 - described
1027:13 - it is an array of Link lists and so in
1027:15 - this case I just have four heads and
1027:18 - four tails that point to the head of a
1027:20 - link
1027:22 - list and so that means that every D Noe
1027:25 - has got to be the either the beginning
1027:28 - middle or end of a link list and so it's
1027:29 - got to have the D noes have to have a
1027:31 - star next in them so let's go compare
1027:34 - and contrast that with how gido did it
1027:37 - so gido still has a d Noe because now
1027:38 - we're in dictionaries and so you need a
1027:40 - key and a value um and and so I so in my
1027:45 - KR dict I made the value be integers
1027:47 - just to simplify it but I'm going to
1027:49 - make the keys be the values Be Strings
1027:52 - in my python code to be a little closer
1027:54 - to you know what what gido
1027:57 - did but then the change happens when we
1028:00 - start allocating the actual dictionary
1028:02 - object itself so if we look at what I
1028:05 - allocated I have a number of buckets and
1028:07 - I have a count for my struct krct but
1028:10 - then I have an array aray of four heads
1028:13 - an array of Four Tails which is
1028:14 - basically a way to make four link lists
1028:18 - that I will select among the link lists
1028:20 - based on the hash function but that's
1028:22 - not
1028:24 - what GTO did in P1 dict we got an
1028:27 - allocation in a length but then we also
1028:30 - just have an
1028:32 - array seriously an array of pointers to
1028:36 - D noes that we'll call items now the fun
1028:39 - thing is if you look at this
1028:42 - let me go ahead and show you this a
1028:43 - little bit different if I look the P1
1028:46 - list and I compare and
1028:49 - contrast a P1 list has an allocation a
1028:52 - length and a pointer
1028:55 - to it an array of pointers to
1028:59 - strings in my P1 dictionary it's an
1029:02 - array of pointers to key value pairs but
1029:04 - the Alec length and then an array of
1029:06 - pointers to something is a very similar
1029:10 - approach and you'll see when we we get
1029:12 - to the Python 3 stuff that the there's
1029:15 - almost a duality in in gido's mind
1029:19 - between the dictionary and the list the
1029:21 - dictionary is like just a slightly
1029:24 - improved list having to do with indexing
1029:27 - and and again it was a surprise to me
1029:31 - and
1029:33 - um but the similarity again when we get
1029:36 - to python the three python python 37
1029:39 - version of the dictionary is going to be
1029:42 - like oh I see what here going on but so
1029:45 - just for now remember the approximate
1029:48 - Duality between dictionaries and lists
1029:52 - in Python
1029:53 - 1.0
1029:56 - okay so again we have our link list
1029:59 - nodes that have a pointer to a key
1030:00 - pointer to a Val that'll be a
1030:02 - dynamically allocated uh pointer uh
1030:05 - pointer to a dynamically allocated in
1030:06 - save string and then we have a
1030:08 - dictionary which is then a
1030:10 - one-dimensional array
1030:12 - of pointer those pointers to those D
1030:15 - nodes um and if we um if we look so so
1030:22 - the key thing here is we need to know
1030:27 - which entries in um this array of D noes
1030:33 - are empty and available and which ones
1030:36 - are used so the Constructor is a little
1030:39 - more complex if we look at uh P1 dict
1030:41 - under underscore
1030:42 - new of course we allocate the kind of
1030:45 - object itself we set the length because
1030:47 - there's nothing in it and we're going to
1030:50 - allocate two slots just like we did in
1030:53 - the P1 list that that forces us to
1030:56 - reallocate um so that we don't have to
1030:58 - write too big of a code to cause
1031:00 - reallocation and we can debug our
1031:02 - reallocation and then we basically
1031:03 - create an array of D noes right so we're
1031:06 - like two times the size of struck D node
1031:10 - and the size of struck D node is is um
1031:13 - two 64-bit pointers and then what we're
1031:16 - going to do is we're going to mark them
1031:19 - as empty we need to know that these
1031:22 - items are empty and so we're going to
1031:24 - set the key which is a pointer in the
1031:26 - value for each of them to null so you've
1031:30 - created an a two long array of D noes
1031:34 - with keys and values of null and again
1031:37 - we need to we need to remember which
1031:39 - ones are empty and are not and so uh so
1031:43 - then let's look at the main code so
1031:44 - that's the Constructor that's the data
1031:46 - that's
1031:48 - the that's the data structures and the
1031:50 - Constructor so so what we're going to do
1031:53 - is we're um oh man I didn't I thought I
1031:57 - deleted that line that
1032:02 - um yeah let's delete this
1032:06 - line because we're printing it we've
1032:08 - added some stuff in the print that makes
1032:10 - it a little simpler
1032:12 - okay let's hope it still runs that would
1032:14 - be cool let's run ITC I change the
1032:20 - code yay it works
1032:23 - okay okay it's simpler I like simple so
1032:26 - we create a dictionary calling P1 dict
1032:28 - new we print it it's going to be empty
1032:33 - then we put under the key of Z the
1032:36 - string
1032:37 - catchphrase and print it then we put the
1032:39 - key we we put W in that should be a
1032:42 - replacement and then we put the string
1032:44 - Sakai in Sakai equals B basically Sally
1032:48 - equals c basically and then a equals D
1032:51 - and then we say how how many things do
1032:53 - we have in there and then we do a get
1032:56 - like a DOT get in a python dictionary
1032:58 - we're looking for the the key Z and we
1033:00 - looking for the key X well the key X
1033:02 - isn't going to be in there and then we
1033:03 - delete it so let's go ahead and run this
1033:05 - code which we just
1033:06 - did and um and so what this print does
1033:10 - I've added stuff to it so you see the
1033:12 - first print is just curly braake open
1033:14 - and Clos curly brace empty and it's also
1033:17 - printing out the length an Alec and so
1033:21 - basically what it's saying is there is a
1033:25 - length of zero and and we what we have
1033:27 - two spaces alect so then what we do is
1033:30 - we put Z
1033:32 - in and that Z ends up in Z equals
1033:36 - catchphrase and that ends up in position
1033:40 - zero in the array
1033:42 - and then we have a length of two a
1033:44 - length of one because we've got one
1033:46 - thing in there an Alec of two then if
1033:49 - you recall we replace Z equals W now
1033:53 - because Z hashes to the same spot we'll
1033:56 - talk about how that happens in a second
1033:58 - that hashes to position zero in the
1034:01 - array and then it just replaces it and
1034:04 - so it just replaced the value in that
1034:06 - case and so we still have only one item
1034:08 - in there and an allocation of two
1034:13 - okay and so then what we're doing is
1034:15 - we're inserting a new like Sakai equals
1034:19 - B I should probably put some more print
1034:22 - statements in
1034:24 - there uh Let's do let's do that let's do
1034:29 - the underscore put and let's put a print
1034:32 - statement in
1034:33 - here print
1034:35 - F
1034:39 - insert percent s
1034:42 - equals percent
1034:44 - s back sln comma key comma
1034:50 - value
1034:52 - oops it'll be just easy for us to debug
1034:59 - this okay okay so we insert Z equals
1035:04 - catchphrase that goes in hashed slot
1035:07 - zero we have one item and a length of
1035:11 - two we insert Z equals uh no I want to
1035:13 - call that put I want to call that
1035:15 - put because it's not
1035:21 - insert so then we put Z equals W and
1035:24 - then it uses the hashing and the lookup
1035:26 - and all that stuff to find that that's
1035:28 - in position zero and so we simply
1035:30 - replace the Valu so we didn't we don't
1035:32 - we didn't extend it at all and now it's
1035:35 - trying to put Sakai equals B in there
1035:39 - and with the hashing hashing of Sakai
1035:42 - Finds Its way to position one in our two
1035:44 - item array and when we're done we've got
1035:47 - our two item array um happens to be
1035:49 - insert order but that doesn't
1035:51 - necessarily mean because this it's just
1035:52 - my hash function is terrible um and then
1035:56 - we have two items in and and two items
1035:58 - Al two items in there and two items
1036:00 - allocated now we're trying to insert
1036:03 - Sally equals c and now the hashing
1036:06 - algorithm which I'll show you in a bit
1036:08 - looks through and says wait a sec
1036:10 - there's no space here usually it that
1036:13 - hashing algorithm says if it's above
1036:16 - 60% full then we declare it no space and
1036:20 - so we're going to do what's called
1036:22 - rehashing so we reallocate and then we
1036:24 - read the thing so we're making the space
1036:27 - so it doubles it in size so when it's
1036:29 - all said and done um Sakai ends up in
1036:33 - position one and Z ends up in position
1036:35 - two and Sally ends up in position three
1036:38 - and we have three items in a four long
1036:43 - array now here's an interesting thing
1036:45 - you will see here when we go through the
1036:47 - rehashing Z in the two two long array Z
1036:52 - was in position zero but in the four
1036:54 - long array Z is in position two because
1036:57 - this is rehashing now what what happens
1036:59 - is that's because whatever the hash
1037:01 - value for Z was modulo 2 is zero
1037:07 - but modulo 4 is two and that's be and so
1037:11 - the positions don't change right it
1037:13 - wasn't it wasn't going to end up in
1037:14 - position
1037:16 - one but modulo 2 and modulo four are are
1037:20 - multiples of each other but you'll see
1037:23 - you see in this case here Sakai Z Sally
1037:27 - the position of Z moved and so again if
1037:29 - you're writing an iterator that's going
1037:31 - through this and you just inserted one
1037:33 - and it reallocated in that that's why
1037:37 - python 1 dictionaries and literally any
1037:41 - hash based dictionary that's truly using
1037:44 - hash we'll see how it worked in Python 3
1037:46 - in a second
1037:48 - but when we reallocate things stuff gets
1037:52 - shuffled around so the order is
1037:55 - different so we made space for Sally and
1037:58 - then we put a equals D in now the thing
1038:02 - we're triggering is if it's greater than
1038:04 - 60% full one when you have one and you
1038:07 - got two that's 50% full and that's why
1038:09 - the Sakai equals B did not trigger
1038:12 - reallocation but if we have three items
1038:15 - in a four slots that's above 60% and so
1038:20 - we're going to reallocate so even though
1038:22 - we could have snuck it in that last spot
1038:25 - that's not good for hashing so we're
1038:27 - going to say you know what it's time to
1038:29 - make this bigger again so we're going to
1038:31 - make so a equals D we're going to make
1038:33 - space for a and they're going to double
1038:35 - the size of the array to be eight and
1038:39 - let's see we got Sakai equals B and
1038:41 - position one we got zal W in position
1038:43 - two we got Sally equals c in position 3
1038:48 - and a equals D in position four and
1038:50 - we're half full at this point so we're
1038:53 - done now we have a length of four and we
1038:56 - say hey let's look up Z and yes we get W
1038:59 - and let's look up X and the answer is
1039:02 - there is no X and so our code is working
1039:06 - doing you know our little unit test our
1039:09 - little unit test is kind of doing
1039:11 - dictionary
1039:13 - things so let's take a look
1039:17 - at uh put okay let's take a look at
1039:21 - print because print's easier let's take
1039:23 - a look at
1039:24 - print because print teaches us a little
1039:27 - bit about the data
1039:29 - structure okay so oh come back come back
1039:33 - come back so in P1 dict uncore print the
1039:36 - whole little first equals one that's
1039:37 - just there so that we put the comma out
1039:40 - but
1039:42 - the nice thing is it's a for Loop for I
1039:46 - equal z i less than self Alec now if we
1039:50 - look at the P1 list let's go look at P1
1039:54 - list
1039:57 - the the P1 list the array the it's I
1040:01 - equals z i less than self length and
1040:03 - that's because in the list we just
1040:05 - append in the beginning of the array Sub
1040:08 - Zero sub one sub two sub three that's
1040:10 - how this work but because we're using
1040:13 - hashing our array is like sparse in that
1040:17 - it starts out empty and we start using
1040:19 - slots but we don't use every slot in
1040:22 - order so we got to go through all the
1040:25 - slots to iterate through a dictionary
1040:29 - array and if it's null remember in the
1040:32 - remember if self item sub i. key equal
1040:35 - equal null continue which means skip
1040:38 - empty slots
1040:41 - skip empty slots so this this array
1040:43 - could have a hundred things in it and if
1040:45 - we only put one where where where the
1040:49 - thing is inserted which we're going to
1040:50 - see in a second with
1040:52 - insert is dependent on the hash function
1040:55 - because we're not just inserting them
1040:56 - linearly we're inserting them based on
1040:58 - hash function using open hashing and so
1041:02 - we have to skip the empty items but at
1041:04 - after that it's okay we just print them
1041:07 - and so we're iterating
1041:08 - through this array of pointers skipping
1041:13 - empty empty entries and printing out the
1041:17 - entries that exist every time we're
1041:19 - doing an underscore print and so we're
1041:21 - seeing them in the order that they got
1041:25 - spread out using the hashing function
1041:28 - okay and so you can see that it it
1041:31 - prints the key and it prints the value
1041:33 - and then it prints the I the
1041:35 - position um and so that leads to you
1041:38 - know very very pretty stuff and then we
1041:40 - print the length and the Alec and so
1041:42 - this is great for
1041:43 - debugging great for debugging for us
1041:47 - okay so that kind of reviews that the
1041:50 - items is a sparse array with nulls being
1041:55 - our way of marking emptiness okay so and
1041:59 - again if you go back to the the
1042:00 - underscore
1042:03 - new we allocated it and we set
1042:06 - everything to
1042:08 - null okay so let's go look at the
1042:11 - underscore put because that's where all
1042:13 - the good stuff happens it's it's a bit
1042:15 - of
1042:17 - work yeah can I get it all on one screen
1042:20 - no I can't get it all on one
1042:23 - screen
1042:25 - okay so we'll just work through
1042:29 - it um so the the first thing we have to
1042:33 - do is we have to figure
1042:36 - out which of the slots in this array the
1042:40 - key belongs in which of the slots in the
1042:44 - array does the key belong in so we're
1042:47 - going to use a a utility thing we write
1042:50 - we wrote called P1 dictor find to say
1042:53 - find me the entry in the
1042:58 - array that is the right entry for this
1043:02 - particular key okay so now I got to look
1043:05 - at that P1 dict find
1043:12 - okay so this is pretty
1043:15 - straightforward and so that this is open
1043:20 - hashing and so the way open hasing works
1043:23 - is it starts by doing a hash computation
1043:26 - to figure out a
1043:30 - position in this array of items and get
1043:37 - bucket you've seen this in other code
1043:39 - that I wrote get bucket is just a crappy
1043:42 - little hash
1043:44 - function that does a shift and an
1043:47 - exclusive ore repeatedly going through
1043:49 - the entire string with the idea of
1043:52 - creating a pseudo random number that is
1043:55 - deterministic based on the string that I
1043:57 - can then take the modulo of the number
1043:59 - of buckets so this ends up with a
1044:01 - relatively large integer that in Long
1044:03 - strings might even overflow and again
1044:06 - hashing Computing hash functions is a uh
1044:11 - is is a is is a research area unto
1044:13 - itself this is a terrible hassing
1044:15 - function but I've used it over and over
1044:18 - and over again because it's short and
1044:20 - gives me some random some pseudo
1044:22 - Randomness but it's probably highly
1044:24 - Collision resistant so the whole idea is
1044:28 - if I have two buckets this gives me a
1044:32 - deterministic number between zero and
1044:35 - and two but not including two okay so
1044:38 - let's go back to uh the find um
1044:41 - um
1044:42 - operation so
1044:45 - we we get the bucket and that bucket
1044:49 - might be let's say it's bigger let's say
1044:52 - we've got uh 16 slots and they're all
1044:57 - empty the way it works is bucket will
1044:59 - say okay you're you're you're hopefully
1045:02 - you're slot five the problem is is then
1045:06 - there's what's called Collision
1045:08 - resolution and if slot five is is
1045:11 - already
1045:12 - filled slot you got to find another
1045:16 - slot and but you got to find another
1045:18 - slot in a way that later after it's in
1045:22 - there you can find it again find the key
1045:25 - again and so we do linear hashing uh we
1045:30 - we do linear Collision resolution which
1045:33 - means if we find oursel hashing to
1045:36 - position five and position five is full
1045:39 - we say oh well let's just linearly go
1045:41 - forward let's look at six let's look at
1045:43 - seven then 8 n whatever and then when we
1045:46 - get to the end we go 0 1 2 3 4 5 and if
1045:50 - we get to the point where we have
1045:52 - checked all the slots and they're all
1045:54 - full then we kind of have to blow up and
1045:58 - that's where it says print F could not
1045:59 - fly slot for key that would be like
1046:02 - throwing an exception we'll just print
1046:04 - it out here cuz but that'd be like uh
1046:07 - something went wrong because you're
1046:08 - never supposed to 100% allocate a hash
1046:13 - about 60 or 70% is when you're supposed
1046:16 - to quit and double it or expended in
1046:19 - some other way so let's look at the code
1046:22 - that hunts for a starting at position
1046:26 - five hunts for a free
1046:29 - position and so we say offset equals
1046:33 - zero offset less than self alak offset
1046:35 - Plus+ so that's going to go if we have
1046:37 - like eight entries that's going to go
1046:39 - from 0 to seven
1046:41 - but we really want to start that
1046:42 - iterator in five and then wrap around
1046:45 - when we get to eight okay and so I just
1046:49 - I call it offset but then I calculate
1046:52 - the position in the in the um array as
1046:57 - offset plus the number of buckets I mean
1047:00 - offset plus the bucket which is five and
1047:03 - then modulo self alic so if we got eight
1047:07 - offset's going to go from zero through
1047:08 - seven and if off and bucket is five
1047:11 - that's going to go from 5 through 7 and
1047:14 - then 0 through 4 okay so I is the
1047:18 - circular look so we're we're doing a
1047:21 - circular lookup in an array starting at
1047:24 - five we're going to look through every
1047:25 - if necessary every single position in
1047:27 - that Ray array is going to be
1047:30 - checked so we're starting at like five
1047:32 - where the hash function told us to go
1047:34 - and if self item sub five. key is null
1047:38 - it's a great Splat that means that the
1047:40 - function pointed us to a available entry
1047:44 - and we're done so we return the address
1047:46 - ersan self Arrow items
1047:50 - subi
1047:53 - otherwise we might have found something
1047:55 - that's full and we don't know right now
1047:57 - if we're going to replace this value or
1047:59 - not but if the key matches what we're
1048:02 - looking for we actually found the right
1048:05 - one and so we return self the address of
1048:08 - self items I and if if we didn't find an
1048:12 - empty one and and we didn't find one
1048:16 - that was full with a matching key then
1048:19 - what we've got to do is go back up into
1048:20 - the for Loop and go down one so if we
1048:24 - were at five and we it was full but the
1048:27 - key didn't match then we would go to six
1048:30 - and if six was full and the key didn't
1048:32 - match we'd go to seven if seven was
1048:34 - empty then we're done so we say oh
1048:37 - Seven's the where we're going to go and
1048:38 - so you can see if you think about this
1048:40 - for a little while and you can go read
1048:42 - the the lecture uh slide on open
1048:45 - hashing you can see that as long as
1048:48 - there's space in this array and it's not
1048:50 - completely full eventually we're going
1048:52 - to find a place okay we're either going
1048:55 - to find a place that matches the key or
1048:57 - we're going to find an empty place and
1048:59 - that's what Fine's job is to do and
1049:02 - again as long as resize is working and
1049:04 - we never let it get to be above
1049:06 - 70% we can always find a slot for the
1049:09 - key okay okay so this again when we say
1049:12 - print F could not fly slot for key
1049:14 - that's really traceback time because
1049:17 - that means that the thing above us which
1049:19 - we're going to look at now is going to
1049:22 - be um going to blow up okay so let's
1049:25 - look at underscore put
1049:27 - again so come underscore
1049:31 - put
1049:33 - so a lot of work gets done in underscore
1049:36 - find where we hash the key and then we
1049:39 - do the linear we do the linear look up
1049:42 - if it
1049:44 - um we do the L we we do the linear
1049:47 - lookup for cl Collision resolution and
1049:50 - we either have an empty entry or we have
1049:54 - the actual entry and so the first if
1049:57 - statement we have afterwards is if old
1049:59 - is not null and the key is not null that
1050:02 - means we just found it which means all
1050:05 - we got to do is replace the value we
1050:08 - don't have to add any entries the index
1050:10 - is great great the array is great so we
1050:12 - just free the old value and we alloc the
1050:14 - new value and then we just string copy
1050:17 - it in and away we go so that's that's
1050:20 - when we did the uh that's when we did
1050:23 - the Z equals W that was the code that
1050:26 - ran to basically say oh well we found Z
1050:29 - so we just have to CH we have to free
1050:31 - the original string and the original
1050:33 - string is catchphrase and the second
1050:35 - string is W so we're replacing
1050:37 - catchphrase with w and this little bit
1050:40 - code right after the underscore find is
1050:42 - the thing that does here we found
1050:45 - it okay but so that's that's the second
1050:49 - one let's go back to Z equals
1050:51 - catchphrase because Z equals catchphrase
1050:54 - is not found because we're starting with
1050:55 - an empty array so that means that old
1051:00 - key we're going to get an old because
1051:03 - the the hash will find a slot and that
1051:05 - slot will be empty and it'll give us
1051:07 - back to us but old key is going to be no
1051:10 - which means this one is available which
1051:13 - is
1051:14 - cool okay
1051:18 - now actually this to-do is no to-do not
1051:22 - a to-do
1051:23 - anymore right now it's going to be an
1051:26 - ignore so this is the bit okay I'll come
1051:30 - back to this okay this is the tricky
1051:33 - bit now I never did this in kernigan and
1051:37 - Richie I don't think I have to check
1051:41 - but this is called rehashing and this is
1051:43 - when our length is greater than or equal
1051:47 - to 70% of our allocation which means
1051:50 - this array is more than 70%
1051:54 - full that's when we're going to do this
1051:56 - reallocation okay but I'm going to
1051:59 - ignore that whole if statement for now
1052:03 - I'll come back so we're processing Z
1052:06 - equals catchphrase here and Z ends up we
1052:10 - can even look ends up in subzero of the
1052:14 - array and so if if it's time to insert
1052:18 - this part is really easy so it's time to
1052:21 - insert we're going to allocate the key
1052:25 - the value maloc the value and maloc the
1052:28 - key and string copy them in the old
1052:32 - already exists old is a pointer into an
1052:35 - entry into an array that's got a key and
1052:38 - a value okay so there's an array of key
1052:43 - value Pairs and so we don't have to
1052:45 - allocate the old itself because the old
1052:47 - is already in the array but we do have
1052:49 - to allocate the strings that we've been
1052:51 - passed as parameters and then we add one
1052:53 - to the
1052:55 - length and so that's basically how it
1052:57 - ran when we're doing Z equals
1052:59 - catchphrase at the end we had Z in
1053:02 - position zero we had a length of one and
1053:04 - an Alec of
1053:06 - two
1053:08 - okay so now now we're going to look
1053:12 - at where we've got a and you'll notice
1053:16 - my 7 let's go back to that now because
1053:19 - we're going to look at that this is kind
1053:21 - of
1053:23 - tricky okay so this whole self length
1053:26 - greater than or equal to Alec 7 I kind
1053:29 - of it it allowed me because it was only
1053:32 - two items it allowed me to fill it up
1053:35 - completely because one item is only
1053:38 - 0.5 and so when I put aai equals B in I
1053:42 - didn't trigger the
1053:43 - reallocation so it just put it in
1053:46 - position one I don't know
1053:49 - if oh Sakai did go into position one so
1053:54 - um but now we're doing C and it's like I
1053:57 - could not find a slot for key Sally and
1054:01 - so
1054:03 - um that
1054:06 - means could not find slot for key Sally
1054:09 - so means that it searched let's go back
1054:11 - to find I guess this is not really a
1054:14 - traceback this is just a
1054:17 - fact so it it went and looked it hashed
1054:21 - this the what's the key on that again
1054:22 - Sally that key is Sally it hashed the
1054:25 - Sally found a a a starting point with
1054:29 - bucket that that hash just found a
1054:31 - bucket and where did Sally want to go
1054:34 - Sally ends up well in three but it would
1054:36 - probably have been a One S would have
1054:37 - been bucket one before it got
1054:41 - expanded and then it looked through the
1054:43 - whole thing which in this case was only
1054:44 - two and it couldn't find either an empty
1054:47 - one or one that matched Sally and so we
1054:49 - say ah can't find it return
1054:53 - null okay and so now we get back to put
1054:58 - so we're doing Sally now and we find old
1055:02 - is actually null so this code doesn't
1055:05 - run so we didn't find an entry old key
1055:09 - is not even allowed we're not even
1055:10 - allowed to say old Arrow key because old
1055:13 - is null and
1055:15 - now fine didn't find it which could be
1055:18 - bad but we're going to fix
1055:20 - it come back come back we're going to
1055:23 - fix it so we're coming through here and
1055:26 - we're saying if self length is too full
1055:30 - greater than 70% full then we're going
1055:33 - to make space so you can see here in the
1055:35 - output it says we are making space for
1055:38 - Sally we're still in the middle of the
1055:41 - put of Sally equals c right and
1055:47 - so we're going to grab a copy of the old
1055:50 - allocation number and the old items
1055:52 - those are just
1055:54 - integers and then what we're going to do
1055:56 - is we're going to make a brand new empty
1056:00 - items and so we are going to double the
1056:02 - size of our
1056:04 - array and then we're going to set the
1056:08 - new items that's why had toore old items
1056:11 - here we're going to set the new items to
1056:14 - be four D noes it's an array of 4D nodes
1056:19 - now we got to be really careful this is
1056:21 - kind of like a Constructor for that
1056:22 - items we're going to set the key and the
1056:24 - value of the newly allocated four items
1056:28 - in that array to null because they start
1056:30 - empty you'll see in a sec that we got to
1056:32 - read them so we're kind of creating an
1056:34 - empty array that's twice as
1056:38 - big and now we got to do this is why we
1056:41 - call this rehashing is we got to go
1056:43 - through the old
1056:45 - array and find all those items and then
1056:48 - we got to add them in the right spot and
1056:52 - this is where you'll notice that um Z
1056:56 - was in position zero and Z ends up in
1056:59 - this the reallocated rehashed array in
1057:01 - position two so you really have to reash
1057:04 - it because all the rules in the new one
1057:07 - have to be followed the initial hash
1057:10 - cash the linear resolution of conflicts
1057:13 - of collisions
1057:14 - Etc so you really think of this items as
1057:17 - a brand new one and we've got the old
1057:20 - items sitting there not much longer but
1057:22 - we're going to go through them all and
1057:24 - we're going to just add them again okay
1057:28 - now yeah so so we're going through all
1057:32 - of the old items if the key is null
1057:35 - that's one of the empty slots in Old
1057:37 - items continue then we're going to call
1057:40 - call find again and the key thing there
1057:42 - is that's why we made self items be the
1057:44 - new thing is so we could call find so
1057:47 - that's the first time it's being called
1057:49 - in this Loop the the new items is
1057:52 - completely empty but old item sub I sub
1057:54 - key is the
1057:56 - key and then
1057:59 - um and
1058:01 - so let's see what we got
1058:07 - here yeah so new item if new item is
1058:11 - null that means it didn't find Space now
1058:14 - we just doubled the space so that
1058:16 - shouldn't happen and given that the keys
1058:21 - in Old items are already unique because
1058:23 - this is a dictionary we should never
1058:27 - find in the new empty the key twice so
1058:32 - that basically that basically says oh
1058:34 - it's already in there and the answer is
1058:35 - wait wait wait we started with an empty
1058:37 - one so new item key not equals null is a
1058:40 - bad
1058:41 - thing but it should never happen because
1058:44 - we're going we have a unique each key is
1058:47 - unique there are no duplicates and so as
1058:49 - we're inserting them again into a new
1058:53 - hashmap array that we should never get
1058:56 - it so that's why it says very bad news
1058:59 - that means that we either couldn't find
1059:00 - Space because I don't know why or it's
1059:03 - already in there which I don't know why
1059:05 - either that means that this is like
1059:07 - traceback time this is like uh the Run
1059:09 - time library is not well formed and we
1059:12 - made a bug in our runtime
1059:14 - Library so then that means that new item
1059:17 - should be non-null and it should be
1059:20 - empty which means we can just like copy
1059:23 - now this is just a pointer copy it's not
1059:25 - actually the stuff because we're take
1059:26 - the key is the pointer to the key the
1059:28 - string array and the value is the
1059:30 - pointer to the string array so we say
1059:32 - new item key equals old item soy. key
1059:35 - and the same thing for value and so now
1059:37 - what we've done is we've copied all of
1059:40 - the old items and we've positioned them
1059:43 - correctly in the new items so at this
1059:46 - point we're done and the free here is
1059:48 - simpler because we're not freeing the
1059:51 - strings because we just copied those we
1059:55 - are freeing the
1059:57 - array okay so we're freeing the old
1059:59 - array free old underscore items frees
1060:02 - the old
1060:06 - array now what we need to do
1060:10 - is we need to search for the position
1060:12 - because we're going back
1060:14 - to put Sally equals c and so Sally is
1060:19 - the key that we're putting in so we just
1060:21 - made space for
1060:24 - Sally now again if Sally was already in
1060:28 - there this code would have run and we'd
1060:29 - be done and so we have to relook in the
1060:33 - new the newly expanded array we got to
1060:36 - find the right spot and again if Sally
1060:40 - was already in there this code would
1060:41 - have been run and we'd never be down
1060:43 - here so we have to redo this and say
1060:45 - okay where is Sally in this case we
1060:48 - really where should Sally be long
1060:50 - because we just made more
1060:54 - space and so old equals null would mean
1060:56 - we don't have we still don't have space
1060:58 - for Sally even though we doubled the
1060:59 - darn thing or yeah we doubled it and old
1061:03 - key not equal no that's means that we s
1061:05 - Sally's already in there well wait a
1061:07 - second if Sally was in there we' not
1061:10 - even come down here so again the selling
1061:12 - old key not equal again you put out
1061:15 - these kind of Trace backy very very bad
1061:17 - news that is like somebody our code our
1061:21 - code the LI we're the library writer our
1061:23 - code is messing up so old is is really
1061:27 - supposed to find no matter what we're
1061:30 - adding Sally to the dictionary old's got
1061:33 - to find a slot for us or we just or our
1061:37 - code is broken so this is me debugging
1061:40 - and leaving this in you know just to
1061:43 - make sure like oh man that is impossible
1061:45 - should never happen but I'm going to say
1061:47 - very bad
1061:48 - news so it finds a slot and then we just
1061:52 - copy the key and the value and increment
1061:54 - the
1061:55 - length and so this whole realic thing is
1061:59 - kind of new I don't think I did this
1062:00 - when I did the kernigan and Richie
1062:02 - because the way kernigan and Richie does
1062:04 - it you can just ex keep extending those
1062:06 - link lists like if you look so if we
1062:08 - look at the um under _ put in the Kernan
1062:10 - en Richie code you'll see I do a get
1062:13 - bucket
1062:15 - right and I find a
1062:18 - bucket and if I if it
1062:21 - matches there's always a bucket in this
1062:23 - one because it's the buckets are
1062:25 - Pointers to link list so there's always
1062:27 - a bucket there's no resolution by linear
1062:29 - Collision resolution so old is if we
1062:33 - find it we just copy the value and this
1062:35 - I had integer values and then otherwise
1062:38 - you just appen
1062:40 - to the end of the tail of the bucket
1062:43 - using you know self head sub bucket
1062:46 - equal all new then it's just at that
1062:48 - point this is just SM in in P in KR dict
1062:53 - we don't have to reallocate now you
1062:55 - would want to reallocate at some point
1062:57 - because then these
1062:58 - chains uh get too long and that's and so
1063:01 - it's not like you don't have to
1063:02 - reallocate with these chains I didn't
1063:05 - write it so the reallocation would be
1063:07 - sort
1063:08 - of in the middle of put and it'd be very
1063:11 - complex code and it would be actually
1063:14 - probably about the same complexity maybe
1063:16 - a little bit more complex than what the
1063:18 - python 1 uh implementation was and so uh
1063:24 - with that I think I pretty much have
1063:26 - covered the essential differences
1063:29 - between the kernigan and Richie
1063:32 - dictionary code that I wrote and the
1063:35 - basic approach you know the basic
1063:39 - approach using an array of den Noe items
1063:44 - and if we look at find a linear
1063:48 - Collision resolution and the linear
1063:51 - Collision
1063:52 - resolution let's do this I'll put a
1063:54 - comment in here linear and underscore
1064:00 - find H can't
1064:05 - um I got to figure out how to spell
1064:07 - Collision
1064:10 - well the version you see will
1064:12 - have
1064:14 - uh how many s's no how many
1064:22 - L's okay I'll fix that for you and so
1064:25 - this is linear Collision resolution and
1064:26 - that that's tricky stuff and so you want
1064:29 - to take a look at that and understand
1064:31 - that uh very carefully
1064:34 - so I hope that you found uh this lecture
1064:38 - uh useful I think the next thing we're
1064:40 - going to talk about is how dictionaries
1064:42 - changed from python 1 through 3.6 all
1064:47 - the way up through python 37 because the
1064:49 - dictionaries did change and got a lot
1064:51 - better so we'll talk about that soon
1064:54 - [Music]
1065:04 - cheers hello and welcome to another
1065:07 - programming walkthr for C programming
1065:10 - for everybody this is uh one of the last
1065:13 - walkthroughs for the epilog code and in
1065:16 - this walkthrough we are going to look at
1065:18 - how dictionary the internal data
1065:20 - structures in Python for dictionary
1065:23 - changed between the first version and
1065:27 - the 3.7 version and so the we we talked
1065:31 - previously P1 dict doc about in effect
1065:34 - python 0.01 through python
1065:38 - 3.6 and then python 3.7 and later has a
1065:41 - new dictionary that maintains uh insert
1065:45 - order um but it also saves a lot in
1065:47 - terms of efficiency so here is our
1065:50 - approximation and simplification of the
1065:53 - Python 3.7
1065:55 - dictionary um and so let's talk a little
1065:59 - bit about the problem that the python
1066:01 - 3.7 dictionary solved by looking at the
1066:04 - python uh 0.01 dictionary now if you
1066:08 - listen to the you rossom video that I've
1066:11 - got these key value
1066:14 - pairs in the real version of the
1066:17 - dictionary it stores the pointer to a
1066:19 - key pointer to the value and the hash
1066:21 - value so it doesn't have to recompute
1066:23 - the hash now I I kept it simple and all
1066:25 - my stuff was going to be small so I
1066:26 - didn't didn't do this optimization to
1066:29 - recompute the hash I could have but I
1066:31 - just kind of want to keep the code as
1066:33 - small as possible so I just recompute
1066:35 - the hash in the few places I need it but
1066:37 - this means that in a 64-bit system this
1066:41 - is uh 3 * 8 or 24 bytes and the problem
1066:45 - is let me delete this line so I don't
1066:47 - break my code uh the load Factor now we
1066:51 - never let the load Factor get above 0.7
1066:54 - which means that by definition and the
1066:56 - larger the structure gets the larger the
1066:58 - wastage is 30% of the entries have to be
1067:02 - empty in the key value pair array and
1067:05 - again that's 30% of 24 bytes
1067:09 - wasted 34 20 uh 30% of the size of the
1067:13 - array times 24 bytes that's always
1067:15 - wasted you cannot not waste
1067:19 - it and so what happened is is that in
1067:23 - the python 37 version in effect items
1067:27 - started were was treated more like a
1067:29 - simple linear array of pointers to key
1067:32 - value pairs so now you got your key
1067:34 - value pair and in in Python is key value
1067:36 - hash and a few other things so this is a
1067:39 - larger data structure D Noe is a larger
1067:42 - data structure um and then we have a
1067:45 - separate simple integer array that is
1067:48 - the index because items is an array and
1067:52 - index is the offset into that array but
1067:55 - that's just one integer and so we're
1067:57 - going to do all the hash indexing and re
1068:00 - re resolution and conflict resolution
1068:02 - and collision resolution in this index
1068:05 - array which itself is a much smaller
1068:08 - item and I'm going to just make it and I
1068:10 - don't know if if uh python does this I'm
1068:13 - just going to let index be twice as long
1068:15 - as items which means from an indexing
1068:17 - perspective we never get a load Factor
1068:19 - above 50% and we're only going to extend
1068:22 - the array when we run out of space in
1068:24 - items and we're going to store the key
1068:27 - value pairs linearly 0 1 2 3 4 5 in
1068:31 - items and then we're going to just
1068:32 - reallocate so in many ways all of a
1068:36 - sudden the kind of reing let me open a
1068:38 - new tab here P1
1068:41 - list. C the realin code if we go back to
1068:46 - the P1 list extend if necessary you're
1068:49 - going to see that in in P1 list append
1068:52 - in P3 list append we're going to see
1068:54 - that it looks a lot like the realic
1068:57 - pattern in the python list because it is
1069:01 - an array okay the the actual key value
1069:05 - pairs are stored linearly in an array
1069:07 - and that's also how you end up with
1069:10 - maintaining insert order it wasn't they
1069:12 - tried to maintain insert order but at
1069:14 - some point if you're just using a linear
1069:16 - list 012 3 4 insert order is going to be
1069:20 - maintained and if you delete one you
1069:22 - shift them all up and it just treats so
1069:24 - I would guess that ultimately inside of
1069:28 - uh python itself after 3.7 there might
1069:31 - be some overlap in the code between
1069:33 - dictionary and list because they pulled
1069:35 - out the hashing lookup in this separate
1069:39 - data structure which is an array of
1069:42 - integers okay so so then if we look at
1069:46 - the the get bucket is the same it allows
1069:50 - a hash function I make did it as small
1069:52 - as I could just so it didn't take up a
1069:54 - lot of screen space if we look at the
1069:56 - Constructor P3 dictor new we see we're
1069:59 - allocating the actual dictionary object
1070:01 - and then we're
1070:02 - allocating two key value pairs two
1070:06 - struck D noes and then we're allocating
1070:08 - four two times the Alex size of integers
1070:12 - and so our index is four and our d Noe
1070:15 - list our D node array is
1070:18 - um D note array is two and we don't have
1070:22 - to initialize the key value pair array
1070:26 - the items array because we know with
1070:28 - length which ones are valid and which
1070:30 - ones aren't valid but we do have to take
1070:32 - this new index and put negative-1 in
1070:35 - there we did this a little differently
1070:36 - in Python 1 dictionary we use null but
1070:39 - right now I'm just it's an array of
1070:40 - integers and the negative one is going
1070:42 - to be my marker that's going to be my
1070:45 - marker to say this is an available index
1070:47 - slot okay so that's what the data
1070:50 - structures look like let's go ahead and
1070:52 - run the code now you'll note that this
1070:54 - code is in effect exactly the same as
1070:57 - the P1 dict code that we went through
1070:59 - before and so we'll run it and it will
1071:02 - look stunningly familiar meaning that
1071:05 - you know we're putting we have an empty
1071:07 - empty dictionary we're putting putting
1071:09 - uh Z equals catchphrase and putting Z
1071:11 - equal W soai equal B Sally equals c AAL
1071:14 - D and we're printing it out so now we're
1071:18 - printing it out this is like an iterator
1071:20 - so Z catchphrase and then zero is is the
1071:25 - position in the index not the position
1071:27 - in the items it's the position in the
1071:30 - index so this is in index position
1071:34 - zero and when we get and so we see Z
1071:37 - Maps w
1071:39 - Sakai maps to be and they're in index
1071:41 - positions zero and one it's kind of hard
1071:43 - to hash and we didn't and be because we
1071:47 - we don't have to rehash until it's
1071:49 - completely full because and we have two
1071:52 - items the Alec is two so we can put Z
1071:55 - equal W and soai equals B remember that
1071:58 - index is four when Alec is two so index
1072:01 - has four integers so we still have a
1072:03 - load factor of 50% but now what happens
1072:06 - we're going to put Sally equals c in and
1072:09 - now we have to
1072:11 - extend the items and we automatically
1072:15 - extend the index so we have a 50% load
1072:17 - average before the extend and then we
1072:19 - have a 50% load average after the extend
1072:23 - well actually less than 50% load average
1072:24 - but the point is is because I just by
1072:27 - definition had my hash index be double
1072:30 - the length I never get to a load average
1072:32 - of
1072:33 - 0.5 above 0.5 and again you can make
1072:36 - this more complex and let the load
1072:38 - average get to 7 but I'm I'm keeping it
1072:40 - really simple the other thing that
1072:41 - you'll notice is in the rehash again
1072:44 - thinking back to the python 1 so you'll
1072:47 - notice that the hash position of Z just
1072:50 - like in the previous one after it went
1072:53 - from two to four went from position zero
1072:55 - to position two and I talked about how
1072:57 - it's not going to completely move
1072:59 - randomly but it it hopped in this case
1073:01 - because whatever the hash value um
1073:05 - modulo 2 was zero and modulo 4 was two
1073:09 - and that's because
1073:10 - two you know zero is modulo 2 so these
1073:15 - things kind of go by powers of two like
1073:18 - and so but b equals one stayed in the
1073:20 - same place etc etc etc and so but here's
1073:23 - the thing notice the order of the things
1073:25 - printing out these zeros and ones Etc
1073:29 - that's the hash position but it's not
1073:32 - the position in items so Z equals
1073:34 - catchphrase is item Subzero Z equal W is
1073:38 - in item Sub Zero Sakai is B that's in
1073:41 - item sub
1073:43 - one hash position so Z equal W in in
1073:47 - this output is in hash position two but
1073:51 - items position zero and so that you'll
1073:54 - notice that insert order is maintained
1073:56 - in this unlike the
1073:58 - P1 again this wasn't to make insert
1074:02 - order work it was a side effect of
1074:04 - changing the data structures to make
1074:07 - items be just a an indexed array
1074:10 - starting at zero and again pulling the
1074:13 - hash computation not oh
1074:16 - sorry yeah items is an array that's
1074:20 - linear and index is an array that is
1074:24 - looked up by hash okay so let's take a
1074:28 - look so let's take a look at
1074:32 - put and of course the first thing we see
1074:34 - is
1074:35 - P3
1074:37 - find and
1074:39 - uh just underscore find let's so recall
1074:43 - from the previous one that the goal of
1074:46 - find is to find a bucket position that's
1074:51 - free and available
1074:54 - okay and so um remember that get bucket
1074:58 - is just the hash computation for that
1075:00 - particular key we're looking for and we
1075:03 - have the same kind of circular this will
1075:06 - give us a number between you know Z and
1075:10 - eight like 0 through 7even if there's
1075:13 - eight entries or 0 through three if
1075:15 - there's four or 0 through 0 or one with
1075:17 - there's
1075:18 - two and then we have to go with the
1075:21 - circular look okay but you'll notice now
1075:23 - when I say four offset equals z offset
1075:26 - less than self Alec time 2 I am now
1075:29 - looping through the index array not the
1075:32 - items not the items array and I do the
1075:36 - same little trick to do the modulos so
1075:39 - that it goes like
1075:41 - 56701 2 3 4 so so I goes 567 01234 which
1075:48 - is exactly what you need to do to do uh
1075:52 - Collision resolution using linear
1075:54 - probing which is the way we do it and
1075:57 - it's very simple if we find an empty
1076:00 - spot in the index now the data is not an
1076:02 - index the data is still in items right
1076:05 - so if we find an empty spot in index
1076:07 - meaning it's a negative one that's a
1076:09 - free one and that's what we're going to
1076:10 - return notice that in this one I'm
1076:12 - returning an integer rather than a
1076:13 - pointer I probably should go back and
1076:15 - change all those others to return
1076:17 - integers instead of pointers because it
1076:19 - I think makes code easier it looks a
1076:21 - little more complex in some places but
1076:22 - easier to understand in other
1076:24 - places if it's negative one we're
1076:27 - done
1076:29 - if we care we look at the key and we
1076:32 - find in items now now this one's a
1076:35 - little trickier we're comparing the key
1076:38 - to
1076:39 - self items which is the key value pairs
1076:42 - right but it's self index sub I self
1076:45 - index sub I is the position within items
1076:50 - of a particular key value pair so we
1076:52 - have to look up using self index to find
1076:56 - the right spot because self items is
1076:58 - like a linear list it's not really a d
1077:01 - it's not really a hashmap the only thing
1077:03 - that's hashing here is the index and
1077:05 - then we go grab the key out of the thing
1077:07 - and if we match it we're like oh this is
1077:10 - the position oh by the way I found it so
1077:14 - in our calling code we'll check to see
1077:15 - if it's empty or not but right now if
1077:18 - it's empty we turn I and if it's if it
1077:20 - matches we return I otherwise we keep
1077:25 - incrementing now the key thing is
1077:29 - because the the load factor is only 0.5
1077:34 - this is always going to succeed that's
1077:36 - another nice thing about this it always
1077:38 - is going to succeed because when we
1077:41 - increase the size of items we also
1077:46 - increase the size of index so that index
1077:48 - is always two times the size of
1077:50 - items so we never get a load Factor
1077:53 - above 0.5 which means this feels to me
1077:56 - like a lot more reliable
1077:59 - code and if we get if we don't find an
1078:01 - empty slot which in the other one we
1078:03 - that was a trigger for reallocation but
1078:05 - in this one we reallocate uh differently
1078:08 - so returning negative 1 that's just like
1078:10 - not a good sign okay so let's take a
1078:12 - look again at at at find I mean at the
1078:20 - put so this code here when we do the
1078:23 - find position equals P3 dict fine of the
1078:26 - inserted key we basically say if the
1078:30 - position is not equal to1 that means
1078:34 - this is a valid entry which means we're
1078:36 - replacing the value and again again
1078:38 - that's the that's the scenario where we
1078:40 - have Z equals catchphrase and then we
1078:42 - say Z equal W we're just going to
1078:45 - replace the value we're not going to
1078:46 - change the key the key is already in the
1078:47 - right position the key is already hashed
1078:49 - properly the index is correct the items
1078:52 - is correct and all we need to do is grab
1078:57 - the value and get rid of it and then
1078:59 - alloc the new value and stir copy it in
1079:01 - and we're done so we're done so if we
1079:04 - find it that's great okay so we don't
1079:08 - find it we have to insert it but we know
1079:11 - where to insert it right here but now
1079:13 - what we
1079:14 - do is we simply say if self length is
1079:19 - greater than or equal to self alic
1079:21 - that's when we're going to expand
1079:25 - it so here we're saying if self length
1079:28 - is greater than or equal to self Alec
1079:31 - 0.7 now the Alec here is the number of
1079:34 - things in the items which we're using
1079:37 - linearly which means we can build up
1079:39 - 100% before we have to extend it so
1079:42 - we're looking to see if the length is
1079:43 - greater than or equal to self Alec here
1079:45 - we were looking as is the length greater
1079:47 - than or equal to self Alec times the
1079:49 - load Factor 0.7 that's when we triggered
1079:51 - in Python 1 dictionaries but if we
1079:55 - look this again this aen says if self
1079:59 - and now we in P1 list this is again that
1080:01 - Duality between Python 1 lists and
1080:04 - python 37 dictionaries because in a
1080:07 - sense the items is
1080:11 - just a list right so if self length
1080:16 - which means now it's full we've it's
1080:18 - 100% full it's 100% utilized there are
1080:21 - no spaces in items if self length is
1080:24 - greater than self aloc we're going to
1080:26 - extend it so that means that this code
1080:28 - here self length self alic is really
1080:32 - quite
1080:33 - simple right so we just realloc the
1080:37 - items
1080:39 - and realic twice and realic whatever
1080:41 - we're going to do twice as big in this
1080:43 - case and so that is like exactly copied
1080:46 - from the list we just
1080:48 - reic okay so but now we got a little bit
1080:51 - more work to do in Python 3 because the
1080:54 - items was easy we just reall it we did
1080:57 - exactly what lists would do in this
1080:59 - situation but now we got to fix the
1081:03 - index okay and so uh so self items at
1081:08 - this point is
1081:10 - right okay so self items is right
1081:14 - because realic did all the work for us
1081:17 - you know we doubled the size of it but
1081:19 - then it copied all that stuff okay and
1081:23 - the other thing we don't have to do here
1081:25 - which we did have to do in Python 1 is
1081:26 - we didn't have to set all these new new
1081:29 - items that have been allocated because
1081:31 - in items because it's like a list Alec
1081:34 - and length all is all that matters and
1081:36 - we haven't changed length yet we have
1081:37 - changed Alex so the fact there might be
1081:39 - garbage in all that new data it might be
1081:41 - zeros might be garbage is
1081:43 - okay now what we're going to do is
1081:46 - rebuild the
1081:47 - index items hasn't moved and so we don't
1081:51 - need it we just free Index right now
1081:53 - remember index is that integer array
1081:55 - that's that's twice aloc right so now we
1081:59 - just allocate another integer array
1082:01 - that's twice the size of whatever we've
1082:04 - got allocated in the in items an integer
1082:08 - array so self Arrow Alec time 2 * size
1082:12 - of int
1082:15 - boom and then we just have a little for
1082:17 - Loop for IAL less than or equal to self
1082:19 - Alec 2 I ++ set it to Nega 1 because
1082:23 - what we're doing is we're creating a new
1082:25 - completely empty index the key value
1082:27 - pairs are just sitting there happy as a
1082:29 - clam in items but now we got to make a
1082:31 - new index okay so we're going to refill
1082:35 - this index but it's really simple
1082:38 - so now we're going not to Alec for I
1082:41 - equals 0 I less than self length now
1082:43 - we're going to go through the items and
1082:45 - that's
1082:46 - length and then we're going to call the
1082:48 - find
1082:50 - operation based on the key of each of
1082:53 - the
1082:53 - items and that's going to give us a
1082:55 - position and it's going to do conflict
1082:59 - resolution uh Collision resolution using
1083:02 - linear probing and so at that point all
1083:06 - the index at that position position is
1083:09 - the position is where in this array
1083:11 - should it go and that means that you
1083:14 - know if it's in the third position in
1083:15 - the hash map and we're looking at the
1083:17 - zeroth position in in items I is zero
1083:21 - and position is
1083:23 - three and so this code if you compare
1083:26 - this code again it's better memory-wise
1083:30 - if you compare this code to the code
1083:33 - inside if you compare this real code
1083:36 - between the python one
1083:39 - code and the Python 3
1083:42 - code oh and oh and I don't even do it in
1083:45 - KR because it was going to be so ugly I
1083:47 - didn't want to show it to you right so
1083:49 - it's ugly in Python 1 it is pretty in
1083:53 - Python to I'm seriously this you look at
1083:56 - this for look at this code in undor put
1083:58 - for a while and you'll be like why
1084:01 - didn't they think of that back in
1084:03 - 1989 why did it take them till whatever
1084:06 - 2008
1084:08 - or something to to see this it's a
1084:10 - beautiful data structure right it is a
1084:13 - it is a beautiful data structure okay so
1084:15 - here we are in this code where we have
1084:17 - refilled the
1084:18 - index and again self index is changing
1084:23 - right and because that's how the
1084:24 - conflict resolution works and positions
1084:27 - in the index might be different before
1084:29 - and
1084:30 - after
1084:32 - so after that we're done extending we're
1084:36 - going to have to do the actual insert
1084:39 - because the reason we extended is we're
1084:40 - were going to insert a new thing in this
1084:42 - case if we look at we're we're trying to
1084:44 - put Sally equals c in then we extend
1084:46 - from two through four and now we're like
1084:48 - done extending and so we got to put
1084:50 - Sally in right so Sally's going to go in
1084:53 - and this is the insert code that we've
1084:55 - already looked at right but we do have
1084:57 - to go find its the position of Sally
1084:59 - because we found it before in the
1085:03 - pre-expanded index slash items and now
1085:05 - we're finding it in the post expanded
1085:07 - index SL items but then we just allocate
1085:09 - the key and the value copy them in um
1085:12 - and then add the key value pair at the
1085:16 - end of length which is not Alec but
1085:20 - length is like the next position in that
1085:23 - linear array of items so we're new items
1085:26 - we set the new key the new value and
1085:29 - then we set the index to be pointing at
1085:33 - this entry in self items because index
1085:36 - is an integer so it's like if we're
1085:38 - putting it in so if we're expanding from
1085:40 - two to four and we're going to now use
1085:41 - three uh position two actually um self
1085:46 - index whatever the hash the position is
1085:48 - computed by hashing and linear Collision
1085:52 - clean up and then we set it to length
1085:54 - and we add one to the length so if you
1085:56 - watch kind of all this stuff it it
1086:00 - just of of these four lines of code only
1086:04 - one of those lines has to do with
1086:05 - hashing and that is the self- index
1086:07 - position equal self
1086:09 - length we're we're recording it's kind
1086:11 - of like recording a a a cookie crumb in
1086:14 - the Hansel grle so so we're just
1086:16 - remembering in the index where that is
1086:19 - so we we can jump to the right position
1086:20 - in index quickly using hashing rather
1086:23 - than doing a linear scan of the key
1086:26 - value pairs but literally if you took
1086:28 - this index away you have just a list and
1086:31 - so again let's look at python
1086:34 - list yeah this is simpler because I'm
1086:36 - not um
1086:39 - yeah but all it does is it it extends
1086:42 - the extends this was a list of strings
1086:44 - so it's actually a little simpler but
1086:46 - all it does is it copies the string and
1086:48 - then puts it at the end and then adds
1086:50 - one to the length and it's done and so
1086:51 - the Python 3 dictionary uh does
1086:57 - that it's kind of
1086:59 - cool so as we put Sally C it extends it
1087:04 - it recomputes the index and that's why
1087:07 - the hash position of Z moved but not the
1087:11 - position in items the position in index
1087:13 - moved because this sub
1087:15 - two Z maps to W in position two that's
1087:19 - the index position not the items
1087:22 - position the items position is just like
1087:24 - a link list Z is in zero Sakai is in sub
1087:26 - one and Sally is in sub two and so
1087:29 - that's insert order and uh everything
1087:33 - works pretty well and so for me as as I
1087:38 - think about like the Python 3 dictionary
1087:41 - and compare that
1087:43 - to uh classic kernigan and Richie
1087:47 - dictionary where I didn't where the
1087:49 - classic kernigan and Richie dictionary
1087:51 - was so complex on
1087:54 - rehashing uh that I didn't even write
1087:56 - code for it I'm like let's pretend
1087:58 - that's not a problem okay and and now I
1088:00 - can tell you in the Python 3 code I can
1088:04 - tell you I can go all the way through
1088:06 - the rehashing and tell you at some of
1088:08 - the more beautiful code that I've seen
1088:11 - so I hope this you found this valuable
1088:14 - uh cheers and hope to see you
1088:16 - [Music]
1088:27 - online so now let's talk about what
1088:29 - happened between Python 3.6 and python
1088:33 - 3.7 where
1088:35 - dictionaries began to maintain insert
1088:38 - order not key order but insert order so
1088:41 - it really what the the basic idea here
1088:43 - is is that the hashing is a quick way to
1088:47 - find a starting position in an array but
1088:49 - it doesn't necessarily mean that
1088:51 - everything has to be stored in hash list
1088:53 - so so now what happens and you you saw
1088:56 - this the code we wrote with trees the
1088:59 - tree map exercises you can have sort of
1089:02 - more than one data structure that you're
1089:03 - maintaining at the same time and so
1089:06 - that's what's happening in Python 3.7
1089:09 - now python 3.6 we made a big fuss about
1089:12 - how there was no order and when you when
1089:15 - I go when you go through the code
1089:16 - walkthroughs you'll see that sometimes
1089:18 - the order changes at the moment of
1089:20 - rehashing so the order is pseudo random
1089:23 - as it were but the order can then change
1089:25 - at any
1089:26 - moment because of rehashing and um but
1089:31 - the pseudo Randomness is because of
1089:32 - hashing and the it's not even consistent
1089:35 - from insert to insert because rehashing
1089:38 - and datab and not database hashmap
1089:41 - reorganization so like I said python 3.7
1089:46 - separated the notion of the hash index
1089:49 - from the key value
1089:51 - store and so this leads to the fact that
1089:55 - iterators that go through python 3.7
1089:57 - dictionaries function much more like
1090:00 - python lists which are iterated in Key
1090:03 - order now you don't have a Subzero or
1090:05 - sub one because that
1090:08 - dictionaries don't want to give you that
1090:09 - semantic um but it basically is a python
1090:13 - list plus a hash index for quick lookup
1090:15 - and quick for inserts and gets and
1090:18 - iterating through the dictionary is just
1090:20 - like the python 1.0 list and key insert
1090:23 - key look up by key and insert by key is
1090:26 - still very quick now I have a whole long
1090:30 - walkth through that goes through all
1090:32 - this and I'll just kind of give you the
1090:35 - highlevel picture and that will help you
1090:38 - when you go through the walkthr so if
1090:40 - you look at struct PCT it's got an
1090:42 - allocation and it's got a length and
1090:44 - it's got a
1090:46 - struct D Noe that is an array of items
1090:50 - okay but now we have an integer array
1090:53 - that's index and in the code that I
1090:55 - wrote I just made index be twice as big
1090:59 - as the the number of items in index was
1091:02 - twice as big as the number of items and
1091:04 - items and that basically meant that I
1091:07 - always had space and so I end up with a
1091:09 - load factor of 0
1091:11 - five and so if you look at items it's a
1091:16 - list meaning that we insert Z equals
1091:19 - catchphrase zal w yal b and Cal 42 and
1091:23 - they maintain insert order and a new
1091:25 - insert is just done at the end so what
1091:28 - we're seeing here is a list that's 3/4
1091:30 - full but we don't care about that in the
1091:33 - same way as we did in the python 1
1091:35 - because the load factor of the items is
1091:39 - irrelevant it's the load factor of the
1091:41 - index that matters and because I'm
1091:43 - making the index twice as large as items
1091:47 - it never reaches a load Factor above 50
1091:49 - meaning we we reallocate when we need to
1091:52 - make the list bigger but then we also
1091:54 - make index bigger too and so we never
1091:57 - exceed a load factor of 50% which makes
1092:00 - things really smooth and really easy now
1092:04 - the key thing is the index is an array
1092:07 - of of integers and what's stored in each
1092:10 - integer as you can see with these arrows
1092:12 - is simply the index that the key value
1092:15 - pair lives in the items so again this is
1092:18 - kind of two simultaneous data structures
1092:22 - the index is a
1092:24 - hash items is a
1092:28 - list and index points to the offset
1092:32 - within the list now I didn't do it but
1092:34 - gido could easily have they could easily
1092:37 - shared some of the code
1092:39 - between and some of the optimizations
1092:42 - between list and the the
1092:45 - items in a dict so I'm not going to go
1092:49 - into it I do have a Code walkthrough
1092:50 - that takes a good bit of time that goes
1092:52 - through all this code just remember this
1092:54 - picture but it's really kind of
1092:56 - extracting the hash index into its own
1093:00 - table so in
1093:03 - summary we learned from gido
1093:06 - surprisingly that he loved realic and
1093:09 - expandable arrays of strs with pointers
1093:11 - to his objects link list is not hardly
1093:15 - used in Python's core data structures
1093:17 - and it turns out to be a really really
1093:19 - good choice in retrospect the code is
1093:21 - surprisingly simple once you start
1093:23 - taking a look at it and you're kind of
1093:24 - glad I was kind of glad to leave link
1093:26 - list behind even though I'm pretty good
1093:27 - at link lists and moving memory
1093:31 - management into python from realic was
1093:33 - something that happened like 10 years
1093:34 - later that EO mentioned um because the
1093:38 - realic wasn't as predictable as he
1093:41 - wanted it to be and eventually there's
1093:43 - this concept of garbage collection which
1093:44 - is underneath realic and and it was too
1093:48 - difficult to hope that realic was going
1093:51 - to do the things that python wanted done
1093:54 - so the places in the code that you've
1093:56 - looked at here that use realic now use a
1093:59 - python allocator and realic is it what
1094:02 - happens is realus gives us bigger chunks
1094:04 - of memory and then python manages those
1094:07 - and garage collects them and cleans them
1094:08 - up Etc um and so that's you know
1094:12 - that's the modern era of python really
1094:16 - depended a lot less on the cleverness of
1094:19 - realic because it just turned out to not
1094:21 - always be as clever as we
1094:24 - [Music]
1094:28 - thought but there's more youo and I
1094:31 - didn't stop
1094:33 - talking after we
1094:38 - talked about the data structure shape
1094:41 - the whole surprise link list thing I'm
1094:43 - like oh and so if you recall I had this
1094:47 - picture which was kind of like not just
1094:51 - how things worked I was placing in this
1094:54 - picture I'm placing C in the context of
1094:58 - all the languages that influence C and
1095:01 - all the languages that influenced that
1095:04 - see influenced right and so this is the
1095:06 - you've seen this picture before but what
1095:09 - I wanted to talk to gido about is I
1095:10 - wanted to talk to him about what were
1095:13 - the influences on python C C++ ABC and
1095:20 - as you will see in the video modula I
1095:23 - wasn't expecting that but I was expect I
1095:26 - don't know what I was well I do know
1095:27 - what I was expecting I I was expecting
1095:29 - that he didn't like C++ and he loves C
1095:31 - and I forgotten I didn't know as much
1095:34 - how AB how strongly uh AB had influenced
1095:38 - him so there was in ABC there was much
1095:40 - to like and for him much to dislike so
1095:44 - C++ something gido used it he wrote code
1095:47 - in it he wrote A series sounds like a
1095:50 - series of experimentations to like to
1095:54 - some degree I guess maybe his question
1095:55 - was should I is C++ so awesome that I
1095:59 - can get done what I want to get done in
1096:00 - Python in
1096:02 - C++ and so he he did some C++
1096:06 - experiments so that he found some
1096:07 - disappointing and so that's why he used
1096:10 - C instead of C++ cuz he had to he could
1096:13 - get done what he wanted to get done and
1096:16 - um and so G chose c as a language to uh
1096:20 - build python but gido learned a lot
1096:23 - about how to layer object-oriented
1096:27 - Concepts on top of an otherwise
1096:29 - procedural uh programming language and
1096:31 - so C++ had a big influence and I bet at
1096:34 - some point he thought C++ was the answer
1096:37 - and then said no I got to use uh C and
1096:41 - and of course
1096:42 - ABC if you look at the Wikipedia entries
1096:44 - like ABC influenced uh Python and the
1096:47 - answer is yes but it influenced it more
1096:50 - than you might think and that is that uh
1096:53 - there were things that gido liked and
1096:55 - things that gido didn't like about ABC
1096:58 - places he wanted to improve so it had a
1097:01 - lot of ABC had a lot of cool types ABC
1097:05 - handled allocation and deallocation
1097:06 - using reference counting G elect all
1097:08 - that stuff but it used B trees
1097:11 - internally and be trees are not binary
1097:13 - trees be trees are a thing that's most
1097:15 - commonly done on databases the other
1097:17 - thing is it it had no mechanism for user
1097:19 - defin classes all the concept of object
1097:22 - orientation was in the language itself
1097:24 - and in the language implementation
1097:26 - itself and there was no chance for users
1097:29 - to Define their own objects in
1097:31 - ABC and so I mean ABC did what it did
1097:34 - well and and gido knew ABC well and
1097:37 - worked on ABC and and knew what he
1097:39 - wanted to take from ABC and knew what he
1097:41 - wanted to build Beyond ABC I mean I
1097:44 - think that in some ways the the
1097:46 - language ABC is kind of pretty I mean I
1097:49 - can read that and you can see things
1097:51 - like split and in and other Concepts the
1097:55 - for Loop the sort of implicit iteration
1097:57 - in the for Loop for line in document you
1098:00 - can see that that just came straight to
1098:03 - python except he made it all lower case
1098:05 - of course ABC was kind of cobalt like
1098:07 - where would wanted you wanted how to
1098:09 - return words a doc how to return words
1098:12 - document is parameter that that first
1098:14 - line is a little bit tricky right he
1098:16 - also wanted uh real object orientation
1098:18 - and he wanted to stay much closer to the
1098:20 - C libraries because ABC didn't really
1098:23 - care about being able to call like C
1098:25 - string libraries or C socket libraries
1098:27 - or anything like that and he wanted
1098:30 - lowercase keywords another thing that
1098:32 - surprised me was the fact that modula 3
1098:35 - was a significant influence so modula 3
1098:38 - was a rather European centered language
1098:41 - it kind of came from Pascal which came
1098:43 - from Zurich aaha and Zurich and so this
1098:46 - was the kind of thing where folks like
1098:49 - myself in the United States really
1098:50 - didn't think too much of modula but G
1098:54 - was clearly investigating how to do
1098:56 - things and there were some really good
1098:58 - ideas in modula 3 and he went and talk
1099:01 - to the folks at modula 3 and the concept
1099:03 - of self as the first parameter is a way
1099:06 - to layer an objectoriented mechanism on
1099:09 - top of a procedural language really the
1099:11 - concept of self that was inspired by uh
1099:14 - gido's interaction with modula 3 I'm
1099:17 - going to give gido the last word here so
1099:19 - I'm going to put the second half of my
1099:21 - interview and just let gido talk about
1099:23 - what inspired him as he was designing
1099:26 - object orientation in Python
1099:35 - [Music]
1100:00 - can you walk us up to The Inspirations
1100:03 - and the history of how ABC got so good
1100:09 - at
1100:10 - o h
1100:12 - so
1100:15 - uh ABC was actually not
1100:18 - objectoriented okay
1100:22 - ABC had a fixed set of data types the
1100:27 - while the data types were
1100:29 - composable
1100:32 - like you could have
1100:35 - say a list of integers or a list of
1100:39 - strings and those would share the the
1100:42 - operations on lists but sort
1100:45 - of there was no concept of class there
1100:49 - was no concept of
1100:53 - users defining classes there was no
1100:56 - concept of
1100:59 - subclassing either in the implementation
1101:02 - or for the built-in types it was like
1101:05 - ABC had a bunch of really convenient to
1101:08 - use Primitives yeah did a lot work for
1101:11 - you but they weren't really oh that's
1101:14 - correct and and and they
1101:17 - even they insisted that there was only a
1101:20 - single numeric
1101:22 - type so that in part so that they could
1101:26 - could sort
1101:28 - of not deal with the complicated
1101:32 - hierarchy of integers and floats and
1101:36 - rationals and sort of so then so then in
1101:40 - but when you started pip you had like
1101:42 - object orientation very front of mind
1101:44 - not just a convenient set of Primitives
1101:47 - but a convenient set of object based
1101:49 - Primitives where where did you did you
1101:52 - read that in yeah or did you read that
1101:55 - somewhere
1101:56 - else uh I was familiar with
1102:00 - C++ okay yeah and I think that might
1102:06 - have been the only objectoriented
1102:08 - language that I knew at the time at
1102:11 - least I can't think of any well I I I
1102:16 - own a big book about simula which is the
1102:20 - sort of the granddaddy of all object
1102:22 - oriented languages I don't think I ever
1102:25 - managed to get my hands on a simula
1102:28 - compiler and I have to admit I also only
1102:31 - skimmed the book because it was was
1102:34 - actually sort of had you written C Plus+
1102:37 - before you yes like what kind of how
1102:40 - much have you written C++ uh enough to
1102:43 - invent automatic or what I forget what
1102:46 - they're called the pointers that are
1102:48 - like automatically ref counted so yeah I
1102:52 - I forget C layered there standard
1102:54 - counting on top of C++ so that you would
1102:56 - not lose your sanity while working in
1102:58 - C++ uh no because I was very familiar
1103:02 - with ref count because ABC's
1103:04 - implementation is written in C and all
1103:08 - everything uses reference counting and
1103:11 - it works out better in ABC because there
1103:14 - are no Cycles in possible in the data
1103:17 - types because there are no
1103:19 - mutable data types you you you can't
1103:22 - have an object that contains itself or
1103:26 - references itself directly or indirectly
1103:29 - in ABC I don't think that I sort of
1103:33 - realized all the details of why that is
1103:36 - important and I didn't care because
1103:38 - pragmatically uh those things aren't
1103:42 - always as important as they seem to be
1103:44 - theoretically but anyway I was very
1103:47 - familiar with reference counting in C
1103:50 - sort of for how it was used for ABC I
1103:53 - think that that's where I'd learned
1103:55 - about it and I didn't sort of hear much
1103:59 - about it
1104:00 - elsewhere then at some point when I was
1104:02 - teaching myself
1104:05 - C++ this must have been been in the mid
1104:07 - 80s one of the things I tried was I mean
1104:11 - my experience with ABC and reference
1104:14 - counts in the implementation was that it
1104:16 - was very error prone we
1104:20 - regularly had to sort of deal with bugs
1104:23 - in the
1104:24 - implementation where we either leaked
1104:26 - memory or uh sort of crashed because we
1104:32 - had had freed things early and it was
1104:34 - always like oh there's a missing incraft
1104:36 - for de C and of course the the Mi the
1104:39 - missing decra is much harder to debug
1104:43 - because you leak a bite here and you
1104:45 - leak aite there and nobody notices
1104:47 - because people didn't write large
1104:49 - applications in
1104:51 - ABC uh so so anyway I I I someone
1104:56 - probably put me on the idea of uh in C++
1105:02 - you can override primitive operations to
1105:05 - the extent that you can build automatic
1105:08 - reference counting and I built
1105:13 - that for some toy
1105:16 - application and played with
1105:19 - it and
1105:22 - realized that it didn't work right the
1105:26 - problem was that it was was like and I I
1105:29 - probably didn't know enough C++ at the
1105:32 - time or possibly C++ hadn't developed
1105:36 - certain subtle mechanisms like move
1105:40 - operations uh it was very crude like
1105:43 - over overloading assignment that was
1105:46 - basically what I did and so I found that
1105:51 - where if I had handwritten reference
1105:54 - count operations I would sort of know
1105:58 - okay this object is owned here so we
1106:00 - pass it to some function that function
1106:04 - doesn't have to increment the reference
1106:06 - count just because it's using that that
1106:09 - object because it's not going anywhere
1106:11 - as long as the color of that function
1106:14 - has a reference to it on the other hand
1106:16 - the automatic reference counting as I
1106:19 - had implemented it using
1106:21 - C++ uh would say oh we're passing this
1106:24 - thing as an argument to a function so
1106:27 - increment the reference count oh that
1106:29 - function Returns decrement the reference
1106:31 - count so there was much much much more
1106:33 - reference counting activity and sort of
1106:36 - that part I didn't like and so python
1106:38 - still does it does it manually and is
1106:41 - written in C not in
1106:42 - C++ but somehow I picked up the idea of
1106:48 - VTS or at least arrays of pointers to
1106:53 - functions as a handy way to implement
1106:58 - objects and actually initially for the
1107:02 - first probably six months python was not
1107:06 - object or oriented the Implement and so
1107:10 - very few people saw that like a handful
1107:12 - of my co-workers saw that and the sort
1107:16 - of the
1107:17 - implementation had this notion
1107:20 - of you can Implement an object type by
1107:25 - putting a bunch of function pointers and
1107:27 - a bit of other information in a standard
1107:30 - structure that describes the type I
1107:33 - called it a type not an object so so in
1107:36 - a way that you were you you were
1107:37 - emulating c++'s way of kind of like
1107:40 - creating a perception of objectoriented
1107:42 - programming without TR yeah oh and wait
1107:46 - a second I there is another step that I
1107:51 - just
1107:53 - missed
1107:55 - uh I so in around 88 I spent a summer as
1108:00 - an intern at
1108:03 - dexer and I talked to the designers and
1108:06 - inventors of a language named modula
1108:10 - 3 and they were
1108:12 - like putting the
1108:15 - last proof raing reading efforts for the
1108:18 - modula 3 report but they had built a
1108:22 - modula two and a half compiler they
1108:25 - called it modula
1108:27 - 2+ uh and in their documentation either
1108:32 - the the draft of the modula 3 manual or
1108:35 - the the internal modula 2+
1108:38 - manual I learned this concept of how
1108:42 - modula 2+ and three
1108:45 - do kind of not quite object orientation
1108:49 - and I think they meant it as as sort of
1108:53 - a reaction to how it was done in
1108:56 - C++ they said modula 3 is not actually
1108:59 - an object oriented language but the sort
1109:03 - of the key part of of object oriented
1109:08 - use where you you define a class through
1109:14 - a bunch of functions and the
1109:17 - notation uh where you say object. method
1109:21 - and then the arguments instead of
1109:24 - function and then the object and then
1109:27 - the rest of the arguments they they they
1109:30 - said if you use that notation object dot
1109:34 - or thing do do method pen and then
1109:38 - arguments thing had to be something that
1109:43 - that had a type I think it was a
1109:47 - Structure type that had a bunch of
1109:48 - pointers function pointers in it and so
1109:52 - the method names were
1109:55 - simply
1109:57 - uh fields or members of that structure
1110:01 - in in modular 3 and so to create the
1110:05 - equivalent of a class you defined a
1110:09 - structure you defined a structure that
1110:12 - had a bunch of function pointers they
1110:13 - were all typed so you could say this is
1110:15 - a function that takes one argument of
1110:17 - this type and it returns blah blah and
1110:20 - then a bunch of those with names and the
1110:23 - trick was if the compiler sort of
1110:25 - noticed that you were using that and
1110:27 - then you were calling it it would say oh
1110:30 - we're going to
1110:32 - insert the thing whose method you just
1110:35 - used as the the very first parameter to
1110:39 - the function this is where Python's
1110:41 - explicit self comes from exactly and so
1110:45 - that is all modular 3's design that I
1110:49 - copied and so
1110:52 - originally in Python I didn't have a
1110:55 - user level notation to even do that I
1110:58 - only the the type system was only
1111:01 - extensible by writing a c
1111:05 - extension oh
1111:07 - and
1111:08 - so the the author of class keyword what
1111:12 - we think it was the class keyword was
1111:13 - not there that was month and a half that
1111:16 - in the first probably five or six months
1111:19 - it wasn't there and uh we I think we had
1111:23 - an
1111:24 - intern who who knew C++ better or or who
1111:29 - somehow had the right lik it better who
1111:32 - knows he he was younger than me uh and
1111:36 - he said
1111:38 - hey if
1111:40 - you if you want to give users the
1111:43 - ability to Define their own classes
1111:46 - here's a heck how you could do it you
1111:48 - add this little bit of
1111:51 - syntax uh and then you map it to this
1111:54 - structure at the implementation time and
1111:57 - it all works and that's five months in
1112:00 - and and and yeah and so everything else
1112:03 - was working we we we had like like a
1112:07 - working interpreter with a reppel and
1112:09 - integers and floats and strings and
1112:12 - tupal and lists and dictionaries and
1112:16 - functions and types that were were sort
1112:19 - of internal things I think even even
1112:23 - then you could ask for the type of an
1112:26 - object did you at the time in these
1112:30 - first six months of python did you feel
1112:34 - like you were doing
1112:36 - core research on what object orientation
1112:39 - was going to mean in the future no were
1112:41 - you just no I was I was just hacking
1112:45 - together an implementation of a language
1112:48 - that I didn't know where it was going I
1112:52 - I obviously spent enough time on it
1112:55 - that I I was hoping it would go
1113:00 - somewhere uh but you didn't think of
1113:03 - yourself as like a that you were going
1113:04 - to someday like write a paper about like
1113:07 - how object orientation should be done
1113:09 - you weren't thinking like a researcher
1113:10 - would think definitely not that you were
1113:13 - just solid problem I was not a
1113:15 - researcher I was a
1113:17 - programmer I I do not have a
1113:20 - PhD uh I was employed by CWI as a
1113:26 - programmer do do you do you now even
1113:29 - think maybe that you made a profound
1113:33 - contribution you're the first person to
1113:35 - tell me that
1113:36 - and I'm not sure that I I totally
1113:40 - believe it I would I would say that the
1113:43 - modula 3
1113:46 - inventors sort of made that
1113:50 - contribution because they were they were
1113:53 - much more sort of researchy
1113:57 - types Theory types they they thought
1114:01 - long and deep about all the the sort of
1114:05 - theoretical eventual repercussions of
1114:08 - designs like that and I I was happy to
1114:11 - implement something
1114:14 - even even if there were edge cases where
1114:17 - it would just not do the right thing at
1114:19 - all like until we we finally after about
1114:24 - a decade or so added a sickly garbage
1114:27 - collector to the
1114:28 - language python would leak memory
1114:32 - irretrievably in many situations where
1114:35 - you had created a cycle and then lost
1114:40 - the last pointer into the cycle from
1114:42 - outside
1114:43 - it and it took a very long time before
1114:47 - our users convinced us that there were
1114:50 - some edge cases where that was actually
1114:54 - a real problem and there was no good
1114:56 - existing solution
1115:00 - [Music]