00:00 - Welcome to this crash course on
best scripting. Throughout this
00:03 - course Herbert will teach you a
wide range of topics, including
00:07 - basic commands, writing your
first bash script, working with
00:10 - variables, mastering control
structures, and diving into
00:14 - powerful text manipulation tools
like awk and sed, Get ready to
00:19 - unlock the full potential of
bash scripting and enhance your
00:22 - productivity by automating
tasks, streamlining processes,
00:26 - and making your workflow more
efficient. Hello, everyone, and
00:30 - welcome to this introduction
course to bash shell scripting.
00:34 - This course is aimed at anyone
who is new to shell scripting
00:37 - people who want to expand their
knowledge or for those who want
00:40 - to refresh their knowledge. My
name is Herbert and I will be
00:43 - your instructor for this course.
I've been in the IT sector as a
00:47 - system engineer since 2009. I've
dealt with multiple systems
00:51 - ranging from Windows Server to
Linux servers, and in the last
00:55 - few years, I started
specializing in automation and
00:58 - development. I've been doing
YouTube content creation since
01:01 - 2017. Up until now, and I've
already created a course on
01:05 - Linux, which might be a good
starting point. If you're
01:08 - completely new to Linux, I want
to learn more about the basics
01:11 - of the operating system itself.
01:13 - Now what is bash, bash is short
for Bourne again, shell, it
01:17 - replaced the Bourne shell in the
glue slash Linux project, which
01:21 - was the default shell for Unix
operating systems. A shell is a
01:25 - user interface for ease of use,
it makes it easy for the user to
01:29 - manage the operating system
without knowing all of the inner
01:31 - workings and complexity of the
operating system itself.
01:36 - Now why would you learn bash?
Well, the reason you want to
01:39 - learn Bash is because it's
currently the most popular shell
01:42 - scripting language for the Linux
operating system. Bash has been
01:45 - around forever it has been used
since the early days of Linux,
01:48 - and it has stood the test of
time ever since. It's also
01:52 - included in Mac OS and in
windows when you're using the
01:55 - Windows subsystem for Linux.
01:59 - Now, why would you not use bash?
Well, even though Bash is
02:02 - considered a programming
language, it obviously lacks
02:05 - some features. For example, the
ability to do object oriented
02:09 - programming is not available in
bash. Python would obviously be
02:13 - the preferred choice here if
you're looking to create more
02:16 - advanced scripts that allow
object oriented programming.
02:20 - Speaking of Python, bash is also
more complex in its syntax. When
02:24 - comparing Python syntax to bash
one could say that Bash is a lot
02:28 - harder to read and write. Not
only Python is often a better
02:32 - choice for more advanced
scripting. Newer tools like
02:35 - Ansible also make it a lot
easier for you to manage
02:38 - multiple systems, which is a lot
harder to do with bash. Of
02:41 - course, Ansible in Python are
often overkill for simple
02:44 - scripts and using one does not
exclude the other. Bash is often
02:48 - used in tandem with tools like
Ansible, or integrated in Python
02:52 - scripts. This is exactly the
reason why you should learn
02:55 - bash, just knowing the basics
could mean a big difference in a
02:58 - lot of situations. Sometimes,
the old trusty tools are still
03:02 - the most valuable. What will you
need for this course, I aimed
03:07 - this course at the standard
Windows user. So I built the
03:10 - course around the windows
subsystem for Linux, aka WsL.
03:15 - Since we will be only using
command line tools and no GUI
03:18 - WsL seems like the obvious
choice. And I also have a video
03:22 - explaining how to install WsL on
Windows. If you're running a
03:26 - true Linux distro, even better.
If you're using a Mac, you can
03:30 - follow along in your terminal
window. But first make sure that
03:33 - you have bash set as your
preferred shell. small
03:36 - disclaimer basic Linux knowledge
is required. If you're
03:39 - completely new to Linux, or even
new to bash, I would suggest you
03:43 - at least follow along with the
Linux guide that I have on my
03:46 - channel is going to give you a
good basic understanding of how
03:50 - the Linux operating system
works.
03:54 - Before we start with actual
scripting, let's first do some
03:57 - basic commands in the terminal.
Let's look at an example of two
04:01 - very simple commands to display
text in the command line. The
04:05 - first one is called Echo, which
will display the text you pass
04:08 - it as an argument. We will write
the command echo and then we
04:11 - pass it some text like so we
just type in Echo Hello. And so
04:16 - we can detect this by looking at
Echo as the command and hello as
04:20 - the argument. We will learn more
about arguments later in this
04:24 - course. In this case, we talk
about a positional argument.
04:29 - Now we can see the output that
says hello, which is the word we
04:32 - gave it as an argument.
04:34 - Let's try and see how another
command the cat command compares
04:38 - to this. The cat command
displays the contents of a file.
04:42 - But right now we don't have one.
So let's first create a file
04:44 - with our text editor Vim. In
this course, we're always going
04:48 - to be using vim because it's a
good text editor that comes with
04:51 - almost all Linux distributions.
Plus, it's actually not that
04:55 - hard to use if you get the hang
of it. I myself have written
04:58 - multiple scripts in bash.
05:00 - In Python, with Vim, so it's
definitely a good text editor
05:03 - unless you want to start writing
some serious scripts or
05:06 - software. In that case, a decent
GUI text editor like VS code,
05:10 - atom, or Sublime, or better
options.
05:15 - Let's create a new file with
them by typing vim text file.
05:20 - txt, and let's write something
in it. To write something in
05:23 - Vim, press the I button, and you
will enter the insert mode.
05:28 - From this mode, you can start
writing text. Let's write hello
05:32 - world in this file, now we press
the Escape button. And you will
05:35 - see that the insert mode is now
gone, we have exited the insert
05:40 - mode and we're back into command
mode. And once you're back into
05:43 - the regular command mode, you
can press the colon W to write
05:47 - the file. And this will make
sure the changes we made are
05:49 - actually done and saved to the
disk. And then we can press Q to
05:54 - exit the file. Also, to make
life simpler, we can go into
05:58 - Vim, make some changes and
combine the colon W and call on
06:02 - Q to write colon wq. This will
automatically write the file and
06:07 - quit vim at the same time.
06:10 - If you made any changes you
don't want to save, you can
06:12 - ignore the changes by typing
colon Q, exclamation mark, which
06:17 - will quit vim while ignoring any
changes made.
06:21 - Now that we created our file,
let's try to print the contents
06:24 - of the file with the cat
command. This command will print
06:27 - out whatever's in the first
positional argument, in our case
06:30 - is the name of the file we just
created. So we just type in cat
06:34 - txt file a TXT, and we should
see the contents of the file
06:37 - printed here. Okay, great. We
can now print our own text and
06:41 - also text files to the terminal.
06:44 - This may not sound like much,
but it's something that you will
06:46 - use a lot when writing bash
scripts.
06:53 - So now finally, we are going to
write a shell script with the
06:56 - knowledge we just gathered in
the previous section. Start off
07:00 - by first opening your favorite
text editor, and named the text
07:04 - file shell test.sh, like so. Vim
space, shell test.sh.
07:12 - Now that we have our text editor
opened, let's try another mode
07:15 - of writing text in Vim, the
Append mode, instead of pressing
07:19 - i On your keyboard, press the A
button. This will append your
07:23 - text rather than inserted. With
the insert mode, you write the
07:26 - character before the cursor with
the Append mode, you write the
07:30 - character after the cursor. Now
in this case, it doesn't matter
07:33 - of course, because it's a new
file, but I thought I would
07:36 - mention it anyways, since
sometimes it can come in handy.
07:40 - Let's not start with our shell
script. In Vim, write echo Hello
07:44 - World, and write and quit the
file by pressing the insert or
07:49 - append mode, writing echo Hello
World, and pressing the Escape
07:53 - button and then writing colon
wq. Now let's see if we can
07:57 - actually find the file in here
using the ls command, which will
08:01 - list all the files in our
current directory. As you can
08:04 - see, the file is there and we
can verify the location by
08:08 - looking at the terminals current
location over here, which says
08:11 - the tilde symbol and the tilde
symbol indicates that we are in
08:15 - our current home directory. By
typing P WD. We can verify that
08:20 - we are indeed in the home
directory. pwd stands for print
08:23 - working directory. And this way
we can print the directory that
08:27 - we are currently working in,
which is indeed our home
08:30 - directory.
08:32 - Now let's run our file by
providing the command line with
08:35 - the command line interpreter.
08:38 - Which is bash space, shell
test.sh. This will output the
08:45 - command we entered in the shell
script using the bash
08:47 - interpreter. But when we type in
Echo dollar sign shell, we can
08:52 - verify that we are actually
running in a bash shell. So
08:56 - should we really have to specify
it? Well, the short answer is
09:00 - yes. Just because we are running
in a bash shell, that does not
09:04 - mean that Linux is going to
assume every file we want to run
09:07 - is also in bash. We should
always provide an interpreter
09:11 - for our shell scripts to use the
correct type of shell.
09:14 - That does not mean however, that
we shouldn't make it easier for
09:18 - ourselves. We can actually
provide the command line
09:21 - interpreter in the shell script
itself by typing it at the top
09:24 - of our script. In our case, we
have to provide the full path to
09:28 - the shell interpreter. Let's
copy our output from the echo
09:32 - dollar sign shell command and
use it in our shell script.
09:37 - Copy the output by selecting it
and using either Ctrl C or right
09:40 - clicking the selection either it
should work.
09:45 - Now let's go back into our shell
script and let's enter the
09:48 - insert mode. Since we want to
enter all this information in
09:51 - the beginning of the file, press
I am type in pound sign
09:55 - exclamation mark and then paste
in the output of the echo
10:00 - Dollar Sign shell command. And
what we do here is we provide
10:04 - the shebang. So the pound sign
exclamation mark is a way of
10:08 - telling the shell script which
interpreter to use, we follow up
10:13 - the shebang by providing the
full path to the shell
10:18 - interpreter. And this way, the
shell knows which type of shell
10:23 - interpreter it needs to use, we
can now run this file doing
10:27 - period forward slash shell
test.sh. But we will see that
10:32 - permission is denied and we need
to give the file permission to
10:35 - be executed. This is because in
Linux, we need to give files
10:39 - permission to act as an
executable file. Let's have a
10:42 - look at this when we type in LS
minus l, which is a long format
10:47 - of the ls command, which is
another type of argument we call
10:51 - a flag. So the minus L here is
called a flag we give as an
10:55 - argument to the ls command,
we're actually asking the ls
10:59 - command to provide the long
format, which will display some
11:03 - more information about the files
and directories, we can see in
11:07 - our permissions that we do not
have executable permissions yet,
11:10 - if you want to learn more about
the basics of file permissions,
11:13 - you should look at my Linux for
beginners tutorial.
11:17 - Let's give our file executable
permissions by typing in ch, mo
11:21 - D or smart u plus x space shell
test.sh. We want to provide u
11:29 - plus x because this will give
only the owner user permission
11:32 - to execute the file rather than
the entire group or anybody on
11:36 - the system.
11:37 - It's good to have this
discipline baked into your head,
11:40 - although on a development
environment, it doesn't really
11:42 - matter very much.
11:44 - Okay, now we can finally run our
shell script by typing in period
11:48 - forward slash shell test.sh. And
we will see the output on the
11:53 - terminal. Now that we finally
have the basics out of the way,
11:56 - we can actually start writing
some bash scripts.
12:02 - To understand a little bit
better what variables do in
12:04 - bash, have a look at this
script. So in this script, you
12:08 - have a classic example of a copy
command where we copy something
12:12 - from to a location underneath
that we have the same location
12:17 - paths twice typed out
completely. Now, this is
12:21 - something that you want to avoid
as much as you can. Underneath
12:24 - that we have a better option
where we actually define a
12:29 - location path in a variable
called my location from now this
12:33 - is quite a long variable name,
you could actually just define
12:36 - something like loc underscore
from, which would be better
12:41 - to make it a little bit shorter.
But it's just you know, it's
12:43 - just for demonstration purposes
how this would work. So you
12:46 - could understand if you would
have a very long path here, we
12:48 - could have that very long file
location stored in a variable.
12:52 - And then you could actually
reuse that variable over and
12:55 - over again, like we did in the
example below with that. So
12:58 - let's now have a look at how we
can actually use this in an
13:01 - example. So we can either type
our name like this first name
13:05 - equals, let's say Herbert. And
that's how we can actually use
13:09 - these variables by typing like
Echo Hello, and then typing the
13:13 - variable like so. So that's how
it would work like in line or in
13:18 - the command line itself. But we
could actually also just write a
13:20 - script to demonstrate a little
bit better how variables work.
13:26 - So just type in Vim, hello,
there.sh.
13:32 - And then we'll do the insert
mode with the shebang forward
13:35 - slash bin forward slash bash.
And then over here, we'll define
13:39 - our first name equals pervert or
you know your name. And then
13:44 - last name, equals lindemans,
which is my last name. And that
13:50 - will just do like this echo.
Hello, dollar sign first name.
13:57 - And then we'll do dollar sign
last name.
14:02 - And then we'll exits with wq.
And now, the only thing we need
14:06 - to do is Srimad u plus x. Hello
there.sh. And now we can run it.
14:13 - And now we can see that our name
is printed out here. Just like
14:18 - that.
14:20 - So now we actually type this
statically. But we can actually
14:23 - also ask the user for input,
like so. So let's open a new
14:27 - shell script with Vim.
Interactive shell.sh will do the
14:33 - same insert, they'll do the
shebang bin bash. And first of
14:39 - all, we'll need to ask the user
like, What is your name? So what
14:44 - is your name? What is your first
name? Let's ask. And then we'll
14:47 - do a read statement. I will read
the first name. I will do the
14:51 - same with what is your last name
14:54 - and I will read last name and I
will echo Hello
15:00 - Oh,
15:01 - dollar sign first name,
15:04 - space dollar sign last name.
15:10 - And then we'll write and quit.
15:14 - And then we'll do the classic
smart u plus x. And then
15:18 - interactive shell.sh. I will run
it and now it's going to prompt
15:22 - us for our first name, or last
name, and then it will just
15:26 - print out our first and last
name back. So
15:31 - we could have the terminal
display our own name, or
15:33 - anything else provided in a
positional argument as well. But
15:36 - first, what is a positional
argument? A positional argument
15:40 - is exactly what it sounds like,
we place the argument at a
15:43 - certain position behind the
command or script we want to
15:46 - run. The positional argument can
be in position, 123, and so
15:51 - forth. The positions are always
separated by a space. When
15:55 - working with positional
arguments, you expect arguments
15:58 - to be in a certain position that
is separated by a space and
16:01 - counting from one position zero
is reserved for the shell
16:04 - itself.
16:06 - Now let's have a look at one of
these positional arguments.
16:09 - Create a new script by typing
vim pulse ru.sh. And enter the
16:14 - insert mode again, we will have
the script taking our first and
16:18 - last name and position one and
two and have it take these words
16:21 - as positional arguments. Let's
just write our shebang and write
16:25 - our one line of code like so.
16:28 - shebang, Bin bash, Echo, hello.
Dollar sign $1 sign two. Now
16:35 - save the file and close Vim,
change our permissions. And
16:39 - let's run the script again with
the positional arguments dot
16:42 - forward slash POS argue that sh,
herbert lindemans, or whatever
16:47 - your name is here. And as you
can see, we get the same output
16:50 - here with only one line of code.
16:54 - One of the most frequently used
features in Bash is piping, it
16:58 - makes it very easy to perform a
specific action on the output of
17:02 - the command. Let's say the
output of a command is very long
17:06 - and you wish to filter something
out. Piping is going to give you
17:09 - that option. Now how does piping
work? Let's have a look at an
17:14 - example.
17:15 - Let's say we want to look at a
specific directory. But we just
17:19 - want to filter out certain files
or subdirectories. We could for
17:23 - example, use a command like
this. So we type in LS minus L
17:28 - forward slash our directory. In
this case, we're using the bin
17:31 - directory at forward slash user
forward slash bin and then space
17:36 - and then we type the piping
symbol SPACE grep, which is
17:41 - something that we use to filter
out specific words and then we
17:44 - type in bash. And we'll see the
output is just the bash binaries
17:51 - that we can see here. Rather
than the entire bin directory.
17:54 - In this command, we forward the
output of the ls command into
17:58 - the next command with the pipe
symbol. This symbol represents a
18:02 - pipe and this is what we call
piping. We literally sent the
18:05 - output from a command before the
pipe symbol to the command
18:08 - behind the pipe symbol. grep is
just an example there are many
18:12 - more commands that have very
powerful potential when used
18:15 - with piping.
18:18 - When sending output to a file,
we have to use different kinds
18:22 - of symbols than the pipe symbol.
Instead, we use the greater than
18:26 - and double greater than symbols.
These symbols will be used to
18:30 - send the output from a command
to a file. This can have many
18:34 - potential use cases, the first
thing that comes to mind is
18:37 - logging something from your
script to a log file. And this
18:40 - is something that you'll
definitely use in real life
18:42 - scenarios. Let's see how we can
use these symbols. First, we
18:45 - catch the output of a simple
echo command. Start by typing in
18:49 - Echo hello world greater than
hello dot exe. This prints hello
18:55 - world into a file called hello
dot txt. Notice that we put the
18:59 - command before the greater than
symbol and the name of the text
19:02 - file after the greater than
symbol. Now we can see if this
19:05 - work by typing in cat hello dot
txt and we should see the output
19:09 - of the echo command in here. Now
let's try something different
19:12 - here typing echo Good day to
you. Greater than hello dot txt.
19:18 - And let's see what's the hello
dot txt file by typing in cat
19:22 - hello dot txt. But what is this,
the file was overwritten. We
19:27 - don't have our hello world
anymore. This is because the
19:30 - greater than symbol always
overwrites any existing file.
19:35 - What we need to have is a proper
way to append text rather than
19:38 - overwrite it. This is where the
double greater than symbol comes
19:42 - in. This will append any output
to our destination file rather
19:46 - than overwrite it. Let's try it
out. But first let's remove that
19:50 - original file with RM space
hello dot txt. Then we use Echo
19:55 - hello world double greater than
symbol hello dot txt
20:00 - We check if the contents are
indeed correct with cat hello
20:03 - dot exe. And indeed, the text is
there. And once we verified
20:09 - this, we sent another output to
the file using the double
20:12 - greater than symbol and type in
Echo Good day to you double
20:17 - greater than hello dot exe. And
we once again verify this output
20:22 - with cat hello dot exe. And we
should see both outputs here.
20:27 - Now imagine using this in
combination with timestamps to
20:30 - see which command ran at which
time and also some error
20:33 - handling. We're starting to
collect the tools we need to
20:37 - write real script, we can also
feed input into a command by
20:41 - reversing the greater than
symbol, we can use the lesser
20:45 - than double lesser than or even
triple lesser than symbol to get
20:49 - input from a file, multiple
lines of text or a single string
20:53 - of text. Let's first look at the
lesser than operator, which will
20:59 - get input from a txt file. We
will use the word count command
21:03 - as an example here, because it's
one of those commands that has a
21:05 - use case for these types of
operators. Let's type in WC
21:10 - minus w hello dot exe to get the
word count. But what happens
21:15 - here, we get a little more than
we asked for as an output. The
21:19 - wc command, by default also
shows the filename, which is not
21:23 - what we want. If we just want to
get the number of words, we need
21:27 - to feed the wc command and input
from the file with the lesser
21:31 - than operator rather than the
file itself as a positional
21:35 - argument. This can be done like
so WC minus w space lesser than
21:41 - space hello dot txt, and this
way, we will redirect the file
21:45 - to the wc command. Rather than
passing it as a positional
21:49 - argument to the command, we will
now get to the second way of
21:52 - feeding data to a command with
the double lesser than operator.
21:56 - This is a great way to supply
multiple lines of text to a
21:59 - command. When we write the
double lesser than operator, we
22:03 - will immediately follow it up
with a word that will open and
22:06 - close the text we want to input.
Basically, we tell the command
22:10 - line Hey, wait for this word,
and then capture everything I
22:14 - wrote in between the first and
second occurrence. Often people
22:18 - will write e o f, but you can
write whatever you want. Let's
22:22 - have a look at how this would
work. So we type in cat space,
22:27 - double lesser than symbol elf.
Now we see that the command line
22:31 - waits for input. So we can keep
writing lines of text here. And
22:35 - let's write some text creating a
new line with the enter key
22:38 - we'll type in I will enter write
some enter text here, enter. And
22:45 - now we close it with the first
word we supply it and we type
22:48 - again e o f. And now we should
see the text that we wrote here
22:52 - between the two e o f
statements. Now last but not
22:56 - least, we can also supply single
strings of text to the command
22:59 - line. This will be done with you
guessed it the triple lesser
23:03 - than operator. Let's have a look
at another example of the wc
23:07 - command we use. By default, wc
will either read a file or a
23:12 - command output, but not actual
strings supplied as positional
23:16 - arguments. We should feed the
command either an entire file or
23:20 - the output of a file with one of
the lesser than operator
23:23 - variations. Let's see how we can
provide a string to this wc
23:27 - command. So we typing w c minus
w again, space, triple lesser
23:33 - than symbol, and then we open
with double quotes Hello, their
23:37 - word count. And then we close
again with double quotes and we
23:41 - should see the word count
printed here in the terminal.
23:44 - This is how we can feed a string
into a command and take note
23:47 - that the string needs to be in
between double quotes otherwise
23:50 - it will not work.
23:54 - In bash, we have a built in
command called test that will
23:57 - take in a couple of arguments
and show you if the expression
24:00 - is true or not. For example, we
can ask a terminal to show us
24:04 - whether or not a string of text
is equal to another. We can
24:07 - write test followed by the
expression, but I prefer using
24:11 - square brackets. Let's see how
that's done. So we just write
24:15 - open square brackets space. And
this is important because you
24:19 - need the space in between Hello
space, equal sign space again
24:24 - Hello, followed by another space
and enclosing the square
24:27 - brackets. And this will show no
output but when we do echo
24:31 - dollar sign question mark. We
should see output zero here
24:35 - because the first string of text
is equal to the second and that
24:39 - will give us a return value of
$0 sign question mark returns
24:43 - the value of the exit code or
the last executed command. We
24:46 - will learn more about exit codes
later. For now it's enough to
24:49 - know that exit code zero means
that the command was executed
24:52 - without any issues. Another
example of this would be
24:56 - comparing numbers with each
other. For example, again
25:00 - We open the square brackets
space one equals zero space, we
25:05 - close the square brackets, and
then we do echo dollar sign
25:08 - question mark. And this shows us
that the values are not the same
25:12 - because we get a return code
one. But we could also use a
25:15 - different operator here to make
sure that the values are
25:18 - actually numerical. We could use
the minus EQ operator for this.
25:23 - And we do this with opening
square brackets, one minus EQ,
25:28 - one closing square brackets,
Echo dollar sign question mark.
25:33 - This also shows us the same
return value exit code zero,
25:37 - which means that the values do
equate, though this will throw
25:40 - an error if you would use
alphabetical characters instead
25:42 - of numerical ones.
25:46 - Now for some more powerful
stuff, we can actually use these
25:50 - test expressions and perform an
action on it. Let's have a look
25:53 - at this more closely with an
actual script. Let's create a
25:57 - login script which will not
really log us in but it will
26:00 - show us what is possible with
these if Elif else statements.
26:05 - Create a new script called if
Elif else.sh.
26:13 - Type in the shebang.
26:17 - Do F open the square brackets,
dollar sign, open curly braces,
26:23 - one comma comma close curly
braces and I'll explain to you
26:27 - what this means in just a second
equals your username, close the
26:32 - square brackets, semicolon,
then, and then we follow up what
26:37 - we actually want to do here. So
we want to echo Oh, you're the
26:42 - boss here. Welcome.
26:45 - Then start a new line. lf open
square brackets again, dollar
26:51 - sign, curly braces, one comma
comma curly braces equals help.
26:56 - Close the square brackets,
semicolon, then echo, just enter
27:02 - your user name data. Else. Echo.
I don't know who you are, but
27:07 - you're not the boss of me. And
then close it with FY. Now let
27:11 - me explain to you what we did
here. So this script will take
27:15 - in a positional argument, which
is a great way to test how the
27:18 - if statements will work.
27:21 - We start our if statements with
an F followed by the test
27:25 - expression. Take note of the
square brackets used in previous
27:28 - section, we test if the first
positional argument is equal to
27:32 - the value we provide. Take note
of the double comma and the
27:35 - curly braces. This is called a
parameter expansion. And it will
27:39 - allow us to ignore upper and
lower cases when comparing the
27:42 - two values. We then end the test
operator with a semicolon. And
27:46 - we'll follow it up by then. And
then beginning a new line. And
27:51 - on this line, we type what we
actually want to do with set
27:53 - test expression. In this case,
we just print something out to
27:57 - the console telling the user the
script has recognized the user
28:01 - name and that he is indeed the
boss of the system. We can also
28:05 - have a script check for multiple
test expressions. We can define
28:09 - this with an elif statement.
This stands for else if being
28:13 - that else if the previous
statement wasn't true test if
28:17 - this is true. Again, start a new
line. We defined a test
28:21 - expression that will test if the
positional argument is help. And
28:24 - if it is, we display a message
that shows us instructions on
28:28 - how to use the script. Being an
easy script we want to state
28:31 - that it isn't so hard to use.
Maybe a little rude, but it's
28:35 - all in good fun. Then if none of
these statements are true,
28:39 - finally we have the else
statement. This will perform an
28:43 - action if none of the if or Elif
statements are true. We can
28:47 - display a message saying that
the user name was not detected
28:50 - and that the system will not be
bossed around by someone that
28:53 - does not have the correct
username.
28:56 - Finally, to close our if
statements we ended with FYI.
29:00 - This closes the entire block of
if Elif else statements and is
29:04 - required.
29:09 - If Elif else statements are
useful, but you won't use them
29:13 - very often if you want to check
for multiple values. For these
29:17 - kinds of things. We use case
statements. First of all, what
29:21 - is a case statement? Well, a
case statement performs
29:25 - different actions depending on
which case is true. This means
29:30 - that we can define multiple
options, and if the option
29:33 - matches the case, we will
perform an action bound to that
29:36 - option. Let's have a look at how
this works in a real script.
29:41 - Let's try to recreate our
previous exercise with a case
29:44 - statement instead of the if Elif
else statements, create a new
29:49 - file with vim login.sh and type
in the shebang. And then we
29:54 - start our case statement by
typing in case space. Dollar
29:58 - sign and then
30:00 - ie variable expansion with the
curly brackets, one comma,
30:04 - comma, space in and over here,
we're going to do something
30:08 - special, we're going to define
multiple options. Now this is
30:11 - something that you could also do
with if statements. But I'm just
30:14 - introducing it here with the
case statements. Since I thought
30:17 - it would be interesting to see
how it works. So we type in our
30:20 - username, space, and then the
pipe symbol. And over here, this
30:24 - is actually like a separator for
multiple options, rather than
30:28 - the pipe symbol that we saw
earlier, to pipe things through
30:33 - two different commands. In a
case statement, it serves a
30:36 - different function over here, it
serves as a separator for
30:40 - multiple options. So user name,
space, pipe, symbol, space, and
30:45 - then another user name, for
example, the administrator, and
30:49 - then we close the bracket. And
then we define what we want to
30:54 - say or do here. So you want to
say something like, Oh, you're
30:58 - the boss here, welcome, again,
like we did in the previous
31:02 - exercise, and then we close this
option with double semicolons.
31:08 - Then we define another option
here, for example, help like we
31:11 - did in the previous exercise
will copy the same echo command
31:16 - that we close that option with
double semi colons. And then
31:20 - what we do here is we define
this star symbol or asterisk or
31:24 - whatever you want to call it.
This is the catch all option
31:28 - that we're going to define. And
the catch all option is like the
31:31 - default option, when none of the
options are true, or when no
31:36 - options are given. And then we
define Hello there, but you're
31:39 - not the boss of me, please enter
a valid username, then we close
31:43 - that option with double
semicolons. And then close that
31:47 - with E sec. So it's case just
reversed. So again, like I said
31:52 - before, notice that we have two
options in one line using the
31:56 - pipe symbol, again, and when we
use the pipe symbol in one of
31:59 - the case statement options, we
can use it to have multiple
32:02 - values to test for, we define
our option for help. also define
32:07 - a catch all or default option.
And this is equal to like the
32:10 - else statement like we saw
earlier, meaning that if none of
32:13 - the options are equal to the
input, we will perform a
32:16 - specific action and now we can
run our scripts and get the
32:19 - results that we expect.
32:48 - Before we get into looping, we
need to first extend our
32:51 - knowledge about variables, we
can actually assign multiple
32:54 - values to one variable collected
in a list. We call these kinds
32:59 - of variable lists arrays. Let's
see how we can actually create
33:03 - this in the command line. In the
command line type my first list
33:08 - equals open brackets one, space
two, space three, space four,
33:15 - space five, close the brackets.
Take note of how we start the
33:19 - array with open brackets, use a
space as a separator for each
33:23 - item, and close the array with
the closing bracket. Now let's
33:27 - see what the output is when we
try to print this array. Just
33:30 - type in Echo, and then just like
we would with any other
33:34 - variable, space, dollar sign my
first list and now we will see
33:40 - that the output is just the
first element. And this is of
33:43 - course not what we want. To echo
the entire list, we need to
33:46 - specify it like this echo,
dollar sign, open curly braces,
33:52 - my first list square brackets,
apt symbol, closing square
33:58 - brackets, close the curly
braces, and this will print out
34:01 - everything in the list. But we
can also define which item we
34:05 - want to print like this echo
space, dollar sign curly braces,
34:11 - my first list square brackets,
and then over here we'll just
34:15 - type in zero, which is the
index, close the square brackets
34:19 - close the curly braces, and this
will print out the first item in
34:23 - the array because we define the
index in between the square
34:27 - brackets. And because in bash,
the first item in the array
34:30 - always has index zero counting
upwards we will see the first
34:34 - item in the array. But let's say
we want to do something else
34:37 - with all these items in the
array. We can do this with a for
34:40 - loop.
34:44 - Now that we have created our
array, we want to loop over the
34:46 - items in it and do something
using a for loop. In our
34:50 - example, we will count the
length of each word in the array
34:54 - by piping the item output using
echo to the wc command
34:59 - don't
35:00 - Get to specify the minus n flag
in our echo command, because
35:03 - otherwise it will also count the
newline characters.
35:07 - type in the command line for
space, item space in dollar sign
35:14 - curly braces, my first list,
square brackets at square
35:18 - brackets, curly braces, semi
colon space, do space, echo
35:24 - space minus n space, dollar sign
item, space pipe symbol SPACE,
35:31 - wc space minus c semi colon
space done.
35:36 - Take note of how we write the
for loop here, we first define
35:40 - the variable item, which will
represent each item in the array
35:44 - during the loop. Then we define
the iterable, which is our
35:48 - array. And what shall we
actually define it in our for
35:51 - loop, we encapsulate it in our
curly brackets and add the
35:55 - square brackets, add square
brackets after it to make sure
35:58 - we loop over the entire array.
Then we follow it up with a semi
36:03 - colon space, then we type in do
and then we type in what we
36:07 - actually want to perform here.
So we'll type in do echo minus
36:12 - n. As I said the minus n is just
a flag for the echo command to
36:15 - ignore all the newline
characters and then space dollar
36:18 - sign item, because the dollar
sign item will represent one of
36:22 - the items that we are currently
looping over space and then the
36:26 - pipe symbol, WC minus c. And
then we do again semicolon, and
36:31 - then we'd have been done.
36:35 - To understand why we need
functions in a bash script, we
36:37 - should first consider this. In
some scenarios, we have a lot of
36:41 - repeated code, we might want to
do a specific set of commands in
36:45 - a certain order. Or we want to
run that through a set of if
36:48 - else statements multiple times.
For these scenarios, we create
36:53 - functions. These functions are
like little programs within your
36:56 - script that you can run from
within your script. It makes it
37:00 - so that you can make your code
reusable very powerful stuff.
37:04 - Because we can save so much time
and lines of code. Let's write
37:08 - our first function in bash.
Let's open up a new file called
37:11 - first function that sh i will
type in the shebang and then a
37:16 - new line we'll type in the name
of the function and we'll just
37:18 - call this show uptime. And then
we open and close the brackets.
37:23 - And then we open the curly
brackets will type in up equals
37:27 - dollar sign open brackets up
time minus p pipe cut minus C
37:31 - for minus and then to close the
brackets. We'll type in since
37:36 - equals dollar sign open brackets
uptime minus s, close the
37:40 - brackets and again, if I'm going
a little bit too fast for you,
37:42 - you can pause the video and I'm
gonna go over what we actually
37:46 - did here, I'm going to dissect
everything we did here in just a
37:49 - second. But then a new line
again cat and then we'll use the
37:53 - double lesser than symbol elf, I
will type a new line I will just
37:57 - create something pretty here. A
few dashes, I will type in this
38:02 - machine has been up for dollar
sign curly braces up curly
38:05 - braces, it has been running
since dollar sign curly brackets
38:10 - since curly braces that a new
line of then we do a new line of
38:14 - dashes. Then we end our
statement with elf, close the
38:18 - curly brackets and then we just
type in show uptime. So let's
38:21 - dissect this again. First, we
define the name of the function
38:26 - followed by open and close
brackets followed by the curly
38:29 - brackets. To define what our
function does, we enter all the
38:32 - things that needs to do in
between the curly brackets. In
38:35 - our case, we will show the
uptime of the machine. Watch how
38:38 - he catched the output of a
command into a variable using
38:40 - the dollar sign in brackets
notation, then we do this again
38:43 - in the next variable. We defined
a variable in the same way. But
38:47 - we use different flags for the
uptime command and store that
38:50 - output in the since variable and
we can now create a nice output
38:53 - using these variables using the
cat command and the redirection
38:57 - we learned earlier in the course
we end by closing the curly
39:00 - brackets, and then we call the
function by just typing it
39:02 - anywhere in the script. As long
as it's typed under the function
39:06 - it's fine, because we need to
make sure that the function
39:08 - first is defined.
39:25 - When we define a variable in our
function, it's available to the
39:28 - entire script by default, this
might seem okay, but it can
39:32 - actually cause trouble when you
write bigger scripts. We want to
39:36 - define the variables inside our
functions as local variables so
39:39 - that they are only available to
our function and not to the
39:41 - entire script. This way, we will
avoid accidentally overwriting
39:45 - global variables, which might
cause issues when we are using
39:49 - functions that share these
variable names. Let's have a
39:52 - look at what happens when we
don't use local variables. So
39:56 - let's define our variables named
up equals
40:00 - Before since equals function,
and then we'll just print those
40:04 - out before we define the
function. So we'll just echo up
40:07 - and echo since. And then now we
will define the show uptime
40:11 - function. Again, we will leave
it the way it is, and then echo
40:15 - up an echo since, and let's run
it and in this example, we can
40:19 - see that the variables are
indeed globally available, which
40:22 - is not what we wanted. We'll see
also that they are globally
40:25 - available, but we have actually
overwritten the variables that
40:28 - were defined before the
function. And then the function
40:31 - was actually reassigning those
variables because they are not
40:35 - assigned as local variables.
Let's fix that. So the only
40:38 - thing we need to do to fix it
really is just add local before
40:42 - we define the variable in our
function, so instead of just
40:46 - writing up, and since equals the
commands that we want to use,
40:51 - before the up, we'll just enter
local space. And then the same
40:56 - goes for since we'll define
local space. And when we run
40:59 - this, we can now see that our
variables are available to the
41:02 - scope of our function, but the
global variable is not
41:06 - overwritten.
41:08 - Just like our entire bash script
can have a positional argument.
41:11 - So can our function, let's have
a look at an example. Create a
41:15 - new script called function pass
argue.sh. And we'll write the
41:20 - shebang. And that will open our
function with the function name,
41:26 - open the brackets, open the
curly brackets, and then we'll
41:29 - write echo Hello, dollar sign
one.
41:34 - And then close the curly
brackets. And then we'll write
41:36 - the function name space. And
then whatever you want to write
41:39 - here, we'll write our own name.
So we can write out whatever set
41:42 - of characters we want. But in
this case, we wrote our own
41:45 - name, we could even go as far as
to pass positional arguments of
41:49 - the entire script to the
position or argument of the
41:52 - function. And of course,
functions can also take multiple
41:56 - positional arguments. So lots of
stuff is possible here.
42:02 - Let's open up the previous file.
Underneath the echo statement,
42:05 - we'll type an if statement. And
then we'll say if dollar sign
42:09 - curly braces, one comma, comma
equals and then your user name,
42:14 - which in my case is Herbert to
close the brackets semicolon,
42:17 - then return zero, else, we will
return one. And that will close
42:23 - the if statement. Then also over
here, we'll remove this static
42:27 - name and change it to a
positional argument one, and
42:29 - that also, if dollar sign
question mark equals one, then
42:34 - close square brackets,
semicolon, then echo and then it
42:38 - will write someone unknown
called the function and then
42:42 - we'll close the if statements or
write and quit. And let's now
42:46 - try to run this with tests. For
example. It'll say hello test,
42:52 - but then you'll see that it also
says that someone unknown
42:56 - requested the function.
43:01 - Aw K is one of the most useful
tools in the bash arsenal, we
43:05 - use aw K to filter file
contents, or the output of a
43:09 - command in such a way that we
can print out the most essential
43:12 - parts and get the output the way
we like it. So use aw K, we can
43:16 - either filter parts of a file,
or we can filter parts of a
43:19 - command output by piping that
output into a Wk let's have a
43:23 - look at how we can filter
through a simple text file with
43:26 - a Wk we first create a test file
which contains three words
43:30 - separated by a space once we
created that file, we can put a
43:34 - Wk to work type in a Wk single
quote, open the curly brackets
43:39 - print dollar sign one, close
curly brackets, single quotes
43:43 - space the name of our test file,
we will see that the dollar sign
43:46 - one acts as a placeholder. For
the first item in the text file.
43:50 - We could also get the second
word that comes after the first
43:52 - word always separated by space
by typing in a Wk single quotes
43:58 - curly braces, print dollar sign
to close curly braces single
44:02 - quote and again our test file
now that we get the idea of aw K
44:05 - in its default mode, which is
using a space character as a
44:09 - separator, we can move on to
changing it into other
44:11 - characters such as a car, let's
create a CSV file and add three
44:15 - values in it again separated by
a comma this time now we can use
44:18 - a Wk again to split the values
in the CSV file by adding the
44:22 - minus capital F flag and
specifying the split character
44:26 - afterwards like this aw k minus
capital F comma space open the
44:32 - single quotes open the curly
braces print dollar sign one
44:36 - close the curly braces single
quote test CSV dot CSV and now
44:40 - we will see that the output is
also the same as in our previous
44:44 - examples, but we will see that
aw K actually used the comma as
44:48 - a separator character. And last
but not least, we can also pipe
44:51 - commands into a Wk like so type
in Echo just get this word colon
44:57 - hello and then we pipe into a Wk
I will
45:00 - print out number five, because
this is the fifth word separated
45:04 - by a space and then we'll see
that the word hello will be
45:07 - printed out. Or we can also
split this at the colon symbol
45:10 - like so. Echo, just get this
word colon Hello, pipe into a
45:16 - WK. And then we specify the
minus f, we follow it up with a
45:19 - colon and then print dollar sign
to and that will still have to
45:22 - cut out the first character
which is a space and that will
45:25 - get the same results as well.
And that's just the beginning.
45:27 - Of course, there's a lot more
possible with a WK. So if you
45:31 - want to practice you can try
using it more often in your
45:33 - scripts. It really pays off to
know this well because you'll do
45:37 - a lot of output filtering and
reformatting in bash.
45:43 - There will come a time where you
want to change certain values in
45:46 - text files, and that's where sed
or set comes in. Set is a
45:51 - command line tool that will
allow you to modify values in a
45:54 - txt file using regular
expressions. Let's have a look
45:58 - at an example on how to use as
Edie are set to replace values
46:03 - in a text file. Create a text
file called Set test dot txt and
46:07 - let's write down some text here.
Now we will replace the word fly
46:11 - with grasshopper just for
demonstration purposes. So we
46:14 - type in set single quotes s
forward slash fly forward slash
46:20 - grasshopper forward slash G
single quotes and then the name
46:24 - of our txt file, which is set
test dot txt. Now the structure
46:28 - of this command is a little bit
daunting, but let's break it
46:31 - down. First, we start off with
the set command, we open the
46:35 - single quotes and start our
regular expression. First we
46:38 - enter the mode we want to use,
which is as for substitute,
46:42 - meaning we want to substitute
the next word behind the forward
46:46 - slash with the word after the
second forward slash, which is
46:50 - the first one is fly. And then
the second one is grasshopper
46:53 - that after the last, we provide
the G which means that we want
46:57 - to do this globally. G stands
for globally and globally means
47:01 - that we want to do this across
the entire text file, which
47:03 - means that we want to change
every occurrence, we close it
47:06 - with another single quote and we
put the text file we want to
47:10 - change behind the entire
command. Let's say we want to
47:13 - keep the original in a backup
file. We can do this by adding
47:16 - the minus II flag to the command
like so. So we just do the same
47:20 - thing we just do set minus i dot
original and then we enter the
47:24 - exact same command we just
provided earlier, we can see
47:27 - here that we use the minus II
flag, but we don't put a space
47:30 - behind it. Instead, we write the
entire suffix behind the minus
47:34 - II flag. This will create a
backup file which contains the
47:37 - original content of the file we
just changed with the set
47:40 - command but the original file
will have the changes we desired
47:44 - just like with aw k this is a
basic introduction to set and
47:48 - there will be so much more to it
but as with all things in it,
47:51 - you need to discover this by
yourself by trying it out as
47:53 - much as you can. Well this
brings us to the end of the
47:56 - course